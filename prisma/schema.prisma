generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
}

model User {
  id                String     @id @default(cuid())
  email             String     @unique
  password          String?
  firstName         String
  lastName          String
  phone             String?    @unique
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  lastLogin         DateTime?
  status            UserStatus @default(PENDING_PHONE_VERIFICATION)
  role              UserRole   @default(CANDIDATE)
  isVerified        Boolean    @default(false)
  isPhoneVerified   Boolean    @default(false)
  isProfileComplete Boolean    @default(false)

  source                    UserSource @default(REGISTRATION) // New field
  addedByMatchmakerId       String? // Optional: ID of matchmaker who added this manual user
  matchmakerWhoAdded        User?      @relation("ManuallyAddedBy", fields: [addedByMatchmakerId], references: [id]) // New relation
  termsAndPrivacyAcceptedAt DateTime? // ××ª×™ ×”××©×ª××© ××™×©×¨ ××ª ×”×ª× ××™× ×•××“×™× ×™×•×ª ×”×¤×¨×˜×™×•×ª
  engagementEmailsConsent     Boolean    @default(false) // ×”×¡×›××” ×œ××™×™×œ×™ ××¢×•×¨×‘×•×ª (×˜×™×¤×™×, ×¤×™×“×‘×§, ×ª×–×›×•×¨×•×ª)
  promotionalEmailsConsent    Boolean    @default(false) // ×”×¡×›××” ×œ××™×™×œ×™× ×©×™×•×•×§×™×™× (××‘×¦×¢×™×, ××™×¨×•×¢×™×)
  language                  Language   @default(he) 
  firstPartyInquiries             AvailabilityInquiry[]   @relation("FirstPartyInquiries")
  matchmakerAvailabilityInquiries AvailabilityInquiry[]   @relation("MatchmakerInquiries")
  secondPartyInquiries            AvailabilityInquiry[]   @relation("SecondPartyInquiries")
  givenFeedback                   DateFeedback[]          @relation("UserFeedback")
  sentInvitations                 Invitation[]            @relation("MatchmakerInvitations")
  receivedInvitation              Invitation?             @relation("ReceivedInvitation")
  firstPartySuggestions           MatchSuggestion[]       @relation("FirstPartySuggestions")
  createdSuggestions              MatchSuggestion[]       @relation("MatchmakerSuggestions")
  accounts                        Account[]
  sessions                        Session[]
  secondPartySuggestions          MatchSuggestion[]       @relation("SecondPartySuggestions")
  profile                         Profile?
  verifiedUsers                   Profile[]               @relation("VerifiedByMatchmaker")
  questionnaireResponses          QuestionnaireResponse[]
  sentSuggestionInquiries         SuggestionInquiry[]     @relation("SentSuggestionInquiries")
  receivedSuggestionInquiries     SuggestionInquiry[]     @relation("ReceivedSuggestionInquiries")
  images                          UserImage[]
  verifications                   Verification[]
  videos                          Video[]
  approvedSuggestions             MatchSuggestion[]       @relation("ApprovedSuggestions")
  reviewedSuggestions             MatchSuggestion[]       @relation("ReviewedSuggestions")
  oneTimeAuthTokens               OneTimeAuthToken[]
  manuallyAddedCandidates         User[]                  @relation("ManuallyAddedBy") // New relation back to matchmaker
  feedbacks                       Feedback[]
  dripCampaign              UserDripCampaign?
lastOnboardingEmailSent DateTime? // ××ª×™ ×©×œ×—× ×• ××™×™×œ onboarding ××—×¨×•×Ÿ
  onboardingCompleted     Boolean   @default(false) // ×¡×™×™× ××ª ×”-onboarding?
neshamaInsightLastGeneratedAt   DateTime?     
  neshamaInsightGeneratedCount    Int       @default(0)  // ğŸ‘ˆ ×”×•×¡×£ ×©×“×” ×–×”
referral    Referral?  @relation("ReferredUser")
  targetUserSearches    SavedMatchSearch[]  @relation("TargetUserSearches")
  matchmakerSearches    SavedMatchSearch[]  @relation("MatchmakerSearches")
targetUserVectorSearches    SavedVectorMatchSearch[]  @relation("TargetUserVectorSearches")
matchmakerVectorSearches    SavedVectorMatchSearch[]  @relation("MatchmakerVectorSearches")
virtualProfiles       VirtualProfile[]    @relation("MatchmakerVirtualProfiles")
  @@index([email])
  @@index([role])
  @@index([status])
  @@index([source]) // Index the new field
  @@index([addedByMatchmakerId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model OneTimeAuthToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×

  @@index([userId])
}

model Verification {
  id          String             @id @default(cuid())
  userId      String?
  type        VerificationType
  token       String
  target      String?
  expiresAt   DateTime
  status      VerificationStatus @default(PENDING)
  attempts    Int                @default(0)
  metadata    Json?
  createdAt   DateTime           @default(now())
  completedAt DateTime?
  user        User?              @relation(fields: [userId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™

  @@index([userId, type, status])
  @@index([target, type, status])
  @@index([token, type, status])
}

// model Profile in your schema.prisma

model Profile {
  id                     String   @id @default(cuid())
  userId                 String   @unique
  gender                 Gender
  birthDate              DateTime
  birthDateIsApproximate Boolean? @default(false) // <--- ×”×•×¡×£ ×©×“×” ×–×”

  nativeLanguage          String?
  additionalLanguages     String[]
  height                  Int?
  maritalStatus           String? // Marital status of the user
  occupation              String?
  education               String?
  educationLevel          String?
  city                    String?
  origin                  String? // Origin of the user
  religiousLevel          String? // Religious level of the user
  religiousJourney        ReligiousJourney? // <--- ×”×•×¡×¤×ª ×”×©×“×” ×”×—×“×©
  testimonialRequests     TestimonialRequest[] // <-- ADD THIS LINE
  shomerNegiah            Boolean?
  serviceType             ServiceType? // Service type of the user
  serviceDetails          String?
  manualEntryText         String?
  headCovering            HeadCoveringType?
  kippahType              KippahType?
  hasChildrenFromPrevious Boolean?          @default(false)
  profileCharacterTraits  String[]          @default([]) // User's own traits
  profileHobbies          String[]          @default([]) // User's own hobbies
  aliyaCountry            String?
  aliyaYear               Int?
  about                   String?
  isAboutVisible Boolean? @default(true)
  testimonials          FriendTestimonial[]
isFriendsSectionVisible Boolean? @default(true)
isNeshamaTechSummaryVisible Boolean? @default(true)
    profileHeadline       String? // ×›×•×ª×¨×ª ××™×©×™×ª ×œ×¤×¨×•×¤×™×œ
  inspiringCoupleStory  String? // ×¡×™×¤×•×¨ ×¢×œ ×–×•×’ ××¢×•×¨×¨ ×”×©×¨××”
  influentialRabbi      String? // ×“××•×ª ×¨×‘× ×™×ª/×¨×•×—× ×™×ª ××©×¤×™×¢×”
  parentStatus            String?
  fatherOccupation        String? // ××§×¦×•×¢ ×”××‘
  motherOccupation        String? // ××§×¦×•×¢ ×”××
  siblings                Int?
  position                Int?
 hasMedicalInfo              Boolean?
  medicalInfoDetails          String?
  medicalInfoDisclosureTiming String? // ×œ×“×•×’××”: 'FROM_THE_START', 'WHEN_SERIOUS'
  // ×©×“×” ×–×” ×§×•×‘×¢ ×”×× ×”××™×“×¢ ×”×¨×¤×•××™ ×™×•×¦×’ ×‘×›×¨×˜×™×¡ ×”×¤×¨×•×¤×™×œ ×”× ×©×œ×— ×œ×¦×“ ×”×©× ×™
  isMedicalInfoVisible        Boolean  @default(false)
  // --- Existing Preference Fields ---
  preferredAgeMin                  Int?
  preferredAgeMax                  Int?
  preferredHeightMin               Int?
  preferredHeightMax               Int?
  preferredReligiousLevels         String[] @default([])
  preferredLocations               String[] @default([])
  preferredEducation               String[] @default([]) // Corresponds to educationPreferenceOptions
  preferredOccupations             String[] @default([]) // Corresponds to occupationPreferenceOptions
  contactPreference                String?

  // --- New Preference Fields ---
  preferredMaritalStatuses    String[]           @default([]) // Preferred marital status(es) of the partner
  preferredShomerNegiah       String? // e.g., "yes", "no", "flexible"
  preferredPartnerHasChildren String? // e.g., "yes_ok", "no_preferred", "does_not_matter"
  preferredOrigins            String[]           @default([]) // Preferred origin(s) of the partner
  preferredServiceTypes       ServiceType[]      @default([]) // Preferred service type(s) of the partner
  preferredHeadCoverings      HeadCoveringType[] @default([]) // Preferred head covering(s) if partner is female
  preferredKippahTypes        KippahType[]       @default([]) // Preferred kippah type(s) if partner is male
  preferredCharacterTraits    String[]           @default([]) // Preferred character trait(s) of the partner
  preferredHobbies            String[]           @default([]) // Preferred hobbies of the partner
  preferredAliyaStatus        String? // e.g., "oleh", "tzabar", "no_preference"
preferredReligiousJourneys  ReligiousJourney[] @default([]) 

  isProfileVisible          Boolean            @default(true)
  preferredMatchmakerGender Gender?
  matchingNotes             String? // General notes about the desired match
  internalMatchmakerNotes String?
  verifiedBy                String?
  availabilityStatus        AvailabilityStatus @default(AVAILABLE)
  availabilityNote          String?
  availabilityUpdatedAt     DateTime?
  createdAt                 DateTime           @default(now())
  updatedAt                 DateTime           @updatedAt
  lastActive                DateTime?

  user                    User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  verifiedByMatchmaker    User?          @relation("VerifiedByMatchmaker", fields: [verifiedBy], references: [id], onDelete: SetNull)
  vector                  ProfileVector? // ×”×•×¡×¤×ª ×§×©×¨ ×”×¤×•×š
  hasViewedProfilePreview Boolean        @default(false)
    needsAiProfileUpdate    Boolean    @default(true)
    aiProfileSummary        Json?      
    cvUrl                   String? // URL to the CV file stored in Cloudinary
  cvSummary               String? @db.Text // AI-generated summary of the CV
conversationSummary     String? @db.Text 
}

model ProfileVector {
  profileId String                      @id // This will be the same as the Profile's ID
  vector    Unsupported("vector(768)")? // ×’×•×“×œ ×”×•×•×§×˜×•×¨ ×©×œ Gemini ×”×•× 768
  updatedAt DateTime                    @updatedAt

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@map("profile_vectors")
}

model Meeting {
  id            String          @id @default(cuid())
  suggestionId  String
  scheduledDate DateTime
  status        MeetingStatus
  location      String?
  notes         String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  feedback      DateFeedback[]  @relation("MeetingFeedback")
  suggestion    MatchSuggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™

  @@index([suggestionId])
  @@index([status])
}

model MatchSuggestion {
  id                    String                    @id @default(cuid())
  matchmakerId          String
  firstPartyId          String
  secondPartyId         String
  status                MatchSuggestionStatus     @default(DRAFT)
  priority              Priority                  @default(MEDIUM)
  internalNotes         String?
  firstPartyNotes       String?
  secondPartyNotes      String?
  matchingReason        String?
  followUpNotes         String?
  responseDeadline      DateTime?
  decisionDeadline      DateTime?
  lastStatusChange      DateTime?
  previousStatus        MatchSuggestionStatus?
  lastActivity          DateTime                  @default(now())
  firstPartySent        DateTime?
  firstPartyResponded   DateTime?
  secondPartySent       DateTime?
  secondPartyResponded  DateTime?
  firstMeetingScheduled DateTime?
  closedAt              DateTime?
  category              SuggestionCategory        @default(ACTIVE)
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
  feedback              DateFeedback[]            @relation("SuggestionFeedback")
  firstParty            User                      @relation("FirstPartySuggestions", fields: [firstPartyId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×
  matchmaker            User                      @relation("MatchmakerSuggestions", fields: [matchmakerId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×
  secondParty           User                      @relation("SecondPartySuggestions", fields: [secondPartyId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×
  meetings              Meeting[]
  inquiries             SuggestionInquiry[]
  statusHistory         SuggestionStatusHistory[]
  approvedBy            User[]                    @relation("ApprovedSuggestions")
  reviewedBy            User[]                    @relation("ReviewedSuggestions")
  firstPartyLastViewedAt  DateTime?  // ××ª×™ ×¦×“ ×' ×¦×¤×” ×‘×”×¦×¢×” ×œ××—×¨×•× ×”
  secondPartyLastViewedAt DateTime?  // ××ª×™ ×¦×“ ×‘' ×¦×¤×” ×‘×”×¦×¢×” ×œ××—×¨×•× ×”


  @@index([category])
  @@index([matchmakerId])
  @@index([firstPartyId])
  @@index([secondPartyId])
  @@index([status])
  @@index([priority])
  @@index([lastActivity])
}

model SuggestionStatusHistory {
  id           String                @id @default(cuid())
  suggestionId String
  status       MatchSuggestionStatus
  reason       String?
  notes        String?
  createdAt    DateTime              @default(now())
  suggestion   MatchSuggestion       @relation(fields: [suggestionId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×

  @@index([suggestionId])
}

model Invitation {
  id           String           @id @default(cuid())
  matchmakerId String
  email        String
  token        String           @unique
  expires      DateTime
  status       InvitationStatus @default(PENDING)
  metadata     Json?
  userId       String?          @unique
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  matchmaker   User             @relation("MatchmakerInvitations", fields: [matchmakerId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
  user         User?            @relation("ReceivedInvitation", fields: [userId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™

  @@index([matchmakerId])
  @@index([email])
  @@index([status])
}

model Video {
  id        String      @id @default(cuid())
  userId    String
  url       String
  type      VideoType
  status    VideoStatus @default(PENDING)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
}

model AvailabilityInquiry {
  id                  String   @id @default(cuid())
  matchmakerId        String
  firstPartyId        String
  secondPartyId       String
  firstPartyResponse  Boolean?
  secondPartyResponse Boolean?
  note                String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  expiresAt           DateTime
  firstParty          User     @relation("FirstPartyInquiries", fields: [firstPartyId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
  matchmaker          User     @relation("MatchmakerInquiries", fields: [matchmakerId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
  secondParty         User     @relation("SecondPartyInquiries", fields: [secondPartyId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™

  @@index([matchmakerId])
  @@index([firstPartyId])
  @@index([secondPartyId])
}

model QuestionnaireResponse {
  id                    String    @id @default(cuid())
  userId                String
  valuesAnswers         Json?
  personalityAnswers    Json?
  relationshipAnswers   Json?
  partnerAnswers        Json?
  religionAnswers       Json?
  valuesCompleted       Boolean   @default(false)
  personalityCompleted  Boolean   @default(false)
  relationshipCompleted Boolean   @default(false)
  partnerCompleted      Boolean   @default(false)
  religionCompleted     Boolean   @default(false)
  worldsCompleted       String[]
  completed             Boolean   @default(false)
  startedAt             DateTime
  completedAt           DateTime?
  lastSaved             DateTime  @default(now())
    currentQuestionIndices Json?

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™

  @@index([userId])
  @@index([completed])
  @@index([valuesCompleted])
  @@index([personalityCompleted])
  @@index([relationshipCompleted])
  @@index([partnerCompleted])
  @@index([religionCompleted])
}

model UserImage {
  id                 String   @id @default(cuid())
  url                String
  isMain             Boolean  @default(false)
  cloudinaryPublicId String?
  userId             String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×

  @@index([userId])
}

model DateFeedback {
  id            String          @id @default(cuid())
  suggestionId  String
  partyId       String
  meetingId     String
  meetingNumber Int
  feedback      String
  status        String
  nextSteps     String?
  createdAt     DateTime        @default(now())
  meeting       Meeting         @relation("MeetingFeedback", fields: [meetingId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
  party         User            @relation("UserFeedback", fields: [partyId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
  suggestion    MatchSuggestion @relation("SuggestionFeedback", fields: [suggestionId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™

  @@index([suggestionId])
  @@index([partyId])
  @@index([meetingId])
}

model SuggestionInquiry {
  id           String          @id @default(cuid())
  suggestionId String
  fromUserId   String
  toUserId     String
  question     String
  answer       String?
  status       InquiryStatus   @default(PENDING)
  createdAt    DateTime        @default(now())
  answeredAt   DateTime?
  fromUser     User            @relation("SentSuggestionInquiries", fields: [fromUserId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
  suggestion   MatchSuggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade) // âœ… ×”×™×” ×§×™×™×
  toUser       User            @relation("ReceivedSuggestionInquiries", fields: [toUserId], references: [id], onDelete: Cascade) // â—ï¸ ×”×•×¡×¤×ª×™/×©×™× ×™×ª×™
recipientReadAt DateTime?

  @@index([suggestionId])
  @@index([fromUserId])
  @@index([toUserId])
}

// --- Enums ---
enum ServiceType {
  MILITARY_COMBATANT
  MILITARY_SUPPORT
  MILITARY_OFFICER
  MILITARY_INTELLIGENCE_CYBER_TECH
  NATIONAL_SERVICE_ONE_YEAR
  NATIONAL_SERVICE_TWO_YEARS
  HESDER_YESHIVA
  YESHIVA_ONLY_POST_HS
  PRE_MILITARY_ACADEMY_AND_SERVICE
  EXEMPTED
  CIVILIAN_SERVICE
  OTHER
}

enum HeadCoveringType {
  FULL_COVERAGE
  PARTIAL_COVERAGE
  HAT_BERET
  SCARF_ONLY_SOMETIMES
  NONE
}

enum KippahType {
  BLACK_VELVET
  KNITTED_SMALL
  KNITTED_LARGE
  CLOTH
  BRESLEV
  NONE_AT_WORK_OR_CASUAL
  NONE_USUALLY
  OTHER
}

enum MeetingStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
  RESCHEDULED
}

enum Gender {
  MALE
  FEMALE
}

enum UserRole {
  CANDIDATE
  MATCHMAKER
  ADMIN
}

enum UserStatus {
  PENDING_EMAIL_VERIFICATION
  PENDING_PHONE_VERIFICATION
  ACTIVE
  INACTIVE
  BLOCKED
}

enum VideoType {
  INTRODUCTION
  PERSONAL_STORY
  OTHER
}

enum VideoStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ContactMethod {
  EMAIL
  WHATSAPP
  PHONE
}

enum MatchSuggestionStatus {
  DRAFT
  PENDING_FIRST_PARTY
  FIRST_PARTY_APPROVED
  FIRST_PARTY_DECLINED
  PENDING_SECOND_PARTY
  SECOND_PARTY_APPROVED
  SECOND_PARTY_DECLINED
  AWAITING_MATCHMAKER_APPROVAL
  CONTACT_DETAILS_SHARED
  AWAITING_FIRST_DATE_FEEDBACK
  THINKING_AFTER_DATE
  PROCEEDING_TO_SECOND_DATE
  ENDED_AFTER_FIRST_DATE
  MEETING_PENDING
  MEETING_SCHEDULED
  MATCH_APPROVED
  MATCH_DECLINED
  DATING
  ENGAGED
  MARRIED
  EXPIRED
  CLOSED
  CANCELLED
}

enum SuggestionCategory {
  ACTIVE
  PENDING
  HISTORY
}

enum UserSource {
  REGISTRATION // User registered themselves
  MANUAL_ENTRY // User added manually by a matchmaker
  IMPORTED // Future: User imported from another system
}

enum AvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
  DATING
  PAUSED
  ENGAGED
  MARRIED
}

enum ReligiousJourney {
  BORN_INTO_CURRENT_LIFESTYLE // ×’×“×œ×ª×™ ×‘×¡×‘×™×‘×” ×“×•××”
  BORN_SECULAR
  BAAL_TESHUVA                // ×—×–×¨×ª×™ ×‘×ª×©×•×‘×”
  DATLASH                     // ×™×¦××ª×™ ×‘×©××œ×”
  CONVERT                     // ×’×¨/×’×™×•×¨×ª
  IN_PROCESS                  // ×‘×ª×”×œ×™×š ×©×œ ×©×™× ×•×™
  OTHER                       // ××—×¨
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum VerificationType {
  EMAIL
  PHONE_WHATSAPP
  DOCUMENT
  REFERENCE
  PASSWORD_RESET
  ACCOUNT_SETUP
}

enum VerificationStatus {
  PENDING
  COMPLETED
  EXPIRED
  FAILED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum InquiryStatus {
  PENDING
  ANSWERED
  CLOSED
}

model Feedback {
  id            String         @id @default(cuid())
  createdAt     DateTime       @default(now())
  userId        String?
  user          User?          @relation(fields: [userId], references: [id], onDelete: Cascade)
  pageUrl       String
  feedbackType  FeedbackType
  content       String         @db.Text
  status        FeedbackStatus @default(NEW)
  userAgent     String?
  screenshotUrl String?      // Field for the screenshot URL

  @@index([userId])
}

enum FeedbackType {
  SUGGESTION
  BUG
  POSITIVE
}

enum FeedbackStatus {
  NEW
  IN_PROGRESS
  RESOLVED
  WONT_FIX
}

model FriendTestimonial {
  id           String   @id @default(cuid())
  profileId    String
  profile      Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  authorName   String   // ×©× ×”×—×‘×¨/×” ×”×××œ×™×¦/×”
  relationship String   // ×”×§×©×¨ ×œ××•×¢××“/×ª (×œ××©×œ: "×—×‘×¨ ×™×œ×“×•×ª")
  content      String   @db.Text
  authorPhone  String?  // ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×©×œ ×”×××œ×™×¦/×” (××•×¤×¦×™×•× ×œ×™)
  
  // --- ×©×“×•×ª ×‘×§×¨×” ×•×¤×¨×˜×™×•×ª ---
  isPhoneVisibleToMatch Boolean   @default(false) // ×”×¡×›××” ××¤×•×¨×©×ª ×œ×”×¦×’×ª ×”××¡×¤×¨
  status                TestimonialStatus @default(PENDING) // ×¡×˜×˜×•×¡ ×”×”××œ×¦×”
  submittedBy           SubmissionSource  @default(USER)   // ××™×š ×”×”××œ×¦×” ×”×•×’×©×”
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([profileId])
}

// --- ×”×•×¡×¤×ª Enums ×—×“×©×™× ---
enum TestimonialStatus {
  PENDING   // ×××ª×™×Ÿ ×œ××™×©×•×¨ ×”××•×¢××“/×ª
  APPROVED  // ×××•×©×¨ ×•××•×¦×’ ×‘×¤×¨×•×¤×™×œ
  HIDDEN    // ×××•×©×¨ ××š ××•×¡×ª×¨ ×–×× ×™×ª ×¢×œ ×™×“×™ ×”××•×¢××“/×ª
}


enum SubmissionSource {
  USER   // ×”×•×–×Ÿ ×™×“× ×™×ª ×¢×œ ×™×“×™ ×”××•×¢××“/×ª
  FRIEND // ×”×•×’×© ×¢×œ ×™×“×™ ×—×‘×¨ ×“×¨×š ×§×™×©×•×¨ ×××•×‘×˜×—
}

enum TestimonialRequestStatus {
  PENDING
  COMPLETED
}

model TestimonialRequest {
  id        String    @id @default(cuid())
  token     String    @unique // The secure, random token for the URL
  expiresAt DateTime  // The date when the link will expire
  status    TestimonialRequestStatus @default(PENDING) // Tracks if the token has been used
  
  profileId String
  profile   Profile   @relation(fields: [profileId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([profileId])
}

model UserDripCampaign {
  id            String         @id @default(cuid())
  userId        String         @unique
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  currentStep   Int            @default(1)
  nextSendDate  DateTime
  status        CampaignStatus @default(ACTIVE)
  lastSentType  String?        // To track which type of message was last sent
  sentEmailTypes String[] @default([])
    lastEveningEmailSent   DateTime?  // ××ª×™ ×©×œ×—× ×• ××™×™×œ ×¢×¨×‘ ××—×¨×•×Ÿ
  eveningEmailsCount     Int        @default(0)  // ×›××” ××™×™×œ×™ ×¢×¨×‘ ×©×œ×—× ×•
  lastAiSummarySent      DateTime?  // ××ª×™ ×©×œ×—× ×• AI Summary ××—×¨×•×Ÿ
  aiSummaryCount         Int        @default(0)  // ×›××” ×¤×¢××™× ×©×œ×—× ×• AI Summary
  

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@index([nextSendDate, status])
   @@index([lastEveningEmailSent])
}

enum CampaignStatus {
  ACTIVE
  PAUSED
  UNSUBSCRIBED
  PROCESSING 
  COMPLETED
}

enum Language {
  en
  he
}

model ReferralCampaign {
  id          String   @id @default(cuid())
  name        String   // "×§××¤×™×™×Ÿ ×§×™×¥ 2025"
  slug        String   @unique // "summer-2025" - ×œ×–×™×”×•×™ ×‘×§×œ×•×ª
  description String?  @db.Text
  
  // ×ª××¨×™×›×™×
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean  @default(true)
  
  // ×¤×¨×¡×™×
  prizeTiers  Json?    // [{ threshold: 3, prize: "×§×¤×”", prizeValue: 50 }, ...]
  grandPrize  String?  // "××¨×•×—×” ×–×•×’×™×ª ×¤×¨×™××™×•×"
  
  // ×”×’×“×¨×•×ª
  settings    Json?    // { requireVerification: true, minAgeForReferral: 0 }
  
  referrers   Referrer[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([isActive])
  @@index([slug])
  @@index([startDate, endDate])
}

model Referrer {
  id           String   @id @default(cuid())
  campaignId   String
  campaign     ReferralCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  
  // ×¤×¨×˜×™ ×”××¤× ×”
  name         String
  email        String?
  phone        String?
  code         String   @unique  // "DAVID", "SARA123" - ×§×•×“ ×§×¦×¨ ×•×™×™×—×•×“×™
  
  // ×¡×•×’ ×”××¤× ×”
  tier         ReferrerTier @default(COMMUNITY)
  
  // ×”×¢×¨×•×ª ×¤× ×™××™×•×ª
  notes        String?  @db.Text
  
  // ×¡×˜×˜×™×¡×˜×™×§×•×ª ××˜××•×Ÿ (×œ×‘×™×¦×•×¢×™× - ××ª×¢×“×›×Ÿ ×‘×›×œ ××™×¨×•×¢)
  clickCount       Int @default(0)
  registrationCount Int @default(0)
  verifiedCount    Int @default(0)
  completedCount   Int @default(0)
  
  // ×¤×¨×¡×™× ×©×”×ª×§×‘×œ×•
  prizesAwarded    Json?  // [{ prize: "×§×¤×”", awardedAt: "2025-06-15" }]
  
  referrals    Referral[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([campaignId])
  @@index([code])
  @@index([tier])
  @@index([verifiedCount])
}

model Referral {
  id          String   @id @default(cuid())
  referrerId  String
  referrer    Referrer @relation(fields: [referrerId], references: [id], onDelete: Cascade)
  
  // ×”××©×ª××© ×©× ×¨×©× (null ×¢×“ ×©××©×œ×™× ×¨×™×©×•×)
  userId      String?  @unique
  user        User?    @relation("ReferredUser", fields: [userId], references: [id], onDelete: SetNull)
  
  // ××¢×§×‘ ×”×ª×§×“××•×ª
  status      ReferralStatus @default(CLICKED)
  
  // ××™×“×¢ ×˜×›× ×™ ×œ×× ×™×¢×ª ×”×•× ××•×ª
  ipAddress   String?
  userAgent   String?
  sessionId   String?  // ×œ×–×™×”×•×™ ×¡×©×Ÿ ×™×™×—×•×“×™
  
  // ×ª××¨×™×›×™× ×œ×›×œ ×©×œ×‘
  clickedAt    DateTime @default(now())
  startedAt    DateTime?  // ×”×ª×—×™×œ ×œ××œ× ×˜×•×¤×¡
  registeredAt DateTime?  // ×¡×™×™× ×¨×™×©×•× ×‘×¡×™×¡×™
  verifiedAt   DateTime?  // ××™××ª ×˜×œ×¤×•×Ÿ
  completedAt  DateTime?  // ×”×©×œ×™× ×¤×¨×•×¤×™×œ
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([referrerId])
  @@index([userId])
  @@index([status])
  @@index([ipAddress])
  @@index([clickedAt])
}

// --- Enums ×—×“×©×™× ---

enum ReferrerTier {
  AMBASSADOR  // ×©×’×¨×™×¨ - ×—×‘×¨ ×§×¨×•×‘ ×©×§×™×‘×œ ×¢×¨×›×” ××œ××”
  COMMUNITY   // ×§×”×™×œ×” - × ×¨×©× ×“×¨×š ×”×“×£ ×”×¦×™×‘×•×¨×™
}

enum ReferralStatus {
  CLICKED      // ×œ×—×¥ ×¢×œ ×”×§×™×©×•×¨
  STARTED      // ×”×ª×—×™×œ ×”×¨×©××” (× ×›× ×¡ ×œ×˜×•×¤×¡)
  REGISTERED   // ×¡×™×™× ×”×¨×©××” ×‘×¡×™×¡×™×ª
  VERIFIED     // ××™××ª ×˜×œ×¤×•×Ÿ
  COMPLETED    // ×”×©×œ×™× ×¤×¨×•×¤×™×œ + ×ª××•× ×”
}
model SavedMatchSearch {
  id               String   @id @default(cuid())
  
  // ×”××•×¢××“ ×©×—×™×¤×©× ×• ×¢×‘×•×¨×• ×”×ª×××•×ª
  targetUserId     String   @unique  // @unique = ×¨×§ ×—×™×¤×•×© ××—×“ ×©××•×¨ ×œ×›×œ ××•×¢××“
  targetUser       User     @relation("TargetUserSearches", fields: [targetUserId], references: [id], onDelete: Cascade)
  
  // ×”×©×“×›×Ÿ ×©×”×¤×¢×™×œ ××ª ×”×—×™×¤×•×©
  matchmakerId     String
  matchmaker       User     @relation("MatchmakerSearches", fields: [matchmakerId], references: [id], onDelete: Cascade)
  
  // ×ª×•×¦××•×ª ×”×—×™×¤×•×© (JSON)
  // ××‘× ×”: [{ userId, score, reasoning, firstName, lastName }]
  results          Json
  
  // ××˜×-×“××˜×”
  algorithmVersion String   @default("v2.0")
  candidatesCount  Int      @default(0)  // ×›××” ××•×¢××“×™× × ×•×ª×—×•
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  @@index([targetUserId])
  @@index([matchmakerId])
  @@index([createdAt])
}

model SavedVectorMatchSearch {
  id               String   @id @default(cuid())
  targetUserId     String   @unique
  targetUser       User     @relation("TargetUserVectorSearches", fields: [targetUserId], references: [id], onDelete: Cascade)
  matchmakerId     String
  matchmaker       User     @relation("MatchmakerVectorSearches", fields: [matchmakerId], references: [id], onDelete: Cascade)
  results          Json
  algorithmVersion String   @default("vector-v1.0")
  candidatesCount  Int      @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  @@index([targetUserId])
  @@index([matchmakerId])
}

model MatchingJob {
  id              String    @id @default(cuid())
  targetUserId    String
  matchmakerId    String
  method          String
  status          String    @default("pending")
  progress        Int       @default(0)
  progressMessage String?
  result          Json?
  error           String?
  totalCandidates Int?
  matchesFound    Int?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  completedAt     DateTime?

  @@index([targetUserId])
  @@index([matchmakerId])
  @@index([status])
  @@index([createdAt])
}
  
model VirtualProfile {
  id                  String   @id @default(cuid())
  
  // ××™ ×™×¦×¨ ××ª ×”×¤×¨×•×¤×™×œ ×”×•×™×¨×˜×•××œ×™
  matchmakerId        String
  matchmaker          User     @relation("MatchmakerVirtualProfiles", fields: [matchmakerId], references: [id], onDelete: Cascade)
  
  // ×§×œ×˜ ×”×©×“×›×Ÿ
  name                String?              // ×©× ×œ×–×™×”×•×™ (××•×¤×¦×™×•× ×œ×™)
  sourceText          String   @db.Text    // ×”×˜×§×¡×˜ ×”×—×•×¤×©×™ ×©×”×©×“×›×Ÿ ×”×–×™×Ÿ
  
  // ×¤×¨××˜×¨×™× ×©×”×©×“×›×Ÿ ×‘×•×—×¨ (×—×•×‘×”)
  gender              Gender               // ××’×“×¨ ×”×™×•×–×¨ ×”×•×™×¨×˜×•××œ×™
  religiousLevel      String               // ×¨××” ×“×ª×™×ª
  
  // ×”×¤×¨×•×¤×™×œ ×©×”-AI ×™×¦×¨
  generatedProfile    Json?                // { personalitySummary, lookingForSummary, inferredAge, ... }
  
  // ×¡×™×›×•× ×¢×¨×•×š (×× ×”×©×“×›×Ÿ ×¢×¨×š ××ª ×”×¡×™×›×•×)
  editedSummary       String?  @db.Text    // ×¡×™×›×•× ×©×”×©×“×›×Ÿ ×¢×¨×š ×™×“× ×™×ª
  wasEdited           Boolean  @default(false)
  
  // ×•×§×˜×•×¨ ×œ×”×ª×××” (× ×•×¦×¨ ××”×¤×¨×•×¤×™×œ)
  vector              Unsupported("vector(768)")?
  
  // ××˜×-×“××˜×”
  isStarred           Boolean  @default(false)
  lastUsedAt          DateTime?
  usageCount          Int      @default(0)
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([matchmakerId])
  @@index([isStarred])
  @@index([lastUsedAt])
}
