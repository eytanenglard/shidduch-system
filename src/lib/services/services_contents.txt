################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services
# Generated on: 2025-08-18 13:44:44
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\aiService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/aiService.ts

import { GoogleGenerativeAI } from '@google/generative-ai';

const apiKey = process.env.GOOGLE_API_KEY;

if (!apiKey) {
  console.error(
    '[FATAL ERROR] GOOGLE_API_KEY is not set in .env or .env.local!'
  );
  throw new Error('GOOGLE_API_KEY must be set.');
}

const genAI = new GoogleGenerativeAI(apiKey);

/**
 * יוצר וקטור הטמעה (embedding) עבור טקסט נתון.
 * @param text הטקסט להטמעה.
 * @returns Promise שמחזיר מערך של מספרים (הווקטור), או null במקרה של כישלון.
 */
export async function generateTextEmbedding(
  text: string
): Promise<number[] | null> {
  try {
    const model = genAI.getGenerativeModel({ model: 'text-embedding-004' });
    const result = await model.embedContent(text);
    const embedding = result.embedding;
    if (embedding && embedding.values) {
      return embedding.values;
    }
    console.error('Embedding generation returned no values.');
    return null;
  } catch (error) {
    console.error('Error generating text embedding:', error);
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח התאמה עבור שדכנים.
 */
export interface AiAnalysisResult {
  overallScore: number;
  matchSummary: string;
  compatibilityPoints: Array<{
    area: string;
    explanation: string;
    strength: 'HIGH' | 'MEDIUM' | 'LOW';
  }>;
  potentialChallenges: Array<{
    area: string;
    explanation: string;
    severity: 'HIGH' | 'MEDIUM' | 'LOW';
  }>;
  suggestedConversationStarters: string[];
}

/**
 * מנתח את ההתאמה בין שני פרופילים נרטיביים עבור שדכן.
 * @param profileAText הפרופיל הנרטיבי של המשתמש הראשון.
 * @param profileBText הפרופיל הנרטיבי של המשתמש השני.
 * @param language שפת הפלט הרצויה.
 * @returns Promise שמחזיר אובייקט ניתוח מובנה, או null במקרה של כישלון.
 */
export async function analyzePairCompatibility(
  profileAText: string,
  profileBText: string,
  language: 'he' | 'en' = 'he'
): Promise<AiAnalysisResult | null> {
  console.log(
    `--- Attempting to analyze compatibility for matchmaker in ${language} ---`
  );
  if (!profileAText || !profileBText) {
    console.error(
      'analyzePairCompatibility called with one or more empty profiles.'
    );
    return null;
  }
  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.3,
    },
  });

  const languageInstruction =
    language === 'he'
      ? 'Your entire JSON output, including all string values (keys and explanations), must be in Hebrew.'
      : 'Your entire JSON output, including all string values, must be in English.';

  const prompt = `
    You are a "Matchmaking AI Expert" for a religious Jewish dating platform. Your goal is to analyze the compatibility of two user profiles and provide a structured, insightful, and helpful analysis for the matchmaker.
    ${languageInstruction}
    Your output MUST be a valid JSON object.
    The JSON structure: { "overallScore": number, "matchSummary": "string", "compatibilityPoints": [{ "area": "string", "explanation": "string", "strength": "HIGH" | "MEDIUM" | "LOW" }], "potentialChallenges": [{ "area": "string", "explanation": "string", "severity": "HIGH" | "MEDIUM" | "LOW" }], "suggestedConversationStarters": ["string"] }
    --- Profile 1 ---
    ${profileAText}
    --- Profile 2 ---
    ${profileBText}
    `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error('Direct Gemini API returned an empty response.');
      return null;
    }

    console.log(
      `--- Successfully received compatibility analysis from Gemini API in ${language} ---`
    );
    return JSON.parse(jsonString) as AiAnalysisResult;
  } catch (error) {
    console.error(
      `Error generating compatibility analysis from Direct Gemini API in ${language}:`,
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח פרופיל עבור המשתמש עצמו.
 */
// --- START OF CHANGE ---
export interface AiProfileAnalysisResult {
  personalitySummary: string;
  lookingForSummary: string;
  completenessReport: Array<{
    area: string;
    status: 'COMPLETE' | 'PARTIAL' | 'MISSING';
    feedback: string;
  }>;
  actionableTips: Array<{
    area: string;
    tip: string;
  }>;
  // photoFeedback הוסר
}
// --- END OF CHANGE ---

/**
 * מנתח פרופיל של משתמש ומספק משוב וטיפים לשיפור.
 * @param userNarrativeProfile הטקסט הנרטיבי המקיף של פרופיל המשתמש.
 * @returns Promise שמחזיר אובייקט ניתוח מובנה, או null במקרה של כישלון.
 */
export async function getProfileAnalysis(
  userNarrativeProfile: string
): Promise<AiProfileAnalysisResult | null> {
  console.log(
    '--- [AI Profile Advisor] Starting profile analysis with Gemini API ---'
  );

  if (!userNarrativeProfile) {
    console.error(
      '[AI Profile Advisor] Called with an empty user narrative profile.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.4,
    },
  });

  // --- START OF CHANGE ---
  // עודכנה ההנחיה כדי להסיר את photoFeedback ממבנה ה-JSON המבוקש
  const prompt = `
    You are an expert, warm, and encouraging dating profile coach for a religious Jewish audience. Your goal is to help the user improve their profile to attract the best possible matches. Based on the following comprehensive user profile, provide a structured JSON analysis. The entire output MUST be a valid JSON object in Hebrew.
    The JSON structure must be: { "personalitySummary": "string", "lookingForSummary": "string", "completenessReport": [{ "area": "string", "status": "COMPLETE" | "PARTIAL" | "MISSING", "feedback": "string" }], "actionableTips": [{ "area": "string", "tip": "string" }] }
    --- User Profile Narrative ---
    ${userNarrativeProfile}
    --- End of User Profile Narrative ---
  `;
  // --- END OF CHANGE ---

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Profile Advisor] Gemini API returned an empty response.'
      );
      return null;
    }

    console.log(
      '--- [AI Profile Advisor] Successfully received analysis from Gemini API. ---'
    );
    return JSON.parse(jsonString) as AiProfileAnalysisResult;
  } catch (error) {
    console.error(
      '[AI Profile Advisor] Error generating profile analysis:',
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח הצעה עבור משתמש הקצה.
 */
export interface AiSuggestionAnalysisResult {
  overallScore: number;
  matchTitle: string;
  matchSummary: string;
  compatibilityPoints: Array<{ area: string; explanation: string }>;
  pointsToConsider: Array<{ area: string; explanation: string }>;
  suggestedConversationStarters: string[];
}

/**
 * מנתח התאמה בין שני פרופילים ומחזיר ניתוח מותאם למשתמש הקצה,
 * עם דגש על טון חיובי ומעודד.
 * @param currentUserProfileText הפרופיל הנרטיבי של המשתמש הנוכחי.
 * @param suggestedUserProfileText הפרופיל הנרטיבי של המשתמש המוצע.
 * @returns Promise שמחזיר אובייקט ניתוח מובנה, או null במקרה של כישלון.
 */
export async function analyzeSuggestionForUser(
  currentUserProfileText: string,
  suggestedUserProfileText: string
): Promise<AiSuggestionAnalysisResult | null> {
  console.log(
    '--- [AI Suggestion Advisor] Starting suggestion analysis for user ---'
  );

  if (!currentUserProfileText || !suggestedUserProfileText) {
    console.error(
      '[AI Suggestion Advisor] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.5,
    },
  });

  const prompt = `
    You are a 'Matchmaking AI Advisor'. Your tone is positive, warm, and encouraging. Your goal is to help a user understand the potential of a match suggestion they received. Analyze the compatibility between 'My Profile' and the 'Suggested Profile'.
    Your entire output MUST be a valid JSON object in Hebrew.
    The JSON structure must be: { "overallScore": number, "matchTitle": "string", "matchSummary": "string", "compatibilityPoints": [{ "area": "string", "explanation": "string (user-friendly explanation)" }], "pointsToConsider": [{ "area": "string", "explanation": "string (rephrased positively, e.g., 'הוא אוהב טיולים ואת מעדיפה בית. זו הזדמנות נהדרת לחוות דברים חדשים יחד!')" }], "suggestedConversationStarters": ["string"] }
    
    --- My Profile ---
    ${currentUserProfileText}

    --- Suggested Profile ---
    ${suggestedUserProfileText}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Suggestion Advisor] Gemini API returned an empty response.'
      );
      return null;
    }

    console.log(
      '--- [AI Suggestion Advisor] Successfully received analysis from Gemini API. ---'
    );
    return JSON.parse(jsonString) as AiSuggestionAnalysisResult;
  } catch (error) {
    console.error(
      '[AI Suggestion Advisor] Error generating suggestion analysis:',
      error
    );
    return null;
  }
}

/**
 * מייצר טקסט נימוק מותאם אישית עבור הצעת שידוך.
 * @param profile1Text הפרופיל הנרטיבי של צד א'.
 * @param profile2Text הפרופיל הנרטיבי של צד ב'.
 * @returns Promise שמחזיר מחרוזת טקסט עם הנימוק, או null במקרה של כישלון.
 */
export async function generateSuggestionRationale(
  profile1Text: string,
  profile2Text: string
): Promise<string | null> {
  console.log(
    '--- [AI Rationale Writer] Starting suggestion rationale generation ---'
  );
  if (!profile1Text || !profile2Text) {
    console.error(
      '[AI Rationale Writer] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

  const prompt = `
    You are a professional and sensitive matchmaker in the religious Jewish community. Your task is to write a warm, personal, and compelling justification ('matchingReason') for a match suggestion.
    Based on the two profiles provided, identify 2-3 key points of compatibility (values, life goals, personality traits, background) and weave them into a concise and positive paragraph.
    The output should be ONLY the justification text in Hebrew, without any additional titles, formatting, or explanations. Start directly with the text.

    **Example Output Structure:**
    "אני חושב/ת שיש כאן פוטנציאל להתאמה מצוינת מכמה סיבות. ראשית, שניכם ציינתם ש... וזה מראה על... שנית, הרקע ה... שלכם יכול להוות בסיס משותף חזק. בנוסף, נראה ששניכם חולקים... וזה יכול לתרום רבות לבניית קשר..."

    --- Profile 1 ---
    ${profile1Text}

    --- Profile 2 ---
    ${profile2Text}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    if (!text) {
      console.error(
        '[AI Rationale Writer] Gemini API returned an empty response.'
      );
      return null;
    }

    console.log(
      '--- [AI Rationale Writer] Successfully generated rationale. ---'
    );
    return text.trim();
  } catch (error) {
    console.error(
      '[AI Rationale Writer] Error generating suggestion rationale:',
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של אובייקט הנימוקים המלא.
 */
export interface FullRationaleResult {
  generalRationale: string;
  rationaleForParty1: string;
  rationaleForParty2: string;
}

/**
 * מייצר חבילת נימוקים מלאה עבור הצעת שידוך: כללי, ואישי לכל צד.
 * @param profile1Text הפרופיל הנרטיבי של צד א'.
 * @param profile2Text הפרופיל הנרטיבי של צד ב'.
 * @returns Promise שמחזיר אובייקט עם שלושת סוגי הנימוקים, או null במקרה של כישלון.
 */
export async function generateFullSuggestionRationale(
  profile1Text: string,
  profile2Text: string
): Promise<FullRationaleResult | null> {
  console.log(
    '--- [AI Rationale Writer] Starting full rationale package generation ---'
  );
  if (!profile1Text || !profile2Text) {
    console.error(
      '[AI Rationale Writer] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.6,
    },
  });

  const prompt = `
    You are a professional and sensitive matchmaker in the religious Jewish community. Your task is to write three distinct texts for a match suggestion based on the two provided user profiles.
    The entire output MUST be a valid JSON object in Hebrew, with the following exact structure:
    {
      "generalRationale": "A general, objective summary of the compatibility points. This is for the matchmaker's internal use.",
      "rationaleForParty1": "A personal and warm message for Party 1, explaining why Party 2 is a great match for them. Address them directly and highlight how Party 2's qualities align with Party 1's stated needs and desires. Use encouraging and persuasive language.",
      "rationaleForParty2": "A personal and warm message for Party 2, explaining why Party 1 is a great match for them. Do the same as above, but from Party 2's perspective."
    }

    **Key instructions for personal rationales (rationaleForParty1, rationaleForParty2):**
    - Start with a warm opening.
    - Reference specific details from the person's own profile to show you understand them.
    - Connect those details to specific strengths of the suggested partner.
    - Maintain a positive, professional, and slightly persuasive tone, without being pushy.
    - The goal is to make each person feel understood and that this suggestion was made with careful consideration for them personally.

    --- Profile 1 ---
    ${profile1Text}

    --- Profile 2 ---
    ${profile2Text}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Rationale Writer] Gemini API returned an empty response for full rationale.'
      );
      return null;
    }

    console.log(
      '--- [AI Rationale Writer] Successfully generated full rationale package. ---'
    );
    return JSON.parse(jsonString) as FullRationaleResult;
  } catch (error) {
    console.error(
      '[AI Rationale Writer] Error generating full suggestion rationale:',
      error
    );
    return null;
  }
}

const aiService = {
  generateTextEmbedding,
  analyzePairCompatibility,
  getProfileAnalysis,
  analyzeSuggestionForUser,
  generateSuggestionRationale,
  generateFullSuggestionRationale,
};

export default aiService;
--- End of Content for aiService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\availabilityService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/availabilityService.ts
import prisma from '@/lib/prisma';
import { AvailabilityStatus, Prisma } from '@prisma/client';
import { emailService } from '@/lib/email/emailService';

interface SendInquiryParams {
  matchmakerId: string;
  firstPartyId: string;
  secondPartyId?: string;
  note?: string;
}

interface UpdateInquiryResponse {
  inquiryId: string;
  userId: string;
  isAvailable: boolean;
  note?: string;
}

interface GetInquiriesOptions {
  status?: 'pending' | 'completed' | 'expired';
  orderBy?: 'createdAt' | 'updatedAt';
  limit?: number;
}

interface AvailabilityStats {
  available: number;
  unavailable: number;
  dating: number;
  pending: number;
}

export class AvailabilityService {
  static async sendAvailabilityInquiry({
    matchmakerId,
    firstPartyId,
    note
  }: SendInquiryParams) {
    try {
      console.log('Starting availability inquiry process', {
        matchmakerId,
        firstPartyId,
        note
      });

      // Check for existing active inquiry
      const existingInquiry = await prisma.availabilityInquiry.findFirst({
        where: {
          firstPartyId,
          expiresAt: {
            gt: new Date()
          }
        }
      });

      if (existingInquiry) {
        console.log('Found existing active inquiry:', existingInquiry);
        throw new Error('קיימת כבר בקשת זמינות פעילה');
      }

      // Create new inquiry
      console.log('Creating new inquiry...');
      const inquiry = await prisma.availabilityInquiry.create({
        data: {
          matchmakerId,
          firstPartyId,
          secondPartyId: firstPartyId,
          note,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
        },
        include: {
          firstParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          secondParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      });
      
      console.log('Successfully created inquiry:', inquiry);

      // Send email notification
      if (inquiry.firstParty.email) {
        console.log('Attempting to send email to:', inquiry.firstParty.email);
        
        try {
          await emailService.sendAvailabilityCheck({
            email: inquiry.firstParty.email,
            recipientName: `${inquiry.firstParty.firstName} ${inquiry.firstParty.lastName}`,
            matchmakerName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            inquiryId: inquiry.id
          });
          console.log('Email sent successfully');
        } catch (emailError) {
          console.error('Failed to send email:', emailError);
          // Continue even if email fails - we want the inquiry to be saved
        }
      } else {
        console.warn('No email found for first party');
      }

      return inquiry;

    } catch (error) {
      console.error('Error in sendAvailabilityInquiry:', error);
      throw error;
    }
  }

  static async updateInquiryResponse({
    inquiryId,
    userId,
    isAvailable,
    note
  }: UpdateInquiryResponse) {
    try {
      console.log('Starting to update inquiry response:', {
        inquiryId,
        userId,
        isAvailable,
        note
      });

      // Check if inquiry exists
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      });

      if (!inquiry) {
        console.log('Inquiry not found:', inquiryId);
        throw new Error('בקשת הזמינות לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);

      if (inquiry.expiresAt < new Date()) {
        console.log('Inquiry expired:', inquiry.expiresAt);
        throw new Error('תוקף הבקשה פג');
      }

      const isFirstParty = inquiry.firstPartyId === userId;
      const isSecondParty = inquiry.secondPartyId === userId;

      if (!isFirstParty && !isSecondParty) {
        console.log('Unauthorized response attempt. User:', userId);
        throw new Error('אין הרשאה לעדכן בקשה זו');
      }

      // Update both inquiry and profile in a transaction
      console.log('Updating inquiry and profile...');
      const result = await prisma.$transaction(async (tx) => {
        // Update user's profile
        const updatedProfile = await tx.profile.update({
          where: { userId },
          data: {
            availabilityStatus: isAvailable ? AvailabilityStatus.AVAILABLE : AvailabilityStatus.UNAVAILABLE,
            availabilityNote: note,
            availabilityUpdatedAt: new Date()
          }
        });
        console.log('Profile updated:', updatedProfile);

        // Update the inquiry
        const updatedInquiry = await tx.availabilityInquiry.update({
          where: { id: inquiryId },
          data: {
            ...(isFirstParty ? { firstPartyResponse: isAvailable } : { secondPartyResponse: isAvailable }),
            updatedAt: new Date()
          },
          include: {
            firstParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true
              }
            },
            secondParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true
              }
            },
            matchmaker: {
              select: {
                firstName: true,
                lastName: true,
                email: true
              }
            }
          }
        });
        console.log('Inquiry updated:', updatedInquiry);

        // Send notification to matchmaker
        if (inquiry.matchmaker.email) {
          await emailService.sendSuggestionNotification({
            email: inquiry.matchmaker.email,
            recipientName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            matchmakerName: "המערכת",
            suggestionDetails: {
              additionalInfo: `${isFirstParty ? 'הצד הראשון' : 'הצד השני'} ${isAvailable ? 'זמין' : 'אינו זמין'} ${note ? `(הערה: ${note})` : ''}`
            }
          });
        }

        return updatedInquiry;
      });

      return result;

    } catch (error) {
      console.error('Error in updateInquiryResponse:', error);
      throw error;
    }
  }

  static async getInquiryById(inquiryId: string) {
    console.log('Fetching inquiry by ID:', inquiryId);
    try {
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      });

      if (!inquiry) {
        console.log('No inquiry found with ID:', inquiryId);
        throw new Error('הבקשה לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);
      return inquiry;

    } catch (error) {
      console.error('Error in getInquiryById:', error);
      throw error;
    }
  }

  static async getAvailabilityStats(matchmakerId: string): Promise<AvailabilityStats> {
    console.log('Calculating availability stats for matchmaker:', matchmakerId);
    try {
      const stats = await prisma.profile.groupBy({
        by: ['availabilityStatus'],
        where: {
          user: {
            OR: [
              { firstPartyInquiries: { some: { matchmakerId } } },
              { secondPartyInquiries: { some: { matchmakerId } } }
            ]
          }
        },
        _count: true
      });

      console.log('Raw stats:', stats);

      const result = {
        available: stats.find(s => s.availabilityStatus === AvailabilityStatus.AVAILABLE)?._count || 0,
        unavailable: stats.find(s => s.availabilityStatus === AvailabilityStatus.UNAVAILABLE)?._count || 0,
        dating: stats.find(s => s.availabilityStatus === AvailabilityStatus.DATING)?._count || 0,
        pending: stats.find(s => s.availabilityStatus === null)?._count || 0
      };

      console.log('Processed stats:', result);
      return result;

    } catch (error) {
      console.error('Error in getAvailabilityStats:', error);
      throw error;
    }
  }

  static async getAllInquiries(
    userId: string,
    { status = 'pending', orderBy = 'createdAt', limit }: GetInquiriesOptions = {}
  ) {
    try {
      // Build the where clause based on status
      const where: Prisma.AvailabilityInquiryWhereInput = {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId }
        ],
        ...(status === 'pending' && {
          expiresAt: { gt: new Date() },
          OR: [
            { firstPartyResponse: null },
            { secondPartyResponse: null }
          ]
        }),
        ...(status === 'completed' && {
          firstPartyResponse: { not: null },
          secondPartyResponse: { not: null }
        }),
        ...(status === 'expired' && {
          expiresAt: { lt: new Date() }
        })
      };

      const validOrderBy = orderBy || 'createdAt';

      const inquiries = await prisma.availabilityInquiry.findMany({
        where,
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        },
        orderBy: {
          [validOrderBy]: 'desc'
        },
        ...(limit ? { take: limit } : {})
      });

      return inquiries;

    } catch (error) {
      console.error('Error in getAllInquiries:', error);
      throw error;
    }
  }
}
--- End of Content for availabilityService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\profileAiService.ts
--------------------------------------------------------------------------------
Content:
// File: src/lib/services/profileAiService.ts

import prisma from "@/lib/prisma";
import aiService from "./aiService";
import type { User, Profile, QuestionnaireResponse, Prisma as PrismaTypes, ReligiousJourney } from '@prisma/client';

// 1. --- Import types and questions from the questionnaire module ---
import type { Question } from '@/components/questionnaire/types/types';
import { valuesQuestions } from '@/components/questionnaire/questions/values/valuesQuestions';
import { personalityQuestions } from '@/components/questionnaire/questions/personality/personalityQuestions';
import { relationshipQuestions } from '@/components/questionnaire/questions/relationship/relationshipQuestions';
import { partnerQuestions } from '@/components/questionnaire/questions/partner/partnerQuestions';
import { religionQuestions } from '@/components/questionnaire/questions/religion/religionQuestions';

// 2. --- Centralized Question Data ---
const allQuestions: Map<string, Question> = new Map();
[
  ...valuesQuestions,
  ...personalityQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
].forEach(q => allQuestions.set(q.id, q));

// 3. --- Strongly-typed interfaces for data handling ---
type WorldKey = 'values' | 'personality' | 'relationship' | 'partner' | 'religion';
type DbWorldKey = `${WorldKey}Answers`;

const KEY_MAPPING: Record<WorldKey, DbWorldKey> = {
  values: 'valuesAnswers',
  personality: 'personalityAnswers',
  relationship: 'relationshipAnswers',
  partner: 'partnerAnswers',
  religion: 'religionAnswers'
};

interface JsonAnswerData {
  questionId: string;
  value: PrismaTypes.JsonValue;
  answeredAt: string;
  isVisible?: boolean;
}

type UserWithRelations = User & {
  profile: Profile | null;
  questionnaireResponses: QuestionnaireResponse[];
};

// 4. --- Helper Functions for Formatting ---

function formatDisplayValue(value: PrismaTypes.JsonValue | null | undefined, fallback: string = "לא צוין"): string {
  if (value === null || value === undefined) {
    return fallback;
  }
  if (typeof value === 'string' && value.trim() === '') {
    return fallback;
  }
  if (typeof value === 'boolean') {
    return value ? "כן" : "לא";
  }
  if (typeof value === 'number') {
    return String(value);
  }
  if (value instanceof Date) {
    return value.toLocaleDateString('he-IL');
  }
  if (Array.isArray(value)) {
    return value.length > 0 ? value.map(String).join(', ') : fallback;
  }
  if (typeof value === 'object') {
     if (Object.keys(value).length > 0) {
         return Object.entries(value)
             .map(([key, val]) => `${key}: ${val}`)
             .join('; ');
     }
     return fallback;
  }
  return String(value);
}

function formatArray(arr: string[] | null | undefined, fallback: string = "לא צוין"): string {
  if (!arr || arr.length === 0) {
    return fallback;
  }
  return arr.join(', ');
}

function isValidAnswerObject(item: unknown): item is PrismaTypes.JsonObject & { value: PrismaTypes.JsonValue; questionId: unknown; answeredAt: unknown } {
  return (
    typeof item === 'object' &&
    item !== null &&
    'questionId' in item &&
    'value' in item &&
    item.value !== undefined &&
    'answeredAt' in item
  );
}

function safeParseAnswers(jsonValue: PrismaTypes.JsonValue | null): JsonAnswerData[] {
  if (Array.isArray(jsonValue)) {
    return jsonValue
      .filter(isValidAnswerObject)
      .map(item => ({
        questionId: String(item.questionId || ''),
        value: item.value,
        answeredAt: String(item.answeredAt || new Date().toISOString()),
        isVisible: typeof item.isVisible === 'boolean' ? item.isVisible : true,
      }))
      .filter(item => item.questionId);
  }
  return [];
}

function formatSingleAnswer(answer: JsonAnswerData): string | null {
  const questionDef = allQuestions.get(answer.questionId);
  if (!questionDef) {
    return `**שאלה לא מזוהה (${answer.questionId}):** ${formatDisplayValue(answer.value)}\n`;
  }

  if (answer.value === null || answer.value === undefined || answer.value === '') return null;
  if (Array.isArray(answer.value) && answer.value.length === 0) return null;

  let narrativePart = `**${questionDef.question}**\n`;
  
  switch (questionDef.type) {
    case 'singleChoice':
    case 'iconChoice':
    case 'scenario': {
      const selectedOption = questionDef.options?.find(o => o.value === answer.value);
      narrativePart += `תשובה: ${selectedOption ? selectedOption.text : formatDisplayValue(answer.value)}\n`;
      break;
    }
    case 'multiChoice':
    case 'multiSelect':
    case 'multiSelectWithOther': {
      if (Array.isArray(answer.value)) {
        const selectedTexts = answer.value.map(val => {
          if (typeof val === 'string' && val.startsWith('custom:')) {
            return `(אחר) ${val.replace('custom:', '').trim()}`;
          }
          const option = questionDef.options?.find(o => o.value === val);
          return option ? option.text : String(val);
        });
        narrativePart += `תשובות: ${selectedTexts.join(', ')}\n`;
      }
      break;
    }
    case 'openText': {
      narrativePart += `תשובה: "${formatDisplayValue(answer.value)}"\n`;
      break;
    }
    case 'scale': {
      const minLabel = questionDef.labels?.min || 'נמוך';
      const maxLabel = questionDef.labels?.max || 'גבוה';
      narrativePart += `דירוג: ${answer.value}/10 (כאשר 1=${minLabel} ו-10=${maxLabel})\n`;
      break;
    }
    case 'budgetAllocation': {
      if (typeof answer.value === 'object' && answer.value && !Array.isArray(answer.value)) {
          const allocations = Object.entries(answer.value)
              .filter(([, points]) => typeof points === 'number' && points > 0)
              .map(([category, points]) => `${category}: ${points}%`)
              .join('; ');
          narrativePart += `הקצאת חשיבות: ${allocations || 'לא צוין'}\n`;
      }
      break;
    }
    default: {
      narrativePart += `תשובה: ${formatDisplayValue(answer.value)}\n`;
    }
  }
  
  return narrativePart + '\n';
}

function processQuestionnaireData(questionnaire: QuestionnaireResponse | null | undefined) {
    const totalCount = allQuestions.size;
    if (!questionnaire) {
        return {
            answeredCount: 0,
            totalCount,
            completionPercentage: 0,
            answersNarrative: "המשתמש עדיין לא החל למלא את השאלון."
        };
    }

    const worldKeys: WorldKey[] = ['values', 'personality', 'relationship', 'partner', 'religion'];
    let answeredCount = 0;
    const narrativeChunks: string[] = [];

    worldKeys.forEach(worldKey => {
        const dbKey = KEY_MAPPING[worldKey];
        const answers = safeParseAnswers(questionnaire[dbKey]);
        
        if (answers.length > 0) {
            answeredCount += answers.length;
            
            const worldInfo = allQuestions.get(answers[0].questionId);
            const worldTitle = worldInfo?.worldId ? worldInfo.worldId.charAt(0) + worldInfo.worldId.slice(1).toLowerCase() : worldKey;
            
            narrativeChunks.push(`### עולם ה${worldTitle}`);
            
            answers.forEach(answer => {
                const formattedPart = formatSingleAnswer(answer);
                if (formattedPart) {
                    narrativeChunks.push(formattedPart);
                }
            });
        }
    });

    const completionPercentage = totalCount > 0 ? Math.round((answeredCount / totalCount) * 100) : 0;
    
    return {
        answeredCount,
        totalCount,
        completionPercentage,
        answersNarrative: narrativeChunks.length > 0 ? narrativeChunks.join('\n') : "המשתמש החל למלא את השאלון אך לא נמצאו תשובות תקפות לעיבוד."
    };
}


// 5. --- Main Service Functions ---

export async function generateNarrativeProfile(userId: string): Promise<string | null> {
  const user: UserWithRelations | null = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      profile: true,
      questionnaireResponses: { orderBy: { lastSaved: 'desc' }, take: 1 },
    },
  });

  if (!user || !user.profile) {
    console.error(`Could not generate narrative profile: User or Profile not found for userId: ${userId}`);
    return null;
  }

  const { profile, questionnaireResponses } = user;
  const questionnaire = questionnaireResponses[0];

  const calculateAge = (birthDate: Date): number => {
    const today = new Date();
    const age = today.getFullYear() - birthDate.getFullYear();
    const m = today.getMonth() - birthDate.getMonth();
    return (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) ? age - 1 : age;
  };
  const age = calculateAge(profile.birthDate);
  
  const questionnaireData = processQuestionnaireData(questionnaire);

  const religiousJourneyMap: Record<ReligiousJourney, string> = {
      BORN_INTO_CURRENT_LIFESTYLE: "גדל/ה בסביבה דתית הדומה לרמתו/ה כיום",
      BORN_SECULAR: "גדל/ה בסביבה חילונית",
      BAAL_TESHUVA: "חוזר/ת בתשובה",
      DATLASH: "יצא/ה בשאלה (דתל\"ש)",
      CONVERT: "גר/גיורת",
      IN_PROCESS: "בתהליך של שינוי/התחזקות/התלבטות דתית",
      OTHER: "בעל/ת רקע דתי אחר או מורכב"
  };

  const narrativeParts: string[] = [
    `# פרופיל AI עבור ${user.firstName} ${user.lastName}, ${profile.gender === 'MALE' ? 'גבר' : 'אישה'} בן/בת ${age}`,
    `## סיכום כללי`,
    `- **שם:** ${user.firstName} ${user.lastName}`,
    `- **גיל:** ${age} ${profile.birthDateIsApproximate ? '(משוער)' : ''}`,
    `- **מצב משפחתי:** ${formatDisplayValue(profile.maritalStatus)}`,
    `- **מגורים:** ${formatDisplayValue(profile.city)}`,
    `- **רמה דתית:** ${formatDisplayValue(profile.religiousLevel)}`,
    profile.religiousJourney ? `- **רקע/מסע דתי:** ${formatDisplayValue(religiousJourneyMap[profile.religiousJourney])}` : '',
    `- **עיסוק:** ${formatDisplayValue(profile.occupation)}`,
    `- **השכלה:** ${formatDisplayValue(profile.educationLevel)}, ${formatDisplayValue(profile.education)}`,
    `- **שומר/ת נגיעה:** ${formatDisplayValue(profile.shomerNegiah)}`,
    `- **רקע משפחתי:** מצב הורים: ${formatDisplayValue(profile.parentStatus)}. מקצוע האב: ${formatDisplayValue(profile.fatherOccupation)}. מקצוע האם: ${formatDisplayValue(profile.motherOccupation)}.`,
  ].filter(Boolean);

  if (user.source === 'MANUAL_ENTRY' && profile.manualEntryText) {
    narrativeParts.push(`\n**הערת שדכן (למועמד ידני):** ${profile.manualEntryText}`);
  }

  if (profile.about) {
    narrativeParts.push(`## קצת עליי (מהפרופיל)\n"${profile.about}"`);
  }

  // --- START: הוספת השדות הנרטיביים החדשים ---
  const personalInsightsParts = [
    profile.profileHeadline ? `**הכותרת האישית שלי:**\n"${profile.profileHeadline}"` : '',
    profile.humorStory ? `**סיפור שמדגים את חוש ההומור שלי:**\n${profile.humorStory}` : '',
    profile.inspiringCoupleStory ? `**זוג שמעורר בי השראה:**\n${profile.inspiringCoupleStory}` : '',
    profile.influentialRabbi ? `**דמות רוחנית שהשפיעה עליי:**\n${profile.influentialRabbi}` : ''
  ].filter(Boolean);

  if (personalInsightsParts.length > 0) {
    narrativeParts.push(`## תובנות אישיות נוספות\n${personalInsightsParts.join('\n\n')}`);
  }
  // --- END: הוספת השדות הנרטיביים החדשים ---

  if (profile.hasMedicalInfo) {
    narrativeParts.push(
      `## מידע רפואי`,
      `- **פירוט המידע:** ${formatDisplayValue(profile.medicalInfoDetails)}`,
      `- **תזמון חשיפה:** ${formatDisplayValue(profile.medicalInfoDisclosureTiming)}`,
      `- **המידע גלוי בפרופיל הציבורי:** ${profile.isMedicalInfoVisible ? 'כן' : 'לא'}`
    );
  }
  
  narrativeParts.push(
    `## תכונות אופי ותחביבים`,
    `- **תכונות בולטות:** ${formatArray(profile.profileCharacterTraits)}`,
    `- **תחביבים עיקריים:** ${formatArray(profile.profileHobbies)}`
  );
  
  const preferredJourneysText = (profile.preferredReligiousJourneys && profile.preferredReligiousJourneys.length > 0)
    ? formatArray(profile.preferredReligiousJourneys.map(j => religiousJourneyMap[j] || j))
    : "לא צוין";

  narrativeParts.push(
    `## מה אני מחפש/ת בבן/בת הזוג (העדפות מהפרופיל)`,
    `- **תיאור כללי:** ${formatDisplayValue(profile.matchingNotes)}`,
    `- **טווח גילאים מועדף:** ${formatDisplayValue(profile.preferredAgeMin, '?')} - ${formatDisplayValue(profile.preferredAgeMax, '?')}`,
    `- **רמות דתיות מועדפות:** ${formatArray(profile.preferredReligiousLevels)}`,
    `- **רקע/מסע דתי מועדף:** ${preferredJourneysText}`,
    `- **רמות השכלה מועדפות:** ${formatArray(profile.preferredEducation)}`,
    `- **מוצאים מועדפים:** ${formatArray(profile.preferredOrigins)}`
  );

  narrativeParts.push(
    `\n## ניתוח השלמת השאלון`,
    `- **סך הכל שאלות במערכת:** ${questionnaireData.totalCount}`,
    `- **שאלות שנענו:** ${questionnaireData.answeredCount}`,
    `- **אחוז השלמה:** ${questionnaireData.completionPercentage}%`,
    `\n## תובנות מהשאלון (תשובות מפורטות)\n${questionnaireData.answersNarrative}`
  );

  return narrativeParts.join('\n\n').trim();
}

export async function updateUserAiProfile(userId: string): Promise<void> {
  console.log(`Starting AI profile update for userId: ${userId}`);
  const profileText = await generateNarrativeProfile(userId);
  if (!profileText) {
    console.error(`Failed to generate narrative profile for userId: ${userId}. Aborting AI update.`);
    return;
  }

  const vector = await aiService.generateTextEmbedding(profileText);
  if (!vector) {
    console.error(`Failed to generate vector embedding for userId: ${userId}. Aborting DB update.`);
    return;
  }

  try {
    const profile = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });
    if (!profile) {
      console.error(`No profile found for userId: ${userId} to save the vector against.`);
      return;
    }
    
    const vectorSqlString = `[${vector.join(',')}]`;
    await prisma.$executeRaw`
      INSERT INTO "profile_vectors" ("profileId", vector, "updatedAt")
      VALUES (${profile.id}, ${vectorSqlString}::vector, NOW())
      ON CONFLICT ("profileId")
      DO UPDATE SET
        vector = EXCLUDED.vector,
        "updatedAt" = NOW();
    `;
    console.log(`Successfully updated AI profile and vector for userId: ${userId} (profileId: ${profile.id})`);
  } catch (error) {
    console.error(`Error saving profile vector to DB for userId: ${userId}:`, error);
  }
}

const profileAiService = {
  generateNarrativeProfile,
  updateUserAiProfile,
};

export default profileAiService;
--- End of Content for profileAiService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\services_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\verificationService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/verificationService.ts
import { VerificationType, VerificationStatus, UserStatus, Prisma } from '@prisma/client';
import { randomInt } from 'crypto'; // For OTP generation
import prisma from '@/lib/prisma'; // Assuming global prisma instance

const OTP_LENGTH = 6;
const MAX_VERIFICATION_ATTEMPTS = 5; // Example value

interface VerificationResult {
  success: boolean;
  message: string;
  userId?: string | null; // Can be null if user association isn't direct or fails
  id?: string; // ID of the verification record
}

export class VerificationService {
  static async createVerification(
    userId: string,
    type: VerificationType,
    target: string, // e.g., email address or phone number
    expiresInHours: number,
    tx?: Prisma.TransactionClient // Optional transaction client
  ): Promise<{ otp: string; verification: { id: string; token: string; expiresAt: Date } }> {
    const effectivePrisma = tx || prisma;
    const otp = randomInt(10**(OTP_LENGTH - 1), 10**OTP_LENGTH -1).toString().padStart(OTP_LENGTH, '0');
    const expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);

    // Invalidate previous PENDING verifications of the same type for this user/target
    // This is especially important for OTPs to ensure only the latest one is active.
    // For PASSWORD_RESET, this is handled in the API route before calling createVerification.
    // For EMAIL verification during registration, this might also be good practice.
    if (type === VerificationType.EMAIL || type === VerificationType.PHONE_WHATSAPP) {
        await effectivePrisma.verification.updateMany({
            where: {
                // If userId is available and relevant for uniqueness (e.g. for EMAIL type)
                ...(userId && { userId }), 
                // For PHONE_WHATSAPP, target (phone number) is more critical for pending check
                ...(!userId && { target }), 
                type: type,
                status: VerificationStatus.PENDING,
            },
            data: {
                status: VerificationStatus.EXPIRED, // Or 'CANCELLED'
            },
        });
    }


    const verification = await effectivePrisma.verification.create({
      data: {
        userId,
        type,
        token: otp,
        target: target.toLowerCase(), // Normalize target (e.g. email)
        expiresAt,
        status: VerificationStatus.PENDING,
        attempts: 0,
      },
      select: { id: true, token: true, expiresAt: true } // Return only necessary fields
    });

    return { otp, verification };
  }

  static async verifyCode(
    code: string,
    type: VerificationType,
    target?: string // Target (e.g., email for password reset, phone for phone verify)
  ): Promise<VerificationResult & { userId: string | null }> { // Ensure userId is part of the promise
    const normalizedTarget = target?.toLowerCase();

    const verification = await prisma.verification.findFirst({
      where: {
        token: code,
        type,
        ...(normalizedTarget && { target: normalizedTarget }), // Use target if provided
        status: VerificationStatus.PENDING,
      },
      orderBy: {
        createdAt: 'desc', // Get the most recent one if multiple match (should be rare)
      },
    });

    if (!verification) {
      throw new Error('קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.');
    }

    if (new Date() > verification.expiresAt) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: VerificationStatus.EXPIRED },
      });
      throw new Error('תוקף הקוד פג. אנא בקש קוד חדש.');
    }

    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: VerificationStatus.FAILED },
      });
      throw new Error('חרגת ממספר ניסיונות האימות המותר. אנא בקש קוד חדש.');
    }

    // If code is correct (Implicitly, as we found it by token)
    // Increment attempts
    await prisma.verification.update({
      where: { id: verification.id },
      data: { 
        attempts: { increment: 1 },
        // DO NOT set to COMPLETED yet for PASSWORD_RESET.
        // Only set to COMPLETED after password has been updated in DB by the calling API.
        // For EMAIL verification, we can set to COMPLETED here.
        ...(type === VerificationType.EMAIL && { 
            status: VerificationStatus.COMPLETED,
            completedAt: new Date()
        })
      },
    });
    
    if (!verification.userId) {
        // This should not happen if the verification record was created correctly with a userId
        console.error(`VerificationService: userId missing on verification record ${verification.id} for type ${type} and target ${target}`);
        throw new Error('שגיאה פנימית: רשומת האימות אינה משויכת למשתמש.');
    }

    // For EMAIL verification type, update user status as well
    if (type === VerificationType.EMAIL && verification.userId) {
      const user = await prisma.user.findUnique({ where: {id: verification.userId }});
      if (user && !user.isVerified) { // Only update if not already verified
        await prisma.user.update({
          where: { id: verification.userId },
          data: {
            isVerified: true,
            // Only update status if it's PENDING_EMAIL_VERIFICATION
            ...(user.status === UserStatus.PENDING_EMAIL_VERIFICATION && {
                status: UserStatus.PENDING_PHONE_VERIFICATION, // Or ACTIVE if phone verification is not mandatory next
            }),
            updatedAt: new Date(),
          },
        });
      }
    }
    
    // For PASSWORD_RESET, the calling API (`/api/auth/reset-password`) will handle updating the password
    // and THEN it should explicitly mark the verification record as COMPLETED.
    // This function's role is just to validate the OTP itself.

    return {
      success: true,
      message: 'Code verified.',
      userId: verification.userId, // Return userId
      id: verification.id // Return verification record id
    };
  }

  // New method to explicitly complete a verification, e.g., after password reset
  static async completeVerification(verificationId: string): Promise<void> {
    await prisma.verification.update({
        where: { id: verificationId },
        data: {
            status: VerificationStatus.COMPLETED,
            completedAt: new Date(),
        },
    });
  }
}
--- End of Content for verificationService.ts ---

