################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib
# Generated on: 2025-10-03 16:47:23
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\auth.ts
--------------------------------------------------------------------------------
Content:
// lib/auth.ts

import { PrismaAdapter } from "@next-auth/prisma-adapter";
import { NextAuthOptions, Profile as OAuthProfile } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import prisma from "./prisma";
import { compare } from "bcryptjs";
import type {
  User as ExtendedUser,
  UserProfile,
  UserImage,
  QuestionnaireResponse
} from "@/types/next-auth";
import { JWT as ExtendedUserJWT } from "next-auth/jwt";
import { Session as ExtendedSession } from "next-auth";
import { UserRole, UserStatus, UserSource } from "@prisma/client";

console.log("Auth options file loaded");

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  debug: process.env.NODE_ENV === "development",

  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
        },
      },
      profile(profile: OAuthProfile & { sub?: string; given_name?: string; family_name?: string; picture?: string; email_verified?: boolean }, tokens) {
        const now = new Date();
        console.log("[GoogleProvider Profile Fn] Raw profile from Google:", profile);
        console.log("[GoogleProvider Profile Fn] Tokens from Google:", tokens);
    
        if (!profile.email) {
          throw new Error("Email not found in Google profile");
        }
        if (!profile.sub) {
          throw new Error("Sub (Google User ID) not found in Google profile");
        }
    
        const firstName = profile.given_name || profile.name?.split(' ')[0] || "";
        const lastName = profile.family_name || profile.name?.split(' ').slice(1).join(' ') || "";

        const userForAdapter: ExtendedUser = {
          id: profile.sub, 
          email: profile.email.toLowerCase(),
          firstName: firstName,
          lastName: lastName,
          name: profile.name || `${firstName} ${lastName}`.trim(), 
          phone: null, 
          image: profile.picture || null, 
          role: UserRole.CANDIDATE,
          status: UserStatus.PENDING_PHONE_VERIFICATION,
          isVerified: !!profile.email_verified,
          isProfileComplete: false,
          isPhoneVerified: false,
          lastLogin: null, 
          createdAt: now,
          updatedAt: now,
          source: UserSource.REGISTRATION, 
          addedByMatchmakerId: null,  
           termsAndPrivacyAcceptedAt: null,
          profile: null, 
          images: [], 
          questionnaireResponses: [],
          questionnaireCompleted: false,

          redirectUrl: undefined,
          newlyCreated: true, 
          requiresCompletion: true, 
        };
    
        console.log("[GoogleProvider Profile Fn] User object for adapter:", userForAdapter);
        return userForAdapter;
      }
    }),
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        console.log("[CredentialsProvider Authorize] Attempting login for:", credentials?.email);
        if (!credentials?.email || !credentials?.password) {
          console.error("[CredentialsProvider Authorize] Missing email or password");
          return null;
        }

        const userFromDb = await prisma.user.findUnique({
          where: { email: credentials.email.toLowerCase() },
          include: {
            images: { where: { isMain: true }, take: 1 },
          }
        });

        if (!userFromDb || !userFromDb.password) {
          console.log(`[CredentialsProvider Authorize] User ${credentials.email} not found or password not set.`);
          return null;
        }

        const isPasswordValid = await compare(credentials.password, userFromDb.password);
        if (!isPasswordValid) {
          console.log(`[CredentialsProvider Authorize] Invalid password for ${credentials.email}.`);
          return null;
        }

        console.log(`[CredentialsProvider Authorize] Authentication successful for ${credentials.email}`);
        await prisma.user.update({
          where: { id: userFromDb.id },
          data: { lastLogin: new Date() }
        }).catch(err => console.error("[CredentialsProvider Authorize] Failed to update lastLogin:", err));

        const { images, ...restOfUser } = userFromDb;
        return {
          ...restOfUser,
          name: `${userFromDb.firstName} ${userFromDb.lastName}`,
          image: images?.[0]?.url || null, 
          profile: null, // We do not load heavy data here
          images: [],
          questionnaireResponses: [],
          questionnaireCompleted: false, // Will be determined in JWT callback
          source: userFromDb.source,
          addedByMatchmakerId: userFromDb.addedByMatchmakerId,
           termsAndPrivacyAcceptedAt: userFromDb.termsAndPrivacyAcceptedAt,
        } as ExtendedUser;
      }
    }),
    CredentialsProvider({
      id: "email-verified-autologin",
      name: "Email Verified AutoLogin",
      credentials: {
        authToken: { label: "Auth Token", type: "text" },
      },
      async authorize(credentials) {
        console.log("[AutoLoginProvider Authorize] Attempting auto-login with token:", credentials?.authToken ? "Token Present" : "No Token");
        if (!credentials?.authToken) {
          console.error("[AutoLoginProvider Authorize] No authToken provided.");
          return null;
        }

        const tokenRecord = await prisma.oneTimeAuthToken.findUnique({
          where: { token: credentials.authToken },
        });

        if (!tokenRecord) {
          console.log("[AutoLoginProvider Authorize] AuthToken not found in DB.");
          return null;
        }

        if (new Date() > tokenRecord.expiresAt) {
          console.log("[AutoLoginProvider Authorize] AuthToken expired. Deleting token.");
          await prisma.oneTimeAuthToken.delete({ where: { id: tokenRecord.id } }).catch(err => console.error("[AutoLoginProvider Authorize] Error deleting expired token:", err));
          return null;
        }

        console.log("[AutoLoginProvider Authorize] AuthToken valid. Deleting token.");
        await prisma.oneTimeAuthToken.delete({ where: { id: tokenRecord.id } }).catch(err => console.error("[AutoLoginProvider Authorize] Error deleting used token:", err));

        const userFromDb = await prisma.user.findUnique({
          where: { id: tokenRecord.userId },
          include: {
            images: { where: { isMain: true }, take: 1 },
          }
        });

        if (!userFromDb) {
          console.log("[AutoLoginProvider Authorize] User not found for the given authToken.");
          return null;
        }
        console.log(`[AutoLoginProvider Authorize] Auto-login successful for user ${userFromDb.email}`);
        
        const { images, ...restOfUser } = userFromDb;
        return {
          ...restOfUser,
          name: `${userFromDb.firstName} ${userFromDb.lastName}`,
          image: images?.[0]?.url || null,
          profile: null,
          images: [],
          questionnaireResponses: [],
          questionnaireCompleted: false,
          source: userFromDb.source,
          addedByMatchmakerId: userFromDb.addedByMatchmakerId,
           termsAndPrivacyAcceptedAt: userFromDb.termsAndPrivacyAcceptedAt,
        } as ExtendedUser;
      },
    }),
  ],

 // הדבק את הקוד הזה במקום כל בלוק ה-callbacks הקיים

  callbacks: {
    async signIn({ user, account, profile }) {
      const typedUser = user as ExtendedUser; 
      const oauthProfile = profile as OAuthProfile & { email_verified?: boolean };
      console.log("[signIn Callback] Triggered.", {
        userId: typedUser.id,
        userEmail: typedUser.email,
        accountProvider: account?.provider,
        isUserVerifiedByProvider: oauthProfile?.email_verified,
        accountId: account?.providerAccountId
      });
    
      const userEmail = typedUser.email?.toLowerCase();
      if (!userEmail) {
        console.error("[signIn Callback] Critical: No user email available.", { user, account });
        return false;
      }

      let dbUser = await prisma.user.findUnique({
        where: { email: userEmail },
      });
    
      if (!dbUser && account?.provider === 'google') {
        console.log(`[signIn Callback] Google sign-in for potentially new user: ${userEmail}.`);
        
        dbUser = await prisma.user.findUnique({ 
            where: { email: userEmail } 
        });

        if (!dbUser) {
            try {
                console.log(`[signIn Callback] User ${userEmail} not found. Attempting to create.`);
                const createdDbUser = await prisma.user.create({
                    data: {
                        email: userEmail,
                        firstName: typedUser.firstName || "", 
                        lastName: typedUser.lastName || "",  
                        role: typedUser.role || UserRole.CANDIDATE,
                        status: typedUser.status || UserStatus.PENDING_PHONE_VERIFICATION,
                        isVerified: typedUser.isVerified === undefined ? (!!oauthProfile?.email_verified) : typedUser.isVerified,
                        isProfileComplete: typedUser.isProfileComplete || false,
                        isPhoneVerified: typedUser.isPhoneVerified || false,
                        source: UserSource.REGISTRATION,
                    },
                });
                dbUser = createdDbUser; 
                console.log(`[signIn Callback] Created new user ${dbUser.email} during signIn.`);

                if (account && account.providerAccountId) {
                    const existingAccount = await prisma.account.findUnique({
                        where: { provider_providerAccountId: { provider: account.provider, providerAccountId: account.providerAccountId }}
                    });
                    if (!existingAccount) {
                        await prisma.account.create({
                            data: {
                                userId: dbUser.id,
                                type: account.type,
                                provider: account.provider,
                                providerAccountId: account.providerAccountId,
                                access_token: account.access_token,
                                refresh_token: account.refresh_token,
                                expires_at: account.expires_at,
                                token_type: account.token_type,
                                scope: account.scope,
                                id_token: account.id_token,
                                session_state: account.session_state,
                            },
                        });
                        console.log(`[signIn Callback] Linked Google account for ${dbUser.email}`);
                    }
                }
              } catch (error: unknown) { 
                console.error("[signIn Callback] Failed to create user or link account:", error);
                
                if (typeof error === 'object' && error !== null && 'code' in error && 'meta' in error) {
                    const prismaError = error as { code?: string; meta?: { target?: string[] } }; 
                    if (prismaError.code === 'P2002' && prismaError.meta?.target?.includes('email')) {
                        console.log("[signIn Callback] User likely created by adapter in parallel. Re-fetching.");
                        dbUser = await prisma.user.findUnique({ where: { email: userEmail }});
                        if (!dbUser) {
                            console.error("[signIn Callback] Failed to re-fetch user after P2002 error.");
                            return false;
                        }
                    } else {
                        return false; 
                    }
                } else {
                  console.error("[signIn Callback] An unexpected error type occurred:", error);
                  return false;
                }
            }
        }
      }
    
      if (!dbUser) {
        console.error(`[signIn Callback] User with email ${userEmail} not found and could not be created.`);
        return false;
      }
    
      // כאן אנו מעבירים את המידע מה-DB לאובייקט ה-user שישמש בהמשך
      typedUser.id = dbUser.id; 
      typedUser.email = dbUser.email;
      typedUser.firstName = dbUser.firstName;
      typedUser.lastName = dbUser.lastName;
      typedUser.name = `${dbUser.firstName} ${dbUser.lastName}`.trim(); 
      typedUser.role = dbUser.role;
      typedUser.status = dbUser.status;
      typedUser.isVerified = dbUser.isVerified;
      typedUser.isProfileComplete = dbUser.isProfileComplete;
      typedUser.isPhoneVerified = dbUser.isPhoneVerified;
      typedUser.source = dbUser.source;
      typedUser.addedByMatchmakerId = dbUser.addedByMatchmakerId;
      typedUser.termsAndPrivacyAcceptedAt = dbUser.termsAndPrivacyAcceptedAt;
      typedUser.marketingConsent = dbUser.marketingConsent;
      typedUser.createdAt = dbUser.createdAt; // מעבירים את התאריך
      typedUser.updatedAt = dbUser.updatedAt; // מעבירים את התאריך
      typedUser.lastLogin = dbUser.lastLogin; // מעבירים את התאריך

      if (account?.provider === "google") {
        if (dbUser.isVerified === false && oauthProfile?.email_verified === true) {
          console.log(`[signIn Callback] Google User ${dbUser.email} was not email-verified, but Google says it is. Updating DB.`);
          const updatedUser = await prisma.user.update({
            where: { id: dbUser.id },
            data: { isVerified: true, status: UserStatus.PENDING_PHONE_VERIFICATION }
          });
          typedUser.isVerified = updatedUser.isVerified;
          typedUser.status = updatedUser.status;
        }
      }
    
      await prisma.user.update({
        where: { id: dbUser.id },
        data: { lastLogin: new Date() }
      }).catch(err => console.error(`[signIn Callback] Failed to update lastLogin for user ${dbUser.id}:`, err));
    
      const requiresCompletion = !dbUser.isProfileComplete || !dbUser.isPhoneVerified || !dbUser.termsAndPrivacyAcceptedAt;
      typedUser.requiresCompletion = requiresCompletion;

      if (requiresCompletion) {
        typedUser.redirectUrl = '/auth/register';
      } else {
        typedUser.redirectUrl = '/profile';
      }
    
      console.log("[signIn Callback] Processed user. Flags:", {
        requiresCompletion: typedUser.requiresCompletion,
        redirectUrl: typedUser.redirectUrl,
      });
      return true;
    },

    async jwt({ token, user, trigger }) {
      const typedToken = token as ExtendedUserJWT;
      const typedUserFromCallback = user as ExtendedUser | undefined;

      // שלב 1: אנו שומרים את התאריכים כאובייקט Date תקין בתוך הטוקן.
      // next-auth יהפוך אותם למחרוזת טקסט באופן אוטומטי "מאחורי הקלעים".

      // בכניסה ראשונית למערכת
      if (typedUserFromCallback) {
        typedToken.id = typedUserFromCallback.id;
        typedToken.email = typedUserFromCallback.email.toLowerCase();
        typedToken.firstName = typedUserFromCallback.firstName;
        typedToken.lastName = typedUserFromCallback.lastName;
        typedToken.name = typedUserFromCallback.name || `${typedUserFromCallback.firstName} ${typedUserFromCallback.lastName}`.trim();
        typedToken.picture = typedUserFromCallback.image || null; 
        typedToken.role = typedUserFromCallback.role;
        typedToken.status = typedUserFromCallback.status;
        typedToken.isVerified = typedUserFromCallback.isVerified;
        typedToken.isProfileComplete = typedUserFromCallback.isProfileComplete || false;
        typedToken.isPhoneVerified = typedUserFromCallback.isPhoneVerified || false;
        typedToken.questionnaireCompleted = typedUserFromCallback.questionnaireCompleted; 
        typedToken.source = typedUserFromCallback.source;
        typedToken.addedByMatchmakerId = typedUserFromCallback.addedByMatchmakerId;
        typedToken.termsAndPrivacyAcceptedAt = typedUserFromCallback.termsAndPrivacyAcceptedAt;
        typedToken.requiresCompletion = typedUserFromCallback.requiresCompletion;
        typedToken.redirectUrl = typedUserFromCallback.redirectUrl;
        typedToken.marketingConsent = typedUserFromCallback.marketingConsent;
        // לקיחת התאריכים כאובייקט Date
        typedToken.createdAt = typedUserFromCallback.createdAt;
        typedToken.updatedAt = typedUserFromCallback.updatedAt;
        typedToken.lastLogin = typedUserFromCallback.lastLogin;
      }
      
      // ברענון של הסשן או עדכון
      if (typedToken.id && (trigger === "update" || trigger === "signIn")) {
          const dbUserForJwt = await prisma.user.findUnique({
            where: { id: typedToken.id },
            include: {
              images: { where: { isMain: true }, take: 1 },
            }
          });

          if (dbUserForJwt) {
            typedToken.firstName = dbUserForJwt.firstName;
            typedToken.lastName = dbUserForJwt.lastName;
            typedToken.picture = dbUserForJwt.images?.[0]?.url || typedToken.picture; 
            typedToken.role = dbUserForJwt.role;
            typedToken.status = dbUserForJwt.status;
            typedToken.isVerified = dbUserForJwt.isVerified;
            typedToken.isProfileComplete = dbUserForJwt.isProfileComplete;
            typedToken.isPhoneVerified = dbUserForJwt.isPhoneVerified;
            typedToken.source = dbUserForJwt.source;
            typedToken.addedByMatchmakerId = dbUserForJwt.addedByMatchmakerId;
            typedToken.termsAndPrivacyAcceptedAt = dbUserForJwt.termsAndPrivacyAcceptedAt;
            typedToken.marketingConsent = dbUserForJwt.marketingConsent;
            // רענון התאריכים מה-DB כאובייקט Date
            typedToken.createdAt = dbUserForJwt.createdAt;
            typedToken.updatedAt = dbUserForJwt.updatedAt;
            typedToken.lastLogin = dbUserForJwt.lastLogin;

            const questionnaireStatus = await prisma.questionnaireResponse.findFirst({
              where: { userId: typedToken.id },
              select: { completed: true },
              orderBy: { createdAt: 'desc' },
            });
            typedToken.questionnaireCompleted = questionnaireStatus?.completed ?? false;

            const requiresCompletionFromDb = (!dbUserForJwt.isProfileComplete || !dbUserForJwt.isPhoneVerified || !dbUserForJwt.termsAndPrivacyAcceptedAt);
            typedToken.requiresCompletion = requiresCompletionFromDb;
            typedToken.redirectUrl = requiresCompletionFromDb ? '/auth/register' : '/profile';
          }
      }
      
      return typedToken;
    },

     async session({ session, token }) {
      const typedToken = token as ExtendedUserJWT;
      const typedSession = session as ExtendedSession;

      if (typedSession.user && typedToken.id) {
        typedSession.user.id = typedToken.id;
        typedSession.user.email = typedToken.email;
        typedSession.user.firstName = typedToken.firstName;
        typedSession.user.lastName = typedToken.lastName;
        typedSession.user.name = typedToken.name ?? null; 
        typedSession.user.image = typedToken.picture ?? null; 
        typedSession.user.role = typedToken.role;
        typedSession.user.status = typedToken.status;
        typedSession.user.isVerified = typedToken.isVerified;
        typedSession.user.isProfileComplete = typedToken.isProfileComplete;
        typedSession.user.isPhoneVerified = typedToken.isPhoneVerified;
        typedSession.user.questionnaireCompleted = typedToken.questionnaireCompleted;
        typedSession.user.hasCompletedOnboarding = typedToken.hasCompletedOnboarding as boolean;
        typedSession.user.source = typedToken.source;
        typedSession.user.addedByMatchmakerId = typedToken.addedByMatchmakerId;
        typedSession.user.marketingConsent = typedToken.marketingConsent;
        
        // =================== התיקון הסופי והנכון ===================
        // אנו משתמשים ב- 'as unknown as string' כדי לבצע המרה בטוחה
        // שהיא גם מפורשת ומסבירה ל-TypeScript את כוונתנו.
        
        if (typedToken.createdAt) {
          typedSession.user.createdAt = new Date(typedToken.createdAt as unknown as string);
        }
        if (typedToken.updatedAt) {
          typedSession.user.updatedAt = new Date(typedToken.updatedAt as unknown as string);
        }
        if (typedToken.lastLogin) {
          typedSession.user.lastLogin = new Date(typedToken.lastLogin as unknown as string);
        }
        if (typedToken.termsAndPrivacyAcceptedAt) {
          typedSession.user.termsAndPrivacyAcceptedAt = new Date(typedToken.termsAndPrivacyAcceptedAt as unknown as string);
        }
        // ================================================================
        
        typedSession.requiresCompletion = typedToken.requiresCompletion;
        typedSession.redirectUrl = typedToken.redirectUrl;
      }
      return typedSession;
    },

    async redirect({ url, baseUrl }) {
        console.log(`[Redirect Callback] Triggered with url: ${url}`);
        
        if (url.startsWith('/')) {
            const finalUrl = `${baseUrl}${url}`;
            console.log(`[Redirect Callback] Relative URL detected. Returning: ${finalUrl}`);
            return finalUrl;
        }
        
        if (new URL(url).origin === baseUrl) {
            console.log(`[Redirect Callback] Same origin URL detected. Returning: ${url}`);
            return url;
        }
        
        console.log(`[Redirect Callback] External URL detected. Redirecting to baseUrl: ${baseUrl}`);
        return baseUrl;
    }
  },
  pages: {
    signIn: '/auth/signin',
    error: '/auth/error',
    verifyRequest: '/auth/verify-request'
  },

  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },

  secret: process.env.NEXTAUTH_SECRET,
  jwt: {
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  useSecureCookies: process.env.NODE_ENV === "production",
};

export default authOptions;
--- End of Content for auth.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\db.ts
--------------------------------------------------------------------------------
Content:
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

type PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>

declare global {
  // Using interface instead of var for global augmentation
  interface Global {
    prisma: PrismaClientSingleton | undefined
  }
}

const prismaGlobal = global as { prisma?: PrismaClientSingleton }
export const db = prismaGlobal.prisma ?? prismaClientSingleton()

if (process.env.NODE_ENV !== 'production') prismaGlobal.prisma = db
--- End of Content for db.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\dictionaries.ts
--------------------------------------------------------------------------------
Content:
// src/lib/dictionaries.ts

import 'server-only';
import type { Locale } from '../../i18n-config';
import type { 
  Dictionary, 
  QuestionnaireDictionary, 
  AuthDictionary, 
  EmailDictionary
} from '@/types/dictionary';

// --- הגדרת טוענים (Loaders) עבור כל מודול של המילון ---
// כל טוען הוא אובייקט המכיל פונקציות ייבוא דינמיות עבור כל שפה נתמכת.
// גישה זו מבטיחה שנטען רק את קבצי השפה הנדרשים (Code Splitting).

const mainDictionaries = {
  en: () => import('../../dictionaries/en.json').then((module) => module.default),
  he: () => import('../../dictionaries/he.json').then((module) => module.default),
};

const authDictionaries = {
  en: () => import('../../dictionaries/auth/en.json').then((module) => module.default),
  he: () => import('../../dictionaries/auth/he.json').then((module) => module.default),
};

const suggestionsDictionaries = {
  en: () => import('../../dictionaries/suggestions/en.json').then((module) => module.default),
  he: () => import('../../dictionaries/suggestions/he.json').then((module) => module.default),
};

const questionnaireDictionaries = {
  en: () => import('../../dictionaries/questionnaire/en.json').then((module) => module.default),
  he: () => import('../../dictionaries/questionnaire/he.json').then((module) => module.default),
};

const questionnaireQuestionsDictionaries = {
  en: () => import('../../dictionaries/questionnaire/questions.en.json').then((module) => module.default),
  he: () => import('../../dictionaries/questionnaire/questions.he.json').then((module) => module.default),
};

const profileDictionaries = {
  en: () => import('../../dictionaries/profile/en.json').then((module) => module.default),
  he: () => import('../../dictionaries/profile/he.json').then((module) => module.default),
};

const matchmakerDictionaries = {
  en: () => import('../../dictionaries/matchmaker/en.json').then((module) => module.default),
  he: () => import('../../dictionaries/matchmaker/he.json').then((module) => module.default),
};

const emailDictionaries = {
  en: () => import('../../dictionaries/email/en.json').then((module) => module.default),
  he: () => import('../../dictionaries/email/he.json').then((module) => module.default),
};


/**
 * טוען את כל מודולי המילון עבור שפה (locale) נתונה ומרכיב אותם לאובייקט אחד שלם.
 * @param locale השפה לטעינה ('en' או 'he').
 * @returns Promise שנפתר לאובייקט המילון המלא והמובנה.
 */
export const getDictionary = async (locale: Locale): Promise<Dictionary> => {
  // קביעת השפה לטעינה, עם עברית ('he') כשפת ברירת מחדל אם השפה המבוקשת אינה זמינה.
  const targetLocale = mainDictionaries[locale] ? locale : 'he';

  // טעינה מקבילית של כל חלקי המילון באמצעות Promise.all לביצועים מיטביים.
  const [
    main, 
    auth,
    suggestions, 
    questionnaireBase, 
    profilePage, 
    matchmakerPage,
    email
  ] = await Promise.all([
    mainDictionaries[targetLocale](),
    authDictionaries[targetLocale](),
    suggestionsDictionaries[targetLocale](),
    questionnaireDictionaries[targetLocale](),
    profileDictionaries[targetLocale](),
    matchmakerDictionaries[targetLocale](),
    emailDictionaries[targetLocale](),
  ]);

  // טיפול מיוחד במילון השאלון:
  // טוענים בנפרד את קובץ השאלות ומשלבים אותו עם קובץ הבסיס של השאלון.
  const questionsContent = await questionnaireQuestionsDictionaries[targetLocale]();

  // הרכבת אובייקט השאלון השלם
  const questionnaire: QuestionnaireDictionary = {
    ...(questionnaireBase as Omit<QuestionnaireDictionary, 'questions'>),
    questions: questionsContent,
  };

  // הרכבת אובייקט המילון הסופי והשלם, כולל כל המודולים שנטענו.
  return {
    ...main, // פורס את כל התוכן מהמילון הראשי (en.json / he.json)
    auth: auth as AuthDictionary,
    suggestions,
    questionnaire,
    profilePage,
    matchmakerPage,
    email: email as EmailDictionary,
  } as Dictionary;
};

/**
 * טוען באופן ספציפי רק את מילון השאלות של השאלון עבור שפה נתונה.
 * פונקציה זו שימושית עבור רכיבי צד-שרת או API routes שצריכים גישה לתרגומי השאלות.
 * @param locale השפה לטעינה ('en' או 'he').
 * @returns Promise שנפתר לאובייקט מילון השאלות (questions).
 */
export const getQuestionnaireQuestionsDictionary = async (locale: Locale) => {
  const targetLocale = questionnaireQuestionsDictionaries[locale] ? locale : 'he';
  const questionsContent = await questionnaireQuestionsDictionaries[targetLocale]();
  return questionsContent;
};
--- End of Content for dictionaries.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\languageOptions.ts
--------------------------------------------------------------------------------
Content:
// src/lib/languageOptions.ts (או נתיב אחר שתבחר)

export interface LanguageOption {
  value: string;
  label: string;
}

const preferredLanguagesValues: string[] = [
  "hebrew",
  "yiddish",
  "ladino",
  "english",
  "french",
  "spanish",
  "russian",
  "german",
  "portuguese",
  "italian",
  "arabic", // חשובה ליהודים מארצות ערב וליהודים בישראל
  "amharic", // לקהילת יוצאי אתיופיה
  "hungarian",
  "polish",
  "romanian",
  "dutch",
  "persian", // לקהילת יוצאי איראן
  "georgian", // לקהילת יוצאי גאורגיה
  "turkish", // לקהילות יהודיות בטורקיה ובבלקן
  "ukrainian",
  // אפשר להוסיף כאן עוד ערכי 'value' של שפות שחשוב לך שיופיעו למעלה
];

const allLanguageOptions: LanguageOption[] = [
  // רשימת 100 השפות מהתשובה הקודמת נכנסת כאן.
  // לצורך קיצור, אשים רק חלק, אבל תעתיק את הרשימה המלאה שסיפקתי קודם.
  { value: "uzbek", label: "אוזבקית" },
  { value: "ukrainian", label: "אוקראינית" },
  { value: "urdu", label: "אורדו" },
  { value: "oromo", label: "אורומו" },
  { value: "azerbaijani", label: "אזרית" },
  { value: "igbo", label: "איגבו" },
  { value: "italian", label: "איטלקית" },
  { value: "indonesian", label: "אינדונזית" },
  { value: "icelandic", label: "איסלנדית" },
  { value: "irish_gaelic", label: "אירית (גאלית)" },
  { value: "albanian", label: "אלבנית" },
  { value: "amharic", label: "אמהרית" },
  { value: "english", label: "אנגלית" },
  { value: "estonian", label: "אסטונית" },
  { value: "esperanto", label: "אספרנטו" },
  { value: "afrikaans", label: "אפריקאנס" },
  { value: "armenian", label: "ארמנית" },
  { value: "bashkir", label: "בשקירית" },
  { value: "bulgarian", label: "בולגרית" },
  { value: "bosnian", label: "בוסנית" },
  { value: "burmese_myanmar", label: "בורמזית (מיאנמרית)" },
  { value: "belarusian", label: "בלארוסית" },
  { value: "bengali", label: "בנגלית" },
  { value: "basque", label: "בסקית" },
  { value: "breton", label: "ברטונית" },
  { value: "georgian", label: "גאורגית" },
  { value: "gujarati", label: "גוג'ראטית" },
  { value: "guarani", label: "גוארני" },
  { value: "galician", label: "גליסית" },
  { value: "german", label: "גרמנית" },
  { value: "danish", label: "דנית" },
  { value: "hausa", label: "האוסה" },
  { value: "hawaiian", label: "הוואית" },
  { value: "dutch", label: "הולנדית" },
  { value: "hungarian", label: "הונגרית" },
  { value: "hindi", label: "הינדי" },
  { value: "vietnamese", label: "וייטנאמית" },
  { value: "welsh", label: "וולשית" },
  { value: "zulu", label: "זולו" },
  { value: "khmer_cambodian", label: "חמר (קמבודית)" },
  { value: "tagalog_filipino", label: "טאגאלוג (פיליפינית)" },
  { value: "tatar", label: "טטרית" },
  { value: "turkish", label: "טורקית" },
  { value: "turkmen", label: "טורקמנית" },
  { value: "tigrinya", label: "טיגרינית" },
  { value: "tibetan", label: "טיבטית" },
  { value: "telugu", label: "טלוגו" },
  { value: "tamil", label: "טמילית" },
  { value: "yiddish", label: "יידיש" },
  { value: "yoruba", label: "יורובה" },
  { value: "japanese", label: "יפנית" },
  { value: "greek", label: "יוונית" },
  { value: "ladino", label: "לדינו" },
  { value: "lao", label: "לאו (לאוטית)" },
  { value: "luxembourgish", label: "לוקסמבורגית" },
  { value: "latvian", label: "לטבית" },
  { value: "lithuanian", label: "ליטאית" },
  { value: "maori", label: "מאורית" },
  { value: "mongolian", label: "מונגולית" },
  { value: "malayalam", label: "מלאיאלאם" },
  { value: "malay", label: "מלאית" },
  { value: "maltese", label: "מלטזית" },
  { value: "macedonian", label: "מקדונית" },
  { value: "marathi", label: "מראטהית" },
  { value: "norwegian", label: "נורווגית" },
  { value: "nepali", label: "נפאלית" },
  { value: "swahili", label: "סוואהילי" },
  { value: "somali", label: "סומלית" },
  { value: "sanskrit", label: "סנסקריט" },
  { value: "sinhala", label: "סינהלית" },
  { value: "chinese_mandarin", label: "סינית (מנדרינית)" },
  { value: "slovak", label: "סלובקית" },
  { value: "slovenian", label: "סלובנית" },
  { value: "serbian", label: "סרבית" },
  { value: "spanish", label: "ספרדית" },
  { value: "scottish_gaelic", label: "סקוטית גאלית" },
  { value: "hebrew", label: "עברית" },
  { value: "arabic", label: "ערבית" },
  { value: "faroese", label: "פארואזית" },
  { value: "papiamento", label: "פאפיאמנטו" },
  { value: "punjabi", label: "פנג'אבי" },
  { value: "pashto", label: "פשטו" },
  { value: "polish", label: "פולנית" },
  { value: "portuguese", label: "פורטוגזית" },
  { value: "finnish", label: "פינית" },
  { value: "flemish", label: "פלמית (ניב הולנדי)" },
  { value: "persian", label: "פרסית" },
  { value: "chuvash", label: "צ'ובשית" },
  { value: "czech", label: "צ'כית" },
  { value: "french", label: "צרפתית" },
  { value: "kurdish", label: "כורדית (כל הניבים)" },
  { value: "kazakh", label: "קזחית" },
  { value: "quechua", label: "קצ'ואה" },
  { value: "kyrgyz", label: "קירגיזית" },
  { value: "catalan", label: "קטלאנית" },
  { value: "kannada", label: "קנאדה" },
  { value: "croatian", label: "קרואטית" },
  { value: "korean", label: "קוריאנית" },
  { value: "haitian_creole", label: "קריאולית האיטית" },
  { value: "romanian", label: "רומנית" },
  { value: "russian", label: "רוסית" },
  { value: "swedish", label: "שוודית" },
  { value: "thai", label: "תאית" },
];

// פונקציית עזר למיון לפי מחרוזת בעברית
const hebrewSort = (a: LanguageOption, b: LanguageOption): number => {
  return a.label.localeCompare(b.label, "he");
};

// הפרדת השפות המועדפות מהשאר
const preferred = allLanguageOptions
  .filter(lang => preferredLanguagesValues.includes(lang.value))
  .sort(hebrewSort);

const others = allLanguageOptions
  .filter(lang => !preferredLanguagesValues.includes(lang.value))
  .sort(hebrewSort);

// איחוד הרשימות הממוינות
export const languageOptions: LanguageOption[] = [...preferred, ...others];
--- End of Content for languageOptions.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\lib_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\phoneVerificationService.ts
--------------------------------------------------------------------------------
Content:
// lib/phoneVerificationService.ts
import twilio from 'twilio';
import crypto from 'crypto';

// ודא שמשתני הסביבה הנדרשים קיימים
const accountSid = process.env.TWILIO_ACCOUNT_SID;
const authToken = process.env.TWILIO_AUTH_TOKEN;
const twilioWhatsAppNumber = process.env.TWILIO_WHATSAPP_NUMBER; // מספר השולח שלך, למשל +14155238886
const otpTemplateSid = process.env.TWILIO_OTP_TEMPLATE_SID; // ה-SID של התבנית (כרגע של match_suggestion)

let twilioClient: twilio.Twilio | null = null;

if (accountSid && authToken) {
    twilioClient = twilio(accountSid, authToken);
} else {
    console.error('[PhoneVerificationService] Error: Twilio Account SID or Auth Token not configured.');
}

// פונקציה ליצירת OTP
export function generateOtp(length: number = 6): string {
    const buffer = crypto.randomBytes(Math.ceil(length / 2));
    let code = buffer.toString('hex').slice(0, length);
    if (code.startsWith('0')) {
        code = '1' + code.slice(1);
    }
    while (code.length < length) {
        code = crypto.randomBytes(1).toString('hex').slice(0,1) + code;
    }
     code = code.replace(/[^0-9]/g, '');
     while (code.length < length) {
       code += Math.floor(Math.random() * 10).toString();
     }
     return code.slice(0, length);
}

// פונקציה לשליחת ה-OTP בוואטסאפ
export async function sendOtpViaWhatsApp(phoneNumber: string, otpCode: string, recipientName?: string): Promise<boolean> {
    if (!twilioClient) {
        console.error('[PhoneVerificationService] Error: Twilio client not initialized.');
        return false;
    }
    if (!twilioWhatsAppNumber) {
        console.error('[PhoneVerificationService] Error: Twilio WhatsApp sender number (TWILIO_WHATSAPP_NUMBER) is not configured.');
        return false;
    }
    if (!otpTemplateSid) {
        console.error('[PhoneVerificationService] Error: WhatsApp OTP Template SID (TWILIO_OTP_TEMPLATE_SID) is not configured. Cannot send templated message.');
        return false;
    }

    // --- התיקון המרכזי ---
    // אנו מניחים שה-phoneNumber כבר מגיע בפורמט E.164 מלא (למשל +14155552671)
    // ולכן מסירים את כל הלוגיקה שניסתה לנחש את הקידומת.
    if (!phoneNumber || !phoneNumber.startsWith('+')) {
        console.error(`[PhoneVerificationService] Error: Invalid phone number format. Expected E.164 format (e.g., +14155552671). Received: ${phoneNumber}`);
        return false;
    }

    const recipientWhatsAppNumber = `whatsapp:${phoneNumber}`;
    const senderWhatsAppNumber = `whatsapp:${twilioWhatsAppNumber}`;

    console.log(`[PhoneVerificationService] Attempting to send OTP via WhatsApp to ${recipientWhatsAppNumber}. Recipient: ${recipientName || 'N/A'}`);

    try {
        const contentVariables = JSON.stringify({
            '1': otpCode,
            // '2': recipientName || 'User' // Add if your template requires it
        });

        const message = await twilioClient.messages.create({
            contentSid: otpTemplateSid,
            contentVariables: contentVariables,
            to: recipientWhatsAppNumber,
            from: senderWhatsAppNumber,
        });

        console.log(`[PhoneVerificationService] WhatsApp OTP message sent successfully. SID: ${message.sid}`);
        return true;
    } catch (error) {

        console.error('[PhoneVerificationService] Error: Failed to send WhatsApp message via Twilio.');
        if (error instanceof Error) {
            console.error(`  Message: ${error.message}`);
            // בדיקה אם המאפיינים הספציפיים של Twilio קיימים לפני הגישה אליהם
            if (typeof error === 'object' && error !== null) {
                if ('code' in error) {
                    console.error(`  Twilio Error Code: ${(error as { code: unknown }).code}`);
                }
                if ('status' in error) {
                    console.error(`  HTTP Status: ${(error as { status: unknown }).status}`);
                }
                if ('moreInfo' in error) {
                    console.error(`  More Info: ${(error as { moreInfo: unknown }).moreInfo}`);
                }
            }
        } else {
            // אם השגיאה אינה מטיפוס Error סטנדרטי
            console.error('  An unexpected error occurred:', error);
        }
        return false;
    }
}
--- End of Content for phoneVerificationService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\prisma.ts
--------------------------------------------------------------------------------
Content:
// src/lib/prisma.ts - גרסה מותאמת ל-Heroku
import { PrismaClient } from '@prisma/client'

// הגדרות אופטימליות ל-Heroku
const prismaClientSingleton = () => {
  return new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    datasources: {
      db: {
        url: process.env.DATABASE_URL
      }
    },
    // הגדרות connection pool מתאימות ל-Heroku
    // Heroku Postgres מגביל ל-20 connections ב-hobby plan
    // ו-120 ב-standard plans
  })
}

type PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClientSingleton | undefined
}

const prisma = globalForPrisma.prisma ?? prismaClientSingleton()

// חשוב: מניעת memory leaks ב-development
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}

// פונקציה לניתוק בטוח (אופציונלי)
export async function disconnectPrisma() {
  try {
    await prisma.$disconnect()
  } catch (error) {
    console.error('Error disconnecting Prisma:', error)
  }
}

// פונקציה לבדיקת connection health
export async function checkDatabaseHealth() {
  try {
    await prisma.$queryRaw`SELECT 1`
    return { healthy: true }
  } catch (error) {
    console.error('Database health check failed:', error)
    return { healthy: false, error }
  }
}

export default prisma
--- End of Content for prisma.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\questionnaireFormatter.ts
--------------------------------------------------------------------------------
Content:
// src/lib/questionnaireFormatter.ts

import { Prisma } from "@prisma/client";
import { valuesQuestions } from "@/components/questionnaire/questions/values/valuesQuestions";
import { personalityQuestions } from "@/components/questionnaire/questions/personality/personalityQuestions";
import { relationshipQuestions } from "@/components/questionnaire/questions/relationship/relationshipQuestions";
import { partnerQuestions } from "@/components/questionnaire/questions/partner/partnerQuestions";
import { religionQuestions } from "@/components/questionnaire/questions/religion/religionQuestions";
import type { Question } from '@/components/questionnaire/types/types';
import type { FormattedAnswer, WorldId } from "@/types/next-auth"; 

// איחוד כל השאלות למקור מידע אחד
const allQuestions: Question[] = [
  ...valuesQuestions,
  ...personalityQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
];
const allQuestionsMap = new Map(allQuestions.map(q => [q.id, q]));

export type DbWorldKey =
  | 'valuesAnswers'
  | 'personalityAnswers'
  | 'relationshipAnswers'
  | 'partnerAnswers'
  | 'religionAnswers';

export const KEY_MAPPING: Record<WorldId, DbWorldKey> = {
  VALUES: 'valuesAnswers',
  PERSONALITY: 'personalityAnswers',
  RELATIONSHIP: 'relationshipAnswers',
  PARTNER: 'partnerAnswers',
  RELIGION: 'religionAnswers'
};

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

export type FormattedAnswersType = Record<WorldId, FormattedAnswer[]>;

const valueTranslations: Record<string, string> = { yes: 'כן', no: 'לא' };

function formatValue(value: Prisma.JsonValue): string {
  if (value === null || value === undefined) return 'לא נענה';
  if (typeof value === 'boolean') return value ? 'כן' : 'לא';
  if (Array.isArray(value))
    return value
      .map((v) => valueTranslations[String(v)] || String(v))
      .join(', ');
  if (typeof value === 'object' && !Array.isArray(value)) {
    return Object.entries(value)
      .map(([key, val]) => `${key}: ${val}`)
      .join('; ');
  }
  const stringValue = String(value);
  return valueTranslations[stringValue] || stringValue;
}

function isValidAnswerObject(
  item: Prisma.JsonValue
): item is Prisma.JsonObject & {
  questionId: unknown;
  value: Prisma.JsonValue;
  answeredAt: unknown;
  isVisible?: unknown;
} {
  return (
    typeof item === 'object' &&
    item !== null &&
    'questionId' in item &&
    'value' in item &&
    'answeredAt' in item
  );
}

function safeParseJson(jsonValue: Prisma.JsonValue | null): JsonAnswerData[] {
  if (Array.isArray(jsonValue)) {
    return jsonValue.filter(isValidAnswerObject).map((item) => ({
      questionId: String(item.questionId),
      value: item.value,
      answeredAt: String(item.answeredAt),
      isVisible: typeof item.isVisible === 'boolean' ? item.isVisible : true,
    }));
  }
  return [];
}

/**
 * הפונקציה המרכזית והמתוקנת: מקבלת תשובות גולמיות ומחזירה מערך מעוצב עם כל המידע.
 */
export function formatAnswers(
  answersJson: Prisma.JsonValue | null
): FormattedAnswer[] {
  const parsedAnswers = safeParseJson(answersJson);

  const formattedResult: FormattedAnswer[] = parsedAnswers.map((answer) => {
    const fullQuestion = allQuestionsMap.get(answer.questionId);

    // --- START: התיקון המרכזי ---
    return {
      questionId: answer.questionId,
      question: fullQuestion?.question || answer.questionId,
      questionType: fullQuestion?.type || 'unknown', // <-- הוספנו את סוג השאלה
      rawValue: answer.value, // <-- הוספנו את הערך הגולמי
      displayText: formatValue(answer.value),
      isVisible: answer.isVisible,
      answeredAt: new Date(answer.answeredAt),
    };
    // --- END: התיקון המרכזי ---
  });

  return formattedResult.sort((a, b) =>
    a.questionId.localeCompare(b.questionId)
  );
}
--- End of Content for questionnaireFormatter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\rate-limiter.ts
--------------------------------------------------------------------------------
Content:
// src/lib/rate-limiter.ts

import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';
import { NextRequest, NextResponse } from 'next/server';
import { getToken } from 'next-auth/jwt';

// Initialize Redis client only once
let redis: Redis | null = null;
if (process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN) {
  redis = new Redis({
    url: process.env.UPSTASH_REDIS_REST_URL,
    token: process.env.UPSTASH_REDIS_REST_TOKEN,
  });
} else {
  console.warn('Upstash Redis credentials are not configured. Rate limiting will be disabled.');
}

type RateLimitConfig = {
  requests: number;
  window: `${number} ${'s' | 'm' | 'h'}`;
};

/**
 * Applies rate limiting to an API endpoint.
 *
 * @param req The NextRequest object.
 * @param config The rate limit configuration.
 * @returns A NextResponse object if rate-limited, otherwise null.
 */
export async function applyRateLimit(req: NextRequest, config: RateLimitConfig): Promise<NextResponse | null> {
  if (!redis || process.env.NODE_ENV === 'development') {
    return null;
  }

  const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
  const identifier = token?.sub ?? req.ip ?? '127.0.0.1';

  const ratelimit = new Ratelimit({
    redis: redis,
    limiter: Ratelimit.slidingWindow(config.requests, config.window),
    analytics: true,
    prefix: `ratelimit:${req.nextUrl.pathname}`,
  });

  const { success, limit, remaining, reset } = await ratelimit.limit(identifier);

  if (!success) {
    return new NextResponse('Too many requests. Please try again later.', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': reset.toString(),
      },
    });
  }

  return null;
}

// THIS IS THE FIX: Explicitly mark the file as a module.
export {};
--- End of Content for rate-limiter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\tokens.ts
--------------------------------------------------------------------------------
Content:
// src/lib/tokens.ts
import { randomBytes } from 'crypto';
import { promisify } from 'util';

const randomBytesAsync = promisify(randomBytes);

export const generateToken = async (length: number = 32): Promise<string> => {
  const buffer = await randomBytesAsync(length);
  return buffer.toString('hex');
};
--- End of Content for tokens.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\utils.ts
--------------------------------------------------------------------------------
Content:
// src/lib/utils.ts
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function calculateAge(birthDate: Date | string | null): number {
  if (!birthDate) return 0;

  const birth = new Date(birthDate);
  const today = new Date();

  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();

  // If not had birthday this year yet, subtract one year
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }

  return age;
}

/**
 * Creates initials from a full name.
 * @param fullName - The full name string (e.g., "Yisrael Israeli").
 * @returns A string with the initials (e.g., "YI").
 */
export function getInitials(fullName?: string): string {
  if (!fullName || typeof fullName !== 'string' || fullName.trim() === '') {
    return 'ש'; // Default initial for "שדכן" or anonymous
  }

  const nameParts = fullName.trim().split(/\s+/); // Split by one or more spaces
  if (nameParts.length === 1) {
    // If only one name part, take the first one or two letters
    return nameParts[0].length > 1
      ? nameParts[0].substring(0, 2).toUpperCase()
      : nameParts[0].charAt(0).toUpperCase();
  }

  // Take the first letter of the first part and the first letter of the last part
  const firstInitial = nameParts[0].charAt(0);
  const lastInitial = nameParts[nameParts.length - 1].charAt(0);

  return `${firstInitial}${lastInitial}`.toUpperCase();
}

// --- START OF NEW CODE ---
// ===================================================================
// זו הפונקציה החדשה שהוספנו כדי לתקן את נתיבי התמונות
// ===================================================================

/**
 * מקבלת כתובת URL מלאה של תמונה מ-Cloudinary ומחזירה
 * את הנתיב היחסי שהרכיב Image של Next.js צריך.
 * @param fullUrl - הכתובת המלאה של התמונה.
 * @returns הנתיב היחסי, לדוגמה: /v12345/profile-images/image.jpg
 */
// בקובץ src/lib/utils.ts

export const getRelativeCloudinaryPath = (
  fullUrl: string | undefined | null
): string => {
  if (!fullUrl) {
    return '';
  }
  const basePath = 'https://res.cloudinary.com/dmfxoi6g0/image/upload/';
  if (fullUrl.startsWith(basePath)) {
    // ודא שההחלפה היא עם לוכסן בהתחלה
    return fullUrl.replace(basePath, '/');
  }
  return fullUrl;
};
// --- END OF NEW CODE ---
--- End of Content for utils.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\emailService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/email/emailService.ts

import nodemailer from 'nodemailer';
import { emailTemplates, TemplateContextMap } from './templates/emailTemplates';
import { getDictionary } from '@/lib/dictionaries';
import { EmailDictionary } from '@/types/dictionary';
import { Locale } from '../../../i18n-config'; // ודא שהנתיב נכון

// =================  עדכון הממשק הקיים =================
/**
 * ממשק זה מאגד את כל המאפיינים האפשריים שניתן להעביר לכל תבנית אימייל.
 * הוא מחליף את השימוש ב-'any' ומספק בטיחות טיפוסים מלאה.
 * כל המאפיינים הם אופציונליים מכיוון שכל תבנית משתמשת בתת-קבוצה שונה של מאפיינים.
 */

interface ProfileSummaryUpdateEmailParams {
    locale: Locale;
    email: string;
    firstName: string;
    matchmakerName: string;
}


interface TemplateContext {
  // מאפיינים שנוספים אוטומטית בפונקציה sendEmail
  supportEmail: string;
  companyName: string;
  currentYear: string;
  baseUrl: string;

  // מאפיינים דינמיים המגיעים מהקונטקסט של כל סוג אימייל
  locale?: Locale; // אופציונלי, כי אימיילים פנימיים לא צריכים אותו
  dict?: EmailDictionary[keyof EmailDictionary]; // אופציונלי
  sharedDict?: EmailDictionary['shared']; // אופציונלי
  name?: string;
  firstName?: string;
  matchmakerAssigned?: boolean;
  matchmakerName?: string;
  dashboardUrl?: string;
  setupToken?: string;
  setupLink?: string;
  expiresIn?: string;
  verificationCode?: string;
  invitationLink?: string;
  recipientName?: string;
  otherPartyName?: string;
  otherPartyContact?: {
    phone?: string;
    email?: string;
    whatsapp?: string;
  };
  suggestionDetails?: {
    age?: number;
    city?: string;
    occupation?: string;
    additionalInfo?: string | null;
  };
  otp?: string;
  loginUrl?: string;
  inquiryId?: string;

  // --- הוספת שדות עבור אימייל הפידבק ---
  feedbackType?: string;
  userIdentifier?: string;
  content?: string;
  pageUrl?: string;
  screenshotUrl?: string;
  feedbackId?: string;
}
// =================  סוף עדכון הממשק =================

// הגדרות טיפוסים בסיסיות עם locale
interface EmailConfig {
  to: string;
  subject: string;
  templateName: keyof TemplateContextMap;
  context: Omit<TemplateContext, 'supportEmail' | 'companyName' | 'currentYear' | 'baseUrl'>;
}

// ================= הוספת locale לכל הטיפוסים =================
interface AccountSetupEmailParams {
    locale: Locale;
    email: string;
    firstName: string;
    matchmakerName: string;
    setupToken: string;
    expiresIn: string;
}
interface WelcomeEmailParams {
  locale: Locale;
  email: string;
  firstName: string;
  matchmakerAssigned?: boolean;
  matchmakerName?: string;
  dashboardUrl: string;
}

interface VerificationEmailParams {
  locale: Locale;
  email: string;
  verificationCode: string;
  firstName?: string;
  expiresIn?: string;
}

interface InvitationEmailParams {
  locale: Locale;
  email: string;
  invitationLink: string;
  matchmakerName: string;
  expiresIn?: string;
}

interface SuggestionEmailParams {
  locale: Locale;
  email: string;
  recipientName: string;
  matchmakerName: string;
  suggestionDetails?: {
    age?: number;
    city?: string;
    occupation?: string;
    additionalInfo?: string | null;
  };
}

interface ContactDetailsEmailParams {
  locale: Locale;
  email: string;
  recipientName: string;
  otherPartyName: string;
  otherPartyContact: {
    phone?: string;
    email?: string;
    whatsapp?: string;
  };
  matchmakerName: string;
}

interface AvailabilityCheckEmailParams {
  locale: Locale;
  email: string;
  recipientName: string;
  matchmakerName: string;
  inquiryId: string;
}

interface PasswordResetOtpEmailParams {
  locale: Locale;
  email: string;
  otp: string;
  firstName?: string;
  expiresIn?: string;
}

interface PasswordChangedConfirmationParams {
    locale: Locale;
    email: string;
    firstName?: string;
}
// ================= סוף השינויים בטיפוסים =================


class EmailService {
  private static instance: EmailService;
  private transporter: nodemailer.Transporter;
  
  private constructor() {
    this.transporter = nodemailer.createTransport({
      service: process.env.EMAIL_SERVICE || 'gmail',
      auth: {
        user: process.env.GMAIL_USER || process.env.EMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
      },
      tls: {
        rejectUnauthorized: process.env.NODE_ENV === 'production',
      }
    });
  }

  public static getInstance(): EmailService {
    if (!EmailService.instance) {
      EmailService.instance = new EmailService();
    }
    return EmailService.instance;
  }

  async sendEmail({ to, subject, templateName, context }: EmailConfig): Promise<void> {
    try {
      const templateFunction = emailTemplates[templateName];
      if (!templateFunction) {
        console.error(`תבנית אימייל "${templateName}" לא נמצאה.`);
        throw new Error(`Template ${templateName} not found`);
      }

      const fullContext: TemplateContext = {
        ...context,
        supportEmail: process.env.SUPPORT_EMAIL || 'support@example.com',
        companyName: process.env.COMPANY_NAME || 'NeshamaTech',
        currentYear: new Date().getFullYear().toString(),
        baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
      };
      
      const html = templateFunction(fullContext as any); // Use 'as any' here as a bridge, since the function signatures are typed

      const mailOptions: nodemailer.SendMailOptions = {
        from: `${process.env.EMAIL_FROM_NAME || 'NeshamaTech'} <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to,
        subject,
        html,
        headers: {
          'Content-Type': 'text/html; charset=UTF-8',
        }
      };

      const info = await this.transporter.sendMail(mailOptions);
      console.log('אימייל נשלח בהצלחה:', info.messageId, 'אל:', to, 'נושא:', subject);
      
    } catch (error) {
      console.error('שגיאה בשליחת אימייל אל:', to, 'נושא:', subject, 'תבנית:', templateName, 'שגיאה:', error);
      throw new Error(`Failed to send email to ${to} using template ${templateName}`);
    }
  }

  // ============================ פונקציות מעודכנות עם locale ============================

  async sendWelcomeEmail({
    locale,
    email,
    firstName,
    matchmakerAssigned = false,
    matchmakerName = '',
    dashboardUrl,
  }: WelcomeEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    await this.sendEmail({
      to: email,
      subject: emailDict.welcome.subject,
      templateName: 'welcome',
      context: {
        locale,
        dict: emailDict.welcome,
        sharedDict: emailDict.shared,
        name: firstName,
        firstName,
        matchmakerAssigned,
        matchmakerName,
        dashboardUrl: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}${dashboardUrl}`,
      }
    });
  }

  async sendAccountSetupEmail({ locale, email, firstName, matchmakerName, setupToken, expiresIn }: AccountSetupEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    const setupLink = `${process.env.NEXT_PUBLIC_BASE_URL}/auth/setup-account?token=${setupToken}`;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.accountSetup.subject,
      templateName: 'accountSetup',
      context: {
        locale,
        dict: emailDict.accountSetup,
        sharedDict: emailDict.shared,
        name: firstName,
        firstName,
        matchmakerName,
        setupLink,
        expiresIn,
      },
    });
  }
  async sendProfileSummaryUpdateEmail({
    locale,
    email,
    firstName,
    matchmakerName,
  }: ProfileSummaryUpdateEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    await this.sendEmail({
      to: email,
      subject: emailDict.profileSummaryUpdate.subject,
      templateName: 'profileSummaryUpdate',
      context: {
        locale,
        dict: emailDict.profileSummaryUpdate,
        sharedDict: emailDict.shared,
        name: firstName,
        firstName,
        matchmakerName,
        dashboardUrl: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/profile`,
      }
    });
  }

  async sendVerificationEmail({
    locale,
    email,
    verificationCode,
    firstName,
    expiresIn = '1 hour'
  }: VerificationEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    await this.sendEmail({
      to: email,
      subject: emailDict.emailOtpVerification.subject,
      templateName: 'emailOtpVerification',
      context: {
        locale,
        dict: emailDict.emailOtpVerification,
        sharedDict: emailDict.shared,
        name: firstName || email,
        firstName,
        verificationCode,
        expiresIn,
      }
    });
  }

  async sendInvitation({
    locale,
    email,
    invitationLink,
    matchmakerName,
    expiresIn = '7 days'
  }: InvitationEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const fullInvitationLink = `${baseUrl}/auth/accept-invitation?token=${invitationLink}`;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.invitation.subject.replace('{{matchmakerName}}', matchmakerName),
      templateName: 'invitation',
      context: {
        locale,
        dict: emailDict.invitation,
        sharedDict: emailDict.shared,
        name: email,
        matchmakerName,
        invitationLink: fullInvitationLink,
        expiresIn,
      }
    });
  }

  async sendContactDetailsEmail({
    locale,
    email,
    recipientName,
    otherPartyName,
    otherPartyContact,
    matchmakerName,
  }: ContactDetailsEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.shareContactDetails.subject,
      templateName: 'shareContactDetails',
      context: {
        locale,
        dict: emailDict.shareContactDetails,
        sharedDict: emailDict.shared,
        name: recipientName,
        recipientName,
        otherPartyName,
        otherPartyContact,
        matchmakerName,
      }
    });
  }

  async sendSuggestionNotification({
    locale,
    email,
    recipientName,
    matchmakerName,
    suggestionDetails
  }: SuggestionEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    await this.sendEmail({
      to: email,
      subject: emailDict.suggestion.subject,
      templateName: 'suggestion',
      context: {
        locale,
        dict: emailDict.suggestion,
        sharedDict: emailDict.shared,
        name: recipientName,
        recipientName,
        matchmakerName,
        suggestionDetails,
        dashboardUrl: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/dashboard/suggestions`,
      }
    });
  }

  async sendPasswordResetOtpEmail({
    locale,
    email,
    otp,
    firstName,
    expiresIn = '15 minutes'
  }: PasswordResetOtpEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.passwordResetOtp.subject,
      templateName: 'passwordResetOtp',
      context: {
        locale,
        dict: emailDict.passwordResetOtp,
        sharedDict: emailDict.shared,
        name: firstName || email,
        firstName,
        otp,
        expiresIn,
      }
    });
  }

  async sendPasswordChangedConfirmationEmail({
      locale,
      email,
      firstName,
  }: PasswordChangedConfirmationParams): Promise<void> {
      const dictionary = await getDictionary(locale);
      const emailDict = dictionary.email;
      
      await this.sendEmail({
          to: email,
          subject: emailDict.passwordChangedConfirmation.subject,
          templateName: 'passwordChangedConfirmation',
          context: {
              locale,
              dict: emailDict.passwordChangedConfirmation,
              sharedDict: emailDict.shared,
              name: firstName || email,
              firstName,
              loginUrl: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/auth/signin`,
          }
      });
  }
  async sendRawEmail({ to, subject, html }: { to: string; subject: string; html: string }): Promise<void> {
    try {
      const mailOptions: nodemailer.SendMailOptions = {
        from: `${process.env.EMAIL_FROM_NAME || 'NeshamaTech'} <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to,
        subject,
        html,
        headers: {
          'Content-Type': 'text/html; charset=UTF-8',
        }
      };

      const info = await this.transporter.sendMail(mailOptions);
      console.log('אימייל גולמי נשלח בהצלחה:', info.messageId, 'אל:', to, 'נושא:', subject);
      
    } catch (error) {
      console.error('שגיאה בשליחת אימייל גולמי אל:', to, 'נושא:', subject, 'שגיאה:', error);
      throw new Error(`Failed to send raw email to ${to}`);
    }
  }

  async sendAvailabilityCheck({
    locale,
    email,
    recipientName,
    matchmakerName,
    inquiryId,
  }: AvailabilityCheckEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.availabilityCheck.subject,
      templateName: 'availabilityCheck',
      context: {
        locale,
        dict: emailDict.availabilityCheck,
        sharedDict: emailDict.shared,
        name: recipientName,
        recipientName,
        matchmakerName,
        inquiryId,
      }
    });
  }
  
  async verifyConnection(): Promise<boolean> {
    try {
      await this.transporter.verify();
      console.log("חיבור שירות האימייל אומת בהצלחה.");
      return true;
    } catch (error) {
      console.error('שגיאה בחיבור לשירות האימייל:', error);
      return false;
    }
  }
}

export const emailService = EmailService.getInstance();
export type {
  EmailConfig,
  WelcomeEmailParams,
  VerificationEmailParams,
  InvitationEmailParams,
  SuggestionEmailParams,
  ContactDetailsEmailParams,
  AvailabilityCheckEmailParams,
  PasswordResetOtpEmailParams,
  PasswordChangedConfirmationParams,
  AccountSetupEmailParams,
  ProfileSummaryUpdateEmailParams,
};
--- End of Content for emailService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\email_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email
# Generated on: 2025-09-25 18:03:15
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\emailService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/email/emailService.ts

import nodemailer from 'nodemailer';
import { emailTemplates, TemplateContextMap } from './templates/emailTemplates';
import { getDictionary } from '@/lib/dictionaries';
import { EmailDictionary } from '@/types/dictionary';
import { Locale } from '../../../i18n-config'; // ודא שהנתיב נכון

// =================  עדכון הממשק הקיים =================
/**
 * ממשק זה מאגד את כל המאפיינים האפשריים שניתן להעביר לכל תבנית אימייל.
 * הוא מחליף את השימוש ב-'any' ומספק בטיחות טיפוסים מלאה.
 * כל המאפיינים הם אופציונליים מכיוון שכל תבנית משתמשת בתת-קבוצה שונה של מאפיינים.
 */
interface TemplateContext {
  // מאפיינים שנוספים אוטומטית בפונקציה sendEmail
  supportEmail: string;
  companyName: string;
  currentYear: string;
  baseUrl: string;

  // מאפיינים דינמיים המגיעים מהקונטקסט של כל סוג אימייל
  locale?: Locale; // אופציונלי, כי אימיילים פנימיים לא צריכים אותו
  dict?: EmailDictionary[keyof EmailDictionary]; // אופציונלי
  sharedDict?: EmailDictionary['shared']; // אופציונלי
  name?: string;
  firstName?: string;
  matchmakerAssigned?: boolean;
  matchmakerName?: string;
  dashboardUrl?: string;
  setupToken?: string;
  setupLink?: string;
  expiresIn?: string;
  verificationCode?: string;
  invitationLink?: string;
  recipientName?: string;
  otherPartyName?: string;
  otherPartyContact?: {
    phone?: string;
    email?: string;
    whatsapp?: string;
  };
  suggestionDetails?: {
    age?: number;
    city?: string;
    occupation?: string;
    additionalInfo?: string | null;
  };
  otp?: string;
  loginUrl?: string;
  inquiryId?: string;

  // --- הוספת שדות עבור אימייל הפידבק ---
  feedbackType?: string;
  userIdentifier?: string;
  content?: string;
  pageUrl?: string;
  screenshotUrl?: string;
  feedbackId?: string;
}
// =================  סוף עדכון הממשק =================

// הגדרות טיפוסים בסיסיות עם locale
interface EmailConfig {
  to: string;
  subject: string;
  templateName: keyof TemplateContextMap;
  context: Omit<TemplateContext, 'supportEmail' | 'companyName' | 'currentYear' | 'baseUrl'>;
}

// ================= הוספת locale לכל הטיפוסים =================
interface AccountSetupEmailParams {
    locale: Locale;
    email: string;
    firstName: string;
    matchmakerName: string;
    setupToken: string;
    expiresIn: string;
}
interface WelcomeEmailParams {
  locale: Locale;
  email: string;
  firstName: string;
  matchmakerAssigned?: boolean;
  matchmakerName?: string;
  dashboardUrl: string;
}

interface VerificationEmailParams {
  locale: Locale;
  email: string;
  verificationCode: string;
  firstName?: string;
  expiresIn?: string;
}

interface InvitationEmailParams {
  locale: Locale;
  email: string;
  invitationLink: string;
  matchmakerName: string;
  expiresIn?: string;
}

interface SuggestionEmailParams {
  locale: Locale;
  email: string;
  recipientName: string;
  matchmakerName: string;
  suggestionDetails?: {
    age?: number;
    city?: string;
    occupation?: string;
    additionalInfo?: string | null;
  };
}

interface ContactDetailsEmailParams {
  locale: Locale;
  email: string;
  recipientName: string;
  otherPartyName: string;
  otherPartyContact: {
    phone?: string;
    email?: string;
    whatsapp?: string;
  };
  matchmakerName: string;
}

interface AvailabilityCheckEmailParams {
  locale: Locale;
  email: string;
  recipientName: string;
  matchmakerName: string;
  inquiryId: string;
}

interface PasswordResetOtpEmailParams {
  locale: Locale;
  email: string;
  otp: string;
  firstName?: string;
  expiresIn?: string;
}

interface PasswordChangedConfirmationParams {
    locale: Locale;
    email: string;
    firstName?: string;
}
// ================= סוף השינויים בטיפוסים =================


class EmailService {
  private static instance: EmailService;
  private transporter: nodemailer.Transporter;
  
  private constructor() {
    this.transporter = nodemailer.createTransport({
      service: process.env.EMAIL_SERVICE || 'gmail',
      auth: {
        user: process.env.GMAIL_USER || process.env.EMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
      },
      tls: {
        rejectUnauthorized: process.env.NODE_ENV === 'production',
      }
    });
  }

  public static getInstance(): EmailService {
    if (!EmailService.instance) {
      EmailService.instance = new EmailService();
    }
    return EmailService.instance;
  }

  async sendEmail({ to, subject, templateName, context }: EmailConfig): Promise<void> {
    try {
      const templateFunction = emailTemplates[templateName];
      if (!templateFunction) {
        console.error(`תבנית אימייל "${templateName}" לא נמצאה.`);
        throw new Error(`Template ${templateName} not found`);
      }

      const fullContext: TemplateContext = {
        ...context,
        supportEmail: process.env.SUPPORT_EMAIL || 'support@example.com',
        companyName: process.env.COMPANY_NAME || 'NeshamaTech',
        currentYear: new Date().getFullYear().toString(),
        baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
      };
      
      const html = templateFunction(fullContext as any); // Use 'as any' here as a bridge, since the function signatures are typed

      const mailOptions: nodemailer.SendMailOptions = {
        from: `${process.env.EMAIL_FROM_NAME || 'NeshamaTech'} <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to,
        subject,
        html,
        headers: {
          'Content-Type': 'text/html; charset=UTF-8',
        }
      };

      const info = await this.transporter.sendMail(mailOptions);
      console.log('אימייל נשלח בהצלחה:', info.messageId, 'אל:', to, 'נושא:', subject);
      
    } catch (error) {
      console.error('שגיאה בשליחת אימייל אל:', to, 'נושא:', subject, 'תבנית:', templateName, 'שגיאה:', error);
      throw new Error(`Failed to send email to ${to} using template ${templateName}`);
    }
  }

  // ============================ פונקציות מעודכנות עם locale ============================

  async sendWelcomeEmail({
    locale,
    email,
    firstName,
    matchmakerAssigned = false,
    matchmakerName = '',
    dashboardUrl,
  }: WelcomeEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    await this.sendEmail({
      to: email,
      subject: emailDict.welcome.subject,
      templateName: 'welcome',
      context: {
        locale,
        dict: emailDict.welcome,
        sharedDict: emailDict.shared,
        name: firstName,
        firstName,
        matchmakerAssigned,
        matchmakerName,
        dashboardUrl: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}${dashboardUrl}`,
      }
    });
  }

  async sendAccountSetupEmail({ locale, email, firstName, matchmakerName, setupToken, expiresIn }: AccountSetupEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    const setupLink = `${process.env.NEXT_PUBLIC_BASE_URL}/auth/setup-account?token=${setupToken}`;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.accountSetup.subject,
      templateName: 'accountSetup',
      context: {
        locale,
        dict: emailDict.accountSetup,
        sharedDict: emailDict.shared,
        name: firstName,
        firstName,
        matchmakerName,
        setupLink,
        expiresIn,
      },
    });
  }

  async sendVerificationEmail({
    locale,
    email,
    verificationCode,
    firstName,
    expiresIn = '1 hour'
  }: VerificationEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    await this.sendEmail({
      to: email,
      subject: emailDict.emailOtpVerification.subject,
      templateName: 'emailOtpVerification',
      context: {
        locale,
        dict: emailDict.emailOtpVerification,
        sharedDict: emailDict.shared,
        name: firstName || email,
        firstName,
        verificationCode,
        expiresIn,
      }
    });
  }

  async sendInvitation({
    locale,
    email,
    invitationLink,
    matchmakerName,
    expiresIn = '7 days'
  }: InvitationEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const fullInvitationLink = `${baseUrl}/auth/accept-invitation?token=${invitationLink}`;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.invitation.subject.replace('{{matchmakerName}}', matchmakerName),
      templateName: 'invitation',
      context: {
        locale,
        dict: emailDict.invitation,
        sharedDict: emailDict.shared,
        name: email,
        matchmakerName,
        invitationLink: fullInvitationLink,
        expiresIn,
      }
    });
  }

  async sendContactDetailsEmail({
    locale,
    email,
    recipientName,
    otherPartyName,
    otherPartyContact,
    matchmakerName,
  }: ContactDetailsEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.shareContactDetails.subject,
      templateName: 'shareContactDetails',
      context: {
        locale,
        dict: emailDict.shareContactDetails,
        sharedDict: emailDict.shared,
        name: recipientName,
        recipientName,
        otherPartyName,
        otherPartyContact,
        matchmakerName,
      }
    });
  }

  async sendSuggestionNotification({
    locale,
    email,
    recipientName,
    matchmakerName,
    suggestionDetails
  }: SuggestionEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;

    await this.sendEmail({
      to: email,
      subject: emailDict.suggestion.subject,
      templateName: 'suggestion',
      context: {
        locale,
        dict: emailDict.suggestion,
        sharedDict: emailDict.shared,
        name: recipientName,
        recipientName,
        matchmakerName,
        suggestionDetails,
        dashboardUrl: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/dashboard/suggestions`,
      }
    });
  }

  async sendPasswordResetOtpEmail({
    locale,
    email,
    otp,
    firstName,
    expiresIn = '15 minutes'
  }: PasswordResetOtpEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.passwordResetOtp.subject,
      templateName: 'passwordResetOtp',
      context: {
        locale,
        dict: emailDict.passwordResetOtp,
        sharedDict: emailDict.shared,
        name: firstName || email,
        firstName,
        otp,
        expiresIn,
      }
    });
  }

  async sendPasswordChangedConfirmationEmail({
      locale,
      email,
      firstName,
  }: PasswordChangedConfirmationParams): Promise<void> {
      const dictionary = await getDictionary(locale);
      const emailDict = dictionary.email;
      
      await this.sendEmail({
          to: email,
          subject: emailDict.passwordChangedConfirmation.subject,
          templateName: 'passwordChangedConfirmation',
          context: {
              locale,
              dict: emailDict.passwordChangedConfirmation,
              sharedDict: emailDict.shared,
              name: firstName || email,
              firstName,
              loginUrl: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/auth/signin`,
          }
      });
  }
  async sendRawEmail({ to, subject, html }: { to: string; subject: string; html: string }): Promise<void> {
    try {
      const mailOptions: nodemailer.SendMailOptions = {
        from: `${process.env.EMAIL_FROM_NAME || 'NeshamaTech'} <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to,
        subject,
        html,
        headers: {
          'Content-Type': 'text/html; charset=UTF-8',
        }
      };

      const info = await this.transporter.sendMail(mailOptions);
      console.log('אימייל גולמי נשלח בהצלחה:', info.messageId, 'אל:', to, 'נושא:', subject);
      
    } catch (error) {
      console.error('שגיאה בשליחת אימייל גולמי אל:', to, 'נושא:', subject, 'שגיאה:', error);
      throw new Error(`Failed to send raw email to ${to}`);
    }
  }

  async sendAvailabilityCheck({
    locale,
    email,
    recipientName,
    matchmakerName,
    inquiryId,
  }: AvailabilityCheckEmailParams): Promise<void> {
    const dictionary = await getDictionary(locale);
    const emailDict = dictionary.email;
    
    await this.sendEmail({
      to: email,
      subject: emailDict.availabilityCheck.subject,
      templateName: 'availabilityCheck',
      context: {
        locale,
        dict: emailDict.availabilityCheck,
        sharedDict: emailDict.shared,
        name: recipientName,
        recipientName,
        matchmakerName,
        inquiryId,
      }
    });
  }
  
  async verifyConnection(): Promise<boolean> {
    try {
      await this.transporter.verify();
      console.log("חיבור שירות האימייל אומת בהצלחה.");
      return true;
    } catch (error) {
      console.error('שגיאה בחיבור לשירות האימייל:', error);
      return false;
    }
  }
}

export const emailService = EmailService.getInstance();
export type {
  EmailConfig,
  WelcomeEmailParams,
  VerificationEmailParams,
  InvitationEmailParams,
  SuggestionEmailParams,
  ContactDetailsEmailParams,
  AvailabilityCheckEmailParams,
  PasswordResetOtpEmailParams,
  PasswordChangedConfirmationParams,
  AccountSetupEmailParams,
};
--- End of Content for emailService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\email_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\account-setup.hbs
--------------------------------------------------------------------------------
Content:
{{!-- src/lib/email/templates/account-setup.hbs --}}
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>הזמנה להגדרת חשבונך ב-{{companyName}}</title>
    <style>
        body { font-family: 'Arial', sans-serif; direction: rtl; text-align: right; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .highlight-box { background-color: #f0f9ff; border-right: 4px solid #38bdf8; padding: 15px; margin: 20px 0; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>הזמנה להגדרת חשבונך</h1>
        </div>
        <div class="email-body">
            <p>שלום <strong>{{firstName}}</strong>,</p>
            <p>אנו שמחים לבשר לך שהשדכן/ית, <strong>{{matchmakerName}}</strong>, יצר/ה עבורך פרופיל במערכת השידוכים המתקדמת שלנו, {{companyName}}.</p>
            <p>כדי שתוכל/י לקחת שליטה על הפרופיל, לעדכן פרטים, ולצפות בהצעות, יש להגדיר סיסמה אישית לחשבונך.</p>
            <p style="text-align: center;">
                <a href="{{setupLink}}" class="button">הגדרת סיסמה והפעלת החשבון</a>
            </p>
            <div class="highlight-box">
                <p><strong>שימ/י לב:</strong> קישור זה הינו חד-פעמי ותקף למשך <strong>{{expiresIn}}</strong>.</p>
            </div>
            <p>לאחר הגדרת הסיסמה, תוכל/י להתחבר למערכת בכל עת באמצעות כתובת המייל שלך והסיסמה החדשה.</p>
            <p>אנו מאחלים לך הצלחה רבה!</p>
        </div>
        <div class="footer">
            <p>לתמיכה ושאלות, ניתן לפנות אלינו בכתובת: <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
            <p>© {{currentYear}} כל הזכויות שמורות ל{{companyName}}.</p>
        </div>
    </div>
</body>
</html>
--- End of Content for account-setup.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\availability-check.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .deadline {
            background-color: #FEF3C7;
            border-radius: 4px;
            padding: 10px;
            margin: 15px 0;
            color: #92400E;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>בקשת בדיקת זמינות</h1>
        </div>
        
        <div style="padding: 20px;">
            <h2>שלום {{recipientName}},</h2>
            
            <p>השדכן/ית {{matchmakerName}} חושב/ת על הצעת שידוך עבורך ומבקש/ת לוודא את זמינותך.</p>
            
            <p>נשמח אם תוכל/י לאשר את זמינותך דרך המערכת באחת משתי הדרכים:</p>
            
            <div style="text-align: center;">
             <a href="{{baseUrl}}/messages" class="button">
    כניסה למערכת למענה על הבקשה
</a>
            </div>

            <p>או דרך:</p>
            <ol>
                <li>כניסה למערכת</li>
                <li>לחיצה על "הודעות" בתפריט העליון</li>
                <li>מענה על בקשת הזמינות</li>
            </ol>

            <div class="deadline">
                <p>⏰ חשוב לדעת:</p>
                <ul>
                    <li>התשובה תקפה ל-24 שעות</li>
                    <li>תשובתך תעדכן את סטטוס הזמינות הכללי שלך במערכת</li>
                </ul>
            </div>
            
            <p>בברכה,<br>צוות מערכת השידוכים</p>
        </div>
    </div>
</body>
</html>
--- End of Content for availability-check.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\email-verification.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid #f0f0f0;
        }
        .content {
            padding: 30px 20px;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
            text-align: center;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #f0f0f0;
            text-align: center;
            font-size: 14px;
            color: #666;
        }
        .info {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>אימות כתובת אימייל</h1>
        </div>
        
        <div class="content">
            {{#if firstName}}
            <h2>שלום {{firstName}}!</h2>
            {{else}}
            <h2>שלום!</h2>
            {{/if}}
            
            <p>תודה שנרשמת למערכת השידוכים שלנו. כדי להשלים את תהליך ההרשמה, אנא לחץ/י על הכפתור הבא:</p>
            
            <div style="text-align: center;">
                <a href="{{verificationLink}}" class="button">
                    אימות כתובת אימייל
                </a>
            </div>

            <div class="info">
                <p>⏰ שים/י לב: קישור זה תקף ל-{{expiresIn}}</p>
                <p>אם לא ביקשת לאמת את כתובת האימייל שלך, אנא התעלם/י מהודעה זו.</p>
            </div>

            <p>לאחר האימות, תוכל/י להשלים את פרטי הפרופיל שלך ולהתחיל להשתמש במערכת.</p>
        </div>

        <div class="footer">
            <p>בברכה,<br>צוות מערכת השידוכים</p>
            {{#if supportEmail}}
            <p>לתמיכה: {{supportEmail}}</p>
            {{/if}}
        </div>
    </div>
</body>
</html>
--- End of Content for email-verification.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\emailTemplates.ts
--------------------------------------------------------------------------------
Content:
// src/lib/email/templates/emailTemplates.ts

import { EmailDictionary } from '@/types/dictionary';
import { Locale } from '../../../../i18n-config'; // ודא שהנתיב נכון
import { ProfileFeedbackReport } from '@/lib/services/profileFeedbackService'; // ייבוא חדש

// --- הגדרות טיפוסים לקונטקסט של כל תבנית ---
interface BaseTemplateContext {
  locale: Locale;
  supportEmail: string;
  currentYear: string;
  companyName: string;
  baseUrl: string;
  sharedDict: EmailDictionary['shared'];
  name: string;
}

export interface ProfileFeedbackTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['profileFeedback'];
  report: ProfileFeedbackReport;
  isAutomated: boolean;
  matchmakerName: string;
  greeting?: string; // הוספת שדה greeting אופציונלי
}

// שאר הטיפוסים נשארים זהים...
export interface WelcomeTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['welcome'];
  firstName: string;
  matchmakerAssigned?: boolean;
  matchmakerName?: string;
  dashboardUrl: string;
}

export interface AccountSetupTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['accountSetup'];
  firstName: string;
  matchmakerName: string;
  setupLink: string;
  expiresIn: string;
}

export interface EmailOtpVerificationTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['emailOtpVerification'];
  verificationCode: string;
  expiresIn: string;
}

export interface InvitationTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['invitation'];
  matchmakerName: string;
  invitationLink: string;
  expiresIn: string;
}

export interface SuggestionTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['suggestion'];
  recipientName: string;
  matchmakerName: string;
  suggestionDetails?: { age?: number; city?: string; occupation?: string; additionalInfo?: string | null; };
  dashboardUrl: string;
}

export interface ContactDetailsTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['shareContactDetails'];
  recipientName: string;
  otherPartyName: string;
  otherPartyContact: { phone?: string; email?: string; whatsapp?: string; };
  matchmakerName: string;
}

export interface AvailabilityCheckTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['availabilityCheck'];
  recipientName: string;
  matchmakerName: string;
  inquiryId: string;
}

export interface PasswordResetOtpTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['passwordResetOtp'];
  otp: string;
  expiresIn: string;
}

export interface PasswordChangedConfirmationTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['passwordChangedConfirmation'];
  loginUrl: string;
}

export interface InternalFeedbackNotificationTemplateContext {
    feedbackType: string;
    userIdentifier: string;
    content: string;
    pageUrl: string;
    screenshotUrl?: string;
    feedbackId: string;
}

// מפה בין שם התבנית לסוג הקונטקסט שלה
export type TemplateContextMap = {
  welcome: WelcomeTemplateContext;
  accountSetup: AccountSetupTemplateContext;
  emailOtpVerification: EmailOtpVerificationTemplateContext;
  invitation: InvitationTemplateContext;
  suggestion: SuggestionTemplateContext;
  shareContactDetails: ContactDetailsTemplateContext;
  availabilityCheck: AvailabilityCheckTemplateContext;
  passwordResetOtp: PasswordResetOtpTemplateContext;
  passwordChangedConfirmation: PasswordChangedConfirmationTemplateContext;
  'internal-feedback-notification': InternalFeedbackNotificationTemplateContext;
  // שים לב: אנחנו משאירים את הטיפוס כאן, אך לא נגדיר עבורו פונקציה
  'profileFeedback': ProfileFeedbackTemplateContext;
};

// --- פונקציית עזר ליצירת HTML בסיסי לאימיילים פנימיים ---
const createInternalBaseEmailHtml = (title: string, content: string): string => {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; line-height: 1.6; color: #333; }
        .container { max-width: 700px; margin: 20px auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px; background-color: #fff; }
        h1 { color: #06b6d4; border-bottom: 2px solid #f0f0f0; padding-bottom: 10px; margin-top: 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { text-align: left; padding: 12px; border-bottom: 1px solid #eee; vertical-align: top; }
        th { background-color: #f7f7f7; font-weight: 600; width: 150px; }
        pre { white-space: pre-wrap; font-family: inherit; margin: 0; }
        .screenshot { margin-top: 25px; }
        .screenshot h2 { font-size: 18px; color: #333; margin-bottom: 10px; }
        .screenshot img { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }
        a { color: #06b6d4; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        ${content}
    </div>
</body>
</html>`;
};

// --- פונקציית עזר ליצירת HTML בסיסי ---
const createBaseEmailHtml = (title: string, content: string, context: BaseTemplateContext): string => {
    const isRtl = context.locale === 'he';
    const direction = isRtl ? 'rtl' : 'ltr';
    const textAlign = isRtl ? 'right' : 'left';

    return `
<!DOCTYPE html>
<html dir="${direction}" lang="${context.locale}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; direction: ${direction}; text-align: ${textAlign}; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; border-bottom: 5px solid #0891b2; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .otp-code { font-size: 28px; font-weight: bold; color: #ec4899; text-align: center; margin: 25px 0; padding: 15px; background-color: #fdf2f8; border: 1px dashed #fbcfe8; border-radius: 5px; letter-spacing: 3px; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .footer a { color: #06b6d4; text-decoration: none; }
        .highlight-box { background-color: #fef9e7; border-${isRtl ? 'right' : 'left'}: 4px solid #f7c75c; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .attributes-list { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header"><h1>${title}</h1></div>
        <div class="email-body">
            ${content}
            <p style="margin-top: 30px;">${context.sharedDict.closing}<br>${context.sharedDict.team}</p>
        </div>
        <div class="footer">
            <p>${context.sharedDict.supportPrompt} <a href="mailto:${context.supportEmail}">${context.supportEmail}</a></p>
            <p>${context.sharedDict.rightsReserved.replace('{{year}}', context.currentYear)}</p>
        </div>
    </div>
</body>
</html>
`;
};

// --- מיפוי התבניות עם הטיפוס המדויק ---
export const emailTemplates: {
  [K in keyof TemplateContextMap]: (context: TemplateContextMap[K]) => string;
} = {
  welcome: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name)}</p>
    <p>${context.dict.intro}</p>
    ${context.matchmakerAssigned && context.matchmakerName ? `
      <div class="highlight-box">
        <p><strong>${context.dict.matchmakerAssigned.replace('{{matchmakerName}}', context.matchmakerName)}</strong></p>
      </div>` : ''
    }
    <p>${context.dict.getStarted}</p>
    <p style="text-align: center;">
      <a href="${context.dashboardUrl}" class="button">${context.dict.dashboardButton}</a>
    </p>
  `, context),

  accountSetup: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name)}</p>
    <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
    <p>${context.dict.actionPrompt}</p>
    <p style="text-align: center;">
      <a href="${context.setupLink}" class="button">${context.dict.actionButton}</a>
    </p>
    <div class="highlight-box">
      <p><strong>${context.dict.notice.replace('{{expiresIn}}', context.expiresIn)}</strong></p>
    </div>
    <p>${context.dict.nextStep}</p>
  `, context),
  
  emailOtpVerification: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name || 'משתמש יקר')}</p>
    <p>${context.dict.intro}</p>
    <p>${context.dict.codeInstruction}</p>
    <div class="otp-code">${context.verificationCode}</div>
    <p>${context.dict.expiryNotice.replace('{{expiresIn}}', context.expiresIn)}</p>
    <p>${context.dict.securityNote}</p>
  `, context),

  invitation: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name)}</p>
    <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
    <p>${context.dict.actionPrompt}</p>
    <p style="text-align: center;">
      <a href="${context.invitationLink}" class="button">${context.dict.actionButton}</a>
    </p>
    <p>${context.dict.expiryNotice.replace('{{expiresIn}}', context.expiresIn)}</p>
  `, context),
  
  suggestion: (context) => {
    let detailsHtml = '';
    if (context.suggestionDetails) {
      const detailsList = [
        context.suggestionDetails.age && `<li><strong>${context.dict.details.age}:</strong> ${context.suggestionDetails.age}</li>`,
        context.suggestionDetails.city && `<li><strong>${context.dict.details.city}:</strong> ${context.suggestionDetails.city}</li>`,
        context.suggestionDetails.occupation && `<li><strong>${context.dict.details.occupation}:</strong> ${context.suggestionDetails.occupation}</li>`,
        context.suggestionDetails.additionalInfo && `<li><strong>${context.dict.details.additionalInfo}:</strong> ${context.suggestionDetails.additionalInfo}</li>`,
      ].filter(Boolean).join('');
      
      if (detailsList) {
        detailsHtml = `
          <div class="attributes-list">
            <h4>${context.dict.previewTitle}</h4>
            <ul>${detailsList}</ul>
          </div>`;
      }
    }
    
     return createBaseEmailHtml(
       context.dict.title, 
       `
        <p>${context.sharedDict.greeting.replace('{{name}}', context.recipientName)}</p>
        <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
        ${detailsHtml}
        <p>${context.dict.actionPrompt}</p>
        <p style="text-align: center;">
            <a href="${context.dashboardUrl}" class="button">${context.dict.actionButton}</a>
        </p>
        <p>${context.dict.closing}</p>
      `, 
      context
    );
  },
'profileFeedback': (context) => {
    // כאן, במקום לבנות HTML ידנית, אנו משתמשים במנוע התבניות
    // שנטען על ידי השרת שלך (למשל, hbs). הלוגיקה עצמה נמצאת בקובץ ה-hbs.
    // הקוד כאן רק צריך להעביר את האובייקט 'context' למנוע העיבוד.
    // לצורך הדוגמה, אני מדמה את זה. ודא שהתשתית שלך תומכת בזה.
    const Handlebars = require('handlebars'); // ייבוא סימבולי
    const templateSource = require('./profile-feedback.hbs'); // טעינה סימבולית של הקובץ
    const compiledTemplate = Handlebars.compile(templateSource);
    return compiledTemplate(context);
},
  shareContactDetails: (context) => {
    const contactInfoHtml = [
      context.otherPartyContact.phone && `<p><strong>טלפון:</strong> ${context.otherPartyContact.phone}</p>`,
      context.otherPartyContact.email && `<p><strong>אימייל:</strong> <a href="mailto:${context.otherPartyContact.email}">${context.otherPartyContact.email}</a></p>`,
      context.otherPartyContact.whatsapp && `<p><strong>וואטסאפ:</strong> ${context.otherPartyContact.whatsapp}</p>`,
    ].filter(Boolean).join('');

    return createBaseEmailHtml(context.dict.title, `
      <p>${context.sharedDict.greeting.replace('{{name}}', context.recipientName)}</p>
      <p>${context.dict.intro}</p>
      <div class="attributes-list">
        <h3>${context.dict.detailsOf.replace('{{otherPartyName}}', context.otherPartyName)}</h3>
        ${contactInfoHtml || '<p>לא סופקו פרטי קשר.</p>'}
      </div>
      <div class="highlight-box">
        <p><strong>${context.dict.tipTitle}</strong> ${context.dict.tipContent}</p>
      </div>
      <p>${context.dict.goodLuck}</p>
    `, context);
  },

  availabilityCheck: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.recipientName)}</p>
    <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
    <p>${context.dict.actionPrompt}</p>
    <p style="text-align: center;">
      <a href="${context.baseUrl}/dashboard/suggestions?inquiryId=${context.inquiryId}" class="button">${context.dict.actionButton}</a>
    </p>
    <div class="highlight-box">
      <p><strong>${context.dict.noticeTitle}</strong> ${context.dict.noticeContent}</p>
    </div>
  `, context),

  passwordResetOtp: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name || 'משתמש יקר')}</p>
    <p>${context.dict.intro}</p>
    <p>${context.dict.codeInstruction}</p>
    <div class="otp-code">${context.otp}</div>
    <p>${context.dict.expiryNotice.replace('{{expiresIn}}', context.expiresIn)}</p>
    <p>${context.dict.securityNote}</p>
  `, context),

  passwordChangedConfirmation: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name || 'משתמש יקר')}</p>
    <p>${context.dict.intro}</p>
    <div class="highlight-box">
      <p>${context.dict.securityNote}</p>
    </div>
    <p style="text-align: center;">
      <a href="${context.loginUrl}" class="button">${context.dict.actionButton}</a>
    </p>
  `, context),
  
  // ============================ הוספת התבנית החדשה כאן ============================
  'internal-feedback-notification': (context) => createInternalBaseEmailHtml('New Feedback Received', `
    <h1>New Feedback Received</h1>
    <p>A new piece of feedback has been submitted through the website widget.</p>
    
    <table>
        <tr>
            <th>Feedback ID</th>
            <td>${context.feedbackId}</td>
        </tr>
        <tr>
            <th>Type</th>
            <td><strong>${context.feedbackType}</strong></td>
        </tr>
        <tr>
            <th>Submitted By</th>
            <td>${context.userIdentifier}</td>
        </tr>
        <tr>
            <th>Page URL</th>
            <td><a href="${context.pageUrl}" target="_blank">${context.pageUrl}</a></td>
        </tr>
        <tr>
            <th>Content</th>
            <td><pre>${context.content}</pre></td>
        </tr>
    </table>

    ${context.screenshotUrl ? `
    <div class="screenshot">
        <h2>Screenshot Attached</h2>
        <a href="${context.screenshotUrl}" target="_blank">
            <img src="${context.screenshotUrl}" alt="User-submitted screenshot">
        </a>
    </div>
    ` : ''}
  `),
  // ==============================================================================
};
--- End of Content for emailTemplates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\internal-feedback-notification.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>New Feedback Received</title>
    <style>
        body { font-family: sans-serif; line-height: 1.5; color: #333; }
        .container { max-width: 700px; margin: 20px auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        h1 { color: #06b6d4; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { text-align: left; padding: 12px; border-bottom: 1px solid #eee; }
        th { background-color: #f7f7f7; font-weight: 600; }
        .screenshot { margin-top: 20px; }
        .screenshot img { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>New Feedback Received</h1>
        <p>A new piece of feedback has been submitted through the website widget.</p>
        
        <table>
            <tr>
                <th>Feedback ID</th>
                <td>{{feedbackId}}</td>
            </tr>
            <tr>
                <th>Type</th>
                <td><strong>{{feedbackType}}</strong></td>
            </tr>
            <tr>
                <th>Submitted By</th>
                <td>{{userIdentifier}}</td>
            </tr>
            <tr>
                <th>Page URL</th>
                <td><a href="{{pageUrl}}">{{pageUrl}}</a></td>
            </tr>
            <tr>
                <th>Content</th>
                <td><pre style="white-space: pre-wrap; font-family: sans-serif;">{{content}}</pre></td>
            </tr>
        </table>

        {{#if screenshotUrl}}
        <div class="screenshot">
            <h2>Screenshot Attached</h2>
            <a href="{{screenshotUrl}}" target="_blank">
                <img src="{{screenshotUrl}}" alt="User-submitted screenshot">
            </a>
        </div>
        {{/if}}
    </div>
</body>
</html>
--- End of Content for internal-feedback-notification.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\invitation.hbs
--------------------------------------------------------------------------------
Content:
{{! src/lib/email/templates/invitation.hbs - Updated Version }}
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{dict.title}}</title>
    <style>
        body { font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; direction: rtl; text-align: right; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; border-bottom: 5px solid #0891b2; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .footer a { color: #06b6d4; text-decoration: none; }
        .highlight-box { background-color: #fef9e7; border-right: 4px solid #f7c75c; padding: 15px; margin: 20px 0; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>{{dict.title}}</h1>
        </div>
        <div class="email-body">
            <p>{{sharedDict.greeting.replace '{{name}}' name}}</p>
            <p>{{dict.intro}}</p>
            <p>{{dict.actionPrompt}}</p>
            
            <p style="text-align: center;">
                <a href="{{invitationLink}}" class="button">{{dict.actionButton}}</a>
            </p>

            <div class="highlight-box">
                <p><strong>{{dict.expiryNotice}}</strong></p>
            </div>

            <p style="margin-top: 30px;">{{sharedDict.closing}}<br>{{sharedDict.team}}</p>
        </div>
        <div class="footer">
            <p>{{sharedDict.supportPrompt}} <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
            <p>{{sharedDict.rightsReserved}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for invitation.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\password-changed-confirmation.html
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אישור שינוי סיסמה - NeshamaTech</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; direction: rtl; text-align: right; }
        .container { max-width: 600px; margin: 20px auto; background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .header { background-color: #10b981; /* Green */ color: #ffffff; padding: 15px; text-align: center; border-top-left-radius: 8px; border-top-right-radius: 8px; }
        .header h1 { margin: 0; font-size: 24px; }
        .content { padding: 20px; color: #333333; line-height: 1.6; }
        .footer { text-align: center; padding: 15px; font-size: 12px; color: #777777; border-top: 1px solid #eeeeee; margin-top: 20px; }
        .button { display: inline-block; background-color: #06b6d4; color: #ffffff !important; padding: 10px 20px; text-decoration: none; border-radius: 5px; font-weight: bold; margin-top: 15px; }
        a { color: #06b6d4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>הסיסמה שלך שונתה בהצלחה</h1>
        </div>
        <div class="content">
            <p>שלום {{firstName}},</p>
            <p>אנו מאשרים שהסיסמה עבור חשבונך ב-NeshamaTech שונתה בהצלחה.</p>
            <p>אם לא ביצעת שינוי זה, או אם אתה חושד בפעילות לא מורשית בחשבונך, אנא פנה אלינו באופן מיידי בכתובת: <a href="mailto:{{supportEmail}}">{{supportEmail}}</a>.</p>
            <p>תוכל להתחבר לחשבונך כעת באמצעות הסיסמה החדשה שלך:</p>
            <p style="text-align: center;">
                <a href="{{loginUrl}}" class="button">התחבר לחשבונך</a>
            </p>
            <p>בברכה,<br>צוות NeshamaTech</p>
        </div>
        <div class="footer">
            © {{currentYear}} NeshamaTech. כל הזכויות שמורות.
        </div>
    </div>
</body>
</html>
--- End of Content for password-changed-confirmation.html ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\password-reset-otp.html
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-TMLF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>איפוס סיסמה - NeshamaTech</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; direction: rtl; text-align: right; }
        .container { max-width: 600px; margin: 20px auto; background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .header { background-color: #06b6d4; /* Cyan */ color: #ffffff; padding: 15px; text-align: center; border-top-left-radius: 8px; border-top-right-radius: 8px; }
        .header h1 { margin: 0; font-size: 24px; }
        .content { padding: 20px; color: #333333; line-height: 1.6; }
        .otp-code { font-size: 28px; font-weight: bold; color: #ec4899; /* Pink */ text-align: center; margin: 20px 0; padding: 10px; background-color: #fdf2f8; border: 1px dashed #ec4899; border-radius: 4px; }
        .instructions { font-size: 14px; color: #555555; }
        .important { color: #d9534f; font-weight: bold; }
        .footer { text-align: center; padding: 15px; font-size: 12px; color: #777777; border-top: 1px solid #eeeeee; margin-top: 20px; }
        .button { display: inline-block; background-color: #06b6d4; color: #ffffff !important; padding: 10px 20px; text-decoration: none; border-radius: 5px; font-weight: bold; margin-top: 15px; }
        a { color: #06b6d4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>איפוס סיסמה</h1>
        </div>
        <div class="content">
            <p>שלום {{firstName}},</p>
            <p>קיבלנו בקשה לאיפוס הסיסמה שלך עבור חשבונך ב-NeshamaTech.</p>
            <p>אנא השתמש בקוד האימות החד-פעמי הבא כדי לאפס את סיסמתך:</p>
            <div class="otp-code">{{otp}}</div>
            <p class="instructions">הקוד תקף למשך {{expiresIn}}.</p>
            <p class="instructions">אם לא ביקשת לאפס את סיסמתך, אנא התעלם ממייל זה. ייתכן שמישהו אחר הזין את כתובת המייל שלך בטעות.</p>
            <p class="important instructions">מטעמי אבטחה, לעולם אל תשתף קוד זה עם אף אחד.</p>
            <p>אם אתה נתקל בבעיות כלשהן, או שאתה זקוק לעזרה נוספת, אנא פנה לתמיכה שלנו בכתובת: <a href="mailto:{{supportEmail}}">{{supportEmail}}</a>.</p>
            <p>בברכה,<br>צוות NeshamaTech</p>
        </div>
        <div class="footer">
            © {{currentYear}} NeshamaTech. כל הזכויות שמורות.
        </div>
    </div>
</body>
</html>
--- End of Content for password-reset-otp.html ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\password-reset.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        .content {
            padding: 20px;
        }
        .verification-code {
            text-align: center;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 5px;
            margin: 20px 0;
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 5px;
            color: #1a56db;
            border: 1px dashed #a4cafe;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .important-note {
            background-color: #fff9e6;
            border-right: 4px solid #fbbf24;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .steps {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .step {
            margin-bottom: 10px;
            padding-right: 25px;
            position: relative;
        }
        .step:before {
            content: "✓";
            position: absolute;
            right: 0;
            color: #4F46E5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>קוד לשינוי סיסמה</h1>
        </div>
        <div class="content">
            <h2>שלום,</h2>
            <p>קיבלנו בקשה לשינוי הסיסמה שלך. להשלמת התהליך, השתמש בקוד האימות הבא:</p>
            
            <div class="verification-code">
                {{resetLink}}
            </div>

            <div class="steps">
                <h3>כיצד להשתמש בקוד:</h3>
                <div class="step">
                    הזן את הקוד בחלון שינוי הסיסמה במערכת
                </div>
                <div class="step">
                    הסיסמה החדשה תיכנס לתוקף לאחר אישור הקוד
                </div>
            </div>

            <div class="important-note">
                <strong>🔒 שים לב:</strong>
                <p>הקוד תקף ל-{{expiresIn}} בלבד ויכול לשמש פעם אחת בלבד.</p>
                <p>אם לא ביקשת לשנות את הסיסמה שלך, אנא התעלם מהודעה זו והסיסמה הנוכחית תישאר בתוקף.</p>
            </div>
        </div>

        <div class="footer">
            <p>
                הודעה זו נשלחה אוטומטית, אנא אל תשיב להודעה זו.
                <br>
                לתמיכה: {{supportEmail}}
            </p>
        </div>
    </div>
</body>
</html>
--- End of Content for password-reset.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\profile-feedback.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="{{#if (eq locale 'he')}}rtl{{else}}ltr{{/if}}" lang="{{locale}}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{dict.title}}</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Arial, sans-serif; 
            direction: {{#if (eq locale 'he')}}rtl{{else}}ltr{{/if}}; 
            text-align: {{#if (eq locale 'he')}}right{{else}}left{{/if}}; 
            line-height: 1.6; 
            margin: 0; 
            padding: 0; 
            background-color: #f8fafc; 
            color: #374151; 
        }
        
        .email-container { 
            max-width: 600px; 
            margin: 20px auto; 
            background-color: #ffffff; 
            border-radius: 12px; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.08); 
            overflow: hidden; 
        }
        
        .email-header { 
            background: linear-gradient(135deg, #06b6d4, #0891b2); 
            color: #ffffff; 
            padding: 30px; 
            text-align: center; 
        }
        
        .email-header h1 { 
            margin: 0; 
            font-size: 26px; 
            font-weight: 700; 
            letter-spacing: -0.5px;
        }
        
        .email-body { 
            padding: 30px; 
            font-size: 16px; 
        }
        
        .greeting {
            font-size: 20px;
            color: #1e293b;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .intro-text {
            font-size: 16px;
            color: #475569;
            margin-bottom: 30px;
            line-height: 1.7;
        }
        
        /* Progress Section */
        .progress-section {
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            border: 2px solid #bfdbfe;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }
        
        .progress-title {
            color: #1e40af;
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 15px;
        }
        
        .progress-number {
            font-size: 48px;
            font-weight: 900;
            color: #06b6d4;
            margin: 10px 0;
        }
        
        .progress-bar-container {
            background-color: #e2e8f0;
            border-radius: 25px;
            height: 20px;
            margin: 20px 0;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #06b6d4, #0891b2);
            height: 100%;
            border-radius: 25px;
            transition: width 1s ease-out;
            position: relative;
        }
        
        .progress-text {
            color: #64748b;
            font-size: 15px;
            margin-top: 10px;
            font-weight: 500;
        }
        
        /* AI Summary */
        .ai-summary {
            background: linear-gradient(135deg, #fefce8, #fef3c7);
            border-{{#if (eq locale 'he')}}right{{else}}left{{/if}}: 5px solid #f59e0b;
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
        }
        
        .ai-summary h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #b45309;
            font-size: 18px;
            font-weight: 700;
        }
        
        .ai-insight {
            background: rgba(255, 255, 255, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .ai-insight strong {
            color: #92400e;
            font-weight: 600;
        }
        
        .ai-disclaimer {
            font-size: 14px;
            color: #6b7280;
            font-style: italic;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 6px;
        }
        
        /* Status Section */
        .status-section {
            margin: 30px 0;
        }
        
        .section-title {
            font-size: 22px;
            color: #1e293b;
            margin-bottom: 25px;
            font-weight: 700;
            border-bottom: 3px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }
        
        .status-card {
            border-radius: 12px;
            padding: 20px;
            border: 2px solid;
        }
        
        .completed-card {
            background: linear-gradient(135deg, #f0fdf4, #dcfce7);
            border-color: #22c55e;
        }
        
        .missing-card {
            background: linear-gradient(135deg, #fffbeb, #fef3c7);
            border-color: #f59e0b;
        }
        
        .card-title {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 700;
        }
        
        .completed-card .card-title {
            color: #15803d;
        }
        
        .missing-card .card-title {
            color: #b45309;
        }
        
        .status-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .status-item {
            padding: 8px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-icon {
            margin-{{#if (eq locale 'he')}}left{{else}}right{{/if}}: 10px;
            font-size: 18px;
        }
        
        /* Questionnaire Section */
        .questionnaire-section {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border: 2px solid #0ea5e9;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
        }
        
        .questionnaire-title {
            color: #0369a1;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        
        .questionnaire-icon {
            margin-{{#if (eq locale 'he')}}left{{else}}right{{/if}}: 10px;
            font-size: 24px;
        }
        
        .question-summary {
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 600;
            color: #0369a1;
            font-size: 16px;
        }
        
        .question-details {
            color: #0369a1;
            text-align: center;
            font-weight: 600;
            margin-top: 10px;
        }
        
        /* CTA Section */
        .cta-section {
            background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
            border: 2px solid #94a3b8;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin: 30px 0;
        }
        
        .cta-title {
            font-size: 24px;
            color: #1e293b;
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .cta-text {
            color: #64748b;
            margin-bottom: 25px;
            font-size: 16px;
        }
        
        .cta-button {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: white !important;
            text-decoration: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 18px;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(6, 182, 212, 0.3);
            transition: transform 0.2s ease;
        }
        
        .cta-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(6, 182, 212, 0.4);
        }
        
        /* Footer */
        .footer {
            background-color: #f8fafc;
            padding: 25px;
            text-align: center;
            font-size: 14px;
            color: #64748b;
            border-top: 1px solid #e2e8f0;
        }
        
        .footer a {
            color: #06b6d4;
            text-decoration: none;
        }
        
        /* Mobile Responsive */
        @media (max-width: 600px) {
            .status-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .email-body {
                padding: 20px;
            }
            
            .progress-number {
                font-size: 36px;
            }
            
            .cta-title {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="email-container">
        <!-- Header -->
        <div class="email-header">
            <h1>{{dict.title}}</h1>
        </div>
        
        <!-- Body -->
        <div class="email-body">
            <!-- Greeting -->
            <div class="greeting">{{greeting}}</div>
            
            <div class="intro-text">
                {{#if isAutomated}}
                    {{dict.systemIntro}}
                {{else}}
                    {{dict.matchmakerIntro}}
                {{/if}}
            </div>

            <!-- Progress Section -->
            <div class="progress-section">
                <div class="progress-title">{{dict.progressHeader}}</div>
                <div class="progress-number">{{report.completionPercentage}}%</div>
                <div class="progress-bar-container">
                    <div class="progress-bar" style="width: {{report.completionPercentage}}%;"></div>
                </div>
                <div class="progress-text">
                    השקעת עד כה והגעת ל-<strong>{{report.completionPercentage}}% השלמה</strong>.<br>
                    כל הכבוד! עוד מאמץ קטן והפרופיל שלך יהיה מוכן למצוא את ההתאמה המושלמת.
                </div>
            </div>

            {{#if report.aiSummary}}
            <!-- AI Summary -->
            <div class="ai-summary">
                <h3>{{dict.aiSummaryHeader}}</h3>
                
                <div class="ai-insight">
                    <strong>{{dict.aiSummary.personalityTitle}}:</strong><br>
                    "{{report.aiSummary.personality}}"
                </div>
                
                <div class="ai-insight">
                    <strong>{{dict.aiSummary.lookingForTitle}}:</strong><br>
                    "{{report.aiSummary.lookingFor}}"
                </div>
                
                <div class="ai-disclaimer">
                    זוהי רק טעימה מהתובנות שה-AI שלנו יכול להפיק מפרופיל מלא. ככל שתוסיף יותר מידע, כך נוכל לחדד יותר את ההתאמות עבורך.
                </div>
            </div>
            {{/if}}

            <!-- Status Section -->
            <div class="status-section">
                <h2 class="section-title">סטטוס הפרופיל שלך</h2>
                
                <div class="status-grid">
                    <!-- Completed Items -->
                    <div class="status-card completed-card">
                        <h4 class="card-title">כל הכבוד! מה שכבר השלמת:</h4>
                        <ul class="status-list">
                            {{#each report.completedProfileItems}}
                                <li class="status-item">
                                    <span class="status-icon">✅</span>
                                    {{this}}
                                </li>
                            {{/each}}
                        </ul>
                    </div>
                    
                    <!-- Missing Items -->
                    <div class="status-card missing-card">
                        <h4 class="card-title">השלב הבא: מה חסר</h4>
                        <ul class="status-list">
                             {{#each report.missingProfileItems}}
                                <li class="status-item">
                                    <span class="status-icon">📝</span>
                                    {{this}}
                                </li>
                            {{/each}}
                        </ul>
                    </div>
                </div>
                
                {{#if report.missingQuestionnaireItems}}
                <div class="questionnaire-section">
                    <div class="questionnaire-title">
                        <span class="questionnaire-icon">📋</span>
                        שאלון המעמיק - הזדמנות זהב!
                    </div>
                    
                    <div class="question-summary">
                        יש לנו {{report.missingQuestionnaireItems.length}} שאלות מעמיקות שמחכות לך!<br>
                        הן יעזרו לנו להכיר אותך טוב יותר ולמצוא התאמות מדויקות.
                    </div>
                    
                    <p class="question-details">
                        השאלות מחולקות לעולמות: אישיות, ערכים, זוגיות, פרטנר ודת ומסורת
                    </p>
                </div>
                {{/if}}
            </div>

            <!-- CTA Section -->
            <div class="cta-section">
                <h3 class="cta-title">{{dict.cta.title}}</h3>
                <p class="cta-text">השלמת הפרופיל מגדילה משמעותית את הסיכוי למצוא התאמה איכותית.</p>
                <a href="{{baseUrl}}/profile" class="cta-button">{{dict.cta.button}}</a>
            </div>

        </div>
        
        <!-- Footer -->
        <div class="footer">
             <p>{{sharedDict.supportPrompt}} <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
             <p>{{sharedDict.rightsReserved}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for profile-feedback.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\share-contact-details.hbs
--------------------------------------------------------------------------------
Content:
// src/lib/email/templates/share-contact-details.hbs
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        .content {
            padding: 20px;
        }
        .contact-details {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .important-note {
            background-color: #fef3c7;
            border-right: 4px solid #f59e0b;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>פרטי קשר לפגישה ראשונה</h1>
        </div>
        
        <div class="content">
            <h2>שלום {{recipientName}}!</h2>
            
            <p>השדכן/ית {{matchmakerName}} אישר/ה את ההצעה ואתם יכולים ליצור קשר ראשוני!</p>

        <div class="contact-details">
  <h3>פרטי הקשר של {{otherPartyName}}:</h3>
  {{#if otherPartyContact.email}}
    <p>📧 אימייל: {{otherPartyContact.email}}</p>
  {{/if}}
  {{#if otherPartyContact.whatsapp}}
    <p>💬 וואטסאפ: {{otherPartyContact.whatsapp}}</p>
  {{/if}}
</div>

            <div class="important-note">
                <h4>🔔 שימו לב:</h4>
                <ul>
                    <li>מומלץ ליצור קשר תוך 24 שעות</li>
                    <li>אנא עדכנו את השדכן/ית על קביעת הפגישה</li>
                    <li>לאחר הפגישה, תתבקשו למלא משוב קצר במערכת</li>
                </ul>
            </div>

            <p>בהצלחה רבה! אנו מאחלים לכם פגישה טובה ומוצלחת.</p>
        </div>

        <div class="footer">
            <p>בברכה,<br>צוות מערכת השידוכים</p>
            <p>{{supportEmail}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for share-contact-details.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\suggestion.hbs
--------------------------------------------------------------------------------
Content:
{{! src/lib/email/templates/suggestion.hbs - Updated Version }}
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{dict.title}}</title>
    <style>
        body { font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; direction: rtl; text-align: right; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; border-bottom: 5px solid #0891b2; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .footer a { color: #06b6d4; text-decoration: none; }
        .attributes-list { background-color: #f8f9fa; border: 1px solid #e9ecef; padding: 20px; border-radius: 8px; margin: 25px 0; }
        .attributes-list h4 { margin-top: 0; color: #0891b2; }
        .attributes-list ul { padding-right: 20px; margin: 10px 0; list-style-type: disc; }
        .attributes-list li { margin-bottom: 8px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>{{dict.title}}</h1>
        </div>
        <div class="email-body">
            <p>{{sharedDict.greeting}}</p>
            <p>{{dict.intro}}</p>
            
            {{{detailsHtml}}}

            <p>{{dict.actionPrompt}}</p>
            
            <p style="text-align: center;">
                <a href="{{dashboardUrl}}" class="button">{{dict.actionButton}}</a>
            </p>

            <p>{{dict.closing}}</p>

            <p style="margin-top: 30px;">{{sharedDict.closing}}<br>{{sharedDict.team}}</p>
        </div>
        <div class="footer">
            <p>{{sharedDict.supportPrompt}} <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
            <p>{{sharedDict.rightsReserved}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for suggestion.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\welcome.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #4F46E5;
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        .content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .steps {
            background-color: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .step {
            margin-bottom: 15px;
            padding-right: 20px;
            position: relative;
        }
        .step:before {
            content: "✓";
            position: absolute;
            right: 0;
            color: #4F46E5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ברוכים הבאים למערכת השידוכים</h1>
        </div>
        <div class="content">
            <h2>שלום {{firstName}}!</h2>
            <p>תודה שבחרת להצטרף למערכת השידוכים שלנו. אנו שמחים לקחת חלק במסע החשוב שלך.</p>
            
            <div class="steps">
                <h3>השלבים הבאים:</h3>
                {{#if requiresVerification}}
                <div class="step">
                    <strong>אימות חשבון:</strong> נשלח אליך מייל נפרד עם קישור לאימות החשבון שלך.
                </div>
                {{/if}}
                <div class="step">
                    <strong>השלמת פרופיל:</strong> הוסף/י את כל הפרטים החשובים שיעזרו לנו למצוא את ההתאמה המושלמת עבורך.
                </div>
                <div class="step">
                    <strong>העדפות התאמה:</strong> הגדר/י את ההעדפות שלך לגבי בן/בת הזוג המיועד/ת.
                </div>
                {{#if matchmakerAssigned}}
                <div class="step">
                    <strong>השדכן/ית שלך:</strong> {{matchmakerName}} ילווה אותך בתהליך.
                </div>
                {{/if}}
            </div>

            <p>מה עכשיו?</p>
            <a href="{{dashboardUrl}}" class="button">כניסה למערכת</a>

            <p>טיפים חשובים:</p>
            <ul>
                <li>מלא/י את הפרופיל בצורה מפורטת ככל האפשר</li>
                <li>הוסף/י תמונה עדכנית לפרופיל</li>
                <li>הגדר/י את העדפות החיפוש שלך בקפידה</li>
                <li>עדכן/י את הסטטוס שלך באופן שוטף</li>
            </ul>

            {{#if privacyNote}}
            <p class="privacy-note">
                <strong>הערה חשובה:</strong> הפרופיל שלך יהיה גלוי רק למשתמשים מאומתים ולשדכנים מורשים במערכת.
            </p>
            {{/if}}
        </div>
        <div class="footer">
            <p>
                מערכת השידוכים | לכל שאלה ניתן ליצור קשר במייל {{supportEmail}}
                {{#if unsubscribeUrl}}
                | <a href="{{unsubscribeUrl}}">הסרה מרשימת התפוצה</a>
                {{/if}}
            </p>
        </div>
    </div>
</body>
</html>
--- End of Content for welcome.hbs ---

--- End of Content for email_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\account-setup.hbs
--------------------------------------------------------------------------------
Content:
{{!-- src/lib/email/templates/account-setup.hbs --}}
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>הזמנה להגדרת חשבונך ב-{{companyName}}</title>
    <style>
        body { font-family: 'Arial', sans-serif; direction: rtl; text-align: right; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .highlight-box { background-color: #f0f9ff; border-right: 4px solid #38bdf8; padding: 15px; margin: 20px 0; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>הזמנה להגדרת חשבונך</h1>
        </div>
        <div class="email-body">
            <p>שלום <strong>{{firstName}}</strong>,</p>
            <p>אנו שמחים לבשר לך שהשדכן/ית, <strong>{{matchmakerName}}</strong>, יצר/ה עבורך פרופיל במערכת השידוכים המתקדמת שלנו, {{companyName}}.</p>
            <p>כדי שתוכל/י לקחת שליטה על הפרופיל, לעדכן פרטים, ולצפות בהצעות, יש להגדיר סיסמה אישית לחשבונך.</p>
            <p style="text-align: center;">
                <a href="{{setupLink}}" class="button">הגדרת סיסמה והפעלת החשבון</a>
            </p>
            <div class="highlight-box">
                <p><strong>שימ/י לב:</strong> קישור זה הינו חד-פעמי ותקף למשך <strong>{{expiresIn}}</strong>.</p>
            </div>
            <p>לאחר הגדרת הסיסמה, תוכל/י להתחבר למערכת בכל עת באמצעות כתובת המייל שלך והסיסמה החדשה.</p>
            <p>אנו מאחלים לך הצלחה רבה!</p>
        </div>
        <div class="footer">
            <p>לתמיכה ושאלות, ניתן לפנות אלינו בכתובת: <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
            <p>© {{currentYear}} כל הזכויות שמורות ל{{companyName}}.</p>
        </div>
    </div>
</body>
</html>
--- End of Content for account-setup.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\availability-check.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .deadline {
            background-color: #FEF3C7;
            border-radius: 4px;
            padding: 10px;
            margin: 15px 0;
            color: #92400E;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>בקשת בדיקת זמינות</h1>
        </div>
        
        <div style="padding: 20px;">
            <h2>שלום {{recipientName}},</h2>
            
            <p>השדכן/ית {{matchmakerName}} חושב/ת על הצעת שידוך עבורך ומבקש/ת לוודא את זמינותך.</p>
            
            <p>נשמח אם תוכל/י לאשר את זמינותך דרך המערכת באחת משתי הדרכים:</p>
            
            <div style="text-align: center;">
             <a href="{{baseUrl}}/messages" class="button">
    כניסה למערכת למענה על הבקשה
</a>
            </div>

            <p>או דרך:</p>
            <ol>
                <li>כניסה למערכת</li>
                <li>לחיצה על "הודעות" בתפריט העליון</li>
                <li>מענה על בקשת הזמינות</li>
            </ol>

            <div class="deadline">
                <p>⏰ חשוב לדעת:</p>
                <ul>
                    <li>התשובה תקפה ל-24 שעות</li>
                    <li>תשובתך תעדכן את סטטוס הזמינות הכללי שלך במערכת</li>
                </ul>
            </div>
            
            <p>בברכה,<br>צוות מערכת השידוכים</p>
        </div>
    </div>
</body>
</html>
--- End of Content for availability-check.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\email-verification.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid #f0f0f0;
        }
        .content {
            padding: 30px 20px;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
            text-align: center;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #f0f0f0;
            text-align: center;
            font-size: 14px;
            color: #666;
        }
        .info {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>אימות כתובת אימייל</h1>
        </div>
        
        <div class="content">
            {{#if firstName}}
            <h2>שלום {{firstName}}!</h2>
            {{else}}
            <h2>שלום!</h2>
            {{/if}}
            
            <p>תודה שנרשמת למערכת השידוכים שלנו. כדי להשלים את תהליך ההרשמה, אנא לחץ/י על הכפתור הבא:</p>
            
            <div style="text-align: center;">
                <a href="{{verificationLink}}" class="button">
                    אימות כתובת אימייל
                </a>
            </div>

            <div class="info">
                <p>⏰ שים/י לב: קישור זה תקף ל-{{expiresIn}}</p>
                <p>אם לא ביקשת לאמת את כתובת האימייל שלך, אנא התעלם/י מהודעה זו.</p>
            </div>

            <p>לאחר האימות, תוכל/י להשלים את פרטי הפרופיל שלך ולהתחיל להשתמש במערכת.</p>
        </div>

        <div class="footer">
            <p>בברכה,<br>צוות מערכת השידוכים</p>
            {{#if supportEmail}}
            <p>לתמיכה: {{supportEmail}}</p>
            {{/if}}
        </div>
    </div>
</body>
</html>
--- End of Content for email-verification.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\emailTemplates.ts
--------------------------------------------------------------------------------
Content:
// src/lib/email/templates/emailTemplates.ts

import { EmailDictionary } from '@/types/dictionary';
import { Locale } from '../../../../i18n-config'; // ודא שהנתיב נכון
import { ProfileFeedbackReport } from '@/lib/services/profileFeedbackService'; // ייבוא חדש

// --- הגדרות טיפוסים לקונטקסט של כל תבנית ---
interface BaseTemplateContext {
  locale: Locale;
  supportEmail: string;
  currentYear: string;
  companyName: string;
  baseUrl: string;
  sharedDict: EmailDictionary['shared'];
  name: string;
}

export interface ProfileFeedbackTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['profileFeedback'];
  report: ProfileFeedbackReport;
  isAutomated: boolean;
  matchmakerName: string;
  greeting?: string; // הוספת שדה greeting אופציונלי
}

// שאר הטיפוסים נשארים זהים...
export interface WelcomeTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['welcome'];
  firstName: string;
  matchmakerAssigned?: boolean;
  matchmakerName?: string;
  dashboardUrl: string;
}

export interface AccountSetupTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['accountSetup'];
  firstName: string;
  matchmakerName: string;
  setupLink: string;
  expiresIn: string;
}

export interface EmailOtpVerificationTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['emailOtpVerification'];
  verificationCode: string;
  expiresIn: string;
}

export interface InvitationTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['invitation'];
  matchmakerName: string;
  invitationLink: string;
  expiresIn: string;
}
export interface ProfileSummaryUpdateTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['profileSummaryUpdate'];
  firstName: string;
  matchmakerName: string;
  dashboardUrl: string;
}

export interface SuggestionTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['suggestion'];
  recipientName: string;
  matchmakerName: string;
  suggestionDetails?: { age?: number; city?: string; occupation?: string; additionalInfo?: string | null; };
  dashboardUrl: string;
}

export interface ContactDetailsTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['shareContactDetails'];
  recipientName: string;
  otherPartyName: string;
  otherPartyContact: { phone?: string; email?: string; whatsapp?: string; };
  matchmakerName: string;
}

export interface AvailabilityCheckTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['availabilityCheck'];
  recipientName: string;
  matchmakerName: string;
  inquiryId: string;
}

export interface PasswordResetOtpTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['passwordResetOtp'];
  otp: string;
  expiresIn: string;
}

export interface PasswordChangedConfirmationTemplateContext extends BaseTemplateContext {
  dict: EmailDictionary['passwordChangedConfirmation'];
  loginUrl: string;
}

export interface InternalFeedbackNotificationTemplateContext {
    feedbackType: string;
    userIdentifier: string;
    content: string;
    pageUrl: string;
    screenshotUrl?: string;
    feedbackId: string;
}

// מפה בין שם התבנית לסוג הקונטקסט שלה
export type TemplateContextMap = {
  welcome: WelcomeTemplateContext;
  accountSetup: AccountSetupTemplateContext;
  emailOtpVerification: EmailOtpVerificationTemplateContext;
  invitation: InvitationTemplateContext;
  suggestion: SuggestionTemplateContext;
  shareContactDetails: ContactDetailsTemplateContext;
  availabilityCheck: AvailabilityCheckTemplateContext;
  passwordResetOtp: PasswordResetOtpTemplateContext;
  passwordChangedConfirmation: PasswordChangedConfirmationTemplateContext;
    profileSummaryUpdate: ProfileSummaryUpdateTemplateContext; // ✨ הוספת התבנית החדשה למפה

  'internal-feedback-notification': InternalFeedbackNotificationTemplateContext;
  // שים לב: אנחנו משאירים את הטיפוס כאן, אך לא נגדיר עבורו פונקציה
  'profileFeedback': ProfileFeedbackTemplateContext;
};

// --- פונקציית עזר ליצירת HTML בסיסי לאימיילים פנימיים ---
const createInternalBaseEmailHtml = (title: string, content: string): string => {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; line-height: 1.6; color: #333; }
        .container { max-width: 700px; margin: 20px auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px; background-color: #fff; }
        h1 { color: #06b6d4; border-bottom: 2px solid #f0f0f0; padding-bottom: 10px; margin-top: 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { text-align: left; padding: 12px; border-bottom: 1px solid #eee; vertical-align: top; }
        th { background-color: #f7f7f7; font-weight: 600; width: 150px; }
        pre { white-space: pre-wrap; font-family: inherit; margin: 0; }
        .screenshot { margin-top: 25px; }
        .screenshot h2 { font-size: 18px; color: #333; margin-bottom: 10px; }
        .screenshot img { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }
        a { color: #06b6d4; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        ${content}
    </div>
</body>
</html>`;
};

// --- פונקציית עזר ליצירת HTML בסיסי ---
const createBaseEmailHtml = (title: string, content: string, context: BaseTemplateContext): string => {
    const isRtl = context.locale === 'he';
    const direction = isRtl ? 'rtl' : 'ltr';
    const textAlign = isRtl ? 'right' : 'left';

    return `
<!DOCTYPE html>
<html dir="${direction}" lang="${context.locale}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; direction: ${direction}; text-align: ${textAlign}; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; border-bottom: 5px solid #0891b2; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .otp-code { font-size: 28px; font-weight: bold; color: #ec4899; text-align: center; margin: 25px 0; padding: 15px; background-color: #fdf2f8; border: 1px dashed #fbcfe8; border-radius: 5px; letter-spacing: 3px; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .footer a { color: #06b6d4; text-decoration: none; }
        .highlight-box { background-color: #fef9e7; border-${isRtl ? 'right' : 'left'}: 4px solid #f7c75c; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .attributes-list { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header"><h1>${title}</h1></div>
        <div class="email-body">
            ${content}
            <p style="margin-top: 30px;">${context.sharedDict.closing}<br>${context.sharedDict.team}</p>
        </div>
        <div class="footer">
            <p>${context.sharedDict.supportPrompt} <a href="mailto:${context.supportEmail}">${context.supportEmail}</a></p>
            <p>${context.sharedDict.rightsReserved.replace('{{year}}', context.currentYear)}</p>
        </div>
    </div>
</body>
</html>
`;
};

// --- מיפוי התבניות עם הטיפוס המדויק ---
export const emailTemplates: {
  [K in keyof TemplateContextMap]: (context: TemplateContextMap[K]) => string;
} = {
  welcome: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name)}</p>
    <p>${context.dict.intro}</p>
    ${context.matchmakerAssigned && context.matchmakerName ? `
      <div class="highlight-box">
        <p><strong>${context.dict.matchmakerAssigned.replace('{{matchmakerName}}', context.matchmakerName)}</strong></p>
      </div>` : ''
    }
    <p>${context.dict.getStarted}</p>
    <p style="text-align: center;">
      <a href="${context.dashboardUrl}" class="button">${context.dict.dashboardButton}</a>
    </p>
  `, context),

  accountSetup: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name)}</p>
    <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
    <p>${context.dict.actionPrompt}</p>
    <p style="text-align: center;">
      <a href="${context.setupLink}" class="button">${context.dict.actionButton}</a>
    </p>
    <div class="highlight-box">
      <p><strong>${context.dict.notice.replace('{{expiresIn}}', context.expiresIn)}</strong></p>
    </div>
    <p>${context.dict.nextStep}</p>
  `, context),
  
    profileSummaryUpdate: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name)}</p>
    <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
    <div class="highlight-box">
      <p><strong>${context.dict.highlight}</strong></p>
    </div>
    <p>${context.dict.encouragement}</p>
    <p style="text-align: center;">
      <a href="${context.dashboardUrl}" class="button">${context.dict.actionButton}</a>
    </p>
  `, context),
  // ✨ END: הוספת לוגיקת תבנית חדשה

  emailOtpVerification: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name || 'משתמש יקר')}</p>
    <p>${context.dict.intro}</p>
    <p>${context.dict.codeInstruction}</p>
    <div class="otp-code">${context.verificationCode}</div>
    <p>${context.dict.expiryNotice.replace('{{expiresIn}}', context.expiresIn)}</p>
    <p>${context.dict.securityNote}</p>
  `, context),

  invitation: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name)}</p>
    <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
    <p>${context.dict.actionPrompt}</p>
    <p style="text-align: center;">
      <a href="${context.invitationLink}" class="button">${context.dict.actionButton}</a>
    </p>
    <p>${context.dict.expiryNotice.replace('{{expiresIn}}', context.expiresIn)}</p>
  `, context),
  
  suggestion: (context) => {
    let detailsHtml = '';
    if (context.suggestionDetails) {
      const detailsList = [
        context.suggestionDetails.age && `<li><strong>${context.dict.details.age}:</strong> ${context.suggestionDetails.age}</li>`,
        context.suggestionDetails.city && `<li><strong>${context.dict.details.city}:</strong> ${context.suggestionDetails.city}</li>`,
        context.suggestionDetails.occupation && `<li><strong>${context.dict.details.occupation}:</strong> ${context.suggestionDetails.occupation}</li>`,
        context.suggestionDetails.additionalInfo && `<li><strong>${context.dict.details.additionalInfo}:</strong> ${context.suggestionDetails.additionalInfo}</li>`,
      ].filter(Boolean).join('');
      
      if (detailsList) {
        detailsHtml = `
          <div class="attributes-list">
            <h4>${context.dict.previewTitle}</h4>
            <ul>${detailsList}</ul>
          </div>`;
      }
    }
    
     return createBaseEmailHtml(
       context.dict.title, 
       `
        <p>${context.sharedDict.greeting.replace('{{name}}', context.recipientName)}</p>
        <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
        ${detailsHtml}
        <p>${context.dict.actionPrompt}</p>
        <p style="text-align: center;">
            <a href="${context.dashboardUrl}" class="button">${context.dict.actionButton}</a>
        </p>
        <p>${context.dict.closing}</p>
      `, 
      context
    );
  },
'profileFeedback': (context) => {
    // כאן, במקום לבנות HTML ידנית, אנו משתמשים במנוע התבניות
    // שנטען על ידי השרת שלך (למשל, hbs). הלוגיקה עצמה נמצאת בקובץ ה-hbs.
    // הקוד כאן רק צריך להעביר את האובייקט 'context' למנוע העיבוד.
    // לצורך הדוגמה, אני מדמה את זה. ודא שהתשתית שלך תומכת בזה.
    const Handlebars = require('handlebars'); // ייבוא סימבולי
    const templateSource = require('./profile-feedback.hbs'); // טעינה סימבולית של הקובץ
    const compiledTemplate = Handlebars.compile(templateSource);
    return compiledTemplate(context);
},
  shareContactDetails: (context) => {
    const contactInfoHtml = [
      context.otherPartyContact.phone && `<p><strong>טלפון:</strong> ${context.otherPartyContact.phone}</p>`,
      context.otherPartyContact.email && `<p><strong>אימייל:</strong> <a href="mailto:${context.otherPartyContact.email}">${context.otherPartyContact.email}</a></p>`,
      context.otherPartyContact.whatsapp && `<p><strong>וואטסאפ:</strong> ${context.otherPartyContact.whatsapp}</p>`,
    ].filter(Boolean).join('');

    return createBaseEmailHtml(context.dict.title, `
      <p>${context.sharedDict.greeting.replace('{{name}}', context.recipientName)}</p>
      <p>${context.dict.intro}</p>
      <div class="attributes-list">
        <h3>${context.dict.detailsOf.replace('{{otherPartyName}}', context.otherPartyName)}</h3>
        ${contactInfoHtml || '<p>לא סופקו פרטי קשר.</p>'}
      </div>
      <div class="highlight-box">
        <p><strong>${context.dict.tipTitle}</strong> ${context.dict.tipContent}</p>
      </div>
      <p>${context.dict.goodLuck}</p>
    `, context);
  },

  availabilityCheck: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.recipientName)}</p>
    <p>${context.dict.intro.replace('{{matchmakerName}}', context.matchmakerName)}</p>
    <p>${context.dict.actionPrompt}</p>
    <p style="text-align: center;">
      <a href="${context.baseUrl}/dashboard/suggestions?inquiryId=${context.inquiryId}" class="button">${context.dict.actionButton}</a>
    </p>
    <div class="highlight-box">
      <p><strong>${context.dict.noticeTitle}</strong> ${context.dict.noticeContent}</p>
    </div>
  `, context),

  passwordResetOtp: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name || 'משתמש יקר')}</p>
    <p>${context.dict.intro}</p>
    <p>${context.dict.codeInstruction}</p>
    <div class="otp-code">${context.otp}</div>
    <p>${context.dict.expiryNotice.replace('{{expiresIn}}', context.expiresIn)}</p>
    <p>${context.dict.securityNote}</p>
  `, context),

  passwordChangedConfirmation: (context) => createBaseEmailHtml(context.dict.title, `
    <p>${context.sharedDict.greeting.replace('{{name}}', context.name || 'משתמש יקר')}</p>
    <p>${context.dict.intro}</p>
    <div class="highlight-box">
      <p>${context.dict.securityNote}</p>
    </div>
    <p style="text-align: center;">
      <a href="${context.loginUrl}" class="button">${context.dict.actionButton}</a>
    </p>
  `, context),
  
  // ============================ הוספת התבנית החדשה כאן ============================
  'internal-feedback-notification': (context) => createInternalBaseEmailHtml('New Feedback Received', `
    <h1>New Feedback Received</h1>
    <p>A new piece of feedback has been submitted through the website widget.</p>
    
    <table>
        <tr>
            <th>Feedback ID</th>
            <td>${context.feedbackId}</td>
        </tr>
        <tr>
            <th>Type</th>
            <td><strong>${context.feedbackType}</strong></td>
        </tr>
        <tr>
            <th>Submitted By</th>
            <td>${context.userIdentifier}</td>
        </tr>
        <tr>
            <th>Page URL</th>
            <td><a href="${context.pageUrl}" target="_blank">${context.pageUrl}</a></td>
        </tr>
        <tr>
            <th>Content</th>
            <td><pre>${context.content}</pre></td>
        </tr>
    </table>

    ${context.screenshotUrl ? `
    <div class="screenshot">
        <h2>Screenshot Attached</h2>
        <a href="${context.screenshotUrl}" target="_blank">
            <img src="${context.screenshotUrl}" alt="User-submitted screenshot">
        </a>
    </div>
    ` : ''}
  `),
  // ==============================================================================
};
--- End of Content for emailTemplates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\internal-feedback-notification.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>New Feedback Received</title>
    <style>
        body { font-family: sans-serif; line-height: 1.5; color: #333; }
        .container { max-width: 700px; margin: 20px auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        h1 { color: #06b6d4; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { text-align: left; padding: 12px; border-bottom: 1px solid #eee; }
        th { background-color: #f7f7f7; font-weight: 600; }
        .screenshot { margin-top: 20px; }
        .screenshot img { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>New Feedback Received</h1>
        <p>A new piece of feedback has been submitted through the website widget.</p>
        
        <table>
            <tr>
                <th>Feedback ID</th>
                <td>{{feedbackId}}</td>
            </tr>
            <tr>
                <th>Type</th>
                <td><strong>{{feedbackType}}</strong></td>
            </tr>
            <tr>
                <th>Submitted By</th>
                <td>{{userIdentifier}}</td>
            </tr>
            <tr>
                <th>Page URL</th>
                <td><a href="{{pageUrl}}">{{pageUrl}}</a></td>
            </tr>
            <tr>
                <th>Content</th>
                <td><pre style="white-space: pre-wrap; font-family: sans-serif;">{{content}}</pre></td>
            </tr>
        </table>

        {{#if screenshotUrl}}
        <div class="screenshot">
            <h2>Screenshot Attached</h2>
            <a href="{{screenshotUrl}}" target="_blank">
                <img src="{{screenshotUrl}}" alt="User-submitted screenshot">
            </a>
        </div>
        {{/if}}
    </div>
</body>
</html>
--- End of Content for internal-feedback-notification.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\invitation.hbs
--------------------------------------------------------------------------------
Content:
{{! src/lib/email/templates/invitation.hbs - Updated Version }}
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{dict.title}}</title>
    <style>
        body { font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; direction: rtl; text-align: right; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; border-bottom: 5px solid #0891b2; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .footer a { color: #06b6d4; text-decoration: none; }
        .highlight-box { background-color: #fef9e7; border-right: 4px solid #f7c75c; padding: 15px; margin: 20px 0; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>{{dict.title}}</h1>
        </div>
        <div class="email-body">
            <p>{{sharedDict.greeting.replace '{{name}}' name}}</p>
            <p>{{dict.intro}}</p>
            <p>{{dict.actionPrompt}}</p>
            
            <p style="text-align: center;">
                <a href="{{invitationLink}}" class="button">{{dict.actionButton}}</a>
            </p>

            <div class="highlight-box">
                <p><strong>{{dict.expiryNotice}}</strong></p>
            </div>

            <p style="margin-top: 30px;">{{sharedDict.closing}}<br>{{sharedDict.team}}</p>
        </div>
        <div class="footer">
            <p>{{sharedDict.supportPrompt}} <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
            <p>{{sharedDict.rightsReserved}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for invitation.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\password-changed-confirmation.html
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אישור שינוי סיסמה - NeshamaTech</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; direction: rtl; text-align: right; }
        .container { max-width: 600px; margin: 20px auto; background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .header { background-color: #10b981; /* Green */ color: #ffffff; padding: 15px; text-align: center; border-top-left-radius: 8px; border-top-right-radius: 8px; }
        .header h1 { margin: 0; font-size: 24px; }
        .content { padding: 20px; color: #333333; line-height: 1.6; }
        .footer { text-align: center; padding: 15px; font-size: 12px; color: #777777; border-top: 1px solid #eeeeee; margin-top: 20px; }
        .button { display: inline-block; background-color: #06b6d4; color: #ffffff !important; padding: 10px 20px; text-decoration: none; border-radius: 5px; font-weight: bold; margin-top: 15px; }
        a { color: #06b6d4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>הסיסמה שלך שונתה בהצלחה</h1>
        </div>
        <div class="content">
            <p>שלום {{firstName}},</p>
            <p>אנו מאשרים שהסיסמה עבור חשבונך ב-NeshamaTech שונתה בהצלחה.</p>
            <p>אם לא ביצעת שינוי זה, או אם אתה חושד בפעילות לא מורשית בחשבונך, אנא פנה אלינו באופן מיידי בכתובת: <a href="mailto:{{supportEmail}}">{{supportEmail}}</a>.</p>
            <p>תוכל להתחבר לחשבונך כעת באמצעות הסיסמה החדשה שלך:</p>
            <p style="text-align: center;">
                <a href="{{loginUrl}}" class="button">התחבר לחשבונך</a>
            </p>
            <p>בברכה,<br>צוות NeshamaTech</p>
        </div>
        <div class="footer">
            © {{currentYear}} NeshamaTech. כל הזכויות שמורות.
        </div>
    </div>
</body>
</html>
--- End of Content for password-changed-confirmation.html ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\password-reset-otp.html
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-TMLF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>איפוס סיסמה - NeshamaTech</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; direction: rtl; text-align: right; }
        .container { max-width: 600px; margin: 20px auto; background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .header { background-color: #06b6d4; /* Cyan */ color: #ffffff; padding: 15px; text-align: center; border-top-left-radius: 8px; border-top-right-radius: 8px; }
        .header h1 { margin: 0; font-size: 24px; }
        .content { padding: 20px; color: #333333; line-height: 1.6; }
        .otp-code { font-size: 28px; font-weight: bold; color: #ec4899; /* Pink */ text-align: center; margin: 20px 0; padding: 10px; background-color: #fdf2f8; border: 1px dashed #ec4899; border-radius: 4px; }
        .instructions { font-size: 14px; color: #555555; }
        .important { color: #d9534f; font-weight: bold; }
        .footer { text-align: center; padding: 15px; font-size: 12px; color: #777777; border-top: 1px solid #eeeeee; margin-top: 20px; }
        .button { display: inline-block; background-color: #06b6d4; color: #ffffff !important; padding: 10px 20px; text-decoration: none; border-radius: 5px; font-weight: bold; margin-top: 15px; }
        a { color: #06b6d4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>איפוס סיסמה</h1>
        </div>
        <div class="content">
            <p>שלום {{firstName}},</p>
            <p>קיבלנו בקשה לאיפוס הסיסמה שלך עבור חשבונך ב-NeshamaTech.</p>
            <p>אנא השתמש בקוד האימות החד-פעמי הבא כדי לאפס את סיסמתך:</p>
            <div class="otp-code">{{otp}}</div>
            <p class="instructions">הקוד תקף למשך {{expiresIn}}.</p>
            <p class="instructions">אם לא ביקשת לאפס את סיסמתך, אנא התעלם ממייל זה. ייתכן שמישהו אחר הזין את כתובת המייל שלך בטעות.</p>
            <p class="important instructions">מטעמי אבטחה, לעולם אל תשתף קוד זה עם אף אחד.</p>
            <p>אם אתה נתקל בבעיות כלשהן, או שאתה זקוק לעזרה נוספת, אנא פנה לתמיכה שלנו בכתובת: <a href="mailto:{{supportEmail}}">{{supportEmail}}</a>.</p>
            <p>בברכה,<br>צוות NeshamaTech</p>
        </div>
        <div class="footer">
            © {{currentYear}} NeshamaTech. כל הזכויות שמורות.
        </div>
    </div>
</body>
</html>
--- End of Content for password-reset-otp.html ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\password-reset.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        .content {
            padding: 20px;
        }
        .verification-code {
            text-align: center;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 5px;
            margin: 20px 0;
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 5px;
            color: #1a56db;
            border: 1px dashed #a4cafe;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .important-note {
            background-color: #fff9e6;
            border-right: 4px solid #fbbf24;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .steps {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .step {
            margin-bottom: 10px;
            padding-right: 25px;
            position: relative;
        }
        .step:before {
            content: "✓";
            position: absolute;
            right: 0;
            color: #4F46E5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>קוד לשינוי סיסמה</h1>
        </div>
        <div class="content">
            <h2>שלום,</h2>
            <p>קיבלנו בקשה לשינוי הסיסמה שלך. להשלמת התהליך, השתמש בקוד האימות הבא:</p>
            
            <div class="verification-code">
                {{resetLink}}
            </div>

            <div class="steps">
                <h3>כיצד להשתמש בקוד:</h3>
                <div class="step">
                    הזן את הקוד בחלון שינוי הסיסמה במערכת
                </div>
                <div class="step">
                    הסיסמה החדשה תיכנס לתוקף לאחר אישור הקוד
                </div>
            </div>

            <div class="important-note">
                <strong>🔒 שים לב:</strong>
                <p>הקוד תקף ל-{{expiresIn}} בלבד ויכול לשמש פעם אחת בלבד.</p>
                <p>אם לא ביקשת לשנות את הסיסמה שלך, אנא התעלם מהודעה זו והסיסמה הנוכחית תישאר בתוקף.</p>
            </div>
        </div>

        <div class="footer">
            <p>
                הודעה זו נשלחה אוטומטית, אנא אל תשיב להודעה זו.
                <br>
                לתמיכה: {{supportEmail}}
            </p>
        </div>
    </div>
</body>
</html>
--- End of Content for password-reset.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\profile-feedback.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="{{#if (eq locale 'he')}}rtl{{else}}ltr{{/if}}" lang="{{locale}}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{dict.title}}</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Arial, sans-serif; 
            direction: {{#if (eq locale 'he')}}rtl{{else}}ltr{{/if}}; 
            text-align: {{#if (eq locale 'he')}}right{{else}}left{{/if}}; 
            line-height: 1.6; 
            margin: 0; 
            padding: 0; 
            background-color: #f8fafc; 
            color: #374151; 
        }
        
        .email-container { 
            max-width: 600px; 
            margin: 20px auto; 
            background-color: #ffffff; 
            border-radius: 12px; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.08); 
            overflow: hidden; 
        }
        
        .email-header { 
            background: linear-gradient(135deg, #06b6d4, #0891b2); 
            color: #ffffff; 
            padding: 30px; 
            text-align: center; 
        }
        
        .email-header h1 { 
            margin: 0; 
            font-size: 26px; 
            font-weight: 700; 
            letter-spacing: -0.5px;
        }
        
        .email-body { 
            padding: 30px; 
            font-size: 16px; 
        }
        
        .greeting {
            font-size: 20px;
            color: #1e293b;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .intro-text {
            font-size: 16px;
            color: #475569;
            margin-bottom: 30px;
            line-height: 1.7;
        }
        
        /* Progress Section */
        .progress-section {
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            border: 2px solid #bfdbfe;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }
        
        .progress-title {
            color: #1e40af;
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 15px;
        }
        
        .progress-number {
            font-size: 48px;
            font-weight: 900;
            color: #06b6d4;
            margin: 10px 0;
        }
        
        .progress-bar-container {
            background-color: #e2e8f0;
            border-radius: 25px;
            height: 20px;
            margin: 20px 0;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #06b6d4, #0891b2);
            height: 100%;
            border-radius: 25px;
            transition: width 1s ease-out;
            position: relative;
        }
        
        .progress-text {
            color: #64748b;
            font-size: 15px;
            margin-top: 10px;
            font-weight: 500;
        }
        
        /* AI Summary */
        .ai-summary {
            background: linear-gradient(135deg, #fefce8, #fef3c7);
            border-{{#if (eq locale 'he')}}right{{else}}left{{/if}}: 5px solid #f59e0b;
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
        }
        
        .ai-summary h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #b45309;
            font-size: 18px;
            font-weight: 700;
        }
        
        .ai-insight {
            background: rgba(255, 255, 255, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .ai-insight strong {
            color: #92400e;
            font-weight: 600;
        }
        
        .ai-disclaimer {
            font-size: 14px;
            color: #6b7280;
            font-style: italic;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 6px;
        }
        
        /* Status Section */
        .status-section {
            margin: 30px 0;
        }
        
        .section-title {
            font-size: 22px;
            color: #1e293b;
            margin-bottom: 25px;
            font-weight: 700;
            border-bottom: 3px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }
        
        .status-card {
            border-radius: 12px;
            padding: 20px;
            border: 2px solid;
        }
        
        .completed-card {
            background: linear-gradient(135deg, #f0fdf4, #dcfce7);
            border-color: #22c55e;
        }
        
        .missing-card {
            background: linear-gradient(135deg, #fffbeb, #fef3c7);
            border-color: #f59e0b;
        }
        
        .card-title {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 700;
        }
        
        .completed-card .card-title {
            color: #15803d;
        }
        
        .missing-card .card-title {
            color: #b45309;
        }
        
        .status-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .status-item {
            padding: 8px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-icon {
            margin-{{#if (eq locale 'he')}}left{{else}}right{{/if}}: 10px;
            font-size: 18px;
        }
        
        /* Questionnaire Section */
        .questionnaire-section {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border: 2px solid #0ea5e9;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
        }
        
        .questionnaire-title {
            color: #0369a1;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        
        .questionnaire-icon {
            margin-{{#if (eq locale 'he')}}left{{else}}right{{/if}}: 10px;
            font-size: 24px;
        }
        
        .question-summary {
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 600;
            color: #0369a1;
            font-size: 16px;
        }
        
        .question-details {
            color: #0369a1;
            text-align: center;
            font-weight: 600;
            margin-top: 10px;
        }
        
        /* CTA Section */
        .cta-section {
            background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
            border: 2px solid #94a3b8;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin: 30px 0;
        }
        
        .cta-title {
            font-size: 24px;
            color: #1e293b;
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .cta-text {
            color: #64748b;
            margin-bottom: 25px;
            font-size: 16px;
        }
        
        .cta-button {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: white !important;
            text-decoration: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 18px;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(6, 182, 212, 0.3);
            transition: transform 0.2s ease;
        }
        
        .cta-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(6, 182, 212, 0.4);
        }
        
        /* Footer */
        .footer {
            background-color: #f8fafc;
            padding: 25px;
            text-align: center;
            font-size: 14px;
            color: #64748b;
            border-top: 1px solid #e2e8f0;
        }
        
        .footer a {
            color: #06b6d4;
            text-decoration: none;
        }
        
        /* Mobile Responsive */
        @media (max-width: 600px) {
            .status-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .email-body {
                padding: 20px;
            }
            
            .progress-number {
                font-size: 36px;
            }
            
            .cta-title {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="email-container">
        <!-- Header -->
        <div class="email-header">
            <h1>{{dict.title}}</h1>
        </div>
        
        <!-- Body -->
        <div class="email-body">
            <!-- Greeting -->
            <div class="greeting">{{greeting}}</div>
            
            <div class="intro-text">
                {{#if isAutomated}}
                    {{dict.systemIntro}}
                {{else}}
                    {{dict.matchmakerIntro}}
                {{/if}}
            </div>

            <!-- Progress Section -->
            <div class="progress-section">
                <div class="progress-title">{{dict.progressHeader}}</div>
                <div class="progress-number">{{report.completionPercentage}}%</div>
                <div class="progress-bar-container">
                    <div class="progress-bar" style="width: {{report.completionPercentage}}%;"></div>
                </div>
                <div class="progress-text">
                    השקעת עד כה והגעת ל-<strong>{{report.completionPercentage}}% השלמה</strong>.<br>
                    כל הכבוד! עוד מאמץ קטן והפרופיל שלך יהיה מוכן למצוא את ההתאמה המושלמת.
                </div>
            </div>

            {{#if report.aiSummary}}
            <!-- AI Summary -->
            <div class="ai-summary">
                <h3>{{dict.aiSummaryHeader}}</h3>
                
                <div class="ai-insight">
                    <strong>{{dict.aiSummary.personalityTitle}}:</strong><br>
                    "{{report.aiSummary.personality}}"
                </div>
                
                <div class="ai-insight">
                    <strong>{{dict.aiSummary.lookingForTitle}}:</strong><br>
                    "{{report.aiSummary.lookingFor}}"
                </div>
                
                <div class="ai-disclaimer">
                    זוהי רק טעימה מהתובנות שה-AI שלנו יכול להפיק מפרופיל מלא. ככל שתוסיף יותר מידע, כך נוכל לחדד יותר את ההתאמות עבורך.
                </div>
            </div>
            {{/if}}

            <!-- Status Section -->
            <div class="status-section">
                <h2 class="section-title">סטטוס הפרופיל שלך</h2>
                
                <div class="status-grid">
                    <!-- Completed Items -->
                    <div class="status-card completed-card">
                        <h4 class="card-title">כל הכבוד! מה שכבר השלמת:</h4>
                        <ul class="status-list">
                            {{#each report.completedProfileItems}}
                                <li class="status-item">
                                    <span class="status-icon">✅</span>
                                    {{this}}
                                </li>
                            {{/each}}
                        </ul>
                    </div>
                    
                    <!-- Missing Items -->
                    <div class="status-card missing-card">
                        <h4 class="card-title">השלב הבא: מה חסר</h4>
                        <ul class="status-list">
                             {{#each report.missingProfileItems}}
                                <li class="status-item">
                                    <span class="status-icon">📝</span>
                                    {{this}}
                                </li>
                            {{/each}}
                        </ul>
                    </div>
                </div>
                
                {{#if report.missingQuestionnaireItems}}
                <div class="questionnaire-section">
                    <div class="questionnaire-title">
                        <span class="questionnaire-icon">📋</span>
                        שאלון המעמיק - הזדמנות זהב!
                    </div>
                    
                    <div class="question-summary">
                        יש לנו {{report.missingQuestionnaireItems.length}} שאלות מעמיקות שמחכות לך!<br>
                        הן יעזרו לנו להכיר אותך טוב יותר ולמצוא התאמות מדויקות.
                    </div>
                    
                    <p class="question-details">
                        השאלות מחולקות לעולמות: אישיות, ערכים, זוגיות, פרטנר ודת ומסורת
                    </p>
                </div>
                {{/if}}
            </div>

            <!-- CTA Section -->
            <div class="cta-section">
                <h3 class="cta-title">{{dict.cta.title}}</h3>
                <p class="cta-text">השלמת הפרופיל מגדילה משמעותית את הסיכוי למצוא התאמה איכותית.</p>
                <a href="{{baseUrl}}/profile" class="cta-button">{{dict.cta.button}}</a>
            </div>

        </div>
        
        <!-- Footer -->
        <div class="footer">
             <p>{{sharedDict.supportPrompt}} <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
             <p>{{sharedDict.rightsReserved}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for profile-feedback.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\profile-summary-update.hbs
--------------------------------------------------------------------------------
Content:
{{! src/lib/email/templates/profile-summary-update.hbs }}
<!DOCTYPE html>
<html dir="{{#if (eq locale 'he')}}rtl{{else}}ltr{{/if}}" lang="{{locale}}">
<head>
    <meta charset="UTF-8">
    <title>{{dict.title}}</title>
    <style>
        body { font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; direction: {{#if (eq locale 'he')}}rtl{{else}}ltr{{/if}}; text-align: {{#if (eq locale 'he')}}right{{else}}left{{/if}}; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; border-bottom: 5px solid #0891b2; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .footer a { color: #06b6d4; text-decoration: none; }
        .highlight-box { background-color: #f0f9ff; border-{{#if (eq locale 'he')}}right{{else}}left{{/if}}: 4px solid #38bdf8; padding: 15px; margin: 20px 0; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>{{dict.title}}</h1>
        </div>
        <div class="email-body">
            <p>{{replace sharedDict.greeting '{{name}}' name}}</p>
            <p>{{replace dict.intro '{{matchmakerName}}' matchmakerName}}</p>
            <div class="highlight-box">
                <p><strong>{{dict.highlight}}</strong></p>
            </div>
            <p>{{dict.encouragement}}</p>
            <p style="text-align: center;">
                <a href="{{dashboardUrl}}" class="button">{{dict.actionButton}}</a>
            </p>
            <p style="margin-top: 30px;">{{sharedDict.closing}}<br>{{sharedDict.team}}</p>
        </div>
        <div class="footer">
            <p>{{sharedDict.supportPrompt}} <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
            <p>{{replace sharedDict.rightsReserved '{{year}}' currentYear}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for profile-summary-update.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\share-contact-details.hbs
--------------------------------------------------------------------------------
Content:
// src/lib/email/templates/share-contact-details.hbs
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        .content {
            padding: 20px;
        }
        .contact-details {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .important-note {
            background-color: #fef3c7;
            border-right: 4px solid #f59e0b;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>פרטי קשר לפגישה ראשונה</h1>
        </div>
        
        <div class="content">
            <h2>שלום {{recipientName}}!</h2>
            
            <p>השדכן/ית {{matchmakerName}} אישר/ה את ההצעה ואתם יכולים ליצור קשר ראשוני!</p>

        <div class="contact-details">
  <h3>פרטי הקשר של {{otherPartyName}}:</h3>
  {{#if otherPartyContact.email}}
    <p>📧 אימייל: {{otherPartyContact.email}}</p>
  {{/if}}
  {{#if otherPartyContact.whatsapp}}
    <p>💬 וואטסאפ: {{otherPartyContact.whatsapp}}</p>
  {{/if}}
</div>

            <div class="important-note">
                <h4>🔔 שימו לב:</h4>
                <ul>
                    <li>מומלץ ליצור קשר תוך 24 שעות</li>
                    <li>אנא עדכנו את השדכן/ית על קביעת הפגישה</li>
                    <li>לאחר הפגישה, תתבקשו למלא משוב קצר במערכת</li>
                </ul>
            </div>

            <p>בהצלחה רבה! אנו מאחלים לכם פגישה טובה ומוצלחת.</p>
        </div>

        <div class="footer">
            <p>בברכה,<br>צוות מערכת השידוכים</p>
            <p>{{supportEmail}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for share-contact-details.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\suggestion.hbs
--------------------------------------------------------------------------------
Content:
{{! src/lib/email/templates/suggestion.hbs - Updated Version }}
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{dict.title}}</title>
    <style>
        body { font-family: 'Arial', 'Helvetica Neue', Helvetica, sans-serif; direction: rtl; text-align: right; line-height: 1.6; margin: 0; padding: 0; background-color: #f8f9fa; color: #343a40; }
        .email-container { max-width: 600px; margin: 20px auto; background-color: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .email-header { background-color: #06b6d4; color: #ffffff; padding: 25px; text-align: center; border-bottom: 5px solid #0891b2; }
        .email-header h1 { margin: 0; font-size: 26px; font-weight: 600; }
        .email-body { padding: 25px 30px; font-size: 16px; }
        .email-body p { margin-bottom: 1em; }
        .button { display: inline-block; padding: 12px 25px; background-color: #06b6d4; color: white !important; text-decoration: none; border-radius: 5px; margin: 15px 0; font-weight: 500; text-align: center; }
        .button:hover { background-color: #0891b2; }
        .footer { background-color: #f1f3f5; padding: 20px; text-align: center; font-size: 0.9em; color: #6c757d; border-top: 1px solid #e9ecef; }
        .footer a { color: #06b6d4; text-decoration: none; }
        .attributes-list { background-color: #f8f9fa; border: 1px solid #e9ecef; padding: 20px; border-radius: 8px; margin: 25px 0; }
        .attributes-list h4 { margin-top: 0; color: #0891b2; }
        .attributes-list ul { padding-right: 20px; margin: 10px 0; list-style-type: disc; }
        .attributes-list li { margin-bottom: 8px; }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>{{dict.title}}</h1>
        </div>
        <div class="email-body">
            <p>{{sharedDict.greeting}}</p>
            <p>{{dict.intro}}</p>
            
            {{{detailsHtml}}}

            <p>{{dict.actionPrompt}}</p>
            
            <p style="text-align: center;">
                <a href="{{dashboardUrl}}" class="button">{{dict.actionButton}}</a>
            </p>

            <p>{{dict.closing}}</p>

            <p style="margin-top: 30px;">{{sharedDict.closing}}<br>{{sharedDict.team}}</p>
        </div>
        <div class="footer">
            <p>{{sharedDict.supportPrompt}} <a href="mailto:{{supportEmail}}">{{supportEmail}}</a></p>
            <p>{{sharedDict.rightsReserved}}</p>
        </div>
    </div>
</body>
</html>
--- End of Content for suggestion.hbs ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\email\templates\welcome.hbs
--------------------------------------------------------------------------------
Content:
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #4F46E5;
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        .content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .steps {
            background-color: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .step {
            margin-bottom: 15px;
            padding-right: 20px;
            position: relative;
        }
        .step:before {
            content: "✓";
            position: absolute;
            right: 0;
            color: #4F46E5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ברוכים הבאים למערכת השידוכים</h1>
        </div>
        <div class="content">
            <h2>שלום {{firstName}}!</h2>
            <p>תודה שבחרת להצטרף למערכת השידוכים שלנו. אנו שמחים לקחת חלק במסע החשוב שלך.</p>
            
            <div class="steps">
                <h3>השלבים הבאים:</h3>
                {{#if requiresVerification}}
                <div class="step">
                    <strong>אימות חשבון:</strong> נשלח אליך מייל נפרד עם קישור לאימות החשבון שלך.
                </div>
                {{/if}}
                <div class="step">
                    <strong>השלמת פרופיל:</strong> הוסף/י את כל הפרטים החשובים שיעזרו לנו למצוא את ההתאמה המושלמת עבורך.
                </div>
                <div class="step">
                    <strong>העדפות התאמה:</strong> הגדר/י את ההעדפות שלך לגבי בן/בת הזוג המיועד/ת.
                </div>
                {{#if matchmakerAssigned}}
                <div class="step">
                    <strong>השדכן/ית שלך:</strong> {{matchmakerName}} ילווה אותך בתהליך.
                </div>
                {{/if}}
            </div>

            <p>מה עכשיו?</p>
            <a href="{{dashboardUrl}}" class="button">כניסה למערכת</a>

            <p>טיפים חשובים:</p>
            <ul>
                <li>מלא/י את הפרופיל בצורה מפורטת ככל האפשר</li>
                <li>הוסף/י תמונה עדכנית לפרופיל</li>
                <li>הגדר/י את העדפות החיפוש שלך בקפידה</li>
                <li>עדכן/י את הסטטוס שלך באופן שוטף</li>
            </ul>

            {{#if privacyNote}}
            <p class="privacy-note">
                <strong>הערה חשובה:</strong> הפרופיל שלך יהיה גלוי רק למשתמשים מאומתים ולשדכנים מורשים במערכת.
            </p>
            {{/if}}
        </div>
        <div class="footer">
            <p>
                מערכת השידוכים | לכל שאלה ניתן ליצור קשר במייל {{supportEmail}}
                {{#if unsubscribeUrl}}
                | <a href="{{unsubscribeUrl}}">הסרה מרשימת התפוצה</a>
                {{/if}}
            </p>
        </div>
    </div>
</body>
</html>
--- End of Content for welcome.hbs ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\aiService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/aiService.ts

import { GoogleGenerativeAI } from '@google/generative-ai';

const apiKey = process.env.GOOGLE_API_KEY;

if (!apiKey) {
  console.error(
    '[FATAL ERROR] GOOGLE_API_KEY is not set in .env or .env.local!'
  );
  throw new Error('GOOGLE_API_KEY must be set.');
}

const genAI = new GoogleGenerativeAI(apiKey);

/**
 * יוצר וקטור הטמעה (embedding) עבור טקסט נתון.
 * @param text הטקסט להטמעה.
 * @returns Promise שמחזיר מערך של מספרים (הווקטור), או null במקרה של כישלון.
 */
export async function generateTextEmbedding(
  text: string
): Promise<number[] | null> {
  try {
    const model = genAI.getGenerativeModel({ model: 'text-embedding-004' });
    const result = await model.embedContent(text);
    const embedding = result.embedding;
    if (embedding && embedding.values) {
      return embedding.values;
    }
    console.error('Embedding generation returned no values.');
    return null;
  } catch (error) {
    console.error('Error generating text embedding:', error);
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח התאמה עבור שדכנים.
 */
export interface AiAnalysisResult {
  overallScore: number;
  matchSummary: string;
  compatibilityPoints: Array<{
    area: string;
    explanation: string;
    strength: 'HIGH' | 'MEDIUM' | 'LOW';
  }>;
  potentialChallenges: Array<{
    area: string;
    explanation: string;
    severity: 'HIGH' | 'MEDIUM' | 'LOW';
  }>;
  suggestedConversationStarters: string[];
}

/**
 * מנתח את ההתאמה בין שני פרופילים נרטיביים עבור שדכן.
 * @param profileAText הפרופיל הנרטיבי של המשתמש הראשון.
 * @param profileBText הפרופיל הנרטיבי של המשתמש השני.
 * @param language שפת הפלט הרצויה.
 * @returns Promise שמחזיר אובייקט ניתוח מובנה, או null במקרה של כישלון.
 */
export async function analyzePairCompatibility(
  profileAText: string,
  profileBText: string,
  language: 'he' | 'en' = 'he'
): Promise<AiAnalysisResult | null> {
  console.log(
    `--- Attempting to analyze compatibility for matchmaker in ${language} ---`
  );
  if (!profileAText || !profileBText) {
    console.error(
      'analyzePairCompatibility called with one or more empty profiles.'
    );
    return null;
  }
  const model = genAI.getGenerativeModel({
    model: 'gemini-2.5-flash',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.3,
    },
  });

  const targetLanguage = language === 'he' ? 'Hebrew' : 'English';

  const prompt = `
    You are a "Matchmaking AI Expert" for a religious Jewish dating platform. Your goal is to analyze the compatibility of two user profiles and provide a structured, insightful, and helpful analysis for the matchmaker.
    
    IMPORTANT: Your entire JSON output, including all string values (keys and explanations), must be in ${targetLanguage}.

    Your output MUST be a valid JSON object. Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.
    The JSON structure: { "overallScore": number, "matchSummary": "string", "compatibilityPoints": [{ "area": "string", "explanation": "string", "strength": "HIGH" | "MEDIUM" | "LOW" }], "potentialChallenges": [{ "area": "string", "explanation": "string", "severity": "HIGH" | "MEDIUM" | "LOW" }], "suggestedConversationStarters": ["string"] }
    --- Profile 1 ---
    ${profileAText}
    --- Profile 2 ---
    ${profileBText}
    `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error('Direct Gemini API returned an empty response.');
      return null;
    }

    console.log(
      `--- Successfully received compatibility analysis from Gemini API in ${language} ---`
    );
    // כאן אין צורך בניקוי מיוחד כי אנחנו מצפים ל-JSON נקי, אבל אם יתחילו בעיות נוסיף גם פה
    return JSON.parse(jsonString) as AiAnalysisResult;
  } catch (error) {
    console.error(
      `Error generating compatibility analysis from Direct Gemini API in ${language}:`,
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח פרופיל עבור המשתמש עצמו.
 */
export interface AiProfileAnalysisResult {
  personalitySummary: string;
  lookingForSummary: string;
  completenessReport: Array<{
    area: string;
    status: 'COMPLETE' | 'PARTIAL' | 'MISSING';
    feedback: string;
  }>;
  actionableTips: Array<{
    area: string;
    tip: string;
  }>;
}

/**
 * מנתח פרופיל של משתמש ומספק משוב וטיפים לשיפור.
 * @param userNarrativeProfile הטקסט הנרטיבי המקיף של פרופיל המשתמש.
 * @returns Promise שמחזיר אובייקט ניתוח מובנה, או null במקרה של כישלון.
 */
export async function getProfileAnalysis(
  userNarrativeProfile: string
): Promise<AiProfileAnalysisResult | null> {
  console.log(
    '--- [AI Profile Advisor] Starting profile analysis with Gemini API ---'
  );

  if (!userNarrativeProfile) {
    console.error(
      '[AI Profile Advisor] Called with an empty user narrative profile.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-2.5-flash',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.4,
    },
  });

  const prompt = `
    You are an expert, warm, and encouraging dating profile coach for a religious Jewish audience. Your goal is to help the user improve their profile to attract the best possible matches. Based on the following comprehensive user profile, provide a structured JSON analysis.
    The entire output MUST be a valid JSON object in Hebrew.
    IMPORTANT: Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.
    The JSON structure must be: { "personalitySummary": "string", "lookingForSummary": "string", "completenessReport": [{ "area": "string", "status": "COMPLETE" | "PARTIAL" | "MISSING", "feedback": "string" }], "actionableTips": [{ "area": "string", "tip": "string" }] }
    
    --- User Profile Narrative ---
    ${userNarrativeProfile}
    --- End of User Profile Narrative ---
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    let jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Profile Advisor] Gemini API returned an empty response.'
      );
      return null;
    }

    // ======================= תהליך הניקוי והפענוח הבטוח =======================
    
    // שלב 1: בדוק אם התשובה עטופה ב-markdown והסר אותו אם כן.
    if (jsonString.startsWith('```json')) {
      jsonString = jsonString.slice(7, -3).trim();
    } else if (jsonString.startsWith('```')) {
        jsonString = jsonString.slice(3, -3).trim();
    }

    try {
        // שלב 2: נסה לפענח את ה-JSON הנקי.
        const parsedJson = JSON.parse(jsonString) as AiProfileAnalysisResult;
        console.log(
          '--- [AI Profile Advisor] Successfully received and parsed analysis from Gemini API. ---'
        );
        return parsedJson;
    } catch (parseError) {
        // שלב 3: אם הפענוח נכשל, הדפס שגיאה מפורטת ואת התשובה הגולמית לטובת דיבאגינג.
        console.error(
          '[AI Profile Advisor] Failed to parse JSON response from Gemini.',
          parseError
        );
        console.error('--- RAW AI RESPONSE THAT FAILED PARSING ---');
        console.error(jsonString);
        console.error('--- END OF RAW AI RESPONSE ---');
        
        // זרוק שגיאה חדשה כדי שהפונקציה שקראה לנו תדע שהתהליך נכשל.
        throw new Error('Invalid JSON response from AI service.');
    }
    // ======================= סוף תהליך הניקוי =======================

  } catch (error) {
    // תפיסת שגיאות תקשורת עם ה-API או את השגיאה שזרקנו מה-catch הפנימי.
    console.error(
      '[AI Profile Advisor] Error during profile analysis process:',
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח הצעה עבור משתמש הקצה.
 */
export interface AiSuggestionAnalysisResult {
  overallScore: number;
  matchTitle: string;
  matchSummary: string;
  compatibilityPoints: Array<{ area: string; explanation: string }>;
  pointsToConsider: Array<{ area: string; explanation: string }>;
  suggestedConversationStarters: string[];
}

/**
 * מנתח התאמה בין שני פרופילים ומחזיר ניתוח מותאם למשתמש הקצה.
 */
export async function analyzeSuggestionForUser(
  currentUserProfileText: string,
  suggestedUserProfileText: string
): Promise<AiSuggestionAnalysisResult | null> {
  console.log(
    '--- [AI Suggestion Advisor] Starting suggestion analysis for user ---'
  );

  if (!currentUserProfileText || !suggestedUserProfileText) {
    console.error(
      '[AI Suggestion Advisor] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-2.5-flash',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.5,
    },
  });

  const prompt = `
    You are a 'Matchmaking AI Advisor'. Your tone is positive, warm, and encouraging. Your goal is to help a user understand the potential of a match suggestion they received. Analyze the compatibility between 'My Profile' and the 'Suggested Profile'.
    Your entire output MUST be a valid JSON object in Hebrew.
    IMPORTANT: Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.
    The JSON structure must be: { "overallScore": number, "matchTitle": "string", "matchSummary": "string", "compatibilityPoints": [{ "area": "string", "explanation": "string (user-friendly explanation)" }], "pointsToConsider": [{ "area": "string", "explanation": "string (rephrased positively, e.g., 'הוא אוהב טיולים ואת מעדיפה בית. זו הזדמנות נהדרת לחוות דברים חדשים יחד!')" }], "suggestedConversationStarters": ["string"] }
    
    --- My Profile ---
    ${currentUserProfileText}

    --- Suggested Profile ---
    ${suggestedUserProfileText}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Suggestion Advisor] Gemini API returned an empty response.'
      );
      return null;
    }

    console.log(
      '--- [AI Suggestion Advisor] Successfully received analysis from Gemini API. ---'
    );
    return JSON.parse(jsonString) as AiSuggestionAnalysisResult;
  } catch (error) {
    console.error(
      '[AI Suggestion Advisor] Error generating suggestion analysis:',
      error
    );
    return null;
  }
}

/**
 * מייצר טקסט נימוק מותאם אישית עבור הצעת שידוך.
 */
export async function generateSuggestionRationale(
  profile1Text: string,
  profile2Text: string
): Promise<string | null> {
  console.log(
    '--- [AI Rationale Writer] Starting suggestion rationale generation ---'
  );
  if (!profile1Text || !profile2Text) {
    console.error(
      '[AI Rationale Writer] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
    You are a professional and sensitive matchmaker in the religious Jewish community. Your task is to write a warm, personal, and compelling justification ('matchingReason') for a match suggestion.
    Based on the two profiles provided, identify 2-3 key points of compatibility (values, life goals, personality traits, background) and weave them into a concise and positive paragraph.
    The output should be ONLY the justification text in Hebrew, without any additional titles, formatting, or explanations. Start directly with the text.

    **Example Output Structure:**
    "אני חושב/ת שיש כאן פוטנציאל להתאמה מצוינת מכמה סיבות. ראשית, שניכם ציינתם ש... וזה מראה על... שנית, הרקע ה... שלכם יכול להוות בסיס משותף חזק. בנוסף, נראה ששניכם חולקים... וזה יכול לתרום רבות לבניית קשר..."

    --- Profile 1 ---
    ${profile1Text}

    --- Profile 2 ---
    ${profile2Text}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    if (!text) {
      console.error(
        '[AI Rationale Writer] Gemini API returned an empty response.'
      );
      return null;
    }

    console.log(
      '--- [AI Rationale Writer] Successfully generated rationale. ---'
    );
    return text.trim();
  } catch (error) {
    console.error(
      '[AI Rationale Writer] Error generating suggestion rationale:',
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של אובייקט הנימוקים המלא.
 */
export interface FullRationaleResult {
  generalRationale: string;
  rationaleForParty1: string;
  rationaleForParty2: string;
}

/**
 * מייצר חבילת נימוקים מלאה עבור הצעת שידוך.
 */
export async function generateFullSuggestionRationale(
  profile1Text: string,
  profile2Text: string
): Promise<FullRationaleResult | null> {
  console.log(
    '--- [AI Rationale Writer] Starting full rationale package generation ---'
  );
  if (!profile1Text || !profile2Text) {
    console.error(
      '[AI Rationale Writer] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-2.5-flash',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.6,
    },
  });

  const prompt = `
    You are a professional and sensitive matchmaker in the religious Jewish community. Your task is to write three distinct texts for a match suggestion based on the two provided user profiles.
    The entire output MUST be a valid JSON object in Hebrew, with the following exact structure:
    {
      "generalRationale": "A general, objective summary of the compatibility points. This is for the matchmaker's internal use.",
      "rationaleForParty1": "A personal and warm message for Party 1, explaining why Party 2 is a great match for them. Address them directly and highlight how Party 2's qualities align with Party 1's stated needs and desires. Use encouraging and persuasive language.",
      "rationaleForParty2": "A personal and warm message for Party 2, explaining why Party 1 is a great match for them. Do the same as above, but from Party 2's perspective."
    }
    IMPORTANT: Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.

    --- Profile 1 ---
    ${profile1Text}

    --- Profile 2 ---
    ${profile2Text}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Rationale Writer] Gemini API returned an empty response for full rationale.'
      );
      return null;
    }

    console.log(
      '--- [AI Rationale Writer] Successfully generated full rationale package. ---'
    );
    return JSON.parse(jsonString) as FullRationaleResult;
  } catch (error) {
    console.error(
      '[AI Rationale Writer] Error generating full suggestion rationale:',
      error
    );
    return null;
  }
}
export interface AiNeshamaTechSummary {
  summaryText: string;
}

/**
 * יוצר סיכום היכרות מקצועי וחם עבור פרופיל מועמד.
 * @param userNarrativeProfile הטקסט הנרטיבי המקיף של פרופיל המשתמש.
 * @returns Promise שמחזיר אובייקט עם טקסט הסיכום, או null במקרה של כישלון.
 */
export async function generateNeshamaTechSummary(
  userNarrativeProfile: string,
  locale: 'he' | 'en' = 'he'
): Promise<AiNeshamaTechSummary | null> {
  console.log(
    `--- [AI NeshamaTech Summary] Starting DYNAMIC summary generation for locale: ${locale} ---`
  );

  if (!userNarrativeProfile) {
    console.error(
      '[AI NeshamaTech Summary] Called with an empty user narrative profile.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-2.5-flash',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.6,
    },
  });

  // --- הגדרת פרומפטים נפרדים לכל שפה ---

  const hebrewPromptInstructions = `
    את/ה שדכן/ית מומחה/ית וקופירייטר/ית ב-NeshamaTech, שירות שידוכים המשלב טכנולוגיה מתקדמת עם ליווי אנושי וחם. את/ה לא רק כותב/ת, את/ה מספר/ת סיפורים שרואה את הנשמה (Neshama) שמאחורי הנתונים. המשימה שלך היא לזקק את פרופיל הנתונים המקיף של המועמד/ת ל"תקציר היכרות" ('דבר המערכת') – טקסט פורטרט בן 3-4 פסקאות, שהוא אישי, מעורר כבוד, ומצית סקרנות אמיתית אצל התאמה פוטנציאלית. הטון הוא שיא של מקצועיות, חום, ענווה ואותנטיות.

    **עקרונות מנחים לסינתזה עמוקה (החלק החשוב ביותר):**
    המטרה שלך היא לא לדווח על עובדות, אלא לחבר אותן לנרטיב משמעותי. חפש/י את החוט המקשר בין ה"עולמות" השונים בפרופיל:
    - **חיבור אישיות-ערכים:** איך תכונות האופי של המועמד/ת (עולם האישיות) באות לידי ביטוי בסדרי העדיפויות שהגדיר/ה (עולם הערכים)?
    - **חיבור סיפור-חזון:** כיצד מסלול החיים (השכלה, קריירה, מסע דתי) עיצב את מה שהם מחפשים בזוגיות ובפרטנר (עולמות הזוגיות והפרטנר)?
    - **איתור "המתח היצירתי":** חפש/י שילובים ייחודיים ומעניינים. למשל: "איש הייטק עם נשמה של אמן", "אשת אקדמיה שמוצאת את הרוחניות שלה בטבע", "קצין קרבי שמנגן ניגונים חסידיים". אלו היהלומים שיוצרים סיפור בלתי נשכח.

    **מבנה התקציר (נוסחת NeshamaTech):**

    1.  **הפתיחה (הפורטרט):** פתח/י במשפט אחד, חזק ומדויק, הלוכד קונפליקט פנימי מעניין או שילוב תכונות ייחודי של המועמד/ת. זו הכותרת הבלתי נראית של הפרופיל. (ראה דוגמת "דניאל": קוד לוגי מול סוגיה תלמודית).
    2.  **מסלול החיים (הנרטיב):** בפסקה זו, ארג/י את נקודות המפתח בחייו/ה (לימודים, צבא, קריירה, רקע דתי) לסיפור קוהרנטי של צמיחה ותכלית. הראה/י כיצד אירוע אחד הוביל לאחר, ואיך כל שלב עיצב את מי שהם היום. אל תציין/י עובדות, הסבר/י את משמעותן.
    3.  **החזון לזוגיות (השאיפה):** תאר/י באופן חי וברור את הבית והשותפות שהם שואפים לבנות, בהתבסס על תשובותיהם בעולמות הזוגיות והפרטנר. השתמש/י בשפה של ערכים, חזון וצמיחה משותפת, לא ברשימת מכולת של דרישות.
    4.  **חותמת המערכת (הערת NeshamaTech):** סיים/י במשפט מקצועי אחד, מנקודת המבט שלנו כשדכנים, המסכם תכונה מרכזית או שילוב נדיר שהופך את המועמד/ת למיוחד/ת בעינינו. (ראה דוגמת "דניאל": "אנו מתרשמים מהשילוב הנדיר של רצינות, עומק תורני ויכולת ביצוע...").

    **כללי ברזל (עשה ואל תעשה):**
    - **עשה:** השתמש/י בשפה חיובית, עשירה ומכבדת.
    - **עשה:** חבר/י את הנקודות, סנתז/י ולא רק סכם/י.
    - **אל תעשה:** אל תשתמש/י בקלישאות ("בחור/ה איכותי/ת", "טוב/ת לב"). הראה/י את האיכות, אל תצהיר/י עליה.
    - **אל תעשה:** אל תפרט/י רשימות של תכונות או תחביבים. שלב/י אותם בתוך הסיפור.
  `;

  const englishPromptInstructions = `
    You are an expert matchmaker and copywriter at NeshamaTech, a service that blends advanced technology with warm, human guidance. You are not just a writer; you are a storyteller who sees the soul (Neshama) behind the data. Your mission is to distill a candidate's comprehensive profile into an "Introduction Summary" – a 3-4 paragraph portrait that is personal, respectful, and sparks genuine curiosity in a potential match. The tone is the pinnacle of professionalism, warmth, humility, and authenticity.

    **Guiding Principles for Deep Synthesis (The Most Important Part):**
    Your goal is not to report facts, but to connect them into a meaningful narrative. Look for the thread that connects the different "Worlds" of the profile:
    - **Personality-Values Connection:** How do the candidate's character traits (Personality World) manifest in their stated priorities (Values World)?
    - **Story-Vision Connection:** How has their life path (education, career, spiritual journey) shaped what they seek in a relationship and a partner (Relationship & Partner Worlds)?
    - **Find the "Creative Tension":** Look for unique and interesting combinations. For example: "A high-tech professional with an artist's soul," "An academic who finds her spirituality in nature," "A combat officer who plays soulful Hasidic melodies." These are the gems that create an unforgettable story.

    **The Summary Structure (The NeshamaTech Formula):**

    1.  **The Overture (The Portrait):** Open with a single, powerful, and precise sentence that captures an interesting internal conflict or a unique combination of traits. This is the profile's invisible headline. (Reference the "Daniel" example: logical code vs. Talmudic discourse).
    2.  **The Life Path (The Narrative):** In this paragraph, weave the key points of their life (studies, army service, career, religious background) into a coherent story of growth and purpose. Show how one event led to the next, and how each stage shaped who they are today. Don't state facts; explain their significance.
    3.  **The Vision for Partnership (The Aspiration):** Vividly describe the home and partnership they aspire to build, based on their answers in the Relationship and Partner worlds. Use the language of values, vision, and mutual growth, not a grocery list of requirements.
    4.  **The System's Stamp (NeshamaTech's Note):** Conclude with a single professional sentence, from our perspective as matchmakers, summarizing a key trait or a rare combination that makes the candidate special in our eyes. (Reference the "Daniel" example: "we are impressed by the rare combination of seriousness, Torah depth, and executive ability...").

    **Golden Rules (Dos and Don'ts):**
    - **Do:** Use positive, rich, and respectful language.
    - **Do:** Connect the dots. Synthesize, don't just summarize.
    - **Don't:** Use clichés ("a quality person," "kind-hearted"). Show the quality, don't just state it.
    - **Don't:** List traits or hobbies. Weave them into the story.
  `;

  // בחירה דינמית של הפרומפט ושפת היעד
  const targetLanguage = locale === 'he' ? 'Hebrew' : 'English';
  const promptInstructions =
    locale === 'he' ? hebrewPromptInstructions : englishPromptInstructions;

  const prompt = `
    ${promptInstructions}

    **Output Format:** Your entire output MUST be a valid JSON object in ${targetLanguage}. Do NOT wrap it in markdown backticks. Output ONLY the raw JSON object with the following structure:
      {
        "summaryText": "The full, multi-paragraph summary text in ${targetLanguage}, with paragraphs separated by a newline character (\\n)."
      }

    --- User Profile Narrative for Analysis ---
    ${userNarrativeProfile}
    --- End of User Profile Narrative ---
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        `[AI NeshamaTech Summary] Gemini API returned an empty response for locale: ${locale}.`
      );
      return null;
    }

    // ניקוי ופענוח בטוח של ה-JSON
    let cleanJsonString = jsonString;
    if (cleanJsonString.startsWith('```json')) {
      cleanJsonString = cleanJsonString.slice(7, -3).trim();
    } else if (cleanJsonString.startsWith('```')) {
      cleanJsonString = cleanJsonString.slice(3, -3).trim();
    }

    try {
      const parsedJson = JSON.parse(cleanJsonString) as AiNeshamaTechSummary;
      console.log(
        `--- [AI NeshamaTech Summary] Successfully received and parsed summary from Gemini API for locale: ${locale}. ---`
      );
      return parsedJson;
    } catch (parseError) {
      console.error(
        `[AI NeshamaTech Summary] Failed to parse JSON response for locale: ${locale}.`,
        parseError
      );
      console.error('--- RAW AI RESPONSE THAT FAILED PARSING ---');
      console.error(jsonString);
      console.error('--- END OF RAW AI RESPONSE ---');
      throw new Error('Invalid JSON response from AI service.');
    }
  } catch (error) {
    console.error(
      `[AI NeshamaTech Summary] Error during summary generation for locale: ${locale}:`,
      error
    );
    return null;
  }
}



// ייצוא כל הפונקציות כאובייקט אחד
const aiService = {
  generateTextEmbedding,
  analyzePairCompatibility,
  getProfileAnalysis,
  analyzeSuggestionForUser,
  generateSuggestionRationale,
  generateFullSuggestionRationale,
  generateNeshamaTechSummary, 
};

export default aiService;
--- End of Content for aiService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\availabilityService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/availabilityService.ts

import prisma from '@/lib/prisma';
import { AvailabilityStatus, Prisma } from '@prisma/client';
import { emailService } from '@/lib/email/emailService';

// ============================ INICIO DE LA MODIFICACIÓN ============================
// Se ha añadido 'locale' a las interfaces para que se pueda pasar a los servicios de correo electrónico.
interface SendInquiryParams {
  matchmakerId: string;
  firstPartyId: string;
  note?: string;
  locale: 'he' | 'en'; // El 'locale' es ahora obligatorio.
}

interface UpdateInquiryResponse {
  inquiryId: string;
  userId: string;
  isAvailable: boolean;
  note?: string;
  locale: 'he' | 'en'; // El 'locale' es ahora obligatorio.
}
// ============================= FIN DE LA MODIFICACIÓN ==============================

interface GetInquiriesOptions {
  status?: 'pending' | 'completed' | 'expired';
  orderBy?: 'createdAt' | 'updatedAt';
  limit?: number;
}

interface AvailabilityStats {
  available: number;
  unavailable: number;
  dating: number;
  pending: number;
}

export class AvailabilityService {
  static async sendAvailabilityInquiry({
    matchmakerId,
    firstPartyId,
    note,
    locale, // Destructurar el nuevo parámetro 'locale'.
  }: SendInquiryParams) {
    try {
      console.log('Starting availability inquiry process', {
        matchmakerId,
        firstPartyId,
        note,
        locale,
      });

      // Comprobar si existe una consulta activa.
      const existingInquiry = await prisma.availabilityInquiry.findFirst({
        where: {
          firstPartyId,
          expiresAt: {
            gt: new Date(),
          },
        },
      });

      if (existingInquiry) {
        console.log('Found existing active inquiry:', existingInquiry);
        throw new Error('קיימת כבר בקשת זמינות פעילה');
      }

      // Crear una nueva consulta.
      console.log('Creating new inquiry...');
      const inquiry = await prisma.availabilityInquiry.create({
        data: {
          matchmakerId,
          firstPartyId,
          secondPartyId: firstPartyId,
          note,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 horas
        },
        include: {
          firstParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          secondParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          matchmaker: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      });

      console.log('Successfully created inquiry:', inquiry);

      // Enviar notificación por correo electrónico.
      if (inquiry.firstParty.email) {
        console.log('Attempting to send email to:', inquiry.firstParty.email);
        
        try {
          // ============================ INICIO DE LA MODIFICACIÓN ============================
          // Pasar el 'locale' al servicio de correo electrónico.
          await emailService.sendAvailabilityCheck({
            locale, // Pasar el 'locale' recibido.
            email: inquiry.firstParty.email,
            recipientName: `${inquiry.firstParty.firstName} ${inquiry.firstParty.lastName}`,
            matchmakerName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            inquiryId: inquiry.id,
          });
          // ============================= FIN DE LA MODIFICACIÓN ==============================
          console.log('Email sent successfully');
        } catch (emailError) {
          console.error('Failed to send email:', emailError);
          // Continuar aunque el correo electrónico falle; queremos que la consulta se guarde.
        }
      } else {
        console.warn('No email found for first party');
      }

      return inquiry;
    } catch (error) {
      console.error('Error in sendAvailabilityInquiry:', error);
      throw error;
    }
  }

  static async updateInquiryResponse({
    inquiryId,
    userId,
    isAvailable,
    note,
    locale, // Destructurar el nuevo parámetro 'locale'.
  }: UpdateInquiryResponse) {
    try {
      console.log('Starting to update inquiry response:', {
        inquiryId,
        userId,
        isAvailable,
        note,
        locale
      });

      // Comprobar si la consulta existe.
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true,
            },
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true,
            },
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      });

      if (!inquiry) {
        console.log('Inquiry not found:', inquiryId);
        throw new Error('בקשת הזמינות לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);

      if (inquiry.expiresAt < new Date()) {
        console.log('Inquiry expired:', inquiry.expiresAt);
        throw new Error('תוקף הבקשה פג');
      }

      const isFirstParty = inquiry.firstPartyId === userId;
      const isSecondParty = inquiry.secondPartyId === userId;

      if (!isFirstParty && !isSecondParty) {
        console.log('Unauthorized response attempt. User:', userId);
        throw new Error('אין הרשאה לעדכן בקשה זו');
      }

      // Actualizar tanto la consulta como el perfil en una transacción.
      console.log('Updating inquiry and profile...');
      const result = await prisma.$transaction(async (tx) => {
        // Actualizar el perfil del usuario.
        const updatedProfile = await tx.profile.update({
          where: { userId },
          data: {
            availabilityStatus: isAvailable
              ? AvailabilityStatus.AVAILABLE
              : AvailabilityStatus.UNAVAILABLE,
            availabilityNote: note,
            availabilityUpdatedAt: new Date(),
          },
        });
        console.log('Profile updated:', updatedProfile);

        // Actualizar la consulta.
        const updatedInquiry = await tx.availabilityInquiry.update({
          where: { id: inquiryId },
          data: {
            ...(isFirstParty
              ? { firstPartyResponse: isAvailable }
              : { secondPartyResponse: isAvailable }),
            updatedAt: new Date(),
          },
          include: {
            firstParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true,
              },
            },
            secondParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true,
              },
            },
            matchmaker: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
              },
            },
          },
        });
        console.log('Inquiry updated:', updatedInquiry);

        // Enviar notificación al matchmaker.
        if (inquiry.matchmaker.email) {
          // ============================ INICIO DE LA MODIFICACIÓN ============================
          // Pasar el 'locale' al servicio de correo electrónico.
          await emailService.sendSuggestionNotification({
            locale, // Pasar el 'locale' recibido.
            email: inquiry.matchmaker.email,
            recipientName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            matchmakerName: 'המערכת',
            suggestionDetails: {
              additionalInfo: `${
                isFirstParty ? 'הצד הראשון' : 'הצד השני'
              } ${isAvailable ? 'זמין' : 'אינו זמין'} ${
                note ? `(הערה: ${note})` : ''
              }`,
            },
          });
          // ============================= FIN DE LA MODIFICACIÓN ==============================
        }

        return updatedInquiry;
      });

      return result;
    } catch (error) {
      console.error('Error in updateInquiryResponse:', error);
      throw error;
    }
  }

  static async getInquiryById(inquiryId: string) {
    console.log('Fetching inquiry by ID:', inquiryId);
    try {
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      });

      if (!inquiry) {
        console.log('No inquiry found with ID:', inquiryId);
        throw new Error('הבקשה לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);
      return inquiry;
    } catch (error) {
      console.error('Error in getInquiryById:', error);
      throw error;
    }
  }

  static async getAvailabilityStats(
    matchmakerId: string
  ): Promise<AvailabilityStats> {
    console.log('Calculating availability stats for matchmaker:', matchmakerId);
    try {
      const stats = await prisma.profile.groupBy({
        by: ['availabilityStatus'],
        where: {
          user: {
            OR: [
              { firstPartyInquiries: { some: { matchmakerId } } },
              { secondPartyInquiries: { some: { matchmakerId } } },
            ],
          },
        },
        _count: true,
      });

      console.log('Raw stats:', stats);

      const result: AvailabilityStats = {
        available:
          stats.find((s) => s.availabilityStatus === AvailabilityStatus.AVAILABLE)
            ?._count || 0,
        unavailable:
          stats.find(
            (s) => s.availabilityStatus === AvailabilityStatus.UNAVAILABLE
          )?._count || 0,
        dating:
          stats.find((s) => s.availabilityStatus === AvailabilityStatus.DATING)
            ?._count || 0,
        pending: stats.find((s) => s.availabilityStatus === null)?._count || 0,
      };

      console.log('Processed stats:', result);
      return result;
    } catch (error) {
      console.error('Error in getAvailabilityStats:', error);
      throw error;
    }
  }

  static async getAllInquiries(
    userId: string,
    { status = 'pending', orderBy = 'createdAt', limit }: GetInquiriesOptions = {}
  ) {
    try {
      // Construir la cláusula 'where' basada en el estado.
      const where: Prisma.AvailabilityInquiryWhereInput = {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
        ...(status === 'pending' && {
          expiresAt: { gt: new Date() },
          OR: [
            { firstPartyResponse: null },
            { secondPartyResponse: null },
          ],
        }),
        ...(status === 'completed' && {
          firstPartyResponse: { not: null },
          secondPartyResponse: { not: null },
        }),
        ...(status === 'expired' && {
          expiresAt: { lt: new Date() },
        }),
      };

      const validOrderBy = orderBy || 'createdAt';

      const inquiries = await prisma.availabilityInquiry.findMany({
        where,
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
        orderBy: {
          [validOrderBy]: 'desc',
        },
        ...(limit ? { take: limit } : {}),
      });

      return inquiries;
    } catch (error) {
      console.error('Error in getAllInquiries:', error);
      throw error;
    }
  }
}
--- End of Content for availabilityService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\profileAiService.ts
--------------------------------------------------------------------------------
Content:
// File: src/lib/services/profileAiService.ts

import prisma from "@/lib/prisma";
import aiService from "./aiService";
import type { User, Profile, QuestionnaireResponse, Prisma as PrismaTypes, ReligiousJourney, FriendTestimonial } from '@prisma/client';

// 1. --- Import types and questions from the questionnaire module ---
import type { Question } from '@/components/questionnaire/types/types';
import { valuesQuestions } from '@/components/questionnaire/questions/values/valuesQuestions';
import { personalityQuestions } from '@/components/questionnaire/questions/personality/personalityQuestions';
import { relationshipQuestions } from '@/components/questionnaire/questions/relationship/relationshipQuestions';
import { partnerQuestions } from '@/components/questionnaire/questions/partner/partnerQuestions';
import { religionQuestions } from '@/components/questionnaire/questions/religion/religionQuestions';

// 2. --- Centralized Question Data ---
const allQuestions: Map<string, Question> = new Map();
[
  ...valuesQuestions,
  ...personalityQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
].forEach(q => allQuestions.set(q.id, q));

// 3. --- Strongly-typed interfaces for data handling ---
type WorldKey = 'values' | 'personality' | 'relationship' | 'partner' | 'religion';
type DbWorldKey = `${WorldKey}Answers`;

const KEY_MAPPING: Record<WorldKey, DbWorldKey> = {
  values: 'valuesAnswers',
  personality: 'personalityAnswers',
  relationship: 'relationshipAnswers',
  partner: 'partnerAnswers',
  religion: 'religionAnswers'
};

interface JsonAnswerData {
  questionId: string;
  value: PrismaTypes.JsonValue;
  answeredAt: string;
  isVisible?: boolean;
}

type UserWithRelations = User & {
  profile: (Profile & {
    testimonials?: FriendTestimonial[]; // הוספת השדה האופציונלי
  }) | null;
  questionnaireResponses: QuestionnaireResponse[];
};

// 4. --- Helper Functions for Formatting ---

function formatDisplayValue(value: PrismaTypes.JsonValue | null | undefined, fallback: string = "לא צוין"): string {
  if (value === null || value === undefined) {
    return fallback;
  }
  if (typeof value === 'string' && value.trim() === '') {
    return fallback;
  }
  if (typeof value === 'boolean') {
    return value ? "כן" : "לא";
  }
  if (typeof value === 'number') {
    return String(value);
  }
  if (value instanceof Date) {
    return value.toLocaleDateString('he-IL');
  }
  if (Array.isArray(value)) {
    return value.length > 0 ? value.map(String).join(', ') : fallback;
  }
  if (typeof value === 'object') {
     if (Object.keys(value).length > 0) {
         return Object.entries(value)
             .map(([key, val]) => `${key}: ${val}`)
             .join('; ');
     }
     return fallback;
  }
  return String(value);
}

function formatArray(arr: string[] | null | undefined, fallback: string = "לא צוין"): string {
  if (!arr || arr.length === 0) {
    return fallback;
  }
  return arr.join(', ');
}

function isValidAnswerObject(item: unknown): item is PrismaTypes.JsonObject & { value: PrismaTypes.JsonValue; questionId: unknown; answeredAt: unknown } {
  return (
    typeof item === 'object' &&
    item !== null &&
    'questionId' in item &&
    'value' in item &&
    item.value !== undefined &&
    'answeredAt' in item
  );
}

function safeParseAnswers(jsonValue: PrismaTypes.JsonValue | null): JsonAnswerData[] {
  if (Array.isArray(jsonValue)) {
    return jsonValue
      .filter(isValidAnswerObject)
      .map(item => ({
        questionId: String(item.questionId || ''),
        value: item.value,
        answeredAt: String(item.answeredAt || new Date().toISOString()),
        isVisible: typeof item.isVisible === 'boolean' ? item.isVisible : true,
      }))
      .filter(item => item.questionId);
  }
  return [];
}

function formatSingleAnswer(answer: JsonAnswerData): string | null {
  const questionDef = allQuestions.get(answer.questionId);
  if (!questionDef) {
    return `**שאלה לא מזוהה (${answer.questionId}):** ${formatDisplayValue(answer.value)}\n`;
  }

  if (answer.value === null || answer.value === undefined || answer.value === '') return null;
  if (Array.isArray(answer.value) && answer.value.length === 0) return null;

  let narrativePart = `**${questionDef.question}**\n`;
  
  switch (questionDef.type) {
    case 'singleChoice':
    case 'iconChoice':
    case 'scenario': {
      const selectedOption = questionDef.options?.find(o => o.value === answer.value);
      narrativePart += `תשובה: ${selectedOption ? selectedOption.text : formatDisplayValue(answer.value)}\n`;
      break;
    }
    case 'multiChoice':
    case 'multiSelect':
    case 'multiSelectWithOther': {
      if (Array.isArray(answer.value)) {
        const selectedTexts = answer.value.map(val => {
          if (typeof val === 'string' && val.startsWith('custom:')) {
            return `(אחר) ${val.replace('custom:', '').trim()}`;
          }
          const option = questionDef.options?.find(o => o.value === val);
          return option ? option.text : String(val);
        });
        narrativePart += `תשובות: ${selectedTexts.join(', ')}\n`;
      }
      break;
    }
    case 'openText': {
      narrativePart += `תשובה: "${formatDisplayValue(answer.value)}"\n`;
      break;
    }
    case 'scale': {
      const minLabel = questionDef.labels?.min || 'נמוך';
      const maxLabel = questionDef.labels?.max || 'גבוה';
      narrativePart += `דירוג: ${answer.value}/10 (כאשר 1=${minLabel} ו-10=${maxLabel})\n`;
      break;
    }
    case 'budgetAllocation': {
      if (typeof answer.value === 'object' && answer.value && !Array.isArray(answer.value)) {
          const allocations = Object.entries(answer.value)
              .filter(([, points]) => typeof points === 'number' && points > 0)
              .map(([category, points]) => `${category}: ${points}%`)
              .join('; ');
          narrativePart += `הקצאת חשיבות: ${allocations || 'לא צוין'}\n`;
      }
      break;
    }
    default: {
      narrativePart += `תשובה: ${formatDisplayValue(answer.value)}\n`;
    }
  }
  
  return narrativePart + '\n';
}

function processQuestionnaireData(questionnaire: QuestionnaireResponse | null | undefined) {
    const totalCount = allQuestions.size;
    if (!questionnaire) {
        return {
            answeredCount: 0,
            totalCount,
            completionPercentage: 0,
            answersNarrative: "המשתמש עדיין לא החל למלא את השאלון."
        };
    }

    const worldKeys: WorldKey[] = ['values', 'personality', 'relationship', 'partner', 'religion'];
    let answeredCount = 0;
    const narrativeChunks: string[] = [];

    worldKeys.forEach(worldKey => {
        const dbKey = KEY_MAPPING[worldKey];
        const answers = safeParseAnswers(questionnaire[dbKey]);
        
        if (answers.length > 0) {
            answeredCount += answers.length;
            
            const worldInfo = allQuestions.get(answers[0].questionId);
            const worldTitle = worldInfo?.worldId ? worldInfo.worldId.charAt(0) + worldInfo.worldId.slice(1).toLowerCase() : worldKey;
            
            narrativeChunks.push(`### עולם ה${worldTitle}`);
            
            answers.forEach(answer => {
                const formattedPart = formatSingleAnswer(answer);
                if (formattedPart) {
                    narrativeChunks.push(formattedPart);
                }
            });
        }
    });

    const completionPercentage = totalCount > 0 ? Math.round((answeredCount / totalCount) * 100) : 0;
    
    return {
        answeredCount,
        totalCount,
        completionPercentage,
        answersNarrative: narrativeChunks.length > 0 ? narrativeChunks.join('\n') : "המשתמש החל למלא את השאלון אך לא נמצאו תשובות תקפות לעיבוד."
    };
}


// 5. --- Main Service Functions ---

export async function generateNarrativeProfile(userId: string): Promise<string | null> {
  const user: UserWithRelations | null = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      profile: true,
      
      questionnaireResponses: { orderBy: { lastSaved: 'desc' }, take: 1 },
    
    },
  });

  if (!user || !user.profile) {
    console.error(`Could not generate narrative profile: User or Profile not found for userId: ${userId}`);
    return null;
  }

  const { profile, questionnaireResponses } = user;
  const questionnaire = questionnaireResponses[0];

  const calculateAge = (birthDate: Date): number => {
    const today = new Date();
    const age = today.getFullYear() - birthDate.getFullYear();
    const m = today.getMonth() - birthDate.getMonth();
    return (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) ? age - 1 : age;
  };
  const age = calculateAge(profile.birthDate);
  
  const questionnaireData = processQuestionnaireData(questionnaire);

  const religiousJourneyMap: Record<ReligiousJourney, string> = {
      BORN_INTO_CURRENT_LIFESTYLE: "גדל/ה בסביבה דתית הדומה לרמתו/ה כיום",
      BORN_SECULAR: "גדל/ה בסביבה חילונית",
      BAAL_TESHUVA: "חוזר/ת בתשובה",
      DATLASH: "יצא/ה בשאלה (דתל\"ש)",
      CONVERT: "גר/גיורת",
      IN_PROCESS: "בתהליך של שינוי/התחזקות/התלבטות דתית",
      OTHER: "בעל/ת רקע דתי אחר או מורכב"
  };

  const narrativeParts: string[] = [
    `# פרופיל AI עבור ${user.firstName} ${user.lastName}, ${profile.gender === 'MALE' ? 'גבר' : 'אישה'} בן/בת ${age}`,
    `## סיכום כללי`,
    `- **שם:** ${user.firstName} ${user.lastName}`,
    `- **גיל:** ${age} ${profile.birthDateIsApproximate ? '(משוער)' : ''}`,
    `- **מצב משפחתי:** ${formatDisplayValue(profile.maritalStatus)}`,
    `- **מגורים:** ${formatDisplayValue(profile.city)}`,
    `- **רמה דתית:** ${formatDisplayValue(profile.religiousLevel)}`,
    profile.religiousJourney ? `- **רקע/מסע דתי:** ${formatDisplayValue(religiousJourneyMap[profile.religiousJourney])}` : '',
    `- **עיסוק:** ${formatDisplayValue(profile.occupation)}`,
    `- **השכלה:** ${formatDisplayValue(profile.educationLevel)}, ${formatDisplayValue(profile.education)}`,
    `- **שומר/ת נגיעה:** ${formatDisplayValue(profile.shomerNegiah)}`,
    `- **רקע משפחתי:** מצב הורים: ${formatDisplayValue(profile.parentStatus)}. מקצוע האב: ${formatDisplayValue(profile.fatherOccupation)}. מקצוע האם: ${formatDisplayValue(profile.motherOccupation)}.`,
  ].filter(Boolean);

  if (user.source === 'MANUAL_ENTRY' && profile.manualEntryText) {
    narrativeParts.push(`\n**הערת שדכן (למועמד ידני):** ${profile.manualEntryText}`);
  }

  if (profile.about) {
    narrativeParts.push(`## קצת עליי (מהפרופיל)\n"${profile.about}"`);
  }

  // --- START: הוספת השדות הנרטיביים החדשים ---
  const personalInsightsParts = [
    profile.profileHeadline ? `**הכותרת האישית שלי:**\n"${profile.profileHeadline}"` : '',
    profile.inspiringCoupleStory ? `**זוג שמעורר בי השראה:**\n${profile.inspiringCoupleStory}` : '',
    profile.influentialRabbi ? `**דמות רוחנית שהשפיעה עליי:**\n${profile.influentialRabbi}` : ''
  ].filter(Boolean);

  if (personalInsightsParts.length > 0) {
    narrativeParts.push(`## תובנות אישיות נוספות\n${personalInsightsParts.join('\n\n')}`);
  }
  // --- END: הוספת השדות הנרטיביים החדשים ---

  if (profile.hasMedicalInfo) {
    narrativeParts.push(
      `## מידע רפואי`,
      `- **פירוט המידע:** ${formatDisplayValue(profile.medicalInfoDetails)}`,
      `- **תזמון חשיפה:** ${formatDisplayValue(profile.medicalInfoDisclosureTiming)}`,
      `- **המידע גלוי בפרופיל הציבורי:** ${profile.isMedicalInfoVisible ? 'כן' : 'לא'}`
    );
  }
  
  narrativeParts.push(
    `## תכונות אופי ותחביבים`,
    `- **תכונות בולטות:** ${formatArray(profile.profileCharacterTraits)}`,
    `- **תחביבים עיקריים:** ${formatArray(profile.profileHobbies)}`
  );
  
  const preferredJourneysText = (profile.preferredReligiousJourneys && profile.preferredReligiousJourneys.length > 0)
    ? formatArray(profile.preferredReligiousJourneys.map(j => religiousJourneyMap[j] || j))
    : "לא צוין";

  narrativeParts.push(
    `## מה אני מחפש/ת בבן/בת הזוג (העדפות מהפרופיל)`,
    `- **תיאור כללי:** ${formatDisplayValue(profile.matchingNotes)}`,
    `- **טווח גילאים מועדף:** ${formatDisplayValue(profile.preferredAgeMin, '?')} - ${formatDisplayValue(profile.preferredAgeMax, '?')}`,
    `- **רמות דתיות מועדפות:** ${formatArray(profile.preferredReligiousLevels)}`,
    `- **רקע/מסע דתי מועדף:** ${preferredJourneysText}`,
    `- **רמות השכלה מועדפות:** ${formatArray(profile.preferredEducation)}`,
    `- **מוצאים מועדפים:** ${formatArray(profile.preferredOrigins)}`
  );

  narrativeParts.push(
    `\n## ניתוח השלמת השאלון`,
    `- **סך הכל שאלות במערכת:** ${questionnaireData.totalCount}`,
    `- **שאלות שנענו:** ${questionnaireData.answeredCount}`,
    `- **אחוז השלמה:** ${questionnaireData.completionPercentage}%`,
    `\n## תובנות מהשאלון (תשובות מפורטות)\n${questionnaireData.answersNarrative}`
  );
  const approvedTestimonials = profile.testimonials?.filter(t => t.status === 'APPROVED');
  if (approvedTestimonials && approvedTestimonials.length > 0) {
    narrativeParts.push(`## המלצות מחברים`);
    approvedTestimonials.forEach(t => {
      narrativeParts.push(
        `**ממליץ/ה:** ${t.authorName} (${t.relationship})\n` +
        `**תוכן ההמלצה:** "${t.content}"`
      );
    });
  }
  return narrativeParts.join('\n\n').trim();
}

export async function updateUserAiProfile(userId: string): Promise<void> {
  console.log(`Starting AI profile update for userId: ${userId}`);
  const profileText = await generateNarrativeProfile(userId);
  if (!profileText) {
    console.error(`Failed to generate narrative profile for userId: ${userId}. Aborting AI update.`);
    return;
  }

  const vector = await aiService.generateTextEmbedding(profileText);
  if (!vector) {
    console.error(`Failed to generate vector embedding for userId: ${userId}. Aborting DB update.`);
    return;
  }

  try {
    const profile = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });
    if (!profile) {
      console.error(`No profile found for userId: ${userId} to save the vector against.`);
      return;
    }
    
    const vectorSqlString = `[${vector.join(',')}]`;
    await prisma.$executeRaw`
      INSERT INTO "profile_vectors" ("profileId", vector, "updatedAt")
      VALUES (${profile.id}, ${vectorSqlString}::vector, NOW())
      ON CONFLICT ("profileId")
      DO UPDATE SET
        vector = EXCLUDED.vector,
        "updatedAt" = NOW();
    `;
    console.log(`Successfully updated AI profile and vector for userId: ${userId} (profileId: ${profile.id})`);
  } catch (error) {
    console.error(`Error saving profile vector to DB for userId: ${userId}:`, error);
  }
}

const profileAiService = {
  generateNarrativeProfile,
  updateUserAiProfile,
};

export default profileAiService;
--- End of Content for profileAiService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\profileFeedbackService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/profileFeedbackService.ts

import prisma from "@/lib/prisma";
import aiService from "./aiService";
import { generateNarrativeProfile } from "./profileAiService";
import { getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";

// Import types
import type { UserProfile, QuestionnaireResponse, UserImage } from '@/types/next-auth';
import type { Question } from '@/components/questionnaire/types/types';
import type { User } from '@prisma/client';
import { Gender } from '@prisma/client';
import type { Locale } from "../../../i18n-config";

// Import all question definitions
import { personalityQuestions } from '@/components/questionnaire/questions/personality/personalityQuestions';
import { valuesQuestions } from '@/components/questionnaire/questions/values/valuesQuestions';
import { relationshipQuestions } from '@/components/questionnaire/questions/relationship/relationshipQuestions';
import { partnerQuestions } from '@/components/questionnaire/questions/partner/partnerQuestions';
import { religionQuestions } from '@/components/questionnaire/questions/religion/religionQuestions';

const allQuestions: Question[] = [
  ...personalityQuestions,
  ...valuesQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
];

// טיפוס מפושט רק לשאלות
type QuestionnaireQuestionsDict = {
  [worldKey: string]: {
    [questionId: string]: {
      question: string;
      placeholder?: string;
      helpText?: string;
      [key: string]: any;
    };
  };
};

export interface ProfileFeedbackReport {
  name: string;
  aiSummary: {
    personality: string;
    lookingFor: string;
  } | null;
  completedProfileItems: string[];
  missingProfileItems: string[];
  missingQuestionnaireItems: {
    world: string;
    question: string;
    link: string;
  }[];
  completionPercentage: number;
}

type FullUserForFeedback = User & {
    profile: UserProfile | null;
    images: UserImage[];
    questionnaireResponses: QuestionnaireResponse[];
};

class ProfileFeedbackService {
  private static instance: ProfileFeedbackService;
  private constructor() {}

  public static getInstance(): ProfileFeedbackService {
    if (!ProfileFeedbackService.instance) {
      ProfileFeedbackService.instance = new ProfileFeedbackService();
    }
    return ProfileFeedbackService.instance;
  }

  public async compileFeedbackReport(
    userId: string, 
    locale: Locale,
    questionsDict: QuestionnaireQuestionsDict
  ): Promise<ProfileFeedbackReport> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { 
        profile: true, 
        images: true, 
        questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } }
      },
    });

    if (!user || !user.profile) {
      throw new Error(`User or profile not found for userId: ${userId}`);
    }

    const narrativeProfile = await generateNarrativeProfile(userId);
    const aiAnalysis = narrativeProfile ? await aiService.getProfileAnalysis(narrativeProfile) : null;
    
    const { completed, missing } = this.analyzeProfileFields(user as FullUserForFeedback);
    
    const missingQuestionnaireItems = this.analyzeMissingQuestionnaireAnswers(
      user.questionnaireResponses[0], 
      locale,
      questionsDict
    );

    const completionPercentage = this.calculateCompletionPercentage(user as FullUserForFeedback);

    return {
      name: user.firstName,
      aiSummary: aiAnalysis ? {
        personality: aiAnalysis.personalitySummary,
        lookingFor: aiAnalysis.lookingForSummary,
      } : null,
      completedProfileItems: completed,
      missingProfileItems: missing,
      missingQuestionnaireItems,
      completionPercentage,
    };
  }
  
  private calculateCompletionPercentage(user: FullUserForFeedback): number {
    if (!user.profile) return 0;
    
    const checks: boolean[] = [];
    const p = user.profile;

    checks.push((user.images?.length ?? 0) >= 1);
    checks.push(!!p.profileHeadline);
    checks.push(!!p.about && p.about.trim().length >= 100);
    checks.push(!!p.inspiringCoupleStory);
    checks.push(p.height !== null && p.height !== undefined);
    checks.push(!!p.city);
    checks.push(!!p.maritalStatus);
    checks.push(!!p.religiousLevel);
    checks.push(!!p.educationLevel);
    checks.push(!!p.occupation);
    checks.push(!!(p.matchingNotes && p.matchingNotes.trim().length > 0));
    
    const totalProfileChecks = checks.length;
    const completedProfileChecks = checks.filter(Boolean).length;
    const profileScore = totalProfileChecks > 0 ? (completedProfileChecks / totalProfileChecks) : 0;
    
    const totalQuestions = allQuestions.length;
    const answeredQuestionsCount = this.getAnsweredQuestionIds(user.questionnaireResponses[0]).size;
    const questionnaireScore = totalQuestions > 0 ? (answeredQuestionsCount / totalQuestions) : 0;
    
    const finalPercentage = (profileScore * 60) + (questionnaireScore * 40);

    return Math.round(finalPercentage);
  }

  private analyzeProfileFields(user: FullUserForFeedback): { completed: string[], missing: string[] } {
    const completed: string[] = [];
    const missing: string[] = [];
    const profile = user.profile;

    const fields = [
      { key: 'images', label: "תמונת פרופיל אחת לפחות", check: () => (user.images?.length ?? 0) > 0 },
      { key: 'profileHeadline', label: "כותרת פרופיל אישית", check: () => !!profile?.profileHeadline },
      { key: 'about', label: "שדה 'אודותיי' (לפחות 100 תווים)", check: () => !!profile?.about && profile.about.trim().length >= 100 },
      { key: 'inspiringCoupleStory', label: "סיפור על זוג מעורר השראה", check: () => !!profile?.inspiringCoupleStory },
      { key: 'height', label: "גובה", check: () => !!profile?.height },
      { key: 'city', label: "עיר מגורים", check: () => !!profile?.city },
      { key: 'maritalStatus', label: "מצב משפחתי", check: () => !!profile?.maritalStatus },
      { key: 'religiousLevel', label: "רמה דתית", check: () => !!profile?.religiousLevel },
      { key: 'educationLevel', label: "רמת השכלה", check: () => !!profile?.educationLevel },
      { key: 'occupation', label: "עיסוק", check: () => !!profile?.occupation },
      { key: 'matchingNotes', label: "תיאור על בן/בת הזוג", check: () => !!profile?.matchingNotes && profile.matchingNotes.trim().length > 0 },
    ];

    fields.forEach(field => {
      if (field.check()) {
        completed.push(field.label);
      } else {
        missing.push(field.label);
      }
    });

    return { completed, missing };
  }
  
  private getAnsweredQuestionIds(questionnaire: QuestionnaireResponse | undefined): Set<string> {
    const answeredIds = new Set<string>();
    if (!questionnaire) return answeredIds;

    const worldKeys: (keyof QuestionnaireResponse)[] = ['valuesAnswers', 'personalityAnswers', 'relationshipAnswers', 'partnerAnswers', 'religionAnswers'];
    
    worldKeys.forEach(worldKey => {
      const answers = questionnaire[worldKey] as { questionId: string }[] | undefined;
      if(Array.isArray(answers)) {
        answers.forEach(ans => ans && ans.questionId && answeredIds.add(ans.questionId));
      }
    });
    return answeredIds;
  }

  private analyzeMissingQuestionnaireAnswers(
    questionnaire: QuestionnaireResponse | undefined, 
    locale: Locale,
    questionsDict: QuestionnaireQuestionsDict
  ): { world: string; question: string; link: string }[] {
    const answeredIds = this.getAnsweredQuestionIds(questionnaire);

    // מפת שמות העולמות בעברית
    const worldNames: Record<string, string> = {
      'personality': 'האישיות',
      'values': 'הערכים', 
      'relationship': 'הזוגיות',
      'partner': 'הפרטנר',
      'religion': 'דת ומסורת'
    };

    return allQuestions
      .filter(q => !answeredIds.has(q.id))
      .map(q => {
        const worldKey = q.worldId.toUpperCase();
        
        // נסה למצוא את השאלה במילון
        const translatedQuestion = questionsDict[worldKey]?.[q.id]?.question || q.question || q.id;
        
        // השתמש בשם העולם בעברית
        const translatedWorld = worldNames[q.worldId] || q.worldId;

        return {
            world: translatedWorld,
            question: translatedQuestion,
            link: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/${locale}/questionnaire?world=${q.worldId.toUpperCase()}&question=${q.id}`
        };
      });
  }
}

export const profileFeedbackService = ProfileFeedbackService.getInstance();
--- End of Content for profileFeedbackService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\questionnaireService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/questionnaireService.ts

import 'server-only';
import { Prisma } from '@prisma/client';
import type { Locale } from '../../../i18n-config';
import { getQuestionnaireQuestionsDictionary } from '@/lib/dictionaries';
import {
  FormattedAnswer,
  QuestionnaireResponse,
} from '@/types/next-auth';
import { Question, WorldId } from '@/components/questionnaire/types/types';

// Importowanie oryginalnych struktur pytań
import { personalityQuestions } from '@/components/questionnaire/questions/personality/personalityQuestions';
import { valuesQuestions } from '@/components/questionnaire/questions/values/valuesQuestions';
import { relationshipQuestions } from '@/components/questionnaire/questions/relationship/relationshipQuestions';
import { partnerQuestions } from '@/components/questionnaire/questions/partner/partnerQuestions';
import { religionQuestions } from '@/components/questionnaire/questions/religion/religionQuestions';

// Mapowanie struktur pytań
const allQuestionStructures: Record<WorldId, Question[]> = {
  PERSONALITY: personalityQuestions,
  VALUES: valuesQuestions,
  RELATIONSHIP: relationshipQuestions,
  PARTNER: partnerQuestions,
  RELIGION: religionQuestions,
};

/**
 * פונקציה זו מעצבת את התשובות הגולמיות מהשאלון לתצוגה,
 * תוך שימוש בלוגיקת תרגום דינמית בהתאם לשפת הצופה.
 * @param questionnaireResponse - אובייקט השאלון הגולמי ממסד הנתונים.
 * @param viewerLocale - שפת הממשק של המשתמש הצופה בפרופיל.
 * @returns אובייקט QuestionnaireResponse עם שדה 'formattedAnswers' מעוצב ומתורגם.
 */
export async function formatQuestionnaireForDisplay(
  questionnaireResponse: QuestionnaireResponse,
  viewerLocale: Locale,
   canViewAll: boolean // <-- הוספת הפרמטר החדש

): Promise<QuestionnaireResponse> {
  console.log('---[ SERVER LOG | questionnaireService ]--- מתחיל עיבוד תשובות עבור שפה:', viewerLocale);

  // טעינת מילון התרגומים המתאים לשפת הצפייה
  const questionsDict = await getQuestionnaireQuestionsDictionary(viewerLocale);

  const formattedAnswers: { [key: string]: FormattedAnswer[] } = {};
  const worlds: WorldId[] = ['PERSONALITY', 'VALUES', 'RELATIONSHIP', 'PARTNER', 'RELIGION'];

  for (const world of worlds) {
    const worldKey = `${world.toLowerCase()}Answers` as keyof QuestionnaireResponse;
    const rawAnswers = (questionnaireResponse[worldKey] as Prisma.JsonArray) || [];
    
    console.log(`---[ SERVER LOG | questionnaireService ]--- מעבד את עולם "${world}". נמצאו ${Array.isArray(rawAnswers) ? rawAnswers.length : 0} תשובות גולמיות.`);
    
    if (!Array.isArray(rawAnswers)) continue;

    formattedAnswers[world] = rawAnswers
      .map((rawAns: any): FormattedAnswer | null => {
        // ולידציה בסיסית של מבנה התשובה
        if (typeof rawAns !== 'object' || rawAns === null || !rawAns.questionId) {
            console.warn(`---[ SERVER LOG | questionnaireService ]--- מדלג על רשומת תשובה לא תקינה בעולם "${world}":`, rawAns);
            return null;
        }

        // איתור מבנה השאלה המקורי (מכיל הגדרות כמו type, totalPoints וכו')
        const questionStructure = allQuestionStructures[world].find(q => q.id === rawAns.questionId);
        if (!questionStructure) {
            console.warn(`---[ SERVER LOG | questionnaireService ]--- לא נמצאה הגדרת מבנה עבור שאלה עם ID "${rawAns.questionId}" בעולם "${world}".`);
            return null;
        }

        // איתור התרגומים עבור השאלה הספציפית מהמילון שנטען
        const questionContent = questionsDict[world]?.[rawAns.questionId];
        if (!questionContent || !questionContent.question) {
            console.warn(`---[ SERVER LOG | questionnaireService ]--- חסר תוכן במילון עבור שאלה עם ID "${rawAns.questionId}" בעולם "${world}".`);
            return null;
        }

        let displayText = 'לא נענה';
        
        // --- לוגיקת עיצוב התשובות לפי סוג השאלה ---

        if (questionStructure.type === 'openText' && typeof rawAns.value === 'object' && rawAns.value?.text) {
          // שאלת טקסט פתוח (עם תמיכה בשפה)
          displayText = rawAns.value.text;
        
        } else if (typeof rawAns.value === 'string' && questionContent.options?.[rawAns.value]) {
          // שאלת בחירה יחידה
          const optionContent = questionContent.options[rawAns.value];
          displayText = typeof optionContent === 'string' ? optionContent : optionContent.text;
        
        } else if (Array.isArray(rawAns.value)) {
          // שאלת בחירה מרובה
          displayText = rawAns.value
            .map(val => {
                const optionContent = questionContent.options?.[val];
                if (optionContent) {
                    return typeof optionContent === 'string' ? optionContent : optionContent.text;
                }
                if (typeof val === 'string' && val.startsWith('custom:')) {
                    return val.replace('custom:', '');
                }
                return val;
            })
            .join(', ');
        
        } else if (typeof rawAns.value === 'number' && questionStructure.type === 'scale') {
            // שאלת סולם
            displayText = `${rawAns.value} / ${questionStructure.max || 10}`;
        
        } else if (typeof rawAns.value === 'object' && !Array.isArray(rawAns.value) && rawAns.value !== null && questionStructure.type === 'budgetAllocation') {
            // #############################################################
            // # START: *** התיקון המרכזי והסופי לשאלות תקציב ***
            // #############################################################
            displayText = Object.entries(rawAns.value as Record<string, number>)
              .map(([key, val]) => {
                  // 1. שלוף את התרגום עבור המפתח (למשל, 'family_connections') מתוך המילון שנטען
                  const translatedLabel = questionContent.categories?.[key];

                  // 2. השתמש בתרגום אם נמצא, אחרת חזור למפתח המקורי באנגלית (כגיבוי)
                  const finalLabel = translatedLabel || key;

                  // 3. קבע את יחידת המידה: אם מוגדר `totalPoints`, אלו נקודות ולא אחוזים
                  const unit = questionStructure.totalPoints ? '' : '%';
                  
                  // 4. הרכב את הטקסט הסופי לתצוגה
                  return `${finalLabel}: ${val}${unit}`;
              })
              .join(' | '); // הפרדה ברורה בין הפריטים
            // #############################################################
            // # END: *** התיקון המרכזי והסופי לשאלות תקציב ***
            // #############################################################
        
        } else if (rawAns.value !== null && rawAns.value !== undefined) {
          // גיבוי כללי לכל מקרה אחר
          displayText = String(rawAns.value);
        }
        
        return {
          questionId: rawAns.questionId,
          question: questionContent.question,
          questionType: questionStructure.type,
          rawValue: rawAns.value,
          displayText,
          isVisible: rawAns.isVisible ?? true,
          answeredAt: rawAns.answeredAt,
        };
      })
      .filter((ans): ans is FormattedAnswer => ans !== null);
  }

// סינון תשובות שאינן גלויות (isVisible: false)
// יתבצע רק אם הצופה הוא לא הבעלים של הפרופיל.
  if (!canViewAll) { // <-- שימוש בשם החדש
    console.log('---[ SERVER LOG | questionnaireService ]--- מבצע סינון תשובות מוסתרות עבור צופה ללא הרשאה.');
    for (const world in formattedAnswers) {
        formattedAnswers[world] = formattedAnswers[world].filter(ans => ans.isVisible === true);
    }
  } else {
    console.log('---[ SERVER LOG | questionnaireService ]--- מדלג על סינון תשובות. לצופה יש הרשאה לראות הכל.');
  }


  console.log('---[ SERVER LOG | questionnaireService ]--- העיבוד הסתיים. מבנה הנתונים המעוצב:', JSON.stringify(formattedAnswers, null, 2));

  return {
    ...questionnaireResponse,
    formattedAnswers,
  };
}
--- End of Content for questionnaireService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\services_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services
# Generated on: 2025-10-03 14:11:55
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\aiService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/aiService.ts

import { GoogleGenerativeAI } from '@google/generative-ai';

const apiKey = process.env.GOOGLE_API_KEY;

if (!apiKey) {
  console.error(
    '[FATAL ERROR] GOOGLE_API_KEY is not set in .env or .env.local!'
  );
  throw new Error('GOOGLE_API_KEY must be set.');
}

const genAI = new GoogleGenerativeAI(apiKey);

/**
 * יוצר וקטור הטמעה (embedding) עבור טקסט נתון.
 * @param text הטקסט להטמעה.
 * @returns Promise שמחזיר מערך של מספרים (הווקטור), או null במקרה של כישלון.
 */
export async function generateTextEmbedding(
  text: string
): Promise<number[] | null> {
  try {
    const model = genAI.getGenerativeModel({ model: 'text-embedding-004' });
    const result = await model.embedContent(text);
    const embedding = result.embedding;
    if (embedding && embedding.values) {
      return embedding.values;
    }
    console.error('Embedding generation returned no values.');
    return null;
  } catch (error) {
    console.error('Error generating text embedding:', error);
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח התאמה עבור שדכנים.
 */
export interface AiAnalysisResult {
  overallScore: number;
  matchSummary: string;
  compatibilityPoints: Array<{
    area: string;
    explanation: string;
    strength: 'HIGH' | 'MEDIUM' | 'LOW';
  }>;
  potentialChallenges: Array<{
    area: string;
    explanation: string;
    severity: 'HIGH' | 'MEDIUM' | 'LOW';
  }>;
  suggestedConversationStarters: string[];
}

/**
 * מנתח את ההתאמה בין שני פרופילים נרטיביים עבור שדכן.
 * @param profileAText הפרופיל הנרטיבי של המשתמש הראשון.
 * @param profileBText הפרופיל הנרטיבי של המשתמש השני.
 * @param language שפת הפלט הרצויה.
 * @returns Promise שמחזיר אובייקט ניתוח מובנה, או null במקרה של כישלון.
 */
export async function analyzePairCompatibility(
  profileAText: string,
  profileBText: string,
  language: 'he' | 'en' = 'he'
): Promise<AiAnalysisResult | null> {
  console.log(
    `--- Attempting to analyze compatibility for matchmaker in ${language} ---`
  );
  if (!profileAText || !profileBText) {
    console.error(
      'analyzePairCompatibility called with one or more empty profiles.'
    );
    return null;
  }
  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.3,
    },
  });

  const targetLanguage = language === 'he' ? 'Hebrew' : 'English';

  const prompt = `
    You are a "Matchmaking AI Expert" for a religious Jewish dating platform. Your goal is to analyze the compatibility of two user profiles and provide a structured, insightful, and helpful analysis for the matchmaker.
    
    IMPORTANT: Your entire JSON output, including all string values (keys and explanations), must be in ${targetLanguage}.

    Your output MUST be a valid JSON object. Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.
    The JSON structure: { "overallScore": number, "matchSummary": "string", "compatibilityPoints": [{ "area": "string", "explanation": "string", "strength": "HIGH" | "MEDIUM" | "LOW" }], "potentialChallenges": [{ "area": "string", "explanation": "string", "severity": "HIGH" | "MEDIUM" | "LOW" }], "suggestedConversationStarters": ["string"] }
    --- Profile 1 ---
    ${profileAText}
    --- Profile 2 ---
    ${profileBText}
    `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error('Direct Gemini API returned an empty response.');
      return null;
    }

    console.log(
      `--- Successfully received compatibility analysis from Gemini API in ${language} ---`
    );
    // כאן אין צורך בניקוי מיוחד כי אנחנו מצפים ל-JSON נקי, אבל אם יתחילו בעיות נוסיף גם פה
    return JSON.parse(jsonString) as AiAnalysisResult;
  } catch (error) {
    console.error(
      `Error generating compatibility analysis from Direct Gemini API in ${language}:`,
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח פרופיל עבור המשתמש עצמו.
 */
export interface AiProfileAnalysisResult {
  personalitySummary: string;
  lookingForSummary: string;
  completenessReport: Array<{
    area: string;
    status: 'COMPLETE' | 'PARTIAL' | 'MISSING';
    feedback: string;
  }>;
  actionableTips: Array<{
    area: string;
    tip: string;
  }>;
}

/**
 * מנתח פרופיל של משתמש ומספק משוב וטיפים לשיפור.
 * @param userNarrativeProfile הטקסט הנרטיבי המקיף של פרופיל המשתמש.
 * @returns Promise שמחזיר אובייקט ניתוח מובנה, או null במקרה של כישלון.
 */
export async function getProfileAnalysis(
  userNarrativeProfile: string
): Promise<AiProfileAnalysisResult | null> {
  console.log(
    '--- [AI Profile Advisor] Starting profile analysis with Gemini API ---'
  );

  if (!userNarrativeProfile) {
    console.error(
      '[AI Profile Advisor] Called with an empty user narrative profile.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.4,
    },
  });

  const prompt = `
    You are an expert, warm, and encouraging dating profile coach for a religious Jewish audience. Your goal is to help the user improve their profile to attract the best possible matches. Based on the following comprehensive user profile, provide a structured JSON analysis.
    The entire output MUST be a valid JSON object in Hebrew.
    IMPORTANT: Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.
    The JSON structure must be: { "personalitySummary": "string", "lookingForSummary": "string", "completenessReport": [{ "area": "string", "status": "COMPLETE" | "PARTIAL" | "MISSING", "feedback": "string" }], "actionableTips": [{ "area": "string", "tip": "string" }] }
    
    --- User Profile Narrative ---
    ${userNarrativeProfile}
    --- End of User Profile Narrative ---
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    let jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Profile Advisor] Gemini API returned an empty response.'
      );
      return null;
    }

    // ======================= תהליך הניקוי והפענוח הבטוח =======================
    
    // שלב 1: בדוק אם התשובה עטופה ב-markdown והסר אותו אם כן.
    if (jsonString.startsWith('```json')) {
      jsonString = jsonString.slice(7, -3).trim();
    } else if (jsonString.startsWith('```')) {
        jsonString = jsonString.slice(3, -3).trim();
    }

    try {
        // שלב 2: נסה לפענח את ה-JSON הנקי.
        const parsedJson = JSON.parse(jsonString) as AiProfileAnalysisResult;
        console.log(
          '--- [AI Profile Advisor] Successfully received and parsed analysis from Gemini API. ---'
        );
        return parsedJson;
    } catch (parseError) {
        // שלב 3: אם הפענוח נכשל, הדפס שגיאה מפורטת ואת התשובה הגולמית לטובת דיבאגינג.
        console.error(
          '[AI Profile Advisor] Failed to parse JSON response from Gemini.',
          parseError
        );
        console.error('--- RAW AI RESPONSE THAT FAILED PARSING ---');
        console.error(jsonString);
        console.error('--- END OF RAW AI RESPONSE ---');
        
        // זרוק שגיאה חדשה כדי שהפונקציה שקראה לנו תדע שהתהליך נכשל.
        throw new Error('Invalid JSON response from AI service.');
    }
    // ======================= סוף תהליך הניקוי =======================

  } catch (error) {
    // תפיסת שגיאות תקשורת עם ה-API או את השגיאה שזרקנו מה-catch הפנימי.
    console.error(
      '[AI Profile Advisor] Error during profile analysis process:',
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של ניתוח הצעה עבור משתמש הקצה.
 */
export interface AiSuggestionAnalysisResult {
  overallScore: number;
  matchTitle: string;
  matchSummary: string;
  compatibilityPoints: Array<{ area: string; explanation: string }>;
  pointsToConsider: Array<{ area: string; explanation: string }>;
  suggestedConversationStarters: string[];
}

/**
 * מנתח התאמה בין שני פרופילים ומחזיר ניתוח מותאם למשתמש הקצה.
 */
export async function analyzeSuggestionForUser(
  currentUserProfileText: string,
  suggestedUserProfileText: string
): Promise<AiSuggestionAnalysisResult | null> {
  console.log(
    '--- [AI Suggestion Advisor] Starting suggestion analysis for user ---'
  );

  if (!currentUserProfileText || !suggestedUserProfileText) {
    console.error(
      '[AI Suggestion Advisor] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.5,
    },
  });

  const prompt = `
    You are a 'Matchmaking AI Advisor'. Your tone is positive, warm, and encouraging. Your goal is to help a user understand the potential of a match suggestion they received. Analyze the compatibility between 'My Profile' and the 'Suggested Profile'.
    Your entire output MUST be a valid JSON object in Hebrew.
    IMPORTANT: Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.
    The JSON structure must be: { "overallScore": number, "matchTitle": "string", "matchSummary": "string", "compatibilityPoints": [{ "area": "string", "explanation": "string (user-friendly explanation)" }], "pointsToConsider": [{ "area": "string", "explanation": "string (rephrased positively, e.g., 'הוא אוהב טיולים ואת מעדיפה בית. זו הזדמנות נהדרת לחוות דברים חדשים יחד!')" }], "suggestedConversationStarters": ["string"] }
    
    --- My Profile ---
    ${currentUserProfileText}

    --- Suggested Profile ---
    ${suggestedUserProfileText}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Suggestion Advisor] Gemini API returned an empty response.'
      );
      return null;
    }

    console.log(
      '--- [AI Suggestion Advisor] Successfully received analysis from Gemini API. ---'
    );
    return JSON.parse(jsonString) as AiSuggestionAnalysisResult;
  } catch (error) {
    console.error(
      '[AI Suggestion Advisor] Error generating suggestion analysis:',
      error
    );
    return null;
  }
}

/**
 * מייצר טקסט נימוק מותאם אישית עבור הצעת שידוך.
 */
export async function generateSuggestionRationale(
  profile1Text: string,
  profile2Text: string
): Promise<string | null> {
  console.log(
    '--- [AI Rationale Writer] Starting suggestion rationale generation ---'
  );
  if (!profile1Text || !profile2Text) {
    console.error(
      '[AI Rationale Writer] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

  const prompt = `
    You are a professional and sensitive matchmaker in the religious Jewish community. Your task is to write a warm, personal, and compelling justification ('matchingReason') for a match suggestion.
    Based on the two profiles provided, identify 2-3 key points of compatibility (values, life goals, personality traits, background) and weave them into a concise and positive paragraph.
    The output should be ONLY the justification text in Hebrew, without any additional titles, formatting, or explanations. Start directly with the text.

    **Example Output Structure:**
    "אני חושב/ת שיש כאן פוטנציאל להתאמה מצוינת מכמה סיבות. ראשית, שניכם ציינתם ש... וזה מראה על... שנית, הרקע ה... שלכם יכול להוות בסיס משותף חזק. בנוסף, נראה ששניכם חולקים... וזה יכול לתרום רבות לבניית קשר..."

    --- Profile 1 ---
    ${profile1Text}

    --- Profile 2 ---
    ${profile2Text}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    if (!text) {
      console.error(
        '[AI Rationale Writer] Gemini API returned an empty response.'
      );
      return null;
    }

    console.log(
      '--- [AI Rationale Writer] Successfully generated rationale. ---'
    );
    return text.trim();
  } catch (error) {
    console.error(
      '[AI Rationale Writer] Error generating suggestion rationale:',
      error
    );
    return null;
  }
}

/**
 * מגדיר את מבנה ה-JSON של אובייקט הנימוקים המלא.
 */
export interface FullRationaleResult {
  generalRationale: string;
  rationaleForParty1: string;
  rationaleForParty2: string;
}

/**
 * מייצר חבילת נימוקים מלאה עבור הצעת שידוך.
 */
export async function generateFullSuggestionRationale(
  profile1Text: string,
  profile2Text: string
): Promise<FullRationaleResult | null> {
  console.log(
    '--- [AI Rationale Writer] Starting full rationale package generation ---'
  );
  if (!profile1Text || !profile2Text) {
    console.error(
      '[AI Rationale Writer] Called with one or more empty profiles.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.6,
    },
  });

  const prompt = `
    You are a professional and sensitive matchmaker in the religious Jewish community. Your task is to write three distinct texts for a match suggestion based on the two provided user profiles.
    The entire output MUST be a valid JSON object in Hebrew, with the following exact structure:
    {
      "generalRationale": "A general, objective summary of the compatibility points. This is for the matchmaker's internal use.",
      "rationaleForParty1": "A personal and warm message for Party 1, explaining why Party 2 is a great match for them. Address them directly and highlight how Party 2's qualities align with Party 1's stated needs and desires. Use encouraging and persuasive language.",
      "rationaleForParty2": "A personal and warm message for Party 2, explaining why Party 1 is a great match for them. Do the same as above, but from Party 2's perspective."
    }
    IMPORTANT: Do NOT wrap the JSON in markdown backticks (e.g., \`\`\`json). Output ONLY the raw JSON object.

    --- Profile 1 ---
    ${profile1Text}

    --- Profile 2 ---
    ${profile2Text}
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        '[AI Rationale Writer] Gemini API returned an empty response for full rationale.'
      );
      return null;
    }

    console.log(
      '--- [AI Rationale Writer] Successfully generated full rationale package. ---'
    );
    return JSON.parse(jsonString) as FullRationaleResult;
  } catch (error) {
    console.error(
      '[AI Rationale Writer] Error generating full suggestion rationale:',
      error
    );
    return null;
  }
}
export interface AiNeshamaTechSummary {
  summaryText: string;
}

/**
 * יוצר סיכום היכרות מקצועי וחם עבור פרופיל מועמד.
 * @param userNarrativeProfile הטקסט הנרטיבי המקיף של פרופיל המשתמש.
 * @returns Promise שמחזיר אובייקט עם טקסט הסיכום, או null במקרה של כישלון.
 */
export async function generateNeshamaTechSummary(
  userNarrativeProfile: string,
  locale: 'he' | 'en' = 'he'
): Promise<AiNeshamaTechSummary | null> {
  console.log(
    `--- [AI NeshamaTech Summary] Starting DYNAMIC summary generation for locale: ${locale} ---`
  );

  if (!userNarrativeProfile) {
    console.error(
      '[AI NeshamaTech Summary] Called with an empty user narrative profile.'
    );
    return null;
  }

  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-pro-latest',
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.6,
    },
  });

  // --- הגדרת פרומפטים נפרדים לכל שפה ---

  const hebrewPromptInstructions = `
    את/ה שדכן/ית מומחה/ית וקופירייטר/ית ב-NeshamaTech, שירות שידוכים המשלב טכנולוגיה מתקדמת עם ליווי אנושי וחם. את/ה לא רק כותב/ת, את/ה מספר/ת סיפורים שרואה את הנשמה (Neshama) שמאחורי הנתונים. המשימה שלך היא לזקק את פרופיל הנתונים המקיף של המועמד/ת ל"תקציר היכרות" ('דבר המערכת') – טקסט פורטרט בן 3-4 פסקאות, שהוא אישי, מעורר כבוד, ומצית סקרנות אמיתית אצל התאמה פוטנציאלית. הטון הוא שיא של מקצועיות, חום, ענווה ואותנטיות.

    **עקרונות מנחים לסינתזה עמוקה (החלק החשוב ביותר):**
    המטרה שלך היא לא לדווח על עובדות, אלא לחבר אותן לנרטיב משמעותי. חפש/י את החוט המקשר בין ה"עולמות" השונים בפרופיל:
    - **חיבור אישיות-ערכים:** איך תכונות האופי של המועמד/ת (עולם האישיות) באות לידי ביטוי בסדרי העדיפויות שהגדיר/ה (עולם הערכים)?
    - **חיבור סיפור-חזון:** כיצד מסלול החיים (השכלה, קריירה, מסע דתי) עיצב את מה שהם מחפשים בזוגיות ובפרטנר (עולמות הזוגיות והפרטנר)?
    - **איתור "המתח היצירתי":** חפש/י שילובים ייחודיים ומעניינים. למשל: "איש הייטק עם נשמה של אמן", "אשת אקדמיה שמוצאת את הרוחניות שלה בטבע", "קצין קרבי שמנגן ניגונים חסידיים". אלו היהלומים שיוצרים סיפור בלתי נשכח.

    **מבנה התקציר (נוסחת NeshamaTech):**

    1.  **הפתיחה (הפורטרט):** פתח/י במשפט אחד, חזק ומדויק, הלוכד קונפליקט פנימי מעניין או שילוב תכונות ייחודי של המועמד/ת. זו הכותרת הבלתי נראית של הפרופיל. (ראה דוגמת "דניאל": קוד לוגי מול סוגיה תלמודית).
    2.  **מסלול החיים (הנרטיב):** בפסקה זו, ארג/י את נקודות המפתח בחייו/ה (לימודים, צבא, קריירה, רקע דתי) לסיפור קוהרנטי של צמיחה ותכלית. הראה/י כיצד אירוע אחד הוביל לאחר, ואיך כל שלב עיצב את מי שהם היום. אל תציין/י עובדות, הסבר/י את משמעותן.
    3.  **החזון לזוגיות (השאיפה):** תאר/י באופן חי וברור את הבית והשותפות שהם שואפים לבנות, בהתבסס על תשובותיהם בעולמות הזוגיות והפרטנר. השתמש/י בשפה של ערכים, חזון וצמיחה משותפת, לא ברשימת מכולת של דרישות.
    4.  **חותמת המערכת (הערת NeshamaTech):** סיים/י במשפט מקצועי אחד, מנקודת המבט שלנו כשדכנים, המסכם תכונה מרכזית או שילוב נדיר שהופך את המועמד/ת למיוחד/ת בעינינו. (ראה דוגמת "דניאל": "אנו מתרשמים מהשילוב הנדיר של רצינות, עומק תורני ויכולת ביצוע...").

    **כללי ברזל (עשה ואל תעשה):**
    - **עשה:** השתמש/י בשפה חיובית, עשירה ומכבדת.
    - **עשה:** חבר/י את הנקודות, סנתז/י ולא רק סכם/י.
    - **אל תעשה:** אל תשתמש/י בקלישאות ("בחור/ה איכותי/ת", "טוב/ת לב"). הראה/י את האיכות, אל תצהיר/י עליה.
    - **אל תעשה:** אל תפרט/י רשימות של תכונות או תחביבים. שלב/י אותם בתוך הסיפור.
  `;

  const englishPromptInstructions = `
    You are an expert matchmaker and copywriter at NeshamaTech, a service that blends advanced technology with warm, human guidance. You are not just a writer; you are a storyteller who sees the soul (Neshama) behind the data. Your mission is to distill a candidate's comprehensive profile into an "Introduction Summary" – a 3-4 paragraph portrait that is personal, respectful, and sparks genuine curiosity in a potential match. The tone is the pinnacle of professionalism, warmth, humility, and authenticity.

    **Guiding Principles for Deep Synthesis (The Most Important Part):**
    Your goal is not to report facts, but to connect them into a meaningful narrative. Look for the thread that connects the different "Worlds" of the profile:
    - **Personality-Values Connection:** How do the candidate's character traits (Personality World) manifest in their stated priorities (Values World)?
    - **Story-Vision Connection:** How has their life path (education, career, spiritual journey) shaped what they seek in a relationship and a partner (Relationship & Partner Worlds)?
    - **Find the "Creative Tension":** Look for unique and interesting combinations. For example: "A high-tech professional with an artist's soul," "An academic who finds her spirituality in nature," "A combat officer who plays soulful Hasidic melodies." These are the gems that create an unforgettable story.

    **The Summary Structure (The NeshamaTech Formula):**

    1.  **The Overture (The Portrait):** Open with a single, powerful, and precise sentence that captures an interesting internal conflict or a unique combination of traits. This is the profile's invisible headline. (Reference the "Daniel" example: logical code vs. Talmudic discourse).
    2.  **The Life Path (The Narrative):** In this paragraph, weave the key points of their life (studies, army service, career, religious background) into a coherent story of growth and purpose. Show how one event led to the next, and how each stage shaped who they are today. Don't state facts; explain their significance.
    3.  **The Vision for Partnership (The Aspiration):** Vividly describe the home and partnership they aspire to build, based on their answers in the Relationship and Partner worlds. Use the language of values, vision, and mutual growth, not a grocery list of requirements.
    4.  **The System's Stamp (NeshamaTech's Note):** Conclude with a single professional sentence, from our perspective as matchmakers, summarizing a key trait or a rare combination that makes the candidate special in our eyes. (Reference the "Daniel" example: "we are impressed by the rare combination of seriousness, Torah depth, and executive ability...").

    **Golden Rules (Dos and Don'ts):**
    - **Do:** Use positive, rich, and respectful language.
    - **Do:** Connect the dots. Synthesize, don't just summarize.
    - **Don't:** Use clichés ("a quality person," "kind-hearted"). Show the quality, don't just state it.
    - **Don't:** List traits or hobbies. Weave them into the story.
  `;

  // בחירה דינמית של הפרומפט ושפת היעד
  const targetLanguage = locale === 'he' ? 'Hebrew' : 'English';
  const promptInstructions =
    locale === 'he' ? hebrewPromptInstructions : englishPromptInstructions;

  const prompt = `
    ${promptInstructions}

    **Output Format:** Your entire output MUST be a valid JSON object in ${targetLanguage}. Do NOT wrap it in markdown backticks. Output ONLY the raw JSON object with the following structure:
      {
        "summaryText": "The full, multi-paragraph summary text in ${targetLanguage}, with paragraphs separated by a newline character (\\n)."
      }

    --- User Profile Narrative for Analysis ---
    ${userNarrativeProfile}
    --- End of User Profile Narrative ---
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const jsonString = response.text();

    if (!jsonString) {
      console.error(
        `[AI NeshamaTech Summary] Gemini API returned an empty response for locale: ${locale}.`
      );
      return null;
    }

    // ניקוי ופענוח בטוח של ה-JSON
    let cleanJsonString = jsonString;
    if (cleanJsonString.startsWith('```json')) {
      cleanJsonString = cleanJsonString.slice(7, -3).trim();
    } else if (cleanJsonString.startsWith('```')) {
      cleanJsonString = cleanJsonString.slice(3, -3).trim();
    }

    try {
      const parsedJson = JSON.parse(cleanJsonString) as AiNeshamaTechSummary;
      console.log(
        `--- [AI NeshamaTech Summary] Successfully received and parsed summary from Gemini API for locale: ${locale}. ---`
      );
      return parsedJson;
    } catch (parseError) {
      console.error(
        `[AI NeshamaTech Summary] Failed to parse JSON response for locale: ${locale}.`,
        parseError
      );
      console.error('--- RAW AI RESPONSE THAT FAILED PARSING ---');
      console.error(jsonString);
      console.error('--- END OF RAW AI RESPONSE ---');
      throw new Error('Invalid JSON response from AI service.');
    }
  } catch (error) {
    console.error(
      `[AI NeshamaTech Summary] Error during summary generation for locale: ${locale}:`,
      error
    );
    return null;
  }
}



// ייצוא כל הפונקציות כאובייקט אחד
const aiService = {
  generateTextEmbedding,
  analyzePairCompatibility,
  getProfileAnalysis,
  analyzeSuggestionForUser,
  generateSuggestionRationale,
  generateFullSuggestionRationale,
  generateNeshamaTechSummary, 
};

export default aiService;
--- End of Content for aiService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\availabilityService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/availabilityService.ts

import prisma from '@/lib/prisma';
import { AvailabilityStatus, Prisma } from '@prisma/client';
import { emailService } from '@/lib/email/emailService';

// ============================ INICIO DE LA MODIFICACIÓN ============================
// Se ha añadido 'locale' a las interfaces para que se pueda pasar a los servicios de correo electrónico.
interface SendInquiryParams {
  matchmakerId: string;
  firstPartyId: string;
  note?: string;
  locale: 'he' | 'en'; // El 'locale' es ahora obligatorio.
}

interface UpdateInquiryResponse {
  inquiryId: string;
  userId: string;
  isAvailable: boolean;
  note?: string;
  locale: 'he' | 'en'; // El 'locale' es ahora obligatorio.
}
// ============================= FIN DE LA MODIFICACIÓN ==============================

interface GetInquiriesOptions {
  status?: 'pending' | 'completed' | 'expired';
  orderBy?: 'createdAt' | 'updatedAt';
  limit?: number;
}

interface AvailabilityStats {
  available: number;
  unavailable: number;
  dating: number;
  pending: number;
}

export class AvailabilityService {
  static async sendAvailabilityInquiry({
    matchmakerId,
    firstPartyId,
    note,
    locale, // Destructurar el nuevo parámetro 'locale'.
  }: SendInquiryParams) {
    try {
      console.log('Starting availability inquiry process', {
        matchmakerId,
        firstPartyId,
        note,
        locale,
      });

      // Comprobar si existe una consulta activa.
      const existingInquiry = await prisma.availabilityInquiry.findFirst({
        where: {
          firstPartyId,
          expiresAt: {
            gt: new Date(),
          },
        },
      });

      if (existingInquiry) {
        console.log('Found existing active inquiry:', existingInquiry);
        throw new Error('קיימת כבר בקשת זמינות פעילה');
      }

      // Crear una nueva consulta.
      console.log('Creating new inquiry...');
      const inquiry = await prisma.availabilityInquiry.create({
        data: {
          matchmakerId,
          firstPartyId,
          secondPartyId: firstPartyId,
          note,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 horas
        },
        include: {
          firstParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          secondParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          matchmaker: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      });

      console.log('Successfully created inquiry:', inquiry);

      // Enviar notificación por correo electrónico.
      if (inquiry.firstParty.email) {
        console.log('Attempting to send email to:', inquiry.firstParty.email);
        
        try {
          // ============================ INICIO DE LA MODIFICACIÓN ============================
          // Pasar el 'locale' al servicio de correo electrónico.
          await emailService.sendAvailabilityCheck({
            locale, // Pasar el 'locale' recibido.
            email: inquiry.firstParty.email,
            recipientName: `${inquiry.firstParty.firstName} ${inquiry.firstParty.lastName}`,
            matchmakerName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            inquiryId: inquiry.id,
          });
          // ============================= FIN DE LA MODIFICACIÓN ==============================
          console.log('Email sent successfully');
        } catch (emailError) {
          console.error('Failed to send email:', emailError);
          // Continuar aunque el correo electrónico falle; queremos que la consulta se guarde.
        }
      } else {
        console.warn('No email found for first party');
      }

      return inquiry;
    } catch (error) {
      console.error('Error in sendAvailabilityInquiry:', error);
      throw error;
    }
  }

  static async updateInquiryResponse({
    inquiryId,
    userId,
    isAvailable,
    note,
    locale, // Destructurar el nuevo parámetro 'locale'.
  }: UpdateInquiryResponse) {
    try {
      console.log('Starting to update inquiry response:', {
        inquiryId,
        userId,
        isAvailable,
        note,
        locale
      });

      // Comprobar si la consulta existe.
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true,
            },
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true,
            },
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      });

      if (!inquiry) {
        console.log('Inquiry not found:', inquiryId);
        throw new Error('בקשת הזמינות לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);

      if (inquiry.expiresAt < new Date()) {
        console.log('Inquiry expired:', inquiry.expiresAt);
        throw new Error('תוקף הבקשה פג');
      }

      const isFirstParty = inquiry.firstPartyId === userId;
      const isSecondParty = inquiry.secondPartyId === userId;

      if (!isFirstParty && !isSecondParty) {
        console.log('Unauthorized response attempt. User:', userId);
        throw new Error('אין הרשאה לעדכן בקשה זו');
      }

      // Actualizar tanto la consulta como el perfil en una transacción.
      console.log('Updating inquiry and profile...');
      const result = await prisma.$transaction(async (tx) => {
        // Actualizar el perfil del usuario.
        const updatedProfile = await tx.profile.update({
          where: { userId },
          data: {
            availabilityStatus: isAvailable
              ? AvailabilityStatus.AVAILABLE
              : AvailabilityStatus.UNAVAILABLE,
            availabilityNote: note,
            availabilityUpdatedAt: new Date(),
          },
        });
        console.log('Profile updated:', updatedProfile);

        // Actualizar la consulta.
        const updatedInquiry = await tx.availabilityInquiry.update({
          where: { id: inquiryId },
          data: {
            ...(isFirstParty
              ? { firstPartyResponse: isAvailable }
              : { secondPartyResponse: isAvailable }),
            updatedAt: new Date(),
          },
          include: {
            firstParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true,
              },
            },
            secondParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true,
              },
            },
            matchmaker: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
              },
            },
          },
        });
        console.log('Inquiry updated:', updatedInquiry);

        // Enviar notificación al matchmaker.
        if (inquiry.matchmaker.email) {
          // ============================ INICIO DE LA MODIFICACIÓN ============================
          // Pasar el 'locale' al servicio de correo electrónico.
          await emailService.sendSuggestionNotification({
            locale, // Pasar el 'locale' recibido.
            email: inquiry.matchmaker.email,
            recipientName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            matchmakerName: 'המערכת',
            suggestionDetails: {
              additionalInfo: `${
                isFirstParty ? 'הצד הראשון' : 'הצד השני'
              } ${isAvailable ? 'זמין' : 'אינו זמין'} ${
                note ? `(הערה: ${note})` : ''
              }`,
            },
          });
          // ============================= FIN DE LA MODIFICACIÓN ==============================
        }

        return updatedInquiry;
      });

      return result;
    } catch (error) {
      console.error('Error in updateInquiryResponse:', error);
      throw error;
    }
  }

  static async getInquiryById(inquiryId: string) {
    console.log('Fetching inquiry by ID:', inquiryId);
    try {
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      });

      if (!inquiry) {
        console.log('No inquiry found with ID:', inquiryId);
        throw new Error('הבקשה לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);
      return inquiry;
    } catch (error) {
      console.error('Error in getInquiryById:', error);
      throw error;
    }
  }

  static async getAvailabilityStats(
    matchmakerId: string
  ): Promise<AvailabilityStats> {
    console.log('Calculating availability stats for matchmaker:', matchmakerId);
    try {
      const stats = await prisma.profile.groupBy({
        by: ['availabilityStatus'],
        where: {
          user: {
            OR: [
              { firstPartyInquiries: { some: { matchmakerId } } },
              { secondPartyInquiries: { some: { matchmakerId } } },
            ],
          },
        },
        _count: true,
      });

      console.log('Raw stats:', stats);

      const result: AvailabilityStats = {
        available:
          stats.find((s) => s.availabilityStatus === AvailabilityStatus.AVAILABLE)
            ?._count || 0,
        unavailable:
          stats.find(
            (s) => s.availabilityStatus === AvailabilityStatus.UNAVAILABLE
          )?._count || 0,
        dating:
          stats.find((s) => s.availabilityStatus === AvailabilityStatus.DATING)
            ?._count || 0,
        pending: stats.find((s) => s.availabilityStatus === null)?._count || 0,
      };

      console.log('Processed stats:', result);
      return result;
    } catch (error) {
      console.error('Error in getAvailabilityStats:', error);
      throw error;
    }
  }

  static async getAllInquiries(
    userId: string,
    { status = 'pending', orderBy = 'createdAt', limit }: GetInquiriesOptions = {}
  ) {
    try {
      // Construir la cláusula 'where' basada en el estado.
      const where: Prisma.AvailabilityInquiryWhereInput = {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
        ...(status === 'pending' && {
          expiresAt: { gt: new Date() },
          OR: [
            { firstPartyResponse: null },
            { secondPartyResponse: null },
          ],
        }),
        ...(status === 'completed' && {
          firstPartyResponse: { not: null },
          secondPartyResponse: { not: null },
        }),
        ...(status === 'expired' && {
          expiresAt: { lt: new Date() },
        }),
      };

      const validOrderBy = orderBy || 'createdAt';

      const inquiries = await prisma.availabilityInquiry.findMany({
        where,
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true,
                },
              },
            },
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
        orderBy: {
          [validOrderBy]: 'desc',
        },
        ...(limit ? { take: limit } : {}),
      });

      return inquiries;
    } catch (error) {
      console.error('Error in getAllInquiries:', error);
      throw error;
    }
  }
}
--- End of Content for availabilityService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\profileAiService.ts
--------------------------------------------------------------------------------
Content:
// File: src/lib/services/profileAiService.ts

import prisma from "@/lib/prisma";
import aiService from "./aiService";
import type { User, Profile, QuestionnaireResponse, Prisma as PrismaTypes, ReligiousJourney, FriendTestimonial } from '@prisma/client';

// 1. --- Import types and questions from the questionnaire module ---
import type { Question } from '@/components/questionnaire/types/types';
import { valuesQuestions } from '@/components/questionnaire/questions/values/valuesQuestions';
import { personalityQuestions } from '@/components/questionnaire/questions/personality/personalityQuestions';
import { relationshipQuestions } from '@/components/questionnaire/questions/relationship/relationshipQuestions';
import { partnerQuestions } from '@/components/questionnaire/questions/partner/partnerQuestions';
import { religionQuestions } from '@/components/questionnaire/questions/religion/religionQuestions';

// 2. --- Centralized Question Data ---
const allQuestions: Map<string, Question> = new Map();
[
  ...valuesQuestions,
  ...personalityQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
].forEach(q => allQuestions.set(q.id, q));

// 3. --- Strongly-typed interfaces for data handling ---
type WorldKey = 'values' | 'personality' | 'relationship' | 'partner' | 'religion';
type DbWorldKey = `${WorldKey}Answers`;

const KEY_MAPPING: Record<WorldKey, DbWorldKey> = {
  values: 'valuesAnswers',
  personality: 'personalityAnswers',
  relationship: 'relationshipAnswers',
  partner: 'partnerAnswers',
  religion: 'religionAnswers'
};

interface JsonAnswerData {
  questionId: string;
  value: PrismaTypes.JsonValue;
  answeredAt: string;
  isVisible?: boolean;
}

type UserWithRelations = User & {
  profile: (Profile & {
    testimonials?: FriendTestimonial[]; // הוספת השדה האופציונלי
  }) | null;
  questionnaireResponses: QuestionnaireResponse[];
};

// 4. --- Helper Functions for Formatting ---

function formatDisplayValue(value: PrismaTypes.JsonValue | null | undefined, fallback: string = "לא צוין"): string {
  if (value === null || value === undefined) {
    return fallback;
  }
  if (typeof value === 'string' && value.trim() === '') {
    return fallback;
  }
  if (typeof value === 'boolean') {
    return value ? "כן" : "לא";
  }
  if (typeof value === 'number') {
    return String(value);
  }
  if (value instanceof Date) {
    return value.toLocaleDateString('he-IL');
  }
  if (Array.isArray(value)) {
    return value.length > 0 ? value.map(String).join(', ') : fallback;
  }
  if (typeof value === 'object') {
     if (Object.keys(value).length > 0) {
         return Object.entries(value)
             .map(([key, val]) => `${key}: ${val}`)
             .join('; ');
     }
     return fallback;
  }
  return String(value);
}

function formatArray(arr: string[] | null | undefined, fallback: string = "לא צוין"): string {
  if (!arr || arr.length === 0) {
    return fallback;
  }
  return arr.join(', ');
}

function isValidAnswerObject(item: unknown): item is PrismaTypes.JsonObject & { value: PrismaTypes.JsonValue; questionId: unknown; answeredAt: unknown } {
  return (
    typeof item === 'object' &&
    item !== null &&
    'questionId' in item &&
    'value' in item &&
    item.value !== undefined &&
    'answeredAt' in item
  );
}

function safeParseAnswers(jsonValue: PrismaTypes.JsonValue | null): JsonAnswerData[] {
  if (Array.isArray(jsonValue)) {
    return jsonValue
      .filter(isValidAnswerObject)
      .map(item => ({
        questionId: String(item.questionId || ''),
        value: item.value,
        answeredAt: String(item.answeredAt || new Date().toISOString()),
        isVisible: typeof item.isVisible === 'boolean' ? item.isVisible : true,
      }))
      .filter(item => item.questionId);
  }
  return [];
}

function formatSingleAnswer(answer: JsonAnswerData): string | null {
  const questionDef = allQuestions.get(answer.questionId);
  if (!questionDef) {
    return `**שאלה לא מזוהה (${answer.questionId}):** ${formatDisplayValue(answer.value)}\n`;
  }

  if (answer.value === null || answer.value === undefined || answer.value === '') return null;
  if (Array.isArray(answer.value) && answer.value.length === 0) return null;

  let narrativePart = `**${questionDef.question}**\n`;
  
  switch (questionDef.type) {
    case 'singleChoice':
    case 'iconChoice':
    case 'scenario': {
      const selectedOption = questionDef.options?.find(o => o.value === answer.value);
      narrativePart += `תשובה: ${selectedOption ? selectedOption.text : formatDisplayValue(answer.value)}\n`;
      break;
    }
    case 'multiChoice':
    case 'multiSelect':
    case 'multiSelectWithOther': {
      if (Array.isArray(answer.value)) {
        const selectedTexts = answer.value.map(val => {
          if (typeof val === 'string' && val.startsWith('custom:')) {
            return `(אחר) ${val.replace('custom:', '').trim()}`;
          }
          const option = questionDef.options?.find(o => o.value === val);
          return option ? option.text : String(val);
        });
        narrativePart += `תשובות: ${selectedTexts.join(', ')}\n`;
      }
      break;
    }
    case 'openText': {
      narrativePart += `תשובה: "${formatDisplayValue(answer.value)}"\n`;
      break;
    }
    case 'scale': {
      const minLabel = questionDef.labels?.min || 'נמוך';
      const maxLabel = questionDef.labels?.max || 'גבוה';
      narrativePart += `דירוג: ${answer.value}/10 (כאשר 1=${minLabel} ו-10=${maxLabel})\n`;
      break;
    }
    case 'budgetAllocation': {
      if (typeof answer.value === 'object' && answer.value && !Array.isArray(answer.value)) {
          const allocations = Object.entries(answer.value)
              .filter(([, points]) => typeof points === 'number' && points > 0)
              .map(([category, points]) => `${category}: ${points}%`)
              .join('; ');
          narrativePart += `הקצאת חשיבות: ${allocations || 'לא צוין'}\n`;
      }
      break;
    }
    default: {
      narrativePart += `תשובה: ${formatDisplayValue(answer.value)}\n`;
    }
  }
  
  return narrativePart + '\n';
}

function processQuestionnaireData(questionnaire: QuestionnaireResponse | null | undefined) {
    const totalCount = allQuestions.size;
    if (!questionnaire) {
        return {
            answeredCount: 0,
            totalCount,
            completionPercentage: 0,
            answersNarrative: "המשתמש עדיין לא החל למלא את השאלון."
        };
    }

    const worldKeys: WorldKey[] = ['values', 'personality', 'relationship', 'partner', 'religion'];
    let answeredCount = 0;
    const narrativeChunks: string[] = [];

    worldKeys.forEach(worldKey => {
        const dbKey = KEY_MAPPING[worldKey];
        const answers = safeParseAnswers(questionnaire[dbKey]);
        
        if (answers.length > 0) {
            answeredCount += answers.length;
            
            const worldInfo = allQuestions.get(answers[0].questionId);
            const worldTitle = worldInfo?.worldId ? worldInfo.worldId.charAt(0) + worldInfo.worldId.slice(1).toLowerCase() : worldKey;
            
            narrativeChunks.push(`### עולם ה${worldTitle}`);
            
            answers.forEach(answer => {
                const formattedPart = formatSingleAnswer(answer);
                if (formattedPart) {
                    narrativeChunks.push(formattedPart);
                }
            });
        }
    });

    const completionPercentage = totalCount > 0 ? Math.round((answeredCount / totalCount) * 100) : 0;
    
    return {
        answeredCount,
        totalCount,
        completionPercentage,
        answersNarrative: narrativeChunks.length > 0 ? narrativeChunks.join('\n') : "המשתמש החל למלא את השאלון אך לא נמצאו תשובות תקפות לעיבוד."
    };
}


// 5. --- Main Service Functions ---

export async function generateNarrativeProfile(userId: string): Promise<string | null> {
  const user: UserWithRelations | null = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      profile: true,
      
      questionnaireResponses: { orderBy: { lastSaved: 'desc' }, take: 1 },
    
    },
  });

  if (!user || !user.profile) {
    console.error(`Could not generate narrative profile: User or Profile not found for userId: ${userId}`);
    return null;
  }

  const { profile, questionnaireResponses } = user;
  const questionnaire = questionnaireResponses[0];

  const calculateAge = (birthDate: Date): number => {
    const today = new Date();
    const age = today.getFullYear() - birthDate.getFullYear();
    const m = today.getMonth() - birthDate.getMonth();
    return (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) ? age - 1 : age;
  };
  const age = calculateAge(profile.birthDate);
  
  const questionnaireData = processQuestionnaireData(questionnaire);

  const religiousJourneyMap: Record<ReligiousJourney, string> = {
      BORN_INTO_CURRENT_LIFESTYLE: "גדל/ה בסביבה דתית הדומה לרמתו/ה כיום",
      BORN_SECULAR: "גדל/ה בסביבה חילונית",
      BAAL_TESHUVA: "חוזר/ת בתשובה",
      DATLASH: "יצא/ה בשאלה (דתל\"ש)",
      CONVERT: "גר/גיורת",
      IN_PROCESS: "בתהליך של שינוי/התחזקות/התלבטות דתית",
      OTHER: "בעל/ת רקע דתי אחר או מורכב"
  };

  const narrativeParts: string[] = [
    `# פרופיל AI עבור ${user.firstName} ${user.lastName}, ${profile.gender === 'MALE' ? 'גבר' : 'אישה'} בן/בת ${age}`,
    `## סיכום כללי`,
    `- **שם:** ${user.firstName} ${user.lastName}`,
    `- **גיל:** ${age} ${profile.birthDateIsApproximate ? '(משוער)' : ''}`,
    `- **מצב משפחתי:** ${formatDisplayValue(profile.maritalStatus)}`,
    `- **מגורים:** ${formatDisplayValue(profile.city)}`,
    `- **רמה דתית:** ${formatDisplayValue(profile.religiousLevel)}`,
    profile.religiousJourney ? `- **רקע/מסע דתי:** ${formatDisplayValue(religiousJourneyMap[profile.religiousJourney])}` : '',
    `- **עיסוק:** ${formatDisplayValue(profile.occupation)}`,
    `- **השכלה:** ${formatDisplayValue(profile.educationLevel)}, ${formatDisplayValue(profile.education)}`,
    `- **שומר/ת נגיעה:** ${formatDisplayValue(profile.shomerNegiah)}`,
    `- **רקע משפחתי:** מצב הורים: ${formatDisplayValue(profile.parentStatus)}. מקצוע האב: ${formatDisplayValue(profile.fatherOccupation)}. מקצוע האם: ${formatDisplayValue(profile.motherOccupation)}.`,
  ].filter(Boolean);

  if (user.source === 'MANUAL_ENTRY' && profile.manualEntryText) {
    narrativeParts.push(`\n**הערת שדכן (למועמד ידני):** ${profile.manualEntryText}`);
  }

  if (profile.about) {
    narrativeParts.push(`## קצת עליי (מהפרופיל)\n"${profile.about}"`);
  }

  // --- START: הוספת השדות הנרטיביים החדשים ---
  const personalInsightsParts = [
    profile.profileHeadline ? `**הכותרת האישית שלי:**\n"${profile.profileHeadline}"` : '',
    profile.inspiringCoupleStory ? `**זוג שמעורר בי השראה:**\n${profile.inspiringCoupleStory}` : '',
    profile.influentialRabbi ? `**דמות רוחנית שהשפיעה עליי:**\n${profile.influentialRabbi}` : ''
  ].filter(Boolean);

  if (personalInsightsParts.length > 0) {
    narrativeParts.push(`## תובנות אישיות נוספות\n${personalInsightsParts.join('\n\n')}`);
  }
  // --- END: הוספת השדות הנרטיביים החדשים ---

  if (profile.hasMedicalInfo) {
    narrativeParts.push(
      `## מידע רפואי`,
      `- **פירוט המידע:** ${formatDisplayValue(profile.medicalInfoDetails)}`,
      `- **תזמון חשיפה:** ${formatDisplayValue(profile.medicalInfoDisclosureTiming)}`,
      `- **המידע גלוי בפרופיל הציבורי:** ${profile.isMedicalInfoVisible ? 'כן' : 'לא'}`
    );
  }
  
  narrativeParts.push(
    `## תכונות אופי ותחביבים`,
    `- **תכונות בולטות:** ${formatArray(profile.profileCharacterTraits)}`,
    `- **תחביבים עיקריים:** ${formatArray(profile.profileHobbies)}`
  );
  
  const preferredJourneysText = (profile.preferredReligiousJourneys && profile.preferredReligiousJourneys.length > 0)
    ? formatArray(profile.preferredReligiousJourneys.map(j => religiousJourneyMap[j] || j))
    : "לא צוין";

  narrativeParts.push(
    `## מה אני מחפש/ת בבן/בת הזוג (העדפות מהפרופיל)`,
    `- **תיאור כללי:** ${formatDisplayValue(profile.matchingNotes)}`,
    `- **טווח גילאים מועדף:** ${formatDisplayValue(profile.preferredAgeMin, '?')} - ${formatDisplayValue(profile.preferredAgeMax, '?')}`,
    `- **רמות דתיות מועדפות:** ${formatArray(profile.preferredReligiousLevels)}`,
    `- **רקע/מסע דתי מועדף:** ${preferredJourneysText}`,
    `- **רמות השכלה מועדפות:** ${formatArray(profile.preferredEducation)}`,
    `- **מוצאים מועדפים:** ${formatArray(profile.preferredOrigins)}`
  );

  narrativeParts.push(
    `\n## ניתוח השלמת השאלון`,
    `- **סך הכל שאלות במערכת:** ${questionnaireData.totalCount}`,
    `- **שאלות שנענו:** ${questionnaireData.answeredCount}`,
    `- **אחוז השלמה:** ${questionnaireData.completionPercentage}%`,
    `\n## תובנות מהשאלון (תשובות מפורטות)\n${questionnaireData.answersNarrative}`
  );
  const approvedTestimonials = profile.testimonials?.filter(t => t.status === 'APPROVED');
  if (approvedTestimonials && approvedTestimonials.length > 0) {
    narrativeParts.push(`## המלצות מחברים`);
    approvedTestimonials.forEach(t => {
      narrativeParts.push(
        `**ממליץ/ה:** ${t.authorName} (${t.relationship})\n` +
        `**תוכן ההמלצה:** "${t.content}"`
      );
    });
  }
  return narrativeParts.join('\n\n').trim();
}

export async function updateUserAiProfile(userId: string): Promise<void> {
  console.log(`Starting AI profile update for userId: ${userId}`);
  const profileText = await generateNarrativeProfile(userId);
  if (!profileText) {
    console.error(`Failed to generate narrative profile for userId: ${userId}. Aborting AI update.`);
    return;
  }

  const vector = await aiService.generateTextEmbedding(profileText);
  if (!vector) {
    console.error(`Failed to generate vector embedding for userId: ${userId}. Aborting DB update.`);
    return;
  }

  try {
    const profile = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });
    if (!profile) {
      console.error(`No profile found for userId: ${userId} to save the vector against.`);
      return;
    }
    
    const vectorSqlString = `[${vector.join(',')}]`;
    await prisma.$executeRaw`
      INSERT INTO "profile_vectors" ("profileId", vector, "updatedAt")
      VALUES (${profile.id}, ${vectorSqlString}::vector, NOW())
      ON CONFLICT ("profileId")
      DO UPDATE SET
        vector = EXCLUDED.vector,
        "updatedAt" = NOW();
    `;
    console.log(`Successfully updated AI profile and vector for userId: ${userId} (profileId: ${profile.id})`);
  } catch (error) {
    console.error(`Error saving profile vector to DB for userId: ${userId}:`, error);
  }
}

const profileAiService = {
  generateNarrativeProfile,
  updateUserAiProfile,
};

export default profileAiService;
--- End of Content for profileAiService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\profileFeedbackService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/profileFeedbackService.ts

import prisma from "@/lib/prisma";
import aiService from "./aiService";
import { generateNarrativeProfile } from "./profileAiService";
import { getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";

// Import types
import type { UserProfile, QuestionnaireResponse, UserImage } from '@/types/next-auth';
import type { Question } from '@/components/questionnaire/types/types';
import type { User } from '@prisma/client';
import { Gender } from '@prisma/client';
import type { Locale } from "../../../i18n-config";

// Import all question definitions
import { personalityQuestions } from '@/components/questionnaire/questions/personality/personalityQuestions';
import { valuesQuestions } from '@/components/questionnaire/questions/values/valuesQuestions';
import { relationshipQuestions } from '@/components/questionnaire/questions/relationship/relationshipQuestions';
import { partnerQuestions } from '@/components/questionnaire/questions/partner/partnerQuestions';
import { religionQuestions } from '@/components/questionnaire/questions/religion/religionQuestions';

const allQuestions: Question[] = [
  ...personalityQuestions,
  ...valuesQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
];

// טיפוס מפושט רק לשאלות
type QuestionnaireQuestionsDict = {
  [worldKey: string]: {
    [questionId: string]: {
      question: string;
      placeholder?: string;
      helpText?: string;
      [key: string]: any;
    };
  };
};

export interface ProfileFeedbackReport {
  name: string;
  aiSummary: {
    personality: string;
    lookingFor: string;
  } | null;
  completedProfileItems: string[];
  missingProfileItems: string[];
  missingQuestionnaireItems: {
    world: string;
    question: string;
    link: string;
  }[];
  completionPercentage: number;
}

type FullUserForFeedback = User & {
    profile: UserProfile | null;
    images: UserImage[];
    questionnaireResponses: QuestionnaireResponse[];
};

class ProfileFeedbackService {
  private static instance: ProfileFeedbackService;
  private constructor() {}

  public static getInstance(): ProfileFeedbackService {
    if (!ProfileFeedbackService.instance) {
      ProfileFeedbackService.instance = new ProfileFeedbackService();
    }
    return ProfileFeedbackService.instance;
  }

  public async compileFeedbackReport(
    userId: string, 
    locale: Locale,
    questionsDict: QuestionnaireQuestionsDict
  ): Promise<ProfileFeedbackReport> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { 
        profile: true, 
        images: true, 
        questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } }
      },
    });

    if (!user || !user.profile) {
      throw new Error(`User or profile not found for userId: ${userId}`);
    }

    const narrativeProfile = await generateNarrativeProfile(userId);
    const aiAnalysis = narrativeProfile ? await aiService.getProfileAnalysis(narrativeProfile) : null;
    
    const { completed, missing } = this.analyzeProfileFields(user as FullUserForFeedback);
    
    const missingQuestionnaireItems = this.analyzeMissingQuestionnaireAnswers(
      user.questionnaireResponses[0], 
      locale,
      questionsDict
    );

    const completionPercentage = this.calculateCompletionPercentage(user as FullUserForFeedback);

    return {
      name: user.firstName,
      aiSummary: aiAnalysis ? {
        personality: aiAnalysis.personalitySummary,
        lookingFor: aiAnalysis.lookingForSummary,
      } : null,
      completedProfileItems: completed,
      missingProfileItems: missing,
      missingQuestionnaireItems,
      completionPercentage,
    };
  }
  
  private calculateCompletionPercentage(user: FullUserForFeedback): number {
    if (!user.profile) return 0;
    
    const checks: boolean[] = [];
    const p = user.profile;

    checks.push((user.images?.length ?? 0) >= 1);
    checks.push(!!p.profileHeadline);
    checks.push(!!p.about && p.about.trim().length >= 100);
    checks.push(!!p.inspiringCoupleStory);
    checks.push(p.height !== null && p.height !== undefined);
    checks.push(!!p.city);
    checks.push(!!p.maritalStatus);
    checks.push(!!p.religiousLevel);
    checks.push(!!p.educationLevel);
    checks.push(!!p.occupation);
    checks.push(!!(p.matchingNotes && p.matchingNotes.trim().length > 0));
    
    const totalProfileChecks = checks.length;
    const completedProfileChecks = checks.filter(Boolean).length;
    const profileScore = totalProfileChecks > 0 ? (completedProfileChecks / totalProfileChecks) : 0;
    
    const totalQuestions = allQuestions.length;
    const answeredQuestionsCount = this.getAnsweredQuestionIds(user.questionnaireResponses[0]).size;
    const questionnaireScore = totalQuestions > 0 ? (answeredQuestionsCount / totalQuestions) : 0;
    
    const finalPercentage = (profileScore * 60) + (questionnaireScore * 40);

    return Math.round(finalPercentage);
  }

  private analyzeProfileFields(user: FullUserForFeedback): { completed: string[], missing: string[] } {
    const completed: string[] = [];
    const missing: string[] = [];
    const profile = user.profile;

    const fields = [
      { key: 'images', label: "תמונת פרופיל אחת לפחות", check: () => (user.images?.length ?? 0) > 0 },
      { key: 'profileHeadline', label: "כותרת פרופיל אישית", check: () => !!profile?.profileHeadline },
      { key: 'about', label: "שדה 'אודותיי' (לפחות 100 תווים)", check: () => !!profile?.about && profile.about.trim().length >= 100 },
      { key: 'inspiringCoupleStory', label: "סיפור על זוג מעורר השראה", check: () => !!profile?.inspiringCoupleStory },
      { key: 'height', label: "גובה", check: () => !!profile?.height },
      { key: 'city', label: "עיר מגורים", check: () => !!profile?.city },
      { key: 'maritalStatus', label: "מצב משפחתי", check: () => !!profile?.maritalStatus },
      { key: 'religiousLevel', label: "רמה דתית", check: () => !!profile?.religiousLevel },
      { key: 'educationLevel', label: "רמת השכלה", check: () => !!profile?.educationLevel },
      { key: 'occupation', label: "עיסוק", check: () => !!profile?.occupation },
      { key: 'matchingNotes', label: "תיאור על בן/בת הזוג", check: () => !!profile?.matchingNotes && profile.matchingNotes.trim().length > 0 },
    ];

    fields.forEach(field => {
      if (field.check()) {
        completed.push(field.label);
      } else {
        missing.push(field.label);
      }
    });

    return { completed, missing };
  }
  
  private getAnsweredQuestionIds(questionnaire: QuestionnaireResponse | undefined): Set<string> {
    const answeredIds = new Set<string>();
    if (!questionnaire) return answeredIds;

    const worldKeys: (keyof QuestionnaireResponse)[] = ['valuesAnswers', 'personalityAnswers', 'relationshipAnswers', 'partnerAnswers', 'religionAnswers'];
    
    worldKeys.forEach(worldKey => {
      const answers = questionnaire[worldKey] as { questionId: string }[] | undefined;
      if(Array.isArray(answers)) {
        answers.forEach(ans => ans && ans.questionId && answeredIds.add(ans.questionId));
      }
    });
    return answeredIds;
  }

  private analyzeMissingQuestionnaireAnswers(
    questionnaire: QuestionnaireResponse | undefined, 
    locale: Locale,
    questionsDict: QuestionnaireQuestionsDict
  ): { world: string; question: string; link: string }[] {
    const answeredIds = this.getAnsweredQuestionIds(questionnaire);

    // מפת שמות העולמות בעברית
    const worldNames: Record<string, string> = {
      'personality': 'האישיות',
      'values': 'הערכים', 
      'relationship': 'הזוגיות',
      'partner': 'הפרטנר',
      'religion': 'דת ומסורת'
    };

    return allQuestions
      .filter(q => !answeredIds.has(q.id))
      .map(q => {
        const worldKey = q.worldId.toUpperCase();
        
        // נסה למצוא את השאלה במילון
        const translatedQuestion = questionsDict[worldKey]?.[q.id]?.question || q.question || q.id;
        
        // השתמש בשם העולם בעברית
        const translatedWorld = worldNames[q.worldId] || q.worldId;

        return {
            world: translatedWorld,
            question: translatedQuestion,
            link: `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/${locale}/questionnaire?world=${q.worldId.toUpperCase()}&question=${q.id}`
        };
      });
  }
}

export const profileFeedbackService = ProfileFeedbackService.getInstance();
--- End of Content for profileFeedbackService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\questionnaireService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/questionnaireService.ts

import 'server-only';
import { Prisma } from '@prisma/client';
import type { Locale } from '../../../i18n-config';
import { getQuestionnaireQuestionsDictionary } from '@/lib/dictionaries';
import {
  FormattedAnswer,
  QuestionnaireResponse,
} from '@/types/next-auth';
import { Question, WorldId } from '@/components/questionnaire/types/types';

// Importowanie oryginalnych struktur pytań
import { personalityQuestions } from '@/components/questionnaire/questions/personality/personalityQuestions';
import { valuesQuestions } from '@/components/questionnaire/questions/values/valuesQuestions';
import { relationshipQuestions } from '@/components/questionnaire/questions/relationship/relationshipQuestions';
import { partnerQuestions } from '@/components/questionnaire/questions/partner/partnerQuestions';
import { religionQuestions } from '@/components/questionnaire/questions/religion/religionQuestions';

// Mapowanie struktur pytań
const allQuestionStructures: Record<WorldId, Question[]> = {
  PERSONALITY: personalityQuestions,
  VALUES: valuesQuestions,
  RELATIONSHIP: relationshipQuestions,
  PARTNER: partnerQuestions,
  RELIGION: religionQuestions,
};

/**
 * פונקציה זו מעצבת את התשובות הגולמיות מהשאלון לתצוגה,
 * תוך שימוש בלוגיקת תרגום דינמית בהתאם לשפת הצופה.
 * @param questionnaireResponse - אובייקט השאלון הגולמי ממסד הנתונים.
 * @param viewerLocale - שפת הממשק של המשתמש הצופה בפרופיל.
 * @returns אובייקט QuestionnaireResponse עם שדה 'formattedAnswers' מעוצב ומתורגם.
 */
export async function formatQuestionnaireForDisplay(
  questionnaireResponse: QuestionnaireResponse,
  viewerLocale: Locale,
   canViewAll: boolean // <-- הוספת הפרמטר החדש

): Promise<QuestionnaireResponse> {
  console.log('---[ SERVER LOG | questionnaireService ]--- מתחיל עיבוד תשובות עבור שפה:', viewerLocale);

  // טעינת מילון התרגומים המתאים לשפת הצפייה
  const questionsDict = await getQuestionnaireQuestionsDictionary(viewerLocale);

  const formattedAnswers: { [key: string]: FormattedAnswer[] } = {};
  const worlds: WorldId[] = ['PERSONALITY', 'VALUES', 'RELATIONSHIP', 'PARTNER', 'RELIGION'];

  for (const world of worlds) {
    const worldKey = `${world.toLowerCase()}Answers` as keyof QuestionnaireResponse;
    const rawAnswers = (questionnaireResponse[worldKey] as Prisma.JsonArray) || [];
    
    console.log(`---[ SERVER LOG | questionnaireService ]--- מעבד את עולם "${world}". נמצאו ${Array.isArray(rawAnswers) ? rawAnswers.length : 0} תשובות גולמיות.`);
    
    if (!Array.isArray(rawAnswers)) continue;

    formattedAnswers[world] = rawAnswers
      .map((rawAns: any): FormattedAnswer | null => {
        // ולידציה בסיסית של מבנה התשובה
        if (typeof rawAns !== 'object' || rawAns === null || !rawAns.questionId) {
            console.warn(`---[ SERVER LOG | questionnaireService ]--- מדלג על רשומת תשובה לא תקינה בעולם "${world}":`, rawAns);
            return null;
        }

        // איתור מבנה השאלה המקורי (מכיל הגדרות כמו type, totalPoints וכו')
        const questionStructure = allQuestionStructures[world].find(q => q.id === rawAns.questionId);
        if (!questionStructure) {
            console.warn(`---[ SERVER LOG | questionnaireService ]--- לא נמצאה הגדרת מבנה עבור שאלה עם ID "${rawAns.questionId}" בעולם "${world}".`);
            return null;
        }

        // איתור התרגומים עבור השאלה הספציפית מהמילון שנטען
        const questionContent = questionsDict[world]?.[rawAns.questionId];
        if (!questionContent || !questionContent.question) {
            console.warn(`---[ SERVER LOG | questionnaireService ]--- חסר תוכן במילון עבור שאלה עם ID "${rawAns.questionId}" בעולם "${world}".`);
            return null;
        }

        let displayText = 'לא נענה';
        
        // --- לוגיקת עיצוב התשובות לפי סוג השאלה ---

        if (questionStructure.type === 'openText' && typeof rawAns.value === 'object' && rawAns.value?.text) {
          // שאלת טקסט פתוח (עם תמיכה בשפה)
          displayText = rawAns.value.text;
        
        } else if (typeof rawAns.value === 'string' && questionContent.options?.[rawAns.value]) {
          // שאלת בחירה יחידה
          const optionContent = questionContent.options[rawAns.value];
          displayText = typeof optionContent === 'string' ? optionContent : optionContent.text;
        
        } else if (Array.isArray(rawAns.value)) {
          // שאלת בחירה מרובה
          displayText = rawAns.value
            .map(val => {
                const optionContent = questionContent.options?.[val];
                if (optionContent) {
                    return typeof optionContent === 'string' ? optionContent : optionContent.text;
                }
                if (typeof val === 'string' && val.startsWith('custom:')) {
                    return val.replace('custom:', '');
                }
                return val;
            })
            .join(', ');
        
        } else if (typeof rawAns.value === 'number' && questionStructure.type === 'scale') {
            // שאלת סולם
            displayText = `${rawAns.value} / ${questionStructure.max || 10}`;
        
        } else if (typeof rawAns.value === 'object' && !Array.isArray(rawAns.value) && rawAns.value !== null && questionStructure.type === 'budgetAllocation') {
            // #############################################################
            // # START: *** התיקון המרכזי והסופי לשאלות תקציב ***
            // #############################################################
            displayText = Object.entries(rawAns.value as Record<string, number>)
              .map(([key, val]) => {
                  // 1. שלוף את התרגום עבור המפתח (למשל, 'family_connections') מתוך המילון שנטען
                  const translatedLabel = questionContent.categories?.[key];

                  // 2. השתמש בתרגום אם נמצא, אחרת חזור למפתח המקורי באנגלית (כגיבוי)
                  const finalLabel = translatedLabel || key;

                  // 3. קבע את יחידת המידה: אם מוגדר `totalPoints`, אלו נקודות ולא אחוזים
                  const unit = questionStructure.totalPoints ? '' : '%';
                  
                  // 4. הרכב את הטקסט הסופי לתצוגה
                  return `${finalLabel}: ${val}${unit}`;
              })
              .join(' | '); // הפרדה ברורה בין הפריטים
            // #############################################################
            // # END: *** התיקון המרכזי והסופי לשאלות תקציב ***
            // #############################################################
        
        } else if (rawAns.value !== null && rawAns.value !== undefined) {
          // גיבוי כללי לכל מקרה אחר
          displayText = String(rawAns.value);
        }
        
        return {
          questionId: rawAns.questionId,
          question: questionContent.question,
          questionType: questionStructure.type,
          rawValue: rawAns.value,
          displayText,
          isVisible: rawAns.isVisible ?? true,
          answeredAt: rawAns.answeredAt,
        };
      })
      .filter((ans): ans is FormattedAnswer => ans !== null);
  }

// סינון תשובות שאינן גלויות (isVisible: false)
// יתבצע רק אם הצופה הוא לא הבעלים של הפרופיל.
  if (!canViewAll) { // <-- שימוש בשם החדש
    console.log('---[ SERVER LOG | questionnaireService ]--- מבצע סינון תשובות מוסתרות עבור צופה ללא הרשאה.');
    for (const world in formattedAnswers) {
        formattedAnswers[world] = formattedAnswers[world].filter(ans => ans.isVisible === true);
    }
  } else {
    console.log('---[ SERVER LOG | questionnaireService ]--- מדלג על סינון תשובות. לצופה יש הרשאה לראות הכל.');
  }


  console.log('---[ SERVER LOG | questionnaireService ]--- העיבוד הסתיים. מבנה הנתונים המעוצב:', JSON.stringify(formattedAnswers, null, 2));

  return {
    ...questionnaireResponse,
    formattedAnswers,
  };
}
--- End of Content for questionnaireService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\services_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\verificationService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/verificationService.ts
import { VerificationType, VerificationStatus, UserStatus, Prisma } from '@prisma/client';
import { randomInt } from 'crypto'; // For OTP generation
import prisma from '@/lib/prisma'; // Assuming global prisma instance

const OTP_LENGTH = 6;
const MAX_VERIFICATION_ATTEMPTS = 5; // Example value

interface VerificationResult {
  success: boolean;
  message: string;
  userId?: string | null; // Can be null if user association isn't direct or fails
  id?: string; // ID of the verification record
}

export class VerificationService {
  static async createVerification(
    userId: string,
    type: VerificationType,
    target: string, // e.g., email address or phone number
    expiresInHours: number,
    tx?: Prisma.TransactionClient // Optional transaction client
  ): Promise<{ otp: string; verification: { id: string; token: string; expiresAt: Date } }> {
    const effectivePrisma = tx || prisma;
    const otp = randomInt(10**(OTP_LENGTH - 1), 10**OTP_LENGTH -1).toString().padStart(OTP_LENGTH, '0');
    const expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);

    // Invalidate previous PENDING verifications of the same type for this user/target
    // This is especially important for OTPs to ensure only the latest one is active.
    // For PASSWORD_RESET, this is handled in the API route before calling createVerification.
    // For EMAIL verification during registration, this might also be good practice.
    if (type === VerificationType.EMAIL || type === VerificationType.PHONE_WHATSAPP) {
        await effectivePrisma.verification.updateMany({
            where: {
                // If userId is available and relevant for uniqueness (e.g. for EMAIL type)
                ...(userId && { userId }), 
                // For PHONE_WHATSAPP, target (phone number) is more critical for pending check
                ...(!userId && { target }), 
                type: type,
                status: VerificationStatus.PENDING,
            },
            data: {
                status: VerificationStatus.EXPIRED, // Or 'CANCELLED'
            },
        });
    }


    const verification = await effectivePrisma.verification.create({
      data: {
        userId,
        type,
        token: otp,
        target: target.toLowerCase(), // Normalize target (e.g. email)
        expiresAt,
        status: VerificationStatus.PENDING,
        attempts: 0,
      },
      select: { id: true, token: true, expiresAt: true } // Return only necessary fields
    });

    return { otp, verification };
  }

  static async verifyCode(
    code: string,
    type: VerificationType,
    target?: string // Target (e.g., email for password reset, phone for phone verify)
  ): Promise<VerificationResult & { userId: string | null }> { // Ensure userId is part of the promise
    const normalizedTarget = target?.toLowerCase();

    const verification = await prisma.verification.findFirst({
      where: {
        token: code,
        type,
        ...(normalizedTarget && { target: normalizedTarget }), // Use target if provided
        status: VerificationStatus.PENDING,
      },
      orderBy: {
        createdAt: 'desc', // Get the most recent one if multiple match (should be rare)
      },
    });

    if (!verification) {
      throw new Error('קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.');
    }

    if (new Date() > verification.expiresAt) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: VerificationStatus.EXPIRED },
      });
      throw new Error('תוקף הקוד פג. אנא בקש קוד חדש.');
    }

    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: VerificationStatus.FAILED },
      });
      throw new Error('חרגת ממספר ניסיונות האימות המותר. אנא בקש קוד חדש.');
    }

    // If code is correct (Implicitly, as we found it by token)
    // Increment attempts
    await prisma.verification.update({
      where: { id: verification.id },
      data: { 
        attempts: { increment: 1 },
        // DO NOT set to COMPLETED yet for PASSWORD_RESET.
        // Only set to COMPLETED after password has been updated in DB by the calling API.
        // For EMAIL verification, we can set to COMPLETED here.
        ...(type === VerificationType.EMAIL && { 
            status: VerificationStatus.COMPLETED,
            completedAt: new Date()
        })
      },
    });
    
    if (!verification.userId) {
        // This should not happen if the verification record was created correctly with a userId
        console.error(`VerificationService: userId missing on verification record ${verification.id} for type ${type} and target ${target}`);
        throw new Error('שגיאה פנימית: רשומת האימות אינה משויכת למשתמש.');
    }

    // For EMAIL verification type, update user status as well
    if (type === VerificationType.EMAIL && verification.userId) {
      const user = await prisma.user.findUnique({ where: {id: verification.userId }});
      if (user && !user.isVerified) { // Only update if not already verified
        await prisma.user.update({
          where: { id: verification.userId },
          data: {
            isVerified: true,
            // Only update status if it's PENDING_EMAIL_VERIFICATION
            ...(user.status === UserStatus.PENDING_EMAIL_VERIFICATION && {
                status: UserStatus.PENDING_PHONE_VERIFICATION, // Or ACTIVE if phone verification is not mandatory next
            }),
            updatedAt: new Date(),
          },
        });
      }
    }
    
    // For PASSWORD_RESET, the calling API (`/api/auth/reset-password`) will handle updating the password
    // and THEN it should explicitly mark the verification record as COMPLETED.
    // This function's role is just to validate the OTP itself.

    return {
      success: true,
      message: 'Code verified.',
      userId: verification.userId, // Return userId
      id: verification.id // Return verification record id
    };
  }

  // New method to explicitly complete a verification, e.g., after password reset
  static async completeVerification(verificationId: string): Promise<void> {
    await prisma.verification.update({
        where: { id: verificationId },
        data: {
            status: VerificationStatus.COMPLETED,
            completedAt: new Date(),
        },
    });
  }
}
--- End of Content for verificationService.ts ---

--- End of Content for services_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\services\verificationService.ts
--------------------------------------------------------------------------------
Content:
// src/lib/services/verificationService.ts
import { VerificationType, VerificationStatus, UserStatus, Prisma } from '@prisma/client';
import { randomInt } from 'crypto'; // For OTP generation
import prisma from '@/lib/prisma'; // Assuming global prisma instance

const OTP_LENGTH = 6;
const MAX_VERIFICATION_ATTEMPTS = 5; // Example value

interface VerificationResult {
  success: boolean;
  message: string;
  userId?: string | null; // Can be null if user association isn't direct or fails
  id?: string; // ID of the verification record
}

export class VerificationService {
  static async createVerification(
    userId: string,
    type: VerificationType,
    target: string, // e.g., email address or phone number
    expiresInHours: number,
    tx?: Prisma.TransactionClient // Optional transaction client
  ): Promise<{ otp: string; verification: { id: string; token: string; expiresAt: Date } }> {
    const effectivePrisma = tx || prisma;
    const otp = randomInt(10**(OTP_LENGTH - 1), 10**OTP_LENGTH -1).toString().padStart(OTP_LENGTH, '0');
    const expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);

    // Invalidate previous PENDING verifications of the same type for this user/target
    // This is especially important for OTPs to ensure only the latest one is active.
    // For PASSWORD_RESET, this is handled in the API route before calling createVerification.
    // For EMAIL verification during registration, this might also be good practice.
    if (type === VerificationType.EMAIL || type === VerificationType.PHONE_WHATSAPP) {
        await effectivePrisma.verification.updateMany({
            where: {
                // If userId is available and relevant for uniqueness (e.g. for EMAIL type)
                ...(userId && { userId }), 
                // For PHONE_WHATSAPP, target (phone number) is more critical for pending check
                ...(!userId && { target }), 
                type: type,
                status: VerificationStatus.PENDING,
            },
            data: {
                status: VerificationStatus.EXPIRED, // Or 'CANCELLED'
            },
        });
    }


    const verification = await effectivePrisma.verification.create({
      data: {
        userId,
        type,
        token: otp,
        target: target.toLowerCase(), // Normalize target (e.g. email)
        expiresAt,
        status: VerificationStatus.PENDING,
        attempts: 0,
      },
      select: { id: true, token: true, expiresAt: true } // Return only necessary fields
    });

    return { otp, verification };
  }

  static async verifyCode(
    code: string,
    type: VerificationType,
    target?: string // Target (e.g., email for password reset, phone for phone verify)
  ): Promise<VerificationResult & { userId: string | null }> { // Ensure userId is part of the promise
    const normalizedTarget = target?.toLowerCase();

    const verification = await prisma.verification.findFirst({
      where: {
        token: code,
        type,
        ...(normalizedTarget && { target: normalizedTarget }), // Use target if provided
        status: VerificationStatus.PENDING,
      },
      orderBy: {
        createdAt: 'desc', // Get the most recent one if multiple match (should be rare)
      },
    });

    if (!verification) {
      throw new Error('קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.');
    }

    if (new Date() > verification.expiresAt) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: VerificationStatus.EXPIRED },
      });
      throw new Error('תוקף הקוד פג. אנא בקש קוד חדש.');
    }

    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: VerificationStatus.FAILED },
      });
      throw new Error('חרגת ממספר ניסיונות האימות המותר. אנא בקש קוד חדש.');
    }

    // If code is correct (Implicitly, as we found it by token)
    // Increment attempts
    await prisma.verification.update({
      where: { id: verification.id },
      data: { 
        attempts: { increment: 1 },
        // DO NOT set to COMPLETED yet for PASSWORD_RESET.
        // Only set to COMPLETED after password has been updated in DB by the calling API.
        // For EMAIL verification, we can set to COMPLETED here.
        ...(type === VerificationType.EMAIL && { 
            status: VerificationStatus.COMPLETED,
            completedAt: new Date()
        })
      },
    });
    
    if (!verification.userId) {
        // This should not happen if the verification record was created correctly with a userId
        console.error(`VerificationService: userId missing on verification record ${verification.id} for type ${type} and target ${target}`);
        throw new Error('שגיאה פנימית: רשומת האימות אינה משויכת למשתמש.');
    }

    // For EMAIL verification type, update user status as well
    if (type === VerificationType.EMAIL && verification.userId) {
      const user = await prisma.user.findUnique({ where: {id: verification.userId }});
      if (user && !user.isVerified) { // Only update if not already verified
        await prisma.user.update({
          where: { id: verification.userId },
          data: {
            isVerified: true,
            // Only update status if it's PENDING_EMAIL_VERIFICATION
            ...(user.status === UserStatus.PENDING_EMAIL_VERIFICATION && {
                status: UserStatus.PENDING_PHONE_VERIFICATION, // Or ACTIVE if phone verification is not mandatory next
            }),
            updatedAt: new Date(),
          },
        });
      }
    }
    
    // For PASSWORD_RESET, the calling API (`/api/auth/reset-password`) will handle updating the password
    // and THEN it should explicitly mark the verification record as COMPLETED.
    // This function's role is just to validate the OTP itself.

    return {
      success: true,
      message: 'Code verified.',
      userId: verification.userId, // Return userId
      id: verification.id // Return verification record id
    };
  }

  // New method to explicitly complete a verification, e.g., after password reset
  static async completeVerification(verificationId: string): Promise<void> {
    await prisma.verification.update({
        where: { id: verificationId },
        data: {
            status: VerificationStatus.COMPLETED,
            completedAt: new Date(),
        },
    });
  }
}
--- End of Content for verificationService.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\utils
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\utils\serverStatusUtils.ts
--------------------------------------------------------------------------------
Content:
// src/lib/utils/serverStatusUtils.ts

import type { MatchSuggestionStatus } from "@prisma/client";

export interface ServerStatusInfo {
  requiresUserAction: boolean;
  currentParty: "first" | "second" | "matchmaker" | "both" | "none";
  isUrgent: boolean;
  priority: "low" | "medium" | "high" | "critical";
  category: "draft" | "pending" | "approved" | "declined" | "progress" | "completed";
}

/**
 * מחזיר מידע על סטטוס ההצעה מצד השרת
 */
export function getServerStatusInfo(
  status: MatchSuggestionStatus,
  firstPartyId: string,
  secondPartyId: string,
  currentUserId?: string
): ServerStatusInfo {
  const isFirstParty = currentUserId === firstPartyId;
  const isSecondParty = currentUserId === secondPartyId;
  
  const statusMap: Record<MatchSuggestionStatus, ServerStatusInfo> = {
    DRAFT: {
      requiresUserAction: false,
      currentParty: "matchmaker",
      isUrgent: false,
      priority: "medium",
      category: "draft"
    },
    
    PENDING_FIRST_PARTY: {
      requiresUserAction: isFirstParty,
      currentParty: "first",
      isUrgent: true,
      priority: isFirstParty ? "critical" : "medium",
      category: "pending"
    },
    
    FIRST_PARTY_APPROVED: {
      requiresUserAction: false,
      currentParty: "matchmaker",
      isUrgent: false,
      priority: "medium",
      category: "approved"
    },
    
    FIRST_PARTY_DECLINED: {
      requiresUserAction: false,
      currentParty: "none",
      isUrgent: false,
      priority: "low",
      category: "declined"
    },
    
    PENDING_SECOND_PARTY: {
      requiresUserAction: isSecondParty,
      currentParty: "second",
      isUrgent: true,
      priority: isSecondParty ? "critical" : "medium",
      category: "pending"
    },
    
    SECOND_PARTY_APPROVED: {
      requiresUserAction: false,
      currentParty: "matchmaker",
      isUrgent: true,
      priority: "high",
      category: "approved"
    },
    
    SECOND_PARTY_DECLINED: {
      requiresUserAction: false,
      currentParty: "none",
      isUrgent: false,
      priority: "low",
      category: "declined"
    },
    
    AWAITING_MATCHMAKER_APPROVAL: {
      requiresUserAction: false,
      currentParty: "matchmaker",
      isUrgent: true,
      priority: "high",
      category: "pending"
    },
    
    CONTACT_DETAILS_SHARED: {
      requiresUserAction: true,
      currentParty: "both",
      isUrgent: true,
      priority: "high",
      category: "progress"
    },
    
    AWAITING_FIRST_DATE_FEEDBACK: {
      requiresUserAction: true,
      currentParty: "both",
      isUrgent: false,
      priority: "medium",
      category: "pending"
    },
    
    THINKING_AFTER_DATE: {
      requiresUserAction: false,
      currentParty: "both",
      isUrgent: false,
      priority: "medium",
      category: "pending"
    },
    
    PROCEEDING_TO_SECOND_DATE: {
      requiresUserAction: true,
      currentParty: "both",
      isUrgent: false,
      priority: "medium",
      category: "progress"
    },
    
    ENDED_AFTER_FIRST_DATE: {
      requiresUserAction: false,
      currentParty: "none",
      isUrgent: false,
      priority: "low",
      category: "completed"
    },
    
    MEETING_PENDING: {
      requiresUserAction: false,
      currentParty: "matchmaker",
      isUrgent: true,
      priority: "high",
      category: "pending"
    },
    
    MEETING_SCHEDULED: {
      requiresUserAction: true,
      currentParty: "both",
      isUrgent: true,
      priority: "high",
      category: "progress"
    },
    
    MATCH_APPROVED: {
      requiresUserAction: false,
      currentParty: "both",
      isUrgent: false,
      priority: "high",
      category: "approved"
    },
    
    MATCH_DECLINED: {
      requiresUserAction: false,
      currentParty: "none",
      isUrgent: false,
      priority: "low",
      category: "declined"
    },
    
    DATING: {
      requiresUserAction: false,
      currentParty: "both",
      isUrgent: false,
      priority: "medium",
      category: "progress"
    },
    
    ENGAGED: {
      requiresUserAction: false,
      currentParty: "both",
      isUrgent: false,
      priority: "low",
      category: "completed"
    },
    
    MARRIED: {
      requiresUserAction: false,
      currentParty: "both",
      isUrgent: false,
      priority: "low",
      category: "completed"
    },
    
    EXPIRED: {
      requiresUserAction: false,
      currentParty: "none",
      isUrgent: false,
      priority: "low",
      category: "completed"
    },
    
    CLOSED: {
      requiresUserAction: false,
      currentParty: "none",
      isUrgent: false,
      priority: "low",
      category: "completed"
    },
    
    CANCELLED: {
      requiresUserAction: false,
      currentParty: "none",
      isUrgent: false,
      priority: "low",
      category: "completed"
    }
  };

  return statusMap[status];
}

/**
 * מחזיר רשימת הצעות שדורשות תשומת לב של המשתמש
 */
export function getUrgentSuggestions<T extends { 
  status: MatchSuggestionStatus; 
  firstPartyId: string; 
  secondPartyId: string;
  decisionDeadline?: Date | null;
}>(
  suggestions: T[],
  userId: string
): T[] {
  return suggestions.filter(suggestion => {
    const statusInfo = getServerStatusInfo(
      suggestion.status,
      suggestion.firstPartyId,
      suggestion.secondPartyId,
      userId
    );
    
    // בדיקה אם המשתמש צריך לפעול
    if (!statusInfo.requiresUserAction) return false;
    
    // בדיקה אם יש דדליין קרוב
    if (suggestion.decisionDeadline) {
      const deadline = new Date(suggestion.decisionDeadline);
      const now = new Date();
      const daysUntilDeadline = (deadline.getTime() - now.getTime()) / (1000 * 60 * 60 * 24);
      
      // אם יש פחות מ-3 ימים, זה דחוף
      if (daysUntilDeadline <= 3) return true;
    }
    
    return statusInfo.isUrgent;
  });
}

/**
 * מחזיר רשימת הצעות לפי קטגוריה
 */
export function getSuggestionsByCategory<T extends { 
  status: MatchSuggestionStatus; 
  firstPartyId: string; 
  secondPartyId: string;
}>(
  suggestions: T[],
  category: ServerStatusInfo['category'],
  userId?: string
): T[] {
  return suggestions.filter(suggestion => {
    const statusInfo = getServerStatusInfo(
      suggestion.status,
      suggestion.firstPartyId,
      suggestion.secondPartyId,
      userId
    );
    return statusInfo.category === category;
  });
}

/**
 * מחשב נתונים סטטיסטיים על הצעות המשתמש
 */
export function calculateUserStats<T extends { 
  status: MatchSuggestionStatus; 
  firstPartyId: string; 
  secondPartyId: string;
  decisionDeadline?: Date | null;
}>(
  suggestions: T[],
  userId: string
) {
  const urgent = getUrgentSuggestions(suggestions, userId);
  const pending = getSuggestionsByCategory(suggestions, 'pending', userId);
  const approved = getSuggestionsByCategory(suggestions, 'approved', userId);
  const progress = getSuggestionsByCategory(suggestions, 'progress', userId);
  const completed = getSuggestionsByCategory(suggestions, 'completed', userId);
  
  // ספירת הצעות שדורשות תשובה מהמשתמש ספציפית
  const requiresMyAction = suggestions.filter(suggestion => {
    const statusInfo = getServerStatusInfo(
      suggestion.status,
      suggestion.firstPartyId,
      suggestion.secondPartyId,
      userId
    );
    return statusInfo.requiresUserAction;
  });

  return {
    total: suggestions.length,
    urgent: urgent.length,
    pending: pending.length,
    approved: approved.length,
    progress: progress.length,
    completed: completed.length,
    requiresMyAction: requiresMyAction.length,
    categories: {
      urgent,
      pending,
      approved,
      progress,
      completed,
      requiresMyAction
    }
  };
}

/**
 * בודק אם משתמש נמצא בתהליך פעיל (מונע יצירת הצעות חדשות)
 */
export function isUserInActiveProcess<T extends { 
  status: MatchSuggestionStatus; 
  firstPartyId: string; 
  secondPartyId: string;
}>(
  suggestions: T[],
  userId: string
): boolean {
  const activeStatuses: MatchSuggestionStatus[] = [
    'FIRST_PARTY_APPROVED',
    'SECOND_PARTY_APPROVED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'DATING',
    'ENGAGED',
  ];

  return suggestions.some(suggestion => 
    (suggestion.firstPartyId === userId || suggestion.secondPartyId === userId) &&
    activeStatuses.includes(suggestion.status)
  );
}

/**
 * מחזיר הודעת סטטוס מותאמת למשתמש
 */
export function getPersonalizedStatusMessage(
  status: MatchSuggestionStatus,
  isFirstParty: boolean,
  targetPartyName?: string
): string {
  const messages: Record<MatchSuggestionStatus, { first: string; second: string }> = {
    PENDING_FIRST_PARTY: {
      first: "ההצעה מחכה להחלטתך - בדוק ותחליט",
      second: `ההצעה נשלחה לצד הראשון${targetPartyName ? ` (${targetPartyName})` : ''} - נעדכן אותך כשיגיע המשוב`
    },
    FIRST_PARTY_APPROVED: {
      first: "אישרת את ההצעה - עכשיו ההצעה תשלח לצד השני",
      second: `הצד הראשון${targetPartyName ? ` (${targetPartyName})` : ''} אישר את ההצעה! עכשיו התור שלך`
    },
    PENDING_SECOND_PARTY: {
      first: `ההצעה נשלחה לצד השני${targetPartyName ? ` (${targetPartyName})` : ''} - נעדכן אותך כשיגיע המשוב`,
      second: "ההצעה מחכה להחלטתך - בדוק ותחליט"
    },
    SECOND_PARTY_APPROVED: {
      first: `הצד השני${targetPartyName ? ` (${targetPartyName})` : ''} גם אישר! בקרוב תקבלו פרטי קשר`,
      second: "אישרת את ההצעה - בקרוב תקבלו פרטי קשר"
    },
    CONTACT_DETAILS_SHARED: {
      first: "פרטי הקשר שותפו - זמן ליצור קשר ולתאם פגישה!",
      second: "פרטי הקשר שותפו - זמן ליצור קשר ולתאם פגישה!"
    },
    DATING: {
      first: "אתם בתהליך היכרות - בהצלחה!",
      second: "אתם בתהליך היכרות - בהצלחה!"
    },
    ENGAGED: {
      first: "מזל טוב על האירוסין! 💍",
      second: "מזל טוב על האירוסין! 💍"
    },
    MARRIED: {
      first: "מזל טוב על החתונה! 🎉",
      second: "מזל טוב על החתונה! 🎉"
    },
    // Default cases for other statuses
    DRAFT: {
      first: "ההצעה בהכנה",
      second: "ההצעה בהכנה"
    },
    FIRST_PARTY_DECLINED: {
      first: "דחית את ההצעה",
      second: "הצד הראשון דחה את ההצעה"
    },
    SECOND_PARTY_DECLINED: {
      first: "הצד השני דחה את ההצעה",
      second: "דחית את ההצעה"
    },
    AWAITING_MATCHMAKER_APPROVAL: {
      first: "ממתין לאישור השדכן",
      second: "ממתין לאישור השדכן"
    },
    AWAITING_FIRST_DATE_FEEDBACK: {
      first: "ממתין למשוב פגישה",
      second: "ממתין למשוב פגישה"
    },
    THINKING_AFTER_DATE: {
      first: "בחשיבה לאחר הפגישה",
      second: "בחשיבה לאחר הפגישה"
    },
    PROCEEDING_TO_SECOND_DATE: {
      first: "ממשיכים לפגישה שנייה",
      second: "ממשיכים לפגישה שנייה"
    },
    ENDED_AFTER_FIRST_DATE: {
      first: "הסתיים לאחר פגישה ראשונה",
      second: "הסתיים לאחר פגישה ראשונה"
    },
    MEETING_PENDING: {
      first: "פגישה בהמתנה",
      second: "פגישה בהמתנה"
    },
    MEETING_SCHEDULED: {
      first: "פגישה קבועה",
      second: "פגישה קבועה"
    },
    MATCH_APPROVED: {
      first: "השידוך אושר",
      second: "השידוך אושר"
    },
    MATCH_DECLINED: {
      first: "השידוך נדחה",
      second: "השידוך נדחה"
    },
    EXPIRED: {
      first: "פג תוקף",
      second: "פג תוקף"
    },
    CLOSED: {
      first: "ההצעה נסגרה",
      second: "ההצעה נסגרה"
    },
    CANCELLED: {
      first: "ההצעה בוטלה",
      second: "ההצעה בוטלה"
    }
  };

  const defaultMessage = {
    first: "עקוב אחר התקדמות ההצעה בטיימליין",
    second: "עקוב אחר התקדמות ההצעה בטיימליין"
  };

  const statusMessages = messages[status] || defaultMessage;
  return isFirstParty ? statusMessages.first : statusMessages.second;
}
--- End of Content for serverStatusUtils.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\lib\utils\suggestionUtils.ts
--------------------------------------------------------------------------------
Content:
// src/lib/utils/suggestionUtils.ts

import type { MatchSuggestionStatus } from "@prisma/client";
import type { SuggestionsCardDict } from "@/types/dictionary";

export interface StatusWithPartyInfo {
  label: string;
  shortLabel: string;
  description: string;
  currentParty: "first" | "second" | "matchmaker" | "both" | "none";
  icon: React.ElementType;
  className: string;
  pulse: boolean;
  category: "pending" | "approved" | "declined" | "progress" | "completed";
}

export function getEnhancedStatusInfo(
  status: MatchSuggestionStatus,
  isFirstParty: boolean = false,
  dict: SuggestionsCardDict
): StatusWithPartyInfo {
  const statusMap: Record<MatchSuggestionStatus, StatusWithPartyInfo> = {
    DRAFT: {
      label: "טיוטה בהכנה",
      shortLabel: "טיוטה",
      description: dict.statusDescriptions.draft,
      currentParty: "matchmaker",
      icon: require("lucide-react").FileText,
      className: "bg-gradient-to-r from-gray-100 to-slate-100 text-gray-700 border-gray-200",
      pulse: false,
      category: "pending"
    },
    
    PENDING_FIRST_PARTY: {
      label: isFirstParty ? "ממתין לתשובתך" : "נשלח לצד הראשון",
      shortLabel: isFirstParty ? dict.statusIndicator.waitingForYou : dict.statusIndicator.firstParty,
      description: isFirstParty 
        ? dict.statusDescriptions.pendingFirstPartyUser
        : dict.statusDescriptions.pendingFirstPartyOther,
      currentParty: "first",
      icon: require("lucide-react").Clock,
      className: "bg-gradient-to-r from-purple-50 to-violet-50 text-purple-700 border-purple-200",
      pulse: true,
      category: "pending"
    },

    FIRST_PARTY_APPROVED: {
      label: isFirstParty ? "אישרת את ההצעה" : "הצד הראשון אישר",
      shortLabel: isFirstParty ? "אישרת" : `${dict.statusIndicator.firstParty} אישר`,
      description: isFirstParty
        ? dict.statusDescriptions.firstPartyApprovedUser
        : dict.statusDescriptions.firstPartyApprovedOther,
      currentParty: "matchmaker",
      icon: require("lucide-react").CheckCircle,
      className: "bg-gradient-to-r from-emerald-50 to-green-50 text-emerald-700 border-emerald-200",
      pulse: false,
      category: "approved"
    },

    FIRST_PARTY_DECLINED: {
      label: isFirstParty ? "דחית את ההצעה" : "הצד הראשון דחה",
      shortLabel: isFirstParty ? "דחית" : `${dict.statusIndicator.firstParty} דחה`,
      description: isFirstParty
        ? dict.statusDescriptions.firstPartyDeclinedUser
        : dict.statusDescriptions.firstPartyDeclinedOther,
      currentParty: "none",
      icon: require("lucide-react").XCircle,
      className: "bg-gradient-to-r from-red-50 to-rose-50 text-red-700 border-red-200",
      pulse: false,
      category: "declined"
    },

    PENDING_SECOND_PARTY: {
      label: isFirstParty ? "ההצעה נשלחה לצד השני" : "ממתין לתשובתך",
      shortLabel: isFirstParty ? dict.statusIndicator.secondParty : dict.statusIndicator.waitingForYou,
      description: isFirstParty
        ? dict.statusDescriptions.pendingSecondPartyUser
        : dict.statusDescriptions.pendingSecondPartyOther,
      currentParty: "second",
      icon: require("lucide-react").UserPlus,
      className: "bg-gradient-to-r from-blue-50 to-cyan-50 text-blue-700 border-blue-200",
      pulse: true,
      category: "pending"
    },

    SECOND_PARTY_APPROVED: {
      label: isFirstParty ? "הצד השני אישר!" : "אישרת את ההצעה!",
      shortLabel: isFirstParty ? `${dict.statusIndicator.secondParty} אישר` : "אישרת",
      description: isFirstParty
        ? dict.statusDescriptions.secondPartyApprovedUser
        : dict.statusDescriptions.secondPartyApprovedOther,
      currentParty: "matchmaker",
      icon: require("lucide-react").Heart,
      className: "bg-gradient-to-r from-emerald-50 to-green-50 text-emerald-700 border-emerald-200",
      pulse: true,
      category: "approved"
    },

    SECOND_PARTY_DECLINED: {
      label: isFirstParty ? "הצד השני דחה" : "דחית את ההצעה",
      shortLabel: isFirstParty ? `${dict.statusIndicator.secondParty} דחה` : "דחית",
      description: isFirstParty
        ? dict.statusDescriptions.secondPartyDeclinedUser
        : dict.statusDescriptions.secondPartyDeclinedOther,
      currentParty: "none",
      icon: require("lucide-react").XCircle,
      className: "bg-gradient-to-r from-red-50 to-rose-50 text-red-700 border-red-200",
      pulse: false,
      category: "declined"
    },

    AWAITING_MATCHMAKER_APPROVAL: {
      label: "ממתין לאישור השדכן",
      shortLabel: `אישור ${dict.statusIndicator.matchmaker}`,
      description: dict.statusDescriptions.awaitingMatchmakerApproval,
      currentParty: "matchmaker",
      icon: require("lucide-react").Handshake,
      className: "bg-gradient-to-r from-amber-50 to-orange-50 text-amber-700 border-amber-200",
      pulse: true,
      category: "pending"
    },

    CONTACT_DETAILS_SHARED: {
      label: "פרטי קשר שותפו",
      shortLabel: "פרטים שותפו",
      description: dict.statusDescriptions.contactDetailsShared,
      currentParty: "both",
      icon: require("lucide-react").Phone,
      className: "bg-gradient-to-r from-cyan-50 to-emerald-50 text-cyan-700 border-cyan-200",
      pulse: false,
      category: "progress"
    },

    AWAITING_FIRST_DATE_FEEDBACK: {
      label: "ממתין למשוב פגישה",
      shortLabel: "משוב פגישה",
      description: dict.statusDescriptions.awaitingFirstDateFeedback,
      currentParty: "both",
      icon: require("lucide-react").Calendar,
      className: "bg-gradient-to-r from-amber-50 to-orange-50 text-amber-700 border-amber-200",
      pulse: true,
      category: "pending"
    },

    THINKING_AFTER_DATE: {
      label: "בחשיבה לאחר הפגישה",
      shortLabel: "בחשיבה",
      description: dict.statusDescriptions.thinkingAfterDate,
      currentParty: "both",
      icon: require("lucide-react").Brain,
      className: "bg-gradient-to-r from-blue-50 to-cyan-50 text-blue-700 border-blue-200",
      pulse: false,
      category: "pending"
    },

    PROCEEDING_TO_SECOND_DATE: {
      label: "ממשיכים לפגישה שנייה",
      shortLabel: "פגישה שנייה",
      description: dict.statusDescriptions.proceedingToSecondDate,
      currentParty: "both",
      icon: require("lucide-react").ArrowRight,
      className: "bg-gradient-to-r from-green-50 to-emerald-50 text-green-700 border-green-200",
      pulse: false,
      category: "progress"
    },

    ENDED_AFTER_FIRST_DATE: {
      label: "הסתיים לאחר פגישה ראשונה",
      shortLabel: "הסתיים",
      description: dict.statusDescriptions.endedAfterFirstDate,
      currentParty: "none",
      icon: require("lucide-react").XCircle,
      className: "bg-gradient-to-r from-gray-50 to-slate-50 text-gray-700 border-gray-200",
      pulse: false,
      category: "completed"
    },

    MEETING_PENDING: {
      label: "פגישה בהמתנה",
      shortLabel: "פגישה ממתינה",
      description: dict.statusDescriptions.meetingPending,
      currentParty: "matchmaker",
      icon: require("lucide-react").Clock,
      className: "bg-gradient-to-r from-blue-50 to-cyan-50 text-blue-700 border-blue-200",
      pulse: true,
      category: "pending"
    },

    MEETING_SCHEDULED: {
      label: "פגישה קבועה",
      shortLabel: "פגישה קבועה",
      description: dict.statusDescriptions.meetingScheduled,
      currentParty: "both",
      icon: require("lucide-react").Calendar,
      className: "bg-gradient-to-r from-green-50 to-emerald-50 text-green-700 border-green-200",
      pulse: false,
      category: "progress"
    },

    MATCH_APPROVED: {
      label: "השידוך אושר",
      shortLabel: "אושר",
      description: dict.statusDescriptions.matchApproved,
      currentParty: "both",
      icon: require("lucide-react").CheckCircle,
      className: "bg-gradient-to-r from-green-50 to-emerald-50 text-green-700 border-green-200",
      pulse: false,
      category: "approved"
    },

    MATCH_DECLINED: {
      label: "השידוך נדחה",
      shortLabel: "נדחה",
      description: dict.statusDescriptions.matchDeclined,
      currentParty: "none",
      icon: require("lucide-react").XCircle,
      className: "bg-gradient-to-r from-red-50 to-rose-50 text-red-700 border-red-200",
      pulse: false,
      category: "declined"
    },

    DATING: {
      label: "בתהליך היכרות",
      shortLabel: "בהיכרות",
      description: dict.statusDescriptions.dating,
      currentParty: "both",
      icon: require("lucide-react").Heart,
      className: "bg-gradient-to-r from-pink-50 to-rose-50 text-pink-700 border-pink-200",
      pulse: false,
      category: "progress"
    },

    ENGAGED: {
      label: "אירוסין! 💍",
      shortLabel: "מאורסים",
      description: dict.statusDescriptions.engaged,
      currentParty: "both",
      icon: require("lucide-react").Star,
      className: "bg-gradient-to-r from-yellow-50 to-amber-50 text-yellow-700 border-yellow-200",
      pulse: true,
      category: "completed"
    },

    MARRIED: {
      label: "נישואין! 🎉",
      shortLabel: "נשואים",
      description: dict.statusDescriptions.married,
      currentParty: "both",
      icon: require("lucide-react").Gift,
      className: "bg-gradient-to-r from-rose-50 to-pink-50 text-rose-700 border-rose-200",
      pulse: true,
      category: "completed"
    },

    EXPIRED: {
      label: "פג תוקף",
      shortLabel: "פג תוקף",
      description: dict.statusDescriptions.expired,
      currentParty: "none",
      icon: require("lucide-react").AlertTriangle,
      className: "bg-gradient-to-r from-gray-50 to-slate-50 text-gray-700 border-gray-200",
      pulse: false,
      category: "completed"
    },

    CLOSED: {
      label: "ההצעה נסגרה",
      shortLabel: "נסגרה",
      description: dict.statusDescriptions.closed,
      currentParty: "none",
      icon: require("lucide-react").FileX,
      className: "bg-gradient-to-r from-slate-50 to-gray-50 text-slate-700 border-slate-200",
      pulse: false,
      category: "completed"
    },

    CANCELLED: {
      label: "ההצעה בוטלה",
      shortLabel: "בוטלה",
      description: dict.statusDescriptions.cancelled,
      currentParty: "none",
      icon: require("lucide-react").Ban,
      className: "bg-gradient-to-r from-gray-50 to-slate-50 text-gray-700 border-gray-200",
      pulse: false,
      category: "completed"
    }
  };

  return statusMap[status];
}

// Helper function to get party indicator
export function getPartyIndicator(
  status: MatchSuggestionStatus,
  isFirstParty: boolean,
  dict: SuggestionsCardDict
): {
  show: boolean;
  text: string;
  className: string;
} {
  const statusInfo = getEnhancedStatusInfo(status, isFirstParty, dict);
  
  switch (statusInfo.currentParty) {
    case "first":
      return {
        show: true,
        text: isFirstParty ? dict.statusIndicator.yourTurn : dict.statusIndicator.firstParty,
        className: "bg-purple-500 text-white"
      };
    case "second":
      return {
        show: true,
        text: isFirstParty ? dict.statusIndicator.secondParty : dict.statusIndicator.yourTurn,
        className: "bg-blue-500 text-white"
      };
    case "matchmaker":
      return {
        show: true,
        text: dict.statusIndicator.matchmaker,
        className: "bg-emerald-500 text-white"
      };
    case "both":
      return {
        show: true,
        text: dict.statusIndicator.bothParties,
        className: "bg-gradient-to-r from-purple-500 to-blue-500 text-white"
      };
    default:
      return {
        show: false,
        text: "",
        className: ""
      };
  }
}
--- End of Content for suggestionUtils.ts ---

