מבנה התיקייה:
src
  .dist
  app
    (authenticated)
      matches
        page.tsx
      matchmaker
        candidates
        clients
          ClientsPageContent.tsx
          page.tsx
        dashboard
          page.tsx
        inquiries
          page.tsx
        suggestions
          [id]
            page.tsx
          page.tsx
      messages
        page.tsx
      profile
        components
          dashboard
            UnifiedProfileDashboard.tsx
        page.tsx
      settings
        page.tsx
    api
      auth
        [...nextauth]
          route.ts
        complete-password-change
          route.ts
        initiate-password-change
          route.ts
        register
          route.ts
        resend-verification
          route.ts
        send-verification
          route.ts
        verify
          route.ts
      availability
        check
          route.ts
      matchmaker
        candidates
          invite
            route.ts
        clients
          route.ts
        dashbord
          ClientCard.tsx
        inquiries
          [id]
            respond
              route.ts
            route.ts
          route.ts
        suggestions
          [id]
            status
              route.ts
          route.ts
      preferences
        route.ts
        update
          route.ts
      profile
        [userId]
          name
            route.ts
          password
            complete
              route.ts
            initiate
              route.ts
          questionnaire
            route.ts
        availability
          route.ts
        images
          [imageId]
            route.ts
          route.ts
        questionnaire
          route.ts
        route.ts
        update
          route.ts
      questionnaire
        complete
          route.ts
        route.ts
        update
          route.ts
        world
          route.ts
      suggestions
        [id]
          delete
            route.ts
          inquiries
            route.ts
          status
            route.ts
        active
          route.ts
        directory_analysis.txt
        history
          route.ts
        route.ts
    auth
      complete-registration
        page.tsx
      error
        page.tsx
      register
        page.tsx
      signin
        page.tsx
      verify-email
        page.tsx
    components
      auth
        RegisterForm.tsx
        SignInForm.tsx
      matchmaker
        dashboard
          ClientCard.tsx
          MatchmakerDashboard.tsx
          SuggestionCard.tsx
        forms
          AddCandidateForm.tsx
          AddCandidateWizard.tsx
          NewSuggestionForm.tsx
        new
          CandidateCard
            Actions.tsx
            MinimalCard.tsx
            QuickView.tsx
          CandidatesManager
            CandidatesList.tsx
            CandidatesStats.tsx
            SplitView.tsx
            StatsCard.tsx
            index.tsx
          Filters
            ActiveFilters.tsx
            FilterPanel.tsx
            SavedFilters.tsx
            SearchBar.tsx
          NewSuggestionForm
            CandidateSelector.tsx
            MatchPreview.tsx
            SuggestionDetails.tsx
            index.tsx
            schema.ts
          constants
            filterOptions.ts
            matchingCriteria.ts
          dialogs
            ActionDialogs.tsx
          hooks
            filterUtils
            useCandidates.ts
            useFilterLogic.ts
            useMatchmaking.ts
            useStatistics.ts
          services
            email
              EmailService.ts
            suggestions
              StatusTransitionService.ts
              SuggestionService.ts
          shared
            LoadingStates.tsx
            Pagination.tsx
            StatusBadge.tsx
          types
            candidates.ts
            filters.ts
          utils
            matchingAlgorithm.ts
            statisticsCalculator.ts
        suggestions
          container
            MatchmakerDashboard.tsx
            SuggestionActionBar.tsx
            SuggestionsStats.tsx
          details
            SuggestionDetailsDialog.tsx
            SuggestionDetailsView.tsx
          directory_analysis.txt
          list
            ManagerSuggestionsList.tsx
            SuggestionCard.tsx
      messages
        AvailabilityRequestCard.tsx
        MessagesPage.tsx
      shared
        shared
          .dist
          profile
            ProfileCard.tsx
            constants.ts
            elements
              MinimalCard.tsx
              StatsCard.tsx
              VisibilityControl.tsx
            helpers.ts
            index.ts
            sections
              ExtendedProfileSection.tsx
              PhotosSection.tsx
              PreferencesSection.tsx
              ProfileSection.tsx
              QuestionnaireResponsesSection.tsx
            types
              profile.ts
              questionnaire.ts
            utils.ts
      suggestions
        MatchSuggestionsContainer.tsx
        cards
          MinimalSuggestionCard.tsx
          SuggestionQuickView.tsx
        dialogs
          AskMatchmakerDialog.tsx
        list
          SuggestionsList.tsx
    config
      fonts.ts
    contexts
      LanguageContext.tsx
      NotificationContext.tsx
    favicon.ico
    fonts
      GeistMonoVF.woff2
      GeistVF.woff2
    globals.css
    hooks
      useMatchmaker.ts
    layout.tsx
    lib
      auth.ts
      validation
        auth.ts
    metadata.ts
    page.tsx
    questionnaire
      complete
        page.tsx
      directory_analysis.txt
      page.tsx
      restore
        page.tsx
    types
      matchmaker.ts
      suggestions.ts
  code.py
  components
    AvailabilityStatus.tsx
    HomePage.tsx
    Providers.tsx
    UserSuggestions.tsx
    account-settings.tsx
    layout
      Navbar.tsx
    matchmaker
      AvailabilityCheckButton.tsx
      AvailabilityInquiryResponse.tsx
      InquiriesDashboard.tsx
    questionnaire
      MatchmakingQuestionnaire.tsx
      common
        AnswerInput.tsx
        InteractiveScale.tsx
        QuestionCard.tsx
        QuestionnaireCompletion.tsx
        WorldIntro.tsx
      layout
        NavigationBar.tsx
        ProgressTracker.tsx
        QuestionnaireLayout.tsx
        WorldsMap.tsx
      onboarding
        TrackSelection.tsx
        Welcome.tsx
      questions
        directory_analysis.txt
        partner
          partnerBasicQuestions.tsx
          partnerDepthQuestions.tsx
        personality
          personalityQuestionsPartOne.tsx
          personalityQuestionsPartTwo.tsx
        relationship
          relationshipBasicsQuestions.tsx
          relationshipDepthQuestions.tsx
        religion
          faithQuestions.tsx
          practicalReligionQuestions.tsx
        values
          valuesQuestionsPartOne.tsx
          valuesQuestionsPartTwo.tsx
      types
        types.ts
      utils.ts
      worlds
        PartnerWorld.tsx
        PersonalityWorld.tsx
        RelationshipWorld.tsx
        ReligionWorld.tsx
        ValuesWorld.tsx
      שאלות כלליות
        educationCareer.tsx
        familyBackground.tsx
        lifestyleQuestions.tsx
        partnerPreferences.tsx
        personalityQuestions.tsx
        socialRelations.tsx
        valueQuestions.tsx
    ui
      ProfileModal.tsx
      SimpleToast.tsx
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      checkbox.tsx
      collapsible.tsx
      command.tsx
      dialog.tsx
      dropdown-menu.tsx
      form
        form.tsx
      image-viewer.tsx
      input.tsx
      label.tsx
      loading-spinner.tsx
      multi-select.tsx
      popover.tsx
      progress-indicator.tsx
      progress.tsx
      radio-group.tsx
      resizable.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      skeleton.tsx
      slider.tsx
      split-pane.tsx
      stats-card.tsx
      steps.tsx
      switch.tsx
      tabs.tsx
      textarea.tsx
      timeline.tsx
      toast
        toast.d.ts
        toaster.tsx
        use-toast.ts
      tooltip.tsx
      virtual-grid.tsx
      visually-hidden.tsx
  hooks
    useInterval.ts
    useQuestionnaireSave.ts
  lib
    auth.ts
    db.ts
    email
      emailService.ts
      templates
        availability-check.hbs
        email-verification.hbs
        invitation.hbs
        share-contact-details.hbs
        suggestion.hbs
        welcome.hbs
    prisma.ts
    services
      availabilityService.ts
      questionnaireService.ts
      suggestionService.ts
      verificationService.ts
    tokens.ts
    utils.ts
  middleware.ts
  services
    storageService.ts
    suggestions.ts
  types
    availability.ts
    cloudinary.d.ts
    meetings.ts
    messages.ts
    next-auth.d.ts
    profile-extended.ts
    profile.ts
    suggestions.ts

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\code.py:
==================================================
import os 
from datetime import datetime

# הגדרת הנתיב הקבוע
FIXED_DIRECTORY_PATH = r"C:\Users\eytan\Desktop\שידוכים\shidduch-system\src"

def scan_directory(directory_path):
    """
    Scan a directory and save its structure and file contents to a report file
    
    Args:
        directory_path (str): Path to the directory to scan
    """
    try:
        # Create output file name with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = os.path.join(directory_path, f"directory_scan_{timestamp}.txt")
        
        with open(output_file, 'w', encoding='utf-8') as report:
            # Write directory structure
            report.write("=== Directory Structure ===\n\n")
            for root, dirs, files in os.walk(directory_path):
                # Calculate the current level for indentation
                level = root.replace(directory_path, '').count(os.sep)
                indent = '  ' * level
                
                # Write current directory
                folder_name = os.path.basename(root) or os.path.basename(directory_path)
                report.write(f"{indent}[{folder_name}]\n")
                
                # Write files in current directory
                sub_indent = '  ' * (level + 1)
                for file in files:
                    report.write(f"{sub_indent}{file}\n")
            
            # Write contents of each file
            report.write("\n=== File Contents ===\n")
            for root, dirs, files in os.walk(directory_path):
                for file in files:
                    # Skip the report file itself if it shows up
                    if file == os.path.basename(output_file):
                        continue
                        
                    file_path = os.path.join(root, file)
                    report.write(f"\n--- Content of {file_path} ---\n")
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            report.write(content + "\n")
                    except Exception as e:
                        report.write(f"Could not read file: {str(e)}\n")
        
        print(f"Scan complete! Results saved to: {output_file}")
                    
    except Exception as e:
        print(f"Error during scanning: {str(e)}")

def main():
    if os.path.isdir(FIXED_DIRECTORY_PATH):
        scan_directory(FIXED_DIRECTORY_PATH)
    else:
        print(f"Error: The directory {FIXED_DIRECTORY_PATH} does not exist.")

if __name__ == "__main__":
    main()

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\middleware.ts:
==================================================
import { withAuth } from "next-auth/middleware";
import { NextResponse } from "next/server";

// הגדרת הנתיבים הציבוריים שלא דורשים אימות
const publicPaths = [
  '/auth/signin',
  '/auth/register',
  '/auth/verify-email',
  '/auth/verify',
  '/auth/complete-registration',
  '/api/auth/complete-registration',
  '/availability-response',
  '/api/matchmaker/inquiries'
];

export default withAuth(
  function middleware(req) {
    const token = req.nextauth.token;
    const path = req.nextUrl.pathname;
    
    // בדיקה אם הנתיב הוא ציבורי
    if (publicPaths.some(publicPath => path.startsWith(publicPath))) {
      return NextResponse.next();
    }

    // בדיקת סטטוס משתמש
    if (token?.status === "PENDING") {
      // אם המשתמש לא מאומת ומנסה לגשת לדף מוגן
      if (!path.startsWith("/verify-email")) {
        const email = token.email as string;
        return NextResponse.redirect(
          new URL(`/auth/verify-email?email=${encodeURIComponent(email)}`, req.url)
        );
      }
    }

    return NextResponse.next();
  },
  {
    callbacks: {
      authorized: ({ token, req }) => {
        const path = req.nextUrl.pathname;
        
        // מאפשר גישה לנתיבים ציבוריים
        if (publicPaths.some(publicPath => path.startsWith(publicPath))) {
          return true;
        }
        
        return !!token;
      },
    },
  }
);

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/matches/:path*',
    '/preferences/:path*',
    '/profile/:path*',
    '/matchmaker/:path*',
    '/api/matchmaker/:path*',
    '/api/profile/:path*',
    '/api/preferences/:path*',
    '/api/auth/verify',
    '/auth/complete-registration',
    '/api/auth/complete-registration',
    '/availability-response',
    '/api/matchmaker/inquiries/:path*',

  ]
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\favicon.ico:
==================================================
Error reading file C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\favicon.ico: 'utf-8' codec can't decode byte 0x96 in position 50: invalid start byte

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\globals.css:
==================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {

  /* Direction utilities */
  .dir-rtl {
    direction: rtl;
  }

  .dir-ltr {
    direction: ltr;
  }

  /* Force direction when needed */
  .force-ltr {
    direction: ltr !important;
  }

  .force-rtl {
    direction: rtl !important;
  }

  /* UI Component Direction Fixes */
  [data-radix-popper-content-wrapper] {
    direction: ltr;
  }

  /* Button icon margins for RTL/LTR */
  .dir-rtl .button-icon {
    margin-left: 0.5rem;
    margin-right: 0;
  }

  .dir-ltr .button-icon {
    margin-right: 0.5rem;
    margin-left: 0;
  }

  /* Input and form control adjustments */
  .dir-rtl .input-addon {
    border-right: none;
    border-left: 1px solid var(--border);
  }

  .dir-ltr .input-addon {
    border-left: none;
    border-right: 1px solid var(--border);
  }
}

/* Animation classes */
.form-step-enter {
  opacity: 0;
  transform: translateX(var(--enter-translate, 100%));
}

.form-step-enter-active {
  opacity: 1;
  transform: translateX(0%);
  transition: opacity 300ms, transform 300ms;
}

.form-step-exit {
  opacity: 1;
  transform: translateX(0%);
}

.form-step-exit-active {
  opacity: 0;
  transform: translateX(var(--exit-translate, -100%));
  transition: opacity 300ms, transform 300ms;
}

/* RTL animation adjustments */
.dir-rtl .form-step-enter {
  --enter-translate: -100%;
}

.dir-rtl .form-step-exit-active {
  --exit-translate: 100%;
}

/* Wizard layout */
.wizard-content {
  min-height: 400px;
  position: relative;
  overflow: hidden;
}

/* RTL specific layout adjustments */
.dir-rtl .wizard-navigation {
  margin-left: 0;
  margin-right: auto;
}

.dir-rtl .wizard-controls {
  flex-direction: row-reverse;
}

/* Custom scrollbar for RTL/LTR */
.dir-rtl .custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: var(--primary) transparent;
}

.dir-rtl .custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.dir-rtl .custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.dir-rtl .custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: var(--primary);
  border-radius: 3px;
}

/* Dropdown menu positioning */
.dir-rtl .dropdown-menu {
  transform-origin: top right;
}

.dir-ltr .dropdown-menu {
  transform-origin: top left;
}

/* Toast notifications positioning */
.dir-rtl .toast {
  right: auto;
  left: 1rem;
}

.dir-ltr .toast {
  left: auto;
  right: 1rem;
}

.rtl-tabs [role="tablist"] {
  direction: rtl;
}

.rtl-tabs [role="tabpanel"] {
  direction: rtl;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\layout.tsx:
==================================================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import dynamic from "next/dynamic";
import { cookies } from "next/headers";
import "./globals.css";
import { metadata as siteMetadata } from "./metadata";

interface ProvidersProps {
  children: React.ReactNode;
}

type NavbarProps = Record<string, never>;

interface LanguageProviderProps {
  children: React.ReactNode;
}

const Providers = dynamic<ProvidersProps>(() =>
  import("@/components/Providers").then((mod) => mod.default)
);

const Navbar = dynamic<NavbarProps>(() =>
  import("@/components/layout/Navbar").then((mod) => mod.default)
);

const LanguageProvider = dynamic<LanguageProviderProps>(() =>
  import("@/app/contexts/LanguageContext").then((mod) => mod.LanguageProvider)
);

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
  display: "swap",
});

export const metadata = siteMetadata;

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const cookieStore = await cookies();
  const defaultLanguage = cookieStore.get("language")?.value || "he";

  return (
    <html lang={defaultLanguage} dir={defaultLanguage === "he" ? "rtl" : "ltr"}>
      <body className={`${inter.variable} antialiased`}>
        <Providers>
          <LanguageProvider>
            <div className="min-h-screen flex flex-col">
              <Navbar />
              <main className="flex-1">{children}</main>
            </div>
          </LanguageProvider>
        </Providers>
      </body>
    </html>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\metadata.ts:
==================================================
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "מערכת שידוכים",
  description: "מערכת שידוכים המיועדת לציבור הדתי והחרדי",
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\page.tsx:
==================================================
import HomePage from "@/components/HomePage";

export default function Page() {
  return <HomePage />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matches\page.tsx:
==================================================
"use client";
import { useSession } from "next-auth/react";
import MatchSuggestionsContainer from "@/app/components/suggestions/MatchSuggestionsContainer";
import { Skeleton } from "@/components/ui/skeleton";

export default function MatchesPage() {
  const { data: session, status } = useSession();

  if (status === "loading") {
    return (
      <div className="container mx-auto p-6 space-y-4">
        <Skeleton className="h-48 w-full" />
        <Skeleton className="h-48 w-full" />
      </div>
    );
  }

  if (!session?.user?.id) {
    return <div>לא מורשה לצפות בדף זה</div>;
  }

  return <MatchSuggestionsContainer userId={session.user.id} />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\clients\ClientsPageContent.tsx:
==================================================
"use client";

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useNotifications } from "@/app/contexts/NotificationContext";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Label } from "@/components/ui/label";
import { Search, Filter, Users, Plus, Mail } from "lucide-react";
import AddCandidateWizard from "@/app/components/matchmaker/forms/AddCandidateWizard";
import type { Client, ClientStatus } from "@/app/types/matchmaker";
import ClientCard from "@/app/components/matchmaker/dashboard/ClientCard";
import AddCandidateForm from "@/app/components/matchmaker/forms/AddCandidateForm";
import NewSuggestionForm from "@/app/components/matchmaker/forms/NewSuggestionForm";
import {
  AvailabilityStatus,
  Gender,
  UserStatus,
  InvitationStatus,
} from "@prisma/client";
import type { ExtendedClient } from "@/app/types/matchmaker";
// עדכון הממשק ExtendedClient בתחילת הקובץ
import { useInterval } from "@/hooks/useInterval";

export default function ClientsPageContent() {
  const { data: session, status } = useSession();
  const { refreshNotifications } = useNotifications();
  const [clients, setClients] = useState<ExtendedClient[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [showAddCandidateDialog, setShowAddCandidateDialog] = useState(false);
  const [showNewSuggestionDialog, setShowNewSuggestionDialog] = useState(false);
  const [selectedClient, setSelectedClient] = useState<ExtendedClient | null>(
    null
  );
  const [showSendInviteDialog, setShowSendInviteDialog] = useState(false);
  const [inviteEmail, setInviteEmail] = useState("");
  const [clientToInvite, setClientToInvite] = useState<ExtendedClient | null>(
    null
  );

  const [filters, setFilters] = useState({
    gender: "all" as "all" | Gender,
    religiousLevel: "all",
    status: "all" as "all" | ClientStatus,
    hasInvitation: "all" as "all" | "sent" | "pending" | "accepted",
    ageRange: { min: 18, max: 99 },
    availability: "all" as "all" | AvailabilityStatus, // סינון לפי זמינות כללית
    immediateAvailability: "all" as
      | "all"
      | "available"
      | "unavailable"
      | "pending", // סינון לפי זמינות מיידית
  });

  const [showFilters, setShowFilters] = useState(false);
  useEffect(() => {
    if (session?.user) {
      loadClients();
    }
  }, [session]);

  // Helper function to calculate age
  const calculateAge = (birthDate: string) => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birth.getDate())
    ) {
      age--;
    }
    return age;
  };
  const handleCheckAvailability = async (client: ExtendedClient) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ clientId: client.id }),
      });

      if (!response.ok) {
        throw new Error("Failed to check availability");
      }

      await loadClients();
      await refreshNotifications();
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Failed to check availability"
      );
    }
  };
  const loadClients = async () => {
    try {
      setLoading(true);
      setError("");

      if (status === "loading" || !session) {
        return;
      }

      const response = await fetch("/api/matchmaker/clients");
      if (!response.ok) {
        throw new Error(await response.text());
      }
      const data = await response.json();

      const formattedClients = data.clients.map((client: any) => ({
        id: client.id,
        firstName: client.firstName,
        lastName: client.lastName,
        email: client.email,
        gender: client.gender,
        birthDate: client.birthDate,
        status: client.status,
        personalInfo: client.personalInfo || {},
        location: client.location || "",
        lastActive: client.lastActive || new Date().toISOString(),
        contactPreferences: client.contactPreferences || [],
        invitation: client.invitation,
        latestInquiry: client.latestInquiry || null, // הוספת השדה החדש
        profile: client.profile,
      }));

      setClients(formattedClients);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load clients");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadClients();
  }, [session, status]);

  const handleSendInvite = async () => {
    if (!clientToInvite || !inviteEmail) {
      console.error("Missing required data:", { clientToInvite, inviteEmail });
      return;
    }

    try {
      console.log("Sending invitation with data:", {
        clientId: clientToInvite.id,
        email: inviteEmail,
        firstName: clientToInvite.firstName,
        lastName: clientToInvite.lastName,
        // Add all required fields
        gender: clientToInvite.gender,
        birthDate: clientToInvite.birthDate,
        sendInvitation: true,
      });

      const response = await fetch("/api/matchmaker/candidates/invite", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          clientId: clientToInvite.id,
          email: inviteEmail,
          firstName: clientToInvite.firstName,
          lastName: clientToInvite.lastName,
          gender: clientToInvite.gender,
          birthDate: clientToInvite.birthDate,
          sendInvitation: true,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send invitation");
      }

      const data = await response.json();
      console.log("Invitation sent successfully:", data);

      // Clear form and close dialog
      setShowSendInviteDialog(false);
      setClientToInvite(null);
      setInviteEmail("");

      // Optional: Refresh the clients list
      await loadClients();
      await refreshNotifications();
    } catch (error) {
      console.error("Error sending invitation:", error);
      setError(
        error instanceof Error ? error.message : "Failed to send invitation"
      );
    }
  };

  const handleCreateSuggestion = (client: ExtendedClient) => {
    setSelectedClient(client);
    setShowNewSuggestionDialog(true);
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">טוען...</div>
      </div>
    );
  }

  if (error) {
    return (
      <Card className="m-4">
        <CardHeader>
          <CardTitle className="text-red-500">שגיאה</CardTitle>
        </CardHeader>
        <CardContent>
          <p>{error}</p>
          <Button className="mt-4" onClick={() => window.location.reload()}>
            נסה שוב
          </Button>
        </CardContent>
      </Card>
    );
  }

  const filteredClients = clients.filter((client) => {
    // Text search
    if (
      searchQuery &&
      !`${client.firstName} ${client.lastName} ${
        client.personalInfo?.occupation || ""
      } ${client.location}`.includes(searchQuery)
    )
      return false;
    // הוספת סינון לפי זמינות כללית
    if (
      filters.availability !== "all" &&
      client.profile?.availabilityStatus !== filters.availability
    ) {
      return false;
    }

    // הוספת סינון לפי זמינות מיידית
    if (filters.immediateAvailability !== "all") {
      const latestInquiry = client.latestInquiry;
      if (!latestInquiry) return filters.immediateAvailability === "pending";

      if (
        filters.immediateAvailability === "available" &&
        !latestInquiry.firstPartyResponse
      )
        return false;
      if (
        filters.immediateAvailability === "unavailable" &&
        latestInquiry.firstPartyResponse
      )
        return false;
    }

    return true;

    // Gender filter
    if (filters.gender !== "all" && client.gender !== filters.gender)
      return false;

    // Religious level filter
    if (
      filters.religiousLevel !== "all" &&
      client.personalInfo?.religiousLevel !== filters.religiousLevel
    )
      return false;

    // Status filter
    if (filters.status !== "all" && client.status !== filters.status)
      return false;

    // Invitation status filter
    if (filters.hasInvitation !== "all") {
      if (filters.hasInvitation === "sent" && !client.invitation) return false;
      if (
        filters.hasInvitation === "pending" &&
        client.invitation?.status !== "PENDING"
      )
        return false;
      if (
        filters.hasInvitation === "accepted" &&
        client.invitation?.status !== "ACCEPTED"
      )
        return false;
    }

    // Age filter
    const age = calculateAge(client.birthDate);
    if (age < filters.ageRange.min || age > filters.ageRange.max) return false;

    return true;
  });

  return (
    <div className="container mx-auto py-8 px-4">
      <div className="mb-8">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">ניהול מועמדים</h1>
          <Button
            className="bg-green-600 hover:bg-green-700"
            onClick={() => setShowAddCandidateDialog(true)}
          >
            <Plus className="ml-2 h-4 w-4" />
            הוספת מועמד
          </Button>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">{clients.length}</div>
              <div className="text-gray-500">סה"כ מועמדים</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {clients.filter((c) => c.status === "ACTIVE").length}
              </div>
              <div className="text-gray-500">מועמדים פעילים</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {
                  clients.filter((c) => c.invitation?.status === "PENDING")
                    .length
                }
              </div>
              <div className="text-gray-500">הזמנות ממתינות</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {
                  clients.filter((c) => c.invitation?.status === "ACCEPTED")
                    .length
                }
              </div>
              <div className="text-gray-500">הזמנות שאושרו</div>
            </CardContent>
          </Card>
        </div>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <CardTitle>סינון מועמדים</CardTitle>
            <Button
              variant="outline"
              onClick={() => setShowFilters(!showFilters)}
            >
              <Filter className="ml-2 h-4 w-4" />
              {showFilters ? "הסתר סינון" : "הצג סינון"}
            </Button>
          </CardHeader>
          <CardContent>
            <div className="flex gap-4 mb-4">
              <div className="flex-1">
                <Command>
                  <CommandInput
                    placeholder="חיפוש מועמדים..."
                    value={searchQuery}
                    onValueChange={setSearchQuery}
                  />
                  <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                  <CommandGroup>
                    {clients.map((client) => (
                      <CommandItem
                        key={client.id}
                        value={`${client.firstName} ${client.lastName}`}
                        onSelect={(value) => setSearchQuery(value)}
                      >
                        {client.firstName} {client.lastName}
                      </CommandItem>
                    ))}
                  </CommandGroup>
                </Command>
              </div>
            </div>

            {showFilters && (
              <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                  <Select
                    value={filters.gender}
                    onValueChange={(value: typeof filters.gender) =>
                      setFilters((prev) => ({ ...prev, gender: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="מגדר" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="MALE">זכר</SelectItem>
                      <SelectItem value="FEMALE">נקבה</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Select
                    value={filters.religiousLevel}
                    onValueChange={(value) =>
                      setFilters((prev) => ({ ...prev, religiousLevel: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="רמת דתיות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="charedi">חרדי</SelectItem>
                      <SelectItem value="dati">דתי</SelectItem>
                      <SelectItem value="masorti">מסורתי</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Select
                    value={filters.status}
                    onValueChange={(value: typeof filters.status) =>
                      setFilters((prev) => ({ ...prev, status: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="סטטוס" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="ACTIVE">פעיל</SelectItem>
                      <SelectItem value="PAUSED">מושהה</SelectItem>
                      <SelectItem value="INACTIVE">לא פעיל</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Select
                    value={filters.hasInvitation}
                    onValueChange={(value: typeof filters.hasInvitation) =>
                      setFilters((prev) => ({ ...prev, hasInvitation: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="סטטוס הזמנה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="sent">נשלחה הזמנה</SelectItem>
                      <SelectItem value="pending">ממתין לאישור</SelectItem>
                      <SelectItem value="accepted">אושר</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredClients.map((client: ExtendedClient) => (
          <ClientCard
            key={client.id}
            client={client}
            onSendInvite={() => {
              setClientToInvite(client);
              setShowSendInviteDialog(true);
            }}
            onSuggest={() => handleCreateSuggestion(client)}
            onCheckAvailability={handleCheckAvailability} // להוסיף שורה זו
          />
        ))}
      </div>

      {filteredClients.length === 0 && (
        <div className="text-center py-12 text-gray-500">
          <Users className="mx-auto h-12 w-12 mb-4" />
          <h3 className="text-lg font-medium">לא נמצאו מועמדים</h3>
          <p>נסה לשנות את הסינון או לחפש משהו אחר</p>
        </div>
      )}

      {showAddCandidateDialog && (
        <AddCandidateWizard
          isOpen={showAddCandidateDialog}
          onClose={() => setShowAddCandidateDialog(false)}
          onSuccess={() => {
            setShowAddCandidateDialog(false);
            loadClients();
          }}
        />
      )}
      <AlertDialog
        open={showSendInviteDialog}
        onOpenChange={setShowSendInviteDialog}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>שליחת הזמנה למועמד</AlertDialogTitle>
            <AlertDialogDescription>
              {clientToInvite && (
                <span>
                  שליחת הזמנה ל: {clientToInvite.firstName}{" "}
                  {clientToInvite.lastName}
                </span>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <div className="py-4">
            <Label htmlFor="invite-email">כתובת אימייל</Label>
            <Input
              id="invite-email"
              type="email"
              value={inviteEmail}
              onChange={(e) => setInviteEmail(e.target.value)}
              placeholder="הזן כתובת אימייל"
              className="mt-2"
            />
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel
              onClick={() => {
                setShowSendInviteDialog(false);
                setClientToInvite(null);
                setInviteEmail("");
              }}
            >
              ביטול
            </AlertDialogCancel>
            <AlertDialogAction onClick={handleSendInvite}>
              <Mail className="ml-2 h-4 w-4" />
              שלח הזמנה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
      {/* Dialog for new suggestion */}
      <Dialog
        open={showNewSuggestionDialog}
        onOpenChange={setShowNewSuggestionDialog}
      >
        <DialogContent className="sm:max-w-[800px]">
          <DialogHeader>
            <DialogTitle>הצעת שידוך חדשה</DialogTitle>
          </DialogHeader>
          <NewSuggestionForm
            isOpen={showNewSuggestionDialog}
            onClose={() => {
              setShowNewSuggestionDialog(false);
              setSelectedClient(null);
            }}
            selectedClient={selectedClient}
            onSubmit={async (data) => {
              try {
                // כאן נוסיף את הלוגיקה של שליחת ההצעה לשרת
                // למשל:
                // await createSuggestion(data);
                setShowNewSuggestionDialog(false);
                setSelectedClient(null);
              } catch (error) {
                console.error("Error creating suggestion:", error);
              }
            }}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\clients\page.tsx:
==================================================
import CandidatesManager from "@/app/components/matchmaker/new/CandidatesManager/index";

export default function ClientsPage() {
  return <CandidatesManager />;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\dashboard\page.tsx:
==================================================
"use client";

import { MatchmakerDashboard } from "@/app/components/matchmaker/dashboard/MatchmakerDashboard";

export default function DashboardPage() {
  return <MatchmakerDashboard />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\inquiries\page.tsx:
==================================================
// src/app/(authenticated)/matchmaker/inquiries/page.tsx
"use client";

import InquiriesDashboard from "@/app/components/matchmaker/InquiriesDashboard";

export default function InquiriesPage() {
  return <InquiriesDashboard />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\suggestions\page.tsx:
==================================================
"use client";

import { Suspense } from "react";
import MatchmakerDashboard from "@/app/components/matchmaker/suggestions/container/MatchmakerDashboard";
import { Card, CardContent } from "@/components/ui/card";

export default function SuggestionsPage() {
  return (
    <div className="min-h-screen bg-background">
      <Suspense
        fallback={
          <Card className="m-4">
            <CardContent className="p-6">
              <div className="flex justify-center items-center">
                <div className="text-xl">טוען...</div>
              </div>
            </CardContent>
          </Card>
        }
      >
        <MatchmakerDashboard />
      </Suspense>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\suggestions\[id]\page.tsx:
==================================================
// src/app/(authenticated)/matchmaker/suggestions/[id]/page.tsx
"use client";

import { useParams } from "next/navigation";
import { Suspense } from "react";
import SuggestionManagement from "@/app/components/matchmaker/suggestions/SuggestionManagement";
import { Card, CardContent } from "@/components/ui/card";

export default function SuggestionDetailsPage() {
  const params = useParams();
  const suggestionId = params.id as string;

  if (!suggestionId) {
    return (
      <Card className="m-4">
        <CardContent className="p-6">
          <div className="text-red-500">מזהה הצעה חסר</div>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <Suspense
        fallback={
          <Card className="m-4">
            <CardContent className="p-6">
              <div className="flex justify-center items-center">
                <div className="text-xl">טוען...</div>
              </div>
            </CardContent>
          </Card>
        }
      >
        <SuggestionManagement suggestionId={suggestionId} />
      </Suspense>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\messages\page.tsx:
==================================================
"use client";

import MessagesPage from "@/app/components/messages/MessagesPage";
import { Card } from "@/components/ui/card";
import { Loader2 } from "lucide-react";
import { Suspense } from "react";

export default function Messages() {
  return (
    <Suspense
      fallback={
        <Card className="m-4">
          <div className="flex justify-center items-center p-8">
            <Loader2 className="h-8 w-8 animate-spin" />
          </div>
        </Card>
      }
    >
      <MessagesPage />
    </Suspense>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\profile\page.tsx:
==================================================
// src/app/(authenticated)/profile/page.tsx
"use client";

import React from "react";
import { useLanguage } from "@/app/contexts/LanguageContext";
import UnifiedProfileDashboard from "./components/dashboard/UnifiedProfileDashboard";

interface ProfilePageProps {
  viewOnly?: boolean;
  userId?: string;
}

const ProfilePage: React.FC<ProfilePageProps> = ({
  viewOnly = false,
  userId,
}) => {
  const { language } = useLanguage();

  return (
    // הוספת direction="rtl" לאלמנט השורש של הדף
    <div className="min-h-screen bg-background" dir="rtl">
      <UnifiedProfileDashboard viewOnly={viewOnly} userId={userId} />
    </div>
  );
};

export default ProfilePage;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\profile\components\dashboard\UnifiedProfileDashboard.tsx:
==================================================
import React, { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { Eye } from "lucide-react";
import { toast } from "sonner";

// UI Components
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

// Shared Profile Components
import {
  ProfileCard,
  PhotosSection,
  ExtendedProfileSection,
  PreferencesSection,
  ProfileSection,
  QuestionnaireResponsesSection,
  StatsCard,
} from "@/app/components/shared/shared/profile";

// Types
import type { UserProfile, UserImage, QuestionnaireResponse, FormattedAnswer } from "@/types/next-auth";

// Stats configuration
import { User, MapPin, Scroll, Clock } from "lucide-react";

const QUICK_STATS = [
  {
    key: "maritalStatus",
    title: "מצב משפחתי",
    icon: User,
    getValue: (profile: UserProfile) => profile.maritalStatus || "לא צוין",
  },
  {
    key: "location",
    title: "מיקום",
    icon: MapPin,
    getValue: (profile: UserProfile) => profile.city || "לא צוין",
  },
  {
    key: "religiousLevel",
    title: "רמת דתיות",
    icon: Scroll,
    getValue: (profile: UserProfile) => profile.religiousLevel || "לא צוין",
  },
  {
    key: "availability",
    title: "סטטוס פניות",
    icon: Clock,
    getValue: (profile: UserProfile) => profile.availabilityStatus || "לא צוין",
  },
];

interface UnifiedProfileDashboardProps {
  viewOnly?: boolean;
  userId?: string;
}

const UnifiedProfileDashboard: React.FC<UnifiedProfileDashboardProps> = ({
  viewOnly = false,
  userId,
}) => {
  // State
  const [profileData, setProfileData] = useState<UserProfile | null>(null);
  const [images, setImages] = useState<UserImage[]>([]);
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [activeTab, setActiveTab] = useState("overview");
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");
  const [isMatchmaker, setIsMatchmaker] = useState(false);
  const [previewOpen, setPreviewOpen] = useState(false);

  const { data: session, update: updateSession } = useSession();

  // Load initial data
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      try {
        // Load profile data
        const profileUrl = userId
          ? `/api/profile?userId=${userId}`
          : "/api/profile";
        const profileResponse = await fetch(profileUrl);
        const profileData = await profileResponse.json();

        if (profileData.success) {
          setProfileData(profileData.profile);
          setImages(profileData.images || []);
        }

        // Load questionnaire data
        const questionnaireUrl = userId
          ? `/api/profile/${userId}/questionnaire`
          : "/api/profile/questionnaire";
        const questionnaireResponse = await fetch(questionnaireUrl);
        const questionnaireData = await questionnaireResponse.json();

        if (
          questionnaireData.success &&
          questionnaireData.questionnaireResponse
        ) {
          setQuestionnaireResponse(questionnaireData.questionnaireResponse);
        }
      } catch (error) {
        console.error("Failed to load profile data:", error);
        toast.error("שגיאה בטעינת הנתונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [userId]);

  // Handlers
  const handleSave = async (formData: Partial<UserProfile>) => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/profile/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await response.json();
      if (data.success) {
        await updateSession();
        setProfileData((prev) => ({ ...prev, ...formData } as UserProfile));
        setIsEditing(false);
        toast.success("הפרופיל עודכן בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה בעדכון הפרופיל");
    } finally {
      setIsLoading(false);
    }
  };

  const handleImageUpload = async (file: File) => {
    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await fetch("/api/profile/images", {
        method: "POST",
        body: formData,
      });

      const data = await response.json();
      if (data.success) {
        setImages((prev) => [...prev, data.image]);
        await updateSession();
        toast.success("התמונה הועלתה בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה בהעלאת התמונה");
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    try {
      const response = await fetch(`/api/profile/images/${imageId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ imageId }),
      });

      const data = await response.json();
      if (data.success) {
        setImages(data.images);
        await updateSession();
        toast.success("התמונה הראשית עודכנה בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה בעדכון התמונה הראשית");
    }
  };

  const handleDeleteImage = async (imageId: string) => {
    try {
      const response = await fetch(`/api/profile/images/${imageId}`, {
        method: "DELETE",
      });

      const data = await response.json();
      if (data.success) {
        setImages((prev) => prev.filter((img) => img.id !== imageId));
        await updateSession();
        toast.success("התמונה נמחקה בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה במחיקת התמונה");
    }
  };

  const handleQuestionnaireUpdate = async (
    world: string,
    questionId: string,
    value: any
  ) => {
    try {
      const response = await fetch("/api/profile/questionnaire", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ worldKey: world, questionId, value }),
      });

      const data = await response.json();
      if (data.success) {
        setQuestionnaireResponse(data.data);
        toast.success("השאלון עודכן בהצלחה");
      }
    } catch (error) {
      console.error("Failed to update questionnaire:", error);
      toast.error("שגיאה בעדכון השאלון");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen" dir="rtl">
        <p className="text-lg text-muted-foreground">טוען...</p>
      </div>
    );
  }

  return (
    <div className="w-full max-w-7xl mx-auto py-8 px-4" dir="rtl">
      <div className="space-y-6">
        {error && (
          <Alert variant="destructive">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Quick Stats */}
        {profileData && (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            {QUICK_STATS.map((stat) => (
              <StatsCard
                key={stat.key}
                icon={stat.icon}
                title={stat.title}
                value={stat.getValue(profileData)}
              />
            ))}
          </div>
        )}

        {/* Preview Dialog */}
        <div className="flex justify-center my-6">
          <Dialog open={previewOpen} onOpenChange={setPreviewOpen}>
            <DialogTrigger asChild>
              <Button variant="outline" className="px-6 py-2 text-lg gap-2">
                <Eye className="w-5 h-5" />
                תצוגה מקדימה
              </Button>
            </DialogTrigger>
            <DialogContent
              className="w-[90vw] max-w-7xl max-h-[85vh] overflow-y-auto p-6"
              dir="rtl"
            >
              <DialogHeader>
                <DialogTitle>תצוגה מקדימה של הפרופיל</DialogTitle>
                <Select
                  value={isMatchmaker ? "matchmaker" : "candidate"}
                  onValueChange={(value) =>
                    setIsMatchmaker(value === "matchmaker")
                  }
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="candidate">תצוגת מועמד</SelectItem>
                    <SelectItem value="matchmaker">תצוגת שדכן</SelectItem>
                  </SelectContent>
                </Select>
              </DialogHeader>
              {profileData && (
                <ProfileCard
                  profile={profileData}
                  images={images}
                  questionnaire={questionnaireResponse}
                  viewMode={isMatchmaker ? "matchmaker" : "candidate"}
                />
              )}
            </DialogContent>
          </Dialog>
        </div>

        {/* Main Tabs */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="space-y-4"
        >
          <TabsList className="w-full justify-center gap-2" dir="rtl">
            <TabsTrigger value="overview">סקירה כללית</TabsTrigger>
            <TabsTrigger value="extended">פרופיל מורחב</TabsTrigger>
            <TabsTrigger value="photos">תמונות</TabsTrigger>
            <TabsTrigger value="preferences">העדפות</TabsTrigger>
            <TabsTrigger value="questionnaire">תשובות לשאלון</TabsTrigger>
          </TabsList>

          <div className="mt-6">
            <TabsContent value="overview">
              <ProfileSection
                profile={profileData}
                isEditing={isEditing}
                setIsEditing={setIsEditing}
                onSave={handleSave}
                viewOnly={viewOnly}
              />
            </TabsContent>

            <TabsContent value="extended">
              <ExtendedProfileSection
                profile={profileData}
                isEditing={isEditing}
                setIsEditing={setIsEditing}
                onSave={handleSave}
                viewOnly={viewOnly}
              />
            </TabsContent>

            <TabsContent value="photos">
              <PhotosSection
                images={images}
                isUploading={isLoading}
                disabled={viewOnly}
                onUpload={handleImageUpload}
                onSetMain={handleSetMainImage}
                onDelete={handleDeleteImage}
              />
            </TabsContent>

            <TabsContent value="preferences">
              <PreferencesSection
                profile={profileData}
                isEditing={isEditing}
                setIsEditing={setIsEditing}
                onChange={handleSave}
                viewOnly={viewOnly}
              />
            </TabsContent>

            <TabsContent value="questionnaire">
              {questionnaireResponse ? (
                <QuestionnaireResponsesSection
                  questionnaire={questionnaireResponse}
                  onUpdate={handleQuestionnaireUpdate}
                  isEditable={!viewOnly}
                  viewMode={isMatchmaker ? "matchmaker" : "candidate"}
                />
              ) : (
                <div className="text-center py-8 text-muted-foreground">
                  לא נמצאו תשובות לשאלון
                </div>
              )}
            </TabsContent>
          </div>
        </Tabs>
      </div>
    </div>
  );
};

export default UnifiedProfileDashboard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\settings\page.tsx:
==================================================
"use client";

import { useSession } from "next-auth/react";
import AccountSettings from "@/components/account-settings";

export default function SettingsPage() {
  const { data: session, status } = useSession();

  if (status === "loading") return <div>Loading...</div>;
  if (status === "unauthenticated") return <div>Access Denied</div>;
  if (!session?.user) return <div>Error: No user data</div>;

  const userData = {
    id: session.user.id,
    email: session.user.email,
    firstName: session.user.firstName,
    lastName: session.user.lastName,
    role: session.user.role,
    status: session.user.status,
    isVerified: session.user.isVerified,
    lastLogin: session.user.lastLogin,
    createdAt: session.user.createdAt,
  };

  return <AccountSettings user={userData} />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\complete-password-change\route.ts:
==================================================
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, VerificationStatus } from "@prisma/client";

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // מציאת הטוקן
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "קוד לא תקף או שפג תוקפו" },
        { status: 400 }
      );
    }

    const { hashedNewPassword } = verification.metadata as { hashedNewPassword: string };

    // עדכון הסיסמה והשלמת האימות
    await db.$transaction([
      // עדכון סיסמה
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // עדכון סטטוס האימות
      db.verification.update({
        where: { id: verification.id },
        data: { status: "COMPLETED" }
      })
    ]);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בהשלמת שינוי הסיסמה" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\initiate-password-change\route.ts:
==================================================
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { generateToken } from "@/lib/tokens";
import { emailService } from "@/lib/email/emailService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: Request) {
  try {
    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    // בדיקת סיסמה נוכחית
    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "סיסמה נוכחית שגויה" },
        { status: 400 }
      );
    }

    // הצפנת הסיסמה החדשה
    const hashedNewPassword = await hash(newPassword, 12);

    // ביטול אימותים קודמים
    await db.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING"
      },
      data: {
        status: "EXPIRED"
      }
    });

    const token = await generateToken();

    // יצירת רשומת אימות חדשה
    await db.verification.create({
      data: {
        token,
        userId: user.id,
        type: VerificationType.PASSWORD_RESET,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 שעות
        status: "PENDING",
        metadata: { hashedNewPassword }
      }
    });

    // שליחת מייל עם קוד האימות
    await emailService.sendPasswordReset(user.email, token);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בתהליך שינוי הסיסמה" },
      { status: 500 }
    );
  }
   }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\register\route.ts:
==================================================
import { NextResponse } from 'next/server';
import { PrismaClient, UserRole, Gender, UserStatus, Prisma, VerificationType } from '@prisma/client';
import { hash } from 'bcryptjs';
import { randomBytes } from 'crypto';
import { emailService } from '@/lib/email/emailService';

const prisma = new PrismaClient();

interface RegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  gender: Gender;
  birthDate: string;
  maritalStatus?: string;
  height?: number;
  occupation?: string;
  education?: string;
  invitationToken?: string;
  phone?: string;
}

function handleError(error: unknown): { message: string; status: number } {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002': return { message: 'משתמש עם פרטים אלה כבר קיים במערכת', status: 409 };
      case 'P2014': return { message: 'שגיאה בנתונים שהוזנו', status: 400 };
      default: return { message: 'שגיאה בשמירת הנתונים', status: 500 };
    }
  } 
  
  if (error instanceof Error) {
    return { message: error.message, status: 400 };
  }

  return { message: 'אירעה שגיאה בלתי צפויה', status: 500 };
}

export async function POST(req: Request) {
  console.log('Starting registration process...');
  
  try {
    const body: RegistrationData = await req.json();
    console.log('Registration data received:', {
      ...body,
      password: '[REDACTED]'
    });

    if (body.invitationToken) {
      const invitation = await prisma.invitation.findUnique({
        where: { token: body.invitationToken }
      });

      if (!invitation) throw new Error("קישור ההזמנה אינו תקין");
      if (invitation.expires < new Date()) throw new Error("קישור ההזמנה פג תוקף");
      if (invitation.status !== "PENDING") throw new Error("ההזמנה כבר נוצלה או בוטלה");
    }

    if (!body.email || !body.password || !body.firstName || !body.lastName || !body.gender || !body.birthDate) {
      throw new Error('חסרים פרטים חובה');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      throw new Error('כתובת אימייל לא תקינה');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      throw new Error('הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר');
    }

    const birthDateObj = new Date(body.birthDate);
    const age = Math.floor((new Date().getTime() - birthDateObj.getTime()) / 31557600000);
    if (age < 18) {
      throw new Error('גיל מינימלי להרשמה הוא 18');
    }

    const hashedPassword = await hash(body.password, 12);
    
    const result = await prisma.$transaction(async (tx) => {
      const user = await tx.user.create({
        data: {
          email: body.email,
          password: hashedPassword,
          firstName: body.firstName,
          lastName: body.lastName,
          role: UserRole.CANDIDATE,
          status: UserStatus.PENDING,
          isVerified: false,
          profile: {
            create: {
              gender: body.gender,
              birthDate: birthDateObj,
              maritalStatus: body.maritalStatus || null,
              height: body.height || null,
              occupation: body.occupation || null,
              education: body.education || null,
              isProfileVisible: true
            }
          }
        }
      });

      if (body.invitationToken) {
        await tx.invitation.update({
          where: { token: body.invitationToken },
          data: {
            status: "ACCEPTED",
            userId: user.id
          }
        });
      }

      const verification = await tx.verification.create({
        data: {
          userId: user.id,
          type: VerificationType.EMAIL,
          token: randomBytes(32).toString('hex'),
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
          status: 'PENDING',
          attempts: 0
        }
      });

      return { user, verification };
    });

    try {
      await emailService.sendWelcomeEmail({
        email: result.user.email,
        firstName: result.user.firstName,
        requiresVerification: true,
        dashboardUrl: '/profile',
        supportEmail: process.env.SUPPORT_EMAIL || 'support@example.com',
        privacyNote: true
      });

      await emailService.sendVerificationEmail({
        email: result.user.email,
        verificationLink: result.verification.token,
        firstName: result.user.firstName,
        expiresIn: '24 שעות'
      });
    } catch (emailError) {
      return NextResponse.json(
        {
          success: true,
          message: 'ההרשמה הושלמה בהצלחה, אך היתה בעיה בשליחת המייל. נא ליצור קשר עם התמיכה.',
          userId: result.user.id,
          requiresVerification: true
        },
        { status: 201 }
      );
    }

    return NextResponse.json(
      {
        success: true,
        message: 'ההרשמה הושלמה בהצלחה. נשלח אליך מייל לאימות החשבון',
        userId: result.user.id,
        requiresVerification: true
      },
      { status: 201 }
    );
    
  } catch (error) {
    const errorDetails = error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    } : { message: String(error) };

    console.error('Registration error:', errorDetails);
    
    const { message, status } = handleError(error);
    
    return NextResponse.json(
      { 
        success: false,
        error: message,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status }
    );
  } finally {
    await prisma.$disconnect();
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\resend-verification\route.ts:
==================================================
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { randomBytes } from "crypto";
import { emailService } from "@/lib/email/emailService";
import { VerificationType } from "@prisma/client";

export async function POST(req: Request) {
  try {
    const { email, type } = await req.json();

    if (!email || !type) {
      return NextResponse.json(
        { error: "חסרים פרטים נדרשים" },
        { status: 400 }
      );
    }

    // מציאת המשתמש
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { error: "לא נמצא משתמש עם כתובת האימייל הזו" },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { error: "המשתמש כבר מאומת" },
        { status: 400 }
      );
    }

    // יצירת טוקן אימות חדש
    const verification = await prisma.verification.create({
      data: {
        userId: user.id,
        type: type as VerificationType,
        token: randomBytes(32).toString('hex'),
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // תוקף ל-24 שעות
        status: 'PENDING',
        attempts: 0
      }
    });

    // שליחת מייל אימות חדש
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationLink: verification.token,
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({
      success: true,
      message: "מייל אימות חדש נשלח בהצלחה"
    });

  } catch (error) {
    console.error('Resend verification error:', error);
    const errorMessage = error instanceof Error ? error.message : "שגיאה בשליחת מייל האימות";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\send-verification\route.ts:
==================================================
export const runtime = 'nodejs';

import { NextResponse } from "next/server";
import { PrismaClient, VerificationType } from "@prisma/client";
import { generateToken } from "@/lib/tokens";
import { emailService } from "@/lib/email/emailService";

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { email } = await req.json();
    
    if (!email) {
      return NextResponse.json({ error: "אימייל הוא שדה חובה" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return NextResponse.json({ error: "משתמש לא נמצא" }, { status: 404 });
    }

    await prisma.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.EMAIL,
        status: "PENDING"
      },
      data: { status: "EXPIRED" }
    });

    const token = await generateToken();
    const verification = await prisma.verification.create({
      data: {
        token,
        userId: user.id,
        type: VerificationType.EMAIL,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
        status: "PENDING"
      }
    });

    await emailService.sendVerificationEmail({
      email: user.email,
      verificationLink: verification.token,
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({ success: true }, { status: 200 });

  } catch (error) {
    return NextResponse.json({ error: "שגיאה בשליחת קוד האימות" }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\verify\route.ts:
==================================================
import { NextResponse } from "next/server";
import { VerificationService } from "@/lib/services/verificationService";
import prisma from "@/lib/prisma";
import { UserStatus, VerificationType } from '@prisma/client';

export async function POST(req: Request) {
  try {
    const { token, type } = await req.json();

    // ולידציה של הקלט
    if (!token || !type) {
      return NextResponse.json(
        { error: "חסרים פרטים נדרשים" },
        { status: 400 }
      );
    }

    if (!Object.values(VerificationType).includes(type)) {
      return NextResponse.json(
        { error: "סוג אימות לא חוקי" },
        { status: 400 }
      );
    }

    // אימות הטוקן ועדכון סטטוס המשתמש
    const verification = await VerificationService.verifyToken(token, type);

    // עדכון סטטוס המשתמש ל-ACTIVE
    await prisma.user.update({
      where: { id: verification.userId },
      data: {
        status: UserStatus.ACTIVE,
        isVerified: true
      }
    });

    return NextResponse.json({
      success: true,
      message: "האימות הושלם בהצלחה",
      user: {
        id: verification.userId,
        isVerified: true,
        status: UserStatus.ACTIVE
      }
    });

  } catch (error) {
    console.error('Verification error:', error);
    const errorMessage = error instanceof Error ? error.message : "שגיאה באימות";
    return NextResponse.json({ error: errorMessage }, { status: 400 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\[...nextauth]\route.ts:
==================================================
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

console.log('NextAuth route initialization');
const handler = NextAuth(authOptions);
console.log('NextAuth handler created');

export { handler as GET, handler as POST };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\availability\check\route.ts:
==================================================
// src/app/api/availability/check/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { clientId } = await req.json();

    const result = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId: clientId,
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error("Error checking availability:", error);
    return NextResponse.json(
      { error: "Failed to check availability" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\candidates\invite\route.ts:
==================================================
// src/app/api/matchmaker/candidates/invite/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, InvitationStatus, UserStatus } from "@prisma/client";
import { emailService } from '@/lib/email/emailService';
import type { CustomSession } from "@/types/next-auth";
import crypto from 'crypto';

interface CreateCandidateData {
  firstName: string;
  lastName: string;
  email: string;
  gender: Gender;
  birthDate: string;
  personalInfo?: {
    height?: number;
    maritalStatus?: string;
    occupation?: string;
    education?: string;
    religiousLevel?: string;
    city?: string;
  };
  matchingNotes?: string;
}

export async function POST(req: Request) {
  try {
    // Session validation
    const session = await getServerSession(authOptions) as CustomSession | null;

    if (!session?.user?.id || session.user.role !== 'MATCHMAKER') {
      console.log('Unauthorized attempt:', { session });
      return NextResponse.json({ error: "Unauthorized - Matchmaker access only" }, { status: 401 });
    }

    // Parse and validate request data
    const data: CreateCandidateData = await req.json();
    console.log('Received data:', { ...data, password: '[REDACTED]' });

    // Validate required fields
    if (!data.firstName || !data.lastName || !data.gender || !data.birthDate) {
      console.log('Missing required fields:', { data });
      return NextResponse.json({ 
        error: "Missing required fields", 
        details: {
          firstName: !data.firstName,
          lastName: !data.lastName,
          gender: !data.gender,
          birthDate: !data.birthDate
        }
      }, { status: 400 });
    }

    // Email validation if provided
    if (data.email && !data.email.includes('@')) {
      return NextResponse.json({ error: "Invalid email format" }, { status: 400 });
    }

    // Check for existing user with same email
    if (data.email) {
      const existingUser = await prisma.user.findUnique({
        where: { email: data.email }
      });

      if (existingUser) {
        return NextResponse.json({ error: "Email already registered" }, { status: 400 });
      }
    }

    // Generate temporary email if not provided
    const userEmail = data.email || `pending_${crypto.randomUUID()}@pending.com`;

    // Generate invitation token
    const invitationToken = crypto.randomUUID();

    // Create metadata object
    const metadataObject = {
      firstName: data.firstName,
      lastName: data.lastName,
      gender: data.gender,
      birthDate: data.birthDate,
      personalInfo: data.personalInfo || {},
      matchingNotes: data.matchingNotes
    };

    // Start transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: userEmail,
          password: crypto.randomBytes(32).toString('hex'), // temporary password
          firstName: data.firstName,
          lastName: data.lastName,
          gender: data.gender,
          birthDate: new Date(data.birthDate),
          status: UserStatus.PENDING,
          isVerified: false
        }
      });

      // Create profile
      await tx.profile.create({
        data: {
          userId: user.id,
          height: data.personalInfo?.height || null,
          maritalStatus: data.personalInfo?.maritalStatus || null,
          occupation: data.personalInfo?.occupation || null,
          education: data.personalInfo?.education || null,
          religiousLevel: data.personalInfo?.religiousLevel || null,
          city: data.personalInfo?.city || null,
          isProfileVisible: true,
          allowDirectMessages: true
        }
      });

      // Create invitation
      const invitation = await tx.invitation.create({
        data: {
          matchmakerId: session.user.id,
          email: data.email || '',
          token: invitationToken,
          status: InvitationStatus.PENDING,
          expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
          metadata: metadataObject,
          userId: user.id // Link to the created user
        }
      });

      return { user, invitation };
    });

    // Send invitation email if email provided
    if (data.email) {
      try {
        await emailService.sendInvitation({
          email: data.email,
          invitationLink: invitationToken, // שולחים רק את הטוקן
          matchmakerName: `${session.user.firstName} ${session.user.lastName}`,
          expiresIn: '7 ימים'
        });
      } catch (emailError) {
        console.error('Failed to send invitation email:', emailError);
        // Continue with success response even if email fails
        return NextResponse.json({
          success: true,
          warning: "User created but failed to send invitation email",
          data: {
            user: {
              id: result.user.id,
              email: result.user.email,
              firstName: result.user.firstName,
              lastName: result.user.lastName
            },
            invitation: {
              id: result.invitation.id,
              token: result.invitation.token,
              email: result.invitation.email,
              expires: result.invitation.expires
            }
          }
        }, { status: 201 });
      }
    }


    return NextResponse.json({
      success: true,
      data: {
        user: {
          id: result.user.id,
          email: result.user.email,
          firstName: result.user.firstName,
          lastName: result.user.lastName
        },
        invitation: {
          id: result.invitation.id,
          token: result.invitation.token,
          email: result.invitation.email,
          expires: result.invitation.expires
        }
      }
    }, { status: 201 });

  } catch (error) {
    console.error('Error creating invitation:', error);
    return NextResponse.json({
      error: "Failed to create invitation",
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\clients\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401 }
      );
    }

    // שליפת כל המועמדים הפעילים שיש להם פרופיל
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE',
        profile: {
          isNot: null  // רק משתמשים עם פרופיל
        }
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        isVerified: true,
        images: {
          select: {
            id: true,
            url: true,
            isMain: true
          }
        },
        profile: {
          select: {
            id: true,
            gender: true,
            birthDate: true,
            nativeLanguage: true,
            additionalLanguages: true,
            height: true,
            maritalStatus: true,
            occupation: true,
            education: true,
            address: true,
            city: true,
            origin: true,
            religiousLevel: true,
            about: true,
            hobbies: true,
            parentStatus: true,
            siblings: true,
            position: true,
            preferredAgeMin: true,
            preferredAgeMax: true,
            preferredHeightMin: true,
            preferredHeightMax: true,
            preferredReligiousLevels: true,
            preferredLocations: true,
            preferredEducation: true,
            preferredOccupations: true,
            contactPreference: true,
            referenceName1: true,
            referencePhone1: true,
            referenceName2: true,
            referencePhone2: true,
            isProfileVisible: true,
            preferredMatchmakerGender: true,
            matchingNotes: true,
            verifiedBy: true,
            availabilityStatus: true,
            availabilityNote: true,
            availabilityUpdatedAt: true,
            lastActive: true,
            createdAt: true,
            updatedAt: true
          }
        }
      }
    });

    const formattedUsers = users.map(user => ({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      status: user.status,
      isVerified: user.isVerified,
      images: user.images,
      profile: {
        ...user.profile,
        birthDate: user.profile?.birthDate,
        lastActive: user.profile?.lastActive?.toISOString(),
        availabilityUpdatedAt: user.profile?.availabilityUpdatedAt?.toISOString(),
        createdAt: user.profile?.createdAt?.toISOString(),
        updatedAt: user.profile?.updatedAt?.toISOString(),
        user: {
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email
        }
      }
    }));

    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: formattedUsers,
        count: formattedUsers.length
      }),
      { status: 200 }
    );

  } catch (error: any) {
    console.error('Profile fetch error:', error.message || 'Unknown error');
    return new NextResponse(
      JSON.stringify({ 
        success: false,
        error: error.message || 'Internal server error' 
      }),
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\dashbord\ClientCard.tsx:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\inquiries\route.ts:
==================================================
// src/app/api/matchmaker/inquiries/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { emailService } from '@/lib/email/emailService';
import { AvailabilityService } from '@/lib/services/availabilityService';

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status") as 'pending' | 'completed' | 'expired' | undefined;
    const orderBy = searchParams.get("orderBy") as 'createdAt' | 'updatedAt' | undefined;
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : undefined;

    const inquiries = await AvailabilityService.getAllInquiries(session.user.id, {
      status,
      orderBy,
      limit
    });

    return NextResponse.json(inquiries);
  } catch (error) {
    console.error("Error fetching inquiries:", error);
    return NextResponse.json(
      { error: "Failed to fetch inquiries" },
      { status: 500 }
    );
  }
}

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { firstPartyId, secondPartyId, note } = await req.json();

    const inquiry = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId,
      secondPartyId,
      note
    });

    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error creating inquiry:", error);
    return NextResponse.json(
      { error: "Failed to create inquiry" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts:
==================================================
// src/app/api/matchmaker/inquiries/[id]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    return NextResponse.json(
      { error: "Failed to fetch inquiry" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts:
==================================================
// src/app/api/matchmaker/inquiries/[id]/respond/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { isAvailable, note } = await req.json();

    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note
    });

    return NextResponse.json(updatedInquiry);
  } catch (error) {
    console.error("Error updating inquiry response:", error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : "Failed to update response"
      },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\suggestions\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Session } from "next-auth";
import { MatchSuggestionStatus } from "@prisma/client";
import { suggestionService } from "@/app/components/matchmaker/new/services/suggestions/SuggestionService";
import { emailService } from "@/lib/email/emailService";
import type { CreateSuggestionData } from "@/app/types/suggestions";

const getSuggestionCategory = (status: MatchSuggestionStatus) => {
 switch (status) {
   case 'DRAFT':
   case 'AWAITING_MATCHMAKER_APPROVAL':
   case 'PENDING_FIRST_PARTY':
   case 'PENDING_SECOND_PARTY':
     return 'PENDING';
   
   case 'FIRST_PARTY_DECLINED':
   case 'SECOND_PARTY_DECLINED':
   case 'MATCH_DECLINED':
   case 'ENDED_AFTER_FIRST_DATE':
   case 'ENGAGED':
   case 'MARRIED':
   case 'EXPIRED':
   case 'CLOSED':
   case 'CANCELLED':
     return 'HISTORY';
   
   default:
     return 'ACTIVE';
 }
};

export async function POST(req: Request) {
 try {
   const session = await getServerSession(authOptions) as Session | null;
   
   if (!session?.user?.id || session.user.role !== 'MATCHMAKER') {
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
   }

   const data = await req.json();
   
   const suggestionData: CreateSuggestionData = {
     ...data,
     matchmakerId: session.user.id,
   };

   const suggestion = await suggestionService.createSuggestion(suggestionData);
   
   return NextResponse.json(suggestion);
   
 } catch (error) {
   console.error('Error creating suggestion:', error);
   return NextResponse.json(
     { error: 'Failed to create suggestion' },
     { status: 500 }
   );
 }
}

export async function GET(req: Request) {
 try {
   const session = await getServerSession(authOptions) as Session | null;
   
   if (!session?.user?.id) {
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
   }

   const { searchParams } = new URL(req.url);
   const status = searchParams.get("status");
   const priority = searchParams.get("priority");
   const timeframe = searchParams.get("timeframe");

   const where: any = {};
   
   if (session.user.role === 'MATCHMAKER') {
     where.matchmakerId = session.user.id;
   } else {
     where.OR = [
       { firstPartyId: session.user.id },
       { secondPartyId: session.user.id }
     ];
   }

   if (status) where.status = status;
   if (priority) where.priority = priority;

   if (timeframe) {
     const date = new Date();
     switch (timeframe) {
       case 'today':
         date.setHours(0, 0, 0, 0);
         where.createdAt = { gte: date };
         break;
       case 'week':
         date.setDate(date.getDate() - 7);
         where.createdAt = { gte: date };
         break;
       case 'month':
         date.setMonth(date.getMonth() - 1);
         where.createdAt = { gte: date };
         break;
     }
   }

   const suggestions = await prisma.matchSuggestion.findMany({
     where,
     include: {
       firstParty: {
         select: {
           id: true,
           email: true,
           firstName: true,
           lastName: true,
           status: true,
           isVerified: true,
           images: {
             select: {
               id: true,
               url: true,
               isMain: true
             }
           },
           profile: true
         }
       },
       secondParty: {
         select: {
           id: true,
           email: true,
           firstName: true,
           lastName: true,
           status: true,
           isVerified: true,
           images: {
             select: {
               id: true,
               url: true,
               isMain: true
             }
           },
           profile: true
         }
       },
       matchmaker: {
         select: {
           id: true,
           firstName: true,
           lastName: true,
           role: true
         }
       },
       statusHistory: true,
       meetings: true
     },
     orderBy: {
       lastActivity: 'desc'
     }
   });

   const formattedSuggestions = suggestions.map(suggestion => ({
     ...suggestion,
     category: getSuggestionCategory(suggestion.status),
     firstParty: {
       ...suggestion.firstParty,
       profile: suggestion.firstParty.profile ? {
         ...suggestion.firstParty.profile,
         birthDate: suggestion.firstParty.profile.birthDate?.toISOString(),
         lastActive: suggestion.firstParty.profile.lastActive?.toISOString(),
         availabilityUpdatedAt: suggestion.firstParty.profile.availabilityUpdatedAt?.toISOString(),
         createdAt: suggestion.firstParty.profile.createdAt?.toISOString(),
         updatedAt: suggestion.firstParty.profile.updatedAt?.toISOString()
       } : null
     },
     secondParty: {
       ...suggestion.secondParty,
       profile: suggestion.secondParty.profile ? {
         ...suggestion.secondParty.profile,
         birthDate: suggestion.secondParty.profile.birthDate?.toISOString(),
         lastActive: suggestion.secondParty.profile.lastActive?.toISOString(),
         availabilityUpdatedAt: suggestion.secondParty.profile.availabilityUpdatedAt?.toISOString(),
         createdAt: suggestion.secondParty.profile.createdAt?.toISOString(),
         updatedAt: suggestion.secondParty.profile.updatedAt?.toISOString()
       } : null
     },
     statusHistory: suggestion.statusHistory.map(history => ({
       ...history,
       createdAt: history.createdAt.toISOString()
     })),
     meetings: suggestion.meetings.map(meeting => ({
       ...meeting,
       createdAt: meeting.createdAt.toISOString(),
       updatedAt: meeting.updatedAt.toISOString()
     })),
     createdAt: suggestion.createdAt.toISOString(),
     updatedAt: suggestion.updatedAt.toISOString(),
     lastActivity: suggestion.lastActivity.toISOString()
   }));

   return NextResponse.json(formattedSuggestions);
   
 } catch (error) {
   console.error('Error fetching suggestions:', error);
   return NextResponse.json(
     { error: 'Failed to fetch suggestions' },
     { status: 500 }
   );
 }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { MatchSuggestionStatus, PrismaClient } from "@prisma/client";
import { z } from "zod";
import { suggestionService } from "@/app/components/matchmaker/new/services/suggestions/SuggestionService";

// Initialize Prisma Client
const prisma = new PrismaClient();

// Validation schema for status update
const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

// Validation schema for history query parameters
const getHistorySchema = z.object({
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().min(1).max(100).optional().default(50),
});

/**
 * PATCH endpoint for updating suggestion status
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Request validation
    const body = await req.json();
    const { status, notes } = updateStatusSchema.parse(body);

    // 3. Update suggestion status
    const updatedSuggestion = await suggestionService.updateSuggestionStatus(
      params.id,
      status,
      session.user.id,
      notes
    );

    return NextResponse.json({
      message: "Status updated successfully",
      suggestion: updatedSuggestion,
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint for fetching suggestion history
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse URL parameters
    const searchParams = new URL(req.url).searchParams;
    const queryParams = getHistorySchema.parse({
      startDate: searchParams.get("startDate"),
      endDate: searchParams.get("endDate"),
      limit: searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : undefined,
    });

    // 3. Check viewing permissions
    const suggestion = await suggestionService.getSuggestionDetails(params.id, session.user.id);
    
    // 4. Build history query
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(queryParams.startDate && {
          createdAt: {
            gte: new Date(queryParams.startDate),
            ...(queryParams.endDate && {
              lte: new Date(queryParams.endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            secondParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            matchmaker: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc" as const,
      },
      take: queryParams.limit,
    };

    // 5. Fetch status change history
    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    // 6. Format results
    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * HEAD endpoint for getting status summary
 */
export async function HEAD(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return new Response(null, { status: 401 });
    }

    // 2. Fetch suggestion details
    const suggestion = await suggestionService.getSuggestionDetails(params.id, session.user.id);

    // 3. Prepare headers
    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    // Add lastStatusChange header only if it exists
    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\preferences\route.ts:
==================================================
// src/app/api/preferences/route.ts
import { getServerSession } from 'next-auth/next';
import { NextResponse } from 'next/server';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { CustomSession } from '@/types/next-auth';

// טיפוסים
interface PrioritiesObject {
  [key: string]: number;
}

interface FormattedPreferences {
  ageRange: {
    min: number;
    max: number;
  };
  heightRange: {
    min: number;
    max: number;
  };
  religiousLevels: string[];
  locations: string[];
  maritalStatuses: string[];
  preferences: Array<{
    criteria: string;
    importance: number;
    isRequired: boolean;
  }>;
  dealBreakers: string[];
  origins: string[];
}

interface PreferencesData extends Omit<Prisma.MatchPreferencesCreateInput, 'user'> {
  ageRange: number[];
  heightRange: number[];
  religiousLevel: string[];
  location: string[];
  origin: string[];
  maritalStatus: string[];
  priorities: PrioritiesObject;
  dealBreakers: string[];
}

export async function GET(req: Request) {
  try {
    // בדיקת הרשאות
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // שליפת ההעדפות מה-database
    const preferences = await prisma.matchPreferences.findUnique({
      where: {
        userId: session.user.id,
      },
    });

    if (!preferences) {
      return new NextResponse(
        JSON.stringify({ 
          message: 'No preferences found',
          preferences: null 
        }),
        { 
          status: 404,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // המרת ה-priorities ל-object תקין
    const priorities = preferences.priorities as PrioritiesObject;
    const dealBreakers = Array.isArray(preferences.dealBreakers) 
      ? preferences.dealBreakers 
      : [];

    // המרת הנתונים לפורמט המתאים לממשק המשתמש
    const formattedPreferences: FormattedPreferences = {
      ageRange: {
        min: preferences.ageRange[0],
        max: preferences.ageRange[1],
      },
      heightRange: {
        min: preferences.heightRange[0],
        max: preferences.heightRange[1],
      },
      religiousLevels: preferences.religiousLevel,
      locations: preferences.location,
      maritalStatuses: preferences.maritalStatus,
      preferences: Object.entries(priorities).map(([criteria, importance]) => ({
        criteria,
        importance: Number(importance),
        isRequired: dealBreakers.includes(criteria),
      })),
      dealBreakers: preferences.dealBreakers,
      origins: preferences.origin,
    };

    return new NextResponse(
      JSON.stringify(formattedPreferences),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error fetching preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בטעינת ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

export async function PUT(req: Request) {
  try {
    // בדיקת הרשאות
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    const data = await req.json();

    // וולידציה של הנתונים
    if (!data.ageRange || !data.heightRange) {
      return new NextResponse(
        JSON.stringify({ error: 'Missing required fields' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // בדיקת תקינות טווחי גיל וגובה
    if (
      data.ageRange.min < 18 || 
      data.ageRange.max > 120 || 
      data.ageRange.min > data.ageRange.max
    ) {
      return new NextResponse(
        JSON.stringify({ error: 'Invalid age range' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    if (
      data.heightRange.min < 140 || 
      data.heightRange.max > 220 || 
      data.heightRange.min > data.heightRange.max
    ) {
      return new NextResponse(
        JSON.stringify({ error: 'Invalid height range' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // המרת הנתונים לפורמט המתאים ל-database
    const preferencesData: PreferencesData = {
      ageRange: [data.ageRange.min, data.ageRange.max],
      heightRange: [data.heightRange.min, data.heightRange.max],
      religiousLevel: data.religiousLevels || [],
      location: data.locations || [],
      origin: data.origins || [],
      maritalStatus: data.maritalStatuses || [],
      priorities: data.preferences.reduce((acc: PrioritiesObject, pref: any) => {
        acc[pref.criteria] = pref.importance;
        return acc;
      }, {}),
      dealBreakers: data.preferences
        .filter((pref: any) => pref.isRequired)
        .map((pref: any) => pref.criteria)
    };

    // עדכון או יצירת העדפות
    const updatedPreferences = await prisma.matchPreferences.upsert({
      where: {
        userId: session.user.id,
      },
      create: {
        ...preferencesData,
        user: {
          connect: {
            id: session.user.id
          }
        }
      },
      update: preferencesData,
    });

    return new NextResponse(
      JSON.stringify({
        message: 'Preferences updated successfully',
        preferences: updatedPreferences
      }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error updating preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בעדכון ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\preferences\update\route.ts:
==================================================
import { getServerSession } from 'next-auth/next';
import { NextResponse } from 'next/server';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { CustomSession } from '@/types/next-auth';
import { Prisma } from '@prisma/client';

// Types
interface PrioritiesObject {
  [key: string]: number;
}

interface PreferencesData {
  ageRange: {
    min: number;
    max: number;
  };
  heightRange: {
    min: number;
    max: number;
  };
  religiousLevels: string[];
  locations: string[];
  maritalStatuses: string[];
  preferences: Array<{
    criteria: string;
    importance: number;
    isRequired: boolean;
  }>;
  origins?: string[];
}

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    const data = await req.json() as PreferencesData;

    // Validate age range
    if (data.ageRange.min < 18 || data.ageRange.max > 80 || data.ageRange.min > data.ageRange.max) {
      return new NextResponse(
        JSON.stringify({ error: 'טווח גילאים לא תקין' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // Validate height range
    if (data.heightRange.min < 140 || data.heightRange.max > 200 || data.heightRange.min > data.heightRange.max) {
      return new NextResponse(
        JSON.stringify({ error: 'טווח גבהים לא תקין' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // Create or update match preferences
    const updatedPreferences = await prisma.matchPreferences.upsert({
      where: {
        userId: session.user.id,
      },
      create: {
        userId: session.user.id,
        ageRange: [data.ageRange.min, data.ageRange.max],
        heightRange: [data.heightRange.min, data.heightRange.max],
        religiousLevel: data.religiousLevels,
        location: data.locations,
        maritalStatus: data.maritalStatuses,
        priorities: data.preferences.reduce((acc: PrioritiesObject, pref) => {
          acc[pref.criteria] = pref.importance;
          return acc;
        }, {}),
        dealBreakers: data.preferences
          .filter(pref => pref.isRequired)
          .map(pref => pref.criteria),
        origin: data.origins || [],
        updatedAt: new Date()
      },
      update: {
        ageRange: [data.ageRange.min, data.ageRange.max],
        heightRange: [data.heightRange.min, data.heightRange.max],
        religiousLevel: data.religiousLevels,
        location: data.locations,
        maritalStatus: data.maritalStatuses,
        priorities: data.preferences.reduce((acc: PrioritiesObject, pref) => {
          acc[pref.criteria] = pref.importance;
          return acc;
        }, {}),
        dealBreakers: data.preferences
          .filter(pref => pref.isRequired)
          .map(pref => pref.criteria),
        origin: data.origins || [],
        updatedAt: new Date()
      },
    });

    return new NextResponse(
      JSON.stringify({ 
        message: 'העדפות נשמרו בהצלחה',
        preferences: updatedPreferences 
      }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error updating preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בשמירת ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    const preferences = await prisma.matchPreferences.findUnique({
      where: {
        userId: session.user.id,
      },
    });

    if (!preferences) {
      return new NextResponse(
        JSON.stringify({ 
          message: 'No preferences found',
          preferences: null 
        }),
        { 
          status: 404,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // Type assertion for priorities
    const priorities = preferences.priorities as PrioritiesObject;

    // Transform the data back to the format expected by the frontend
    const formattedPreferences = {
      ageRange: {
        min: preferences.ageRange[0],
        max: preferences.ageRange[1],
      },
      heightRange: {
        min: preferences.heightRange[0],
        max: preferences.heightRange[1],
      },
      religiousLevels: preferences.religiousLevel,
      locations: preferences.location,
      maritalStatuses: preferences.maritalStatus,
      preferences: Object.entries(priorities).map(([criteria, importance]) => ({
        criteria,
        importance,
        isRequired: preferences.dealBreakers.includes(criteria),
      })),
      dealBreakers: preferences.dealBreakers,
      origins: preferences.origin,
    };

    return new NextResponse(
      JSON.stringify(formattedPreferences),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error fetching preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בטעינת ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { User, UserProfile } from "@/types/next-auth";

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const userQuery = requestedUserId 
      ? { id: requestedUserId }
      : { email: session.user.email };

    const user = await prisma.user.findUnique({
      where: userQuery,
      include: {
        profile: true,
        images: true
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    const userProfile = user.profile as unknown as UserProfile;

    const profile = {
      ...userProfile,
      // Personal Information
      gender:userProfile?.gender|| null,
      birthDate:userProfile?.birthDate|| null,
      nativeLanguage: userProfile?.nativeLanguage || null,
      additionalLanguages: userProfile?.additionalLanguages || [],
      height: userProfile?.height || null,
      maritalStatus: userProfile?.maritalStatus || null,
      occupation: userProfile?.occupation || "",
      education: userProfile?.education || "",
      address: userProfile?.address || null,
      city: userProfile?.city || null,
      origin: userProfile?.origin || null,
      religiousLevel: userProfile?.religiousLevel || null,
      about: userProfile?.about || null,
      hobbies: userProfile?.hobbies || null,

      // Family Information
      parentStatus: userProfile?.parentStatus || null,
      siblings: userProfile?.siblings || null,
      position: userProfile?.position || null,

      // Matching Preferences
      preferredAgeMin: userProfile?.preferredAgeMin || null,
      preferredAgeMax: userProfile?.preferredAgeMax || null,
      preferredHeightMin: userProfile?.preferredHeightMin || null,
      preferredHeightMax: userProfile?.preferredHeightMax || null,
      preferredReligiousLevels: userProfile?.preferredReligiousLevels || [],
      preferredLocations: userProfile?.preferredLocations || [],
      preferredEducation: userProfile?.preferredEducation || [],
      preferredOccupations: userProfile?.preferredOccupations || [],

      // Contact and References
      contactPreference: userProfile?.contactPreference || null,
      referenceName1: userProfile?.referenceName1 || "",
      referencePhone1: userProfile?.referencePhone1 || "",
      referenceName2: userProfile?.referenceName2 || "",
      referencePhone2: userProfile?.referencePhone2 || "",

      // Profile Settings
      isProfileVisible: userProfile?.isProfileVisible ?? true,
      preferredMatchmakerGender: userProfile?.preferredMatchmakerGender || null,
      matchingNotes: userProfile?.matchingNotes || null,
      verifiedBy: userProfile?.verifiedBy || null,

      // Availability Status
      availabilityStatus: userProfile?.availabilityStatus || 'AVAILABLE',
      availabilityNote: userProfile?.availabilityNote || null,
      availabilityUpdatedAt: userProfile?.availabilityUpdatedAt || null,

      // System Fields
      createdAt: userProfile?.createdAt || new Date(),
      updatedAt: userProfile?.updatedAt || new Date(),
      lastActive: userProfile?.lastActive || null,

      // User Information
      user: {
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
      }
    };

    return NextResponse.json({
      success: true,
      profile,
      images: user.images
    });

  } catch (error) {
    console.error('Profile fetch error:', error instanceof Error ? error.message : 'Unknown error');
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\availability\route.ts:
==================================================
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest, ApiResponse } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\images\route.ts:
==================================================
// src/app/api/profile/images/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// GET - Fetch all images for a user
export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: { 
        user: {
          email: session.user.email 
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error("[GetImages] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch images" },
      { status: 500 }
    );
  }
}

// POST - Upload a new image
export async function POST(req: Request) {
  try {
    console.log("[Upload] Starting upload process");
    
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error("[Upload] Authentication failed - No user session");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: { images: true },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    if (user.images.length >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { error: "Maximum number of images reached" },
        { status: 400 }
      );
    }

    const formData = await req.formData();
    const file = formData.get("file") as File;
    
    if (!file) {
      console.error("[Upload] No file provided in request");
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    // Validate file
    const validTypes = ["image/jpeg", "image/png", "image/jpg"];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        { error: "Invalid file type. Only JPG and PNG are allowed" },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { error: "File size must be less than 5MB" },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    try {
      const uploadPromise = new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          {
            folder: "profile-images",
            resource_type: "image",
          },
          (error, result) => {
            if (error) reject(error);
            else resolve(result);
          }
        );
        uploadStream.end(buffer);
      });

      const result = await uploadPromise as any;

      const image = await prisma.userImage.create({
        data: {
          userId: user.id,
          url: result.secure_url,
          cloudinaryPublicId: result.public_id,
          isMain: user.images.length === 0,
        },
      });

      return NextResponse.json({ success: true, image });
    } catch (cloudinaryError) {
      console.error("[Upload] Cloudinary upload failed:", cloudinaryError);
      return NextResponse.json(
        { error: "Failed to upload image to cloud storage" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("[Upload] General error:", error);
    return NextResponse.json(
      { error: "Failed to upload image" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\images\[imageId]\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;
    
    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Delete from Cloudinary if cloudinaryPublicId exists
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
        // Continue with database deletion even if Cloudinary deletion fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId },
    });

    // If this was the main image, set another image as main if available
    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;

    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Reset all user's images to non-main
    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    // Set the selected image as main
    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    // Get updated images list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\questionnaire\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma } from "@prisma/client";
import { valuesQuestionsPartOne } from "@/components/questionnaire/questions/values/valuesQuestionsPartOne";
import { valuesQuestionsPartTwo } from "@/components/questionnaire/questions/values/valuesQuestionsPartTwo"; 
import { personalityQuestionsPartOne } from "@/components/questionnaire/questions/personality/personalityQuestionsPartOne";
import { personalityQuestionsPartTwo } from "@/components/questionnaire/questions/personality/personalityQuestionsPartTwo";
import { relationshipBasicsQuestions } from "@/components/questionnaire/questions/relationship/relationshipBasicsQuestions";
import { relationshipDepthQuestions } from "@/components/questionnaire/questions/relationship/relationshipDepthQuestions";
import { partnerBasicQuestions } from "@/components/questionnaire/questions/partner/partnerBasicQuestions";
import { partnerDepthQuestions } from "@/components/questionnaire/questions/partner/partnerDepthQuestions";
import { faithQuestions } from "@/components/questionnaire/questions/religion/faithQuestions";
import { practicalQuestions } from "@/components/questionnaire/questions/religion/practicalReligionQuestions";

// Combine all questions into a single array
const allQuestions = [
  ...valuesQuestionsPartOne,
  ...valuesQuestionsPartTwo,
  ...personalityQuestionsPartOne,
  ...personalityQuestionsPartTwo,
  ...relationshipBasicsQuestions,
  ...relationshipDepthQuestions,
  ...partnerBasicQuestions,
  ...partnerDepthQuestions,
  ...faithQuestions,
  ...practicalQuestions
];

// Define key types
type WorldKey = 'values' | 'personality' | 'relationship' | 'partner' | 'religion';
type DbWorldKey = 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers';

// Key mapping utility
const KEY_MAPPING: Record<WorldKey, DbWorldKey> = {
  values: 'valuesAnswers',
  personality: 'personalityAnswers',
  relationship: 'relationshipAnswers',
  partner: 'partnerAnswers',
  religion: 'religionAnswers'
};

// Reverse key mapping utility
const REVERSE_KEY_MAPPING: Record<DbWorldKey, WorldKey> = {
  valuesAnswers: 'values',
  personalityAnswers: 'personality',
  relationshipAnswers: 'relationship',
  partnerAnswers: 'partner',
  religionAnswers: 'religion'
};

function getDbKey(worldKey: WorldKey): DbWorldKey {
  return KEY_MAPPING[worldKey];
}

function getWorldKey(dbKey: DbWorldKey): WorldKey {
  return REVERSE_KEY_MAPPING[dbKey];
}

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible?: boolean;
}

interface UpdateData {
  type: 'answer' | 'visibility';
  value?: string;
  isVisible?: boolean;
}

interface FormattedAnswer {
  questionId: string;
  question: string;
  value: Prisma.JsonValue;
  displayText: string;
  answeredAt: string;
  category?: string;
  isVisible?: boolean;
}

type FormattedAnswersType = Record<WorldKey, FormattedAnswer[]>;

const valueTranslations: Record<string, string> = {
  'combat': 'קרבי',
  'intelligence': 'אינטליגנציה',
  'stable': 'יציב',
  'yes': 'כן',
  'no': 'לא',
  'religious': 'דתי',
  'traditional': 'מסורתי',
  'secular': 'חילוני',
  'male': 'גבר',
  'female': 'אישה',
  'both': 'שניהם',
  'high': 'גבוהה',
  'medium': 'בינונית',
  'low': 'נמוכה'
};

function getQuestionLabel(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.question || questionId;
}

function getQuestionCategory(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.category || '';
}

function formatValue(value: Prisma.JsonValue): string {
  if (typeof value === 'boolean') {
    return value ? 'כן' : 'לא';
  }
  
  if (Array.isArray(value)) {
    return value.map(v => valueTranslations[String(v)] || String(v)).join(', ');
  }
  
  if (typeof value === 'object' && value !== null) {
    return JSON.stringify(value);
  }
  
  const stringValue = String(value);
  return valueTranslations[stringValue] || stringValue;
}

function safeParseJson(value: any): JsonAnswerData[] {
  if (Array.isArray(value)) {
    return value.map(item => ({
      questionId: item.questionId,
      value: item.value,
      answeredAt: item.answeredAt,
      isVisible: item.isVisible ?? true
    }));
  }
  return [];
}

function formatAnswers(answers: Prisma.JsonValue | null): FormattedAnswer[] {
  const parsedAnswers = safeParseJson(answers);
  
  return parsedAnswers.map(answer => {
    const displayText = formatValue(answer.value);
    const category = getQuestionCategory(answer.questionId);
    
    return {
      questionId: answer.questionId,
      question: getQuestionLabel(answer.questionId),
      value: answer.value,
      displayText,
      category,
      isVisible: answer.isVisible,
      answeredAt: new Date(answer.answeredAt).toLocaleDateString('he-IL', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    };
  }).sort((a, b) => a.questionId.localeCompare(b.questionId));
}

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const userId = url.searchParams.get('userId') || session.user.id;

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });

    if (!questionnaireResponse) {
      return NextResponse.json({
        success: true,
        questionnaireResponse: null
      });
    }

    // Create formatted answers with correct typing
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    
    (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(worldKey => {
      const dbKey = getDbKey(worldKey);
      formattedAnswers[worldKey] = formatAnswers(questionnaireResponse[dbKey]);
    });

    const formattedResponse = {
      ...questionnaireResponse,
      formattedAnswers: formattedAnswers as FormattedAnswersType
    };

    // Filter out non-visible answers for other users
    if (userId !== session.user.id) {
      Object.keys(formattedResponse.formattedAnswers).forEach((worldKey) => {
        const key = worldKey as WorldKey;
        formattedResponse.formattedAnswers[key] = 
          formattedResponse.formattedAnswers[key].filter(answer => answer.isVisible !== false);
      });
    }

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedResponse
    });

  } catch (error) {
    console.error('Error in GET:', error);
    return NextResponse.json({ success: false, error: "Failed to fetch questionnaire" }, { status: 500 });
  }
}

export async function PATCH(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { worldKey, questionId, value } = body as { 
      worldKey: WorldKey; 
      questionId: string; 
      value: UpdateData;
    };

    const dbKey = getDbKey(worldKey);

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id },
      orderBy: { createdAt: 'desc' }
    });

    if (!questionnaire) {
      return NextResponse.json({ success: false, error: "שאלון לא נמצא" }, { status: 404 });
    }

    const currentAnswers = (questionnaire[dbKey] as JsonAnswerData[]) || [];
    const existingAnswer = currentAnswers.find((a) => a.questionId === questionId);

    let updatedAnswer: JsonAnswerData;

    if (value.type === 'visibility') {
      if (!existingAnswer) {
        throw new Error("לא נמצאה תשובה לעדכון");
      }
      
      updatedAnswer = {
        ...existingAnswer,
        isVisible: value.isVisible,
        answeredAt: new Date().toISOString()
      };
    } else {
      updatedAnswer = {
        questionId,
        value: value.value as string,
        isVisible: existingAnswer?.isVisible ?? true,
        answeredAt: new Date().toISOString()
      };
    }

    const updatedAnswers = [
      ...currentAnswers.filter((a) => a.questionId !== questionId),
      updatedAnswer
    ];

    const updated = await prisma.questionnaireResponse.update({
      where: { id: questionnaire.id },
      data: {
        [dbKey]: updatedAnswers,
        lastSaved: new Date()
      }
    });

    // Create formatted answers with correct typing
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    
    (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(key => {
      const dbKey = getDbKey(key);
      formattedAnswers[key] = formatAnswers(updated[dbKey]);
    });

    const formattedResponse = {
      ...updated,
      formattedAnswers: formattedAnswers as FormattedAnswersType
    };

    return NextResponse.json({
      success: true,
      data: formattedResponse
    });

  } catch (error) {
    if (error instanceof Error) {
      return NextResponse.json({ success: false, error: error.message }, { status: 500 });
    }
    return NextResponse.json({ success: false, error: "שגיאה בעדכון השאלון" }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\update\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { AvailabilityStatus, Gender } from "@prisma/client";
import { User, UserProfile } from "@/types/next-auth";

export async function PUT(req: Request) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Get request data
    const data = await req.json();
    
    // Find the user
    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: {
        images: true,
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Update or create profile with new schema
    const profile = await prisma.profile.upsert({
      where: {
        userId: user.id
      },
      create: {
        userId: user.id,
        // Personal Information
        gender:data?.gender,
        birthDate:data?.birthDate,
        nativeLanguage: data.nativeLanguage,
        additionalLanguages: data.additionalLanguages || [],
        height: data.height ? parseInt(data.height) : null,
        maritalStatus: data.maritalStatus,
        occupation: data.occupation,
        education: data.education,
        address: data.address,
        city: data.city,
        origin: data.origin,
        religiousLevel: data.religiousLevel,
        about: data.about,
        hobbies: data.hobbies,
        
        // Family Information
        parentStatus: data.parentStatus,
        siblings: data.siblings ? parseInt(data.siblings) : null,
        position: data.position ? parseInt(data.position) : null,
        
        // Matching Preferences
        preferredAgeMin: data.preferredAgeMin ? parseInt(data.preferredAgeMin) : null,
        preferredAgeMax: data.preferredAgeMax ? parseInt(data.preferredAgeMax) : null,
        preferredHeightMin: data.preferredHeightMin ? parseInt(data.preferredHeightMin) : null,
        preferredHeightMax: data.preferredHeightMax ? parseInt(data.preferredHeightMax) : null,
        preferredReligiousLevels: data.preferredReligiousLevels || [],
        preferredLocations: data.preferredLocations || [],
        preferredEducation: data.preferredEducation || [],
        preferredOccupations: data.preferredOccupations || [],
        
        // Contact and References
        contactPreference: data.contactPreference,
        referenceName1: data.referenceName1,
        referencePhone1: data.referencePhone1,
        referenceName2: data.referenceName2,
        referencePhone2: data.referencePhone2,
        
        // Profile Settings
        isProfileVisible: data.isProfileVisible ?? true,
        preferredMatchmakerGender: data.preferredMatchmakerGender as Gender | null,
        matchingNotes: data.matchingNotes,
        
        // Availability Status
        availabilityStatus: data.availabilityStatus as AvailabilityStatus ?? 'AVAILABLE',
        availabilityNote: data.availabilityNote,
        availabilityUpdatedAt: new Date(),
        
        // System Fields
        createdAt: new Date(),
        updatedAt: new Date(),
        lastActive: new Date(),
      },
      update: {
        // Personal Information
        nativeLanguage: data.nativeLanguage,
        additionalLanguages: data.additionalLanguages,
        height: data.height ? parseInt(data.height) : null,
        maritalStatus: data.maritalStatus,
        occupation: data.occupation,
        education: data.education,
        address: data.address,
        city: data.city,
        origin: data.origin,
        religiousLevel: data.religiousLevel,
        about: data.about,
        hobbies: data.hobbies,
        
        // Family Information
        parentStatus: data.parentStatus,
        siblings: data.siblings ? parseInt(data.siblings) : null,
        position: data.position ? parseInt(data.position) : null,
        
        // Matching Preferences
        preferredAgeMin: data.preferredAgeMin ? parseInt(data.preferredAgeMin) : null,
        preferredAgeMax: data.preferredAgeMax ? parseInt(data.preferredAgeMax) : null,
        preferredHeightMin: data.preferredHeightMin ? parseInt(data.preferredHeightMin) : null,
        preferredHeightMax: data.preferredHeightMax ? parseInt(data.preferredHeightMax) : null,
        preferredReligiousLevels: data.preferredReligiousLevels,
        preferredLocations: data.preferredLocations,
        preferredEducation: data.preferredEducation,
        preferredOccupations: data.preferredOccupations,
        
        // Contact and References
        contactPreference: data.contactPreference,
        referenceName1: data.referenceName1,
        referencePhone1: data.referencePhone1,
        referenceName2: data.referenceName2,
        referencePhone2: data.referencePhone2,
        
        // Profile Settings
        isProfileVisible: data.isProfileVisible,
        preferredMatchmakerGender: data.preferredMatchmakerGender as Gender | null,
        matchingNotes: data.matchingNotes,
        
        // Availability Status
        availabilityStatus: data.availabilityStatus as AvailabilityStatus ?? 'AVAILABLE',
        availabilityNote: data.availabilityNote,
        availabilityUpdatedAt: new Date(),
        
        // System Fields
        updatedAt: new Date(),
        lastActive: new Date(),
      }
    });

    // Fetch updated user with all required information
    const updatedUser = await prisma.user.findUnique({
      where: { id: user.id },
      select: {
        firstName: true,
        lastName: true,
        email: true,
        images: true,
        profile: true
      }
    });

    if (!updatedUser) {
      return NextResponse.json(
        { error: 'Failed to fetch updated profile' },
        { status: 500 }
      );
    }

    // Transform the data to include user information
    const transformedProfile = {
      ...updatedUser.profile,
      user: {
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        email: updatedUser.email,
      },
      images: updatedUser.images,
      mainImage: updatedUser.images.find(img => img.isMain) || null
    };

    return NextResponse.json({
      success: true,
      profile: transformedProfile
    });

  } catch (error) {
    console.error('Profile update error:', error);
    
    if (error instanceof Error) {
      // Prisma errors
      if (error.name === 'PrismaClientKnownRequestError') {
        return NextResponse.json(
          { error: 'Database operation failed' },
          { status: 400 }
        );
      }
      
      // Validation errors
      if (error.name === 'ValidationError') {
        return NextResponse.json(
          { error: error.message },
          { status: 400 }
        );
      }
      
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\name\route.ts:
==================================================
// src/app/api/profile/[userId]/name/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";

export async function PUT(
  req: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.id !== params.userId) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { firstName, lastName } = await req.json();
    if (!firstName || !lastName) {
      return NextResponse.json(
        { success: false, error: "Missing required fields" },
        { status: 400 }
      );
    }

    const user = await prisma.user.update({
      where: { id: params.userId },
      data: { firstName, lastName },
    });

    return NextResponse.json({ success: true, user });
  } catch (error) {
    console.error('Name update error:', error);
    return NextResponse.json(
      { success: false, error: "Server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\password\complete\route.ts:
==================================================
// src/app/api/profile/[userId]/password/complete/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";

const MAX_ATTEMPTS = 3;

export async function POST(
  req: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.id !== params.userId) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { verificationCode, newPassword } = await req.json();

    // Find valid verification record
    const verification = await prisma.verification.findFirst({
      where: {
        userId: params.userId,
        token: verificationCode,
        type: 'EMAIL',
        status: 'PENDING',
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { success: false, error: "Invalid or expired verification code" },
        { status: 400 }
      );
    }

    // Check attempts
    if (verification.attempts >= MAX_ATTEMPTS) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: 'FAILED' }
      });
      return NextResponse.json(
        { success: false, error: "Too many failed attempts" },
        { status: 400 }
      );
    }

    // Increment attempts
    await prisma.verification.update({
      where: { id: verification.id },
      data: { attempts: { increment: 1 } }
    });

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 12);

    // Update password and verification record
    await prisma.$transaction([
      prisma.user.update({
        where: { id: params.userId },
        data: { password: hashedPassword }
      }),
      prisma.verification.update({
        where: { id: verification.id },
        data: { 
          status: 'COMPLETED',
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Password change completion error:', error);
    return NextResponse.json(
      { success: false, error: "Server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\password\initiate\route.ts:
==================================================
// src/app/api/profile/[userId]/password/initiate/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";
import { createTransport } from "nodemailer";
import { randomBytes } from "crypto";

export async function POST(
  req: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.id !== params.userId) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { currentPassword } = await req.json();
    
    const user = await prisma.user.findUnique({
      where: { id: params.userId },
    });

    if (!user) {
      return NextResponse.json(
        { success: false, error: "User not found" },
        { status: 404 }
      );
    }

    const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isPasswordValid) {
      return NextResponse.json(
        { success: false, error: "Invalid password" },
        { status: 400 }
      );
    }

    // Generate verification code
    const verificationCode = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes

    // Create verification record
    await prisma.verification.create({
      data: {
        userId: user.id,
        type: 'EMAIL',
        token: verificationCode,
        expiresAt,
        status: 'PENDING'
      }
    });

    // Send verification email
    const transporter = createTransport({
      host: process.env.SMTP_HOST,
      port: Number(process.env.SMTP_PORT),
      secure: true,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });

    await transporter.sendMail({
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'קוד אימות לשינוי סיסמה',
      html: `
        <div dir="rtl">
          <h1>שינוי סיסמה</h1>
          <p>קוד האימות שלך לשינוי הסיסמה הוא:</p>
          <h2>${verificationCode}</h2>
          <p>הקוד תקף ל-30 דקות.</p>
          <p>אם לא ביקשת לשנות את הסיסמה, אנא התעלם מהודעה זו.</p>
        </div>
      `
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Password change initiation error:', error);
    return NextResponse.json(
      { success: false, error: "Server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\questionnaire\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { FormattedAnswer } from "@/types/next-auth";

interface AnswersByWorld {
  values: FormattedAnswer[];
  personality: FormattedAnswer[];
  relationship: FormattedAnswer[];
  partner: FormattedAnswer[];
  religion: FormattedAnswer[];
}

// Helper function to format a single answer
const formatAnswer = (question: string, value: any, answeredAt: Date, isVisible = true): FormattedAnswer => {
  return {
    questionId: question,
    question,
    value,
    displayText: typeof value === 'object' ? value.text || JSON.stringify(value) : String(value),
    answeredAt: answeredAt.toISOString(),
    isVisible
  };
};

// Helper function to format answers for a specific world
const formatWorldAnswers = (worldAnswers: Record<string, any> | null, answeredAt: Date): FormattedAnswer[] => {
  if (!worldAnswers) return [];
  
  return Object.entries(worldAnswers).map(([question, value]) => 
    formatAnswer(question, value, answeredAt)
  );
};

// Main function to format all answers
const formatQuestionnaireAnswers = (questionnaireResponse: any): AnswersByWorld => {
  const answeredAt = questionnaireResponse.updatedAt || questionnaireResponse.createdAt;
  
  return {
    values: formatWorldAnswers(questionnaireResponse.valuesAnswers, answeredAt),
    personality: formatWorldAnswers(questionnaireResponse.personalityAnswers, answeredAt),
    relationship: formatWorldAnswers(questionnaireResponse.relationshipAnswers, answeredAt),
    partner: formatWorldAnswers(questionnaireResponse.partnerAnswers, answeredAt),
    religion: formatWorldAnswers(questionnaireResponse.religionAnswers, answeredAt)
  };
};

export async function GET(
  request: NextRequest,
  context: { params: { userId: string } }
) {
  const { userId } = context.params;

  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // בדיקה שהמשתמש הוא שדכן (אופציונלי)
    if (session.user.role !== 'MATCHMAKER' && session.user.id !== userId) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: userId
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    if (!questionnaireResponse) {
      return NextResponse.json({
        success: true,
        questionnaireResponse: null
      });
    }

    // Format the questionnaire response
    const formattedAnswers = formatQuestionnaireAnswers(questionnaireResponse);

    // Return the response with formatted answers
    return NextResponse.json({
      success: true,
      questionnaireResponse: {
        ...questionnaireResponse,
        formattedAnswers
      }
    });

  } catch (error) {
    console.error("Failed to fetch questionnaire:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch questionnaire" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { Prisma } from "@prisma/client";

// Type guards
function isPrismaError(error: unknown): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

// Constants
const WORLD_IDS = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;

// Zod Schemas
const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const QuestionAnswer = z.object({
  questionId: z.string().min(1),
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number())
  ]),
  answeredAt: z.string().datetime()
});

const WorldAnswers = z.array(QuestionAnswer);

const AnswersByWorld = z.object({
  valuesAnswers: WorldAnswers.optional(),
  personalityAnswers: WorldAnswers.optional(),
  relationshipAnswers: WorldAnswers.optional(),
  partnerAnswers: WorldAnswers.optional(),
  religionAnswers: WorldAnswers.optional()
});

const QuestionnaireAnswer = z.object({
  questionId: z.string(),
  worldId: WorldId,
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
  ]),
  answeredAt: z.string().datetime()
});

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional()
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

/**
 * Groups answers by world ID and formats them for database storage
 */
function groupAnswersByWorld(answers: QuestionnaireSubmission["answers"]) {
  return answers.reduce<Record<string, any>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer = {
      questionId: answer.questionId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      worldId: answer.worldId
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);
    
    return acc;
  }, {});
}

/**
 * Validates that all required fields exist and have correct data types
 */
function validateSubmissionData(data: unknown): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);
  
  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

/**
 * Handles API GET request to retrieve latest questionnaire response
 */
export async function GET(req: Request) {
  try {
    // 1. Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    // 2. Fetch latest questionnaire response
    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    // 3. Transform the data for the client if needed
    const transformedData = questionnaire ? {
      ...questionnaire,
      // Convert JSON fields back to arrays if they exist
      valuesAnswers: questionnaire.valuesAnswers || [],
      personalityAnswers: questionnaire.personalityAnswers || [],
      relationshipAnswers: questionnaire.relationshipAnswers || [],
      partnerAnswers: questionnaire.partnerAnswers || [],
      religionAnswers: questionnaire.religionAnswers || [],
    } : null;

    // 4. Return response
    return NextResponse.json({
      success: true,
      data: transformedData
    });

  } catch (error: unknown) {
    console.error("Error fetching questionnaire:", {
      message: isError(error) ? error.message : "Unknown error occurred",
      stack: process.env.NODE_ENV === 'development' ? error : undefined
    });

    return NextResponse.json({
      error: "אירעה שגיאה בטעינת השאלון",
      details: process.env.NODE_ENV === 'development' ? error : undefined
    }, { status: 500 });
  }
}

/**
 * Handles API PUT request to save questionnaire responses
 */
export async function PUT(req: Request) {
  try {
    // 1. Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "נדרשת התחברות" }, { status: 401 });
    }

    // 2. Parse request body
    const rawBody = await req.json();
    
    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    // 3. Verify user exists
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    // 4. Clean and validate data
    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers: rawBody.answers?.filter((answer: any) => 
        answer && 
        answer.questionId && 
        answer.worldId && 
        answer.value !== undefined && 
        answer.value !== null && 
        answer.value !== ''
      ) ?? []
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: isError(error) ? error.message : 'Unknown validation error'
      }, { status: 400 });
    }

    // 5. Group answers by world
    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    // 6. Save data using upsert
    const result = await prisma.$transaction(async (prisma) => {
      // Try to find existing response
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' }
      });

      // Merge existing and new answers
      const mergedAnswers = {
        valuesAnswers: [...(existingResponse?.valuesAnswers as any[] || []), ...(answersGroupedByWorld.valuesAnswers || [])],
        personalityAnswers: [...(existingResponse?.personalityAnswers as any[] || []), ...(answersGroupedByWorld.personalityAnswers || [])],
        relationshipAnswers: [...(existingResponse?.relationshipAnswers as any[] || []), ...(answersGroupedByWorld.relationshipAnswers || [])],
        partnerAnswers: [...(existingResponse?.partnerAnswers as any[] || []), ...(answersGroupedByWorld.partnerAnswers || [])],
        religionAnswers: [...(existingResponse?.religionAnswers as any[] || []), ...(answersGroupedByWorld.religionAnswers || [])]
      };

      // Remove duplicate answers (keep latest version of each answer)
      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof typeof mergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce((acc: any[], curr: any) => {
            const existingIndex = acc.findIndex(a => a.questionId === curr.questionId);
            if (existingIndex >= 0) {
              // Replace existing answer if new one is more recent
              if (new Date(curr.answeredAt) > new Date(acc[existingIndex].answeredAt)) {
                acc[existingIndex] = curr;
              }
            } else {
              acc.push(curr);
            }
            return acc;
          }, []);
          mergedAnswers[worldKey as keyof typeof mergedAnswers] = uniqueAnswers;
        }
      }

      // Update or create response
      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt ? new Date(validatedData.completedAt) : null,
          valuesCompleted: validatedData.worldsCompleted.includes("VALUES"),
          personalityCompleted: validatedData.worldsCompleted.includes("PERSONALITY"),
          relationshipCompleted: validatedData.worldsCompleted.includes("RELATIONSHIP"),
          partnerCompleted: validatedData.worldsCompleted.includes("PARTNER"),
          religionCompleted: validatedData.worldsCompleted.includes("RELIGION"),
          lastSaved: new Date()
        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt ? new Date(validatedData.completedAt) : null,
          valuesCompleted: validatedData.worldsCompleted.includes("VALUES"),
          personalityCompleted: validatedData.worldsCompleted.includes("PERSONALITY"),
          relationshipCompleted: validatedData.worldsCompleted.includes("RELATIONSHIP"),
          partnerCompleted: validatedData.worldsCompleted.includes("PARTNER"),
          religionCompleted: validatedData.worldsCompleted.includes("RELIGION"),
          lastSaved: new Date()
        }
      });

      // Update user status if questionnaire is completed
      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: "ACTIVE" }
        });
      }

      return savedQuestionnaire;
    });

    // 7. Return success response
    return NextResponse.json({
      success: true,
      data: result
    });

  } catch (error: unknown) {
    // Safe error logging with type checking
    const errorMessage = isError(error) ? error.message : "Unknown error occurred";
    const errorStack = isError(error) ? error.stack : undefined;

    console.error("Error details:", {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined
    });

    // Handle Prisma specific errors
    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון - משתמש לא קיים",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 400 });
        case 'P2002':
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון - רשומה כבר קיימת",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 409 });
        default:
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 500 });
      }
    }

    // Handle general errors
    return NextResponse.json({
      error: "אירעה שגיאה בשמירת השאלון",
      details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\complete\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const allWorldsCompleted = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"].every(
      world => validatedData.worldsCompleted.includes(world as any)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "לא כל העולמות הושלמו"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: "לא נמצא שאלון להשלמה"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
      prisma.user.update({
        where: { id: session.user.id },
        data: { status: "ACTIVE" }
      })
    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "אירעה שגיאה בהשלמת השאלון"
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\update\route.ts:
==================================================
// src/app/api/questionnaire/update/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { answers } = await req.json();

    // קודם נמצא את השאלון של המשתמש
    const existingQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    if (!existingQuestionnaire) {
      return NextResponse.json(
        { success: false, error: "Questionnaire not found" },
        { status: 404 }
      );
    }

    // עכשיו נעדכן אותו עם ה-ID הנכון
    const updatedQuestionnaire = await prisma.questionnaireResponse.update({
      where: {
        id: existingQuestionnaire.id  // משתמשים ב-ID הייחודי
      },
      data: {
        answers: answers,
      }
    });

    return NextResponse.json({
      success: true,
      questionnaireResponse: updatedQuestionnaire,
    });

  } catch (error) {
    console.error("Failed to update questionnaire:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update questionnaire" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\world\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

// Define the WorldId type and validation schema
const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);
type WorldId = z.infer<typeof WorldId>;

// Schema for world answers
const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(z.object({
    questionId: z.string(),
    value: z.union([
      z.string(),
      z.number(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined()
    ]).optional(),
    answeredAt: z.string().datetime()
  }))
});

export async function PUT(req: Request) {
  try {
    // Authenticate user
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    // Parse and validate request body
    const body = await req.json();
    const validatedData = worldAnswersSchema.parse(body);

    // Get existing questionnaire or create new one
    let questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    const updateData: any = {
      lastSaved: new Date()
    };

    // Set answers and completion status based on worldId
    switch (validatedData.worldId) {
      case "VALUES":
        updateData.valuesAnswers = validatedData.answers;
        updateData.valuesCompleted = true;
        break;
      case "PERSONALITY":
        updateData.personalityAnswers = validatedData.answers;
        updateData.personalityCompleted = true;
        break;
      case "RELATIONSHIP":
        updateData.relationshipAnswers = validatedData.answers;
        updateData.relationshipCompleted = true;
        break;
      case "PARTNER":
        updateData.partnerAnswers = validatedData.answers;
        updateData.partnerCompleted = true;
        break;
      case "RELIGION":
        updateData.religionAnswers = validatedData.answers;
        updateData.religionCompleted = true;
        break;
    }

    // Update or create questionnaire
    if (questionnaire) {
      questionnaire = await prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          ...updateData,
          worldsCompleted: Array.from(new Set([
            ...questionnaire.worldsCompleted,
            validatedData.worldId
          ]))
        }
      });
    } else {
      questionnaire = await prisma.questionnaireResponse.create({
        data: {
          userId: session.user.id,
          startedAt: new Date(),
          worldsCompleted: [validatedData.worldId],
          ...updateData
        }
      });
    }

    return NextResponse.json({
      success: true,
      data: questionnaire
    });

  } catch (error: unknown) {
    console.error("Error saving world answers:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "אירעה שגיאה בשמירת התשובות"
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\directory_analysis.txt:
==================================================
מבנה התיקייה:
suggestions
  [id]
    inquiries
      route.ts
    status
      route.ts
  active
    route.ts
  history
    route.ts
  route.ts

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.date(),
});

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Role verification (only matchmakers can create suggestions)
    if (session.user.role !== UserRole.MATCHMAKER) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // 3. Parse and validate request body
    const body = await req.json();
    const validatedData = createSuggestionSchema.parse(body);

    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: "Active suggestion already exists between these parties" },
        { status: 400 }
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id,
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY, // Start with pending first party
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline, // Initial response deadline
          firstPartySent: new Date(), // Mark as sent to first party immediately
          lastStatusChange: new Date(),
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion);

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion,
    });
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { suggestionId, status, notes } = body;

    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 3. Validate status transition
    const isValidTransition = validateStatusTransition(suggestion.status, status);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: "Invalid status transition" },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
        },
      });

      // Create status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes,
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
      // Automatically transition to pending second party
      // TODO: Implement second party notification
    } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      // Automatically share contact details
      // TODO: Implement contact sharing notification
    }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [],
    EXPIRED: [],
    CLOSED: [],
    CANCELLED: []
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\active\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "PENDING_FIRST_PARTY",
                "FIRST_PARTY_APPROVED",
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({
      success: true,
      suggestions: activeSuggestions,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\history\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "FIRST_PARTY_DECLINED",
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        updatedAt: "desc",
      },
    });

    const formattedSuggestions = historySuggestions.map(suggestion => ({
      ...suggestion,
      secondParty: {
        ...suggestion.secondParty,
        profile: {
          ...suggestion.secondParty.profile,
          user: {
            firstName: suggestion.secondParty.firstName,
            lastName: suggestion.secondParty.lastName,
            email: suggestion.secondParty.email,
          }
        }
      }
    }));

    return NextResponse.json({
      success: true,
      suggestions: formattedSuggestions,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts:
==================================================
// src/app/api/suggestions/[id]/inquiries/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { EmailService } from "@/app/components/matchmaker/new/services/email/EmailService";

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { question } = await req.json();

    // Fetch the suggestion to get matchmaker details
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      include: {
        matchmaker: true,
        firstParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          }
        },
        secondParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          }
        },
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // Verify user is authorized to send inquiries for this suggestion
    if (suggestion.firstPartyId !== session.user.id && 
        suggestion.secondPartyId !== session.user.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    // Create the inquiry record
   // בקובץ src/app/api/suggestions/[id]/inquiries/route.ts נעדכן את היחסים:

const inquiry = await prisma.suggestionInquiry.create({
    data: {
      suggestionId: params.id,
      fromUserId: session.user.id,
      toUserId: suggestion.matchmakerId,
      question,
      status: "PENDING",
    },
    include: {
      fromUser: true,
      toUser: true,
      suggestion: true,
    }
  });

    // Send email notification to matchmaker
    const emailTemplate = {
      subject: `שאלה חדשה על הצעת שידוך`,
      body: `
        <div dir="rtl">
          <h2>שלום ${suggestion.matchmaker.firstName},</h2>
          <p>התקבלה שאלה חדשה על הצעת השידוך בין ${suggestion.firstParty.firstName} ל${suggestion.secondParty.firstName}.</p>
          <div style="background: #f5f5f5; padding: 15px; margin: 15px 0; border-radius: 5px;">
            <p style="margin: 0;">${question}</p>
          </div>
          <p>לצפייה בפרטים נוספים ומענה, היכנס/י למערכת.</p>
        </div>
      `,
    };

    await EmailService.getInstance().sendEmail({
      to: suggestion.matchmaker.email,
      subject: emailTemplate.subject,
      html: emailTemplate.body,
    });

    return NextResponse.json({
      success: true,
      inquiry,
    });

  } catch (error) {
    console.error("Error creating inquiry:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\[id]\status\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { statusTransitionService } from "@/app/components/matchmaker/new/services/suggestions/StatusTransitionService";

export async function PATCH(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    // חילוץ הפרמטרים באופן אסינכרוני
    const params = await context.params;
    const suggestionId = params.id;

    // בדיקת אותנטיקציה
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // חילוץ נתונים מה-body
    const body = await req.json();
    const { status, notes } = body;

    // שליפת ההצעה הנוכחית עם כל היחסים הנדרשים
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // וידוא הרשאות המשתמש
    if (suggestion.firstPartyId !== session.user.id && 
        suggestion.secondPartyId !== session.user.id) {
      return NextResponse.json(
        { error: "Unauthorized to update this suggestion" },
        { status: 403 }
      );
    }

    let updatedSuggestion;
    try {
      // עדכון סטטוס ההצעה
      updatedSuggestion = await statusTransitionService.transitionStatus(
        suggestion,
        status,
        notes
      );

      // אם הסטטוס הוא FIRST_PARTY_APPROVED, מעבר אוטומטי ל-PENDING_SECOND_PARTY
      if (status === "FIRST_PARTY_APPROVED") {
        updatedSuggestion = await statusTransitionService.transitionStatus(
          updatedSuggestion,
          "PENDING_SECOND_PARTY",
          "Automatic transition after first party approval"
        );
      } else if (status === "SECOND_PARTY_APPROVED") {
        updatedSuggestion = await statusTransitionService.transitionStatus(
          updatedSuggestion,
          "CONTACT_DETAILS_SHARED",
          "Automatic transition after second party approval"
        );
      }

      return NextResponse.json({
        success: true,
        suggestion: updatedSuggestion,
      });

    } catch (transitionError) {
      console.error("Error in status transition:", transitionError);
      
      // אם היה שגיאה בתהליך המעבר, נחזיר שגיאה מפורטת
      return NextResponse.json({
        error: "Failed to update suggestion status",
        details: transitionError instanceof Error ? transitionError.message : "Unknown error",
      }, { 
        status: 500 
      });
    }

  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json(
      { 
        error: "Internal server error",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.date(),
});

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Role verification (only matchmakers can create suggestions)
    if (session.user.role !== UserRole.MATCHMAKER) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // 3. Parse and validate request body
    const body = await req.json();
    const validatedData = createSuggestionSchema.parse(body);

    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: "Active suggestion already exists between these parties" },
        { status: 400 }
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id,
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY, // Start with pending first party
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline, // Initial response deadline
          firstPartySent: new Date(), // Mark as sent to first party immediately
          lastStatusChange: new Date(),
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion);

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion,
    });
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { suggestionId, status, notes } = body;

    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 3. Validate status transition
    const isValidTransition = validateStatusTransition(suggestion.status, status);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: "Invalid status transition" },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
        },
      });

      // Create status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes,
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
      // Automatically transition to pending second party
      // TODO: Implement second party notification
    } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      // Automatically share contact details
      // TODO: Implement contact sharing notification
    }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [],
    EXPIRED: [],
    CLOSED: [],
    CANCELLED: []
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\active\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "PENDING_FIRST_PARTY",
                "FIRST_PARTY_APPROVED",
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({
      success: true,
      suggestions: activeSuggestions,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\history\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "FIRST_PARTY_DECLINED",
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        updatedAt: "desc",
      },
    });

    const formattedSuggestions = historySuggestions.map(suggestion => ({
      ...suggestion,
      secondParty: {
        ...suggestion.secondParty,
        profile: {
          ...suggestion.secondParty.profile,
          user: {
            firstName: suggestion.secondParty.firstName,
            lastName: suggestion.secondParty.lastName,
            email: suggestion.secondParty.email,
          }
        }
      }
    }));

    return NextResponse.json({
      success: true,
      suggestions: formattedSuggestions,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================