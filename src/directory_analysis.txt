מבנה התיקייה:
src
  .dist
  app
    (authenticated)
      matches
        page.tsx
      matchmaker
        candidates
        clients-למחוק
          ClientsPageContent.tsx
          page.tsx
        dashboard
          page.tsx
      messages
        page.tsx
      profile
        components
          dashboard
            UnifiedProfileDashboard.tsx
        page.tsx
      settings
        page.tsx
    api
      auth
        [...nextauth]
          route.ts
        complete-password-change
          route.ts
        initiate-password-change
          route.ts
        register
          route.ts
        resend-verification
          route.ts
        send-verification
          route.ts
        verify
          route.ts
      availability
        check
          route.ts
      matchmaker
        candidates
          invite
            route.ts
        clients
          route.ts
        dashbord
          ClientCard.tsx
        inquiries
          [id]
            respond
              route.ts
            route.ts
          route.ts
        suggestions
          [id]
            status
              route.ts
          route.ts
      preferences
        route.ts
        update
          route.ts
      profile
        [userId]
          name
            route.ts
          password
            complete
              route.ts
            initiate
              route.ts
          questionnaire
            route.ts
        availability
          route.ts
        images
          [imageId]
            route.ts
          route.ts
        questionnaire
          route.ts
        route.ts
        update
          route.ts
      questionnaire
        complete
          route.ts
        route.ts
        update
          route.ts
        world
          route.ts
      suggestions
        [id]
          delete
            route.ts
          inquiries
            route.ts
          status
            route.ts
        active
          route.ts
        directory_analysis.txt
        history
          route.ts
        route.ts
    auth
      error
        page.tsx
      register
        page.tsx
      signin
        page.tsx
      verify-email
        page.tsx
    components
      auth
        RegisterForm.tsx
        SignInForm.tsx
      matchmaker
        dashboard
          ClientCard.tsx
          MatchmakerDashboard.tsx
          SuggestionCard.tsx
        forms
          AddCandidateForm.tsx
          AddCandidateWizard.tsx
          NewSuggestionForm.tsx
        new
          CandidateCard
            Actions.tsx
            MinimalCard.tsx
            QuickView.tsx
          CandidatesManager
            CandidatesList.tsx
            CandidatesStats.tsx
            SplitView.tsx
            StatsCard.tsx
            index.tsx
          Filters
            ActiveFilters.tsx
            FilterPanel.tsx
            SavedFilters.tsx
            SearchBar.tsx
          NewSuggestionForm
            CandidateSelector.tsx
            MatchPreview.tsx
            SuggestionDetails.tsx
            index.tsx
            schema.ts
          constants
            filterOptions.ts
            matchingCriteria.ts
          dialogs
            ActionDialogs.tsx
          hooks
            filterUtils
            useCandidates.ts
            useFilterLogic.ts
            useMatchmaking.ts
            useStatistics.ts
          services
            email
              EmailService.ts
            suggestions
              StatusTransitionService.ts
              SuggestionService.ts
          shared
            LoadingStates.tsx
            Pagination.tsx
            StatusBadge.tsx
          types
            candidates.ts
            filters.ts
          utils
            matchingAlgorithm.ts
            statisticsCalculator.ts
        suggestions
          container
            MatchmakerDashboard.tsx
            SuggestionActionBar.tsx
            SuggestionsStats.tsx
          details
            SuggestionDetailsDialog.tsx
            SuggestionDetailsView.tsx
          directory_analysis.txt
          list
            ManagerSuggestionsList.tsx
            SuggestionCard.tsx
      messages
        AvailabilityRequestCard.tsx
        MessagesPage.tsx
      shared
        shared
          .dist
          profile
            ProfileCard.tsx
            constants.ts
            elements
              MinimalCard.tsx
              StatsCard.tsx
              VisibilityControl.tsx
            helpers.ts
            index.ts
            sections
              ExtendedProfileSection.tsx
              PhotosSection.tsx
              PreferencesSection.tsx
              ProfileSection.tsx
              QuestionnaireResponsesSection.tsx
            types
              profile.ts
              questionnaire.ts
            utils.ts
      suggestions
        MatchSuggestionsContainer.tsx
        cards
          MinimalSuggestionCard.tsx
          SuggestionQuickView.tsx
        dialogs
          AskMatchmakerDialog.tsx
        list
          SuggestionsList.tsx
    config
      fonts.ts
    contexts
      LanguageContext.tsx
      NotificationContext.tsx
    favicon.ico
    fonts
      GeistMonoVF.woff2
      GeistVF.woff2
    globals.css
    hooks
      useMatchmaker.ts
    layout.tsx
    lib
      auth.ts
      validation
        auth.ts
    metadata.ts
    page.tsx
    questionnaire
      complete
        page.tsx
      page.tsx
      restore
        page.tsx
    types
      matchmaker.ts
      suggestions.ts
  code.py
  components
    AvailabilityStatus.tsx
    HomePage.tsx
    Providers.tsx
    UserSuggestions.tsx
    account-settings.tsx
    layout
      Navbar.tsx
    matchmaker
      AvailabilityCheckButton.tsx
      AvailabilityInquiryResponse.tsx
    questionnaire
      MatchmakingQuestionnaire.tsx
      common
        AnswerInput.tsx
        InteractiveScale.tsx
        QuestionCard.tsx
        QuestionnaireCompletion.tsx
        WorldIntro.tsx
      layout
        NavigationBar.tsx
        ProgressTracker.tsx
        QuestionnaireLayout.tsx
        WorldsMap.tsx
      onboarding
        TrackSelection.tsx
        Welcome.tsx
      questions
        directory_analysis.txt
        partner
          partnerBasicQuestions.tsx
          partnerDepthQuestions.tsx
        personality
          personalityQuestionsPartOne.tsx
          personalityQuestionsPartTwo.tsx
        relationship
          relationshipBasicsQuestions.tsx
          relationshipDepthQuestions.tsx
        religion
          faithQuestions.tsx
          practicalReligionQuestions.tsx
        values
          valuesQuestionsPartOne.tsx
          valuesQuestionsPartTwo.tsx
      types
        types.ts
      utils.ts
      worlds
        PartnerWorld.tsx
        PersonalityWorld.tsx
        RelationshipWorld.tsx
        ReligionWorld.tsx
        ValuesWorld.tsx
      שאלות כלליות
        educationCareer.tsx
        familyBackground.tsx
        lifestyleQuestions.tsx
        partnerPreferences.tsx
        personalityQuestions.tsx
        socialRelations.tsx
        valueQuestions.tsx
    ui
      ProfileModal.tsx
      SimpleToast.tsx
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      checkbox.tsx
      collapsible.tsx
      command.tsx
      dialog.tsx
      dropdown-menu.tsx
      form
        form.tsx
      image-viewer.tsx
      input.tsx
      label.tsx
      loading-spinner.tsx
      multi-select.tsx
      popover.tsx
      progress-indicator.tsx
      progress.tsx
      radio-group.tsx
      resizable.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      skeleton.tsx
      slider.tsx
      split-pane.tsx
      stats-card.tsx
      steps.tsx
      switch.tsx
      tabs.tsx
      textarea.tsx
      timeline.tsx
      toast
        toast.d.ts
        toaster.tsx
        use-toast.ts
      tooltip.tsx
      virtual-grid.tsx
      visually-hidden.tsx
  hooks
    useInterval.ts
    useQuestionnaireSave.ts
  lib
    auth.ts
    db.ts
    email
      emailService.ts
      templates
        availability-check.hbs
        email-verification.hbs
        invitation.hbs
        share-contact-details.hbs
        suggestion.hbs
        welcome.hbs
    prisma.ts
    services
      availabilityService.ts
      questionnaireService.ts
      suggestionService.ts
      verificationService.ts
    tokens.ts
    utils.ts
  middleware.ts
  services
    storageService.ts
    suggestions.ts
  types
    availability.ts
    cloudinary.d.ts
    meetings.ts
    messages.ts
    next-auth.d.ts
    profile-extended.ts
    profile.ts
    suggestions.ts

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\code.py:
==================================================
import os 
from datetime import datetime

# הגדרת הנתיב הקבוע
FIXED_DIRECTORY_PATH = r"C:\Users\eytan\Desktop\שידוכים\shidduch-system\src"

def scan_directory(directory_path):
    """
    Scan a directory and save its structure and file contents to a report file
    
    Args:
        directory_path (str): Path to the directory to scan
    """
    try:
        # Create output file name with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = os.path.join(directory_path, f"directory_scan_{timestamp}.txt")
        
        with open(output_file, 'w', encoding='utf-8') as report:
            # Write directory structure
            report.write("=== Directory Structure ===\n\n")
            for root, dirs, files in os.walk(directory_path):
                # Calculate the current level for indentation
                level = root.replace(directory_path, '').count(os.sep)
                indent = '  ' * level
                
                # Write current directory
                folder_name = os.path.basename(root) or os.path.basename(directory_path)
                report.write(f"{indent}[{folder_name}]\n")
                
                # Write files in current directory
                sub_indent = '  ' * (level + 1)
                for file in files:
                    report.write(f"{sub_indent}{file}\n")
            
            # Write contents of each file
            report.write("\n=== File Contents ===\n")
            for root, dirs, files in os.walk(directory_path):
                for file in files:
                    # Skip the report file itself if it shows up
                    if file == os.path.basename(output_file):
                        continue
                        
                    file_path = os.path.join(root, file)
                    report.write(f"\n--- Content of {file_path} ---\n")
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            report.write(content + "\n")
                    except Exception as e:
                        report.write(f"Could not read file: {str(e)}\n")
        
        print(f"Scan complete! Results saved to: {output_file}")
                    
    except Exception as e:
        print(f"Error during scanning: {str(e)}")

def main():
    if os.path.isdir(FIXED_DIRECTORY_PATH):
        scan_directory(FIXED_DIRECTORY_PATH)
    else:
        print(f"Error: The directory {FIXED_DIRECTORY_PATH} does not exist.")

if __name__ == "__main__":
    main()

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\middleware.ts:
==================================================
import { withAuth } from "next-auth/middleware";
import { NextResponse } from "next/server";

// הגדרת הנתיבים הציבוריים שלא דורשים אימות
const publicPaths = [
  '/auth/signin',
  '/auth/register',
  '/auth/verify-email',
  '/auth/verify',
  '/auth/complete-registration',
  '/api/auth/complete-registration',
  '/availability-response',
  '/api/matchmaker/inquiries'
];

export default withAuth(
  function middleware(req) {
    const token = req.nextauth.token;
    const path = req.nextUrl.pathname;
    
    // בדיקה אם הנתיב הוא ציבורי
    if (publicPaths.some(publicPath => path.startsWith(publicPath))) {
      return NextResponse.next();
    }

    // בדיקת סטטוס משתמש
    if (token?.status === "PENDING") {
      // אם המשתמש לא מאומת ומנסה לגשת לדף מוגן
      if (!path.startsWith("/verify-email")) {
        const email = token.email as string;
        return NextResponse.redirect(
          new URL(`/auth/verify-email?email=${encodeURIComponent(email)}`, req.url)
        );
      }
    }

    return NextResponse.next();
  },
  {
    callbacks: {
      authorized: ({ token, req }) => {
        const path = req.nextUrl.pathname;
        
        // מאפשר גישה לנתיבים ציבוריים
        if (publicPaths.some(publicPath => path.startsWith(publicPath))) {
          return true;
        }
        
        return !!token;
      },
    },
  }
);

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/matches/:path*',
    '/preferences/:path*',
    '/profile/:path*',
    '/matchmaker/:path*',
    '/api/matchmaker/:path*',
    '/api/profile/:path*',
    '/api/preferences/:path*',
    '/api/auth/verify',
    '/auth/complete-registration',
    '/api/auth/complete-registration',
    '/availability-response',
    '/api/matchmaker/inquiries/:path*',

  ]
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\favicon.ico:
==================================================
Error reading file C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\favicon.ico: 'utf-8' codec can't decode byte 0x96 in position 50: invalid start byte

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\globals.css:
==================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {

  /* Direction utilities */
  .dir-rtl {
    direction: rtl;
  }

  .dir-ltr {
    direction: ltr;
  }

  /* Force direction when needed */
  .force-ltr {
    direction: ltr !important;
  }

  .force-rtl {
    direction: rtl !important;
  }

  /* UI Component Direction Fixes */
  [data-radix-popper-content-wrapper] {
    direction: ltr;
  }

  /* Button icon margins for RTL/LTR */
  .dir-rtl .button-icon {
    margin-left: 0.5rem;
    margin-right: 0;
  }

  .dir-ltr .button-icon {
    margin-right: 0.5rem;
    margin-left: 0;
  }

  /* Input and form control adjustments */
  .dir-rtl .input-addon {
    border-right: none;
    border-left: 1px solid var(--border);
  }

  .dir-ltr .input-addon {
    border-left: none;
    border-right: 1px solid var(--border);
  }
}

/* Animation classes */
.form-step-enter {
  opacity: 0;
  transform: translateX(var(--enter-translate, 100%));
}

.form-step-enter-active {
  opacity: 1;
  transform: translateX(0%);
  transition: opacity 300ms, transform 300ms;
}

.form-step-exit {
  opacity: 1;
  transform: translateX(0%);
}

.form-step-exit-active {
  opacity: 0;
  transform: translateX(var(--exit-translate, -100%));
  transition: opacity 300ms, transform 300ms;
}

/* RTL animation adjustments */
.dir-rtl .form-step-enter {
  --enter-translate: -100%;
}

.dir-rtl .form-step-exit-active {
  --exit-translate: 100%;
}

/* Wizard layout */
.wizard-content {
  min-height: 400px;
  position: relative;
  overflow: hidden;
}

/* RTL specific layout adjustments */
.dir-rtl .wizard-navigation {
  margin-left: 0;
  margin-right: auto;
}

.dir-rtl .wizard-controls {
  flex-direction: row-reverse;
}

/* Custom scrollbar for RTL/LTR */
.dir-rtl .custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: var(--primary) transparent;
}

.dir-rtl .custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.dir-rtl .custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.dir-rtl .custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: var(--primary);
  border-radius: 3px;
}

/* Dropdown menu positioning */
.dir-rtl .dropdown-menu {
  transform-origin: top right;
}

.dir-ltr .dropdown-menu {
  transform-origin: top left;
}

/* Toast notifications positioning */
.dir-rtl .toast {
  right: auto;
  left: 1rem;
}

.dir-ltr .toast {
  left: auto;
  right: 1rem;
}

.rtl-tabs [role="tablist"] {
  direction: rtl;
}

.rtl-tabs [role="tabpanel"] {
  direction: rtl;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\layout.tsx:
==================================================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import dynamic from "next/dynamic";
import { cookies } from "next/headers";
import "./globals.css";
import { metadata as siteMetadata } from "./metadata";

interface ProvidersProps {
  children: React.ReactNode;
}

type NavbarProps = Record<string, never>;

interface LanguageProviderProps {
  children: React.ReactNode;
}

const Providers = dynamic<ProvidersProps>(() =>
  import("@/components/Providers").then((mod) => mod.default)
);

const Navbar = dynamic<NavbarProps>(() =>
  import("@/components/layout/Navbar").then((mod) => mod.default)
);

const LanguageProvider = dynamic<LanguageProviderProps>(() =>
  import("@/app/contexts/LanguageContext").then((mod) => mod.LanguageProvider)
);

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
  display: "swap",
});

export const metadata = siteMetadata;

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const cookieStore = await cookies();
  const defaultLanguage = cookieStore.get("language")?.value || "he";

  return (
    <html lang={defaultLanguage} dir={defaultLanguage === "he" ? "rtl" : "ltr"}>
      <body className={`${inter.variable} antialiased`}>
        <Providers>
          <LanguageProvider>
            <div className="min-h-screen flex flex-col">
              <Navbar />
              <main className="flex-1">{children}</main>
            </div>
          </LanguageProvider>
        </Providers>
      </body>
    </html>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\metadata.ts:
==================================================
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "מערכת שידוכים",
  description: "מערכת שידוכים המיועדת לציבור הדתי והחרדי",
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\page.tsx:
==================================================
import HomePage from "@/components/HomePage";

export default function Page() {
  return <HomePage />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matches\page.tsx:
==================================================
"use client";
import { useSession } from "next-auth/react";
import MatchSuggestionsContainer from "@/app/components/suggestions/MatchSuggestionsContainer";
import { Skeleton } from "@/components/ui/skeleton";

export default function MatchesPage() {
  const { data: session, status } = useSession();

  if (status === "loading") {
    return (
      <div className="container mx-auto p-6 space-y-4">
        <Skeleton className="h-48 w-full" />
        <Skeleton className="h-48 w-full" />
      </div>
    );
  }

  if (!session?.user?.id) {
    return <div>לא מורשה לצפות בדף זה</div>;
  }

  return <MatchSuggestionsContainer userId={session.user.id} />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\clients-למחוק\ClientsPageContent.tsx:
==================================================
"use client";

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useNotifications } from "@/app/contexts/NotificationContext";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Label } from "@/components/ui/label";
import { Search, Filter, Users, Plus, Mail } from "lucide-react";
import AddCandidateWizard from "@/app/components/matchmaker/forms/AddCandidateWizard";
import type { Client, ClientStatus } from "@/app/types/matchmaker";
import ClientCard from "@/app/components/matchmaker/dashboard/ClientCard";
import AddCandidateForm from "@/app/components/matchmaker/forms/AddCandidateForm";
import NewSuggestionForm from "@/app/components/matchmaker/forms/NewSuggestionForm";
import {
  AvailabilityStatus,
  Gender,
  UserStatus,
  InvitationStatus,
} from "@prisma/client";
import type { ExtendedClient } from "@/app/types/matchmaker";
// עדכון הממשק ExtendedClient בתחילת הקובץ
import { useInterval } from "@/hooks/useInterval";

export default function ClientsPageContent() {
  const { data: session, status } = useSession();
  const { refreshNotifications } = useNotifications();
  const [clients, setClients] = useState<ExtendedClient[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [showAddCandidateDialog, setShowAddCandidateDialog] = useState(false);
  const [showNewSuggestionDialog, setShowNewSuggestionDialog] = useState(false);
  const [selectedClient, setSelectedClient] = useState<ExtendedClient | null>(
    null
  );
  const [showSendInviteDialog, setShowSendInviteDialog] = useState(false);
  const [inviteEmail, setInviteEmail] = useState("");
  const [clientToInvite, setClientToInvite] = useState<ExtendedClient | null>(
    null
  );

  const [filters, setFilters] = useState({
    gender: "all" as "all" | Gender,
    religiousLevel: "all",
    status: "all" as "all" | ClientStatus,
    hasInvitation: "all" as "all" | "sent" | "pending" | "accepted",
    ageRange: { min: 18, max: 99 },
    availability: "all" as "all" | AvailabilityStatus, // סינון לפי זמינות כללית
    immediateAvailability: "all" as
      | "all"
      | "available"
      | "unavailable"
      | "pending", // סינון לפי זמינות מיידית
  });

  const [showFilters, setShowFilters] = useState(false);
  useEffect(() => {
    if (session?.user) {
      loadClients();
    }
  }, [session]);

  // Helper function to calculate age
  const calculateAge = (birthDate: string) => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birth.getDate())
    ) {
      age--;
    }
    return age;
  };
  const handleCheckAvailability = async (client: ExtendedClient) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ clientId: client.id }),
      });

      if (!response.ok) {
        throw new Error("Failed to check availability");
      }

      await loadClients();
      await refreshNotifications();
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Failed to check availability"
      );
    }
  };
  const loadClients = async () => {
    try {
      setLoading(true);
      setError("");

      if (status === "loading" || !session) {
        return;
      }

      const response = await fetch("/api/matchmaker/clients");
      if (!response.ok) {
        throw new Error(await response.text());
      }
      const data = await response.json();

      const formattedClients = data.clients.map((client: any) => ({
        id: client.id,
        firstName: client.firstName,
        lastName: client.lastName,
        email: client.email,
        gender: client.gender,
        birthDate: client.birthDate,
        status: client.status,
        personalInfo: client.personalInfo || {},
        location: client.location || "",
        lastActive: client.lastActive || new Date().toISOString(),
        contactPreferences: client.contactPreferences || [],
        invitation: client.invitation,
        latestInquiry: client.latestInquiry || null, // הוספת השדה החדש
        profile: client.profile,
      }));

      setClients(formattedClients);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load clients");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadClients();
  }, [session, status]);

  const handleSendInvite = async () => {
    if (!clientToInvite || !inviteEmail) {
      console.error("Missing required data:", { clientToInvite, inviteEmail });
      return;
    }

    try {
      console.log("Sending invitation with data:", {
        clientId: clientToInvite.id,
        email: inviteEmail,
        firstName: clientToInvite.firstName,
        lastName: clientToInvite.lastName,
        // Add all required fields
        gender: clientToInvite.gender,
        birthDate: clientToInvite.birthDate,
        sendInvitation: true,
      });

      const response = await fetch("/api/matchmaker/candidates/invite", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          clientId: clientToInvite.id,
          email: inviteEmail,
          firstName: clientToInvite.firstName,
          lastName: clientToInvite.lastName,
          gender: clientToInvite.gender,
          birthDate: clientToInvite.birthDate,
          sendInvitation: true,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send invitation");
      }

      const data = await response.json();
      console.log("Invitation sent successfully:", data);

      // Clear form and close dialog
      setShowSendInviteDialog(false);
      setClientToInvite(null);
      setInviteEmail("");

      // Optional: Refresh the clients list
      await loadClients();
      await refreshNotifications();
    } catch (error) {
      console.error("Error sending invitation:", error);
      setError(
        error instanceof Error ? error.message : "Failed to send invitation"
      );
    }
  };

  const handleCreateSuggestion = (client: ExtendedClient) => {
    setSelectedClient(client);
    setShowNewSuggestionDialog(true);
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">טוען...</div>
      </div>
    );
  }

  if (error) {
    return (
      <Card className="m-4">
        <CardHeader>
          <CardTitle className="text-red-500">שגיאה</CardTitle>
        </CardHeader>
        <CardContent>
          <p>{error}</p>
          <Button className="mt-4" onClick={() => window.location.reload()}>
            נסה שוב
          </Button>
        </CardContent>
      </Card>
    );
  }

  const filteredClients = clients.filter((client) => {
    // Text search
    if (
      searchQuery &&
      !`${client.firstName} ${client.lastName} ${
        client.personalInfo?.occupation || ""
      } ${client.location}`.includes(searchQuery)
    )
      return false;
    // הוספת סינון לפי זמינות כללית
    if (
      filters.availability !== "all" &&
      client.profile?.availabilityStatus !== filters.availability
    ) {
      return false;
    }

    // הוספת סינון לפי זמינות מיידית
    if (filters.immediateAvailability !== "all") {
      const latestInquiry = client.latestInquiry;
      if (!latestInquiry) return filters.immediateAvailability === "pending";

      if (
        filters.immediateAvailability === "available" &&
        !latestInquiry.firstPartyResponse
      )
        return false;
      if (
        filters.immediateAvailability === "unavailable" &&
        latestInquiry.firstPartyResponse
      )
        return false;
    }

    return true;

    // Gender filter
    if (filters.gender !== "all" && client.gender !== filters.gender)
      return false;

    // Religious level filter
    if (
      filters.religiousLevel !== "all" &&
      client.personalInfo?.religiousLevel !== filters.religiousLevel
    )
      return false;

    // Status filter
    if (filters.status !== "all" && client.status !== filters.status)
      return false;

    // Invitation status filter
    if (filters.hasInvitation !== "all") {
      if (filters.hasInvitation === "sent" && !client.invitation) return false;
      if (
        filters.hasInvitation === "pending" &&
        client.invitation?.status !== "PENDING"
      )
        return false;
      if (
        filters.hasInvitation === "accepted" &&
        client.invitation?.status !== "ACCEPTED"
      )
        return false;
    }

    // Age filter
    const age = calculateAge(client.birthDate);
    if (age < filters.ageRange.min || age > filters.ageRange.max) return false;

    return true;
  });

  return (
    <div className="container mx-auto py-8 px-4">
      <div className="mb-8">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">ניהול מועמדים</h1>
          <Button
            className="bg-green-600 hover:bg-green-700"
            onClick={() => setShowAddCandidateDialog(true)}
          >
            <Plus className="ml-2 h-4 w-4" />
            הוספת מועמד
          </Button>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">{clients.length}</div>
              <div className="text-gray-500">סה"כ מועמדים</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {clients.filter((c) => c.status === "ACTIVE").length}
              </div>
              <div className="text-gray-500">מועמדים פעילים</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {
                  clients.filter((c) => c.invitation?.status === "PENDING")
                    .length
                }
              </div>
              <div className="text-gray-500">הזמנות ממתינות</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {
                  clients.filter((c) => c.invitation?.status === "ACCEPTED")
                    .length
                }
              </div>
              <div className="text-gray-500">הזמנות שאושרו</div>
            </CardContent>
          </Card>
        </div>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <CardTitle>סינון מועמדים</CardTitle>
            <Button
              variant="outline"
              onClick={() => setShowFilters(!showFilters)}
            >
              <Filter className="ml-2 h-4 w-4" />
              {showFilters ? "הסתר סינון" : "הצג סינון"}
            </Button>
          </CardHeader>
          <CardContent>
            <div className="flex gap-4 mb-4">
              <div className="flex-1">
                <Command>
                  <CommandInput
                    placeholder="חיפוש מועמדים..."
                    value={searchQuery}
                    onValueChange={setSearchQuery}
                  />
                  <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                  <CommandGroup>
                    {clients.map((client) => (
                      <CommandItem
                        key={client.id}
                        value={`${client.firstName} ${client.lastName}`}
                        onSelect={(value) => setSearchQuery(value)}
                      >
                        {client.firstName} {client.lastName}
                      </CommandItem>
                    ))}
                  </CommandGroup>
                </Command>
              </div>
            </div>

            {showFilters && (
              <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                  <Select
                    value={filters.gender}
                    onValueChange={(value: typeof filters.gender) =>
                      setFilters((prev) => ({ ...prev, gender: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="מגדר" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="MALE">זכר</SelectItem>
                      <SelectItem value="FEMALE">נקבה</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Select
                    value={filters.religiousLevel}
                    onValueChange={(value) =>
                      setFilters((prev) => ({ ...prev, religiousLevel: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="רמת דתיות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="charedi">חרדי</SelectItem>
                      <SelectItem value="dati">דתי</SelectItem>
                      <SelectItem value="masorti">מסורתי</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Select
                    value={filters.status}
                    onValueChange={(value: typeof filters.status) =>
                      setFilters((prev) => ({ ...prev, status: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="סטטוס" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="ACTIVE">פעיל</SelectItem>
                      <SelectItem value="PAUSED">מושהה</SelectItem>
                      <SelectItem value="INACTIVE">לא פעיל</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Select
                    value={filters.hasInvitation}
                    onValueChange={(value: typeof filters.hasInvitation) =>
                      setFilters((prev) => ({ ...prev, hasInvitation: value }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="סטטוס הזמנה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="sent">נשלחה הזמנה</SelectItem>
                      <SelectItem value="pending">ממתין לאישור</SelectItem>
                      <SelectItem value="accepted">אושר</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredClients.map((client: ExtendedClient) => (
          <ClientCard
            key={client.id}
            client={client}
            onSendInvite={() => {
              setClientToInvite(client);
              setShowSendInviteDialog(true);
            }}
            onSuggest={() => handleCreateSuggestion(client)}
            onCheckAvailability={handleCheckAvailability} // להוסיף שורה זו
          />
        ))}
      </div>

      {filteredClients.length === 0 && (
        <div className="text-center py-12 text-gray-500">
          <Users className="mx-auto h-12 w-12 mb-4" />
          <h3 className="text-lg font-medium">לא נמצאו מועמדים</h3>
          <p>נסה לשנות את הסינון או לחפש משהו אחר</p>
        </div>
      )}

      {showAddCandidateDialog && (
        <AddCandidateWizard
          isOpen={showAddCandidateDialog}
          onClose={() => setShowAddCandidateDialog(false)}
          onSuccess={() => {
            setShowAddCandidateDialog(false);
            loadClients();
          }}
        />
      )}
      <AlertDialog
        open={showSendInviteDialog}
        onOpenChange={setShowSendInviteDialog}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>שליחת הזמנה למועמד</AlertDialogTitle>
            <AlertDialogDescription>
              {clientToInvite && (
                <span>
                  שליחת הזמנה ל: {clientToInvite.firstName}{" "}
                  {clientToInvite.lastName}
                </span>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <div className="py-4">
            <Label htmlFor="invite-email">כתובת אימייל</Label>
            <Input
              id="invite-email"
              type="email"
              value={inviteEmail}
              onChange={(e) => setInviteEmail(e.target.value)}
              placeholder="הזן כתובת אימייל"
              className="mt-2"
            />
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel
              onClick={() => {
                setShowSendInviteDialog(false);
                setClientToInvite(null);
                setInviteEmail("");
              }}
            >
              ביטול
            </AlertDialogCancel>
            <AlertDialogAction onClick={handleSendInvite}>
              <Mail className="ml-2 h-4 w-4" />
              שלח הזמנה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
      {/* Dialog for new suggestion */}
      <Dialog
        open={showNewSuggestionDialog}
        onOpenChange={setShowNewSuggestionDialog}
      >
        <DialogContent className="sm:max-w-[800px]">
          <DialogHeader>
            <DialogTitle>הצעת שידוך חדשה</DialogTitle>
          </DialogHeader>
          <NewSuggestionForm
            isOpen={showNewSuggestionDialog}
            onClose={() => {
              setShowNewSuggestionDialog(false);
              setSelectedClient(null);
            }}
            selectedClient={selectedClient}
            onSubmit={async (data) => {
              try {
                // כאן נוסיף את הלוגיקה של שליחת ההצעה לשרת
                // למשל:
                // await createSuggestion(data);
                setShowNewSuggestionDialog(false);
                setSelectedClient(null);
              } catch (error) {
                console.error("Error creating suggestion:", error);
              }
            }}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\clients-למחוק\page.tsx:
==================================================
import CandidatesManager from "@/app/components/matchmaker/new/CandidatesManager/index";

export default function ClientsPage() {
  return <CandidatesManager />;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\matchmaker\dashboard\page.tsx:
==================================================
"use client";

import { MatchmakerDashboard } from "@/app/components/matchmaker/dashboard/MatchmakerDashboard";

export default function DashboardPage() {
  return <MatchmakerDashboard />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\messages\page.tsx:
==================================================
"use client";

import MessagesPage from "@/app/components/messages/MessagesPage";
import { Card } from "@/components/ui/card";
import { Loader2 } from "lucide-react";
import { Suspense } from "react";

export default function Messages() {
  return (
    <Suspense
      fallback={
        <Card className="m-4">
          <div className="flex justify-center items-center p-8">
            <Loader2 className="h-8 w-8 animate-spin" />
          </div>
        </Card>
      }
    >
      <MessagesPage />
    </Suspense>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\profile\page.tsx:
==================================================
// src/app/(authenticated)/profile/page.tsx
"use client";

import React from "react";
import { useLanguage } from "@/app/contexts/LanguageContext";
import UnifiedProfileDashboard from "./components/dashboard/UnifiedProfileDashboard";

interface ProfilePageProps {
  viewOnly?: boolean;
  userId?: string;
}

const ProfilePage: React.FC<ProfilePageProps> = ({
  viewOnly = false,
  userId,
}) => {
  const { language } = useLanguage();

  return (
    // הוספת direction="rtl" לאלמנט השורש של הדף
    <div className="min-h-screen bg-background" dir="rtl">
      <UnifiedProfileDashboard viewOnly={viewOnly} userId={userId} />
    </div>
  );
};

export default ProfilePage;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\profile\components\dashboard\UnifiedProfileDashboard.tsx:
==================================================
import React, { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { Eye } from "lucide-react";
import { toast } from "sonner";

// UI Components
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

// Shared Profile Components
import {
  ProfileCard,
  PhotosSection,
  ExtendedProfileSection,
  PreferencesSection,
  ProfileSection,
  QuestionnaireResponsesSection,
  StatsCard,
} from "@/app/components/shared/shared/profile";

// Types
import type { UserProfile, UserImage, QuestionnaireResponse, FormattedAnswer } from "@/types/next-auth";

// Stats configuration
import { User, MapPin, Scroll, Clock } from "lucide-react";

const QUICK_STATS = [
  {
    key: "maritalStatus",
    title: "מצב משפחתי",
    icon: User,
    getValue: (profile: UserProfile) => profile.maritalStatus || "לא צוין",
  },
  {
    key: "location",
    title: "מיקום",
    icon: MapPin,
    getValue: (profile: UserProfile) => profile.city || "לא צוין",
  },
  {
    key: "religiousLevel",
    title: "רמת דתיות",
    icon: Scroll,
    getValue: (profile: UserProfile) => profile.religiousLevel || "לא צוין",
  },
  {
    key: "availability",
    title: "סטטוס פניות",
    icon: Clock,
    getValue: (profile: UserProfile) => profile.availabilityStatus || "לא צוין",
  },
];

interface UnifiedProfileDashboardProps {
  viewOnly?: boolean;
  userId?: string;
}

const UnifiedProfileDashboard: React.FC<UnifiedProfileDashboardProps> = ({
  viewOnly = false,
  userId,
}) => {
  // State
  const [profileData, setProfileData] = useState<UserProfile | null>(null);
  const [images, setImages] = useState<UserImage[]>([]);
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [activeTab, setActiveTab] = useState("overview");
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");
  const [isMatchmaker, setIsMatchmaker] = useState(false);
  const [previewOpen, setPreviewOpen] = useState(false);

  const { data: session, update: updateSession } = useSession();

  // Load initial data
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      try {
        // Load profile data
        const profileUrl = userId
          ? `/api/profile?userId=${userId}`
          : "/api/profile";
        const profileResponse = await fetch(profileUrl);
        const profileData = await profileResponse.json();

        if (profileData.success) {
          setProfileData(profileData.profile);
          setImages(profileData.images || []);
        }

        // Load questionnaire data
        const questionnaireUrl = userId
          ? `/api/profile/${userId}/questionnaire`
          : "/api/profile/questionnaire";
        const questionnaireResponse = await fetch(questionnaireUrl);
        const questionnaireData = await questionnaireResponse.json();

        if (
          questionnaireData.success &&
          questionnaireData.questionnaireResponse
        ) {
          setQuestionnaireResponse(questionnaireData.questionnaireResponse);
        }
      } catch (error) {
        console.error("Failed to load profile data:", error);
        toast.error("שגיאה בטעינת הנתונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [userId]);

  // Handlers
  const handleSave = async (formData: Partial<UserProfile>) => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/profile/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await response.json();
      if (data.success) {
        await updateSession();
        setProfileData((prev) => ({ ...prev, ...formData } as UserProfile));
        setIsEditing(false);
        toast.success("הפרופיל עודכן בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה בעדכון הפרופיל");
    } finally {
      setIsLoading(false);
    }
  };

  const handleImageUpload = async (file: File) => {
    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await fetch("/api/profile/images", {
        method: "POST",
        body: formData,
      });

      const data = await response.json();
      if (data.success) {
        setImages((prev) => [...prev, data.image]);
        await updateSession();
        toast.success("התמונה הועלתה בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה בהעלאת התמונה");
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    try {
      const response = await fetch(`/api/profile/images/${imageId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ imageId }),
      });

      const data = await response.json();
      if (data.success) {
        setImages(data.images);
        await updateSession();
        toast.success("התמונה הראשית עודכנה בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה בעדכון התמונה הראשית");
    }
  };

  const handleDeleteImage = async (imageId: string) => {
    try {
      const response = await fetch(`/api/profile/images/${imageId}`, {
        method: "DELETE",
      });

      const data = await response.json();
      if (data.success) {
        setImages((prev) => prev.filter((img) => img.id !== imageId));
        await updateSession();
        toast.success("התמונה נמחקה בהצלחה");
      }
    } catch (error) {
      toast.error("שגיאה במחיקת התמונה");
    }
  };

  const handleQuestionnaireUpdate = async (
    world: string,
    questionId: string,
    value: any
  ) => {
    try {
      const response = await fetch("/api/profile/questionnaire", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ worldKey: world, questionId, value }),
      });

      const data = await response.json();
      if (data.success) {
        setQuestionnaireResponse(data.data);
        toast.success("השאלון עודכן בהצלחה");
      }
    } catch (error) {
      console.error("Failed to update questionnaire:", error);
      toast.error("שגיאה בעדכון השאלון");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen" dir="rtl">
        <p className="text-lg text-muted-foreground">טוען...</p>
      </div>
    );
  }

  return (
    <div className="w-full max-w-7xl mx-auto py-8 px-4" dir="rtl">
      <div className="space-y-6">
        {error && (
          <Alert variant="destructive">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Quick Stats */}
        {profileData && (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            {QUICK_STATS.map((stat) => (
              <StatsCard
                key={stat.key}
                icon={stat.icon}
                title={stat.title}
                value={stat.getValue(profileData)}
              />
            ))}
          </div>
        )}

        {/* Preview Dialog */}
        <div className="flex justify-center my-6">
          <Dialog open={previewOpen} onOpenChange={setPreviewOpen}>
            <DialogTrigger asChild>
              <Button variant="outline" className="px-6 py-2 text-lg gap-2">
                <Eye className="w-5 h-5" />
                תצוגה מקדימה
              </Button>
            </DialogTrigger>
            <DialogContent
              className="w-[90vw] max-w-7xl max-h-[85vh] overflow-y-auto p-6"
              dir="rtl"
            >
              <DialogHeader>
                <DialogTitle>תצוגה מקדימה של הפרופיל</DialogTitle>
                <Select
                  value={isMatchmaker ? "matchmaker" : "candidate"}
                  onValueChange={(value) =>
                    setIsMatchmaker(value === "matchmaker")
                  }
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="candidate">תצוגת מועמד</SelectItem>
                    <SelectItem value="matchmaker">תצוגת שדכן</SelectItem>
                  </SelectContent>
                </Select>
              </DialogHeader>
              {profileData && (
                <ProfileCard
                  profile={profileData}
                  images={images}
                  questionnaire={questionnaireResponse}
                  viewMode={isMatchmaker ? "matchmaker" : "candidate"}
                />
              )}
            </DialogContent>
          </Dialog>
        </div>

        {/* Main Tabs */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="space-y-4"
        >
          <TabsList className="w-full justify-center gap-2" dir="rtl">
            <TabsTrigger value="overview">סקירה כללית</TabsTrigger>
            <TabsTrigger value="extended">פרופיל מורחב</TabsTrigger>
            <TabsTrigger value="photos">תמונות</TabsTrigger>
            <TabsTrigger value="preferences">העדפות</TabsTrigger>
            <TabsTrigger value="questionnaire">תשובות לשאלון</TabsTrigger>
          </TabsList>

          <div className="mt-6">
            <TabsContent value="overview">
              <ProfileSection
                profile={profileData}
                isEditing={isEditing}
                setIsEditing={setIsEditing}
                onSave={handleSave}
                viewOnly={viewOnly}
              />
            </TabsContent>

            <TabsContent value="extended">
              <ExtendedProfileSection
                profile={profileData}
                isEditing={isEditing}
                setIsEditing={setIsEditing}
                onSave={handleSave}
                viewOnly={viewOnly}
              />
            </TabsContent>

            <TabsContent value="photos">
              <PhotosSection
                images={images}
                isUploading={isLoading}
                disabled={viewOnly}
                onUpload={handleImageUpload}
                onSetMain={handleSetMainImage}
                onDelete={handleDeleteImage}
              />
            </TabsContent>

            <TabsContent value="preferences">
              <PreferencesSection
                profile={profileData}
                isEditing={isEditing}
                setIsEditing={setIsEditing}
                onChange={handleSave}
                viewOnly={viewOnly}
              />
            </TabsContent>

            <TabsContent value="questionnaire">
              {questionnaireResponse ? (
                <QuestionnaireResponsesSection
                  questionnaire={questionnaireResponse}
                  onUpdate={handleQuestionnaireUpdate}
                  isEditable={!viewOnly}
                  viewMode={isMatchmaker ? "matchmaker" : "candidate"}
                />
              ) : (
                <div className="text-center py-8 text-muted-foreground">
                  לא נמצאו תשובות לשאלון
                </div>
              )}
            </TabsContent>
          </div>
        </Tabs>
      </div>
    </div>
  );
};

export default UnifiedProfileDashboard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\(authenticated)\settings\page.tsx:
==================================================
"use client";

import { useSession } from "next-auth/react";
import AccountSettings from "@/components/account-settings";

export default function SettingsPage() {
  const { data: session, status } = useSession();

  if (status === "loading") return <div>Loading...</div>;
  if (status === "unauthenticated") return <div>Access Denied</div>;
  if (!session?.user) return <div>Error: No user data</div>;

  const userData = {
    id: session.user.id,
    email: session.user.email,
    firstName: session.user.firstName,
    lastName: session.user.lastName,
    role: session.user.role,
    status: session.user.status,
    isVerified: session.user.isVerified,
    lastLogin: session.user.lastLogin,
    createdAt: session.user.createdAt,
  };

  return <AccountSettings user={userData} />;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\complete-password-change\route.ts:
==================================================
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, VerificationStatus } from "@prisma/client";

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // מציאת הטוקן
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "קוד לא תקף או שפג תוקפו" },
        { status: 400 }
      );
    }

    const { hashedNewPassword } = verification.metadata as { hashedNewPassword: string };

    // עדכון הסיסמה והשלמת האימות
    await db.$transaction([
      // עדכון סיסמה
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // עדכון סטטוס האימות
      db.verification.update({
        where: { id: verification.id },
        data: { status: "COMPLETED" }
      })
    ]);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בהשלמת שינוי הסיסמה" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\initiate-password-change\route.ts:
==================================================
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { generateToken } from "@/lib/tokens";
import { emailService } from "@/lib/email/emailService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: Request) {
  try {
    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    // בדיקת סיסמה נוכחית
    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "סיסמה נוכחית שגויה" },
        { status: 400 }
      );
    }

    // הצפנת הסיסמה החדשה
    const hashedNewPassword = await hash(newPassword, 12);

    // ביטול אימותים קודמים
    await db.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING"
      },
      data: {
        status: "EXPIRED"
      }
    });

    const token = await generateToken();

    // יצירת רשומת אימות חדשה
    await db.verification.create({
      data: {
        token,
        userId: user.id,
        type: VerificationType.PASSWORD_RESET,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 שעות
        status: "PENDING",
        metadata: { hashedNewPassword }
      }
    });

    // שליחת מייל עם קוד האימות
    await emailService.sendPasswordReset(user.email, token);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בתהליך שינוי הסיסמה" },
      { status: 500 }
    );
  }
   }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\register\route.ts:
==================================================
import { NextResponse } from 'next/server';
import { PrismaClient, UserRole, Gender, UserStatus, Prisma, VerificationType } from '@prisma/client';
import { hash } from 'bcryptjs';
import { randomBytes } from 'crypto';
import { emailService } from '@/lib/email/emailService';

const prisma = new PrismaClient();

interface RegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  gender: Gender;
  birthDate: string;
  maritalStatus?: string;
  height?: number;
  occupation?: string;
  education?: string;
  invitationToken?: string;
  phone?: string;
}

function handleError(error: unknown): { message: string; status: number } {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002': return { message: 'משתמש עם פרטים אלה כבר קיים במערכת', status: 409 };
      case 'P2014': return { message: 'שגיאה בנתונים שהוזנו', status: 400 };
      default: return { message: 'שגיאה בשמירת הנתונים', status: 500 };
    }
  } 
  
  if (error instanceof Error) {
    return { message: error.message, status: 400 };
  }

  return { message: 'אירעה שגיאה בלתי צפויה', status: 500 };
}

export async function POST(req: Request) {
  console.log('Starting registration process...');
  
  try {
    const body: RegistrationData = await req.json();
    console.log('Registration data received:', {
      ...body,
      password: '[REDACTED]'
    });

    if (body.invitationToken) {
      const invitation = await prisma.invitation.findUnique({
        where: { token: body.invitationToken }
      });

      if (!invitation) throw new Error("קישור ההזמנה אינו תקין");
      if (invitation.expires < new Date()) throw new Error("קישור ההזמנה פג תוקף");
      if (invitation.status !== "PENDING") throw new Error("ההזמנה כבר נוצלה או בוטלה");
    }

    if (!body.email || !body.password || !body.firstName || !body.lastName || !body.gender || !body.birthDate) {
      throw new Error('חסרים פרטים חובה');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      throw new Error('כתובת אימייל לא תקינה');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      throw new Error('הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר');
    }

    const birthDateObj = new Date(body.birthDate);
    const age = Math.floor((new Date().getTime() - birthDateObj.getTime()) / 31557600000);
    if (age < 18) {
      throw new Error('גיל מינימלי להרשמה הוא 18');
    }

    const hashedPassword = await hash(body.password, 12);
    
    const result = await prisma.$transaction(async (tx) => {
      const user = await tx.user.create({
        data: {
          email: body.email,
          password: hashedPassword,
          firstName: body.firstName,
          lastName: body.lastName,
          role: UserRole.CANDIDATE,
          status: UserStatus.PENDING,
          isVerified: false,
          profile: {
            create: {
              gender: body.gender,
              birthDate: birthDateObj,
              maritalStatus: body.maritalStatus || null,
              height: body.height || null,
              occupation: body.occupation || null,
              education: body.education || null,
              isProfileVisible: true
            }
          }
        }
      });

      if (body.invitationToken) {
        await tx.invitation.update({
          where: { token: body.invitationToken },
          data: {
            status: "ACCEPTED",
            userId: user.id
          }
        });
      }

      const verification = await tx.verification.create({
        data: {
          userId: user.id,
          type: VerificationType.EMAIL,
          token: randomBytes(32).toString('hex'),
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
          status: 'PENDING',
          attempts: 0
        }
      });

      return { user, verification };
    });

    try {
      await emailService.sendWelcomeEmail({
        email: result.user.email,
        firstName: result.user.firstName,
        requiresVerification: true,
        dashboardUrl: '/profile',
        supportEmail: process.env.SUPPORT_EMAIL || 'support@example.com',
        privacyNote: true
      });

      await emailService.sendVerificationEmail({
        email: result.user.email,
        verificationLink: result.verification.token,
        firstName: result.user.firstName,
        expiresIn: '24 שעות'
      });
    } catch (emailError) {
      return NextResponse.json(
        {
          success: true,
          message: 'ההרשמה הושלמה בהצלחה, אך היתה בעיה בשליחת המייל. נא ליצור קשר עם התמיכה.',
          userId: result.user.id,
          requiresVerification: true
        },
        { status: 201 }
      );
    }

    return NextResponse.json(
      {
        success: true,
        message: 'ההרשמה הושלמה בהצלחה. נשלח אליך מייל לאימות החשבון',
        userId: result.user.id,
        requiresVerification: true
      },
      { status: 201 }
    );
    
  } catch (error) {
    const errorDetails = error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    } : { message: String(error) };

    console.error('Registration error:', errorDetails);
    
    const { message, status } = handleError(error);
    
    return NextResponse.json(
      { 
        success: false,
        error: message,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status }
    );
  } finally {
    await prisma.$disconnect();
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\resend-verification\route.ts:
==================================================
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { randomBytes } from "crypto";
import { emailService } from "@/lib/email/emailService";
import { VerificationType } from "@prisma/client";

export async function POST(req: Request) {
  try {
    const { email, type } = await req.json();

    if (!email || !type) {
      return NextResponse.json(
        { error: "חסרים פרטים נדרשים" },
        { status: 400 }
      );
    }

    // מציאת המשתמש
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { error: "לא נמצא משתמש עם כתובת האימייל הזו" },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { error: "המשתמש כבר מאומת" },
        { status: 400 }
      );
    }

    // יצירת טוקן אימות חדש
    const verification = await prisma.verification.create({
      data: {
        userId: user.id,
        type: type as VerificationType,
        token: randomBytes(32).toString('hex'),
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // תוקף ל-24 שעות
        status: 'PENDING',
        attempts: 0
      }
    });

    // שליחת מייל אימות חדש
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationLink: verification.token,
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({
      success: true,
      message: "מייל אימות חדש נשלח בהצלחה"
    });

  } catch (error) {
    console.error('Resend verification error:', error);
    const errorMessage = error instanceof Error ? error.message : "שגיאה בשליחת מייל האימות";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\send-verification\route.ts:
==================================================
export const runtime = 'nodejs';

import { NextResponse } from "next/server";
import { PrismaClient, VerificationType } from "@prisma/client";
import { generateToken } from "@/lib/tokens";
import { emailService } from "@/lib/email/emailService";

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { email } = await req.json();
    
    if (!email) {
      return NextResponse.json({ error: "אימייל הוא שדה חובה" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return NextResponse.json({ error: "משתמש לא נמצא" }, { status: 404 });
    }

    await prisma.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.EMAIL,
        status: "PENDING"
      },
      data: { status: "EXPIRED" }
    });

    const token = await generateToken();
    const verification = await prisma.verification.create({
      data: {
        token,
        userId: user.id,
        type: VerificationType.EMAIL,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
        status: "PENDING"
      }
    });

    await emailService.sendVerificationEmail({
      email: user.email,
      verificationLink: verification.token,
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({ success: true }, { status: 200 });

  } catch (error) {
    return NextResponse.json({ error: "שגיאה בשליחת קוד האימות" }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\verify\route.ts:
==================================================
import { NextResponse } from "next/server";
import { VerificationService } from "@/lib/services/verificationService";
import prisma from "@/lib/prisma";
import { UserStatus, VerificationType } from '@prisma/client';

export async function POST(req: Request) {
  try {
    const { token, type } = await req.json();

    // ולידציה של הקלט
    if (!token || !type) {
      return NextResponse.json(
        { error: "חסרים פרטים נדרשים" },
        { status: 400 }
      );
    }

    if (!Object.values(VerificationType).includes(type)) {
      return NextResponse.json(
        { error: "סוג אימות לא חוקי" },
        { status: 400 }
      );
    }

    // אימות הטוקן ועדכון סטטוס המשתמש
    const verification = await VerificationService.verifyToken(token, type);

    // עדכון סטטוס המשתמש ל-ACTIVE
    await prisma.user.update({
      where: { id: verification.userId },
      data: {
        status: UserStatus.ACTIVE,
        isVerified: true
      }
    });

    return NextResponse.json({
      success: true,
      message: "האימות הושלם בהצלחה",
      user: {
        id: verification.userId,
        isVerified: true,
        status: UserStatus.ACTIVE
      }
    });

  } catch (error) {
    console.error('Verification error:', error);
    const errorMessage = error instanceof Error ? error.message : "שגיאה באימות";
    return NextResponse.json({ error: errorMessage }, { status: 400 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\auth\[...nextauth]\route.ts:
==================================================
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

console.log('NextAuth route initialization');
const handler = NextAuth(authOptions);
console.log('NextAuth handler created');

export { handler as GET, handler as POST };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\availability\check\route.ts:
==================================================
// src/app/api/availability/check/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { clientId } = await req.json();

    const result = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId: clientId,
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error("Error checking availability:", error);
    return NextResponse.json(
      { error: "Failed to check availability" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\candidates\invite\route.ts:
==================================================
// src/app/api/matchmaker/candidates/invite/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, InvitationStatus, UserStatus } from "@prisma/client";
import { emailService } from '@/lib/email/emailService';
import type { CustomSession } from "@/types/next-auth";
import crypto from 'crypto';

interface CreateCandidateData {
  firstName: string;
  lastName: string;
  email: string;
  gender: Gender;
  birthDate: string;
  personalInfo?: {
    height?: number;
    maritalStatus?: string;
    occupation?: string;
    education?: string;
    religiousLevel?: string;
    city?: string;
  };
  matchingNotes?: string;
}

export async function POST(req: Request) {
  try {
    // Session validation
    const session = await getServerSession(authOptions) as CustomSession | null;

    if (!session?.user?.id || session.user.role !== 'MATCHMAKER') {
      console.log('Unauthorized attempt:', { session });
      return NextResponse.json({ error: "Unauthorized - Matchmaker access only" }, { status: 401 });
    }

    // Parse and validate request data
    const data: CreateCandidateData = await req.json();
    console.log('Received data:', { ...data, password: '[REDACTED]' });

    // Validate required fields
    if (!data.firstName || !data.lastName || !data.gender || !data.birthDate) {
      console.log('Missing required fields:', { data });
      return NextResponse.json({ 
        error: "Missing required fields", 
        details: {
          firstName: !data.firstName,
          lastName: !data.lastName,
          gender: !data.gender,
          birthDate: !data.birthDate
        }
      }, { status: 400 });
    }

    // Email validation if provided
    if (data.email && !data.email.includes('@')) {
      return NextResponse.json({ error: "Invalid email format" }, { status: 400 });
    }

    // Check for existing user with same email
    if (data.email) {
      const existingUser = await prisma.user.findUnique({
        where: { email: data.email }
      });

      if (existingUser) {
        return NextResponse.json({ error: "Email already registered" }, { status: 400 });
      }
    }

    // Generate temporary email if not provided
    const userEmail = data.email || `pending_${crypto.randomUUID()}@pending.com`;

    // Generate invitation token
    const invitationToken = crypto.randomUUID();

    // Create metadata object
    const metadataObject = {
      firstName: data.firstName,
      lastName: data.lastName,
      gender: data.gender,
      birthDate: data.birthDate,
      personalInfo: data.personalInfo || {},
      matchingNotes: data.matchingNotes
    };

    // Start transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: userEmail,
          password: crypto.randomBytes(32).toString('hex'), // temporary password
          firstName: data.firstName,
          lastName: data.lastName,
          gender: data.gender,
          birthDate: new Date(data.birthDate),
          status: UserStatus.PENDING,
          isVerified: false
        }
      });

      // Create profile
      await tx.profile.create({
        data: {
          userId: user.id,
          height: data.personalInfo?.height || null,
          maritalStatus: data.personalInfo?.maritalStatus || null,
          occupation: data.personalInfo?.occupation || null,
          education: data.personalInfo?.education || null,
          religiousLevel: data.personalInfo?.religiousLevel || null,
          city: data.personalInfo?.city || null,
          isProfileVisible: true,
          allowDirectMessages: true
        }
      });

      // Create invitation
      const invitation = await tx.invitation.create({
        data: {
          matchmakerId: session.user.id,
          email: data.email || '',
          token: invitationToken,
          status: InvitationStatus.PENDING,
          expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
          metadata: metadataObject,
          userId: user.id // Link to the created user
        }
      });

      return { user, invitation };
    });

    // Send invitation email if email provided
    if (data.email) {
      try {
        await emailService.sendInvitation({
          email: data.email,
          invitationLink: invitationToken, // שולחים רק את הטוקן
          matchmakerName: `${session.user.firstName} ${session.user.lastName}`,
          expiresIn: '7 ימים'
        });
      } catch (emailError) {
        console.error('Failed to send invitation email:', emailError);
        // Continue with success response even if email fails
        return NextResponse.json({
          success: true,
          warning: "User created but failed to send invitation email",
          data: {
            user: {
              id: result.user.id,
              email: result.user.email,
              firstName: result.user.firstName,
              lastName: result.user.lastName
            },
            invitation: {
              id: result.invitation.id,
              token: result.invitation.token,
              email: result.invitation.email,
              expires: result.invitation.expires
            }
          }
        }, { status: 201 });
      }
    }


    return NextResponse.json({
      success: true,
      data: {
        user: {
          id: result.user.id,
          email: result.user.email,
          firstName: result.user.firstName,
          lastName: result.user.lastName
        },
        invitation: {
          id: result.invitation.id,
          token: result.invitation.token,
          email: result.invitation.email,
          expires: result.invitation.expires
        }
      }
    }, { status: 201 });

  } catch (error) {
    console.error('Error creating invitation:', error);
    return NextResponse.json({
      error: "Failed to create invitation",
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\clients\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401 }
      );
    }

    // שליפת כל המועמדים הפעילים שיש להם פרופיל
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE',
        profile: {
          isNot: null  // רק משתמשים עם פרופיל
        }
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        isVerified: true,
        images: {
          select: {
            id: true,
            url: true,
            isMain: true
          }
        },
        profile: {
          select: {
            id: true,
            gender: true,
            birthDate: true,
            nativeLanguage: true,
            additionalLanguages: true,
            height: true,
            maritalStatus: true,
            occupation: true,
            education: true,
            address: true,
            city: true,
            origin: true,
            religiousLevel: true,
            about: true,
            hobbies: true,
            parentStatus: true,
            siblings: true,
            position: true,
            preferredAgeMin: true,
            preferredAgeMax: true,
            preferredHeightMin: true,
            preferredHeightMax: true,
            preferredReligiousLevels: true,
            preferredLocations: true,
            preferredEducation: true,
            preferredOccupations: true,
            contactPreference: true,
            referenceName1: true,
            referencePhone1: true,
            referenceName2: true,
            referencePhone2: true,
            isProfileVisible: true,
            preferredMatchmakerGender: true,
            matchingNotes: true,
            verifiedBy: true,
            availabilityStatus: true,
            availabilityNote: true,
            availabilityUpdatedAt: true,
            lastActive: true,
            createdAt: true,
            updatedAt: true
          }
        }
      }
    });

    const formattedUsers = users.map(user => ({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      status: user.status,
      isVerified: user.isVerified,
      images: user.images,
      profile: {
        ...user.profile,
        birthDate: user.profile?.birthDate,
        lastActive: user.profile?.lastActive?.toISOString(),
        availabilityUpdatedAt: user.profile?.availabilityUpdatedAt?.toISOString(),
        createdAt: user.profile?.createdAt?.toISOString(),
        updatedAt: user.profile?.updatedAt?.toISOString(),
        user: {
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email
        }
      }
    }));

    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: formattedUsers,
        count: formattedUsers.length
      }),
      { status: 200 }
    );

  } catch (error: any) {
    console.error('Profile fetch error:', error.message || 'Unknown error');
    return new NextResponse(
      JSON.stringify({ 
        success: false,
        error: error.message || 'Internal server error' 
      }),
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\dashbord\ClientCard.tsx:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\inquiries\route.ts:
==================================================
// src/app/api/matchmaker/inquiries/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { emailService } from '@/lib/email/emailService';
import { AvailabilityService } from '@/lib/services/availabilityService';

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status") as 'pending' | 'completed' | 'expired' | undefined;
    const orderBy = searchParams.get("orderBy") as 'createdAt' | 'updatedAt' | undefined;
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : undefined;

    const inquiries = await AvailabilityService.getAllInquiries(session.user.id, {
      status,
      orderBy,
      limit
    });

    return NextResponse.json(inquiries);
  } catch (error) {
    console.error("Error fetching inquiries:", error);
    return NextResponse.json(
      { error: "Failed to fetch inquiries" },
      { status: 500 }
    );
  }
}

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { firstPartyId, secondPartyId, note } = await req.json();

    const inquiry = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId,
      secondPartyId,
      note
    });

    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error creating inquiry:", error);
    return NextResponse.json(
      { error: "Failed to create inquiry" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts:
==================================================
// src/app/api/matchmaker/inquiries/[id]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    return NextResponse.json(
      { error: "Failed to fetch inquiry" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts:
==================================================
// src/app/api/matchmaker/inquiries/[id]/respond/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { isAvailable, note } = await req.json();

    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note
    });

    return NextResponse.json(updatedInquiry);
  } catch (error) {
    console.error("Error updating inquiry response:", error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : "Failed to update response"
      },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\suggestions\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Session } from "next-auth";
import { MatchSuggestionStatus } from "@prisma/client";
import { suggestionService } from "@/app/components/matchmaker/new/services/suggestions/SuggestionService";
import { emailService } from "@/lib/email/emailService";
import type { CreateSuggestionData } from "@/app/types/suggestions";

const getSuggestionCategory = (status: MatchSuggestionStatus) => {
 switch (status) {
   case 'DRAFT':
   case 'AWAITING_MATCHMAKER_APPROVAL':
   case 'PENDING_FIRST_PARTY':
   case 'PENDING_SECOND_PARTY':
     return 'PENDING';
   
   case 'FIRST_PARTY_DECLINED':
   case 'SECOND_PARTY_DECLINED':
   case 'MATCH_DECLINED':
   case 'ENDED_AFTER_FIRST_DATE':
   case 'ENGAGED':
   case 'MARRIED':
   case 'EXPIRED':
   case 'CLOSED':
   case 'CANCELLED':
     return 'HISTORY';
   
   default:
     return 'ACTIVE';
 }
};

export async function POST(req: Request) {
 try {
   const session = await getServerSession(authOptions) as Session | null;
   
   if (!session?.user?.id || session.user.role !== 'MATCHMAKER') {
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
   }

   const data = await req.json();
   
   const suggestionData: CreateSuggestionData = {
     ...data,
     matchmakerId: session.user.id,
   };

   const suggestion = await suggestionService.createSuggestion(suggestionData);
   
   return NextResponse.json(suggestion);
   
 } catch (error) {
   console.error('Error creating suggestion:', error);
   return NextResponse.json(
     { error: 'Failed to create suggestion' },
     { status: 500 }
   );
 }
}

export async function GET(req: Request) {
 try {
   const session = await getServerSession(authOptions) as Session | null;
   
   if (!session?.user?.id) {
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
   }

   const { searchParams } = new URL(req.url);
   const status = searchParams.get("status");
   const priority = searchParams.get("priority");
   const timeframe = searchParams.get("timeframe");

   const where: any = {};
   
   if (session.user.role === 'MATCHMAKER') {
     where.matchmakerId = session.user.id;
   } else {
     where.OR = [
       { firstPartyId: session.user.id },
       { secondPartyId: session.user.id }
     ];
   }

   if (status) where.status = status;
   if (priority) where.priority = priority;

   if (timeframe) {
     const date = new Date();
     switch (timeframe) {
       case 'today':
         date.setHours(0, 0, 0, 0);
         where.createdAt = { gte: date };
         break;
       case 'week':
         date.setDate(date.getDate() - 7);
         where.createdAt = { gte: date };
         break;
       case 'month':
         date.setMonth(date.getMonth() - 1);
         where.createdAt = { gte: date };
         break;
     }
   }

   const suggestions = await prisma.matchSuggestion.findMany({
     where,
     include: {
       firstParty: {
         select: {
           id: true,
           email: true,
           firstName: true,
           lastName: true,
           status: true,
           isVerified: true,
           images: {
             select: {
               id: true,
               url: true,
               isMain: true
             }
           },
           profile: true
         }
       },
       secondParty: {
         select: {
           id: true,
           email: true,
           firstName: true,
           lastName: true,
           status: true,
           isVerified: true,
           images: {
             select: {
               id: true,
               url: true,
               isMain: true
             }
           },
           profile: true
         }
       },
       matchmaker: {
         select: {
           id: true,
           firstName: true,
           lastName: true,
           role: true
         }
       },
       statusHistory: true,
       meetings: true
     },
     orderBy: {
       lastActivity: 'desc'
     }
   });

   const formattedSuggestions = suggestions.map(suggestion => ({
     ...suggestion,
     category: getSuggestionCategory(suggestion.status),
     firstParty: {
       ...suggestion.firstParty,
       profile: suggestion.firstParty.profile ? {
         ...suggestion.firstParty.profile,
         birthDate: suggestion.firstParty.profile.birthDate?.toISOString(),
         lastActive: suggestion.firstParty.profile.lastActive?.toISOString(),
         availabilityUpdatedAt: suggestion.firstParty.profile.availabilityUpdatedAt?.toISOString(),
         createdAt: suggestion.firstParty.profile.createdAt?.toISOString(),
         updatedAt: suggestion.firstParty.profile.updatedAt?.toISOString()
       } : null
     },
     secondParty: {
       ...suggestion.secondParty,
       profile: suggestion.secondParty.profile ? {
         ...suggestion.secondParty.profile,
         birthDate: suggestion.secondParty.profile.birthDate?.toISOString(),
         lastActive: suggestion.secondParty.profile.lastActive?.toISOString(),
         availabilityUpdatedAt: suggestion.secondParty.profile.availabilityUpdatedAt?.toISOString(),
         createdAt: suggestion.secondParty.profile.createdAt?.toISOString(),
         updatedAt: suggestion.secondParty.profile.updatedAt?.toISOString()
       } : null
     },
     statusHistory: suggestion.statusHistory.map(history => ({
       ...history,
       createdAt: history.createdAt.toISOString()
     })),
     meetings: suggestion.meetings.map(meeting => ({
       ...meeting,
       createdAt: meeting.createdAt.toISOString(),
       updatedAt: meeting.updatedAt.toISOString()
     })),
     createdAt: suggestion.createdAt.toISOString(),
     updatedAt: suggestion.updatedAt.toISOString(),
     lastActivity: suggestion.lastActivity.toISOString()
   }));

   return NextResponse.json(formattedSuggestions);
   
 } catch (error) {
   console.error('Error fetching suggestions:', error);
   return NextResponse.json(
     { error: 'Failed to fetch suggestions' },
     { status: 500 }
   );
 }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { MatchSuggestionStatus, PrismaClient } from "@prisma/client";
import { z } from "zod";
import { suggestionService } from "@/app/components/matchmaker/new/services/suggestions/SuggestionService";

// Initialize Prisma Client
const prisma = new PrismaClient();

// Validation schema for status update
const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

// Validation schema for history query parameters
const getHistorySchema = z.object({
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().min(1).max(100).optional().default(50),
});

/**
 * PATCH endpoint for updating suggestion status
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Request validation
    const body = await req.json();
    const { status, notes } = updateStatusSchema.parse(body);

    // 3. Update suggestion status
    const updatedSuggestion = await suggestionService.updateSuggestionStatus(
      params.id,
      status,
      session.user.id,
      notes
    );

    return NextResponse.json({
      message: "Status updated successfully",
      suggestion: updatedSuggestion,
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint for fetching suggestion history
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse URL parameters
    const searchParams = new URL(req.url).searchParams;
    const queryParams = getHistorySchema.parse({
      startDate: searchParams.get("startDate"),
      endDate: searchParams.get("endDate"),
      limit: searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : undefined,
    });

    // 3. Check viewing permissions
    const suggestion = await suggestionService.getSuggestionDetails(params.id, session.user.id);
    
    // 4. Build history query
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(queryParams.startDate && {
          createdAt: {
            gte: new Date(queryParams.startDate),
            ...(queryParams.endDate && {
              lte: new Date(queryParams.endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            secondParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            matchmaker: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc" as const,
      },
      take: queryParams.limit,
    };

    // 5. Fetch status change history
    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    // 6. Format results
    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    if (error instanceof Error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * HEAD endpoint for getting status summary
 */
export async function HEAD(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return new Response(null, { status: 401 });
    }

    // 2. Fetch suggestion details
    const suggestion = await suggestionService.getSuggestionDetails(params.id, session.user.id);

    // 3. Prepare headers
    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    // Add lastStatusChange header only if it exists
    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\preferences\route.ts:
==================================================
// src/app/api/preferences/route.ts
import { getServerSession } from 'next-auth/next';
import { NextResponse } from 'next/server';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { CustomSession } from '@/types/next-auth';

// טיפוסים
interface PrioritiesObject {
  [key: string]: number;
}

interface FormattedPreferences {
  ageRange: {
    min: number;
    max: number;
  };
  heightRange: {
    min: number;
    max: number;
  };
  religiousLevels: string[];
  locations: string[];
  maritalStatuses: string[];
  preferences: Array<{
    criteria: string;
    importance: number;
    isRequired: boolean;
  }>;
  dealBreakers: string[];
  origins: string[];
}

interface PreferencesData extends Omit<Prisma.MatchPreferencesCreateInput, 'user'> {
  ageRange: number[];
  heightRange: number[];
  religiousLevel: string[];
  location: string[];
  origin: string[];
  maritalStatus: string[];
  priorities: PrioritiesObject;
  dealBreakers: string[];
}

export async function GET(req: Request) {
  try {
    // בדיקת הרשאות
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // שליפת ההעדפות מה-database
    const preferences = await prisma.matchPreferences.findUnique({
      where: {
        userId: session.user.id,
      },
    });

    if (!preferences) {
      return new NextResponse(
        JSON.stringify({ 
          message: 'No preferences found',
          preferences: null 
        }),
        { 
          status: 404,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // המרת ה-priorities ל-object תקין
    const priorities = preferences.priorities as PrioritiesObject;
    const dealBreakers = Array.isArray(preferences.dealBreakers) 
      ? preferences.dealBreakers 
      : [];

    // המרת הנתונים לפורמט המתאים לממשק המשתמש
    const formattedPreferences: FormattedPreferences = {
      ageRange: {
        min: preferences.ageRange[0],
        max: preferences.ageRange[1],
      },
      heightRange: {
        min: preferences.heightRange[0],
        max: preferences.heightRange[1],
      },
      religiousLevels: preferences.religiousLevel,
      locations: preferences.location,
      maritalStatuses: preferences.maritalStatus,
      preferences: Object.entries(priorities).map(([criteria, importance]) => ({
        criteria,
        importance: Number(importance),
        isRequired: dealBreakers.includes(criteria),
      })),
      dealBreakers: preferences.dealBreakers,
      origins: preferences.origin,
    };

    return new NextResponse(
      JSON.stringify(formattedPreferences),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error fetching preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בטעינת ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

export async function PUT(req: Request) {
  try {
    // בדיקת הרשאות
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    const data = await req.json();

    // וולידציה של הנתונים
    if (!data.ageRange || !data.heightRange) {
      return new NextResponse(
        JSON.stringify({ error: 'Missing required fields' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // בדיקת תקינות טווחי גיל וגובה
    if (
      data.ageRange.min < 18 || 
      data.ageRange.max > 120 || 
      data.ageRange.min > data.ageRange.max
    ) {
      return new NextResponse(
        JSON.stringify({ error: 'Invalid age range' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    if (
      data.heightRange.min < 140 || 
      data.heightRange.max > 220 || 
      data.heightRange.min > data.heightRange.max
    ) {
      return new NextResponse(
        JSON.stringify({ error: 'Invalid height range' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // המרת הנתונים לפורמט המתאים ל-database
    const preferencesData: PreferencesData = {
      ageRange: [data.ageRange.min, data.ageRange.max],
      heightRange: [data.heightRange.min, data.heightRange.max],
      religiousLevel: data.religiousLevels || [],
      location: data.locations || [],
      origin: data.origins || [],
      maritalStatus: data.maritalStatuses || [],
      priorities: data.preferences.reduce((acc: PrioritiesObject, pref: any) => {
        acc[pref.criteria] = pref.importance;
        return acc;
      }, {}),
      dealBreakers: data.preferences
        .filter((pref: any) => pref.isRequired)
        .map((pref: any) => pref.criteria)
    };

    // עדכון או יצירת העדפות
    const updatedPreferences = await prisma.matchPreferences.upsert({
      where: {
        userId: session.user.id,
      },
      create: {
        ...preferencesData,
        user: {
          connect: {
            id: session.user.id
          }
        }
      },
      update: preferencesData,
    });

    return new NextResponse(
      JSON.stringify({
        message: 'Preferences updated successfully',
        preferences: updatedPreferences
      }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error updating preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בעדכון ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\preferences\update\route.ts:
==================================================
import { getServerSession } from 'next-auth/next';
import { NextResponse } from 'next/server';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { CustomSession } from '@/types/next-auth';
import { Prisma } from '@prisma/client';

// Types
interface PrioritiesObject {
  [key: string]: number;
}

interface PreferencesData {
  ageRange: {
    min: number;
    max: number;
  };
  heightRange: {
    min: number;
    max: number;
  };
  religiousLevels: string[];
  locations: string[];
  maritalStatuses: string[];
  preferences: Array<{
    criteria: string;
    importance: number;
    isRequired: boolean;
  }>;
  origins?: string[];
}

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    const data = await req.json() as PreferencesData;

    // Validate age range
    if (data.ageRange.min < 18 || data.ageRange.max > 80 || data.ageRange.min > data.ageRange.max) {
      return new NextResponse(
        JSON.stringify({ error: 'טווח גילאים לא תקין' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // Validate height range
    if (data.heightRange.min < 140 || data.heightRange.max > 200 || data.heightRange.min > data.heightRange.max) {
      return new NextResponse(
        JSON.stringify({ error: 'טווח גבהים לא תקין' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // Create or update match preferences
    const updatedPreferences = await prisma.matchPreferences.upsert({
      where: {
        userId: session.user.id,
      },
      create: {
        userId: session.user.id,
        ageRange: [data.ageRange.min, data.ageRange.max],
        heightRange: [data.heightRange.min, data.heightRange.max],
        religiousLevel: data.religiousLevels,
        location: data.locations,
        maritalStatus: data.maritalStatuses,
        priorities: data.preferences.reduce((acc: PrioritiesObject, pref) => {
          acc[pref.criteria] = pref.importance;
          return acc;
        }, {}),
        dealBreakers: data.preferences
          .filter(pref => pref.isRequired)
          .map(pref => pref.criteria),
        origin: data.origins || [],
        updatedAt: new Date()
      },
      update: {
        ageRange: [data.ageRange.min, data.ageRange.max],
        heightRange: [data.heightRange.min, data.heightRange.max],
        religiousLevel: data.religiousLevels,
        location: data.locations,
        maritalStatus: data.maritalStatuses,
        priorities: data.preferences.reduce((acc: PrioritiesObject, pref) => {
          acc[pref.criteria] = pref.importance;
          return acc;
        }, {}),
        dealBreakers: data.preferences
          .filter(pref => pref.isRequired)
          .map(pref => pref.criteria),
        origin: data.origins || [],
        updatedAt: new Date()
      },
    });

    return new NextResponse(
      JSON.stringify({ 
        message: 'העדפות נשמרו בהצלחה',
        preferences: updatedPreferences 
      }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error updating preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בשמירת ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions) as CustomSession | null;
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    const preferences = await prisma.matchPreferences.findUnique({
      where: {
        userId: session.user.id,
      },
    });

    if (!preferences) {
      return new NextResponse(
        JSON.stringify({ 
          message: 'No preferences found',
          preferences: null 
        }),
        { 
          status: 404,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // Type assertion for priorities
    const priorities = preferences.priorities as PrioritiesObject;

    // Transform the data back to the format expected by the frontend
    const formattedPreferences = {
      ageRange: {
        min: preferences.ageRange[0],
        max: preferences.ageRange[1],
      },
      heightRange: {
        min: preferences.heightRange[0],
        max: preferences.heightRange[1],
      },
      religiousLevels: preferences.religiousLevel,
      locations: preferences.location,
      maritalStatuses: preferences.maritalStatus,
      preferences: Object.entries(priorities).map(([criteria, importance]) => ({
        criteria,
        importance,
        isRequired: preferences.dealBreakers.includes(criteria),
      })),
      dealBreakers: preferences.dealBreakers,
      origins: preferences.origin,
    };

    return new NextResponse(
      JSON.stringify(formattedPreferences),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error fetching preferences:', error);
    return new NextResponse(
      JSON.stringify({ error: 'שגיאה בטעינת ההעדפות' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { User, UserProfile } from "@/types/next-auth";

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const userQuery = requestedUserId 
      ? { id: requestedUserId }
      : { email: session.user.email };

    const user = await prisma.user.findUnique({
      where: userQuery,
      include: {
        profile: true,
        images: true
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    const userProfile = user.profile as unknown as UserProfile;

    const profile = {
      ...userProfile,
      // Personal Information
      gender:userProfile?.gender|| null,
      birthDate:userProfile?.birthDate|| null,
      nativeLanguage: userProfile?.nativeLanguage || null,
      additionalLanguages: userProfile?.additionalLanguages || [],
      height: userProfile?.height || null,
      maritalStatus: userProfile?.maritalStatus || null,
      occupation: userProfile?.occupation || "",
      education: userProfile?.education || "",
      address: userProfile?.address || null,
      city: userProfile?.city || null,
      origin: userProfile?.origin || null,
      religiousLevel: userProfile?.religiousLevel || null,
      about: userProfile?.about || null,
      hobbies: userProfile?.hobbies || null,

      // Family Information
      parentStatus: userProfile?.parentStatus || null,
      siblings: userProfile?.siblings || null,
      position: userProfile?.position || null,

      // Matching Preferences
      preferredAgeMin: userProfile?.preferredAgeMin || null,
      preferredAgeMax: userProfile?.preferredAgeMax || null,
      preferredHeightMin: userProfile?.preferredHeightMin || null,
      preferredHeightMax: userProfile?.preferredHeightMax || null,
      preferredReligiousLevels: userProfile?.preferredReligiousLevels || [],
      preferredLocations: userProfile?.preferredLocations || [],
      preferredEducation: userProfile?.preferredEducation || [],
      preferredOccupations: userProfile?.preferredOccupations || [],

      // Contact and References
      contactPreference: userProfile?.contactPreference || null,
      referenceName1: userProfile?.referenceName1 || "",
      referencePhone1: userProfile?.referencePhone1 || "",
      referenceName2: userProfile?.referenceName2 || "",
      referencePhone2: userProfile?.referencePhone2 || "",

      // Profile Settings
      isProfileVisible: userProfile?.isProfileVisible ?? true,
      preferredMatchmakerGender: userProfile?.preferredMatchmakerGender || null,
      matchingNotes: userProfile?.matchingNotes || null,
      verifiedBy: userProfile?.verifiedBy || null,

      // Availability Status
      availabilityStatus: userProfile?.availabilityStatus || 'AVAILABLE',
      availabilityNote: userProfile?.availabilityNote || null,
      availabilityUpdatedAt: userProfile?.availabilityUpdatedAt || null,

      // System Fields
      createdAt: userProfile?.createdAt || new Date(),
      updatedAt: userProfile?.updatedAt || new Date(),
      lastActive: userProfile?.lastActive || null,

      // User Information
      user: {
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
      }
    };

    return NextResponse.json({
      success: true,
      profile,
      images: user.images
    });

  } catch (error) {
    console.error('Profile fetch error:', error instanceof Error ? error.message : 'Unknown error');
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\availability\route.ts:
==================================================
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest, ApiResponse } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\images\route.ts:
==================================================
// src/app/api/profile/images/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// GET - Fetch all images for a user
export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: { 
        user: {
          email: session.user.email 
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error("[GetImages] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch images" },
      { status: 500 }
    );
  }
}

// POST - Upload a new image
export async function POST(req: Request) {
  try {
    console.log("[Upload] Starting upload process");
    
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error("[Upload] Authentication failed - No user session");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: { images: true },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    if (user.images.length >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { error: "Maximum number of images reached" },
        { status: 400 }
      );
    }

    const formData = await req.formData();
    const file = formData.get("file") as File;
    
    if (!file) {
      console.error("[Upload] No file provided in request");
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    // Validate file
    const validTypes = ["image/jpeg", "image/png", "image/jpg"];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        { error: "Invalid file type. Only JPG and PNG are allowed" },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { error: "File size must be less than 5MB" },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    try {
      const uploadPromise = new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          {
            folder: "profile-images",
            resource_type: "image",
          },
          (error, result) => {
            if (error) reject(error);
            else resolve(result);
          }
        );
        uploadStream.end(buffer);
      });

      const result = await uploadPromise as any;

      const image = await prisma.userImage.create({
        data: {
          userId: user.id,
          url: result.secure_url,
          cloudinaryPublicId: result.public_id,
          isMain: user.images.length === 0,
        },
      });

      return NextResponse.json({ success: true, image });
    } catch (cloudinaryError) {
      console.error("[Upload] Cloudinary upload failed:", cloudinaryError);
      return NextResponse.json(
        { error: "Failed to upload image to cloud storage" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("[Upload] General error:", error);
    return NextResponse.json(
      { error: "Failed to upload image" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\images\[imageId]\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;
    
    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Delete from Cloudinary if cloudinaryPublicId exists
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
        // Continue with database deletion even if Cloudinary deletion fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId },
    });

    // If this was the main image, set another image as main if available
    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;

    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Reset all user's images to non-main
    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    // Set the selected image as main
    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    // Get updated images list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\questionnaire\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma } from "@prisma/client";
import { valuesQuestionsPartOne } from "@/components/questionnaire/questions/values/valuesQuestionsPartOne";
import { valuesQuestionsPartTwo } from "@/components/questionnaire/questions/values/valuesQuestionsPartTwo"; 
import { personalityQuestionsPartOne } from "@/components/questionnaire/questions/personality/personalityQuestionsPartOne";
import { personalityQuestionsPartTwo } from "@/components/questionnaire/questions/personality/personalityQuestionsPartTwo";
import { relationshipBasicsQuestions } from "@/components/questionnaire/questions/relationship/relationshipBasicsQuestions";
import { relationshipDepthQuestions } from "@/components/questionnaire/questions/relationship/relationshipDepthQuestions";
import { partnerBasicQuestions } from "@/components/questionnaire/questions/partner/partnerBasicQuestions";
import { partnerDepthQuestions } from "@/components/questionnaire/questions/partner/partnerDepthQuestions";
import { faithQuestions } from "@/components/questionnaire/questions/religion/faithQuestions";
import { practicalQuestions } from "@/components/questionnaire/questions/religion/practicalReligionQuestions";

// Combine all questions into a single array
const allQuestions = [
  ...valuesQuestionsPartOne,
  ...valuesQuestionsPartTwo,
  ...personalityQuestionsPartOne,
  ...personalityQuestionsPartTwo,
  ...relationshipBasicsQuestions,
  ...relationshipDepthQuestions,
  ...partnerBasicQuestions,
  ...partnerDepthQuestions,
  ...faithQuestions,
  ...practicalQuestions
];

// Define key types
type WorldKey = 'values' | 'personality' | 'relationship' | 'partner' | 'religion';
type DbWorldKey = 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers';

// Key mapping utility
const KEY_MAPPING: Record<WorldKey, DbWorldKey> = {
  values: 'valuesAnswers',
  personality: 'personalityAnswers',
  relationship: 'relationshipAnswers',
  partner: 'partnerAnswers',
  religion: 'religionAnswers'
};

// Reverse key mapping utility
const REVERSE_KEY_MAPPING: Record<DbWorldKey, WorldKey> = {
  valuesAnswers: 'values',
  personalityAnswers: 'personality',
  relationshipAnswers: 'relationship',
  partnerAnswers: 'partner',
  religionAnswers: 'religion'
};

function getDbKey(worldKey: WorldKey): DbWorldKey {
  return KEY_MAPPING[worldKey];
}

function getWorldKey(dbKey: DbWorldKey): WorldKey {
  return REVERSE_KEY_MAPPING[dbKey];
}

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible?: boolean;
}

interface UpdateData {
  type: 'answer' | 'visibility';
  value?: string;
  isVisible?: boolean;
}

interface FormattedAnswer {
  questionId: string;
  question: string;
  value: Prisma.JsonValue;
  displayText: string;
  answeredAt: string;
  category?: string;
  isVisible?: boolean;
}

type FormattedAnswersType = Record<WorldKey, FormattedAnswer[]>;

const valueTranslations: Record<string, string> = {
  'combat': 'קרבי',
  'intelligence': 'אינטליגנציה',
  'stable': 'יציב',
  'yes': 'כן',
  'no': 'לא',
  'religious': 'דתי',
  'traditional': 'מסורתי',
  'secular': 'חילוני',
  'male': 'גבר',
  'female': 'אישה',
  'both': 'שניהם',
  'high': 'גבוהה',
  'medium': 'בינונית',
  'low': 'נמוכה'
};

function getQuestionLabel(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.question || questionId;
}

function getQuestionCategory(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.category || '';
}

function formatValue(value: Prisma.JsonValue): string {
  if (typeof value === 'boolean') {
    return value ? 'כן' : 'לא';
  }
  
  if (Array.isArray(value)) {
    return value.map(v => valueTranslations[String(v)] || String(v)).join(', ');
  }
  
  if (typeof value === 'object' && value !== null) {
    return JSON.stringify(value);
  }
  
  const stringValue = String(value);
  return valueTranslations[stringValue] || stringValue;
}

function safeParseJson(value: any): JsonAnswerData[] {
  if (Array.isArray(value)) {
    return value.map(item => ({
      questionId: item.questionId,
      value: item.value,
      answeredAt: item.answeredAt,
      isVisible: item.isVisible ?? true
    }));
  }
  return [];
}

function formatAnswers(answers: Prisma.JsonValue | null): FormattedAnswer[] {
  const parsedAnswers = safeParseJson(answers);
  
  return parsedAnswers.map(answer => {
    const displayText = formatValue(answer.value);
    const category = getQuestionCategory(answer.questionId);
    
    return {
      questionId: answer.questionId,
      question: getQuestionLabel(answer.questionId),
      value: answer.value,
      displayText,
      category,
      isVisible: answer.isVisible,
      answeredAt: new Date(answer.answeredAt).toLocaleDateString('he-IL', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    };
  }).sort((a, b) => a.questionId.localeCompare(b.questionId));
}

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const userId = url.searchParams.get('userId') || session.user.id;

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });

    if (!questionnaireResponse) {
      return NextResponse.json({
        success: true,
        questionnaireResponse: null
      });
    }

    // Create formatted answers with correct typing
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    
    (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(worldKey => {
      const dbKey = getDbKey(worldKey);
      formattedAnswers[worldKey] = formatAnswers(questionnaireResponse[dbKey]);
    });

    const formattedResponse = {
      ...Response,
      formattedAnswers: formattedAnswers as FormattedAnswersType
    };

    // Filter out non-visible answers for other users
    if (userId !== session.user.id) {
      Object.keys(formattedResponse.formattedAnswers).forEach((worldKey) => {
        const key = worldKey as WorldKey;
        formattedResponse.formattedAnswers[key] = 
          formattedResponse.formattedAnswers[key].filter(answer => answer.isVisible !== false);
      });
    }

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedResponse
    });

  } catch (error) {
    console.error('Error in GET:', error);
    return NextResponse.json({ success: false, error: "Failed to fetch questionnaire" }, { status: 500 });
  }
}

export async function PATCH(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { worldKey, questionId, value } = body as { 
      worldKey: WorldKey; 
      questionId: string; 
      value: UpdateData;
    };

    const dbKey = getDbKey(worldKey);

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id },
      orderBy: { createdAt: 'desc' }
    });

    if (!questionnaire) {
      return NextResponse.json({ success: false, error: "שאלון לא נמצא" }, { status: 404 });
    }

    const currentAnswers = (questionnaire[dbKey] as JsonAnswerData[]) || [];
    const existingAnswer = currentAnswers.find((a) => a.questionId === questionId);

    let updatedAnswer: JsonAnswerData;

    if (value.type === 'visibility') {
      if (!existingAnswer) {
        throw new Error("לא נמצאה תשובה לעדכון");
      }
      
      updatedAnswer = {
        ...existingAnswer,
        isVisible: value.isVisible,
        answeredAt: new Date().toISOString()
      };
    } else {
      updatedAnswer = {
        questionId,
        value: value.value as string,
        isVisible: existingAnswer?.isVisible ?? true,
        answeredAt: new Date().toISOString()
      };
    }

    const updatedAnswers = [
      ...currentAnswers.filter((a) => a.questionId !== questionId),
      updatedAnswer
    ];

    const updated = await prisma.questionnaireResponse.update({
      where: { id: questionnaire.id },
      data: {
        [dbKey]: updatedAnswers,
        lastSaved: new Date()
      }
    });

    // Create formatted answers with correct typing
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    
    (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(key => {
      const dbKey = getDbKey(key);
      formattedAnswers[key] = formatAnswers(updated[dbKey]);
    });

    const formattedResponse = {
      ...updated,
      formattedAnswers: formattedAnswers as FormattedAnswersType
    };

    return NextResponse.json({
      success: true,
      data: formattedResponse
    });

  } catch (error) {
    if (error instanceof Error) {
      return NextResponse.json({ success: false, error: error.message }, { status: 500 });
    }
    return NextResponse.json({ success: false, error: "שגיאה בעדכון השאלון" }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\update\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { AvailabilityStatus, Gender } from "@prisma/client";
import { User, UserProfile } from "@/types/next-auth";

export async function PUT(req: Request) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Get request data
    const data = await req.json();
    
    // Find the user
    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: {
        images: true,
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Update or create profile with new schema
    const profile = await prisma.profile.upsert({
      where: {
        userId: user.id
      },
      create: {
        userId: user.id,
        // Personal Information
        gender:data?.gender,
        birthDate:data?.birthDate,
        nativeLanguage: data.nativeLanguage,
        additionalLanguages: data.additionalLanguages || [],
        height: data.height ? parseInt(data.height) : null,
        maritalStatus: data.maritalStatus,
        occupation: data.occupation,
        education: data.education,
        address: data.address,
        city: data.city,
        origin: data.origin,
        religiousLevel: data.religiousLevel,
        about: data.about,
        hobbies: data.hobbies,
        
        // Family Information
        parentStatus: data.parentStatus,
        siblings: data.siblings ? parseInt(data.siblings) : null,
        position: data.position ? parseInt(data.position) : null,
        
        // Matching Preferences
        preferredAgeMin: data.preferredAgeMin ? parseInt(data.preferredAgeMin) : null,
        preferredAgeMax: data.preferredAgeMax ? parseInt(data.preferredAgeMax) : null,
        preferredHeightMin: data.preferredHeightMin ? parseInt(data.preferredHeightMin) : null,
        preferredHeightMax: data.preferredHeightMax ? parseInt(data.preferredHeightMax) : null,
        preferredReligiousLevels: data.preferredReligiousLevels || [],
        preferredLocations: data.preferredLocations || [],
        preferredEducation: data.preferredEducation || [],
        preferredOccupations: data.preferredOccupations || [],
        
        // Contact and References
        contactPreference: data.contactPreference,
        referenceName1: data.referenceName1,
        referencePhone1: data.referencePhone1,
        referenceName2: data.referenceName2,
        referencePhone2: data.referencePhone2,
        
        // Profile Settings
        isProfileVisible: data.isProfileVisible ?? true,
        preferredMatchmakerGender: data.preferredMatchmakerGender as Gender | null,
        matchingNotes: data.matchingNotes,
        
        // Availability Status
        availabilityStatus: data.availabilityStatus as AvailabilityStatus ?? 'AVAILABLE',
        availabilityNote: data.availabilityNote,
        availabilityUpdatedAt: new Date(),
        
        // System Fields
        createdAt: new Date(),
        updatedAt: new Date(),
        lastActive: new Date(),
      },
      update: {
        // Personal Information
        nativeLanguage: data.nativeLanguage,
        additionalLanguages: data.additionalLanguages,
        height: data.height ? parseInt(data.height) : null,
        maritalStatus: data.maritalStatus,
        occupation: data.occupation,
        education: data.education,
        address: data.address,
        city: data.city,
        origin: data.origin,
        religiousLevel: data.religiousLevel,
        about: data.about,
        hobbies: data.hobbies,
        
        // Family Information
        parentStatus: data.parentStatus,
        siblings: data.siblings ? parseInt(data.siblings) : null,
        position: data.position ? parseInt(data.position) : null,
        
        // Matching Preferences
        preferredAgeMin: data.preferredAgeMin ? parseInt(data.preferredAgeMin) : null,
        preferredAgeMax: data.preferredAgeMax ? parseInt(data.preferredAgeMax) : null,
        preferredHeightMin: data.preferredHeightMin ? parseInt(data.preferredHeightMin) : null,
        preferredHeightMax: data.preferredHeightMax ? parseInt(data.preferredHeightMax) : null,
        preferredReligiousLevels: data.preferredReligiousLevels,
        preferredLocations: data.preferredLocations,
        preferredEducation: data.preferredEducation,
        preferredOccupations: data.preferredOccupations,
        
        // Contact and References
        contactPreference: data.contactPreference,
        referenceName1: data.referenceName1,
        referencePhone1: data.referencePhone1,
        referenceName2: data.referenceName2,
        referencePhone2: data.referencePhone2,
        
        // Profile Settings
        isProfileVisible: data.isProfileVisible,
        preferredMatchmakerGender: data.preferredMatchmakerGender as Gender | null,
        matchingNotes: data.matchingNotes,
        
        // Availability Status
        availabilityStatus: data.availabilityStatus as AvailabilityStatus ?? 'AVAILABLE',
        availabilityNote: data.availabilityNote,
        availabilityUpdatedAt: new Date(),
        
        // System Fields
        updatedAt: new Date(),
        lastActive: new Date(),
      }
    });

    // Fetch updated user with all required information
    const updatedUser = await prisma.user.findUnique({
      where: { id: user.id },
      select: {
        firstName: true,
        lastName: true,
        email: true,
        images: true,
        profile: true
      }
    });

    if (!updatedUser) {
      return NextResponse.json(
        { error: 'Failed to fetch updated profile' },
        { status: 500 }
      );
    }

    // Transform the data to include user information
    const transformedProfile = {
      ...updatedUser.profile,
      user: {
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        email: updatedUser.email,
      },
      images: updatedUser.images,
      mainImage: updatedUser.images.find(img => img.isMain) || null
    };

    return NextResponse.json({
      success: true,
      profile: transformedProfile
    });

  } catch (error) {
    console.error('Profile update error:', error);
    
    if (error instanceof Error) {
      // Prisma errors
      if (error.name === 'PrismaClientKnownRequestError') {
        return NextResponse.json(
          { error: 'Database operation failed' },
          { status: 400 }
        );
      }
      
      // Validation errors
      if (error.name === 'ValidationError') {
        return NextResponse.json(
          { error: error.message },
          { status: 400 }
        );
      }
      
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\name\route.ts:
==================================================
// src/app/api/profile/[userId]/name/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";

export async function PUT(
  req: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.id !== params.userId) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { firstName, lastName } = await req.json();
    if (!firstName || !lastName) {
      return NextResponse.json(
        { success: false, error: "Missing required fields" },
        { status: 400 }
      );
    }

    const user = await prisma.user.update({
      where: { id: params.userId },
      data: { firstName, lastName },
    });

    return NextResponse.json({ success: true, user });
  } catch (error) {
    console.error('Name update error:', error);
    return NextResponse.json(
      { success: false, error: "Server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\password\complete\route.ts:
==================================================
// src/app/api/profile/[userId]/password/complete/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";

const MAX_ATTEMPTS = 3;

export async function POST(
  req: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.id !== params.userId) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { verificationCode, newPassword } = await req.json();

    // Find valid verification record
    const verification = await prisma.verification.findFirst({
      where: {
        userId: params.userId,
        token: verificationCode,
        type: 'EMAIL',
        status: 'PENDING',
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { success: false, error: "Invalid or expired verification code" },
        { status: 400 }
      );
    }

    // Check attempts
    if (verification.attempts >= MAX_ATTEMPTS) {
      await prisma.verification.update({
        where: { id: verification.id },
        data: { status: 'FAILED' }
      });
      return NextResponse.json(
        { success: false, error: "Too many failed attempts" },
        { status: 400 }
      );
    }

    // Increment attempts
    await prisma.verification.update({
      where: { id: verification.id },
      data: { attempts: { increment: 1 } }
    });

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 12);

    // Update password and verification record
    await prisma.$transaction([
      prisma.user.update({
        where: { id: params.userId },
        data: { password: hashedPassword }
      }),
      prisma.verification.update({
        where: { id: verification.id },
        data: { 
          status: 'COMPLETED',
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Password change completion error:', error);
    return NextResponse.json(
      { success: false, error: "Server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\password\initiate\route.ts:
==================================================
// src/app/api/profile/[userId]/password/initiate/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";
import { createTransport } from "nodemailer";
import { randomBytes } from "crypto";

export async function POST(
  req: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.id !== params.userId) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { currentPassword } = await req.json();
    
    const user = await prisma.user.findUnique({
      where: { id: params.userId },
    });

    if (!user) {
      return NextResponse.json(
        { success: false, error: "User not found" },
        { status: 404 }
      );
    }

    const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isPasswordValid) {
      return NextResponse.json(
        { success: false, error: "Invalid password" },
        { status: 400 }
      );
    }

    // Generate verification code
    const verificationCode = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes

    // Create verification record
    await prisma.verification.create({
      data: {
        userId: user.id,
        type: 'EMAIL',
        token: verificationCode,
        expiresAt,
        status: 'PENDING'
      }
    });

    // Send verification email
    const transporter = createTransport({
      host: process.env.SMTP_HOST,
      port: Number(process.env.SMTP_PORT),
      secure: true,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });

    await transporter.sendMail({
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'קוד אימות לשינוי סיסמה',
      html: `
        <div dir="rtl">
          <h1>שינוי סיסמה</h1>
          <p>קוד האימות שלך לשינוי הסיסמה הוא:</p>
          <h2>${verificationCode}</h2>
          <p>הקוד תקף ל-30 דקות.</p>
          <p>אם לא ביקשת לשנות את הסיסמה, אנא התעלם מהודעה זו.</p>
        </div>
      `
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Password change initiation error:', error);
    return NextResponse.json(
      { success: false, error: "Server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\profile\[userId]\questionnaire\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { FormattedAnswer } from "@/types/next-auth";

interface AnswersByWorld {
  values: FormattedAnswer[];
  personality: FormattedAnswer[];
  relationship: FormattedAnswer[];
  partner: FormattedAnswer[];
  religion: FormattedAnswer[];
}

// Helper function to format a single answer
const formatAnswer = (question: string, value: any, answeredAt: Date, isVisible = true): FormattedAnswer => {
  return {
    questionId: question,
    question,
    value,
    displayText: typeof value === 'object' ? value.text || JSON.stringify(value) : String(value),
    answeredAt: answeredAt.toISOString(),
    isVisible
  };
};

// Helper function to format answers for a specific world
const formatWorldAnswers = (worldAnswers: Record<string, any> | null, answeredAt: Date): FormattedAnswer[] => {
  if (!worldAnswers) return [];
  
  return Object.entries(worldAnswers).map(([question, value]) => 
    formatAnswer(question, value, answeredAt)
  );
};

// Main function to format all answers
const formatQuestionnaireAnswers = (questionnaireResponse: any): AnswersByWorld => {
  const answeredAt = questionnaireResponse.updatedAt || questionnaireResponse.createdAt;
  
  return {
    values: formatWorldAnswers(questionnaireResponse.valuesAnswers, answeredAt),
    personality: formatWorldAnswers(questionnaireResponse.personalityAnswers, answeredAt),
    relationship: formatWorldAnswers(questionnaireResponse.relationshipAnswers, answeredAt),
    partner: formatWorldAnswers(questionnaireResponse.partnerAnswers, answeredAt),
    religion: formatWorldAnswers(questionnaireResponse.religionAnswers, answeredAt)
  };
};

export async function GET(
  request: NextRequest,
  context: { params: { userId: string } }
) {
  const { userId } = context.params;

  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // בדיקה שהמשתמש הוא שדכן (אופציונלי)
    if (session.user.role !== 'MATCHMAKER' && session.user.id !== userId) {
      return NextResponse.json(
        { success: false, error: "Forbidden" },
        { status: 403 }
      );
    }

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: userId
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    if (!questionnaireResponse) {
      return NextResponse.json({
        success: true,
        questionnaireResponse: null
      });
    }

    // Format the questionnaire response
    const formattedAnswers = formatQuestionnaireAnswers(questionnaireResponse);

    // Return the response with formatted answers
    return NextResponse.json({
      success: true,
      questionnaireResponse: {
        ...questionnaireResponse,
        formattedAnswers
      }
    });

  } catch (error) {
    console.error("Failed to fetch questionnaire:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch questionnaire" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { Prisma } from "@prisma/client";

// Type guards
function isPrismaError(error: unknown): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

// Constants
const WORLD_IDS = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;

// Zod Schemas
const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const QuestionAnswer = z.object({
  questionId: z.string().min(1),
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number())
  ]),
  answeredAt: z.string().datetime()
});

const WorldAnswers = z.array(QuestionAnswer);

const AnswersByWorld = z.object({
  valuesAnswers: WorldAnswers.optional(),
  personalityAnswers: WorldAnswers.optional(),
  relationshipAnswers: WorldAnswers.optional(),
  partnerAnswers: WorldAnswers.optional(),
  religionAnswers: WorldAnswers.optional()
});

const QuestionnaireAnswer = z.object({
  questionId: z.string(),
  worldId: WorldId,
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
  ]),
  answeredAt: z.string().datetime()
});

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional()
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

/**
 * Groups answers by world ID and formats them for database storage
 */
function groupAnswersByWorld(answers: QuestionnaireSubmission["answers"]) {
  return answers.reduce<Record<string, any>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer = {
      questionId: answer.questionId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      worldId: answer.worldId
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);
    
    return acc;
  }, {});
}

/**
 * Validates that all required fields exist and have correct data types
 */
function validateSubmissionData(data: unknown): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);
  
  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

/**
 * Handles API GET request to retrieve latest questionnaire response
 */
export async function GET(req: Request) {
  try {
    // 1. Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    // 2. Fetch latest questionnaire response
    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    // 3. Transform the data for the client if needed
    const transformedData = questionnaire ? {
      ...questionnaire,
      // Convert JSON fields back to arrays if they exist
      valuesAnswers: questionnaire.valuesAnswers || [],
      personalityAnswers: questionnaire.personalityAnswers || [],
      relationshipAnswers: questionnaire.relationshipAnswers || [],
      partnerAnswers: questionnaire.partnerAnswers || [],
      religionAnswers: questionnaire.religionAnswers || [],
    } : null;

    // 4. Return response
    return NextResponse.json({
      success: true,
      data: transformedData
    });

  } catch (error: unknown) {
    console.error("Error fetching questionnaire:", {
      message: isError(error) ? error.message : "Unknown error occurred",
      stack: process.env.NODE_ENV === 'development' ? error : undefined
    });

    return NextResponse.json({
      error: "אירעה שגיאה בטעינת השאלון",
      details: process.env.NODE_ENV === 'development' ? error : undefined
    }, { status: 500 });
  }
}

/**
 * Handles API PUT request to save questionnaire responses
 */
export async function PUT(req: Request) {
  try {
    // 1. Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "נדרשת התחברות" }, { status: 401 });
    }

    // 2. Parse request body
    const rawBody = await req.json();
    
    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    // 3. Verify user exists
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    // 4. Clean and validate data
    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers: rawBody.answers?.filter((answer: any) => 
        answer && 
        answer.questionId && 
        answer.worldId && 
        answer.value !== undefined && 
        answer.value !== null && 
        answer.value !== ''
      ) ?? []
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: isError(error) ? error.message : 'Unknown validation error'
      }, { status: 400 });
    }

    // 5. Group answers by world
    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    // 6. Save data using upsert
    const result = await prisma.$transaction(async (prisma) => {
      // Try to find existing response
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' }
      });

      // Merge existing and new answers
      const mergedAnswers = {
        valuesAnswers: [...(existingResponse?.valuesAnswers as any[] || []), ...(answersGroupedByWorld.valuesAnswers || [])],
        personalityAnswers: [...(existingResponse?.personalityAnswers as any[] || []), ...(answersGroupedByWorld.personalityAnswers || [])],
        relationshipAnswers: [...(existingResponse?.relationshipAnswers as any[] || []), ...(answersGroupedByWorld.relationshipAnswers || [])],
        partnerAnswers: [...(existingResponse?.partnerAnswers as any[] || []), ...(answersGroupedByWorld.partnerAnswers || [])],
        religionAnswers: [...(existingResponse?.religionAnswers as any[] || []), ...(answersGroupedByWorld.religionAnswers || [])]
      };

      // Remove duplicate answers (keep latest version of each answer)
      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof typeof mergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce((acc: any[], curr: any) => {
            const existingIndex = acc.findIndex(a => a.questionId === curr.questionId);
            if (existingIndex >= 0) {
              // Replace existing answer if new one is more recent
              if (new Date(curr.answeredAt) > new Date(acc[existingIndex].answeredAt)) {
                acc[existingIndex] = curr;
              }
            } else {
              acc.push(curr);
            }
            return acc;
          }, []);
          mergedAnswers[worldKey as keyof typeof mergedAnswers] = uniqueAnswers;
        }
      }

      // Update or create response
      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt ? new Date(validatedData.completedAt) : null,
          valuesCompleted: validatedData.worldsCompleted.includes("VALUES"),
          personalityCompleted: validatedData.worldsCompleted.includes("PERSONALITY"),
          relationshipCompleted: validatedData.worldsCompleted.includes("RELATIONSHIP"),
          partnerCompleted: validatedData.worldsCompleted.includes("PARTNER"),
          religionCompleted: validatedData.worldsCompleted.includes("RELIGION"),
          lastSaved: new Date()
        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt ? new Date(validatedData.completedAt) : null,
          valuesCompleted: validatedData.worldsCompleted.includes("VALUES"),
          personalityCompleted: validatedData.worldsCompleted.includes("PERSONALITY"),
          relationshipCompleted: validatedData.worldsCompleted.includes("RELATIONSHIP"),
          partnerCompleted: validatedData.worldsCompleted.includes("PARTNER"),
          religionCompleted: validatedData.worldsCompleted.includes("RELIGION"),
          lastSaved: new Date()
        }
      });

      // Update user status if questionnaire is completed
      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: "ACTIVE" }
        });
      }

      return savedQuestionnaire;
    });

    // 7. Return success response
    return NextResponse.json({
      success: true,
      data: result
    });

  } catch (error: unknown) {
    // Safe error logging with type checking
    const errorMessage = isError(error) ? error.message : "Unknown error occurred";
    const errorStack = isError(error) ? error.stack : undefined;

    console.error("Error details:", {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined
    });

    // Handle Prisma specific errors
    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון - משתמש לא קיים",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 400 });
        case 'P2002':
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון - רשומה כבר קיימת",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 409 });
        default:
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 500 });
      }
    }

    // Handle general errors
    return NextResponse.json({
      error: "אירעה שגיאה בשמירת השאלון",
      details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\complete\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const allWorldsCompleted = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"].every(
      world => validatedData.worldsCompleted.includes(world as any)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "לא כל העולמות הושלמו"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: "לא נמצא שאלון להשלמה"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
      prisma.user.update({
        where: { id: session.user.id },
        data: { status: "ACTIVE" }
      })
    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "אירעה שגיאה בהשלמת השאלון"
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\update\route.ts:
==================================================
// src/app/api/questionnaire/update/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const { answers } = await req.json();

    // קודם נמצא את השאלון של המשתמש
    const existingQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    if (!existingQuestionnaire) {
      return NextResponse.json(
        { success: false, error: "Questionnaire not found" },
        { status: 404 }
      );
    }

    // עכשיו נעדכן אותו עם ה-ID הנכון
    const updatedQuestionnaire = await prisma.questionnaireResponse.update({
      where: {
        id: existingQuestionnaire.id  // משתמשים ב-ID הייחודי
      },
      data: {
        answers: answers,
      }
    });

    return NextResponse.json({
      success: true,
      questionnaireResponse: updatedQuestionnaire,
    });

  } catch (error) {
    console.error("Failed to update questionnaire:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update questionnaire" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\questionnaire\world\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

// Define the WorldId type and validation schema
const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);
type WorldId = z.infer<typeof WorldId>;

// Schema for world answers
const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(z.object({
    questionId: z.string(),
    value: z.union([
      z.string(),
      z.number(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined()
    ]).optional(),
    answeredAt: z.string().datetime()
  }))
});

export async function PUT(req: Request) {
  try {
    // Authenticate user
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    // Parse and validate request body
    const body = await req.json();
    const validatedData = worldAnswersSchema.parse(body);

    // Get existing questionnaire or create new one
    let questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    const updateData: any = {
      lastSaved: new Date()
    };

    // Set answers and completion status based on worldId
    switch (validatedData.worldId) {
      case "VALUES":
        updateData.valuesAnswers = validatedData.answers;
        updateData.valuesCompleted = true;
        break;
      case "PERSONALITY":
        updateData.personalityAnswers = validatedData.answers;
        updateData.personalityCompleted = true;
        break;
      case "RELATIONSHIP":
        updateData.relationshipAnswers = validatedData.answers;
        updateData.relationshipCompleted = true;
        break;
      case "PARTNER":
        updateData.partnerAnswers = validatedData.answers;
        updateData.partnerCompleted = true;
        break;
      case "RELIGION":
        updateData.religionAnswers = validatedData.answers;
        updateData.religionCompleted = true;
        break;
    }

    // Update or create questionnaire
    if (questionnaire) {
      questionnaire = await prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          ...updateData,
          worldsCompleted: Array.from(new Set([
            ...questionnaire.worldsCompleted,
            validatedData.worldId
          ]))
        }
      });
    } else {
      questionnaire = await prisma.questionnaireResponse.create({
        data: {
          userId: session.user.id,
          startedAt: new Date(),
          worldsCompleted: [validatedData.worldId],
          ...updateData
        }
      });
    }

    return NextResponse.json({
      success: true,
      data: questionnaire
    });

  } catch (error: unknown) {
    console.error("Error saving world answers:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "אירעה שגיאה בשמירת התשובות"
    }, { status: 500 });
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\directory_analysis.txt:
==================================================
מבנה התיקייה:
suggestions
  [id]
    inquiries
      route.ts
    status
      route.ts
  active
    route.ts
  history
    route.ts
  route.ts

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.date(),
});

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Role verification (only matchmakers can create suggestions)
    if (session.user.role !== UserRole.MATCHMAKER) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // 3. Parse and validate request body
    const body = await req.json();
    const validatedData = createSuggestionSchema.parse(body);

    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: "Active suggestion already exists between these parties" },
        { status: 400 }
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id,
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY, // Start with pending first party
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline, // Initial response deadline
          firstPartySent: new Date(), // Mark as sent to first party immediately
          lastStatusChange: new Date(),
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion);

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion,
    });
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { suggestionId, status, notes } = body;

    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 3. Validate status transition
    const isValidTransition = validateStatusTransition(suggestion.status, status);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: "Invalid status transition" },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
        },
      });

      // Create status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes,
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
      // Automatically transition to pending second party
      // TODO: Implement second party notification
    } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      // Automatically share contact details
      // TODO: Implement contact sharing notification
    }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [],
    EXPIRED: [],
    CLOSED: [],
    CANCELLED: []
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\active\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "PENDING_FIRST_PARTY",
                "FIRST_PARTY_APPROVED",
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({
      success: true,
      suggestions: activeSuggestions,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\history\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "FIRST_PARTY_DECLINED",
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        updatedAt: "desc",
      },
    });

    const formattedSuggestions = historySuggestions.map(suggestion => ({
      ...suggestion,
      secondParty: {
        ...suggestion.secondParty,
        profile: {
          ...suggestion.secondParty.profile,
          user: {
            firstName: suggestion.secondParty.firstName,
            lastName: suggestion.secondParty.lastName,
            email: suggestion.secondParty.email,
          }
        }
      }
    }));

    return NextResponse.json({
      success: true,
      suggestions: formattedSuggestions,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts:
==================================================
// src/app/api/suggestions/[id]/inquiries/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { EmailService } from "@/app/components/matchmaker/new/services/email/EmailService";

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { question } = await req.json();

    // Fetch the suggestion to get matchmaker details
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      include: {
        matchmaker: true,
        firstParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          }
        },
        secondParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          }
        },
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // Verify user is authorized to send inquiries for this suggestion
    if (suggestion.firstPartyId !== session.user.id && 
        suggestion.secondPartyId !== session.user.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    // Create the inquiry record
   // בקובץ src/app/api/suggestions/[id]/inquiries/route.ts נעדכן את היחסים:

const inquiry = await prisma.suggestionInquiry.create({
    data: {
      suggestionId: params.id,
      fromUserId: session.user.id,
      toUserId: suggestion.matchmakerId,
      question,
      status: "PENDING",
    },
    include: {
      fromUser: true,
      toUser: true,
      suggestion: true,
    }
  });

    // Send email notification to matchmaker
    const emailTemplate = {
      subject: `שאלה חדשה על הצעת שידוך`,
      body: `
        <div dir="rtl">
          <h2>שלום ${suggestion.matchmaker.firstName},</h2>
          <p>התקבלה שאלה חדשה על הצעת השידוך בין ${suggestion.firstParty.firstName} ל${suggestion.secondParty.firstName}.</p>
          <div style="background: #f5f5f5; padding: 15px; margin: 15px 0; border-radius: 5px;">
            <p style="margin: 0;">${question}</p>
          </div>
          <p>לצפייה בפרטים נוספים ומענה, היכנס/י למערכת.</p>
        </div>
      `,
    };

    await EmailService.getInstance().sendEmail({
      to: suggestion.matchmaker.email,
      subject: emailTemplate.subject,
      html: emailTemplate.body,
    });

    return NextResponse.json({
      success: true,
      inquiry,
    });

  } catch (error) {
    console.error("Error creating inquiry:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\[id]\status\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { statusTransitionService } from "@/app/components/matchmaker/new/services/suggestions/StatusTransitionService";

export async function PATCH(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    // חילוץ הפרמטרים באופן אסינכרוני
    const params = await context.params;
    const suggestionId = params.id;

    // בדיקת אותנטיקציה
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // חילוץ נתונים מה-body
    const body = await req.json();
    const { status, notes } = body;

    // שליפת ההצעה הנוכחית עם כל היחסים הנדרשים
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // וידוא הרשאות המשתמש
    if (suggestion.firstPartyId !== session.user.id && 
        suggestion.secondPartyId !== session.user.id) {
      return NextResponse.json(
        { error: "Unauthorized to update this suggestion" },
        { status: 403 }
      );
    }

    let updatedSuggestion;
    try {
      // עדכון סטטוס ההצעה
      updatedSuggestion = await statusTransitionService.transitionStatus(
        suggestion,
        status,
        notes
      );

      // אם הסטטוס הוא FIRST_PARTY_APPROVED, מעבר אוטומטי ל-PENDING_SECOND_PARTY
      if (status === "FIRST_PARTY_APPROVED") {
        updatedSuggestion = await statusTransitionService.transitionStatus(
          updatedSuggestion,
          "PENDING_SECOND_PARTY",
          "Automatic transition after first party approval"
        );
      } else if (status === "SECOND_PARTY_APPROVED") {
        updatedSuggestion = await statusTransitionService.transitionStatus(
          updatedSuggestion,
          "CONTACT_DETAILS_SHARED",
          "Automatic transition after second party approval"
        );
      }

      return NextResponse.json({
        success: true,
        suggestion: updatedSuggestion,
      });

    } catch (transitionError) {
      console.error("Error in status transition:", transitionError);
      
      // אם היה שגיאה בתהליך המעבר, נחזיר שגיאה מפורטת
      return NextResponse.json({
        error: "Failed to update suggestion status",
        details: transitionError instanceof Error ? transitionError.message : "Unknown error",
      }, { 
        status: 500 
      });
    }

  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json(
      { 
        error: "Internal server error",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.date(),
});

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Role verification (only matchmakers can create suggestions)
    if (session.user.role !== UserRole.MATCHMAKER) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // 3. Parse and validate request body
    const body = await req.json();
    const validatedData = createSuggestionSchema.parse(body);

    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: "Active suggestion already exists between these parties" },
        { status: 400 }
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id,
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY, // Start with pending first party
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline, // Initial response deadline
          firstPartySent: new Date(), // Mark as sent to first party immediately
          lastStatusChange: new Date(),
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion);

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion,
    });
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { suggestionId, status, notes } = body;

    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 3. Validate status transition
    const isValidTransition = validateStatusTransition(suggestion.status, status);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: "Invalid status transition" },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
        },
      });

      // Create status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes,
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
      // Automatically transition to pending second party
      // TODO: Implement second party notification
    } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      // Automatically share contact details
      // TODO: Implement contact sharing notification
    }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [],
    EXPIRED: [],
    CLOSED: [],
    CANCELLED: []
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\active\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "PENDING_FIRST_PARTY",
                "FIRST_PARTY_APPROVED",
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({
      success: true,
      suggestions: activeSuggestions,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\history\route.ts:
==================================================
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "FIRST_PARTY_DECLINED",
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true,
                address: true,
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                hobbies: true,
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
                referenceName1: true,
                referencePhone1: true,
                referenceName2: true,
                referencePhone2: true,
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        updatedAt: "desc",
      },
    });

    const formattedSuggestions = historySuggestions.map(suggestion => ({
      ...suggestion,
      secondParty: {
        ...suggestion.secondParty,
        profile: {
          ...suggestion.secondParty.profile,
          user: {
            firstName: suggestion.secondParty.firstName,
            lastName: suggestion.secondParty.lastName,
            email: suggestion.secondParty.email,
          }
        }
      }
    }));

    return NextResponse.json({
      success: true,
      suggestions: formattedSuggestions,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\[id]\delete\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // וידוא שהמשתמש הוא שדכן
    if (session.user.role !== UserRole.MATCHMAKER) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const suggestionId = context.params.id;

    // בדיקה שההצעה קיימת
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // וידוא שהשדכן הוא בעל ההצעה
    if (suggestion.matchmakerId !== session.user.id) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // מחיקת ההצעה וכל הנתונים הקשורים אליה
    await prisma.$transaction([
      // מחיקת היסטוריית סטטוסים
      prisma.suggestionStatusHistory.deleteMany({
        where: { suggestionId },
      }),
      // מחיקת שאלות
      prisma.suggestionInquiry.deleteMany({
        where: { suggestionId },
      }),
      // מחיקת ההצעה עצמה
      prisma.matchSuggestion.delete({
        where: { id: suggestionId },
      }),
    ]);

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully",
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts:
==================================================
// src/app/api/suggestions/[id]/inquiries/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { EmailService } from "@/app/components/matchmaker/new/services/email/EmailService";

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { question } = await req.json();

    // Fetch the suggestion to get matchmaker details
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      include: {
        matchmaker: true,
        firstParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          }
        },
        secondParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          }
        },
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // Verify user is authorized to send inquiries for this suggestion
    if (suggestion.firstPartyId !== session.user.id && 
        suggestion.secondPartyId !== session.user.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    // Create the inquiry record
   // בקובץ src/app/api/suggestions/[id]/inquiries/route.ts נעדכן את היחסים:

const inquiry = await prisma.suggestionInquiry.create({
    data: {
      suggestionId: params.id,
      fromUserId: session.user.id,
      toUserId: suggestion.matchmakerId,
      question,
      status: "PENDING",
    },
    include: {
      fromUser: true,
      toUser: true,
      suggestion: true,
    }
  });

    // Send email notification to matchmaker
    const emailTemplate = {
      subject: `שאלה חדשה על הצעת שידוך`,
      body: `
        <div dir="rtl">
          <h2>שלום ${suggestion.matchmaker.firstName},</h2>
          <p>התקבלה שאלה חדשה על הצעת השידוך בין ${suggestion.firstParty.firstName} ל${suggestion.secondParty.firstName}.</p>
          <div style="background: #f5f5f5; padding: 15px; margin: 15px 0; border-radius: 5px;">
            <p style="margin: 0;">${question}</p>
          </div>
          <p>לצפייה בפרטים נוספים ומענה, היכנס/י למערכת.</p>
        </div>
      `,
    };

    await EmailService.getInstance().sendEmail({
      to: suggestion.matchmaker.email,
      subject: emailTemplate.subject,
      html: emailTemplate.body,
    });

    return NextResponse.json({
      success: true,
      inquiry,
    });

  } catch (error) {
    console.error("Error creating inquiry:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\api\suggestions\[id]\status\route.ts:
==================================================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { statusTransitionService } from "@/app/components/matchmaker/new/services/suggestions/StatusTransitionService";

export async function PATCH(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    // חילוץ הפרמטרים באופן אסינכרוני
    const params = await context.params;
    const suggestionId = params.id;

    // בדיקת אותנטיקציה
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // חילוץ נתונים מה-body
    const body = await req.json();
    const { status, notes } = body;

    // שליפת ההצעה הנוכחית עם כל היחסים הנדרשים
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // וידוא הרשאות המשתמש
    if (suggestion.firstPartyId !== session.user.id && 
        suggestion.secondPartyId !== session.user.id) {
      return NextResponse.json(
        { error: "Unauthorized to update this suggestion" },
        { status: 403 }
      );
    }

    let updatedSuggestion;
    try {
      // עדכון סטטוס ההצעה
      updatedSuggestion = await statusTransitionService.transitionStatus(
        suggestion,
        status,
        notes
      );

      // אם הסטטוס הוא FIRST_PARTY_APPROVED, מעבר אוטומטי ל-PENDING_SECOND_PARTY
      if (status === "FIRST_PARTY_APPROVED") {
        updatedSuggestion = await statusTransitionService.transitionStatus(
          updatedSuggestion,
          "PENDING_SECOND_PARTY",
          "Automatic transition after first party approval"
        );
      } else if (status === "SECOND_PARTY_APPROVED") {
        updatedSuggestion = await statusTransitionService.transitionStatus(
          updatedSuggestion,
          "CONTACT_DETAILS_SHARED",
          "Automatic transition after second party approval"
        );
      }

      return NextResponse.json({
        success: true,
        suggestion: updatedSuggestion,
      });

    } catch (transitionError) {
      console.error("Error in status transition:", transitionError);
      
      // אם היה שגיאה בתהליך המעבר, נחזיר שגיאה מפורטת
      return NextResponse.json({
        error: "Failed to update suggestion status",
        details: transitionError instanceof Error ? transitionError.message : "Unknown error",
      }, { 
        status: 500 
      });
    }

  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json(
      { 
        error: "Internal server error",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\auth\error\page.tsx:
==================================================
"use client";

import { useEffect } from "react";
import { useSearchParams } from "next/navigation";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";

export default function ErrorPage() {
  const searchParams = useSearchParams();
  const error = searchParams.get("error");
  const router = useRouter();

  const getErrorMessage = (error: string) => {
    switch (error) {
      case "Signin":
        return "נסה להתחבר שוב";
      case "OAuthSignin":
        return "נסה להתחבר שוב";
      case "OAuthCallback":
        return "שגיאה בתהליך ההתחברות";
      case "OAuthCreateAccount":
        return "שגיאה ביצירת החשבון";
      case "EmailCreateAccount":
        return "שגיאה ביצירת החשבון";
      case "Callback":
        return "שגיאה בתהליך ההתחברות";
      case "OAuthAccountNotLinked":
        return "החשבון כבר מקושר למשתמש אחר";
      case "EmailSignin":
        return "בדוק את תיבת הדואר שלך";
      case "CredentialsSignin":
        return "פרטי ההתחברות שגויים";
      default:
        return "שגיאה בתהליך ההתחברות";
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl font-bold text-red-600">
            שגיאה
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <p className="text-gray-600">
            {error ? getErrorMessage(error) : "שגיאה לא ידועה"}
          </p>
          <Button
            onClick={() => router.push("/auth/signin")}
            className="w-full"
          >
            חזרה לדף ההתחברות
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\auth\register\page.tsx:
==================================================
import RegisterForm from "@/app/components/auth/RegisterForm";
import Link from "next/link";

export default function RegisterPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            הרשמה למערכת
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            או{" "}
            <Link
              href="/auth/signin"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              התחברות למערכת
            </Link>
          </p>
        </div>
        <RegisterForm />
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\auth\signin\page.tsx:
==================================================
import SignInForm from "@/app/components/auth/SignInForm";
import Link from "next/link";

export default function SignInPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            התחברות למערכת
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            או{" "}
            <Link
              href="/auth/register"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              הרשמה למערכת
            </Link>
          </p>
        </div>
        <SignInForm />
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\auth\verify-email\page.tsx:
==================================================
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useSession } from "next-auth/react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2 } from "lucide-react";

interface VerificationState {
  status: "pending" | "verifying" | "success" | "error";
  message: string;
}

export default function VerifyEmailPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { data: session, update: updateSession } = useSession();

  const token = searchParams.get("token");
  const email = searchParams.get("email");

  const [verification, setVerification] = useState<VerificationState>({
    status: token ? "verifying" : "pending",
    message: "",
  });
  const [isResending, setIsResending] = useState(false);

  // טיפול בשליחה מחדש של מייל אימות
  const handleResendVerification = async () => {
    if (!email) return;

    setIsResending(true);
    try {
      const response = await fetch("/api/auth/resend-verification", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, type: "EMAIL" }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "שגיאה בשליחת מייל האימות");
      }

      setVerification({
        status: "pending",
        message: "מייל אימות חדש נשלח בהצלחה",
      });
    } catch (error) {
      setVerification({
        status: "error",
        message:
          error instanceof Error ? error.message : "שגיאה בשליחת מייל האימות",
      });
    } finally {
      setIsResending(false);
    }
  };

  // אימות הטוקן
  // למחוק את ה-useEffect הקיים ולהחליף אותו בזה:

  useEffect(() => {
    const verifyToken = async () => {
      // אם אין טוקן או שכבר ביצענו אימות, נצא מהפונקציה
      if (
        !token ||
        verification.status === "success" ||
        verification.status === "error"
      ) {
        return;
      }

      try {
        const response = await fetch("/api/auth/verify", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token, type: "EMAIL" }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || "שגיאה באימות החשבון");
        }

        setVerification({
          status: "success",
          message: "החשבון אומת בהצלחה",
        });

        await updateSession();
        setTimeout(() => {
          router.push("/auth/signin?verified=true");
        }, 2000);
      } catch (error) {
        setVerification({
          status: "error",
          message:
            error instanceof Error ? error.message : "שגיאה באימות החשבון",
        });
      }
    };

    verifyToken();
  }, [token]); // שינוי התלויות - רק token
  return (
    <div className="min-h-screen flex items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardContent className="p-6 space-y-4">
          {/* תצוגת המתנה לאימות מייל */}
          {verification.status === "pending" && (
            <div className="text-center space-y-4">
              <h2 className="text-xl font-semibold">אימות חשבון</h2>
              <p>שלחנו מייל אימות לכתובת:</p>
              <p className="font-medium">{email}</p>
              <p>אנא בדקו את תיבת הדואר שלכם ולחצו על הקישור לאימות החשבון</p>

              <Button
                onClick={handleResendVerification}
                disabled={isResending}
                className="mt-4"
              >
                {isResending ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    שולח מייל חדש...
                  </>
                ) : (
                  "שלח מייל אימות מחדש"
                )}
              </Button>
            </div>
          )}

          {/* תצוגת תהליך האימות */}
          {verification.status === "verifying" && (
            <div className="flex flex-col items-center space-y-4">
              <Loader2 className="h-8 w-8 animate-spin" />
              <p>מאמת את החשבון...</p>
            </div>
          )}

          {/* תצוגת הצלחה */}
          {verification.status === "success" && (
            <div className="text-center space-y-4">
              <h2 className="text-xl font-semibold text-green-600">
                {verification.message}
              </h2>
              <p>מעביר אותך לדף ההתחברות...</p>
            </div>
          )}

          {/* תצוגת שגיאה */}
          {verification.status === "error" && (
            <div className="space-y-4">
              <Alert variant="destructive">
                <AlertDescription>{verification.message}</AlertDescription>
              </Alert>
              <div className="flex justify-center">
                <Button onClick={() => router.push("/auth/signin")}>
                  חזור לדף ההתחברות
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\auth\RegisterForm.tsx:
==================================================
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Gender } from "@prisma/client";

interface RegistrationFormData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  phone: string; // הוספת שדה טלפון
  gender: Gender;
  birthDate: string;
  maritalStatus?: string;
  height?: number;
  occupation?: string;
  education?: string;
}

export default function RegisterForm() {
  const router = useRouter();
  const [error, setError] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);
  const [password, setPassword] = useState("");
  const [passwordError, setPasswordError] = useState("");

  const validatePassword = (value: string) => {
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(value)) {
      setPasswordError(
        "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר"
      );
      return false;
    }
    setPasswordError("");
    return true;
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    if (!validatePassword(password)) {
      setIsLoading(false);
      return;
    }

    const formData = new FormData(e.currentTarget);
    const data: RegistrationFormData = {
      email: formData.get("email") as string,
      password: password,
      firstName: formData.get("firstName") as string,
      lastName: formData.get("lastName") as string,
      phone: formData.get("phone") as string, // הוספת שדה טלפון
      gender: formData.get("gender") as Gender,
      birthDate: formData.get("birthDate") as string,
      maritalStatus: formData.get("maritalStatus") as string,
      height: formData.get("height")
        ? Number(formData.get("height"))
        : undefined,
      occupation: formData.get("occupation") as string,
      education: formData.get("education") as string,
    };

    try {
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "אירעה שגיאה בהרשמה");
      }

      const result = await response.json();

      // העברה לדף אימות המייל
      router.push(`/auth/verify-email?email=${encodeURIComponent(data.email)}`);
    } catch (error) {
      setError(error instanceof Error ? error.message : "אירעה שגיאה בהרשמה");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6 max-w-sm mx-auto">
      <div>
        <label
          htmlFor="firstName"
          className="block text-sm font-medium text-gray-700"
        >
          שם פרטי
        </label>
        <input
          type="text"
          name="firstName"
          id="firstName"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      <div>
        <label
          htmlFor="lastName"
          className="block text-sm font-medium text-gray-700"
        >
          שם משפחה
        </label>
        <input
          type="text"
          name="lastName"
          id="lastName"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      <div>
        <label
          htmlFor="email"
          className="block text-sm font-medium text-gray-700"
        >
          אימייל
        </label>
        <input
          type="email"
          name="email"
          id="email"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      {/* הוספת שדה טלפון */}
      <div>
        <label
          htmlFor="phone"
          className="block text-sm font-medium text-gray-700"
        >
          טלפון נייד
        </label>
        <input
          type="tel"
          name="phone"
          id="phone"
          required
          pattern="[0-9]{10}"
          placeholder="0501234567"
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      <div>
        <label
          htmlFor="password"
          className="block text-sm font-medium text-gray-700"
        >
          סיסמה
        </label>
        <input
          type="password"
          name="password"
          id="password"
          required
          value={password}
          onChange={(e) => {
            setPassword(e.target.value);
            validatePassword(e.target.value);
          }}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
        <p className="mt-1 text-sm text-gray-500">
          הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה באנגלית, אות קטנה באנגלית
          ומספר
        </p>
        {passwordError && (
          <div className="text-red-500 text-sm">{passwordError}</div>
        )}
      </div>

      <div>
        <label
          htmlFor="gender"
          className="block text-sm font-medium text-gray-700"
        >
          מגדר
        </label>
        <select
          name="gender"
          id="gender"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        >
          <option value="">בחר מגדר</option>
          <option value="MALE">זכר</option>
          <option value="FEMALE">נקבה</option>
        </select>
      </div>

      <div>
        <label
          htmlFor="birthDate"
          className="block text-sm font-medium text-gray-700"
        >
          תאריך לידה
        </label>
        <input
          type="date"
          name="birthDate"
          id="birthDate"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      <div>
        <label
          htmlFor="maritalStatus"
          className="block text-sm font-medium text-gray-700"
        >
          מצב משפחתי
        </label>
        <select
          name="maritalStatus"
          id="maritalStatus"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        >
          <option value="">בחר מצב משפחתי</option>
          <option value="רווק/ה">רווק/ה</option>
          <option value="גרוש/ה">גרוש/ה</option>
          <option value="אלמן/ה">אלמן/ה</option>
        </select>
      </div>

      <div>
        <label
          htmlFor="height"
          className="block text-sm font-medium text-gray-700"
        >
          גובה (בס"מ)
        </label>
        <input
          type="number"
          name="height"
          id="height"
          min="120"
          max="220"
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      <div>
        <label
          htmlFor="occupation"
          className="block text-sm font-medium text-gray-700"
        >
          עיסוק
        </label>
        <input
          type="text"
          name="occupation"
          id="occupation"
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      <div>
        <label
          htmlFor="education"
          className="block text-sm font-medium text-gray-700"
        >
          השכלה
        </label>
        <input
          type="text"
          name="education"
          id="education"
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
        />
      </div>

      {error && <div className="text-red-500 text-sm">{error}</div>}

      <button
        type="submit"
        disabled={isLoading || !!passwordError}
        className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
      >
        {isLoading ? "נרשם..." : "הרשמה"}
      </button>
    </form>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\auth\SignInForm.tsx:
==================================================
// src/components/auth/SignInForm.tsx
"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";

export default function SignInForm() {
  const router = useRouter();
  const [error, setError] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    const formData = new FormData(e.currentTarget);
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;

    try {
      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError(result.error);
      } else {
        // בדיקה אם יש שאלון זמני
        const tempQuestionnaire = localStorage.getItem("tempQuestionnaire");

        if (tempQuestionnaire) {
          try {
            const response = await fetch("/api/questionnaire", {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: tempQuestionnaire,
            });

            if (response.ok) {
              localStorage.removeItem("tempQuestionnaire");
              localStorage.removeItem("questionnaireProgress");
              router.push("/questionnaire/complete");
              return;
            }
          } catch (error) {
            console.error("Error saving questionnaire:", error);
          }
        }

        // אם אין שאלון או שהשמירה נכשלה, נווט לדשבורד
        router.push("/dashboard");
        router.refresh();
      }
    } catch (error) {
      setError("אירעה שגיאה בהתחברות");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6 max-w-sm mx-auto">
      <div>
        <label
          htmlFor="email"
          className="block text-sm font-medium text-gray-700"
        >
          אימייל
        </label>
        <input
          type="email"
          name="email"
          id="email"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 focus:border-indigo-500 focus:outline-none focus:ring-indigo-500"
        />
      </div>

      <div>
        <label
          htmlFor="password"
          className="block text-sm font-medium text-gray-700"
        >
          סיסמה
        </label>
        <input
          type="password"
          name="password"
          id="password"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 focus:border-indigo-500 focus:outline-none focus:ring-indigo-500"
        />
      </div>

      {error && <div className="text-red-500 text-sm">{error}</div>}

      <button
        type="submit"
        disabled={isLoading}
        className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
      >
        {isLoading ? "מתחבר..." : "התחבר"}
      </button>
    </form>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\dashboard\ClientCard.tsx:
==================================================
"use client";

import { useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  AlertCircle,
  Loader2,
  Check,
  X,
  Clock,
  User,
  Mail,
  MessageCircle,
  MapPin,
  Briefcase,
  GraduationCap,
} from "lucide-react";
import { AvailabilityStatus } from "@prisma/client";
import type { Client, ExtendedClient } from "@/app/types/matchmaker";
import { InvitationStatus } from "@prisma/client";

interface ClientCardProps {
  client: ExtendedClient;
  onSuggest: (client: ExtendedClient) => void;
  onSendInvite: () => void;
  onCheckAvailability?: (client: ExtendedClient) => Promise<void>;
}

export default function ClientCard({
  client,
  onSuggest,
  onSendInvite,
  onCheckAvailability,
}: ClientCardProps) {
  const [isSharing, setIsSharing] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState("");
  console.log("Availability Status:", client.profile?.availabilityStatus);
  console.log("Latest Inquiry:", JSON.stringify(client.latestInquiry, null, 2));
  console.log("Full Client Object:", JSON.stringify(client, null, 2));

  const calculateAge = (birthDate: string) => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birth.getDate())
    ) {
      age--;
    }
    return age;
  };

  const getGeneralAvailabilityDisplay = (
    status?: AvailabilityStatus | null
  ) => {
    if (!status) return null;

    const statusConfig = {
      AVAILABLE: { color: "text-green-600 bg-green-50", text: "פנוי/ה" },
      UNAVAILABLE: { color: "text-red-600 bg-red-50", text: "לא פנוי/ה" },
      DATING: { color: "text-purple-600 bg-purple-50", text: "בתהליך היכרות" },
      ENGAGED: { color: "text-blue-600 bg-blue-50", text: "מאורס/ת" },
      MARRIED: { color: "text-gray-600 bg-gray-50", text: "נשוי/ה" },
    };

    const config = statusConfig[status];
    return (
      <div className={`px-2 py-1 rounded-full text-sm ${config.color}`}>
        {config.text}
        {client.profile?.availabilityUpdatedAt && (
          <span className="text-xs block">
            עודכן:{" "}
            {new Date(
              client.profile.availabilityUpdatedAt
            ).toLocaleDateString()}
          </span>
        )}
      </div>
    );
  };

  const getImmediateAvailabilityDisplay = (latestInquiry?: {
    firstPartyResponse?: boolean | null;
    updatedAt?: string;
  }) => {
    if (!latestInquiry) return null;

    const status = latestInquiry.firstPartyResponse;
    return (
      <div
        className={`px-2 py-1 rounded-full text-sm ${
          status === null
            ? "bg-yellow-50 text-yellow-600"
            : status
            ? "bg-green-50 text-green-600"
            : "bg-red-50 text-red-600"
        }`}
      >
        {status === null
          ? "ממתין לתגובה"
          : status
          ? "זמין/ה מיידית"
          : "לא זמין/ה מיידית"}
        {latestInquiry.updatedAt && (
          <span className="text-xs block">
            עודכן: {new Date(latestInquiry.updatedAt).toLocaleDateString()}
          </span>
        )}
      </div>
    );
  };

  const handleCheckAvailability = async () => {
    if (!onCheckAvailability) return;

    try {
      setIsSending(true);
      setError("");
      await onCheckAvailability(client);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to check availability"
      );
    } finally {
      setIsSending(false);
    }
  };

  return (
    <Card className="w-full hover:shadow-lg transition-all duration-300">
      <CardContent className="p-6">
        {/* Header Section */}
        <div className="flex justify-between items-start">
          <div className="flex items-center space-x-3 space-x-reverse">
            <div className="w-12 h-12 rounded-full bg-gray-100 flex items-center justify-center">
              <User className="w-6 h-6 text-gray-600" />
            </div>
            <div>
              <h3 className="text-lg font-semibold">
                {client.firstName} {client.lastName}
              </h3>
              <p className="text-sm text-gray-500">
                {calculateAge(client.birthDate)} •{" "}
                {client.personalInfo?.religiousLevel}
              </p>
            </div>
          </div>
        </div>

        {/* Personal Info Section */}
        <div className="grid grid-cols-2 gap-4 text-sm mt-4">
          <div className="flex items-center space-x-2 space-x-reverse">
            <MapPin className="h-4 w-4 text-gray-400" />
            <span>{client.personalInfo?.city || "לא צוין"}</span>
          </div>
          <div className="flex items-center space-x-2 space-x-reverse">
            <Briefcase className="h-4 w-4 text-gray-400" />
            <span>{client.personalInfo?.occupation || "לא צוין"}</span>
          </div>
          <div className="flex items-center space-x-2 space-x-reverse">
            <GraduationCap className="h-4 w-4 text-gray-400" />
            <span>{client.personalInfo?.education || "לא צוין"}</span>
          </div>
        </div>

        {/* Availability Status Section */}
        <div className="flex flex-col gap-2 mt-4">
          <div className="flex items-center gap-2">
            <span className="text-sm text-gray-500">זמינות כללית:</span>
            {getGeneralAvailabilityDisplay(client.profile?.availabilityStatus)}
          </div>
          <div className="flex items-center gap-2">
            <span className="text-sm text-gray-500">זמינות מיידית:</span>
            {getImmediateAvailabilityDisplay(client.latestInquiry)}
          </div>
        </div>

        {/* Invitation Status */}
        {client.invitation && (
          <div className="flex items-center space-x-2 space-x-reverse mt-4 text-sm text-gray-600">
            <Clock className="h-4 w-4" />
            <span>
              הזמנה נשלחה ל-{client.invitation.email} •{" "}
              {client.invitation.status}
            </span>
          </div>
        )}


        {/* Action Buttons */}
        <div className="flex gap-2 mt-4">
          <Button
            variant="outline"
            onClick={handleCheckAvailability}
            className="flex-1"
            disabled={isSending}
          >
            {isSending ? (
              <Loader2 className="ml-2 h-4 w-4 animate-spin" />
            ) : (
              <AlertCircle className="ml-2 h-4 w-4" />
            )}
            בדוק זמינות
          </Button>

          {!client.invitation && (
            <Button variant="outline" onClick={onSendInvite} className="flex-1">
              <Mail className="ml-2 h-4 w-4" />
              שליחת הזמנה
            </Button>
          )}

          <Button onClick={() => onSuggest(client)} className="flex-1">
            <User className="ml-2 h-4 w-4" />
            הצעת שידוך
          </Button>
        </div>

        {/* Error Display */}
        {error && (
          <Alert variant="destructive" className="mt-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
      </CardContent>
    </Card>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\dashboard\MatchmakerDashboard.tsx:
==================================================
"use client";

import React, { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import ClientCard from "./ClientCard";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Users, Plus, Filter, Mail as MailIcon, Search } from "lucide-react";
import AddCandidateWizard from "../forms/AddCandidateWizard";
import NewSuggestionForm from "../forms/NewSuggestionForm";
import type { Client, ExtendedClient } from "@/app/types/matchmaker";
import type { Session } from "@/types/next-auth";
import { AvailabilityStatus, UserStatus } from "@prisma/client";
import type { CreateSuggestionData } from "@/app/types/suggestions";
import { AvailabilityService } from "@/lib/services/availabilityService";

interface DashboardStats {
  available: number;
  unavailable: number;
  dating: number;
  pending: number;
}

export function MatchmakerDashboard() {
  const { data: session } = useSession() as { data: Session | null };
  const [clients, setClients] = useState<ExtendedClient[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [showAddCandidateDialog, setShowAddCandidateDialog] = useState(false);
  const [showNewSuggestionDialog, setShowNewSuggestionDialog] = useState(false);
  const [selectedClient, setSelectedClient] = useState<ExtendedClient | null>(
    null
  );
  const [showSendInviteDialog, setShowSendInviteDialog] = useState(false);
  const [inviteEmail, setInviteEmail] = useState("");
  const [clientToInvite, setClientToInvite] = useState<ExtendedClient | null>(
    null
  );
  const [availabilityStats, setAvailabilityStats] = useState<DashboardStats>({
    available: 0,
    unavailable: 0,
    dating: 0,
    pending: 0,
  });
  const [filters, setFilters] = useState({
    status: "all" as UserStatus | "all",
    availabilityStatus: "all" as AvailabilityStatus | "all",
  });
  const [showFilters, setShowFilters] = useState(false);

  const loadClients = async () => {
    if (!session?.user?.id) return;

    try {
      setLoading(true);
      const response = await fetch("/api/matchmaker/clients");
      if (!response.ok) {
        throw new Error("Failed to fetch clients");
      }
      const data = await response.json();
      setClients(data.clients);

      // Load availability stats
      const stats = await AvailabilityService.getAvailabilityStats(
        session.user.id
      );
      setAvailabilityStats(stats);
    } catch (err) {
      console.error("Error loading clients:", err);
      setError(err instanceof Error ? err.message : "Failed to load clients");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadClients();
  }, [session]);

  const handleSendInvite = async () => {
    if (!clientToInvite || !inviteEmail) return;

    try {
      const response = await fetch("/api/matchmaker/candidates/invite", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          clientId: clientToInvite.id,
          email: inviteEmail,
          firstName: clientToInvite.firstName,
          lastName: clientToInvite.lastName,
          gender: clientToInvite.gender,
          birthDate: clientToInvite.birthDate,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to send invitation");
      }

      setShowSendInviteDialog(false);
      setClientToInvite(null);
      setInviteEmail("");
      await loadClients();
    } catch (error) {
      console.error("Error sending invitation:", error);
      setError("Failed to send invitation");
    }
  };

  const handleCheckAvailability = async (client: ExtendedClient) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ clientId: client.id }),
      });

      if (!response.ok) {
        throw new Error("Failed to check availability");
      }

      // Refresh data after successful check
      await loadClients();
    } catch (error) {
      console.error("Error checking availability:", error);
      throw error;
    }
  };
  const handleCreateSuggestion = async (data: CreateSuggestionData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          ...data,
          matchmakerId: session?.user?.id,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to create suggestion");
      }

      setShowNewSuggestionDialog(false);
      setSelectedClient(null);
      await loadClients();
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Failed to create suggestion"
      );
    }
  };

  const getFilteredClients = () => {
    return clients.filter((client) => {
      // Status filter
      if (filters.status !== "all" && client.status !== filters.status) {
        return false;
      }

      // Availability filter
      if (
        filters.availabilityStatus !== "all" &&
        client.profile?.availabilityStatus !== filters.availabilityStatus
      ) {
        return false;
      }

      // Search query
      if (searchQuery) {
        const searchString = `${client.firstName} ${client.lastName} ${
          client.profile?.city || ""
        }`.toLowerCase();
        if (!searchString.includes(searchQuery.toLowerCase())) {
          return false;
        }
      }

      return true;
    });
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">טוען...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <div className="mb-8">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">ניהול מועמדים</h1>
          <Button
            className="bg-green-600 hover:bg-green-700"
            onClick={() => setShowAddCandidateDialog(true)}
          >
            <Plus className="ml-2 h-4 w-4" />
            הוספת מועמד
          </Button>
        </div>

        {/* Statistics Cards */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {availabilityStats.available}
              </div>
              <div className="text-gray-500">זמינים להצעות</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {availabilityStats.dating}
              </div>
              <div className="text-gray-500">בתהליך היכרות</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {availabilityStats.unavailable}
              </div>
              <div className="text-gray-500">לא זמינים</div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-6">
              <div className="text-2xl font-bold">
                {availabilityStats.pending}
              </div>
              <div className="text-gray-500">בדיקות זמינות</div>
            </CardContent>
          </Card>
        </div>

        {/* Filters */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <CardTitle>סינון מועמדים</CardTitle>
            <Button
              variant="outline"
              onClick={() => setShowFilters(!showFilters)}
            >
              <Filter className="ml-2 h-4 w-4" />
              {showFilters ? "הסתר סינון" : "הצג סינון"}
            </Button>
          </CardHeader>
          {showFilters && (
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <Input
                    placeholder="חיפוש..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="w-full"
                  />
                </div>
                <div>
                  <Select
                    value={filters.status}
                    onValueChange={(value) =>
                      setFilters((prev) => ({
                        ...prev,
                        status: value as UserStatus | "all",
                      }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="סטטוס" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="ACTIVE">פעיל</SelectItem>
                      <SelectItem value="INACTIVE">לא פעיל</SelectItem>
                      <SelectItem value="PENDING">ממתין</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <Select
                    value={filters.availabilityStatus}
                    onValueChange={(value) =>
                      setFilters((prev) => ({
                        ...prev,
                        availabilityStatus: value as AvailabilityStatus | "all",
                      }))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="זמינות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="AVAILABLE">זמין</SelectItem>
                      <SelectItem value="UNAVAILABLE">לא זמין</SelectItem>
                      <SelectItem value="DATING">בתהליך היכרות</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </CardContent>
          )}
        </Card>
      </div>

      {/* Clients Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {getFilteredClients().map((client) => (
          <ClientCard
            key={client.id}
            client={client}
            onSendInvite={() => {
              setClientToInvite(client);
              setShowSendInviteDialog(true);
            }}
            onSuggest={() => {
              setSelectedClient(client);
              setShowNewSuggestionDialog(true);
            }}
            onCheckAvailability={() => handleCheckAvailability(client)}
          />
        ))}
      </div>

      {/* Empty State */}
      {getFilteredClients().length === 0 && (
        <div className="text-center py-12">
          <Users className="mx-auto h-12 w-12 text-gray-400" />
          <h3 className="mt-2 text-lg font-medium">אין מועמדים</h3>
          <p className="mt-1 text-sm text-gray-500">
            לא נמצאו מועמדים התואמים את החיפוש
          </p>
        </div>
      )}

      {/* Dialogs */}
      {showAddCandidateDialog && (
        <AddCandidateWizard
          isOpen={showAddCandidateDialog}
          onClose={() => setShowAddCandidateDialog(false)}
          onSuccess={() => {
            setShowAddCandidateDialog(false);
            loadClients();
          }}
        />
      )}

      <AlertDialog
        open={showSendInviteDialog}
        onOpenChange={setShowSendInviteDialog}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>שליחת הזמנה למועמד</AlertDialogTitle>
            <AlertDialogDescription>
              {clientToInvite && (
                <span>
                  שליחת הזמנה ל: {clientToInvite.firstName}{" "}
                  {clientToInvite.lastName}
                </span>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <div className="py-4">
            <Input
              type="email"
              value={inviteEmail}
              onChange={(e) => setInviteEmail(e.target.value)}
              placeholder="הזן כתובת אימייל"
              className="mt-2"
            />
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel
              onClick={() => {
                setShowSendInviteDialog(false);
                setClientToInvite(null);
                setInviteEmail("");
              }}
            >
              ביטול
            </AlertDialogCancel>
            <AlertDialogAction onClick={handleSendInvite}>
              <MailIcon className="ml-2 h-4 w-4" />
              שלח הזמנה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <NewSuggestionForm
        isOpen={showNewSuggestionDialog}
        onClose={() => {
          setShowNewSuggestionDialog(false);
          setSelectedClient(null);
        }}
        selectedClient={selectedClient}
        onSubmit={handleCreateSuggestion}
      />

      {/* Error Alert */}
      {error && (
        <AlertDialog open={!!error} onOpenChange={() => setError("")}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>שגיאה</AlertDialogTitle>
              <AlertDialogDescription>{error}</AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogAction onClick={() => setError("")}>
                הבנתי
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}
    </div>
  );
}

export default MatchmakerDashboard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\dashboard\SuggestionCard.tsx:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\forms\AddCandidateForm.tsx:
==================================================
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Gender, UserStatus } from "@prisma/client";

interface AddCandidateFormProps {
  onSuccess: () => void;
  onCancel: () => void;
}

interface FormData {
  // Basic Information
  firstName: string;
  lastName: string;
  email?: string;
  phone?: string;
  gender: Gender;
  birthDate: string;
  status: UserStatus;
  sendInvitation: boolean;

  // Personal Information
  height?: number;
  maritalStatus?: string;
  occupation?: string;
  education?: string;
  address?: string;
  city?: string;
  origin?: string;
  religiousLevel?: string;

  // Family Information
  parentStatus?: string;
  siblings?: number;
  position?: number;

  // Privacy and Contact Preferences
  contactPreference?: string;
  isProfileVisible?: boolean;
  allowDirectMessages?: boolean;
  preferredMatchmakerGender?: Gender;

  // References and Verification
  referenceName1?: string;
  referencePhone1?: string;
  referenceName2?: string;
  referencePhone2?: string;

  // Additional Information
  about?: string;
  matchingNotes?: string;
}

export default function AddCandidateForm({ onSuccess, onCancel }: AddCandidateFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");

  const { 
    register, 
    handleSubmit,
    watch,
    formState: { errors },
    setValue,
    getValues
  } = useForm<FormData>({
    defaultValues: {
      status: UserStatus.PENDING,
      isProfileVisible: true,
      allowDirectMessages: true,
      sendInvitation: false
    }
  });

  const sendInvitation = watch("sendInvitation");

  const validateAge = (birthDate: string) => {
    const age = new Date().getFullYear() - new Date(birthDate).getFullYear();
    return age >= 18 && age <= 99;
  };

  const onSubmit = async (data: FormData) => {
    try {
      setIsSubmitting(true);
      setError("");

      const response = await fetch("/api/matchmaker/candidates/invite", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          ...data,
          // אם לא נבחרה אופציית שליחת הזמנה, נשלח null במקום אימייל
          email: data.sendInvitation ? data.email : null
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to add candidate");
      }

      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to add candidate");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Basic Information Section */}
      <div className="space-y-4">
        <h3 className="text-lg font-semibold">פרטים בסיסיים</h3>
        
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label htmlFor="firstName">שם פרטי</Label>
            <Input
              id="firstName"
              {...register("firstName", { required: "שדה חובה" })}
              placeholder="שם פרטי"
            />
            {errors.firstName && (
              <p className="text-red-500 text-sm">{errors.firstName.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="lastName">שם משפחה</Label>
            <Input
              id="lastName"
              {...register("lastName", { required: "שדה חובה" })}
              placeholder="שם משפחה"
            />
            {errors.lastName && (
              <p className="text-red-500 text-sm">{errors.lastName.message}</p>
            )}
          </div>
        </div>

        <div className="space-y-2">
          <Label htmlFor="gender">מגדר</Label>
          <Select
            onValueChange={(value: Gender) => setValue("gender", value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="בחר מגדר" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="MALE">זכר</SelectItem>
              <SelectItem value="FEMALE">נקבה</SelectItem>
            </SelectContent>
          </Select>
          {errors.gender && (
            <p className="text-red-500 text-sm">{errors.gender.message}</p>
          )}
        </div>

        <div className="space-y-2">
          <Label htmlFor="birthDate">תאריך לידה</Label>
          <Input
            id="birthDate"
            type="date"
            {...register("birthDate", {
              required: "שדה חובה",
              validate: validateAge
            })}
          />
          {errors.birthDate && (
            <p className="text-red-500 text-sm">
              {errors.birthDate.type === "validate" 
                ? "הגיל חייב להיות בין 18 ל-99" 
                : errors.birthDate.message}
            </p>
          )}
        </div>
      </div>

      {/* Personal Information Section */}
      <div className="space-y-4">
        <h3 className="text-lg font-semibold">פרטים אישיים</h3>

        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label htmlFor="height">גובה (בס"מ)</Label>
            <Input
              id="height"
              type="number"
              {...register("height", {
                min: { value: 140, message: "גובה מינימלי 140 ס\"מ" },
                max: { value: 220, message: "גובה מקסימלי 220 ס\"מ" }
              })}
            />
            {errors.height && (
              <p className="text-red-500 text-sm">{errors.height.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="maritalStatus">מצב משפחתי</Label>
            <Select
              onValueChange={(value) => setValue("maritalStatus", value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר מצב משפחתי" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="רווק/ה">רווק/ה</SelectItem>
                <SelectItem value="גרוש/ה">גרוש/ה</SelectItem>
                <SelectItem value="אלמן/ה">אלמן/ה</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>

        <div className="space-y-2">
          <Label htmlFor="religiousLevel">רמת דתיות</Label>
          <Select
            onValueChange={(value) => setValue("religiousLevel", value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="בחר רמת דתיות" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="חרדי">חרדי</SelectItem>
              <SelectItem value="דתי">דתי</SelectItem>
              <SelectItem value="מסורתי">מסורתי</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label htmlFor="occupation">עיסוק</Label>
            <Input
              id="occupation"
              {...register("occupation")}
              placeholder="עיסוק נוכחי"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="education">השכלה</Label>
            <Input
              id="education"
              {...register("education")}
              placeholder="השכלה"
            />
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label htmlFor="city">עיר מגורים</Label>
            <Input
              id="city"
              {...register("city")}
              placeholder="עיר מגורים"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="origin">מוצא</Label>
            <Input
              id="origin"
              {...register("origin")}
              placeholder="מוצא"
            />
          </div>
        </div>
      </div>

      {/* Family Information Section */}
      <div className="space-y-4">
        <h3 className="text-lg font-semibold">פרטי משפחה</h3>

        <div className="grid grid-cols-3 gap-4">
          <div className="space-y-2">
            <Label htmlFor="siblings">מספר אחים ואחיות</Label>
            <Input
              id="siblings"
              type="number"
              {...register("siblings", {
                min: { value: 0, message: "ערך לא תקין" }
              })}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="position">מיקום בין האחים</Label>
            <Input
              id="position"
              type="number"
              {...register("position", {
                min: { value: 1, message: "ערך לא תקין" }
              })}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="parentStatus">מצב הורים</Label>
            <Select
              onValueChange={(value) => setValue("parentStatus", value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="נשואים">נשואים</SelectItem>
                <SelectItem value="גרושים">גרושים</SelectItem>
                <SelectItem value="אחר">אחר</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      </div>

      {/* Invitation Section */}
      <div className="space-y-4">
        <h3 className="text-lg font-semibold">שליחת הזמנה</h3>

        <div className="flex items-center space-x-2">
          <Checkbox
            id="sendInvitation"
            checked={sendInvitation}
            onCheckedChange={(checked) => setValue("sendInvitation", checked as boolean)}
          />
          <Label htmlFor="sendInvitation">שלח הזמנה להרשמה למערכת</Label>
        </div>

        {sendInvitation && (
          <div className="space-y-2">
            <Label htmlFor="email">כתובת אימייל</Label>
            <Input
              id="email"
              type="email"
              {...register("email", {
                required: sendInvitation ? "נדרש אימייל לשליחת הזמנה" : false,
                pattern: {
                  value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
                  message: "כתובת אימייל לא תקינה"
                }
              })}
              placeholder="example@domain.com"
            />
            {errors.email && (
              <p className="text-red-500 text-sm">{errors.email.message}</p>
            )}
          </div>
        )}
      </div>

      {/* Additional Information */}
      <div className="space-y-4">
        <h3 className="text-lg font-semibold">מידע נוסף</h3>

        <div className="space-y-2">
          <Label htmlFor="about">אודות</Label>
          <Textarea
            id="about"
            {...register("about")}
            placeholder="מידע כללי על המועמד..."
            rows={3}
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="matchingNotes">הערות לשידוך</Label>
          <Textarea
            id="matchingNotes"
            {...register("matchingNotes")}
            placeholder="הערות רלוונטיות לשידוך..."
            rows={3}
          />
        </div>
      </div>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="flex justify-end space-x-2">
        <Button
          type="button"
          variant="outline"
          onClick={onCancel}
          disabled={isSubmitting}
        >
          ביטול
        </Button>
        <Button type="submit" disabled={isSubmitting}>
          {isSubmitting ? "שומר..." : "הוספת מועמד"}
        </Button>
      </div>
    </form>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\forms\AddCandidateWizard.tsx:
==================================================
"use client";

import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogHeader,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogFooter,
  AlertDialogAction,
} from "@/components/ui/alert-dialog";
import {
  User,
  Mail,
  Phone,
  MapPin,
  GraduationCap,
  Heart,
  ChevronLeft,
  ChevronRight,
  Check,
} from "lucide-react";
import { Gender } from "@prisma/client";

interface Step {
  id: string;
  title: string;
  description: string;
  icon: React.ComponentType<{ className?: string }>;
}

interface FormData {
  firstName: string;
  lastName: string;
  gender: Gender | "";
  birthDate: string;
  maritalStatus: string;
  email: string;
  phone: string;
  city: string;
  address: string;
  religiousLevel: string;
  height: string;
  education: string;
  occupation: string;
  about: string;
  sendInvitation: boolean;
}

interface AddCandidateWizardProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess: () => void;
}

const steps: Step[] = [
  {
    id: "basic",
    title: "פרטים בסיסיים",
    description: "מידע אישי בסיסי על המועמד/ת",
    icon: User,
  },
  {
    id: "personal",
    title: "פרטים אישיים",
    description: "מידע נוסף על המועמד/ת",
    icon: Heart,
  },
  {
    id: "contact",
    title: "פרטי קשר",
    description: "דרכי יצירת קשר והעדפות",
    icon: Mail,
  },
  {
    id: "education",
    title: "השכלה ותעסוקה",
    description: "רקע לימודי ומקצועי",
    icon: GraduationCap,
  },
];

export default function NewAddCandidateWizard({
  isOpen,
  onClose,
  onSuccess,
}: AddCandidateWizardProps) {
  const [currentStep, setCurrentStep] = useState(0);
  const [showSuccessDialog, setShowSuccessDialog] = useState(false);
  const [formData, setFormData] = useState<FormData>({
    firstName: "",
    lastName: "",
    gender: "",
    birthDate: "",
    maritalStatus: "",
    email: "",
    phone: "",
    city: "",
    address: "",
    religiousLevel: "",
    height: "",
    education: "",
    occupation: "",
    about: "",
    sendInvitation: false,
  });

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");

  const handleInputChange = (key: keyof FormData, value: string | boolean) => {
    setFormData((prev) => ({ ...prev, [key]: value }));
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setError("");

    try {
      const response = await fetch("/api/matchmaker/candidates/invite", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        throw new Error("Failed to add candidate");
      }

      setShowSuccessDialog(true);
    } catch (error) {
      setError(error instanceof Error ? error.message : "An error occurred");
    } finally {
      setIsSubmitting(false);
    }
  };

  const canProceed = () => {
    switch (currentStep) {
      case 0:
        return formData.firstName && formData.lastName && formData.gender;
      case 1:
        return formData.maritalStatus && formData.religiousLevel;
      case 2:
        return (
          (!formData.sendInvitation || formData.email) &&
          (formData.phone || formData.email)
        );
      case 3:
        return true;
      default:
        return false;
    }
  };

  const handleSuccessClose = () => {
    setShowSuccessDialog(false);
    onSuccess();
    onClose();
  };

  const renderStepContent = () => {
    switch (currentStep) {
      case 0:
        return (
          <div className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="firstName">שם פרטי</Label>
                <Input
                  id="firstName"
                  value={formData.firstName}
                  onChange={(e) =>
                    handleInputChange("firstName", e.target.value)
                  }
                  placeholder="הכנס שם פרטי"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="lastName">שם משפחה</Label>
                <Input
                  id="lastName"
                  value={formData.lastName}
                  onChange={(e) =>
                    handleInputChange("lastName", e.target.value)
                  }
                  placeholder="הכנס שם משפחה"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label>מגדר</Label>
              <Select
                value={formData.gender}
                onValueChange={(value) =>
                  handleInputChange("gender", value as Gender)
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר מגדר" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="MALE">זכר</SelectItem>
                  <SelectItem value="FEMALE">נקבה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="birthDate">תאריך לידה</Label>
              <Input
                id="birthDate"
                type="date"
                value={formData.birthDate}
                onChange={(e) => handleInputChange("birthDate", e.target.value)}
              />
            </div>
          </div>
        );

      case 1:
        return (
          <div className="space-y-4">
            <div className="space-y-2">
              <Label>מצב משפחתי</Label>
              <Select
                value={formData.maritalStatus}
                onValueChange={(value) =>
                  handleInputChange("maritalStatus", value)
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר מצב משפחתי" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="רווק/ה">רווק/ה</SelectItem>
                  <SelectItem value="גרוש/ה">גרוש/ה</SelectItem>
                  <SelectItem value="אלמן/ה">אלמן/ה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label>רמת דתיות</Label>
              <Select
                value={formData.religiousLevel}
                onValueChange={(value) =>
                  handleInputChange("religiousLevel", value)
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר רמת דתיות" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="חרדי">חרדי</SelectItem>
                  <SelectItem value="דתי">דתי</SelectItem>
                  <SelectItem value="מסורתי">מסורתי</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="height">גובה (בס"מ)</Label>
              <Input
                id="height"
                type="number"
                value={formData.height}
                onChange={(e) => handleInputChange("height", e.target.value)}
                placeholder="הכנס גובה"
                min="140"
                max="220"
              />
            </div>
          </div>
        );

      case 2:
        return (
          <div className="space-y-4">
            <div className="flex items-center space-x-2 space-x-reverse">
              <Checkbox
                id="sendInvitation"
                checked={formData.sendInvitation}
                onCheckedChange={(checked) =>
                  handleInputChange("sendInvitation", checked as boolean)
                }
              />
              <Label htmlFor="sendInvitation">שלח הזמנה להרשמה למערכת</Label>
            </div>

            {formData.sendInvitation && (
              <div className="space-y-2">
                <Label htmlFor="email">כתובת אימייל</Label>
                <Input
                  id="email"
                  type="email"
                  value={formData.email}
                  onChange={(e) => handleInputChange("email", e.target.value)}
                  placeholder="example@domain.com"
                />
              </div>
            )}

            <div className="space-y-2">
              <Label htmlFor="phone">מספר טלפון</Label>
              <Input
                id="phone"
                value={formData.phone}
                onChange={(e) => handleInputChange("phone", e.target.value)}
                placeholder="הכנס מספר טלפון"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="city">עיר</Label>
                <Input
                  id="city"
                  value={formData.city}
                  onChange={(e) => handleInputChange("city", e.target.value)}
                  placeholder="הכנס עיר"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="address">כתובת</Label>
                <Input
                  id="address"
                  value={formData.address}
                  onChange={(e) => handleInputChange("address", e.target.value)}
                  placeholder="הכנס כתובת"
                />
              </div>
            </div>
          </div>
        );

      case 3:
        return (
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="education">השכלה</Label>
              <Input
                id="education"
                value={formData.education}
                onChange={(e) => handleInputChange("education", e.target.value)}
                placeholder="פרט/י השכלה"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="occupation">עיסוק</Label>
              <Input
                id="occupation"
                value={formData.occupation}
                onChange={(e) =>
                  handleInputChange("occupation", e.target.value)
                }
                placeholder="פרט/י עיסוק נוכחי"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="about">מידע נוסף</Label>
              <textarea
                id="about"
                value={formData.about}
                onChange={(e) => handleInputChange("about", e.target.value)}
                placeholder="מידע נוסף שחשוב לציין..."
                className="w-full min-h-[100px] p-2 border rounded-md"
              />
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>הוספת מועמד חדש</DialogTitle>
            <DialogDescription>
              מלא/י את הפרטים בטופס להוספת מועמד/ת חדש/ה למערכת
            </DialogDescription>
          </DialogHeader>

          {/* Progress Bar */}
          <div className="mb-6">
            <div className="flex justify-between mb-1 text-sm text-gray-500">
              <span>התקדמות</span>
              <span>
                {Math.round(((currentStep + 1) / steps.length) * 100)}%
              </span>
            </div>
            <div className="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
              <div
                className="h-full bg-blue-600 transition-all duration-300"
                style={{
                  width: `${((currentStep + 1) / steps.length) * 100}%`,
                }}
              />
            </div>
          </div>

          {/* Steps Indicators */}
          <div className="mb-8">
            <div className="flex justify-between">
              {steps.map((step, index) => (
                <div
                  key={step.id}
                  className={`flex flex-col items-center w-1/4 ${
                    index !== steps.length - 1
                      ? "relative after:content-[''] after:absolute after:top-5 after:right-1/2 after:w-full after:h-0.5 after:bg-gray-200"
                      : ""
                  }`}
                >
                  <div
                    className={`w-10 h-10 rounded-full flex items-center justify-center z-10 transition-colors ${
                      index <= currentStep
                        ? "bg-blue-600 text-white"
                        : "bg-gray-200 text-gray-400"
                    }`}
                  >
                    <step.icon className="w-5 h-5" />
                  </div>
                  <div className="mt-2 text-center">
                    <div className="text-sm font-medium">{step.title}</div>
                    <div className="text-xs text-gray-500 hidden md:block">
                      {step.description}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Form Content */}
          <div className="min-h-[400px] relative">
            <div className="absolute inset-0 transition-opacity duration-300">
              {renderStepContent()}
            </div>
          </div>

          {/* Navigation */}
          <div className="mt-8 flex justify-between">
            <Button
              variant="outline"
              onClick={() => setCurrentStep((prev) => prev - 1)}
              disabled={currentStep === 0}
            >
              <ChevronRight className="ml-2 h-4 w-4" />
              הקודם
            </Button>

            {currentStep < steps.length - 1 ? (
              <Button
                onClick={() => setCurrentStep((prev) => prev + 1)}
                disabled={!canProceed()}
              >
                הבא
                <ChevronLeft className="mr-2 h-4 w-4" />
              </Button>
            ) : (
              <Button
                onClick={handleSubmit}
                disabled={isSubmitting || !canProceed()}
                className="bg-green-600 hover:bg-green-700"
              >
                {isSubmitting ? (
                  "שומר..."
                ) : (
                  <>
                    סיום והוספה
                    <Check className="mr-2 h-4 w-4" />
                  </>
                )}
              </Button>
            )}
          </div>

          {error && (
            <div className="mt-4 p-3 bg-red-50 text-red-600 rounded-md">
              {error}
            </div>
          )}
        </DialogContent>
      </Dialog>

      <AlertDialog open={showSuccessDialog} onOpenChange={handleSuccessClose}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>המועמד נוסף בהצלחה</AlertDialogTitle>
            <AlertDialogDescription>
              {formData.sendInvitation
                ? "הזמנה נשלחה לכתובת האימייל שהוזנה"
                : "המועמד נוסף למאגר המועמדים שלך"}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogAction onClick={handleSuccessClose}>
              אישור
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\forms\NewSuggestionForm.tsx:
==================================================
"use client";

import React, { useState, useEffect } from "react";
import { useNotifications } from "@/app/contexts/NotificationContext";
import { useSession } from "next-auth/react";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import { Card } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Progress } from "@/components/ui/progress"; // New import for progress bar
import {
  Search,
  Heart,
  Check,
  User,
  Loader2,
  Phone,
  Mail,
  X,
  ChevronRight,
  ChevronLeft,
} from "lucide-react";
import type { Client } from "@/app/types/matchmaker";
import type { Session } from "@/types/next-auth";
import type { CreateSuggestionData } from "@/app/types/suggestions";
import { ContactMethod } from "@prisma/client";

interface ContactPreference {
  method: ContactMethod;
  value: string;
}

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  selectedClient?: Client | null;
  onSubmit: (data: CreateSuggestionData) => Promise<void>;
}

export default function NewSuggestionForm({
  isOpen,
  onClose,
  selectedClient = null,
  onSubmit,
}: NewSuggestionFormProps) {
  const { data: session } = useSession() as { data: Session | null };
  const { refreshNotifications } = useNotifications();
  const [step, setStep] = useState(1); // Track current step
  const [firstParty, setFirstParty] = useState(selectedClient?.id || "");
  const [secondParty, setSecondParty] = useState("");
  const [availableClients, setAvailableClients] = useState<Client[]>([]);
  const [internalNotes, setInternalNotes] = useState("");
  const [firstPartyNotes, setFirstPartyNotes] = useState("");
  const [secondPartyNotes, setSecondPartyNotes] = useState("");
  const [firstPartyContact, setFirstPartyContact] = useState<ContactPreference>(
    {
      method: ContactMethod.EMAIL,
      value: "",
    }
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");

  useEffect(() => {
    const selectedClientData = availableClients.find(
      (c) => c.id === firstParty
    );
    console.log(
      "Full client data structure:",
      JSON.stringify(selectedClientData, null, 2)
    );

    if (selectedClientData?.email) {
      console.log(
        "About to set email contact with value:",
        selectedClientData.email
      );
      console.log("Current firstPartyContact state:", firstPartyContact);
      setFirstPartyContact({
        method: ContactMethod.EMAIL,
        value: selectedClientData.email,
      });
      console.log("FirstPartyContact has been set to:", {
        method: ContactMethod.EMAIL,
        value: selectedClientData.email,
      });
    } else {
      console.log("No email found for selected client");
    }
  }, [firstParty, availableClients]);
  const calculateAge = (birthDate: string) => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birth.getDate())
    ) {
      age--;
    }
    return age;
  };

  const loadClients = async () => {
    try {
      setIsLoading(true);
      const response = await fetch("/api/matchmaker/clients");
      if (!response.ok) throw new Error("Failed to fetch clients");
      const data = await response.json();
      setAvailableClients(data.clients);
    } catch (error) {
      console.error("Error fetching clients:", error);
      setError(
        error instanceof Error ? error.message : "Failed to load clients"
      );
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (isOpen) {
      loadClients();
      if (selectedClient) {
        setFirstParty(selectedClient.id);
      }
    }
  }, [isOpen, selectedClient]);

  const getFilteredClients = (forFirstParty: boolean = true) => {
    return availableClients.filter((client) => {
      if (forFirstParty && client.id === secondParty) return false;
      if (!forFirstParty && client.id === firstParty) return false;

      const selectedClient = forFirstParty
        ? availableClients.find((c) => c.id === secondParty)
        : availableClients.find((c) => c.id === firstParty);

      if (selectedClient && client.gender === selectedClient.gender)
        return false;

      if (searchQuery) {
        const searchStr =
          `${client.firstName} ${client.lastName}`.toLowerCase();
        return searchStr.includes(searchQuery.toLowerCase());
      }

      return true;
    });
  };

  const ClientCard = ({
    clientId,
    onRemove,
  }: {
    clientId: string;
    onRemove?: () => void;
  }) => {
    const client = availableClients.find((c) => c.id === clientId);
    if (!client) return null;

    return (
      <Card className="p-4 bg-white shadow-sm hover:shadow-md transition-shadow duration-200">
        <div className="flex items-center justify-between">
          <div className="flex-1">
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold text-gray-900">
                {client.firstName} {client.lastName}
              </h3>
              {onRemove && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={onRemove}
                  className="hover:bg-red-50 hover:text-red-600"
                >
                  <X className="w-4 h-4" />
                </Button>
              )}
            </div>
            <div className="mt-2 space-y-1">
              <div className="flex items-center text-sm text-gray-600">
                <User className="w-4 h-4 mr-2" />
                <span>{calculateAge(client.birthDate)} שנים</span>
              </div>
              {client.personalInfo?.religiousLevel && (
                <div className="flex items-center text-sm text-gray-600">
                  <span className="mr-2">🕊</span>
                  <span>{client.personalInfo.religiousLevel}</span>
                </div>
              )}
              {client.location && (
                <div className="flex items-center text-sm text-gray-600">
                  <span className="mr-2">📍</span>
                  <span>{client.location}</span>
                </div>
              )}
              {client.personalInfo?.occupation && (
                <div className="flex items-center text-sm text-gray-600">
                  <span className="mr-2">💼</span>
                  <span>{client.personalInfo.occupation}</span>
                </div>
              )}
            </div>
          </div>
        </div>
      </Card>
    );
  };

  const ClientSelector = ({
    forFirstParty,
    onSelect,
  }: {
    forFirstParty: boolean;
    onSelect: (clientId: string) => void;
  }) => {
    const [isOpen, setIsOpen] = useState(false);

    return (
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <Label className="text-lg font-semibold">
            {forFirstParty ? "צד ראשון" : "צד שני"}
          </Label>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setIsOpen(!isOpen)}
            className="hover:bg-blue-50"
          >
            {isOpen ? "סגור" : "בחר מועמד/ת"}
          </Button>
        </div>

        {isOpen && (
          <div className="relative w-full">
            <Command className="w-full rounded-lg border shadow-md">
              <CommandInput
                placeholder="חיפוש מועמד/ת..."
                onValueChange={setSearchQuery}
                className="w-full"
              />
              <CommandList className="max-h-[200px] overflow-auto">
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {isLoading ? (
                    <div className="flex justify-center p-4">
                      <Loader2 className="w-6 h-6 animate-spin" />
                    </div>
                  ) : (
                    getFilteredClients(forFirstParty).map((client) => (
                      <CommandItem
                        key={client.id}
                        value={`${client.firstName} ${client.lastName}`}
                        onSelect={() => {
                          onSelect(client.id);
                          setIsOpen(false);
                        }}
                        className="flex items-center justify-between p-3 cursor-pointer hover:bg-gray-50"
                      >
                        <div className="flex items-center gap-2">
                          <User className="w-5 h-5 text-gray-400" />
                          <span>
                            {client.firstName} {client.lastName} -{" "}
                            {calculateAge(client.birthDate)} שנים
                          </span>
                        </div>
                        {(forFirstParty ? firstParty : secondParty) ===
                          client.id && (
                          <Check className="w-5 h-5 text-green-600" />
                        )}
                      </CommandItem>
                    ))
                  )}
                </CommandGroup>
              </CommandList>
            </Command>
          </div>
        )}
      </div>
    );
  };

  const handleFirstPartySelect = (clientId: string) => {
    console.log("handleFirstPartySelect called with ID:", clientId);
    const selectedClientData = availableClients.find((c) => c.id === clientId);
    console.log(
      "Full client data structure:",
      JSON.stringify(selectedClientData, null, 2)
    );

    console.log("Found client data:", selectedClientData);
    console.log("Client's email:", selectedClientData?.email);

    setFirstParty(clientId);

    if (selectedClientData?.email) {
      console.log("Setting contact info with email:", selectedClientData.email);
      setFirstPartyContact({
        method: ContactMethod.EMAIL,
        value: selectedClientData.email,
      });
      console.log("Contact info has been set");
    } else {
      console.log("No email found in client data");
    }
  };
  const handleSubmit = async (asDraft: boolean = true) => {
    try {
      setIsSubmitting(true);
      setError("");

      if (!firstParty || !secondParty || !session?.user?.id) {
        throw new Error("חסרים פרטים נדרשים");
      }

      // Prepare suggestion data
      const suggestionData: CreateSuggestionData = {
        matchmakerId: session.user.id,
        firstPartyId: firstParty,
        secondPartyId: secondParty,
        status: asDraft ? "DRAFT" : "PENDING_FIRST_PARTY",
        priority: "MEDIUM",
        requiresRabbinicApproval: false,
        notes: {
          internal: internalNotes || undefined,
          forFirstParty: firstPartyNotes || undefined,
          forSecondParty: secondPartyNotes || undefined,
        },
        dealBreakers: [],
        commonInterests: [],
        matchingCriteria: [],
        communications: !asDraft
          ? {
              firstParty: {
                method: firstPartyContact.method,
                value: firstPartyContact.value,
                content: firstPartyNotes || undefined,
                isUrgent: false,
                requiresResponse: true,
              },
            }
          : undefined,
      };

      console.log("Sending suggestion data:", suggestionData);

      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(suggestionData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to create suggestion");
      }

      const result = await response.json();
      console.log("Suggestion created successfully:", result);
      await refreshNotifications();
      onClose();
    } catch (err) {
      console.error("Form submission error:", err);
      setError(err instanceof Error ? err.message : "אירעה שגיאה ביצירת ההצעה");
    } finally {
      setIsSubmitting(false);
    }
  };

  const renderStepContent = () => {
    switch (step) {
      case 1:
        return (
          <div className="space-y-6">
            <ClientSelector
              forFirstParty={true}
              onSelect={handleFirstPartySelect}
            />
            {firstParty && (
              <ClientCard
                clientId={firstParty}
                onRemove={() => setFirstParty("")}
              />
            )}
            <ClientSelector forFirstParty={false} onSelect={setSecondParty} />
            {secondParty && (
              <ClientCard
                clientId={secondParty}
                onRemove={() => setSecondParty("")}
              />
            )}
          </div>
        );
      case 2:
        return (
          <div className="space-y-4 pt-4">
            <Label className="text-lg font-semibold">פרטי יצירת קשר</Label>
            <div className="space-y-4">
              <RadioGroup
                value={firstPartyContact.method}
                onValueChange={(value: ContactMethod) =>
                  setFirstPartyContact({
                    ...firstPartyContact,
                    method: value,
                  })
                }
                className="flex gap-4"
              >
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value={ContactMethod.EMAIL} id="email" />
                  <Label htmlFor="email" className="flex items-center gap-2">
                    <Mail className="w-4 h-4" />
                    אימייל
                  </Label>
                </div>
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value={ContactMethod.PHONE} id="phone" />
                  <Label htmlFor="phone" className="flex items-center gap-2">
                    <Phone className="w-4 h-4" />
                    טלפון
                  </Label>
                </div>
              </RadioGroup>

              <Input
                placeholder={
                  firstPartyContact.method === ContactMethod.EMAIL
                    ? "כתובת אימייל"
                    : "מספר טלפון"
                }
                value={firstPartyContact.value}
                onChange={(e) =>
                  setFirstPartyContact({
                    ...firstPartyContact,
                    value: e.target.value,
                  })
                }
                className="w-full"
              />
            </div>
          </div>
        );
      case 3:
        return (
          <div className="space-y-6">
            <div className="space-y-2">
              <Label className="flex items-center gap-2 text-gray-700">
                <span className="w-3 h-3 rounded-full bg-yellow-400" />
                הערות פנימיות
              </Label>
              <Textarea
                placeholder="הערות פנימיות לשימוש המשרד..."
                value={internalNotes}
                onChange={(e) => setInternalNotes(e.target.value)}
                className="min-h-[100px] resize-y"
              />
            </div>
            <div className="space-y-2">
              <Label className="flex items-center gap-2 text-gray-700">
                <span className="w-3 h-3 rounded-full bg-blue-400" />
                הערות לצד ראשון
              </Label>
              <Textarea
                placeholder="הערות שיישלחו לצד הראשון..."
                value={firstPartyNotes}
                onChange={(e) => setFirstPartyNotes(e.target.value)}
                className="min-h-[100px] resize-y"
              />
            </div>
            <div className="space-y-2">
              <Label className="flex items-center gap-2 text-gray-700">
                <span className="w-3 h-3 rounded-full bg-green-400" />
                הערות לצד שני
              </Label>
              <Textarea
                placeholder="הערות שיישלחו לצד השני..."
                value={secondPartyNotes}
                onChange={(e) => setSecondPartyNotes(e.target.value)}
                className="min-h-[100px] resize-y"
              />
            </div>
          </div>
        );
      default:
        return null;
    }
  };

  const getStepValidation = (stepNumber: number) => {
    switch (stepNumber) {
      case 1:
        return firstParty && secondParty;
      case 2:
        return firstPartyContact.value.trim() !== "";
      case 3:
        return true; // Notes are optional
      default:
        return false;
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="sm:max-w-[800px] h-[80vh] overflow-hidden"
        dir="rtl"
      >
        <DialogHeader>
          <DialogTitle className="text-2xl font-bold text-center mb-2">
            יצירת הצעת שידוך חדשה
          </DialogTitle>
          <Progress value={(step / 3) * 100} className="w-full h-2 mb-4" />
          <div className="flex justify-center gap-8 text-sm text-gray-600">
            <div
              className={`flex items-center gap-2 ${
                step >= 1 ? "text-blue-600 font-medium" : ""
              }`}
            >
              <span
                className={`w-6 h-6 rounded-full flex items-center justify-center ${
                  step >= 1 ? "bg-blue-100 text-blue-600" : "bg-gray-100"
                }`}
              >
                1
              </span>
              בחירת מועמדים
            </div>
            <div
              className={`flex items-center gap-2 ${
                step >= 2 ? "text-blue-600 font-medium" : ""
              }`}
            >
              <span
                className={`w-6 h-6 rounded-full flex items-center justify-center ${
                  step >= 2 ? "bg-blue-100 text-blue-600" : "bg-gray-100"
                }`}
              >
                2
              </span>
              פרטי קשר
            </div>
            <div
              className={`flex items-center gap-2 ${
                step >= 3 ? "text-blue-600 font-medium" : ""
              }`}
            >
              <span
                className={`w-6 h-6 rounded-full flex items-center justify-center ${
                  step >= 3 ? "bg-blue-100 text-blue-600" : "bg-gray-100"
                }`}
              >
                3
              </span>
              הערות
            </div>
          </div>
        </DialogHeader>

        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        <div className="overflow-y-auto h-[calc(80vh-280px)] px-1 my-4">
          {renderStepContent()}
        </div>

        <DialogFooter className="border-t pt-4 mt-4">
          <div className="flex justify-between w-full">
            <div>
              {step > 1 && (
                <Button
                  variant="outline"
                  onClick={() => setStep(step - 1)}
                  className="flex items-center gap-2"
                >
                  <ChevronRight className="w-4 h-4" />
                  חזור
                </Button>
              )}
            </div>
            <div className="flex gap-3">
              <Button
                variant="outline"
                onClick={onClose}
                disabled={isSubmitting}
                className="hover:bg-gray-100"
              >
                ביטול
              </Button>

              {step === 3 && (
                <>
                  <Button
                    variant="secondary"
                    onClick={() => handleSubmit(true)}
                    disabled={isSubmitting || !firstParty || !secondParty}
                    className="flex items-center gap-2 bg-pink-50 text-pink-700 hover:bg-pink-100 border-pink-200"
                  >
                    <Heart className="h-4 w-4" />
                    {isSubmitting ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      "שמירה כטיוטה"
                    )}
                  </Button>

                  <Button
                    onClick={() => handleSubmit(false)}
                    disabled={
                      isSubmitting ||
                      !firstParty ||
                      !secondParty ||
                      !firstPartyContact.value
                    }
                    className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700"
                  >
                    <User className="h-4 w-4" />
                    {isSubmitting ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      "שליחה לצד ראשון"
                    )}
                  </Button>
                </>
              )}

              {step < 3 && (
                <Button
                  onClick={() => setStep(step + 1)}
                  disabled={!getStepValidation(step)}
                  className="flex items-center gap-2"
                >
                  המשך
                  <ChevronLeft className="w-4 h-4" />
                </Button>
              )}
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidateCard\Actions.tsx:
==================================================
// /components/matchmaker/CandidateCard/Actions.tsx

"use client";

import React, { useState, useCallback } from "react";

import { Button } from "@/components/ui/button";
import { Heart, Mail, FileText, Eye, Clock, AlertCircle } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface ActionsProps {
  candidate: Candidate;
  onInvite: (candidate: Candidate) => void;
  onSuggest: (candidate: Candidate) => void;
  onCheckAvailability: (candidate: Candidate) => void;
  onViewProfile: (candidate: Candidate) => void;
  className?: string;
}

const Actions: React.FC<ActionsProps> = ({
  candidate,
  onInvite,
  onSuggest,
  onCheckAvailability,
  onViewProfile,
  className,
}) => {
  // מונע התפשטות הקליק לכרטיס המינימלי
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  return (
    <div className={`flex flex-wrap gap-2 ${className}`} onClick={handleClick}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onViewProfile(candidate)}
      >
        <Eye className="w-4 h-4 ml-2" />
        צפייה בפרופיל
      </Button>

      <Button variant="outline" size="sm" onClick={() => onInvite(candidate)}>
        <Mail className="w-4 h-4 ml-2" />
        שליחת הזמנה
      </Button>

      <Button variant="outline" size="sm" onClick={() => onSuggest(candidate)}>
        <FileText className="w-4 h-4 ml-2" />
        הצעת שידוך
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => onCheckAvailability(candidate)}
      >
        <Clock className="w-4 h-4 ml-2" />
        בדיקת זמינות
      </Button>

      <Button
        variant="ghost"
        size="sm"
        className="text-red-600 hover:text-red-700 hover:bg-red-50"
      >
        <Heart className="w-4 h-4" />
      </Button>
    </div>
  );
};

export default Actions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidateCard\MinimalCard.tsx:
==================================================
"use client";

import React, { useState, useCallback } from "react";

import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { User, MapPin, Briefcase, Calendar, Clock } from "lucide-react";
import type { Candidate } from "../types/candidates";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";

interface MinimalCandidateCardProps {
  candidate: Candidate;
  onClick: (candidate: Candidate) => void;
  className?: string;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const MinimalCandidateCard: React.FC<MinimalCandidateCardProps> = ({
  candidate,
  onClick,
  className,
}) => {
  const mainImage = candidate.images.find((img) => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);

  return (
    <Card
      className={`relative overflow-hidden cursor-pointer transition-all hover:shadow-lg ${className}`}
      onClick={() => onClick(candidate)}
    >
      {/* Background Image or Avatar */}
      <div className="relative h-48 bg-gradient-to-b from-blue-50 to-blue-100">
        {mainImage ? (
          <img
            src={mainImage.url}
            alt={`${candidate.firstName} ${candidate.lastName}`}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            <User className="w-16 h-16 text-gray-400" />
          </div>
        )}

        {/* Status Badge */}
        <div className="absolute top-3 right-3">
          <Badge
            className={
              candidate.profile.availabilityStatus === "AVAILABLE"
                ? "bg-green-100 text-green-800 border-green-200"
                : "bg-yellow-100 text-yellow-800 border-yellow-200"
            }
          >
            {candidate.profile.availabilityStatus === "AVAILABLE"
              ? "פנוי/ה"
              : "בתהליך"}
          </Badge>
        </div>
      </div>

      {/* Content */}
      <div className="p-4">
        <h3 className="text-lg font-semibold mb-2 text-right">
          {candidate.firstName} {candidate.lastName}
        </h3>

        <div className="space-y-2 text-gray-600 text-sm">
          {/* Basic Info */}
          <div className="flex items-center justify-end gap-2">
            <span>{age}</span>
            <Calendar className="w-4 h-4" />
          </div>

          {candidate.profile.city && (
            <div className="flex items-center justify-end gap-2">
              <span>{candidate.profile.city}</span>
              <MapPin className="w-4 h-4" />
            </div>
          )}

          {candidate.profile.occupation && (
            <div className="flex items-center justify-end gap-2">
              <span>{candidate.profile.occupation}</span>
              <Briefcase className="w-4 h-4" />
            </div>
          )}

          {/* Last Active */}
          {candidate.profile.lastActive && (
            <div className="flex items-center justify-end gap-2 text-xs text-gray-400">
              <span>
                {`פעיל/ה ${formatDistanceToNow(
                  new Date(candidate.profile.lastActive),
                  {
                    addSuffix: true,
                    locale: he,
                  }
                )}`}
              </span>
              <Clock className="w-3 h-3" />
            </div>
          )}
        </div>
      </div>
    </Card>
  );
};

export default MinimalCandidateCard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidateCard\QuickView.tsx:
==================================================
"use client";
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  Mail,
  Phone,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  Globe,
  Languages,
  Home,
  User,
  FileText,
} from "lucide-react";

import type { Candidate } from "../types/candidates";

interface QuickViewProps {
  candidate: Candidate;
  onAction: (action: "view" | "invite" | "suggest" | "contact" | "favorite") => void;
}

const QuickView: React.FC<QuickViewProps> = ({ candidate, onAction }) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = candidate.profile;

  return (
    <div
      className="bg-white/95 backdrop-blur-sm p-4 rounded-lg shadow-lg flex flex-col"
      onClick={handleClick}
    >
      {/* Main Content Container */}
      <div className="flex-1 space-y-4 text-right overflow-y-auto max-h-96">
        {/* Basic Stats Grid */}
        <div className="grid grid-cols-2 gap-3">
          {profile.height && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.height} ס״מ</span>
              <User className="w-4 h-4" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.maritalStatus}</span>
              <Heart className="w-4 h-4" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.religiousLevel}</span>
              <Scroll className="w-4 h-4" />
            </div>
          )}

          {profile.education && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.education}</span>
              <GraduationCap className="w-4 h-4" />
            </div>
          )}
        </div>

        {/* About Section */}
        {profile.about && (
          <div className="border-t border-gray-100 pt-3">
            <p className="text-sm text-gray-600 leading-relaxed line-clamp-3">
              {profile.about}
            </p>
          </div>
        )}

        {/* Location & Occupation */}
        <div className="border-t border-gray-100 pt-3 space-y-2">
          {profile.city && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.city}</span>
              <MapPin className="w-4 h-4" />
            </div>
          )}

          {profile.occupation && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.occupation}</span>
              <Briefcase className="w-4 h-4" />
            </div>
          )}
        </div>
      </div>

      {/* Action Buttons */}
      <div className="grid grid-cols-2 gap-2 mt-4 pt-3 border-t border-gray-100">
        <Button
          variant="default"
          className="w-full"
          onClick={() => onAction("view")}
        >
          <Eye className="w-4 h-4 ml-2" />
          צפייה בפרופיל
        </Button>

        <Button
          variant="outline"
          className="w-full"
          onClick={() => onAction("invite")}
        >
          <Mail className="w-4 h-4 ml-2" />
          שליחת הזמנה
        </Button>

        <Button
          variant="outline"
          className="w-full"
          onClick={() => onAction("suggest")}
        >
          <FileText className="w-4 h-4 ml-2" />
          הצעת שידוך
        </Button>

        <Button
          variant="outline"
          className="w-full"
          onClick={() => onAction("contact")}
        >
          <Clock className="w-4 h-4 ml-2" />
          בדיקת זמינות
        </Button>

        <Button
          variant="ghost"
          className="w-full text-red-600 hover:text-red-700 hover:bg-red-50"
          onClick={() => onAction("favorite")}
        >
          <Heart className="w-4 h-4 ml-2" />
          הוספה למועדפים
        </Button>
      </div>
    </div>
  );
};

export default QuickView;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesList.tsx:
==================================================
import React, { useState, useCallback, useEffect } from "react";
import { User } from "lucide-react";
import MinimalCard from "../CandidateCard/MinimalCard";
import QuickView from "../CandidateCard/QuickView";
import { ProfileCard } from "@/app/components/shared/shared/profile";
import type { Candidate, CandidateAction } from "../types/candidates";
import type { QuestionnaireResponse } from "@/types/next-auth";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { ActionDialogs } from "../dialogs/ActionDialogs";
import NewSuggestionForm from "../NewSuggestionForm";

interface CandidatesListProps {
  candidates: Candidate[];
  allCandidates: Candidate[];
  onCandidateClick?: (candidate: Candidate) => void;
  onCandidateAction?: (type: CandidateAction, candidate: Candidate) => void;
  viewMode: "grid" | "list";
  isLoading?: boolean;
  className?: string;
}

const CandidatesList: React.FC<CandidatesListProps> = ({
  candidates,
  allCandidates,
  onCandidateClick,
  onCandidateAction,
  viewMode,
  isLoading = false,
  className,
}) => {
  // Base states
  const [selectedCandidate, setSelectedCandidate] = useState<Candidate | null>(
    null
  );
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [isMatchmaker, setIsMatchmaker] = useState(false);
  const [hoveredCandidate, setHoveredCandidate] = useState<Candidate | null>(
    null
  );

  // Dialog states
  const [showInviteDialog, setShowInviteDialog] = useState(false);
  const [showAvailabilityDialog, setShowAvailabilityDialog] = useState(false);
  const [showSuggestDialog, setShowSuggestDialog] = useState(false);
  const [dialogCandidate, setDialogCandidate] = useState<Candidate | null>(
    null
  );
  const [error, setError] = useState<string | null>(null);

  // Load questionnaire when candidate is selected
  useEffect(() => {
    const loadQuestionnaire = async () => {
      if (!selectedCandidate) {
        setQuestionnaireResponse(null);
        return;
      }

      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${selectedCandidate.id}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          const formattedQuestionnaire = {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
          setQuestionnaireResponse(formattedQuestionnaire);
        }
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
      }
    };

    loadQuestionnaire();
  }, [selectedCandidate]);

  // Action handlers
  const handleInvite = async (candidate: Candidate, email: string) => {
    try {
      const response = await fetch("/api/matchmaker/candidates/invite", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          candidateId: candidate.id,
          email,
        }),
      });

      if (!response.ok) throw new Error("Failed to send invitation");

      toast.success("ההזמנה נשלחה בהצלחה");
      onCandidateAction?.("invite", candidate);
    } catch (error) {
      console.error("Error sending invite:", error);
      throw error;
    }
  };

  const handleAvailabilityCheck = async (candidate: Candidate) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clientId: candidate.id }),
      });

      if (!response.ok) throw new Error("Failed to check availability");

      toast.success("בדיקת הזמינות נשלחה");
      onCandidateAction?.("contact", candidate);
    } catch (error) {
      console.error("Error checking availability:", error);
      throw error;
    }
  };

  const handleCreateSuggestion = async (data: any) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      toast.success("ההצעה נוצרה בהצלחה");
      onCandidateAction?.("suggest", dialogCandidate!);
    } catch (error) {
      console.error("Error creating suggestion:", error);
      throw error;
    }
  };

  const handleAction = useCallback(
    (action: CandidateAction, candidate: Candidate) => {
      setDialogCandidate(candidate);

      switch (action) {
        case "invite":
          setShowInviteDialog(true);
          break;
        case "contact":
          setShowAvailabilityDialog(true);
          break;
        case "suggest":
          setShowSuggestDialog(true);
          break;
        case "view":
          setSelectedCandidate(candidate);
          onCandidateClick?.(candidate);
          break;
        default:
          onCandidateAction?.(action, candidate);
      }
    },
    [onCandidateAction, onCandidateClick]
  );

  if (isLoading) {
    return (
      <div
        className={`${
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 gap-4"
            : "space-y-4"
        } ${className || ""}`}
      >
        {Array.from({ length: 6 }).map((_, i) => (
          <Skeleton key={i} className="h-48 w-full" />
        ))}
      </div>
    );
  }

  if (candidates.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <User className="w-12 h-12 mb-4" />
        <p>לא נמצאו מועמדים</p>
      </div>
    );
  }

  return (
    <>
      {/* Candidates List */}
      <div
        className={`${
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 gap-4"
            : "space-y-4"
        } ${className || ""}`}
      >
        {candidates.map((candidate) => (
          <div
            key={candidate.id}
            className="group relative"
            onMouseEnter={() => setHoveredCandidate(candidate)}
            onMouseLeave={() => setHoveredCandidate(null)}
          >
            <MinimalCard
              candidate={candidate}
              onClick={() => handleAction("view", candidate)}
              className={viewMode === "list" ? "flex gap-4" : ""}
            />
            {hoveredCandidate?.id === candidate.id && (
              <div className="absolute right-0 left-0 z-10 mt-2">
                <QuickView
                  candidate={candidate}
                  onAction={(action) => handleAction(action, candidate)}
                />
              </div>
            )}
          </div>
        ))}
      </div>

      {/* Profile Dialog */}
      <Dialog
        open={!!selectedCandidate}
        onOpenChange={(open) => {
          if (!open) {
            setSelectedCandidate(null);
            setQuestionnaireResponse(null);
          }
        }}
      >
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>פרופיל מועמד</DialogTitle>
            <DialogDescription>צפייה בפרטי המועמד</DialogDescription>
            <Select
              value={isMatchmaker ? "matchmaker" : "candidate"}
              onValueChange={(value) => setIsMatchmaker(value === "matchmaker")}
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר תצוגה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="candidate">תצוגת מועמד</SelectItem>
                <SelectItem value="matchmaker">תצוגת שדכן</SelectItem>
              </SelectContent>
            </Select>
          </DialogHeader>

          {selectedCandidate && (
            <div className="space-y-6">
              <ProfileCard
                profile={selectedCandidate.profile}
                images={selectedCandidate.images}
                questionnaire={questionnaireResponse}
                viewMode={isMatchmaker ? "matchmaker" : "candidate"}
              />
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* Action Dialogs */}
      <ActionDialogs
        suggestDialog={{
          isOpen: showSuggestDialog,
          onClose: () => setShowSuggestDialog(false),
          onSubmit: handleCreateSuggestion,
          selectedCandidate: dialogCandidate,
        }}
        availabilityDialog={{
          isOpen: showAvailabilityDialog,
          onClose: () => setShowAvailabilityDialog(false),
          onCheck: handleAvailabilityCheck,
          selectedCandidate: dialogCandidate,
        }}
        inviteDialog={{
          isOpen: showInviteDialog,
          onClose: () => setShowInviteDialog(false),
          onInvite: handleInvite,
          selectedCandidate: dialogCandidate,
        }}
      />

      {/* New Suggestion Form */}
      <NewSuggestionForm
        isOpen={showSuggestDialog}
        onClose={() => setShowSuggestDialog(false)}
        candidates={allCandidates}
        selectedCandidate={selectedCandidate}
        onSubmit={handleCreateSuggestion}
      />
    </>
  );
};

export default CandidatesList;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesStats.tsx:
==================================================
// /CandidatesManager/CandidatesStats.tsx

"use client";

import React, { useState, useCallback } from "react";

import { Card } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Users,
  UserSquare2,
  HeartHandshake,
  Clock,
  MapPin,
  Scroll,
  CheckCircle,
  Image as ImageIcon,
} from "lucide-react";
import { useStatistics } from "../hooks/useStatistics";
import type { Candidate } from "../types/candidates";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from "recharts";

interface StatCardProps {
  title: string;
  value: string | number;
  description?: string;
  icon: React.ReactNode;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

interface CandidatesStatsProps {
  candidates: Candidate[];
  className?: string;
}

const CHART_COLORS = [
  "#3B82F6", // כחול
  "#EF4444", // אדום
  "#10B981", // ירוק
  "#F59E0B", // כתום
  "#6366F1", // סגול
  "#EC4899", // ורוד
];

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  icon,
  trend,
  className,
}) => (
  <Card className={`p-6 ${className}`}>
    <div className="flex items-start justify-between">
      <div className="space-y-2">
        <p className="text-sm text-gray-500">{title}</p>
        <p className="text-2xl font-semibold">{value}</p>
        {description && <p className="text-xs text-gray-400">{description}</p>}
        {trend && (
          <div
            className={`text-xs flex items-center gap-1 ${
              trend.isPositive ? "text-green-600" : "text-red-600"
            }`}
          >
            <span>{trend.isPositive ? "↑" : "↓"}</span>
            <span>{Math.abs(trend.value)}%</span>
            <span>מהחודש שעבר</span>
          </div>
        )}
      </div>
      <div className="bg-blue-50 p-3 rounded-lg">{icon}</div>
    </div>
  </Card>
);

const CandidatesStats: React.FC<CandidatesStatsProps> = ({
  candidates,
  className,
}) => {
  const {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats,
  } = useStatistics(candidates);

  const genderRatio = getGenderRatio();
  const activeUsers = getActiveUsersPercent();
  const completionStats = getProfileCompletionStats();
  const ageDistribution = getAgeGroupDistribution();
  const religiousDistribution = getReligiousDistribution();
  const activityTrend = getActivityTrend();
  const topCities = getTopCities(5);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* סטטיסטיקות עיקריות */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          title="סה״כ מועמדים"
          value={stats.gender.total}
          icon={<Users className="w-6 h-6 text-blue-600" />}
          description="סה״כ מועמדים פעילים במערכת"
        />
        <StatCard
          title="יחס מועמדים/ות"
          value={genderRatio.formattedRatio}
          icon={<UserSquare2 className="w-6 h-6 text-blue-600" />}
          description="גברים/נשים"
        />
        <StatCard
          title="פעילות בשבוע האחרון"
          value={`${activeUsers}%`}
          icon={<Clock className="w-6 h-6 text-blue-600" />}
          trend={{
            value: 5,
            isPositive: true,
          }}
        />
        <StatCard
          title="פרופילים מלאים"
          value={`${completionStats.percentage}%`}
          icon={<CheckCircle className="w-6 h-6 text-blue-600" />}
          description={`${completionStats.completed} מתוך ${stats.gender.total}`}
        />
      </div>

      {/* טאבים לניתוחים מתקדמים */}
      <Tabs defaultValue="demographics" className="w-full">
        <TabsList className="w-full justify-start">
          <TabsTrigger value="demographics">דמוגרפיה</TabsTrigger>
          <TabsTrigger value="activity">פעילות</TabsTrigger>
          <TabsTrigger value="completion">שלמות פרופילים</TabsTrigger>
        </TabsList>

        {/* דמוגרפיה */}
        <TabsContent value="demographics">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* התפלגות גילאים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות גילאים</h3>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={ageDistribution}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="range" />
                  <YAxis />
                  <Tooltip />
                  <Bar dataKey="count" fill="#3B82F6" />
                </BarChart>
              </ResponsiveContainer>
            </Card>

            {/* התפלגות דתית */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות רמת דתיות</h3>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={religiousDistribution}
                    dataKey="count"
                    nameKey="level"
                    cx="50%"
                    cy="50%"
                    outerRadius={100}
                    label
                  >
                    {religiousDistribution.map((_, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={CHART_COLORS[index % CHART_COLORS.length]}
                      />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </Card>

            {/* מיקומים מובילים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">ערים מובילות</h3>
              <div className="space-y-4">
                {topCities.map((city) => (
                  <div
                    key={city.city}
                    className="flex items-center justify-between"
                  >
                    <div className="flex items-center gap-2">
                      <MapPin className="w-4 h-4 text-blue-600" />
                      <span>{city.city}</span>
                    </div>
                    <span className="font-medium">{city.count}</span>
                  </div>
                ))}
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* פעילות */}
        <TabsContent value="activity">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* פעילות לאורך זמן */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">פעילות משתמשים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <span>פעילים בשבוע האחרון</span>
                  <span className="font-medium">{activityTrend.weekly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>פעילים בחודש האחרון</span>
                  <span className="font-medium">{activityTrend.monthly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>ממוצע ימים בין התחברויות</span>
                  <span className="font-medium">
                    {activityTrend.average} ימים
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* שלמות פרופילים */}
        <TabsContent value="completion">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">שלמות פרופילים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <ImageIcon className="w-4 h-4 text-blue-600" />
                    <span>תמונות פרופיל</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasPhotos}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <CheckCircle className="w-4 h-4 text-blue-600" />
                    <span>פרופיל מאומת</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.isVerified}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Users className="w-4 h-4 text-blue-600" />
                    <span>המלצות</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasReferences}%
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default CandidatesStats;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\index.tsx:
==================================================
"use client";

import React, { useState, useCallback, useEffect, useMemo } from "react";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Download, Filter, LayoutGrid, List, Plus } from "lucide-react";
import { toast } from "sonner";

// Custom Hooks
import { useCandidates } from "../hooks/useCandidates";
import { useFilterLogic } from "../hooks/useFilterLogic";
import useStatistics from "../hooks/useStatistics";

// Components
import SplitView from "./SplitView";
import FilterPanel from "../Filters/FilterPanel";
import ActiveFilters from "../Filters/ActiveFilters";
import SavedFilters from "../Filters/SavedFilters";
import SearchBar from "../Filters/SearchBar";
import CandidatesStats from "./CandidatesStats";
import { LoadingContainer, LoadingError } from "../shared/LoadingStates";

// Types
import type {
  Candidate,
  CardSize,
  ViewMode,
  CandidatesFilter,
  CandidateAction,
} from "../types/candidates";

// Constants
import { VIEW_OPTIONS, CARD_SIZES } from "../constants/filterOptions";

const CandidatesManager: React.FC = () => {
  // Local State
  const [viewMode, setViewMode] = useState<ViewMode>("grid");
  const [cardSize, setCardSize] = useState<CardSize>("md");
  const [showFilters, setShowFilters] = useState(false);
  const [showStats, setShowStats] = useState(false);
  const [localFilters, setLocalFilters] = useState<CandidatesFilter>({});
  const [isProcessing, setIsProcessing] = useState(false);

  // Custom Hooks
  const {
    loading,
    error,
    maleCandidates,
    femaleCandidates,
    refresh,
    exportCandidates,
    updateCandidate,
  } = useCandidates();

  const {
    filters,
    setFilters,
    savedFilters,
    saveFilter,
    deleteFilter,
    setDefaultFilter,
    loadSavedFilter,
    resetFilters,
  } = useFilterLogic({
    onFilterChange: (newFilters) => {
      setLocalFilters(newFilters);
    },
  });

  const statistics = useStatistics([...maleCandidates, ...femaleCandidates]);

  // Initialize local filters
  useEffect(() => {
    setLocalFilters(filters);
  }, [filters]);

  // Handlers
  const handleFiltersChange = useCallback(
    (newFilters: CandidatesFilter) => {
      setLocalFilters(newFilters);
      setFilters(newFilters);
    },
    [setFilters]
  );

  const handleSearch = useCallback((value: string) => {
    setLocalFilters((prev) => ({ ...prev, searchQuery: value }));
  }, []);

  const handleRemoveFilter = useCallback(
    (key: keyof CandidatesFilter, value?: string) => {
      setLocalFilters((prev) => {
        const newFilters = { ...prev };

        if (key === "cities" && value) {
          return {
            ...newFilters,
            cities: prev.cities?.filter((city) => city !== value),
          };
        }

        if (key === "occupations" && value) {
          return {
            ...newFilters,
            occupations: prev.occupations?.filter((occ) => occ !== value),
          };
        }

        delete newFilters[key];
        return newFilters;
      });
    },
    []
  );

  const handleCandidateAction = useCallback(
    async (type: CandidateAction, candidate: Candidate) => {
      if (isProcessing) return;

      setIsProcessing(true);
      try {
        switch (type) {
          case "suggest":
            // אין צורך בקריאת API כאן - הכל מטופל בתוך NewSuggestionForm
            break;

          case "invite":
            await fetch("/api/matchmaker/invitations", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ candidateId: candidate.id }),
            });
            toast.success("ההזמנה נשלחה בהצלחה");
            break;

          case "contact":
            toast.success("בקשת יצירת הקשר נשלחה");
            break;

          case "favorite":
            await fetch("/api/matchmaker/favorites", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ candidateId: candidate.id }),
            });
            toast.success("המועמד/ת נוספ/ה למועדפים");
            break;
        }
      } catch (error) {
        toast.error("אירעה שגיאה בביצוע הפעולה");
        console.error("Error processing action:", error);
      } finally {
        setIsProcessing(false);
      }
    },
    [isProcessing]
  );

  const handleFilterSave = useCallback(
    async (name: string) => {
      try {
        await saveFilter(name, localFilters);
        toast.success("הפילטר נשמר בהצלחה");
      } catch (error) {
        toast.error("שגיאה בשמירת הפילטר");
      }
    },
    [localFilters, saveFilter]
  );

  const handleExport = useCallback(async () => {
    if (isProcessing) return;

    setIsProcessing(true);
    try {
      await exportCandidates(
        [...maleCandidates, ...femaleCandidates],
        localFilters
      );
      toast.success("הנתונים יוצאו בהצלחה");
    } catch (error) {
      toast.error("שגיאה בייצוא הנתונים");
      console.error("Failed to export candidates:", error);
    } finally {
      setIsProcessing(false);
    }
  }, [
    maleCandidates,
    femaleCandidates,
    localFilters,
    exportCandidates,
    isProcessing,
  ]);

  if (error) {
    return <LoadingError message={error} onRetry={refresh} className="m-8" />;
  }

  const totalCandidates = maleCandidates.length + femaleCandidates.length;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="sticky top-0 z-10 bg-white border-b shadow-sm">
        <div className="container mx-auto py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <h1 className="text-2xl font-bold">ניהול מועמדים</h1>
              <Badge variant="outline" className="text-sm">
                {totalCandidates} מועמדים
              </Badge>
            </div>

            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowStats((prev) => !prev)}
                disabled={isProcessing}
              >
                סטטיסטיקות
              </Button>

              <Button
                variant="outline"
                size="sm"
                onClick={handleExport}
                disabled={isProcessing}
              >
                <Download className="w-4 h-4 ml-2" />
                ייצוא
              </Button>

              <Button
                onClick={() => {
                  /* Add candidate logic */
                }}
                disabled={isProcessing}
              >
                <Plus className="w-4 h-4 ml-2" />
                הוספת מועמד
              </Button>
            </div>
          </div>

          {/* Search and Filters Bar */}
          <div className="mt-4 flex gap-4">
            <SearchBar
              value={localFilters.searchQuery || ""}
              onChange={handleSearch}
              className="flex-1"
            />

            <Button
              variant="outline"
              onClick={() => setShowFilters((prev) => !prev)}
              disabled={isProcessing}
            >
              <Filter className="w-4 h-4 ml-2" />
              {showFilters ? "הסתר סינון" : "הצג סינון"}
            </Button>

            <div className="flex gap-2">
              {VIEW_OPTIONS.map((option) => (
                <Button
                  key={option.value}
                  variant={viewMode === option.value ? "default" : "outline"}
                  size="icon"
                  onClick={() => setViewMode(option.value as ViewMode)}
                  title={option.label}
                  disabled={isProcessing}
                >
                  {option.value === "grid" ? (
                    <LayoutGrid className="w-4 h-4" />
                  ) : (
                    <List className="w-4 h-4" />
                  )}
                </Button>
              ))}
            </div>
          </div>

          {/* Active Filters */}
          <ActiveFilters
            filters={localFilters}
            onRemoveFilter={handleRemoveFilter}
            onResetAll={() => {
              setLocalFilters({});
              resetFilters();
            }}
          />
        </div>
      </div>

      <div className="container mx-auto py-6">
        {/* Statistics Overview */}
        {showStats && (
          <CandidatesStats
            candidates={[...maleCandidates, ...femaleCandidates]}
            className="mb-6"
          />
        )}

        <div className="flex gap-6">
          {/* Filters Panel */}
          {showFilters && (
            <div className="w-80">
              <FilterPanel
                filters={localFilters}
                onFiltersChange={setLocalFilters}
                onReset={() => {
                  setLocalFilters({});
                  resetFilters();
                }}
                onSavePreset={handleFilterSave}
              />
            </div>
          )}

          {/* Main Content */}
          <div className="flex-1">
            {loading ? (
              <LoadingContainer>
                <SplitView
                  maleCandidates={[]}
                  femaleCandidates={[]}
                  onCandidateAction={() => {}}
                  viewMode={viewMode}
                  isLoading
                />
              </LoadingContainer>
            ) : (
              <SplitView
                maleCandidates={maleCandidates}
                femaleCandidates={femaleCandidates}
                onCandidateAction={handleCandidateAction}
                viewMode={viewMode}
                cardSize={cardSize}
              />
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default CandidatesManager;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\SplitView.tsx:
==================================================
"use client";

import React, { useState, useCallback, useMemo } from "react";
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";
import { Card } from "@/components/ui/card";
import CandidatesList from "./CandidatesList";
import StatsCard from "./StatsCard";
import { Users, UserCheck, Clock, Calendar } from "lucide-react";
import type { Candidate, CandidateAction } from "../types/candidates";

interface SplitViewProps {
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  onCandidateClick?: (candidate: Candidate) => void;
  onCandidateAction: (type: CandidateAction, candidate: Candidate) => void;
  viewMode: "grid" | "list";
  cardSize?: "sm" | "md" | "lg";
  isLoading?: boolean;
  className?: string;
}

interface Stats {
  activeCount: number;
  verifiedCount: number;
  availableCount: number;
}

const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;

const SplitView: React.FC<SplitViewProps> = ({
  maleCandidates,
  femaleCandidates,
  onCandidateClick,
  onCandidateAction,
  viewMode,
  cardSize = "md",
  isLoading = false,
  className,
}) => {
  
  // Panel configuration state
  const [panels] = useState({
    male: {
      id: "male-panel",
      minSize: 30,
      defaultSize: 50,
    },
    female: {
      id: "female-panel",
      minSize: 30,
      defaultSize: 50,
    },
  });

  // Wrapper function for handling all action types
  // SplitView.tsx
  const handleAction = useCallback(
    (type: CandidateAction, candidate: Candidate) => {
      if (type === "view" && onCandidateClick) {
        // בדיקה אם הפונקציה קיימת
        onCandidateClick(candidate);
        return;
      }
      onCandidateAction(type, candidate);
    },
    [onCandidateAction, onCandidateClick]
  );

  // Memoized stats calculations
  const calculateStats = useCallback((candidates: Candidate[]): Stats => {
    const now = Date.now();

    return {
      activeCount: candidates.filter(
        (c) =>
          c.profile.lastActive &&
          new Date(c.profile.lastActive).getTime() > now - ONE_WEEK
      ).length,

      verifiedCount: candidates.filter((c) => c.isVerified).length,

      availableCount: candidates.filter(
        (c) => c.profile.availabilityStatus === "AVAILABLE"
      ).length,
    };
  }, []);

  const maleStats = useMemo(
    () => calculateStats(maleCandidates),
    [maleCandidates, calculateStats]
  );

  const femaleStats = useMemo(
    () => calculateStats(femaleCandidates),
    [femaleCandidates, calculateStats]
  );

  const renderStats = (stats: Stats, total: number) => (
    <div className="grid grid-cols-4 gap-3 mb-4">
      <StatsCard icon={Users} title="סה״כ" value={total} variant="default" />
      <StatsCard
        icon={Clock}
        title="פעילים"
        value={stats.activeCount}
        variant="success"
        trend={{
          value: Math.round((stats.activeCount / total) * 100),
          label: "מכלל המועמדים",
          isPositive: true,
        }}
      />
      <StatsCard
        icon={UserCheck}
        title="מאומתים"
        value={stats.verifiedCount}
        variant="success"
        trend={{
          value: Math.round((stats.verifiedCount / total) * 100),
          label: "מכלל המועמדים",
          isPositive: true,
        }}
      />
      <StatsCard
        icon={Calendar}
        title="פנויים"
        value={stats.availableCount}
        variant="warning"
        trend={{
          value: Math.round((stats.availableCount / total) * 100),
          label: "מכלל המועמדים",
          isPositive: true,
        }}
      />
    </div>
  );

  return (
    <div className={`${className || ""}`}>
      <ResizablePanelGroup
        direction="horizontal"
        className="min-h-[800px] rounded-lg bg-white shadow-sm border"
      >
        {/* צד ימין - מועמדים */}
        <ResizablePanel
          id={panels.male.id}
          defaultSize={panels.male.defaultSize}
          minSize={panels.male.minSize}
        >
          <div className="p-6">
            <div className="mb-6">
              <h2 className="text-xl font-semibold mb-4">מועמדים</h2>
              {renderStats(maleStats, maleCandidates.length)}
            </div>
            <CandidatesList
              candidates={maleCandidates}
              allCandidates={[...maleCandidates, ...femaleCandidates]}  // חדש!
              onCandidateClick={onCandidateClick}
              onCandidateAction={handleAction}
              viewMode={viewMode}
              isLoading={isLoading}
              className="min-h-[600px]"
            />
          </div>
        </ResizablePanel>

        <ResizableHandle className="w-2 bg-gray-100 hover:bg-gray-200 transition-colors" />

        {/* צד שמאל - מועמדות */}
        <ResizablePanel
          id={panels.female.id}
          defaultSize={panels.female.defaultSize}
          minSize={panels.female.minSize}
        >
          <div className="p-6">
            <div className="mb-6">
              <h2 className="text-xl font-semibold mb-4">מועמדות</h2>
              {renderStats(femaleStats, femaleCandidates.length)}
            </div>
            <CandidatesList
              candidates={femaleCandidates}
              allCandidates={[...maleCandidates, ...femaleCandidates]}  // חדש!
              onCandidateClick={onCandidateClick}
              onCandidateAction={handleAction}
              viewMode={viewMode}
              isLoading={isLoading}
              className="min-h-[600px]"
            />
          </div>
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  );
};

export default SplitView;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\StatsCard.tsx:
==================================================
"use client";

import React, { useState, useCallback } from "react";

import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };
  variant?: "default" | "success" | "warning" | "destructive";
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  variant = "default",
  className,
}) => {
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "bg-emerald-50 dark:bg-emerald-900/20";
      case "warning":
        return "bg-amber-50 dark:bg-amber-900/20";
      case "destructive":
        return "bg-red-50 dark:bg-red-900/20";
      default:
        return "bg-card";
    }
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-shadow p-4",
        getVariantStyles(),
        className
      )}
    >
      <div className="flex items-center gap-3">
        <div className="p-2 bg-primary/10 rounded-lg">
          <Icon className="w-5 h-5 text-primary" />
        </div>

        <div className="flex-1">
          <p className="text-sm text-muted-foreground">{title}</p>
          <h3 className="text-xl font-semibold mt-1">{value}</h3>

          {trend && (
            <div className="flex items-center gap-1 mt-1">
              <span
                className={cn(
                  "text-sm font-medium",
                  trend.isPositive ? "text-emerald-600" : "text-red-600"
                )}
              >
                {trend.value}%
              </span>
              <span className="text-xs text-muted-foreground">
                {trend.label}
              </span>
            </div>
          )}
        </div>
      </div>
    </Card>
  );
};

export default StatsCard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\constants\filterOptions.ts:
==================================================
// /constants/filterOptions.ts
import { Gender, AvailabilityStatus } from '@prisma/client';

export const AGE_RANGE = {
  min: 18,
  max: 99,
  default: {
    min: 20,
    max: 35
  }
};

export const HEIGHT_RANGE = {
  min: 140,
  max: 210,
  default: {
    min: 150,
    max: 190
  }
};

export const RELIGIOUS_LEVELS = [
  { value: 'חרדי', label: 'חרדי' },
  { value: 'דתי לאומי', label: 'דתי לאומי' },
  { value: 'דתי', label: 'דתי' },
  { value: 'מסורתי', label: 'מסורתי' }
];

export const EDUCATION_LEVELS = [
  { value: 'תיכונית', label: 'השכלה תיכונית' },
  { value: 'ישיבה', label: 'ישיבה' },
  { value: 'סמינר', label: 'סמינר' },
  { value: 'תואר ראשון', label: 'תואר ראשון' },
  { value: 'תואר שני', label: 'תואר שני' },
  { value: 'דוקטורט', label: 'דוקטורט' }
];

export const MARITAL_STATUS = [
  { value: 'רווק/ה', label: 'רווק/ה' },
  { value: 'גרוש/ה', label: 'גרוש/ה' },
  { value: 'אלמן/ה', label: 'אלמן/ה' }
];

export const OCCUPATION_CATEGORIES = [
  { value: 'חינוך', label: 'חינוך והוראה' },
  { value: 'הייטק', label: 'הייטק ותוכנה' },
  { value: 'רפואה', label: 'רפואה ובריאות' },
  { value: 'משפטים', label: 'משפטים' },
  { value: 'עסקים', label: 'עסקים וכלכלה' },
  { value: 'שירותים', label: 'שירותים' },
  { value: 'אחר', label: 'אחר' }
];

export const REGIONS = [
  { value: 'ירושלים', label: 'ירושלים והסביבה' },
  { value: 'תל אביב', label: 'תל אביב והמרכז' },
  { value: 'חיפה', label: 'חיפה והצפון' },
  { value: 'באר שבע', label: 'באר שבע והדרום' },
  { value: 'יהודה ושומרון', label: 'יהודה ושומרון' }
];

export const POPULAR_CITIES = [
  'ירושלים',
  'תל אביב',
  'חיפה',
  'בני ברק',
  'פתח תקווה',
  'אשדוד',
  'נתניה',
  'באר שבע',
  'חולון',
  'רמת גן',
  'בית שמש',
  'מודיעין עילית',
  'אלעד',
  'ביתר עילית'
];

export const AVAILABILITY_STATUS_OPTIONS = [
  { 
    value: AvailabilityStatus.AVAILABLE, 
    label: 'פנוי/ה',
    description: 'מועמד/ת פנוי/ה להצעות'
  },
  { 
    value: AvailabilityStatus.DATING, 
    label: 'בתהליך הכרות',
    description: 'נמצא/ת בתהליך הכרות'
  },
  { 
    value: AvailabilityStatus.UNAVAILABLE, 
    label: 'לא פנוי/ה',
    description: 'לא פנוי/ה להצעות כרגע'
  }
];

export const SORT_OPTIONS = [
  { 
    value: 'lastActive',
    label: 'פעילות אחרונה',
    defaultOrder: 'desc'
  },
  { 
    value: 'age',
    label: 'גיל',
    defaultOrder: 'asc'
  },
  { 
    value: 'name',
    label: 'שם',
    defaultOrder: 'asc'
  },
  { 
    value: 'city',
    label: 'עיר',
    defaultOrder: 'asc'
  },
  { 
    value: 'religiousLevel',
    label: 'רמת דתיות',
    defaultOrder: 'asc'
  },
  { 
    value: 'height',
    label: 'גובה',
    defaultOrder: 'desc'
  },
  { 
    value: 'registrationDate',
    label: 'תאריך הרשמה',
    defaultOrder: 'desc'
  }
];

export const VIEW_OPTIONS = [
  {
    value: 'grid',
    label: 'תצוגת גריד',
    icon: 'LayoutGrid'
  },
  {
    value: 'list',
    label: 'תצוגת רשימה',
    icon: 'List'
  }
];

export const CARD_SIZES = [
  {
    value: 'sm',
    label: 'קטן',
    dimensions: {
      grid: 'h-64',
      list: 'h-24'
    }
  },
  {
    value: 'md',
    label: 'בינוני',
    dimensions: {
      grid: 'h-80',
      list: 'h-32'
    }
  },
  {
    value: 'lg',
    label: 'גדול',
    dimensions: {
      grid: 'h-96',
      list: 'h-40'
    }
  }
];

export const GROUP_BY_OPTIONS = [
  {
    value: 'none',
    label: 'ללא קיבוץ'
  },
  {
    value: 'city',
    label: 'עיר'
  },
  {
    value: 'religiousLevel',
    label: 'רמת דתיות'
  },
  {
    value: 'ageGroup',
    label: 'קבוצת גיל'
  },
  {
    value: 'availability',
    label: 'סטטוס זמינות'
  }
];

export const DEFAULT_FILTERS = {
  gender: undefined,
  ageRange: AGE_RANGE.default,
  heightRange: HEIGHT_RANGE.default,
  cities: [],
  religiousLevel: undefined,
  occupations: [],
  availability: undefined,
  searchQuery: '',
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined
};

export const FILTER_CATEGORIES = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'education', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availability', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\constants\matchingCriteria.ts:
==================================================
// /constants/matchingCriteria.ts

export const CRITERIA_WEIGHTS = {
    // קריטריונים בסיסיים
    age: {
      weight: 15,
      description: 'התאמת גיל',
      thresholds: {
        perfect: 2,  // הפרש של עד שנתיים
        good: 5,     // הפרש של עד 5 שנים
        fair: 8      // הפרש של עד 8 שנים
      }
    },
    
    religiousLevel: {
      weight: 20,
      description: 'התאמה דתית',
      bonusPoints: {
        exactMatch: 1.0,        // התאמה מדויקת
        adjacentLevel: 0.8,     // רמה דתית סמוכה
        twoLevelsApart: 0.4     // הפרש של שתי רמות
      }
    },
  
    location: {
      weight: 10,
      description: 'מיקום גיאוגרפי',
      bonusPoints: {
        sameCity: 1.0,          // אותה עיר
        sameRegion: 0.8,        // אותו אזור
        preferredCity: 0.7,     // עיר מועדפת
        differentRegion: 0.4    // אזור אחר
      }
    },
  
    // קריטריונים מקצועיים והשכלתיים
    education: {
      weight: 8,
      description: 'רמת השכלה',
      bonusPoints: {
        sameLevel: 1.0,         // רמת השכלה זהה
        adjacentLevel: 0.8,     // רמת השכלה סמוכה
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    occupation: {
      weight: 7,
      description: 'תחום עיסוק',
      bonusPoints: {
        sameField: 1.0,         // אותו תחום
        relatedField: 0.8,      // תחום קרוב
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    // קריטריונים אישיים
    familyBackground: {
      weight: 12,
      description: 'רקע משפחתי',
      factors: {
        origin: 0.4,            // מוצא
        parentStatus: 0.3,      // מצב הורים
        familyType: 0.3         // סוג משפחה
      }
    },
  
    personalityMatch: {
      weight: 15,
      description: 'התאמה אישיותית',
      factors: {
        hobbies: 0.3,           // תחביבים משותפים
        lifestyle: 0.4,         // סגנון חיים
        values: 0.3             // ערכים משותפים
      }
    },
  
    // גורמים נוספים
    preferences: {
      weight: 8,
      description: 'העדפות אישיות',
      factors: {
        agePreference: 0.3,     // העדפות גיל
        locationPreference: 0.3, // העדפות מיקום
        otherPreferences: 0.4   // העדפות נוספות
      }
    },
  
    compatibility: {
      weight: 5,
      description: 'תאימות כללית',
      factors: {
        language: 0.3,          // שפה משותפת
        culture: 0.4,           // תרבות
        lifestyle: 0.3          // סגנון חיים
      }
    }
  };
  
  // סף ציון להתאמה טובה
  export const MATCH_THRESHOLDS = {
    EXCELLENT: 85,  // התאמה מצוינת
    GOOD: 75,       // התאמה טובה
    FAIR: 65,       // התאמה סבירה
    POOR: 50        // התאמה חלשה
  };
  
  // משקלים יחסיים לפי סוג התאמה
  export const MATCH_TYPE_WEIGHTS = {
    PRECISE: {     // התאמה מדויקת
      exact: 1.0,
      similar: 0.8,
      partial: 0.5
    },
    FLEXIBLE: {    // התאמה גמישה
      exact: 0.8,
      similar: 1.0,
      partial: 0.7
    },
    OPEN: {        // התאמה פתוחה
      exact: 0.7,
      similar: 0.9,
      partial: 1.0
    }
  };
  
  // הגדרת קטגוריות להתאמה
  export const MATCH_CATEGORIES = {
    IMMEDIATE: {
      minScore: 90,
      label: 'התאמה מיידית',
      description: 'התאמה גבוהה מאוד, מומלץ ליצור קשר בהקדם'
    },
    HIGH: {
      minScore: 80,
      label: 'התאמה גבוהה',
      description: 'התאמה טובה מאוד, שווה לבדוק'
    },
    GOOD: {
      minScore: 70,
      label: 'התאמה טובה',
      description: 'יש פוטנציאל טוב להתאמה'
    },
    MODERATE: {
      minScore: 60,
      label: 'התאמה בינונית',
      description: 'יש נקודות משותפות, אבל גם הבדלים'
    },
    LOW: {
      minScore: 50,
      label: 'התאמה נמוכה',
      description: 'יש פערים משמעותיים בין המועמדים'
    }
  };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\dialogs\ActionDialogs.tsx:
==================================================
"use client";

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Send, Clock, Mail, Loader2, Calendar, Users } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface ActionDialogsProps {
  suggestDialog: {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: any) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  availabilityDialog: {
    isOpen: boolean;
    onClose: () => void;
    onCheck: (candidate: Candidate) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  inviteDialog: {
    isOpen: boolean;
    onClose: () => void;
    onInvite: (candidate: Candidate, email: string) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
}

export const ActionDialogs: React.FC<ActionDialogsProps> = ({
  suggestDialog,
  availabilityDialog,
  inviteDialog,
}) => {
  // State for invite dialog
  const [inviteEmail, setInviteEmail] = useState("");
  const [isInviting, setIsInviting] = useState(false);
  const [inviteError, setInviteError] = useState<string | null>(null);

  // State for availability dialog
  const [isChecking, setIsChecking] = useState(false);
  const [availabilityError, setAvailabilityError] = useState<string | null>(
    null
  );

  // State for suggest dialog
  const [isSuggesting, setIsSuggesting] = useState(false);
  const [suggestError, setSuggestError] = useState<string | null>(null);

  // Handler for invite submission
  const handleInviteSubmit = async () => {
    if (!inviteDialog.selectedCandidate || !inviteEmail) return;

    try {
      setIsInviting(true);
      setInviteError(null);
      await inviteDialog.onInvite(inviteDialog.selectedCandidate, inviteEmail);
      setInviteEmail("");
      inviteDialog.onClose();
    } catch (error) {
      setInviteError(
        error instanceof Error ? error.message : "Failed to send invitation"
      );
    } finally {
      setIsInviting(false);
    }
  };

  // Handler for availability check
  const handleAvailabilityCheck = async () => {
    if (!availabilityDialog.selectedCandidate) return;

    try {
      setIsChecking(true);
      setAvailabilityError(null);
      await availabilityDialog.onCheck(availabilityDialog.selectedCandidate);
      availabilityDialog.onClose();
    } catch (error) {
      setAvailabilityError(
        error instanceof Error ? error.message : "Failed to check availability"
      );
    } finally {
      setIsChecking(false);
    }
  };

  return (
    <>
      {/* Invite Dialog */}
      <Dialog open={inviteDialog.isOpen} onOpenChange={inviteDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>שליחת הזמנה למועמד</DialogTitle>
            <DialogDescription>
              {inviteDialog.selectedCandidate && (
                <span>
                  שליחת הזמנה ל: {inviteDialog.selectedCandidate.firstName}{" "}
                  {inviteDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            <div>
              <Label>כתובת אימייל</Label>
              <Input
                type="email"
                value={inviteEmail}
                onChange={(e) => setInviteEmail(e.target.value)}
                placeholder="הזן כתובת אימייל"
                className="mt-2"
              />
            </div>

            {inviteError && (
              <Alert variant="destructive">
                <AlertDescription>{inviteError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={inviteDialog.onClose}
              disabled={isInviting}
            >
              ביטול
            </Button>
            <Button
              onClick={handleInviteSubmit}
              disabled={isInviting || !inviteEmail}
            >
              {isInviting ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Mail className="ml-2 h-4 w-4" />
              )}
              {isInviting ? "שולח..." : "שלח הזמנה"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Availability Check Dialog */}
      <Dialog
        open={availabilityDialog.isOpen}
        onOpenChange={availabilityDialog.onClose}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>בדיקת זמינות</DialogTitle>
            <DialogDescription>
              {availabilityDialog.selectedCandidate && (
                <span>
                  בדיקת זמינות עבור:{" "}
                  {availabilityDialog.selectedCandidate.firstName}{" "}
                  {availabilityDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            {availabilityError && (
              <Alert variant="destructive">
                <AlertDescription>{availabilityError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={availabilityDialog.onClose}
              disabled={isChecking}
            >
              ביטול
            </Button>
            <Button onClick={handleAvailabilityCheck} disabled={isChecking}>
              {isChecking ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Clock className="ml-2 h-4 w-4" />
              )}
              {isChecking ? "בודק..." : "בדוק זמינות"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Suggest Match Dialog */}
      <Dialog open={suggestDialog.isOpen} onOpenChange={suggestDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>הצעת שידוך חדשה</DialogTitle>
            <DialogDescription>
              {suggestDialog.selectedCandidate && (
                <span>
                  יצירת הצעת שידוך עבור:{" "}
                  {suggestDialog.selectedCandidate.firstName}{" "}
                  {suggestDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>
          {/* תוכן הדיאלוג יועבר מהקומפוננטה NewSuggestionForm */}
        </DialogContent>
      </Dialog>
    </>
  );
};

export default ActionDialogs;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\ActiveFilters.tsx:
==================================================
// /components/matchmaker/Filters/ActiveFilters.tsx

"use client";
import React from "react";
import { X } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import type { CandidatesFilter } from "../types/candidates";

interface ActiveFiltersProps {
  filters: CandidatesFilter;
  onRemoveFilter: (key: keyof CandidatesFilter, value?: string) => void;
  onResetAll: () => void;
}

const ActiveFilters: React.FC<ActiveFiltersProps> = ({
  filters,
  onRemoveFilter,
  onResetAll,
}) => {
  const getActiveFilters = () => {
    const activeFilters = [];

    // Age Range
    if (filters.ageRange) {
      activeFilters.push({
        key: "ageRange",
        label: `גיל: ${filters.ageRange.min}-${filters.ageRange.max}`,
      });
    }

    // Height Range
    if (filters.heightRange) {
      activeFilters.push({
        key: "heightRange",
        label: `גובה: ${filters.heightRange.min}-${filters.heightRange.max} ס"מ`,
      });
    }

    // Religious Level
    if (filters.religiousLevel) {
      activeFilters.push({
        key: "religiousLevel",
        label: `רמת דתיות: ${filters.religiousLevel}`,
      });
    }

    // Education Level
    if (filters.educationLevel) {
      activeFilters.push({
        key: "educationLevel",
        label: `השכלה: ${filters.educationLevel}`,
      });
    }

    // Cities
    filters.cities?.forEach((city) => {
      activeFilters.push({
        key: "cities",
        value: city,
        label: `עיר: ${city}`,
      });
    });

    // Occupations
    filters.occupations?.forEach((occupation) => {
      activeFilters.push({
        key: "occupations",
        value: occupation,
        label: `תחום עיסוק: ${occupation}`,
      });
    });

    // Availability Status
    if (filters.availabilityStatus) {
      activeFilters.push({
        key: "availabilityStatus",
        label: `סטטוס: ${
          filters.availabilityStatus === "AVAILABLE"
            ? "פנוי/ה"
            : filters.availabilityStatus === "DATING"
            ? "בתהליך הכרות"
            : "לא פנוי/ה"
        }`,
      });
    }

    // Search Query
    if (filters.searchQuery) {
      activeFilters.push({
        key: "searchQuery",
        label: `חיפוש: ${filters.searchQuery}`,
      });
    }

    return activeFilters;
  };

  const activeFilters = getActiveFilters();

  if (activeFilters.length === 0) {
    return null;
  }

  return (
    <div className="p-4 bg-gray-50 rounded-lg mt-4">
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-sm text-gray-500">סינון פעיל</h3>
        <Button
          variant="ghost"
          size="sm"
          onClick={onResetAll}
          className="text-gray-500 hover:text-gray-700"
        >
          נקה הכל
        </Button>
      </div>
      <div className="flex flex-wrap gap-2">
        {activeFilters.map((filter, index) => (
          <Badge
            key={`${filter.key}-${index}`}
            variant="secondary"
            className="px-3 py-1 bg-white"
          >
            <span>{filter.label}</span>
            <button
              className="ml-2 hover:text-red-500 focus:outline-none"
              onClick={() =>
                onRemoveFilter(
                  filter.key as keyof CandidatesFilter,
                  filter.value
                )
              }
              aria-label={`הסר פילטר ${filter.label}`}
            >
              <X className="w-3 h-3" />
            </button>
          </Badge>
        ))}
      </div>
    </div>
  );
};

export default ActiveFilters;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\FilterPanel.tsx:
==================================================
// /Filters/FilterPanel.tsx
import React, { useState } from 'react';
import { Card } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Slider } from '@/components/ui/slider';
import { Switch } from '@/components/ui/switch';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { ScrollArea } from '@/components/ui/scroll-area';
import {
  Save,
  User,
  GraduationCap,
  MapPin,
  Scroll,
  Heart,
  Calendar,
  ChevronDown,
  ChevronUp,
  Clock,
  CheckCircle,
  Ruler
} from 'lucide-react';

import type { CandidatesFilter } from '../types/candidates';
import { 
  AGE_RANGE,
  HEIGHT_RANGE,
  RELIGIOUS_LEVELS,
  EDUCATION_LEVELS,
  OCCUPATION_CATEGORIES,
  POPULAR_CITIES,
  AVAILABILITY_STATUS_OPTIONS
} from '../constants/filterOptions';

interface FilterPanelProps {
  filters: CandidatesFilter;
  onFiltersChange: (filters: CandidatesFilter) => void;
  onSavePreset?: (name: string) => void;
  onReset: () => void;
  className?: string;
}

interface FilterSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
  defaultOpen?: boolean;
}

const FilterSection: React.FC<FilterSectionProps> = ({
  title,
  icon,
  children,
  defaultOpen = false
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <Collapsible
      open={isOpen}
      onOpenChange={setIsOpen}
      className="border rounded-lg p-4"
    >
      <CollapsibleTrigger asChild>
        <div className="flex items-center justify-between cursor-pointer">
          <div className="flex items-center gap-2">
            {icon}
            <span className="font-medium">{title}</span>
          </div>
          {isOpen ? <ChevronUp size={16} /> : <ChevronDown size={16} />}
        </div>
      </CollapsibleTrigger>
      <CollapsibleContent className="pt-4">
        {children}
      </CollapsibleContent>
    </Collapsible>
  );
};

const FilterPanel: React.FC<FilterPanelProps> = ({
  filters,
  onFiltersChange,
  onSavePreset,
  onReset,
  className
}) => {
  const [showSavePreset, setShowSavePreset] = useState(false);
  const [presetName, setPresetName] = useState('');

  const handleSavePreset = () => {
    if (presetName && onSavePreset) {
      onSavePreset(presetName);
      setPresetName('');
      setShowSavePreset(false);
    }
  };

  const handleAgeRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      ageRange: { min: value[0], max: value[1] }
    });
  };

  const handleHeightRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      heightRange: { min: value[0], max: value[1] }
    });
  };

  return (
    <Card className={`space-y-6 p-4 ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between">
        <h3 className="font-semibold text-lg">סינון מועמדים</h3>
        <div className="flex gap-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={onReset}
          >
            איפוס
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => setShowSavePreset(!showSavePreset)}
          >
            <Save className="w-4 h-4" />
          </Button>
        </div>
      </div>

      {/* Save Preset Form */}
      {showSavePreset && (
        <div className="p-4 border rounded-lg bg-muted/50">
          <Label>שם לשמירת הפילטר</Label>
          <div className="flex gap-2 mt-2">
            <Input
              value={presetName}
              onChange={(e) => setPresetName(e.target.value)}
              placeholder="פילטר מותאם אישית"
              size="sm"
            />
            <Button size="sm" onClick={handleSavePreset}>
              שמור
            </Button>
          </div>
        </div>
      )}

      <div className="space-y-4">
        {/* Basic Filters */}
        <FilterSection
          title="מידע בסיסי"
          icon={<User className="w-4 h-4 text-blue-600" />}
          defaultOpen={true}
        >
          {/* Age Range */}
          <div className="space-y-4">
            <div className="space-y-2">
              <Label className="flex items-center gap-2">
                <Calendar className="w-4 h-4" />
                גיל
              </Label>
              <Slider
                defaultValue={[AGE_RANGE.default.min, AGE_RANGE.default.max]}
                min={AGE_RANGE.min}
                max={AGE_RANGE.max}
                step={1}
                value={[
                  filters.ageRange?.min || AGE_RANGE.default.min,
                  filters.ageRange?.max || AGE_RANGE.default.max
                ]}
                onValueChange={handleAgeRangeChange}
              />
              <div className="flex justify-between text-sm text-gray-500">
                <span>{filters.ageRange?.min || AGE_RANGE.default.min}</span>
                <span>{filters.ageRange?.max || AGE_RANGE.default.max}</span>
              </div>
            </div>

            {/* Height Range */}
            <div className="space-y-2">
              <Label className="flex items-center gap-2">
                <Ruler className="w-4 h-4" />
                גובה (ס"מ)
              </Label>
              <Slider
                defaultValue={[HEIGHT_RANGE.default.min, HEIGHT_RANGE.default.max]}
                min={HEIGHT_RANGE.min}
                max={HEIGHT_RANGE.max}
                step={1}
                value={[
                  filters.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters.heightRange?.max || HEIGHT_RANGE.default.max
                ]}
                onValueChange={handleHeightRangeChange}
              />
              <div className="flex justify-between text-sm text-gray-500">
                <span>{filters.heightRange?.min || HEIGHT_RANGE.default.min} ס"מ</span>
                <span>{filters.heightRange?.max || HEIGHT_RANGE.default.max} ס"מ</span>
              </div>
            </div>
          </div>
        </FilterSection>

        {/* Religious Level */}
        <FilterSection
          title="רמת דתיות"
          icon={<Scroll className="w-4 h-4 text-blue-600" />}
        >
          <div className="space-y-2">
            <Select
              value={filters.religiousLevel}
              onValueChange={(value) =>
                onFiltersChange({ ...filters, religiousLevel: value })
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר רמת דתיות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">הכל</SelectItem>
                {RELIGIOUS_LEVELS.map((level) => (
                  <SelectItem key={level.value} value={level.value}>
                    {level.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </FilterSection>

        {/* Location */}
        <FilterSection
          title="מיקום"
          icon={<MapPin className="w-4 h-4 text-blue-600" />}
        >
          <ScrollArea className="h-48 rounded-md border p-2">
            {POPULAR_CITIES.map((city) => (
              <div key={city} className="flex items-center space-x-2 py-1">
                <Switch
                  checked={filters.cities?.includes(city)}
                  onCheckedChange={(checked) => {
                    const newCities = checked
                      ? [...(filters.cities || []), city]
                      : filters.cities?.filter((c) => c !== city);
                    onFiltersChange({ ...filters, cities: newCities });
                  }}
                />
                <Label>{city}</Label>
              </div>
            ))}
          </ScrollArea>
        </FilterSection>

        {/* Occupation & Education */}
        <FilterSection
          title="תעסוקה והשכלה"
          icon={<GraduationCap className="w-4 h-4 text-blue-600" />}
        >
          <div className="space-y-4">
            <Select
              value={filters.educationLevel}
              onValueChange={(value) =>
                onFiltersChange({ ...filters, educationLevel: value })
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="רמת השכלה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">הכל</SelectItem>
                {EDUCATION_LEVELS.map((level) => (
                  <SelectItem key={level.value} value={level.value}>
                    {level.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            <ScrollArea className="h-48 rounded-md border p-2">
              {OCCUPATION_CATEGORIES.map((occupation) => (
                <div key={occupation.value} className="flex items-center space-x-2 py-1">
                  <Switch
                    checked={filters.occupations?.includes(occupation.value)}
                    onCheckedChange={(checked) => {
                      const newOccupations = checked
                        ? [...(filters.occupations || []), occupation.value]
                        : filters.occupations?.filter((o) => o !== occupation.value);
                      onFiltersChange({ ...filters, occupations: newOccupations });
                    }}
                  />
                  <Label>{occupation.label}</Label>
                </div>
              ))}
            </ScrollArea>
          </div>
        </FilterSection>

        {/* Availability & Status */}
        <FilterSection
          title="זמינות ומצב"
          icon={<Clock className="w-4 h-4 text-blue-600" />}
        >
          <div className="space-y-4">
            <Select
              value={filters.availabilityStatus}
              onValueChange={(value) =>
                onFiltersChange({ ...filters, availabilityStatus: value })
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="סטטוס זמינות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">הכל</SelectItem>
                {AVAILABILITY_STATUS_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            <div className="flex items-center space-x-2">
              <Switch
                checked={filters.isVerified}
                onCheckedChange={(checked) =>
                  onFiltersChange({ ...filters, isVerified: checked })
                }
              />
              <Label>מועמדים מאומתים בלבד</Label>
            </div>

            <div className="flex items-center space-x-2">
              <Switch
                checked={filters.hasReferences}
                onCheckedChange={(checked) =>
                  onFiltersChange({ ...filters, hasReferences: checked })
                }
              />
              <Label>עם המלצות בלבד</Label>
            </div>
          </div>
        </FilterSection>
      </div>
    </Card>
  );
};

export default FilterPanel;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\SavedFilters.tsx:
==================================================
// /components/matchmaker/Filters/SavedFilters.tsx
"use client";
import React from "react";
import { Save, Star, MoreVertical, Edit, Trash, Share } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import type { CandidatesFilter } from "../types/candidates";

interface SavedFilter {
  id: string;
  name: string;
  filter: CandidatesFilter;
  isDefault?: boolean;
  createdAt: Date;
}

interface SavedFiltersProps {
  filters: SavedFilter[];
  activeFilterId?: string;
  onSelect: (filter: SavedFilter) => void;
  onDelete: (filterId: string) => void;
  onEdit: (filter: SavedFilter) => void;
  onSetDefault: (filterId: string) => void;
  className?: string;
}

const SavedFilters: React.FC<SavedFiltersProps> = ({
  filters,
  activeFilterId,
  onSelect,
  onDelete,
  onEdit,
  onSetDefault,
  className,
}) => {
  return (
    <div className={`space-y-2 ${className}`}>
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-gray-700">פילטרים שמורים</h3>
        <Badge variant="secondary" className="text-xs">
          {filters.length}
        </Badge>
      </div>

      <ScrollArea className="h-[300px]">
        <div className="space-y-2">
          {filters.map((filter) => (
            <div
              key={filter.id}
              className={`
                flex items-center justify-between p-2 rounded-lg
                ${
                  activeFilterId === filter.id
                    ? "bg-blue-50 border border-blue-200"
                    : "bg-white hover:bg-gray-50"
                }
                transition-colors cursor-pointer
              `}
              onClick={() => onSelect(filter)}
            >
              <div className="flex items-center gap-2">
                {filter.isDefault && (
                  <Star className="w-4 h-4 text-yellow-400" />
                )}
                <div>
                  <p className="font-medium text-sm">{filter.name}</p>
                  <p className="text-xs text-gray-500">
                    {formatFilterSummary(filter.filter)}
                  </p>
                </div>
              </div>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8 w-8 p-0"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <MoreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onEdit(filter)}>
                    <Edit className="ml-2 h-4 w-4" />
                    עריכה
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => onSetDefault(filter.id)}
                    disabled={filter.isDefault}
                  >
                    <Star className="ml-2 h-4 w-4" />
                    הגדר כברירת מחדל
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onDelete(filter.id)}>
                    <Trash className="ml-2 h-4 w-4" />
                    מחיקה
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
};

// פונקציית עזר להצגת סיכום הפילטר
const formatFilterSummary = (filter: CandidatesFilter): string => {
  const parts: string[] = [];

  if (filter.ageRange) {
    parts.push(`גיל: ${filter.ageRange.min}-${filter.ageRange.max}`);
  }

  if (filter.cities?.length) {
    parts.push(`ערים: ${filter.cities.length}`);
  }

  if (filter.religiousLevel) {
    parts.push(`רמה דתית: ${filter.religiousLevel}`);
  }

  if (filter.occupations?.length) {
    parts.push(`תחומי עיסוק: ${filter.occupations.length}`);
  }

  return parts.join(" | ") || "פילטר ריק";
};

export default SavedFilters;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\SearchBar.tsx:
==================================================
// /components/matchmaker/Filters/SearchBar.tsx
"use client";
import React from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import type { Candidate } from "../types/candidates";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSelect?: (candidate: Candidate) => void;
  recentSearches?: string[];
  suggestions?: Candidate[];
  loading?: boolean;
  className?: string;
}

const SearchBar: React.FC<SearchBarProps> = ({
  value,
  onChange,
  onSelect,
  recentSearches = [],
  suggestions = [],
  loading = false,
  className,
}) => {
  const [open, setOpen] = React.useState(false);

  return (
    <div className={`relative ${className}`}>
      <div className="relative">
        <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
        <Input
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onClick={() => setOpen(true)}
          placeholder="חיפוש מועמדים..."
          className="pl-10 text-right pr-10"
        />
      </div>

      <CommandDialog open={open} onOpenChange={setOpen}>
        <Command className="rounded-lg border shadow-md">
          <CommandInput placeholder="הקלד לחיפוש..." />
          <CommandList>
            <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
            {recentSearches.length > 0 && (
              <CommandGroup heading="חיפושים אחרונים">
                {recentSearches.map((search, index) => (
                  <CommandItem
                    key={index}
                    onSelect={() => {
                      onChange(search);
                      setOpen(false);
                    }}
                    className="text-right"
                  >
                    {search}
                  </CommandItem>
                ))}
              </CommandGroup>
            )}
            {suggestions.length > 0 && (
              <CommandGroup heading="הצעות">
                {suggestions.map((candidate) => (
                  <CommandItem
                    key={candidate.id}
                    onSelect={() => {
                      onSelect?.(candidate);
                      setOpen(false);
                    }}
                    className="flex items-center gap-2 text-right"
                  >
                    <div className="flex-1">
                      <div>{`${candidate.firstName} ${candidate.lastName}`}</div>
                      <div className="text-sm text-gray-500">
                        {candidate.profile.city &&
                          `${candidate.profile.city}, `}
                        {candidate.profile.occupation}
                      </div>
                    </div>
                  </CommandItem>
                ))}
              </CommandGroup>
            )}
          </CommandList>
        </Command>
      </CommandDialog>
    </div>
  );
};

export default SearchBar;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\filterUtils:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useCandidates.ts:
==================================================
import { useState, useEffect, useMemo, useCallback } from 'react';
import Papa from 'papaparse';
import _ from 'lodash';
import type { Candidate, CandidatesFilter } from '../types/candidates';
import type { CandidateProfile } from '../types/candidates';
import { Dispatch, SetStateAction } from 'react';

export interface UseCandidatesReturn {
  loading: boolean;
  error: string | null;
  candidates: Candidate[];
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  filters: CandidatesFilter;
  setFilters: Dispatch<SetStateAction<CandidatesFilter>>;
  refresh: () => Promise<void>;
  totalCount: number;
  maleCount: number;
  femaleCount: number;
  exportCandidates: (candidates: Candidate[], filters: CandidatesFilter) => Promise<void>;
  updateCandidate: (id: string, updates: Partial<CandidateProfile>) => Promise<void>;
}

export const useCandidates = (): UseCandidatesReturn => {
  // Base states
  const [candidates, setCandidates] = useState<Candidate[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<CandidatesFilter>({});

  // Helper function to calculate age
  const calculateAge = useCallback((birthDate: Date): number => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    return age;
  }, []);

  // Fetch candidates data
  const fetchCandidates = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/matchmaker/clients');
      if (!response.ok) {
        throw new Error(await response.text());
      }
      
      const data = await response.json();
     
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load candidates');
      }
  
      setCandidates(data.clients);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
      console.error('Error fetching candidates:', err);
    } finally {
      setLoading(false);
    }
  };

  // Filter candidates based on current filters
  const filteredCandidates = useMemo(() => {
    return candidates.filter(candidate => {
      // Gender filter
      if (filters.gender && candidate.profile.gender !== filters.gender) {
        return false;
      }

      // Age filter
      if (filters.ageRange) {
        const age = calculateAge(candidate.profile.birthDate )
        if (age < filters.ageRange.min || age > filters.ageRange.max) {
          return false;
        }
      }

      // Height filter
      if (filters.heightRange && candidate.profile.height) {
        if (
          candidate.profile.height < filters.heightRange.min || 
          candidate.profile.height > filters.heightRange.max
        ) {
          return false;
        }
      }

      // Religious level filter
      if (filters.religiousLevel && candidate.profile.religiousLevel !== filters.religiousLevel) {
        return false;
      }

      // Cities filter
      if (filters.cities?.length && candidate.profile.city) {
        if (!filters.cities.includes(candidate.profile.city)) {
          return false;
        }
      }

      // Occupations filter
      if (filters.occupations?.length && candidate.profile.occupation) {
        if (!filters.occupations.includes(candidate.profile.occupation)) {
          return false;
        }
      }

      // Education level filter
      if (filters.educationLevel && candidate.profile.education !== filters.educationLevel) {
        return false;
      }

      // Marital status filter
      if (filters.maritalStatus && candidate.profile.maritalStatus !== filters.maritalStatus) {
        return false;
      }

      // Availability status filter
      if (filters.availabilityStatus && 
          candidate.profile.availabilityStatus !== filters.availabilityStatus) {
        return false;
      }

      // Verification filter
      if (filters.isVerified !== undefined && candidate.isVerified !== filters.isVerified) {
        return false;
      }

      // References filter
      if (filters.hasReferences && 
          !candidate.profile.referenceName1 && 
          !candidate.profile.referenceName2) {
        return false;
      }

      // Last active days filter
      if (filters.lastActiveDays && candidate.profile.lastActive) {
        const lastActive = new Date(candidate.profile.lastActive);
        const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
        if (daysDiff > filters.lastActiveDays) {
          return false;
        }
      }

      // Search query filter
      if (filters.searchQuery) {
        const searchTerm = filters.searchQuery.toLowerCase();
        const searchableText = `
          ${candidate.firstName} 
          ${candidate.lastName} 
          ${candidate.profile.occupation || ''} 
          ${candidate.profile.city || ''}
          ${candidate.profile.religiousLevel || ''}
          ${candidate.profile.about || ''}
        `.toLowerCase();
        
        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      return true;
    });
  }, [candidates, filters, calculateAge]);

  // Split candidates by gender
  const maleCandidates = useMemo(() => 
    filteredCandidates.filter(c => c.profile.gender === 'MALE'),
    [filteredCandidates]
  );

  const femaleCandidates = useMemo(() => 
    filteredCandidates.filter(c => c.profile.gender === 'FEMALE'),
    [filteredCandidates]
  );

  // Export candidates to CSV
  const exportCandidates = async (
    candidates: Candidate[], 
    filters: CandidatesFilter
  ): Promise<void> => {
    try {
      // Prepare data for export
      const exportData = candidates.map(candidate => ({
        'שם פרטי': candidate.firstName,
        'שם משפחה': candidate.lastName,
        'גיל': calculateAge(candidate.profile.birthDate),
        'מגדר': candidate.profile.gender === 'MALE' ? 'זכר' : 'נקבה',
        'עיר': candidate.profile.city || '',
        'גובה': candidate.profile.height || '',
        'רמת דתיות': candidate.profile.religiousLevel || '',
        'תעסוקה': candidate.profile.occupation || '',
        'השכלה': candidate.profile.education || '',
        'מצב משפחתי': candidate.profile.maritalStatus || '',
        'סטטוס זמינות': candidate.profile.availabilityStatus || '',
        'מאומת': candidate.isVerified ? 'כן' : 'לא',
        'פעילות אחרונה': candidate.profile.lastActive || ''
      }));

      // Convert to CSV
      const csv = Papa.unparse(exportData);
      
      // Create and download file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', `candidates_export_${new Date().toISOString()}.csv`);
      document.body.appendChild(link);
      
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Error exporting candidates:', error);
      throw new Error('Failed to export candidates');
    }
  };

  // Update candidate
  const updateCandidate = async (
    id: string, 
    updates: Partial<CandidateProfile>
  ): Promise<void> => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error('Failed to update candidate');
      }
      
      // Refresh candidates list after update
      await fetchCandidates();
    } catch (error) {
      console.error('Error updating candidate:', error);
      throw error;
    }
  };

  // Load candidates on mount
  useEffect(() => {
    fetchCandidates();
  }, []);

  // Return interface
  return {
    loading,
    error,
    candidates: filteredCandidates,
    maleCandidates,
    femaleCandidates,
    filters,
    setFilters,
    refresh: fetchCandidates,
    totalCount: candidates.length,
    maleCount: maleCandidates.length,
    femaleCount: femaleCandidates.length,
    exportCandidates,
    updateCandidate
  };
};

export default useCandidates;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useFilterLogic.ts:
==================================================
// src/app/components/matchmaker/new/hooks/useFilterLogic.ts

import { useState, useEffect, useMemo, useCallback } from 'react';
import type {
  FilterState,
  SavedFilter,
  FilterOption,
  FilterSettings,
  FilterChangeHandler,
  FilterResults,
  FilterCategory
} from '../types/filters';
import { DEFAULT_FILTER_STATE } from '../types/filters'; 

interface UseFilterLogicProps {
  onFilterChange?: FilterChangeHandler;
  defaultFilters?: Partial<FilterState>;
  localStorageKey?: string;
}

export const useFilterLogic = ({
  onFilterChange,
  defaultFilters = {},
  localStorageKey = 'candidateFilters'
}: UseFilterLogicProps = {}) => {
  // States
  const [filters, setFilters] = useState<FilterState>({
    ...DEFAULT_FILTER_STATE,
    ...defaultFilters
  });
  
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);

  // Load saved filters and history from localStorage
  useEffect(() => {
    try {
      // Load saved filters
      const savedPrefs = localStorage.getItem(localStorageKey);
      if (savedPrefs) {
        const parsed = JSON.parse(savedPrefs);
        setSavedFilters(parsed.map((filter: any) => ({
          ...filter,
          createdAt: new Date(filter.createdAt)
        })));
      }

      // Load recent searches
      const searches = localStorage.getItem(`${localStorageKey}_recent_searches`);
      if (searches) {
        setRecentSearches(JSON.parse(searches));
      }
    } catch (error) {
      console.error('Error loading saved filters:', error);
    }
  }, [localStorageKey]);

  // Update filters
  const updateFilters = useCallback((newFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updated = { ...prev, ...newFilters };
      
      // If there's a new search query, update search history
      if (newFilters.searchQuery && newFilters.searchQuery !== prev.searchQuery) {
        setRecentSearches(prevSearches => {
          const updatedSearches = [
            newFilters.searchQuery!,
            ...prevSearches.filter(s => s !== newFilters.searchQuery)
          ].slice(0, 10);
          
          localStorage.setItem(
            `${localStorageKey}_recent_searches`,
            JSON.stringify(updatedSearches)
          );
          
          return updatedSearches;
        });
      }

      // Call onChange callback if exists
      onFilterChange?.(updated);
      
      return updated;
    });
  }, [onFilterChange, localStorageKey]);

  // Reset filters
  const resetFilters = useCallback(() => {
    const defaultState: FilterState = {
      ...DEFAULT_FILTER_STATE,
      ...defaultFilters
    };

    setFilters(defaultState);
    onFilterChange?.(defaultState);
  }, [defaultFilters, onFilterChange]);

  // Save new filter
  const saveFilter = useCallback(async (name: string, filters: FilterState) => {
    const newFilter: SavedFilter = {
      id: Date.now().toString(),
      name,
      filters,
      isDefault: false,
      createdAt: new Date()
    };

    setSavedFilters(prev => {
      const updated = [...prev, newFilter];
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });

    return newFilter;
  }, [localStorageKey]);

  // Update existing filter
  const updateSavedFilter = useCallback((id: string, updates: Partial<SavedFilter>) => {
    setSavedFilters(prev => {
      const updated = prev.map(filter => 
        filter.id === id ? { ...filter, ...updates } : filter
      );
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Delete filter
  const deleteFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.filter(f => f.id !== id);
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Set default filter
  const setDefaultFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.map(f => ({
        ...f,
        isDefault: f.id === id
      }));
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Load saved filter
  const loadSavedFilter = useCallback((id: string) => {
    const filter = savedFilters.find(f => f.id === id);
    if (filter) {
      setFilters({ ...filter.filters, savedFilterId: id });
      onFilterChange?.({ ...filter.filters, savedFilterId: id });
    }
  }, [savedFilters, onFilterChange]);

  // Check for active filters
  const hasActiveFilters = useMemo(() => {
    return (
      filters.searchQuery ||
      filters.gender !== undefined ||
      (filters.cities?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      (filters.occupations?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      filters.religiousLevel ||
      filters.educationLevel ||
      filters.maritalStatus ||
      filters.availabilityStatus ||
      filters.userStatus ||
      filters.isVerified ||
      filters.hasReferences ||
      filters.lastActiveDays ||
      filters.isProfileComplete ||
      (filters.ageRange && (
        filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min ||
        filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
      )) ||
      (filters.heightRange && (
        filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min ||
        filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
      ))
    );
  }, [filters]);

  // Get active filters in formatted array
  const activeFilters = useMemo((): FilterOption[] => {
    const active: FilterOption[] = [];

    if (filters.searchQuery) {
      active.push({
        key: 'searchQuery',
        value: filters.searchQuery,
        label: `חיפוש: ${filters.searchQuery}`,
        category: 'חיפוש'
      });
    }

    if (filters.gender) {
      active.push({
        key: 'gender',
        value: filters.gender,
        label: `מגדר: ${filters.gender === 'MALE' ? 'זכר' : 'נקבה'}`,
        category: 'מידע בסיסי'
      });
    }

    if (filters.ageRange && (
      filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min ||
      filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
    )) {
      active.push({
        key: 'ageRange',
        value: filters.ageRange,
        label: `גיל: ${filters.ageRange.min}-${filters.ageRange.max}`,
        category: 'מידע בסיסי'
      });
    }

    // גיל
    if (filters.ageRange && (filters.ageRange.min !== 18 || filters.ageRange.max !== 99)) {
      active.push({
        key: 'ageRange',
        value: filters.ageRange,
        label: `גיל: ${filters.ageRange.min}-${filters.ageRange.max}`,
        category: 'מידע בסיסי'
      });
    }

    // גובה
    if (filters.heightRange && (filters.heightRange.min !== 140 || filters.heightRange.max !== 210)) {
      active.push({
        key: 'heightRange',
        value: filters.heightRange,
        label: `גובה: ${filters.heightRange.min}-${filters.heightRange.max} ס"מ`,
        category: 'מידע בסיסי'
      });
    }

    // ערים
    if (filters.cities?.length) {
      active.push({
        key: 'cities',
        value: filters.cities,
        label: `ערים: ${filters.cities.join(', ')}`,
        category: 'מיקום'
      });
    }

    // תחומי עיסוק
    if (filters.occupations?.length) {
      active.push({
        key: 'occupations',
        value: filters.occupations,
        label: `תחומי עיסוק: ${filters.occupations.join(', ')}`,
        category: 'תעסוקה'
      });
    }

    // רמת דתיות
    if (filters.religiousLevel) {
      active.push({
        key: 'religiousLevel',
        value: filters.religiousLevel,
        label: `רמת דתיות: ${filters.religiousLevel}`,
        category: 'דת'
      });
    }

    // השכלה
    if (filters.educationLevel) {
      active.push({
        key: 'educationLevel',
        value: filters.educationLevel,
        label: `השכלה: ${filters.educationLevel}`,
        category: 'השכלה'
      });
    }

    // מצב משפחתי
    if (filters.maritalStatus) {
      active.push({
        key: 'maritalStatus',
        value: filters.maritalStatus,
        label: `מצב משפחתי: ${filters.maritalStatus}`,
        category: 'מידע אישי'
      });
    }

    // סטטוס זמינות
    if (filters.availabilityStatus) {
      active.push({
        key: 'availabilityStatus',
        value: filters.availabilityStatus,
        label: `סטטוס זמינות: ${filters.availabilityStatus}`,
        category: 'זמינות'
      });
    }

    // סטטוס משתמש
    if (filters.userStatus) {
      active.push({
        key: 'userStatus',
        value: filters.userStatus,
        label: `סטטוס משתמש: ${filters.userStatus}`,
        category: 'סטטוס'
      });
    }

    // משתמש מאומת
    if (filters.isVerified !== undefined) {
      active.push({
        key: 'isVerified',
        value: filters.isVerified,
        label: `משתמש מאומת: ${filters.isVerified ? 'כן' : 'לא'}`,
        category: 'אימות'
      });
    }

    // יש המלצות
    if (filters.hasReferences !== undefined) {
      active.push({
        key: 'hasReferences',
        value: filters.hasReferences,
        label: `יש המלצות: ${filters.hasReferences ? 'כן' : 'לא'}`,
        category: 'המלצות'
      });
    }

    // פעילות אחרונה
    if (filters.lastActiveDays !== undefined) {
      active.push({
        key: 'lastActiveDays',
        value: filters.lastActiveDays,
        label: `פעיל ב-${filters.lastActiveDays} הימים האחרונים`,
        category: 'פעילות'
      });
    }

    // פרופיל מלא
    if (filters.isProfileComplete !== undefined) {
      active.push({
        key: 'isProfileComplete',
        value: filters.isProfileComplete,
        label: `פרופיל מלא: ${filters.isProfileComplete ? 'כן' : 'לא'}`,
        category: 'שלמות פרופיל'
      });
    }

    return active;
  }, [filters]);
// Remove single filter
const removeFilter = useCallback((key: keyof FilterState, value?: any) => {
    setFilters(prev => {
      const updated = { ...prev };
  
      if (Array.isArray(updated[key]) && value !== undefined) {
        // הגדרת טיפוס ספציפי למערכים
        if (key === 'cities' || key === 'occupations') {
          updated[key] = (updated[key] as string[]).filter(v => v !== value);
        }
      } else {
        // Otherwise, remove the field entirely
        delete updated[key];
      }
  
      onFilterChange?.(updated);
      return updated;
    });
  }, [onFilterChange]);

  return {
    // Current state
    filters,
    savedFilters,
    recentSearches,
    activeFilters,
    hasActiveFilters,

    // Actions
    setFilters: updateFilters,
    removeFilter,
    resetFilters,

    // Saved filters management
    saveFilter,
    updateSavedFilter,
    deleteFilter,
    setDefaultFilter,
    loadSavedFilter,
  };
};

export default useFilterLogic;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useMatchmaking.ts:
==================================================
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import type { Candidate } from '../types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS, MATCH_CATEGORIES } from '../constants/matchingCriteria';

// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: Candidate[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: Candidate;
  candidateB: Candidate;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: Candidate;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchFound,
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Age normalization helper function
  const normalizeAge = (birthDate: string): number => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    return age;
  };

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile.gender === candidateB.profile.gender ||
          candidateA.profile.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA, candidateB);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useStatistics.ts:
==================================================
// /hooks/useStatistics.ts

import { useMemo } from 'react';
import type { Candidate } from '../types/candidates';
import {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
} from '../utils/statisticsCalculator';

export interface Statistics {
  gender: {
    maleCount: number;
    femaleCount: number;
    ratio: number;
    total: number;
    percentages: {
      male: number;
      female: number;
    };
  };
  age: {
    ageGroups: Record<string, number>;
    averageAge: number;
    medianAge: number;
  };
  location: {
    cities: Record<string, number>;
    topCities: Array<{ city: string; count: number }>;
  };
  religious: {
    levels: Record<string, number>;
    percentages: Record<string, number>;
  };
  activity: {
    activeLastWeek: number;
    activeLastMonth: number;
    averageLoginFrequency: number;
    completedProfiles: number;
  };
  availability: {
    counts: Record<string, number>;
    percentages: Record<string, number>;
  };
  completion: {
    counts: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
    percentages: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
  };
}

export const useStatistics = (candidates: Candidate[]) => {
  const stats = useMemo<Statistics>(() => {
    return {
      gender: calculateGenderStats(candidates),
      age: calculateAgeDistribution(candidates),
      location: calculateLocationDistribution(candidates),
      religious: calculateReligiousDistribution(candidates),
      activity: calculateActivityStats(candidates),
      availability: calculateAvailabilityStats(candidates),
      completion: calculateCompletionStats(candidates)
    };
  }, [candidates]);

  // פונקציות עזר לשליפת נתונים ספציפיים
  const getGenderRatio = () => {
    return {
      ratio: stats.gender.ratio,
      formattedRatio: `${stats.gender.maleCount}:${stats.gender.femaleCount}`
    };
  };

  const getTopCities = (limit: number = 5) => {
    return stats.location.topCities.slice(0, limit);
  };

  const getActiveUsersPercent = () => {
    return Math.round((stats.activity.activeLastWeek / stats.gender.total) * 100);
  };

  const getCompletionRate = () => {
    return stats.completion.percentages.fullyCompleted;
  };

  const getAgeGroupDistribution = () => {
    return Object.entries(stats.age.ageGroups)
      .map(([range, count]) => ({
        range,
        count,
        percentage: Math.round((count / stats.gender.total) * 100)
      }))
      .sort((a, b) => {
        const [aMin] = a.range.split('-').map(Number);
        const [bMin] = b.range.split('-').map(Number);
        return aMin - bMin;
      });
  };

  const getReligiousDistribution = () => {
    return Object.entries(stats.religious.levels)
      .map(([level, count]) => ({
        level,
        count,
        percentage: stats.religious.percentages[level]
      }))
      .sort((a, b) => b.count - a.count);
  };

  const getActivityTrend = () => {
    return {
      weekly: stats.activity.activeLastWeek,
      monthly: stats.activity.activeLastMonth,
      average: stats.activity.averageLoginFrequency
    };
  };

  const getProfileCompletionStats = () => {
    return {
      completed: stats.completion.counts.fullyCompleted,
      partial: stats.gender.total - stats.completion.counts.fullyCompleted,
      percentage: stats.completion.percentages.fullyCompleted
    };
  };

  return {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getCompletionRate,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats
  };
};

export default useStatistics;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\CandidateSelector.tsx:
==================================================
import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../types/candidates";

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={(value) => {
                  setInputValue(value);
                  setActiveIndex(-1);
                }}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => (
                    <div
                      key={candidate.id}
                      onClick={() => handleSelect(candidate)}
                      className={`flex items-center gap-2 text-right p-2 hover:bg-accent/50 cursor-pointer ${
                        index === activeIndex ? "bg-accent" : ""
                      }`}
                      role="option"
                      id={`candidate-${candidate.id}`}
                      aria-selected={index === activeIndex}
                      onMouseEnter={() => setActiveIndex(index)}
                    >
                      <div className="flex-1">
                        <div className="font-medium">
                          {formatCandidateDisplay(candidate)}
                        </div>
                        <div className="text-sm text-gray-500">
                          {candidate.profile.religiousLevel} |
                          {candidate.profile.occupation &&
                            ` ${candidate.profile.occupation} |`}
                          {candidate.profile.education &&
                            ` ${candidate.profile.education}`}
                        </div>
                      </div>
                    </div>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => {
                /* Add view profile handler */
              }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\index.tsx:
==================================================
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/toast/use-toast";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { CheckCircle, UserPlus } from "lucide-react";
import { Steps } from "@/components/ui/steps";
import type { Candidate } from "../types/candidates";
import { newSuggestionSchema } from "./schema";
import type { NewSuggestionFormData } from "./schema";
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const STEPS = [
  {
    title: "בחירת מועמדים",
    description: "בחירת שני הצדדים להצעה",
    icon: UserPlus,
  },
  {
    title: "פרטי ההצעה",
    description: "הגדרת פרטי ההצעה ותזמונים",
    icon: CheckCircle,
  },
];

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({
  isOpen,
  onClose,
  candidates,
  selectedCandidate,
  onSubmit,
}) => {
  const [step, setStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(
    selectedCandidate || null
  );
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);

  const { toast } = useToast();

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      firstPartyId: selectedCandidate?.id || "",
      secondPartyId: "",
    },
  });

  // Debug logging for form state changes
  useEffect(() => {
    const subscription = form.watch((value, { name, type }) => {
      console.log("Form value changed:", {
        name,
        value,
        type,
        allValues: form.getValues(),
        formState: form.formState,
      });
    });

    return () => subscription.unsubscribe();
  }, [form]);

  // Handle candidate selection
  const handleCandidateSelect =
    (type: "first" | "second") => (candidate: Candidate | null) => {
      console.log(`${type} party selection:`, { candidate });

      if (type === "first") {
        setFirstParty(candidate);
        if (candidate) {
          form.setValue("firstPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("firstPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      } else {
        setSecondParty(candidate);
        if (candidate) {
          form.setValue("secondPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("secondPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      }

      // Log form state after update
      console.log("Form state after selection:", {
        values: form.getValues(),
        errors: form.formState.errors,
        isDirty: form.formState.isDirty,
        isValid: form.formState.isValid,
      });
    };

  const handleSubmit = async (data: NewSuggestionFormData) => {
    console.log("Submit attempt:", {
      formData: data,
      formState: form.formState,
      firstParty,
      secondParty,
    });

    if (!firstParty || !secondParty) {
      console.log("Missing parties:", { firstParty, secondParty });
      return;
    }

    try {
      setIsSubmitting(true);
      console.log("=== Before API call ===");
      await onSubmit(data);
      console.log("=== After successful API call ===");
      toast({
        title: "ההצעה נוצרה בהצלחה",
        description: "ההצעה נשמרה במערכת והועברה לטיפול",
      });
      onClose();
    } catch (error) {
      console.log("=== API call failed ===", error);
      console.error("Submission error:", error);
      toast({
        title: "שגיאה",
        description: "אירעה שגיאה בעת יצירת ההצעה",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle form validation before moving to next step
  const handleNextStep = () => {
    form.trigger(["firstPartyId", "secondPartyId"]).then((isValid) => {
      if (isValid) {
        setStep(2);
      } else {
        console.log("Validation failed:", form.formState.errors);
      }
    });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto p-0">
        <DialogHeader className="px-8 pt-6 pb-2">
          <DialogTitle className="text-2xl">יצירת הצעת שידוך חדשה</DialogTitle>
          <DialogDescription>
            יצירת הצעת שידוך בין שני מועמדים והגדרת פרטי ההצעה
          </DialogDescription>
        </DialogHeader>

        {/* Steps Indicator */}
        <div className="px-8 py-4">
          <Steps steps={STEPS} currentStep={step} />
        </div>

        <Separator />

        <FormProvider {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="p-8 pt-6">
            {/* Step 1: Candidate Selection */}
            <div className={step !== 1 ? "hidden" : "space-y-8"}>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <CandidateSelector
                  label="צד א׳"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={candidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />

                <CandidateSelector
                  label="צד ב׳"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={candidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

              {firstParty && secondParty && (
                <div className="rounded-lg border bg-card">
                  <div className="px-6 py-4 border-b">
                    <h3 className="text-lg font-semibold">
                      התאמה בין המועמדים
                    </h3>
                  </div>
                  <div className="p-6">
                    <MatchPreview
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  </div>
                </div>
              )}

              <div className="flex justify-end mt-8">
                <Button
                  type="button"
                  size="lg"
                  onClick={handleNextStep}
                  disabled={!firstParty || !secondParty}
                >
                  המשך להגדרת פרטי ההצעה
                </Button>
              </div>
            </div>

            {/* Step 2: Suggestion Details */}
            <div className={step !== 2 ? "hidden" : "space-y-8"}>
              <div className="rounded-lg border bg-card">
                <div className="px-6 py-4 border-b">
                  <h3 className="text-lg font-semibold">פרטי ההצעה</h3>
                </div>
                <div className="p-6">
                  {firstParty && secondParty ? (
                    <SuggestionDetails
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  ) : (
                    <div className="text-center py-4 text-gray-500">
                      יש לבחור את שני הצדדים בשלב הראשון
                    </div>
                  )}
                </div>
              </div>

              <div className="flex justify-between mt-8">
                <Button
                  type="button"
                  variant="outline"
                  size="lg"
                  onClick={() => setStep(1)}
                >
                  חזרה לבחירת מועמדים
                </Button>

                <Button
                  type="submit"
                  size="lg"
                  disabled={isSubmitting || !form.formState.isValid}
                >
                  {isSubmitting ? "שומר הצעה..." : "שמור הצעה"}
                </Button>
              </div>
            </div>
          </form>
        </FormProvider>
      </DialogContent>
    </Dialog>
  );
};

export default NewSuggestionForm;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\MatchPreview.tsx:
==================================================
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\schema.ts:
==================================================
import { z } from "zod";
import type { Priority, MatchSuggestionStatus } from '@prisma/client';
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\SuggestionDetails.tsx:
==================================================
import React from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { calculateAge } from "@/lib/utils";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../types/candidates";

interface SuggestionDetailsProps {
  className?: string;
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({
  className,
  firstParty,
  secondParty,
}) => {
  const {
    register,
    formState: { errors },
    setValue,
    getValues,
  } = useFormContext<NewSuggestionFormData>();

  // Format candidate display
  const formatCandidateInfo = (candidate: Candidate): string => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  };

  // Register all form fields
  React.useEffect(() => {
    // Set default values if not already set
    const currentValues = getValues();
    if (!currentValues.priority) {
      setValue("priority", Priority.MEDIUM);
    }
  }, [setValue, getValues]);

  return (
    <div className="space-y-6">
      {/* Selected Candidates Summary */}
      <Card className="bg-slate-50">
        <CardHeader className="pb-3">
          <h3 className="text-lg font-semibold">הצדדים המוצעים</h3>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד א׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(firstParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {firstParty.profile.religiousLevel} |
                {firstParty.profile.occupation &&
                  ` ${firstParty.profile.occupation} |`}
                {firstParty.profile.education &&
                  ` ${firstParty.profile.education}`}
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד ב׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(secondParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {secondParty.profile.religiousLevel} |
                {secondParty.profile.occupation &&
                  ` ${secondParty.profile.occupation} |`}
                {secondParty.profile.education &&
                  ` ${secondParty.profile.education}`}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Priority Selection with Visual Indicators */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <Label className="text-lg">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => {
                setValue("priority", value, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              value={getValues("priority") || Priority.MEDIUM}
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י עדיפות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="destructive"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    דחופה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.HIGH}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="warning"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    גבוהה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.MEDIUM}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="default"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    רגילה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.LOW}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="secondary"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    נמוכה
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && (
              <p className="text-sm text-red-500">{errors.priority.message}</p>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Matching Details */}
      <Card>
        <CardContent className="pt-6 space-y-6">
          {/* Matching Reason */}
          <div className="space-y-3">
            <Label className="text-lg">סיבת ההתאמה</Label>
            <div className="text-sm text-gray-500 mb-2">
              פרט/י מדוע לדעתך יש התאמה בין המועמדים. מידע זה יוצג לשני הצדדים.
            </div>
            <Textarea
              {...register("matchingReason")}
              placeholder="לדוגמה: שני הצדדים מחפשים בן/בת זוג עם השקפת עולם דומה, שאיפות דומות..."
              className="min-h-[120px] resize-none"
            />
            {errors.matchingReason && (
              <p className="text-sm text-red-500">
                {errors.matchingReason.message}
              </p>
            )}
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-3">
              <Label className="text-lg">הערות לצד א׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{firstParty.firstName}
              </div>
              <Textarea
                {...register("firstPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.firstPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.firstPartyNotes.message}
                </p>
              )}
            </div>

            <div className="space-y-3">
              <Label className="text-lg">הערות לצד ב׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{secondParty.firstName}
              </div>
              <Textarea
                {...register("secondPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.secondPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.secondPartyNotes.message}
                </p>
              )}
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-3">
            <Label className="text-lg">הערות פנימיות</Label>
            <div className="text-sm text-gray-500 mb-2">
              הערות אלו יהיו גלויות רק לצוות השדכנים
            </div>
            <Textarea
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשדכנים..."
              className="min-h-[100px] resize-none"
            />
            {errors.internalNotes && (
              <p className="text-sm text-red-500">
                {errors.internalNotes.message}
              </p>
            )}
          </div>

          {/* Decision Days */}
          <div className="space-y-3">
            <Label className="text-lg">זמן להחלטה</Label>
            <div className="text-sm text-gray-500 mb-2">
              תוך כמה ימים נדרשת החלטה סופית משני הצדדים
            </div>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              defaultValue="14"
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י מספר ימים" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="2">2 ימים</SelectItem>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="5">5 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && (
              <p className="text-sm text-red-500">
                {errors.decisionDeadline.message}
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\services\email\EmailService.ts:
==================================================
import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import nodemailer from 'nodemailer';

type UserWithProfile = User & {
  profile: Profile | null;
};

type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type EmailTemplate = {
  subject: string;
  body: (data: SuggestionWithParties) => string;
};

// Helper function to format user details with proper RTL support
const formatUserDetails = (user: UserWithProfile) => {
  const details = [
    `שם: ${user.firstName} ${user.lastName}`,
    `אימייל: ${user.email}`,
  ];

  if (user.profile?.phone) {
    details.push(`טלפון: ${user.profile.phone}`);
  }

  return details.join('\n');
};

// Base HTML template with RTL support
const createHtmlTemplate = (content: string) => `
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            direction: rtl;
            text-align: right;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }
    </style>
</head>
<body>
    ${content}
</body>
</html>
`;

// Email templates for different statuses
const emailTemplates: Record<MatchSuggestionStatus, EmailTemplate | null> = {
  DRAFT: {
    subject: 'טיוטת הצעת שידוך נשמרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>טיוטת הצעת השידוך נשמרה בהצלחה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטי ההצעה</a></p>
      </div>
    `)
  },
  
  PENDING_FIRST_PARTY: {
    subject: 'הצעת שידוך חדשה עבורך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.firstParty.firstName},</h2>
        <p>${data.matchmaker.firstName} ${data.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p>
        <p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/review">לצפייה בהצעה</a></p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  FIRST_PARTY_APPROVED: {
    subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.firstParty.firstName} ${data.firstParty.lastName} אישר/ה את הצעת השידוך.</p>
        <p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  FIRST_PARTY_DECLINED: {
    subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.firstParty.firstName} ${data.firstParty.lastName} דחה/תה את הצעת השידוך.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  PENDING_SECOND_PARTY: {
    subject: 'הצעת שידוך חדשה עבורך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.secondParty.firstName},</h2>
        <p>${data.matchmaker.firstName} ${data.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p>
        <p>הצד הראשון כבר אישר את ההצעה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/review">לצפייה בפרטי ההצעה ומענה</a></p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  SECOND_PARTY_APPROVED: {
    subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.secondParty.firstName} ${data.secondParty.lastName} אישר/ה את הצעת השידוך.</p>
        <p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  SECOND_PARTY_DECLINED: {
    subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.secondParty.firstName} ${data.secondParty.lastName} דחה/תה את הצעת השידוך.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  AWAITING_MATCHMAKER_APPROVAL: {
    subject: 'נדרש אישור שדכן להצעה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>נדרש אישורך להצעת השידוך בין ${data.firstParty.firstName} ל${data.secondParty.firstName}.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים ואישור</a></p>
      </div>
    `)
  },

  CONTACT_DETAILS_SHARED: {
    subject: 'פרטי קשר להצעת השידוך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2>
        <p>פרטי הקשר של הצד הראשון:</p>
        <pre>${formatUserDetails(data.firstParty)}</pre>
        <p>פרטי הקשר של הצד השני:</p>
        <pre>${formatUserDetails(data.secondParty)}</pre>
        <p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p>
        <p>בהצלחה!</p>
      </div>
    `)
  },

  AWAITING_FIRST_DATE_FEEDBACK: {
    subject: 'בקשה למשוב על הפגישה הראשונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/feedback">לשליחת המשוב</a></p>
      </div>
    `)
  },

  THINKING_AFTER_DATE: {
    subject: 'בקשת זמן למחשבה לאחר הפגישה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  PROCEEDING_TO_SECOND_DATE: {
    subject: 'עדכון סטטוס - ממשיכים לפגישה שנייה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>שני הצדדים הסכימו להמשיך לפגישה שנייה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  ENDED_AFTER_FIRST_DATE: {
    subject: 'עדכון סטטוס - סיום לאחר פגישה ראשונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה הסתיימה לאחר הפגישה הראשונה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים והמשוב</a></p>
      </div>
    `)
  },

  MEETING_PENDING: {
    subject: 'הצעה לקביעת פגישה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>התקבלה הצעה לקביעת פגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/meetings">לצפייה בפרטי ההצעה</a></p>
      </div>
    `)
  },

  MEETING_SCHEDULED: {
    subject: 'פגישה נקבעה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>אנו שמחים לעדכן שנקבעה פגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/meetings">לצפייה בפרטי הפגישה</a></p>
      </div>
    `)
  },

  MATCH_APPROVED: {
    subject: 'ההצעה אושרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה אושרה על ידי שני הצדדים.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  MATCH_DECLINED: {
    subject: 'ההצעה נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה נדחתה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  DATING: {
    subject: 'עדכון סטטוס - בתהליך היכרות',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הזוג נמצא בתהליך היכרות.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  ENGAGED: {
    subject: 'מזל טוב! - אירוסין',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>מזל טוב!</h2>
        <p>אנו שמחים לשמוע על האירוסין ומאחלים המון הצלחה בהמשך הדרך.</p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  MARRIED: {
    subject: 'מזל טוב! - חתונה',
    body: (data) => createHtmlTemplate(`
      <div><h2>מזל טוב!</h2>
        <p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  EXPIRED: {
    subject: 'הצעת השידוך פגה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך פגה עקב חוסר מענה במועד.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  CLOSED: {
    subject: 'הצעת השידוך נסגרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך נסגרה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  CANCELLED: {
    subject: 'הצעת השידוך בוטלה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך בוטלה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },
};

export class EmailService {
  private static instance: EmailService;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure nodemailer for Gmail
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD,
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on startup
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig() {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw - allow the service to continue running even if email verification fails
    }
  }

  public static getInstance(): EmailService {
    if (!EmailService.instance) {
      EmailService.instance = new EmailService();
    }
    return EmailService.instance;
  }

  async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
    previousStatus: MatchSuggestionStatus
  ): Promise<void> {
    try {
      console.log('email222:------------');
      const template = emailTemplates[suggestion.status];
      if (!template) {
        console.log(`No email template for status: ${suggestion.status}`);
        return;
      }

      const recipients = this.getRecipientsByStatus(suggestion);
      
      console.log(`Preparing to send emails for suggestion ${suggestion.id}`, {
        status: suggestion.status,
        recipientCount: recipients.length
      });

      await Promise.all(
        recipients.map(async (recipient) => {
          await this.sendEmail({
            to: recipient,
            subject: template.subject,
            html: template.body(suggestion),
          });
        })
      );

      console.log(`Successfully sent ${recipients.length} emails for suggestion ${suggestion.id}`);
    } catch (error) {
      console.error('Error sending suggestion emails:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        suggestionId: suggestion.id,
        status: suggestion.status
      });
      throw new Error('Failed to send suggestion emails');
    }
  }

  private getRecipientsByStatus(suggestion: SuggestionWithParties): string[] {
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return [suggestion.firstParty.email];
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return [suggestion.secondParty.email];
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
          suggestion.matchmaker.email,
        ];
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
        ];

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
      case MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE:
      case MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE:
        return [suggestion.matchmaker.email];

      case MatchSuggestionStatus.MEETING_PENDING:
      case MatchSuggestionStatus.MEETING_SCHEDULED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
        ];

      case MatchSuggestionStatus.MATCH_APPROVED:
      case MatchSuggestionStatus.MATCH_DECLINED:
      case MatchSuggestionStatus.DATING:
        return [suggestion.matchmaker.email];

      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
          suggestion.matchmaker.email,
        ];
      
      case MatchSuggestionStatus.EXPIRED:
      case MatchSuggestionStatus.CLOSED:
      case MatchSuggestionStatus.CANCELLED:
        return [suggestion.matchmaker.email];
      
      default:
        return [];
    }
  }

  async sendEmail({
    to,
    subject,
    html,
  }: {
    to: string;
    subject: string;
    html: string;
  }): Promise<void> {
    try {
      console.log('Attempting to send email:', {
        to,
        subject,
        fromEmail: process.env.GMAIL_USER,
        fromName: process.env.EMAIL_FROM_NAME,
      });

      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME} <${process.env.GMAIL_USER}>`,
        to,
        subject,
        html,
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
      });
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        emailConfig: {
          to,
          subject,
          fromEmail: process.env.GMAIL_USER,
          fromName: process.env.EMAIL_FROM_NAME,
        }
      });
      throw error;
    }
  }
}

// Export singleton instance
export const emailService = EmailService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\services\suggestions\StatusTransitionService.ts:
==================================================
import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { EmailService } from "../email/EmailService";

type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Send email notifications using EmailService
    try {
      await EmailService.getInstance().handleSuggestionStatusChange(
        updatedSuggestion,
        previousStatus
      );
    } catch (error) {
      // Log error but don't fail the transition
      console.error('Error sending status transition emails:', error);
    }

    return updatedSuggestion;
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\services\suggestions\SuggestionService.ts:
==================================================
import { MatchSuggestionStatus, Priority, User, UserRole, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { emailService } from "../email/EmailService";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
  Suggestion
} from "@/types/suggestions";

type UserWithProfile = User & {
  profile: Profile | null;
};

export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    if (!matchmaker || matchmaker.role !== UserRole.MATCHMAKER) {
      throw new Error("Unauthorized - User is not a matchmaker");
    }

  /*   // 2. בדיקת זמינות המועמדים
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: data.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: data.secondPartyId },
        include: { profile: true },
      }),
    ]); 

    if (!firstParty || !secondParty) {
      throw new Error("One or both parties not found");
    }

    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      throw new Error("One or both parties are not available for matching");
    } 
 */
  /*   // 3. בדיקת הצעות קיימות
    const existingSuggestion = await this.checkExistingSuggestion(
      data.firstPartyId,
      data.secondPartyId
    );

    if (existingSuggestion) {
      throw new Error("Active suggestion already exists between these parties");
    }
 */
    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
console.log('Decision deadline type:', typeof data.decisionDeadline);
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות מייל
    console.log('email:------------');
    await emailService.handleSuggestionStatusChange(
      suggestion,
      MatchSuggestionStatus.DRAFT
    );

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: Suggestion,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;
    const isSecondParty = userId === suggestion.secondPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        if (!isSecondParty) throw new Error("Only second party can approve/decline at this stage");
        break;

      case MatchSuggestionStatus.CANCELLED:
        if (!isMatchmaker && !isFirstParty && !isSecondParty) {
          throw new Error("Only involved parties can cancel the suggestion");
        }
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<Suggestion | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
    });
  }
}

export const suggestionService = SuggestionService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\shared\LoadingStates.tsx:
==================================================
// /shared/LoadingStates.tsx
"use client";

import React from 'react';
import { Loader2, AlertCircle } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Skeleton } from '@/components/ui/skeleton';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';

interface LoadingContainerProps {
  children: React.ReactNode;
  className?: string;
}

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

interface LoadingCardProps {
  count?: number;
  layout?: 'grid' | 'list';
  className?: string;
}

interface LoadingTextProps {
  lines?: number;
  className?: string;
}

interface LoadingErrorProps {
  message: string;
  onRetry?: () => void;
  className?: string;
}

export const LoadingContainer: React.FC<LoadingContainerProps> = ({
  children,
  className
}) => {
  return (
    <div className={cn('relative min-h-[200px]', className)}>
      <div className="absolute inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
      </div>
      <div className="opacity-50 pointer-events-none">
        {children}
      </div>
    </div>
  );
};

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  className
}) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12'
  };

  return (
    <div className={cn('flex items-center justify-center', className)}>
      <Loader2 className={cn('animate-spin text-blue-600', sizeClasses[size])} />
    </div>
  );
};

export const LoadingCard: React.FC<LoadingCardProps> = ({
  count = 1,
  layout = 'grid',
  className
}) => {
  return (
    <div 
      className={cn(
        layout === 'grid' 
          ? 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4'
          : 'space-y-4',
        className
      )}
    >
      {Array.from({ length: count }).map((_, index) => (
        <div
          key={index}
          className={cn(
            'bg-white rounded-lg overflow-hidden shadow-sm',
            layout === 'list' ? 'flex gap-4' : ''
          )}
        >
          {/* תמונת פרופיל */}
          <Skeleton className={cn(
            'bg-gray-200',
            layout === 'list' ? 'w-32 h-32' : 'w-full h-48'
          )} />

          <div className="p-4 flex-1">
            {/* כותרת */}
            <div className="flex items-center justify-between mb-4">
              <Skeleton className="h-6 w-1/3" />
              <Skeleton className="h-6 w-16" />
            </div>

            {/* פרטים */}
            <div className="space-y-2">
              <Skeleton className="h-4 w-2/3" />
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-4 w-3/4" />
            </div>

            {/* כפתורים */}
            <div className="flex gap-2 mt-4">
              <Skeleton className="h-9 w-24" />
              <Skeleton className="h-9 w-24" />
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export const LoadingText: React.FC<LoadingTextProps> = ({
  lines = 3,
  className
}) => {
  return (
    <div className={cn('space-y-2', className)}>
      {Array.from({ length: lines }).map((_, index) => (
        <Skeleton
          key={index}
          className={cn(
            'h-4',
            index === lines - 1 ? 'w-3/4' : 'w-full'
          )}
        />
      ))}
    </div>
  );
};

export const LoadingError: React.FC<LoadingErrorProps> = ({
  message,
  onRetry,
  className
}) => {
  return (
    <Alert variant="destructive" className={cn('border-red-500', className)}>
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>שגיאה</AlertTitle>
      <AlertDescription className="flex items-center justify-between">
        <span>{message}</span>
        {onRetry && (
          <Button
            variant="outline"
            size="sm"
            onClick={onRetry}
            className="ml-4"
          >
            נסה שוב
          </Button>
        )}
      </AlertDescription>
    </Alert>
  );
};

export const LoadingStats: React.FC<{ className?: string }> = ({ className }) => {
  return (
    <div className={cn('grid grid-cols-2 md:grid-cols-4 gap-4', className)}>
      {Array.from({ length: 4 }).map((_, index) => (
        <div key={index} className="bg-white p-4 rounded-lg shadow-sm">
          <Skeleton className="h-4 w-16 mb-2" />
          <Skeleton className="h-8 w-24" />
        </div>
      ))}
    </div>
  );
};

export const LoadingFilters: React.FC<{ className?: string }> = ({ className }) => {
  return (
    <div className={cn('space-y-4', className)}>
      <Skeleton className="h-10 w-full" />
      <div className="flex flex-wrap gap-2">
        {Array.from({ length: 4 }).map((_, index) => (
          <Skeleton key={index} className="h-8 w-24" />
        ))}
      </div>
    </div>
  );
};

export default {
  LoadingContainer,
  LoadingSpinner,
  LoadingCard,
  LoadingText,
  LoadingError,
  LoadingStats,
  LoadingFilters
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\shared\Pagination.tsx:
==================================================
// /shared/Pagination.tsx
"use client";


import React from 'react';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { 
  ChevronRight, 
  ChevronLeft,
  ChevronsLeft,
  ChevronsRight
} from 'lucide-react';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  pageSize: number;
  totalItems: number;
  onPageChange: (page: number) => void;
  onPageSizeChange: (size: number) => void;
  className?: string;
}

const pageSizeOptions = [10, 20, 50, 100];

const Pagination: React.FC<PaginationProps> = ({
  currentPage,
  totalPages,
  pageSize,
  totalItems,
  onPageChange,
  onPageSizeChange,
  className
}) => {
  // Helper to generate page numbers array
  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisiblePages = 5;
    
    if (totalPages <= maxVisiblePages) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    // Always show first page
    pages.push(1);

    // Calculate start and end of visible pages
    let start = Math.max(currentPage - 1, 2);
    let end = Math.min(currentPage + 1, totalPages - 1);

    // Adjust for edge cases
    if (currentPage <= 3) {
      end = Math.min(maxVisiblePages - 1, totalPages - 1);
    } else if (currentPage >= totalPages - 2) {
      start = Math.max(totalPages - maxVisiblePages + 2, 2);
    }

    // Add ellipsis and numbers
    if (start > 2) pages.push('...');
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    if (end < totalPages - 1) pages.push('...');

    // Always show last page
    if (totalPages > 1) pages.push(totalPages);

    return pages;
  };

  const startItem = (currentPage - 1) * pageSize + 1;
  const endItem = Math.min(currentPage * pageSize, totalItems);

  return (
    <div className={`flex flex-col sm:flex-row items-center justify-between gap-4 ${className}`}>
      {/* Page Size Selector */}
      <div className="flex items-center gap-2 text-sm text-gray-600">
        <span>הצג</span>
        <Select
          value={pageSize.toString()}
          onValueChange={(value) => onPageSizeChange(Number(value))}
        >
          <SelectTrigger className="w-[70px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {pageSizeOptions.map(size => (
              <SelectItem key={size} value={size.toString()}>
                {size}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <span>שורות</span>
      </div>

      {/* Results Count */}
      <div className="text-sm text-gray-600">
        מציג {startItem}-{endItem} מתוך {totalItems} תוצאות
      </div>

      {/* Page Navigation */}
      <div className="flex items-center gap-1">
        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(1)}
          disabled={currentPage === 1}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((page, index) => (
          typeof page === 'number' ? (
            <Button
              key={index}
              variant={currentPage === page ? "default" : "outline"}
              size="sm"
              onClick={() => onPageChange(page)}
              className="hidden sm:inline-flex min-w-[32px]"
            >
              {page}
            </Button>
          ) : (
            <span key={index} className="px-2">
              {page}
            </span>
          )
        ))}

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(totalPages)}
          disabled={currentPage === totalPages}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};

export default Pagination;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\shared\StatusBadge.tsx:
==================================================
import React from "react";
import { Badge } from "@/components/ui/badge";
import {
  Circle,
  CheckCircle,
  XCircle,
  Clock,
  AlertTriangle,
} from "lucide-react";
import { MatchSuggestionStatus, VerificationStatus } from "@prisma/client";

type StatusType = "suggestion" | "verification" | "profile";
type StatusSize = "sm" | "md" | "lg";

interface StatusConfig {
  label: string;
  color: "destructive" | "outline" | "secondary" | "success" | "warning";
  icon:
    | typeof Circle
    | typeof CheckCircle
    | typeof XCircle
    | typeof Clock
    | typeof AlertTriangle;
}

interface StatusBadgeProps {
  type: StatusType;
  status: string;
  size?: StatusSize;
}

const suggestionStatuses: Record<MatchSuggestionStatus, StatusConfig> = {
  DRAFT: {
    label: "טיוטה",
    color: "secondary",
    icon: Circle,
  },
  PENDING_FIRST_PARTY: {
    label: "ממתין לצד ראשון",
    color: "warning",
    icon: Clock,
  },
  FIRST_PARTY_APPROVED: {
    label: 'אושר ע"י צד ראשון',
    color: "success",
    icon: CheckCircle,
  },
  FIRST_PARTY_DECLINED: {
    label: 'נדחה ע"י צד ראשון',
    color: "destructive",
    icon: XCircle,
  },
  PENDING_SECOND_PARTY: {
    label: "ממתין לצד שני",
    color: "warning",
    icon: Clock,
  },
  SECOND_PARTY_APPROVED: {
    label: 'אושר ע"י צד שני',
    color: "success",
    icon: CheckCircle,
  },
  SECOND_PARTY_DECLINED: {
    label: 'נדחה ע"י צד שני',
    color: "destructive",
    icon: XCircle,
  },
  AWAITING_MATCHMAKER_APPROVAL: {
    label: "ממתין לאישור שדכן",
    color: "warning",
    icon: Clock,
  },
  CONTACT_DETAILS_SHARED: {
    label: "פרטי קשר שותפו",
    color: "success",
    icon: CheckCircle,
  },
  AWAITING_FIRST_DATE_FEEDBACK: {
    label: "ממתין למשוב פגישה ראשונה",
    color: "warning",
    icon: Clock,
  },
  THINKING_AFTER_DATE: {
    label: "בשיקול לאחר פגישה",
    color: "warning",
    icon: Clock,
  },
  PROCEEDING_TO_SECOND_DATE: {
    label: "ממשיכים לפגישה שנייה",
    color: "success",
    icon: CheckCircle,
  },
  ENDED_AFTER_FIRST_DATE: {
    label: "הסתיים לאחר פגישה ראשונה",
    color: "destructive",
    icon: XCircle,
  },
  MEETING_PENDING: {
    label: "פגישה בתכנון",
    color: "warning",
    icon: Clock,
  },
  MEETING_SCHEDULED: {
    label: "פגישה נקבעה",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_APPROVED: {
    label: "השידוך אושר",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_DECLINED: {
    label: "השידוך נדחה",
    color: "destructive",
    icon: XCircle,
  },
  DATING: {
    label: "בתהליך היכרות",
    color: "secondary",
    icon: Circle,
  },
  ENGAGED: {
    label: "מאורסים",
    color: "success",
    icon: CheckCircle,
  },
  MARRIED: {
    label: "נישאו",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  CLOSED: {
    label: "סגור",
    color: "destructive",
    icon: XCircle,
  },
  CANCELLED: {
    label: "בוטל",
    color: "destructive",
    icon: XCircle,
  },
};

const verificationStatuses: Record<VerificationStatus, StatusConfig> = {
  PENDING: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  COMPLETED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  FAILED: {
    label: "נכשל",
    color: "destructive",
    icon: XCircle,
  },
};

const profileStatuses: Record<string, StatusConfig> = {
  INCOMPLETE: {
    label: "לא הושלם",
    color: "warning",
    icon: AlertTriangle,
  },
  PENDING_VERIFICATION: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  VERIFIED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  BLOCKED: {
    label: "חסום",
    color: "destructive",
    icon: XCircle,
  },
};

const defaultStatus: StatusConfig = {
  label: "לא ידוע",
  color: "secondary",
  icon: Circle,
};

const getStatusConfig = (type: StatusType, status: string): StatusConfig => {
  switch (type) {
    case "suggestion":
      return (
        suggestionStatuses[status as MatchSuggestionStatus] || defaultStatus
      );
    case "verification":
      return (
        verificationStatuses[status as VerificationStatus] || defaultStatus
      );
    case "profile":
      return profileStatuses[status] || defaultStatus;
    default:
      return defaultStatus;
  }
};

const StatusBadge: React.FC<StatusBadgeProps> = ({
  type,
  status,
  size = "md",
}) => {
  const config = getStatusConfig(type, status);
  const Icon = config.icon;

  const sizeClasses = {
    sm: "text-xs px-2 py-0.5",
    md: "text-sm px-2.5 py-1",
    lg: "text-base px-3 py-1.5",
  };

  return (
    <Badge
      variant={config.color}
      className={`flex items-center gap-1.5 ${sizeClasses[size]}`}
    >
      <Icon className={size === "sm" ? "w-3 h-3" : "w-4 h-4"} />
      <span>{config.label}</span>
    </Badge>
  );
};

export default StatusBadge;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\types\candidates.ts:
==================================================
// candidates.ts
import { Gender, AvailabilityStatus, UserStatus } from '@prisma/client';
import type { UserProfile, UserImage, QuestionnaireResponse, ContactPreference } from '@/types/next-auth';

// Base API Response Type
export interface APIResponse<T> {
  success: boolean;
  clients: T[];
  count: number;
  error?: string;
}

// Base Types
export type CandidateImage = UserImage;

export type CandidateProfile = UserProfile;

export interface Candidate {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  status: UserStatus;
  isVerified: boolean;
  images: CandidateImage[];
  profile: CandidateProfile;
}

export interface CandidatesFilter {
  gender?: Gender;
  ageRange?: {
    min: number;
    max: number;
  };
  heightRange?: {
    min: number;
    max: number;
  };
  cities?: string[];
  religiousLevel?: string;
  occupations?: string[];
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
  searchQuery?: string;
  savedFilterId?: string;
}

// ViewMode and Action Types - אלה נשארים כמו שהם
export type ViewMode = 'grid' | 'list';
export type CardSize = 'sm' | 'md' | 'lg';
export type CandidateAction = 'suggest' | 'invite' | 'contact' | 'favorite' | 'view';

// Profile Card Types
export interface ProfileCardData {
  profile: CandidateProfile;
  images: CandidateImage[];
  questionnaire?: QuestionnaireResponse;
}

/**
 * ממפה את אובייקט המועמד מהשרת למבנה הנדרש עבור ProfileCard
 */
export const mapCandidateToProfileCard = (candidate: Candidate): ProfileCardData => {
  return {
    profile: candidate.profile,
    images: candidate.images,
    questionnaire: undefined // יש להוסיף לוגיקה לטעינת השאלון בנפרד
  };
};

/**
 * מפריד מועמדים לפי מגדר
 */
export const separateCandidatesByGender = (candidates: Candidate[]) => {
  return {
    maleCandidates: candidates.filter(c => c.profile.gender === 'MALE'),
    femaleCandidates: candidates.filter(c => c.profile.gender === 'FEMALE')
  };
};

/**
 * בודק האם הפרופיל מלא
 */
export const isProfileComplete = (profile: CandidateProfile): boolean => {
  const requiredFields: Array<keyof CandidateProfile> = [
    'birthDate',
    'city',
    'religiousLevel',
    'about',
    'occupation',
    'education'
  ];

  return requiredFields.every(field => Boolean(profile[field]));
};

export default {
  mapCandidateToProfileCard,
  separateCandidatesByGender,
  isProfileComplete
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\types\filters.ts:
==================================================
// src/app/components/matchmaker/new/types/filters.ts

import { Gender, AvailabilityStatus, UserStatus } from '@prisma/client';
import type { CandidatesFilter } from './candidates';

// הגדרת טווח ערכים מספריים
export interface RangeFilter {
  min: number;
  max: number;
}

// הגדרת פילטר שמור
export interface SavedFilter {
  id: string;
  name: string;
  filters: FilterState;
  isDefault?: boolean;
  createdAt: Date;
}

// הגדרת מצב הפילטרים - ללא הרחבה של CandidatesFilter
export interface FilterState {
  searchQuery?: string;
  savedFilterId?: string;
  gender?: Gender | undefined;
  ageRange?: RangeFilter;
  heightRange?: RangeFilter;
  cities?: string[];
  occupations?: string[];
  religiousLevel?: string;
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus;
  userStatus?: UserStatus;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
}

// הגדרת אפשרות פילטר
export interface FilterOption {
  key: keyof (FilterState & { education: string });
  value: any;
  label: string;
  category?: string;
}

// הגדרת קטגוריית פילטר
export interface FilterCategory {
  id: string;
  label: string;
  filters: Array<keyof (FilterState & { education: string })>;
}

// הגדרת פרופ לקומפוננטת הפילטרים
export interface FilterProps {
  filters: FilterState;
  onFiltersChange: (filters: FilterState) => void;
  onReset?: () => void;
  className?: string;
}

// הגדרת אפשרויות הפילטר
export interface FilterOptions {
  ages: RangeFilter;
  heights: RangeFilter;
  cities: string[];
  religiousLevels: string[];
  educationLevels: string[];
  occupations: string[];
  maritalStatuses: string[];
  availabilityStatuses: AvailabilityStatus[];
}

// הגדרת מצב הממשק של הפילטרים
export interface FilterUIState {
  isOpen: boolean;
  activeCategory?: string;
  showSaveDialog: boolean;
  presetName: string;
}

// הגדרה של אירועי שינוי בפילטרים
export type FilterChangeHandler = (filters: FilterState) => void;

// הגדרת אירועי שמירת פילטר
export interface SaveFilterHandler {
  (name: string, filters: FilterState): Promise<SavedFilter>;
}

// הגדרת אירועי טעינת פילטר
export interface LoadFilterHandler {
  (id: string): void;
}

// הגדרת הגדרות הפילטרים
export interface FilterSettings {
  localStorageKey?: string;
  defaultFilters?: Partial<FilterState>;
  onFilterChange?: FilterChangeHandler;
}

// הגדרת תוצאות הפילטר
export interface FilterResults {
  totalResults: number;
  filteredResults: number;
  categories: Record<string, number>;
}

// קונסטנטות של הפילטרים
export const DEFAULT_FILTER_STATE: FilterState = {
  gender: undefined,
  ageRange: { min: 18, max: 99 },
  heightRange: { min: 140, max: 210 },
  cities: [],
  occupations: [],
  religiousLevel: undefined,
  educationLevel: undefined,
  maritalStatus: undefined,
  availabilityStatus: undefined,
  userStatus: undefined,
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined,
  isProfileComplete: undefined,
  searchQuery: '',
  savedFilterId: undefined
};

// קטגוריות פילטרים מוגדרות מראש
export const FILTER_CATEGORIES: FilterCategory[] = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'educationLevel', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availabilityStatus', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];

// טיפוסי מיון
export type SortDirection = 'asc' | 'desc';

export interface SortOption {
  field: keyof FilterState;
  direction: SortDirection;
  label: string;
}

// הגדרות קיבוץ
export interface GroupOption {
  field: keyof FilterState;
  label: string;
}

export default {
  DEFAULT_FILTER_STATE,
  FILTER_CATEGORIES
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\utils\matchingAlgorithm.ts:
==================================================
import { Gender, AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

interface HeightPreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

export default {
  calculateMatchScore,
  findBestMatches
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\utils\statisticsCalculator.ts:
==================================================
// /utils/statisticsCalculator.ts
import type { Candidate } from '../types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  let stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.referenceName1 || candidate.profile.referenceName2) stats.hasReferences++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      (candidate.profile.referenceName1 || candidate.profile.referenceName2) &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

export default {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\directory_analysis.txt:
==================================================
מבנה התיקייה:
suggestions
  container
    MatchmakerDashboard.tsx
    SuggestionActionBar.tsx
    SuggestionsStats.tsx
  details
    SuggestionDetailsDialog.tsx
    SuggestionDetailsView.tsx
  list
    ManagerSuggestionsList.tsx
    SuggestionCard.tsx

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx:
==================================================
import React, { useState, useCallback, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Filter, Plus, Download } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";
import { MatchSuggestionStatus } from "@prisma/client";
import NewSuggestionForm from "../../new/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import ManagerSuggestionsList from "../list/ManagerSuggestionsList";

export default function MatchmakerDashboard() {
  const [activeTab, setActiveTab] = useState("active");
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);

  useEffect(() => {
    const fetchSuggestions = async () => {
      try {
        const response = await fetch("/api/matchmaker/suggestions");
        if (!response.ok) throw new Error("Failed to fetch suggestions");

        const data = await response.json();
        setSuggestions(data);

        // Log suggestions data
        console.log("Fetched suggestions:", data);
        console.log("Total suggestions count:", data.length);

        // Log suggestions by status
        const activeCount = data.filter((s: Suggestion) => s.category === 'ACTIVE').length;
        const pendingCount = data.filter((s: Suggestion) => s.category === 'PENDING').length;
        const historyCount = data.filter((s: Suggestion) => s.category === 'HISTORY').length;
        console.log("Suggestions by status:", {
          active: activeCount,
          pending: pendingCount,
          history: historyCount,
        });
      } catch (error) {
        console.error("Error fetching suggestions:", error);
      }
    };

    fetchSuggestions();
  }, []);

  const handleNewSuggestion = async (data: any) => {
    try {
      const response = await fetch("/api/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      setShowNewSuggestion(false);
      // Refresh suggestions list after creating new one
      const refreshResponse = await fetch("/api/suggestions");
      if (refreshResponse.ok) {
        const refreshedData = await refreshResponse.json();
        setSuggestions(refreshedData);
        console.log("Suggestions refreshed after new addition:", refreshedData);
      }
    } catch (error) {
      console.error("Error creating suggestion:", error);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <div className="container mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
            <Badge variant="outline" className="text-sm">
              {suggestions.length} הצעות
            </Badge>
          </div>

          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm">
              <Download className="w-4 h-4 ml-2" />
              ייצוא
            </Button>

            <Button onClick={() => setShowNewSuggestion(true)}>
              <Plus className="w-4 h-4 ml-2" />
              הצעה חדשה
            </Button>
          </div>
        </div>

        {/* Stats Overview */}
        <SuggestionsStats suggestions={suggestions} className="mb-6" />

        {/* Main Content */}
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <div className="flex items-center justify-between mb-6">
            <TabsList>
              <TabsTrigger value="active">הצעות פעילות</TabsTrigger>
              <TabsTrigger value="pending">ממתין לאישור</TabsTrigger>
              <TabsTrigger value="history">היסטוריה</TabsTrigger>
            </TabsList>
          </div>

          {/* Action Bar */}
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
          />

          {/* Suggestions List */}
          <TabsContent value="active">
            <ManagerSuggestionsList
              suggestions={suggestions}
              filters={filters}
              searchQuery={searchQuery}
              type="active"
            />
          </TabsContent>

          <TabsContent value="pending">
            <ManagerSuggestionsList
              suggestions={suggestions}
              filters={filters}
              searchQuery={searchQuery}
              type="pending"
            />
          </TabsContent>

          <TabsContent value="history">
            <ManagerSuggestionsList
              suggestions={suggestions}
              filters={filters}
              searchQuery={searchQuery}
              type="history"
            />
          </TabsContent>
        </Tabs>
      </div>

      {/* New Suggestion Form */}
      <NewSuggestionForm
        isOpen={showNewSuggestion}
        onClose={() => setShowNewSuggestion(false)}
        candidates={[]}
        onSubmit={handleNewSuggestion}
      />
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx:
==================================================
import React from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Search, Filter, X } from "lucide-react";
import { Priority } from "@prisma/client";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: Record<string, any>;
  onFiltersChange: (filters: Record<string, any>) => void;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
}) => {
  const activeFilters = Object.keys(filters).length;

  const handleRemoveFilter = (key: string) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  return (
    <div className="space-y-4 mb-6">
      <div className="flex items-center gap-4">
        {/* Search */}
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות..."
            className="pl-10 text-right pr-10"
          />
        </div>

        {/* Priority Filter */}
        <Select
          value={filters.priority || "all"}
          onValueChange={(value) =>
            onFiltersChange({ ...filters, priority: value === "all" ? undefined : value })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">הכל</SelectItem>
            <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
            <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
            <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
            <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
          </SelectContent>
        </Select>

        {/* Timeframe Filter */}
        <Select
          value={filters.timeframe || "all"}
          onValueChange={(value) =>
            onFiltersChange({ ...filters, timeframe: value === "all" ? undefined : value })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="טווח זמן" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">הכל</SelectItem>
            <SelectItem value="today">היום</SelectItem>
            <SelectItem value="week">שבוע אחרון</SelectItem>
            <SelectItem value="month">חודש אחרון</SelectItem>
          </SelectContent>
        </Select>

        {/* Advanced Filters Button */}
        <Button variant="outline">
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2">
          {Object.entries(filters).map(([key, value]) => (
            <Badge key={key} variant="secondary" className="px-3 py-1 bg-white">
              <span>{`${key}: ${value}`}</span>
              <button
                onClick={() => handleRemoveFilter(key)}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          ))}
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה הכל
          </Button>
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx:
==================================================
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Users, CheckCircle, Clock, Calendar } from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
}

const COLORS = ["#3B82F6", "#EF4444", "#10B981", "#F59E0B", "#6366F1"];

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
}) => (
  <Card className={`p-4 ${className}`}>
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter(
      (s) => !["CLOSED", "CANCELLED", "EXPIRED"].includes(s.status)
    ).length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;
    const pending = suggestions.filter((s) =>
      s.status.includes("PENDING")
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const monthlyData = suggestions.reduce((acc, s) => {
      const month = new Date(s.createdAt).getMonth();
      acc[month] = (acc[month] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);

    return {
      total,
      active,
      success,
      pending,
      byStatus,
      monthlyData,
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{ value: 5, isPositive: true }}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
        />
        <StatsCard icon={Clock} title="ממתינות לתגובה" value={stats.pending} />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${Math.round((stats.success / stats.total) * 100)}%`}
        />
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Status Distribution */}
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">התפלגות סטטוסים</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={Object.entries(stats.byStatus).map(
                    ([status, count]) => ({
                      name: status,
                      value: count,
                    })
                  )}
                  cx="50%"
                  cy="50%"
                  labelLine={false}
                  label={({ name, percent }) =>
                    `${name} (${(percent * 100).toFixed(0)}%)`
                  }
                  outerRadius={80}
                  dataKey="value"
                >
                  {Object.entries(stats.byStatus).map((_, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={COLORS[index % COLORS.length]}
                    />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </Card>

        {/* Monthly Trend */}
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={Object.entries(stats.monthlyData).map(
                  ([month, count]) => ({
                    month: new Date(2024, parseInt(month)).toLocaleString(
                      "he",
                      { month: "short" }
                    ),
                    count,
                  })
                )}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Bar dataKey="count" fill="#3B82F6" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx:
==================================================
// SuggestionDetailsDialog.tsx
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card } from "@/components/ui/card";
import { ProfileCard } from "@/app/components/shared/shared/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  MessageCircle,
  AlertCircle,
  CheckCircle,
  XCircle,
  Clock,
  Calendar,
} from "lucide-react";
import { toast } from "sonner";
import type { Suggestion } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  onAction: (action: string) => void;
}

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl max-h-[90vh] p-0">
        <DialogHeader className="p-6 pb-0">
          <DialogTitle>פרטי הצעת שידוך</DialogTitle>
          <DialogDescription>
            הצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex h-full"
        >
          <div className="w-48 border-l">
            <TabsList className="flex flex-col h-full p-2">
              <TabsTrigger value="overview" className="justify-end">
                סקירה כללית
              </TabsTrigger>
              <TabsTrigger value="firstParty" className="justify-end">
                צד ראשון
              </TabsTrigger>
              <TabsTrigger value="secondParty" className="justify-end">
                צד שני
              </TabsTrigger>
              <TabsTrigger value="timeline" className="justify-end">
                ציר זמן
              </TabsTrigger>
              <TabsTrigger value="communication" className="justify-end">
                תקשורת
              </TabsTrigger>
            </TabsList>
          </div>

          <div className="flex-1 p-6">
            <TabsContent value="firstParty">
              <ProfileCard
                profile={suggestion.firstParty.profile}
                images={suggestion.firstParty.images}
                questionnaire={firstPartyQuestionnaire}
                viewMode="matchmaker"
              />
            </TabsContent>

            <TabsContent value="secondParty">
              <ProfileCard
                profile={suggestion.secondParty.profile}
                images={suggestion.secondParty.images}
                questionnaire={secondPartyQuestionnaire}
                viewMode="matchmaker"
              />
            </TabsContent>

            <TabsContent value="timeline">
              <ScrollArea className="h-[500px] pr-4">
                {isLoading ? (
                  <div className="flex items-center justify-center h-full">
                    טוען...
                  </div>
                ) : (
                  <Timeline
                    items={(suggestion?.statusHistory || []).map((history) => ({
                      title: history.status,
                      description: history.notes,
                      date: new Date(history.createdAt),
                      icon: history.status.includes("APPROVED")
                        ? CheckCircle
                        : history.status.includes("DECLINED")
                        ? XCircle
                        : AlertCircle,
                    }))}
                  />
                )}
              </ScrollArea>
            </TabsContent>

            <TabsContent value="communication">
              {/* Communication content here */}
            </TabsContent>
          </div>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsView.tsx:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx:
==================================================
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import { Eye, MessageCircle, Clock, Users } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { Suggestion } from "@/types/suggestions";
import StatusBadge from "../../new/shared/StatusBadge";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: Record<string, any>;
  searchQuery: string;
  type: "active" | "pending" | "history";
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Other filters
      if (filters.priority && suggestion.priority !== filters.priority) {
        return false;
      }

      if (filters.timeframe) {
        const createdAt = new Date(suggestion.createdAt);
        const now = new Date();
        const diff = now.getTime() - createdAt.getTime();
        const days = diff / (1000 * 60 * 60 * 24);

        switch (filters.timeframe) {
          case "today":
            if (days > 1) return false;
            break;
          case "week":
            if (days > 7) return false;
            break;
          case "month":
            if (days > 30) return false;
            break;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const handleViewClick = (suggestion: Suggestion) => {
    if (!suggestion.firstParty?.profile || !suggestion.secondParty?.profile) {
      toast.error("חסרים פרטי פרופיל למועמדים");
      return;
    }
    setSelectedSuggestion(suggestion);
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
    // Implement action handling logic here
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                <div className="flex justify-between items-start">
                  {/* Parties Info */}
                  <div className="flex-1 text-right">
                    <div className="flex items-center justify-between mb-2">
                      <StatusBadge
                        type="suggestion"
                        status={suggestion.status}
                      />
                      <Badge variant="outline" className="bg-white">
                        <Clock className="w-3 h-3 ml-1" />
                        {formatDistanceToNow(new Date(suggestion.createdAt), {
                          addSuffix: true,
                          locale: he,
                        })}
                      </Badge>
                    </div>

                    <div className="flex justify-between items-start gap-8">
                      <div className="flex-1">
                        <h4 className="font-medium">צד ראשון</h4>
                        <p>
                          {suggestion.firstParty.firstName}{" "}
                          {suggestion.firstParty.lastName}
                        </p>
                        <p className="text-sm text-gray-500">
                          {suggestion.firstParty.profile?.city},{" "}
                          {suggestion.firstParty.profile?.birthDate &&
                            Math.floor(
                              (new Date().getTime() -
                                new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).getTime()) /
                                (365.25 * 24 * 60 * 60 * 1000)
                            )}
                        </p>
                      </div>

                      <div className="flex-1">
                        <h4 className="font-medium">צד שני</h4>
                        <p>
                          {suggestion.secondParty.firstName}{" "}
                          {suggestion.secondParty.lastName}
                        </p>
                        <p className="text-sm text-gray-500">
                          {suggestion.secondParty.profile?.city},{" "}
                          {suggestion.secondParty.profile?.birthDate &&
                            Math.floor(
                              (new Date().getTime() -
                                new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).getTime()) /
                                (365.25 * 24 * 60 * 60 * 1000)
                            )}
                        </p>
                      </div>
                    </div>

                    {suggestion.matchingReason && (
                      <p className="mt-2 text-sm text-gray-600 line-clamp-2">
                        {suggestion.matchingReason}
                      </p>
                    )}
                  </div>

                  {/* Actions */}
                  <div className="flex gap-2 mr-4">
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => handleViewClick(suggestion)}
                    >
                      <Eye className="w-4 h-4 ml-2" />
                      צפייה
                    </Button>
                    <Button size="sm" variant="outline">
                      <MessageCircle className="w-4 h-4 ml-2" />
                      תקשורת
                    </Button>
                  </div>
                </div>

                {/* Timeline */}
                {suggestion.statusHistory &&
                  suggestion.statusHistory.length > 0 && (
                    <div className="mt-4 pt-4 border-t">
                      <div className="flex gap-4 text-sm text-gray-500">
                        {suggestion.statusHistory
                          .slice(-3)
                          .map((history, index) => (
                            <div
                              key={index}
                              className="flex items-center gap-2"
                            >
                              <StatusBadge
                                type="suggestion"
                                status={history.status}
                                size="sm"
                              />
                              <span>
                                {formatDistanceToNow(
                                  new Date(history.createdAt),
                                  {
                                    addSuffix: true,
                                    locale: he,
                                  }
                                )}
                              </span>
                            </div>
                          ))}
                      </div>
                    </div>
                  )}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />
    </>
  );
};

export default ManagerSuggestionsList;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionCard.tsx:
==================================================



==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx:
==================================================
import React, { useState, useCallback, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Filter, Plus, Download } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";
import { MatchSuggestionStatus } from "@prisma/client";
import NewSuggestionForm from "../../new/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import ManagerSuggestionsList from "../list/ManagerSuggestionsList";
import { toast } from "sonner";

export default function MatchmakerDashboard() {
  // State management
  const [activeTab, setActiveTab] = useState("active");
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<Record<string, any>>({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  // Fetch suggestions data
  const fetchSuggestions = async () => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/matchmaker/suggestions");
      if (!response.ok) {
        throw new Error("Failed to fetch suggestions");
      }

      const data = await response.json();
      setSuggestions(data);

      // Log suggestions data for debugging
      console.log("Fetched suggestions:", data);
      console.log("Total suggestions count:", data.length);

      // Log suggestions by status
      const activeCount = data.filter((s: Suggestion) => s.category === 'ACTIVE').length;
      const pendingCount = data.filter((s: Suggestion) => s.category === 'PENDING').length;
      const historyCount = data.filter((s: Suggestion) => s.category === 'HISTORY').length;
      console.log("Suggestions by status:", {
        active: activeCount,
        pending: pendingCount,
        history: historyCount,
      });
    } catch (error) {
      console.error("Error fetching suggestions:", error);
      toast.error("שגיאה בטעינת ההצעות");
    } finally {
      setIsLoading(false);
    }
  };

  // Initial data fetch
  useEffect(() => {
    fetchSuggestions();
  }, []);

  // Handle new suggestion creation
  const handleNewSuggestion = async (data: any) => {
    try {
      const response = await fetch("/api/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error("Failed to create suggestion");
      }

      setShowNewSuggestion(false);
      toast.success("ההצעה נוצרה בהצלחה");
      
      // Refresh suggestions list
      await fetchSuggestions();
    } catch (error) {
      console.error("Error creating suggestion:", error);
      toast.error("שגיאה ביצירת ההצעה");
    }
  };

  // Handle suggestion deletion
  const handleSuggestionDeleted = useCallback((deletedId: string) => {
    setSuggestions(prevSuggestions => 
      prevSuggestions.filter(suggestion => suggestion.id !== deletedId)
    );
  }, []);

  // Export suggestions to CSV
  const handleExport = async () => {
    try {
      const response = await fetch("/api/suggestions/export", {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        throw new Error("Failed to export suggestions");
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `suggestions-export-${new Date().toISOString()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error("Error exporting suggestions:", error);
      toast.error("שגיאה בייצוא ההצעות");
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <div className="container mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
            <Badge variant="outline" className="text-sm">
              {suggestions.length} הצעות
            </Badge>
          </div>

          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm" onClick={handleExport}>
              <Download className="w-4 h-4 ml-2" />
              ייצוא
            </Button>

            <Button onClick={() => setShowNewSuggestion(true)}>
              <Plus className="w-4 h-4 ml-2" />
              הצעה חדשה
            </Button>
          </div>
        </div>

        {/* Stats Overview */}
        <SuggestionsStats suggestions={suggestions} className="mb-6" />

        {/* Main Content */}
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <div className="flex items-center justify-between mb-6">
            <TabsList>
              <TabsTrigger value="active">הצעות פעילות</TabsTrigger>
              <TabsTrigger value="pending">ממתין לאישור</TabsTrigger>
              <TabsTrigger value="history">היסטוריה</TabsTrigger>
            </TabsList>
          </div>

          {/* Action Bar */}
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
          />

          {/* Loading State */}
          {isLoading ? (
            <div className="flex items-center justify-center h-64">
              <div className="text-gray-500">טוען...</div>
            </div>
          ) : (
            <>
              {/* Suggestions Lists */}
              <TabsContent value="active">
                <ManagerSuggestionsList
                  suggestions={suggestions}
                  filters={filters}
                  searchQuery={searchQuery}
                  type="active"
                  onSuggestionDeleted={handleSuggestionDeleted}
                />
              </TabsContent>

              <TabsContent value="pending">
                <ManagerSuggestionsList
                  suggestions={suggestions}
                  filters={filters}
                  searchQuery={searchQuery}
                  type="pending"
                  onSuggestionDeleted={handleSuggestionDeleted}
                />
              </TabsContent>

              <TabsContent value="history">
                <ManagerSuggestionsList
                  suggestions={suggestions}
                  filters={filters}
                  searchQuery={searchQuery}
                  type="history"
                  onSuggestionDeleted={handleSuggestionDeleted}
                />
              </TabsContent>
            </>
          )}
        </Tabs>
      </div>

      {/* New Suggestion Form */}
      <NewSuggestionForm
        isOpen={showNewSuggestion}
        onClose={() => setShowNewSuggestion(false)}
        candidates={[]}
        onSubmit={handleNewSuggestion}
      />
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx:
==================================================
import React from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Search, Filter, X } from "lucide-react";
import { Priority } from "@prisma/client";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: Record<string, any>;
  onFiltersChange: (filters: Record<string, any>) => void;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
}) => {
  const activeFilters = Object.keys(filters).length;

  const handleRemoveFilter = (key: string) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  return (
    <div className="space-y-4 mb-6">
      <div className="flex items-center gap-4">
        {/* Search */}
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות..."
            className="pl-10 text-right pr-10"
          />
        </div>

        {/* Priority Filter */}
        <Select
          value={filters.priority || "all"}
          onValueChange={(value) =>
            onFiltersChange({ ...filters, priority: value === "all" ? undefined : value })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">הכל</SelectItem>
            <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
            <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
            <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
            <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
          </SelectContent>
        </Select>

        {/* Timeframe Filter */}
        <Select
          value={filters.timeframe || "all"}
          onValueChange={(value) =>
            onFiltersChange({ ...filters, timeframe: value === "all" ? undefined : value })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="טווח זמן" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">הכל</SelectItem>
            <SelectItem value="today">היום</SelectItem>
            <SelectItem value="week">שבוע אחרון</SelectItem>
            <SelectItem value="month">חודש אחרון</SelectItem>
          </SelectContent>
        </Select>

        {/* Advanced Filters Button */}
        <Button variant="outline">
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2">
          {Object.entries(filters).map(([key, value]) => (
            <Badge key={key} variant="secondary" className="px-3 py-1 bg-white">
              <span>{`${key}: ${value}`}</span>
              <button
                onClick={() => handleRemoveFilter(key)}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          ))}
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה הכל
          </Button>
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx:
==================================================
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Users, CheckCircle, Clock, Calendar } from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
}

const COLORS = ["#3B82F6", "#EF4444", "#10B981", "#F59E0B", "#6366F1"];

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
}) => (
  <Card className={`p-4 ${className}`}>
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter(
      (s) => !["CLOSED", "CANCELLED", "EXPIRED"].includes(s.status)
    ).length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;
    const pending = suggestions.filter((s) =>
      s.status.includes("PENDING")
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const monthlyData = suggestions.reduce((acc, s) => {
      const month = new Date(s.createdAt).getMonth();
      acc[month] = (acc[month] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);

    return {
      total,
      active,
      success,
      pending,
      byStatus,
      monthlyData,
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{ value: 5, isPositive: true }}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
        />
        <StatsCard icon={Clock} title="ממתינות לתגובה" value={stats.pending} />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${Math.round((stats.success / stats.total) * 100)}%`}
        />
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Status Distribution */}
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">התפלגות סטטוסים</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={Object.entries(stats.byStatus).map(
                    ([status, count]) => ({
                      name: status,
                      value: count,
                    })
                  )}
                  cx="50%"
                  cy="50%"
                  labelLine={false}
                  label={({ name, percent }) =>
                    `${name} (${(percent * 100).toFixed(0)}%)`
                  }
                  outerRadius={80}
                  dataKey="value"
                >
                  {Object.entries(stats.byStatus).map((_, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={COLORS[index % COLORS.length]}
                    />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </Card>

        {/* Monthly Trend */}
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={Object.entries(stats.monthlyData).map(
                  ([month, count]) => ({
                    month: new Date(2024, parseInt(month)).toLocaleString(
                      "he",
                      { month: "short" }
                    ),
                    count,
                  })
                )}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Bar dataKey="count" fill="#3B82F6" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx:
==================================================
// SuggestionDetailsDialog.tsx
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card } from "@/components/ui/card";
import { ProfileCard } from "@/app/components/shared/shared/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  MessageCircle,
  AlertCircle,
  CheckCircle,
  XCircle,
  Clock,
  Calendar,
} from "lucide-react";
import { toast } from "sonner";
import type { Suggestion } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  onAction: (action: string) => void;
}

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl max-h-[90vh] p-0">
        <DialogHeader className="p-6 pb-0">
          <DialogTitle>פרטי הצעת שידוך</DialogTitle>
          <DialogDescription>
            הצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex h-full"
        >
          <div className="w-48 border-l">
            <TabsList className="flex flex-col h-full p-2">
              <TabsTrigger value="overview" className="justify-end">
                סקירה כללית
              </TabsTrigger>
              <TabsTrigger value="firstParty" className="justify-end">
                צד ראשון
              </TabsTrigger>
              <TabsTrigger value="secondParty" className="justify-end">
                צד שני
              </TabsTrigger>
              <TabsTrigger value="timeline" className="justify-end">
                ציר זמן
              </TabsTrigger>
              <TabsTrigger value="communication" className="justify-end">
                תקשורת
              </TabsTrigger>
            </TabsList>
          </div>

          <div className="flex-1 p-6">
            <TabsContent value="firstParty">
              <ProfileCard
                profile={suggestion.firstParty.profile}
                images={suggestion.firstParty.images}
                questionnaire={firstPartyQuestionnaire}
                viewMode="matchmaker"
              />
            </TabsContent>

            <TabsContent value="secondParty">
              <ProfileCard
                profile={suggestion.secondParty.profile}
                images={suggestion.secondParty.images}
                questionnaire={secondPartyQuestionnaire}
                viewMode="matchmaker"
              />
            </TabsContent>

            <TabsContent value="timeline">
              <ScrollArea className="h-[500px] pr-4">
                {isLoading ? (
                  <div className="flex items-center justify-center h-full">
                    טוען...
                  </div>
                ) : (
                  <Timeline
                    items={(suggestion?.statusHistory || []).map((history) => ({
                      title: history.status,
                      description: history.notes,
                      date: new Date(history.createdAt),
                      icon: history.status.includes("APPROVED")
                        ? CheckCircle
                        : history.status.includes("DECLINED")
                        ? XCircle
                        : AlertCircle,
                    }))}
                  />
                )}
              </ScrollArea>
            </TabsContent>

            <TabsContent value="communication">
              {/* Communication content here */}
            </TabsContent>
          </div>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsView.tsx:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx:
==================================================
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import { Eye, MessageCircle, Clock, Users, Trash2 } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { Suggestion } from "@/types/suggestions";
import StatusBadge from "../../new/shared/StatusBadge";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: Record<string, any>;
  searchQuery: string;
  type: "active" | "pending" | "history";
  onSuggestionDeleted?: (id: string) => void;
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
  onSuggestionDeleted,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] = useState<Suggestion | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [suggestionToDelete, setSuggestionToDelete] = useState<string | null>(null);

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Other filters
      if (filters.priority && suggestion.priority !== filters.priority) {
        return false;
      }

      if (filters.timeframe) {
        const createdAt = new Date(suggestion.createdAt);
        const now = new Date();
        const diff = now.getTime() - createdAt.getTime();
        const days = diff / (1000 * 60 * 60 * 24);

        switch (filters.timeframe) {
          case "today":
            if (days > 1) return false;
            break;
          case "week":
            if (days > 7) return false;
            break;
          case "month":
            if (days > 30) return false;
            break;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const handleViewClick = (suggestion: Suggestion) => {
    if (!suggestion.firstParty?.profile || !suggestion.secondParty?.profile) {
      toast.error("חסרים פרטי פרופיל למועמדים");
      return;
    }
    setSelectedSuggestion(suggestion);
  };

  const handleDelete = (id: string) => {
    setSuggestionToDelete(id);
    setShowDeleteDialog(true);
  };

  const confirmDelete = async () => {
    if (!suggestionToDelete) return;

    try {
      const response = await fetch(`/api/suggestions/${suggestionToDelete}/delete`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete suggestion');
      }

      toast.success('ההצעה נמחקה בהצלחה');
      if (onSuggestionDeleted) {
        onSuggestionDeleted(suggestionToDelete);
      }
    } catch (error) {
      console.error('Error deleting suggestion:', error);
      toast.error('שגיאה במחיקת ההצעה');
    } finally {
      setShowDeleteDialog(false);
      setSuggestionToDelete(null);
    }
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
    // Implement action handling logic here
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                <div className="flex justify-between items-start">
                  {/* Parties Info */}
                  <div className="flex-1 text-right">
                    <div className="flex items-center justify-between mb-2">
                      <StatusBadge
                        type="suggestion"
                        status={suggestion.status}
                      />
                      <Badge variant="outline" className="bg-white">
                        <Clock className="w-3 h-3 ml-1" />
                        {formatDistanceToNow(new Date(suggestion.createdAt), {
                          addSuffix: true,
                          locale: he,
                        })}
                      </Badge>
                    </div>

                    <div className="flex justify-between items-start gap-8">
                      <div className="flex-1">
                        <h4 className="font-medium">צד ראשון</h4>
                        <p>
                          {suggestion.firstParty.firstName}{" "}
                          {suggestion.firstParty.lastName}
                        </p>
                        <p className="text-sm text-gray-500">
                          {suggestion.firstParty.profile?.city},{" "}
                          {suggestion.firstParty.profile?.birthDate &&
                            Math.floor(
                              (new Date().getTime() -
                                new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).getTime()) /
                                (365.25 * 24 * 60 * 60 * 1000)
                            )}
                        </p>
                      </div>

                      <div className="flex-1">
                        <h4 className="font-medium">צד שני</h4>
                        <p>
                          {suggestion.secondParty.firstName}{" "}
                          {suggestion.secondParty.lastName}
                        </p>
                        <p className="text-sm text-gray-500">
                          {suggestion.secondParty.profile?.city},{" "}
                          {suggestion.secondParty.profile?.birthDate &&
                            Math.floor(
                              (new Date().getTime() -
                                new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).getTime()) /
                                (365.25 * 24 * 60 * 60 * 1000)
                            )}
                        </p>
                      </div>
                    </div>

                    {suggestion.matchingReason && (
                      <p className="mt-2 text-sm text-gray-600 line-clamp-2">
                        {suggestion.matchingReason}
                      </p>
                    )}
                  </div>

                  {/* Actions */}
                  <div className="flex gap-2 mr-4">
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => handleViewClick(suggestion)}
                    >
                      <Eye className="w-4 h-4 ml-2" />
                      צפייה
                    </Button>
                    <Button size="sm" variant="outline">
                      <MessageCircle className="w-4 h-4 ml-2" />
                      תקשורת
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      className="text-red-600 hover:text-red-700"
                      onClick={() => handleDelete(suggestion.id)}
                    >
                      <Trash2 className="w-4 h-4 ml-2" />
                      מחיקה
                    </Button>
                  </div>
                </div>

                {/* Timeline */}
                {suggestion.statusHistory &&
                  suggestion.statusHistory.length > 0 && (
                    <div className="mt-4 pt-4 border-t">
                      <div className="flex gap-4 text-sm text-gray-500">
                        {suggestion.statusHistory
                          .slice(-3)
                          .map((history, index) => (
                            <div
                              key={index}
                              className="flex items-center gap-2"
                            >
                              <StatusBadge
                                type="suggestion"
                                status={history.status}
                                size="sm"
                              />
                              <span>
                                {formatDistanceToNow(
                                  new Date(history.createdAt),
                                  {
                                    addSuffix: true,
                                    locale: he,
                                  }
                                )}
                              </span>
                            </div>
                          ))}
                      </div>
                    </div>
                  )}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
            <AlertDialogDescription>
              פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              מחיקה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default ManagerSuggestionsList;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionCard.tsx:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\messages\AvailabilityRequestCard.tsx:
==================================================
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Clock, CheckCircle, XCircle } from "lucide-react";
import type { ExtendedInquiry } from "@/types/messages";

interface AvailabilityRequestCardProps {
  inquiry: ExtendedInquiry;
  currentUserId: string;
  onRespond: (inquiryId: string, isAvailable: boolean) => Promise<void>;
}

export default function AvailabilityRequestCard({
  inquiry,
  currentUserId,
  onRespond,
}: AvailabilityRequestCardProps) {
  const isFirstParty = inquiry.firstPartyId === currentUserId;
  const isSecondParty = inquiry.secondPartyId === currentUserId;
  const totalResponses = [
    inquiry.firstPartyResponse,
    inquiry.secondPartyResponse,
  ].filter((r) => r !== null).length;
  const progress = (totalResponses / 2) * 100;

  return (
    <Card>
      <CardContent className="p-6">
        <div className="flex justify-between items-start mb-4">
          <div>
            <h3 className="font-medium">בקשת בדיקת זמינות</h3>
            <p className="text-sm text-gray-600">
              מאת {inquiry.matchmaker.firstName} {inquiry.matchmaker.lastName}
            </p>
          </div>
          <Clock className="w-5 h-5 text-gray-400" />
        </div>

        <div className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <div className="text-sm text-gray-500">צד ראשון</div>
              <div className="flex items-center mt-1">
                {inquiry.firstPartyResponse === null ? (
                  <Clock className="w-4 h-4 text-yellow-500 mr-1" />
                ) : inquiry.firstPartyResponse ? (
                  <CheckCircle className="w-4 h-4 text-green-500 mr-1" />
                ) : (
                  <XCircle className="w-4 h-4 text-red-500 mr-1" />
                )}
                <span>
                  {inquiry.firstParty.firstName} {inquiry.firstParty.lastName}
                </span>
              </div>
            </div>
          </div>

          <div className="space-y-2">
            <div className="flex justify-between text-sm text-gray-500">
              <span>התקדמות</span>
              <span>{progress}%</span>
            </div>
            <Progress value={progress} className="w-full" />
          </div>

          {inquiry.note && (
            <div className="text-sm text-gray-600">
              <strong>הערה:</strong> {inquiry.note}
            </div>
          )}

          {isFirstParty && inquiry.firstPartyResponse === null && (
            <div className="flex gap-2 mt-4">
              <Button
                onClick={() => onRespond(inquiry.id, true)}
                className="flex-1 bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="mr-2 h-4 w-4" />
                אני זמין/ה
              </Button>
              <Button
                onClick={() => onRespond(inquiry.id, false)}
                variant="outline"
                className="flex-1"
              >
                <XCircle className="mr-2 h-4 w-4" />
                לא זמין/ה כרגע
              </Button>
            </div>
          )}

          {isSecondParty && inquiry.secondPartyResponse === null && (
            <div className="flex gap-2 mt-4">
              <Button
                onClick={() => onRespond(inquiry.id, true)}
                className="flex-1 bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="mr-2 h-4 w-4" />
                אני זמין/ה
              </Button>
              <Button
                onClick={() => onRespond(inquiry.id, false)}
                variant="outline"
                className="flex-1"
              >
                <XCircle className="mr-2 h-4 w-4" />
                לא זמין/ה כרגע
              </Button>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\messages\MessagesPage.tsx:
==================================================
"use client";
import { useNotifications } from "@/app/contexts/NotificationContext";
import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Progress } from "@/components/ui/progress";
import { Clock, CheckCircle, XCircle, Loader2, Users } from "lucide-react";
import type { ExtendedInquiry } from "@/types/messages";
import type { Session } from "@/types/next-auth";

export default function MessagesPage() {
  const { data: session } = useSession() as { data: Session | null };
  const { refreshNotifications } = useNotifications();
  const [inquiries, setInquiries] = useState<ExtendedInquiry[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [filters, setFilters] = useState({
    status: "pending",
    timeframe: "all",
  });
  const [note, setNote] = useState("");

  useEffect(() => {
    if (session?.user) {
      loadInquiries();
    }
  }, [session, filters]);

  const loadInquiries = async () => {
    try {
      const queryParams = new URLSearchParams({
        status: filters.status,
        timeframe: filters.timeframe,
      });

      const response = await fetch(`/api/matchmaker/inquiries?${queryParams}`);
      if (!response.ok) throw new Error("Failed to load inquiries");
      const data = await response.json();
      setInquiries(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load inquiries");
    } finally {
      setLoading(false);
    }
  };

  const handleResponse = async (inquiryId: string, isAvailable: boolean) => {
    try {
      const response = await fetch(
        `/api/matchmaker/inquiries/${inquiryId}/respond`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ isAvailable, note }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to submit response");
      }

      await loadInquiries();
      await refreshNotifications();
      setNote("");
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to submit response"
      );
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loader2 className="w-8 h-8 animate-spin" />
      </div>
    );
  }

  if (inquiries.length === 0) {
    return (
      <Card className="max-w-4xl mx-auto mt-8">
        <CardContent className="p-6 text-center">
          <Users className="w-12 h-12 mx-auto text-gray-400 mb-4" />
          <h3 className="text-lg font-medium">אין הודעות</h3>
          <p className="text-gray-500">אין הודעות או התראות חדשות</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <Card className="mb-6">
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle>הודעות והתראות</CardTitle>
          <div className="flex gap-4">
            <Select
              value={filters.status}
              onValueChange={(value) =>
                setFilters((prev) => ({ ...prev, status: value }))
              }
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="סינון לפי סטטוס" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                <SelectItem value="pending">ממתין לתגובה</SelectItem>
                <SelectItem value="completed">טופל</SelectItem>
              </SelectContent>
            </Select>

            <Select
              value={filters.timeframe}
              onValueChange={(value) =>
                setFilters((prev) => ({ ...prev, timeframe: value }))
              }
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="סינון לפי זמן" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                <SelectItem value="today">היום</SelectItem>
                <SelectItem value="week">שבוע אחרון</SelectItem>
                <SelectItem value="month">חודש אחרון</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardHeader>
      </Card>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 gap-6">
        {inquiries.map((inquiry) => (
          <Card key={inquiry.id}>
            <CardContent className="p-6">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h3 className="font-medium">בקשת בדיקת זמינות</h3>
                  <p className="text-sm text-gray-600">
                    מאת {inquiry.matchmaker.firstName}{" "}
                    {inquiry.matchmaker.lastName}
                  </p>
                </div>
                <Clock className="w-5 h-5 text-gray-400" />
              </div>

              <div className="space-y-4">
                {inquiry.note && (
                  <div className="text-sm text-gray-600 mt-2">
                    <strong>הערה:</strong> {inquiry.note}
                  </div>
                )}

                {!inquiry.firstPartyResponse && (
                  <>
                    <div className="space-y-2">
                      <label className="block text-sm font-medium">
                        הערות (אופציונלי):
                      </label>
                      <Textarea
                        value={note}
                        onChange={(e) => setNote(e.target.value)}
                        placeholder="הוסף/י הערות..."
                        className="w-full"
                      />
                    </div>

                    <div className="flex gap-2 mt-4">
                      <Button
                        onClick={() => handleResponse(inquiry.id, true)}
                        className="flex-1 bg-green-600 hover:bg-green-700"
                      >
                        <CheckCircle className="mr-2 h-4 w-4" />
                        אני זמין/ה
                      </Button>
                      <Button
                        onClick={() => handleResponse(inquiry.id, false)}
                        variant="outline"
                        className="flex-1"
                      >
                        <XCircle className="mr-2 h-4 w-4" />
                        לא זמין/ה כרגע
                      </Button>
                    </div>
                  </>
                )}

{inquiry.firstPartyResponse !== null && (
  <div className="space-y-4">
    <div className={`flex items-center gap-2 p-2 rounded-md ${
      inquiry.firstPartyResponse
        ? "bg-green-50 text-green-700"
        : "bg-red-50 text-red-700"
    }`}>
      {inquiry.firstPartyResponse ? (
        <CheckCircle className="h-5 w-5" />
      ) : (
        <XCircle className="h-5 w-5" />
      )}
      <span>
        {inquiry.firstPartyResponse
          ? "אישרת זמינות"
          : "ציינת שאינך זמין/ה"}
      </span>
    </div>

    <div>
      <Button
        onClick={() => handleResponse(inquiry.id, !inquiry.firstPartyResponse)}
        className={`w-full ${
          inquiry.firstPartyResponse 
            ? "bg-red-600 hover:bg-red-700"
            : "bg-green-600 hover:bg-green-700"
        }`}
      >
        {inquiry.firstPartyResponse ? (
          <>
            <XCircle className="mr-2 h-4 w-4" />
            שינוי תשובה - אינני זמין/ה
          </>
        ) : (
          <>
            <CheckCircle className="mr-2 h-4 w-4" />
            שינוי תשובה - אני זמין/ה
          </>
        )}
      </Button>
    </div>
  </div>
)}
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\constants.ts:
==================================================
// src/components/shared/profile/constants.ts
import { Heart, User, Users, Scroll, GraduationCap, Briefcase, MapPin, Globe, Languages, Home } from "lucide-react";

export const WORLDS = {
  values: {
    key: "values",
    title: "ערכים ואמונות",
    icon: Heart,
    color: "text-pink-500",
    bgColor: "bg-pink-50",
    borderColor: "border-pink-200",
  },
  personality: {
    key: "personality",
    title: "אישיות",
    icon: User,
    color: "text-blue-500",
    bgColor: "bg-blue-50",
    borderColor: "border-blue-200",
  },
  relationship: {
    key: "relationship",
    title: "זוגיות ומשפחה",
    icon: Users,
    color: "text-purple-500",
    bgColor: "bg-purple-50",
    borderColor: "border-purple-200",
  },
  religion: {
    key: "religion",
    title: "דת ומסורת",
    icon: Scroll,
    color: "text-indigo-500",
    bgColor: "bg-indigo-50",
    borderColor: "border-indigo-200",
  },
  partner: {
    key: "partner",
    title: "העדפות בן/בת זוג",
    icon: Heart,
    color: "text-red-500",
    bgColor: "bg-red-50",
    borderColor: "border-red-200",
  },
} as const;

export const RELIGIOUS_LEVELS = [
  "חרדי",
  "חרדי מודרני",
  "דתי",
  "דתי-לייט",
  "מסורתי"
] as const;

export const MARITAL_STATUS = [
  "single",
  "divorced",
  "widowed"
] as const;

export const EDUCATION_LEVELS = [
  "תיכונית",
  "על תיכונית",
  "אקדמית",
  "תורנית"
] as const;

export const OCCUPATION_TYPES = [
  "עובד/ת",
  "סטודנט/ית",
  "אברך/אברכית",
  "עצמאי/ת"
] as const;

export const LOCATIONS = [
  "צפון",
  "מרכז",
  "דרום",
  "ירושלים",
  "יהודה ושומרון"
] as const;

export const PROFILE_SECTIONS = {
  BASIC_INFO: {
    title: "פרטים אישיים",
    icon: User,
  },
  EDUCATION: {
    title: "השכלה ותעסוקה",
    icon: GraduationCap,
  },
  LOCATION: {
    title: "מיקום",
    icon: MapPin,
  },
  FAMILY: {
    title: "מידע משפחתי",
    icon: Users,
  },
  PREFERENCES: {
    title: "העדפות",
    icon: Heart,
  },
} as const;

export const COMMUNICATION_STYLES = [
  "ישיר",
  "עקיף",
  "דיפלומטי"
] as const;

export const STRESS_MANAGEMENT = [
  "רגוע",
  "לחוץ",
  "משתנה"
] as const;

export const CONTACT_PREFERENCES = [
  { value: "direct", label: "ישירות" },
  { value: "matchmaker", label: "דרך השדכן/ית" },
  { value: "both", label: "שתי האפשרויות" }
] as const;

// הגדרות עבור הוולידציה
export const VALIDATION_RULES = {
  AGE: {
    MIN: 18,
    MAX: 99
  },
  HEIGHT: {
    MIN: 100,
    MAX: 250
  },
  NAME: {
    MIN_LENGTH: 2,
    MAX_LENGTH: 50
  }
} as const;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\helpers.ts:
==================================================
import type { UserProfile, UserImage, QuestionnaireResponse } from "@/types/next-auth";
import { VALIDATION_RULES } from "./constants";

/**
 * Calculates the completion percentage of a profile based on required fields
 * @param profile - The user profile to check
 * @returns The percentage of completion (0-100)
 */
export const getProfileCompletion = (profile: UserProfile): number => {
  const requiredFields = [
    'gender',
    'birthDate',
    'height',
    'maritalStatus',
    'city',
    'religiousLevel',
    'occupation',
    'education',
    'about',
    'referenceName1',
    'referencePhone1'
  ];
  
  const completedFields = requiredFields.filter(field => {
    const value = profile[field as keyof UserProfile];
    return value !== null && value !== undefined && value !== '';
  });

  return Math.round((completedFields.length / requiredFields.length) * 100);
};

/**
 * Formats a date for display in the Hebrew locale
 * @param date - The date to format
 * @returns Formatted date string
 */
export const formatDateDisplay = (date: Date | string): string => {
  return new Date(date).toLocaleDateString('he-IL', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

/**
 * Gets the main profile image from an array of images
 * @param images - Array of user images
 * @returns The main image or undefined if none exists
 */
export const getMainImage = (images: UserImage[]): UserImage | undefined => {
  return images.find(img => img.isMain);
};

/**
 * Validates a profile field based on predefined rules
 * @param fieldName - Name of the field to validate
 * @param value - Value to validate
 * @returns Validation result with optional error message
 */
export const validateProfileField = (
  fieldName: keyof UserProfile,
  value: any
): { isValid: boolean; error?: string } => {
  // Skip validation if value is empty/null
  if (value === null || value === undefined || value === '') {
    return { isValid: true };
  }

  switch (fieldName) {
    case 'height':
      if (value < VALIDATION_RULES.HEIGHT.MIN || value > VALIDATION_RULES.HEIGHT.MAX) {
        return {
          isValid: false,
          error: `גובה חייב להיות בין ${VALIDATION_RULES.HEIGHT.MIN} ל-${VALIDATION_RULES.HEIGHT.MAX} ס"מ`
        };
      }
      break;
    
    case 'birthDate':
      const age = calculateAge(new Date(value));
      if (age < VALIDATION_RULES.AGE.MIN || age > VALIDATION_RULES.AGE.MAX) {
        return {
          isValid: false,
          error: `גיל חייב להיות בין ${VALIDATION_RULES.AGE.MIN} ל-${VALIDATION_RULES.AGE.MAX}`
        };
      }
      break;

    case 'referenceName1':
    case 'referenceName2':
      if (value.length < VALIDATION_RULES.NAME.MIN_LENGTH || value.length > VALIDATION_RULES.NAME.MAX_LENGTH) {
        return {
          isValid: false,
          error: `שם חייב להיות בין ${VALIDATION_RULES.NAME.MIN_LENGTH} ל-${VALIDATION_RULES.NAME.MAX_LENGTH} תווים`
        };
      }
      break;

    case 'referencePhone1':
    case 'referencePhone2':
      const phoneRegex = /^[\d-]{9,15}$/;
      if (!phoneRegex.test(value)) {
        return {
          isValid: false,
          error: 'מספר טלפון לא תקין'
        };
      }
      break;
  }
  
  return { isValid: true };
};

/**
 * Calculates the questionnaire completion progress
 * @param questionnaire - The questionnaire response object
 * @returns Percentage of completion (0-100)
 */
export const getQuestionnaireProgress = (questionnaire: QuestionnaireResponse): number => {
  const totalWorlds = 5; // values, personality, relationship, religion, partner
  const completedWorlds = questionnaire.worldsCompleted.length;
  return Math.round((completedWorlds / totalWorlds) * 100);
};

/**
 * Checks if a profile has minimum required information for matching
 * @param profile - The user profile to check
 * @returns Whether the profile is ready for matching
 */
export const isProfileReadyForMatching = (profile: UserProfile): boolean => {
  const requiredFields: (keyof UserProfile)[] = [
    'gender',
    'birthDate',
    'height',
    'maritalStatus',
    'city',
    'religiousLevel'
  ];

  return requiredFields.every(field => {
    const value = profile[field];
    return value !== null && value !== undefined && value !== '';
  });
};

/**
 * Generates a profile completion summary with specific missing fields
 * @param profile - The user profile to check
 * @returns Object containing completion status and missing fields
 */
export const getProfileCompletionSummary = (profile: UserProfile): {
  isComplete: boolean;
  missingFields: string[];
} => {
  const missingFields: string[] = [];
  const requiredFields = {
    'gender': 'מגדר',
    'birthDate': 'תאריך לידה',
    'height': 'גובה',
    'maritalStatus': 'מצב משפחתי',
    'city': 'עיר מגורים',
    'religiousLevel': 'רמת דתיות',
    'referenceName1': 'שם ממליץ ראשון',
    'referencePhone1': 'טלפון ממליץ ראשון'
  } as const;

  for (const [field, label] of Object.entries(requiredFields)) {
    const value = profile[field as keyof UserProfile];
    if (!value) {
      missingFields.push(label);
    }
  }

  return {
    isComplete: missingFields.length === 0,
    missingFields
  };
};

/**
 * Formats profile data for display, including calculating age
 * @param profile - The user profile to format
 * @returns Formatted profile data
 */
export const formatProfileForDisplay = (profile: UserProfile) => {
  return {
    ...profile,
    age: calculateAge(new Date(profile.birthDate)),
    formattedBirthDate: formatDateDisplay(profile.birthDate),
    formattedLastUpdate: profile.updatedAt ? formatDateDisplay(profile.updatedAt) : undefined
  };
};

/**
 * Calculates age from birthdate
 * @param birthDate - Date of birth
 * @returns Current age
 */
const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\index.ts:
==================================================
// src/components/shared/profile/index.ts

// Main Components
export { default as ProfileCard } from './ProfileCard';

// Sections
export { default as ExtendedProfileSection } from './sections/ExtendedProfileSection';
export { default as PhotosSection } from './sections/PhotosSection';
export { default as PreferencesSection } from './sections/PreferencesSection';
export { default as ProfileSection } from './sections/ProfileSection';
export { default as QuestionnaireResponsesSection } from './sections/QuestionnaireResponsesSection';

// Elements
export { default as StatsCard } from './elements/StatsCard';
export { default as VisibilityControl } from './elements/VisibilityControl';
export { default as MinimalCard } from './elements/MinimalCard';

// Types
export * from './types/profile';
export * from './types/questionnaire';

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\ProfileCard.tsx:
==================================================
import React, { useState } from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";

// UI Components
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Alert, AlertDescription } from "@/components/ui/alert";

// Icons
import {
  User,
  Heart,
  MapPin,
  Clock,
  Eye,
  FileText,
  Image as ImageIcon,
  Info,
  Phone,
  ChevronLeft,
  ChevronRight,
  Briefcase,
  GraduationCap,
  Users,
  Book,
  School,
  Lock,
  CheckCircle,
  Languages,
  Calendar,
  Home,
} from "lucide-react";

// Types
import type {
  UserProfile,
  UserImage,
  QuestionnaireResponse,
  FormattedAnswer,
} from "@/types/next-auth";

// Interfaces
interface WorldConfig {
  key: string;
  title: string;
  icon: React.ElementType;
  color: string;
}

interface ProfileCardProps {
  profile: UserProfile;
  images?: UserImage[];
  questionnaire?: QuestionnaireResponse | null;
  viewMode?: "matchmaker" | "candidate";
  className?: string;
  onAction?: (type: string, data?: any) => void;
}

// Constants
const WORLDS: Record<string, WorldConfig> = {
  values: {
    key: "values",
    title: "ערכים ואמונות",
    icon: Heart,
    color: "text-pink-500",
  },
  personality: {
    key: "personality",
    title: "אישיות",
    icon: User,
    color: "text-blue-500",
  },
  relationship: {
    key: "relationship",
    title: "זוגיות ומשפחה",
    icon: Users,
    color: "text-purple-500",
  },
  religion: {
    key: "religion",
    title: "דת ומסורת",
    icon: Book,
    color: "text-indigo-500",
  },
  partner: {
    key: "partner",
    title: "העדפות בן/בת זוג",
    icon: Heart,
    color: "text-red-500",
  },
};

const ProfileCard: React.FC<ProfileCardProps> = ({
  profile,
  images =[],
  questionnaire,
  viewMode = "candidate",
  className,
  onAction,
}) => {
  // State
  const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(
    null
  );
  const [activeTab, setActiveTab] = useState("about");

  // Calculate age from birthDate
  const calculateAge = (birthDate: Date): number => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();

    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birth.getDate())
    ) {
      age--;
    }
    return age;
  };

  // Derived values
  const age = calculateAge(new Date(profile.birthDate));
  const mainImage = images?.find((img) => img.isMain);

  // Image handlers
  const handleImageClick = (index: number) => {
    setSelectedImageIndex(index);
  };

  const handleNextImage = () => {
    if (selectedImageIndex !== null && selectedImageIndex < images.length - 1) {
      setSelectedImageIndex(selectedImageIndex + 1);
    }
  };

  const handlePreviousImage = () => {
    if (selectedImageIndex !== null && selectedImageIndex > 0) {
      setSelectedImageIndex(selectedImageIndex - 1);
    }
  };

  // Sensitive info component
  const SensitiveInfo: React.FC<{ children: React.ReactNode }> = ({
    children,
  }) => {
    if (viewMode !== "matchmaker") return null;

    return (
      <div className="relative border-2 border-yellow-400 rounded-xl p-6 bg-yellow-50/50">
        <div className="flex items-center gap-2 mb-4 text-yellow-700">
          <Lock className="w-5 h-5" />
          <span className="font-medium">מידע לשדכנים בלבד</span>
        </div>
        {children}
      </div>
    );
  };

  return (
    <Card
      className={cn(
        "w-full bg-white shadow-xl rounded-xl overflow-hidden",
        className
      )}
    >
      {/* Header Section */}
      <div className="bg-gradient-to-b from-white to-gray-50 p-6 text-center">
        <div className="space-y-4">
          {/* Name and Basic Info */}
          <div>
            <h2 className="text-3xl font-serif font-semibold text-gray-900">
              {profile?.user?.firstName} {profile?.user?.lastName}
            </h2>
            <p className="text-gray-600 mt-1">
              {age} שנים | {profile.city}
            </p>
          </div>

          {/* Status Badges */}
          <div className="flex flex-wrap gap-2 justify-center">
            {profile.isProfileVisible && (
              <Badge className="bg-green-100 text-green-800">
                פנוי/ה להצעות
              </Badge>
            )}
            {profile.religiousLevel && (
              <Badge variant="secondary">{profile.religiousLevel}</Badge>
            )}
            {profile.maritalStatus && (
              <Badge variant="secondary">{profile.maritalStatus}</Badge>
            )}
          </div>
        </div>
      </div>

      {/* Main Image Section */}
      <div className="relative bg-gradient-to-r from-gray-50 to-white p-6">
        <div className="flex justify-center gap-4">
          {/* Main Large Image */}
          <div
            className="relative w-64 h-80 rounded-xl overflow-hidden bg-gray-100 shadow-lg cursor-pointer"
            onClick={() =>
              mainImage &&
              handleImageClick(
                images.findIndex((img) => img.id === mainImage.id)
              )
            }
          >
            {mainImage ? (
              <Image
                src={mainImage.url}
                alt="תמונת פרופיל ראשית"
                fill
                className="object-cover"
                sizes="256px"
                priority
              />
            ) : (
              <div className="w-full h-full flex items-center justify-center">
                <User className="w-16 h-16 text-gray-400" />
              </div>
            )}
          </div>

          {/* Thumbnail Strip */}
          <div className="flex flex-col gap-2">
            {(images ?? []).slice(1, 4).map((image, index) => (
              <div
                key={image.id}
                className="relative w-20 h-20 rounded-lg overflow-hidden bg-white shadow-sm cursor-pointer 
                                         hover:opacity-90 transition-opacity"
                onClick={() => handleImageClick(index + 1)}
              >
                <Image
                  src={image.url}
                  alt={`תמונת פרופיל ${index + 2}`}
                  fill
                  className="object-cover"
                  sizes="80px"
                />
              </div>
            ))}
          </div>
        </div>
      </div>
      {/* Quick Stats Grid */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-6 bg-gray-50">
        {/* Age */}
        <div className="flex items-center gap-3 p-4 bg-white rounded-lg shadow-sm">
          <Calendar className="w-5 h-5 text-primary" />
          <div>
            <p className="text-sm text-gray-500">גיל</p>
            <p className="font-medium">{age}</p>
          </div>
        </div>

        {/* Marital Status */}
        <div className="flex items-center gap-3 p-4 bg-white rounded-lg shadow-sm">
          <Heart className="w-5 h-5 text-primary" />
          <div>
            <p className="text-sm text-gray-500">מצב משפחתי</p>
            <p className="font-medium">{profile.maritalStatus || "-"}</p>
          </div>
        </div>

        {/* Education */}
        <div className="flex items-center gap-3 p-4 bg-white rounded-lg shadow-sm">
          <School className="w-5 h-5 text-primary" />
          <div>
            <p className="text-sm text-gray-500">השכלה</p>
            <p className="font-medium">{profile.education || "-"}</p>
          </div>
        </div>

        {/* Native Language */}
        <div className="flex items-center gap-3 p-4 bg-white rounded-lg shadow-sm">
          <Languages className="w-5 h-5 text-primary" />
          <div>
            <p className="text-sm text-gray-500">שפת אם</p>
            <p className="font-medium">{profile.nativeLanguage || "-"}</p>
          </div>
        </div>
      </div>

      {/* Main Tabs Navigation */}
      <div className="p-6">
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <ScrollArea className="w-full" dir="rtl">
            <TabsList className="w-full justify-start inline-flex p-1">
              <TabsTrigger value="about" className="flex items-center gap-2">
                <Info className="w-4 h-4" />
                <span>אודות</span>
              </TabsTrigger>

              <TabsTrigger
                value="education"
                className="flex items-center gap-2"
              >
                <GraduationCap className="w-4 h-4" />
                <span>השכלה ותעסוקה</span>
              </TabsTrigger>

              <TabsTrigger value="family" className="flex items-center gap-2">
                <Users className="w-4 h-4" />
                <span>משפחה</span>
              </TabsTrigger>

              <TabsTrigger value="photos" className="flex items-center gap-2">
                <ImageIcon className="w-4 h-4" />
                <span>תמונות</span>
                {images.length > 0 && (
                  <span className="text-xs">({images.length})</span>
                )}
              </TabsTrigger>

              {questionnaire && (
                <TabsTrigger
                  value="questionnaire"
                  className="flex items-center gap-2"
                >
                  <FileText className="w-4 h-4" />
                  <span>שאלון</span>
                </TabsTrigger>
              )}

              {viewMode === "matchmaker" && (
                <TabsTrigger
                  value="sensitive"
                  className="flex items-center gap-2"
                >
                  <Lock className="w-4 h-4" />
                  <span>מידע נוסף</span>
                </TabsTrigger>
              )}
            </TabsList>
          </ScrollArea>

          {/* About Tab */}
          <TabsContent value="about" className="mt-6">
            <div className="space-y-6">
              {/* Basic Description */}
              <div className="bg-gray-50 rounded-xl p-6">
                <h3 className="text-xl font-semibold mb-4 flex items-center gap-2">
                  <User className="w-5 h-5" />
                  אודות
                </h3>
                <p className="text-gray-700 whitespace-pre-wrap">
                  {profile.about || "לא הוזן תיאור"}
                </p>
              </div>

              {/* Hobbies */}
              <div className="bg-gray-50 rounded-xl p-6">
                <h3 className="text-xl font-semibold mb-4 flex items-center gap-2">
                  <Heart className="w-5 h-5" />
                  תחביבים
                </h3>
                <p className="text-gray-700">
                  {profile.hobbies || "לא הוזנו תחביבים"}
                </p>
              </div>

              {/* Languages */}
              <div className="bg-gray-50 rounded-xl p-6">
                <h3 className="text-xl font-semibold mb-4 flex items-center gap-2">
                  <Languages className="w-5 h-5" />
                  שפות
                </h3>
                <div className="space-y-4">
                  {/* Native Language */}
                  <div>
                    <p className="text-sm text-gray-500">שפת אם</p>
                    <p className="font-medium mt-1">
                      {profile.nativeLanguage || "-"}
                    </p>
                  </div>

                  {/* Additional Languages */}
                  {profile.additionalLanguages &&
                    profile.additionalLanguages.length > 0 && (
                      <div>
                        <p className="text-sm text-gray-500">שפות נוספות</p>
                        <div className="flex flex-wrap gap-2 mt-1">
                          {profile.additionalLanguages.map((lang) => (
                            <Badge key={lang} variant="secondary">
                              {lang}
                            </Badge>
                          ))}
                        </div>
                      </div>
                    )}
                </div>
              </div>
            </div>
          </TabsContent>

          {/* Education & Employment Tab */}
          <TabsContent value="education" className="mt-6">
            <div className="bg-gray-50 rounded-xl p-6">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Education */}
                <div className="space-y-4">
                  <h3 className="text-xl font-semibold flex items-center gap-2">
                    <GraduationCap className="w-5 h-5" />
                    השכלה
                  </h3>
                  <div className="p-4 bg-white rounded-lg shadow-sm">
                    <p className="text-sm text-gray-500">רמת השכלה</p>
                    <p className="font-medium mt-1">
                      {profile.education || "-"}
                    </p>
                  </div>
                </div>

                {/* Employment */}
                <div className="space-y-4">
                  <h3 className="text-xl font-semibold flex items-center gap-2">
                    <Briefcase className="w-5 h-5" />
                    תעסוקה
                  </h3>
                  <div className="p-4 bg-white rounded-lg shadow-sm">
                    <p className="text-sm text-gray-500">עיסוק נוכחי</p>
                    <p className="font-medium mt-1">
                      {profile.occupation || "-"}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </TabsContent>

          {/* Family Tab */}
          <TabsContent value="family" className="mt-6">
            <div className="bg-gray-50 rounded-xl p-6">
              <h3 className="text-xl font-semibold mb-6 flex items-center gap-2">
                <Users className="w-5 h-5" />
                מידע משפחתי
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div className="p-4 bg-white rounded-lg shadow-sm">
                  <p className="text-sm text-gray-500">מצב הורים</p>
                  <p className="font-medium mt-1">
                    {profile.parentStatus || "-"}
                  </p>
                </div>

                <div className="p-4 bg-white rounded-lg shadow-sm">
                  <p className="text-sm text-gray-500">מספר אחים/אחיות</p>
                  <p className="font-medium mt-1">{profile.siblings || "-"}</p>
                </div>

                <div className="p-4 bg-white rounded-lg shadow-sm">
                  <p className="text-sm text-gray-500">מיקום במשפחה</p>
                  <p className="font-medium mt-1">{profile.position || "-"}</p>
                </div>
              </div>
            </div>
          </TabsContent>

          {/* Photos Tab */}
          <TabsContent value="photos" className="mt-6">
            <div className="bg-gray-50 rounded-xl p-6">
              <h3 className="text-xl font-semibold mb-6 flex items-center gap-2">
                <ImageIcon className="w-5 h-5" />
                גלריית תמונות
              </h3>
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                {images.map((image, index) => (
                  <div
                    key={image.id}
                    className="relative aspect-square rounded-lg overflow-hidden cursor-pointer group"
                    onClick={() => handleImageClick(index)}
                  >
                    <Image
                      src={image.url}
                      alt={`תמונת פרופיל ${index + 1}`}
                      fill
                      className="object-cover transition-transform group-hover:scale-105"
                      sizes="(max-width: 768px) 50vw, (max-width: 1200px) 33vw, 25vw"
                    />
                    {image.isMain && (
                      <Badge className="absolute top-2 right-2 bg-white/90">
                        ראשי
                      </Badge>
                    )}
                  </div>
                ))}
                {images.length === 0 && (
                  <div className="col-span-full flex flex-col items-center justify-center py-12">
                    <ImageIcon className="w-12 h-12 text-gray-400 mb-2" />
                    <p className="text-gray-500">לא הועלו תמונות</p>
                  </div>
                )}
              </div>
            </div>
          </TabsContent>

          {/* Questionnaire Tab */}
          {questionnaire && (
            <TabsContent value="questionnaire" className="mt-6">
              <div className="bg-gray-50 rounded-xl p-6">
                <div className="space-y-8">
                  {Object.entries(
                    questionnaire.formattedAnswers || {
                      values: [],
                      personality: [],
                      relationship: [],
                      partner: [],
                      religion: [],
                    }
                  ).map(([world, answers]) => {
                    if (answers.length === 0) return null;
                    const worldConfig = WORLDS[world as keyof typeof WORLDS];

                    return (
                      <div key={world} className="space-y-4">
                        <h3 className="text-xl font-semibold flex items-center gap-2">
                          {worldConfig && (
                            <worldConfig.icon
                              className={cn("h-5 w-5", worldConfig.color)}
                            />
                          )}
                          {worldConfig?.title || world}
                        </h3>

                        <div className="grid gap-4">
                          {answers
                            .filter(
                              (answer) =>
                                viewMode === "matchmaker" ||
                                answer.isVisible !== false
                            )
                            .map((answer) => (
                              <div
                                key={answer.questionId}
                                className="bg-white rounded-lg p-4 shadow-sm"
                              >
                                <p className="text-sm text-gray-500 mb-2">
                                  {answer.question}
                                </p>
                                <p className="text-gray-800">
                                  {answer.displayText}
                                </p>
                                <p className="text-xs text-gray-400 mt-2">
                                  {new Date(
                                    answer.answeredAt
                                  ).toLocaleDateString("he-IL")}
                                </p>
                              </div>
                            ))}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </TabsContent>
          )}

          {/* Sensitive Information Tab (Matchmakers Only) */}
          {viewMode === "matchmaker" && (
            <TabsContent value="sensitive" className="mt-6">
              <SensitiveInfo>
                {/* References */}
                {(profile.referenceName1 || profile.referenceName2) && (
                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold text-yellow-900 flex items-center gap-2">
                      <Phone className="w-5 h-5" />
                      ממליצים
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {profile.referenceName1 && (
                        <div className="p-4 bg-white/80 rounded-lg">
                          <h4 className="font-medium mb-2">ממליץ/ה 1</h4>
                          <div className="space-y-2">
                            <p className="flex items-center gap-2">
                              <User className="w-4 h-4 text-yellow-700" />
                              <span>{profile.referenceName1}</span>
                            </p>
                            <p className="flex items-center gap-2">
                              <Phone className="w-4 h-4 text-yellow-700" />
                              <span dir="ltr">{profile.referencePhone1}</span>
                            </p>
                          </div>
                        </div>
                      )}

                      {profile.referenceName2 && (
                        <div className="p-4 bg-white/80 rounded-lg">
                          <h4 className="font-medium mb-2">ממליץ/ה 2</h4>
                          <div className="space-y-2">
                            <p className="flex items-center gap-2">
                              <User className="w-4 h-4 text-yellow-700" />
                              <span>{profile.referenceName2}</span>
                            </p>
                            <p className="flex items-center gap-2">
                              <Phone className="w-4 h-4 text-yellow-700" />
                              <span dir="ltr">{profile.referencePhone2}</span>
                            </p>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {/* Contact Preferences */}
                <div className="mt-6 space-y-4">
                  <h3 className="text-lg font-semibold text-yellow-900 flex items-center gap-2">
                    <User className="w-5 h-5" />
                    העדפות יצירת קשר
                  </h3>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="p-4 bg-white/80 rounded-lg">
                      <p className="text-sm text-yellow-800 mb-1">
                        אופן יצירת קשר מועדף
                      </p>
                      <p>
                        {profile.contactPreference === "direct"
                          ? "ישירות"
                          : profile.contactPreference === "matchmaker"
                          ? "דרך השדכן/ית"
                          : profile.contactPreference === "both"
                          ? "שתי האפשרויות"
                          : "לא צוין"}
                      </p>
                    </div>
                    <div className="p-4 bg-white/80 rounded-lg">
                      <p className="text-sm text-yellow-800 mb-1">
                        העדפת מגדר שדכן/ית
                      </p>
                      <p>
                        {profile.preferredMatchmakerGender === "MALE"
                          ? "שדכן"
                          : profile.preferredMatchmakerGender === "FEMALE"
                          ? "שדכנית"
                          : "לא צוין"}
                      </p>
                    </div>
                  </div>
                </div>

                {/* Matching Notes */}
                {profile.matchingNotes && (
                  <div className="mt-6 space-y-4">
                    <h3 className="text-lg font-semibold text-yellow-900 flex items-center gap-2">
                      <FileText className="w-5 h-5" />
                      הערות לשדכנים
                    </h3>
                    <div className="p-4 bg-white/80 rounded-lg">
                      <p className="whitespace-pre-wrap">
                        {profile.matchingNotes}
                      </p>
                    </div>
                  </div>
                )}
              </SensitiveInfo>
            </TabsContent>
          )}
        </Tabs>
      </div>

      {/* Image Viewer Dialog */}
      {selectedImageIndex !== null && (
        <Dialog
          open={selectedImageIndex !== null}
          onOpenChange={() => setSelectedImageIndex(null)}
        >
          <DialogContent className="max-w-4xl p-4">
            <DialogTitle className="text-center">תצוגת תמונות</DialogTitle>
            <div className="relative h-[500px] w-full">
              <Image
                src={images[selectedImageIndex].url}
                alt={`תמונת פרופיל ${selectedImageIndex + 1}`}
                fill
                className="object-contain"
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 70vw"
                priority
              />

              {/* Navigation Buttons */}
              {selectedImageIndex > 0 && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="absolute left-2 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white"
                  onClick={(e) => {
                    e.stopPropagation();
                    handlePreviousImage();
                  }}
                >
                  <ChevronLeft className="h-6 w-6" />
                </Button>
              )}

              {selectedImageIndex < images.length - 1 && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="absolute right-2 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleNextImage();
                  }}
                >
                  <ChevronRight className="h-6 w-6" />
                </Button>
              )}

              {/* Image Counter */}
              <div className="absolute bottom-4 left-1/2 -translate-x-1/2 bg-white/80 px-3 py-1 rounded-full">
                {selectedImageIndex + 1} / {images.length}
              </div>
            </div>

            {/* Thumbnails */}
            <div className="flex gap-2 mt-4 overflow-x-auto p-2">
              {images.map((image, index) => (
                <div
                  key={image.id}
                  className={cn(
                    "relative w-16 h-16 rounded-lg overflow-hidden cursor-pointer",
                    selectedImageIndex === index && "ring-2 ring-primary"
                  )}
                  onClick={() => setSelectedImageIndex(index)}
                >
                  <Image
                    src={image.url}
                    alt={`תמונה ${index + 1}`}
                    fill
                    className="object-cover"
                    sizes="64px"
                  />
                </div>
              ))}
            </div>
          </DialogContent>
        </Dialog>
      )}
    </Card>
  );
};

export default ProfileCard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\utils.ts:
==================================================
// src/components/shared/profile/utils.ts
import type { UserProfile } from "@/types/next-auth";

export const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const formatProfileData = (profile: UserProfile) => {
  return {
    ...profile,
    age: calculateAge(new Date(profile.birthDate)),
    // Add any other formatting needed
  };
};

export const validateProfileData = (data: Partial<UserProfile>) => {
  const errors: Record<string, string> = {};
  
  // Add validation rules as needed
  if (data.height && (data.height < 100 || data.height > 250)) {
    errors.height = "גובה חייב להיות בין 100 ל-250 ס\"מ";
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\elements\MinimalCard.tsx:
==================================================
// src/components/shared/profile/elements/MinimalCard.tsx
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { User, MapPin, Scroll, Heart } from "lucide-react";
import Image from "next/image";
import { calculateAge } from "../utils";
import type { UserProfile, UserImage } from "@/types/next-auth";

interface MinimalCardProps {
  profile: UserProfile;
  mainImage?: UserImage;
  onClick?: () => void;
  className?: string;
}

const MinimalCard: React.FC<MinimalCardProps> = ({
  profile,
  mainImage,
  onClick,
  className = "",
}) => {
  const age = calculateAge(new Date(profile.birthDate));

  return (
    <Card
      onClick={onClick}
      className={`relative overflow-hidden cursor-pointer hover:shadow-md transition-shadow ${className}`}
    >
      <div className="flex gap-4 p-4">
        {/* תמונת פרופיל */}
        <div className="relative w-24 h-24 rounded-lg overflow-hidden bg-gray-100">
          {mainImage ? (
            <Image
              src={mainImage.url}
              alt="תמונת פרופיל"
              fill
              className="object-cover"
              sizes="96px"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <User className="w-8 h-8 text-gray-400" />
            </div>
          )}
        </div>

        {/* מידע בסיסי */}
        <div className="flex-1 space-y-2">
          <div>
            <h3 className="text-lg font-medium">
              {profile.user.firstName} {profile.user.lastName}
            </h3>
            <p className="text-sm text-gray-500">{age} שנים</p>
          </div>

          <div className="flex flex-wrap gap-2">
            {profile.city && (
              <Badge variant="secondary" className="flex items-center gap-1">
                <MapPin className="w-3 h-3" />
                {profile.city}
              </Badge>
            )}
            {profile.religiousLevel && (
              <Badge variant="secondary" className="flex items-center gap-1">
                <Scroll className="w-3 h-3" />
                {profile.religiousLevel}
              </Badge>
            )}
          </div>

          {/* סטטוס זמינות */}
          <div className="flex items-center gap-2 text-sm">
            {profile.availabilityStatus === "AVAILABLE" ? (
              <Badge variant="success" className="flex items-center gap-1">
                <Heart className="w-3 h-3" />
                פנוי/ה להצעות
              </Badge>
            ) : (
              <Badge variant="secondary" className="flex items-center gap-1">
                <Heart className="w-3 h-3" />
                בתהליך הכרות
              </Badge>
            )}
          </div>
        </div>
      </div>
    </Card>
  );
};

export default MinimalCard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\elements\StatsCard.tsx:
==================================================
import React from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  /**
   * The icon to display in the card
   */
  icon: React.ElementType;

  /**
   * The title text to display
   */
  title: string;

  /**
   * The main value to display
   */
  value: string | number;

  /**
   * Optional progress value (0-100)
   */
  progress?: number;

  /**
   * Optional trend information
   */
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };

  /**
   * Visual variant of the card
   */
  variant?: "default" | "success" | "warning" | "destructive";

  /**
   * Additional CSS classes
   */
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  progress,
  trend,
  variant = "default",
  className,
}) => {
  // Determine variant-specific background color
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "bg-emerald-50 dark:bg-emerald-900/20";
      case "warning":
        return "bg-amber-50 dark:bg-amber-900/20";
      case "destructive":
        return "bg-red-50 dark:bg-red-900/20";
      default:
        return "bg-card";
    }
  };

  // Special handling for availability status
  const isAvailabilityStatus = title === "סטטוס פניות";
  const isAvailable = typeof value === 'string' && value.toLowerCase() === 'available';

  // Render the value with special handling for availability status
  const renderValue = () => {
    if (isAvailabilityStatus) {
      return (
        <div className="mt-1">
          <span className={cn(
            "inline-flex px-3 py-1 rounded-full text-sm font-semibold tracking-wide",
            isAvailable 
              ? "bg-emerald-100 text-emerald-800 dark:bg-emerald-900/30 dark:text-emerald-300"
              : "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
          )}>
            {value}
          </span>
        </div>
      );
    }
    return <h3 className="text-2xl font-semibold">{value}</h3>;
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-shadow",
        getVariantStyles(),
        className
      )}
    >
      <CardContent className="p-6">
        {/* Header Section */}
        <div className="flex items-center space-x-4 rtl:space-x-reverse">
          <div className="p-2 bg-primary/10 rounded-full">
            <Icon className="w-6 h-6 text-primary" />
          </div>
          <div className="flex-1 space-y-1">
            <p className="text-sm text-muted-foreground">{title}</p>
            {renderValue()}
          </div>
        </div>

        {/* Progress Bar Section */}
        {progress !== undefined && (
          <div className="mt-4 space-y-2">
            <Progress 
              value={progress} 
              className="h-2"
              aria-label={`${title} progress: ${progress}%`}
            />
            <p className="text-sm text-muted-foreground text-right">
              {progress}%
            </p>
          </div>
        )}

        {/* Trend Section */}
        {trend && (
          <div className="mt-4 flex items-center">
            <span
              className={cn(
                "text-sm font-medium",
                trend.isPositive ? "text-emerald-600" : "text-red-600"
              )}
            >
              {trend.isPositive ? "+" : "-"}
              {trend.value}%
            </span>
            <span className="text-sm text-muted-foreground mr-2">
              {trend.label}
            </span>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

// Default export
export default StatsCard;

// Named exports for specific use cases
export type { StatsCardProps };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\elements\VisibilityControl.tsx:
==================================================
import React from "react";
import { Eye, EyeOff } from "lucide-react";
import { Switch } from "@/components/ui/switch";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

interface VisibilityControlProps {
  /**
   * Current visibility state
   */
  isVisible: boolean;

  /**
   * Callback when visibility changes
   */
  onChange: (isVisible: boolean) => void;

  /**
   * Optional class name for additional styling
   */
  className?: string;

  /**
   * Optional disabled state
   */
  disabled?: boolean;

  /**
   * Optional custom tooltip text
   */
  tooltipText?: {
    visible?: string;
    hidden?: string;
    action?: string;
  };
}

const VisibilityControl: React.FC<VisibilityControlProps> = ({
  isVisible,
  onChange,
  className,
  disabled = false,
  tooltipText = {
    visible: "תשובה זו גלויה למועמדים",
    hidden: "תשובה זו מוסתרת מהמועמדים",
    action: "לחץ כדי",
  },
}) => {
  return (
    <div
      className={cn(
        "flex items-center gap-2 bg-secondary/20 p-2 rounded-md",
        disabled && "opacity-50 cursor-not-allowed",
        className
      )}
    >
      {/* Icon */}
      {isVisible ? (
        <Eye 
          className="h-4 w-4 text-primary" 
          aria-hidden="true"
        />
      ) : (
        <EyeOff 
          className="h-4 w-4 text-muted-foreground" 
          aria-hidden="true"
        />
      )}

      {/* Switch with Tooltip */}
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="relative">
              <Switch
                checked={isVisible}
                onCheckedChange={onChange}
                disabled={disabled}
                className={cn(
                  "data-[state=checked]:bg-primary",
                  disabled && "cursor-not-allowed"
                )}
                aria-label={`Toggle visibility: currently ${isVisible ? 'visible' : 'hidden'}`}
              />
              {/* Visually hidden text for screen readers */}
              <span className="sr-only">
                {isVisible ? "הסתר תוכן" : "הצג תוכן"}
              </span>
            </div>
          </TooltipTrigger>
          <TooltipContent 
            side="left" 
            className="max-w-[200px]"
            dir="rtl"
          >
            <p>
              {isVisible ? tooltipText.visible : tooltipText.hidden}
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              {tooltipText.action} {isVisible ? "להסתיר" : "להציג"} תשובה זו
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  );
};

// Default export
export default VisibilityControl;

// Named exports for types
export type { VisibilityControlProps };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\sections\ExtendedProfileSection.tsx:
==================================================
import React, { useState, useEffect } from "react";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { ExtendedProfileData } from "@/types/profile-extended";
import { UserProfile } from "@/types/next-auth";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Slider } from "@/components/ui/slider";
import { Pencil, Save, X } from "lucide-react";
import {
  ExtendedUserProfile,
  PersonalityTraits,
  SpiritualProfile,
  FamilyBackground,
} from "@/types/profile-extended";

interface ExtendedProfileSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onSave: (data: Partial<UserProfile>) => void;
}

const ExtendedProfileSection: React.FC<ExtendedProfileSectionProps> = ({
  profile,
  isEditing,
  viewOnly = false,
  setIsEditing,
  onSave,
}) => {
  const [formData, setFormData] = useState<ExtendedProfileData>({});
  const [initialData, setInitialData] = useState<ExtendedProfileData>({});

  useEffect(() => {
    if (profile) {
      setFormData(profile);
      setInitialData(profile);
    }
  }, [profile]);

  const handleChange = (field: keyof ExtendedProfileData, value: any) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleNestedChange = (
    category: keyof ExtendedProfileData,
    field: string,
    value: any
  ) => {
    setFormData((prev) => ({
      ...prev,
      [category]: {
        ...prev[category],
        [field]: value,
      },
    }));
  };

  const handleSave = () => {
    // שמירת הנתונים המורחבים לשרת
    onSave({
      ...profile,
      extendedData: formData,
    });
    setIsEditing(false);
    setInitialData(formData);
  };

  const handleCancel = () => {
    setFormData(initialData);
    setIsEditing(false);
  };

  return (
    <div className="relative min-h-screen bg-background">
      {/* Sticky Header */}
      <div className="sticky top-0 z-50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b">
        <div className="container mx-auto py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold">פרופיל מורחב</h1>
              <p className="text-sm text-muted-foreground">
                פרטים נוספים להתאמה מיטבית
              </p>
            </div>
            {!viewOnly && (
              <div className="flex gap-2">
                {!isEditing ? (
                  <Button
                    variant="outline"
                    onClick={() => setIsEditing(true)}
                    className="shadow-sm hover:shadow-md transition-shadow"
                  >
                    <Pencil className="w-4 h-4 ml-2" />
                    עריכה
                  </Button>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      onClick={handleCancel}
                      className="shadow-sm hover:shadow-md transition-shadow"
                    >
                      <X className="w-4 h-4 ml-2" />
                      ביטול
                    </Button>
                    <Button
                      variant="default"
                      onClick={handleSave}
                      className="shadow-sm hover:shadow-md transition-shadow"
                    >
                      <Save className="w-4 h-4 ml-2" />
                      שמירה
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="container mx-auto py-6 space-y-6">
        {/* תכונות אישיות */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">תכונות אישיות</CardTitle>
            <CardDescription>אפיון אישיותי ודפוסי התנהגות</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <Label>מזג</Label>
                <Select
                  value={formData.personalityTraits?.temperament}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "personalityTraits",
                      "temperament",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר מזג" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="מופנם">מופנם</SelectItem>
                    <SelectItem value="מעורב">מעורב</SelectItem>
                    <SelectItem value="חברותי">חברותי</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>סגנון קבלת החלטות</Label>
                <Select
                  value={formData.personalityTraits?.decisionMaking}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "personalityTraits",
                      "decisionMaking",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר סגנון" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="ספונטני">ספונטני</SelectItem>
                    <SelectItem value="מתוכנן">מתוכנן</SelectItem>
                    <SelectItem value="משולב">משולב</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>התמודדות עם לחץ</Label>
                <Select
                  value={formData.personalityTraits?.stressManagement}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "personalityTraits",
                      "stressManagement",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר סגנון התמודדות" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="רגוע">רגוע</SelectItem>
                    <SelectItem value="לחוץ">לחוץ</SelectItem>
                    <SelectItem value="משתנה">משתנה</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>סגנון תקשורת</Label>
                <Select
                  value={formData.personalityTraits?.communicationStyle}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "personalityTraits",
                      "communicationStyle",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר סגנון תקשורת" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="ישיר">ישיר</SelectItem>
                    <SelectItem value="עקיף">עקיף</SelectItem>
                    <SelectItem value="דיפלומטי">דיפלומטי</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* פרופיל רוחני */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">פרופיל רוחני</CardTitle>
            <CardDescription>השקפת עולם והשתייכות קהילתית</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <Label>נוסח תפילה</Label>
                <Select
                  value={formData.spiritualProfile?.prayerStyle}
                  onValueChange={(value) =>
                    handleNestedChange("spiritualProfile", "prayerStyle", value)
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר נוסח" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="ספרד">ספרד</SelectItem>
                    <SelectItem value="אשכנז">אשכנז</SelectItem>
                    <SelectItem value="תימני">תימני</SelectItem>
                    <SelectItem value="אחר">אחר</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>גישה ללימודי חול</Label>
                <Select
                  value={formData.spiritualProfile?.secularStudiesAttitude}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "spiritualProfile",
                      "secularStudiesAttitude",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר גישה" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="חיובי">חיובי</SelectItem>
                    <SelectItem value="שלילי">שלילי</SelectItem>
                    <SelectItem value="מסויג">מסויג</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>רמת הקפדה בצניעות</Label>
                <Select
                  value={formData.spiritualProfile?.modestyLevel}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "spiritualProfile",
                      "modestyLevel",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר רמת הקפדה" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="מחמיר">מחמיר</SelectItem>
                    <SelectItem value="מקובל">מקובל</SelectItem>
                    <SelectItem value="מודרני">מודרני</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>גישה לחינוך ילדים</Label>
                <Textarea
                  value={
                    formData.spiritualProfile?.childrenEducationApproach || ""
                  }
                  onChange={(e) =>
                    handleNestedChange(
                      "spiritualProfile",
                      "childrenEducationApproach",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="תאר/י את גישתך לחינוך ילדים..."
                />
              </div>
            </div>
          </CardContent>
        </Card>

        {/* רקע משפחתי */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">רקע משפחתי</CardTitle>
            <CardDescription>פרטים על המשפחה והתמיכה המשפחתית</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <Label>רמה רוחנית של ההורים</Label>
                <Input
                  value={formData.familyBackground?.parentsSpiritualLevel || ""}
                  onChange={(e) =>
                    handleNestedChange(
                      "familyBackground",
                      "parentsSpiritualLevel",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                />
              </div>

              <div>
                <Label>עיסוק האב</Label>
                <Input
                  value={
                    formData.familyBackground?.parentsOccupations?.father || ""
                  }
                  onChange={(e) =>
                    handleNestedChange(
                      "familyBackground",
                      "parentsOccupations",
                      {
                        ...formData.familyBackground?.parentsOccupations,
                        father: e.target.value,
                      }
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                />
              </div>

              <div>
                <Label>עיסוק האם</Label>
                <Input
                  value={
                    formData.familyBackground?.parentsOccupations?.mother || ""
                  }
                  onChange={(e) =>
                    handleNestedChange(
                      "familyBackground",
                      "parentsOccupations",
                      {
                        ...formData.familyBackground?.parentsOccupations,
                        mother: e.target.value,
                      }
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                />
              </div>

              <div>
                <Label>דינמיקה משפחתית</Label>
                <Textarea
                  value={formData.familyBackground?.familyDynamics || ""}
                  onChange={(e) =>
                    handleNestedChange(
                      "familyBackground",
                      "familyDynamics",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="תאר/י את היחסים במשפחה..."
                />
              </div>
            </div>
          </CardContent>
        </Card>

        {/* סגנון חיים */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">סגנון חיים</CardTitle>
            <CardDescription>העדפות ושאיפות לעתיד</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <div>
                <Label>שאיפות קריירה</Label>
                <Textarea
                  value={formData.lifestylePreferences?.careerAspiration || ""}
                  onChange={(e) =>
                    handleNestedChange(
                      "lifestylePreferences",
                      "careerAspiration",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="תאר/י את שאיפותיך המקצועיות..."
                />
              </div>

              <div>
                <Label>תכניות לימודים עתידיות</Label>
                <Textarea
                  value={formData.lifestylePreferences?.futureStudyPlans || ""}
                  onChange={(e) =>
                    handleNestedChange(
                      "lifestylePreferences",
                      "futureStudyPlans",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="תאר/י את תכניות הלימוד העתידיות שלך..."
                />
              </div>

              <div>
                <Label>העדפות מגורים</Label>
                <Select
                  value={
                    formData.lifestylePreferences?.livingPreferences?.proximity
                  }
                  onValueChange={(value) =>
                    handleNestedChange(
                      "lifestylePreferences",
                      "livingPreferences",
                      {
                        ...formData.lifestylePreferences?.livingPreferences,
                        proximity: value,
                      }
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר העדפת מגורים" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="קרוב למשפחה">קרוב למשפחה</SelectItem>
                    <SelectItem value="קרוב לקהילה">קרוב לקהילה</SelectItem>
                    <SelectItem value="גמיש">גמיש</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* בריאות ואורח חיים */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">
              בריאות ואורח חיים
            </CardTitle>
            <CardDescription>מידע רפואי והרגלי חיים</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <Label>מצב בריאותי</Label>
                <Textarea
                  value={formData.healthProfile?.generalHealth || ""}
                  onChange={(e) =>
                    handleNestedChange(
                      "healthProfile",
                      "generalHealth",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="תאר/י את מצבך הבריאותי..."
                />
              </div>

              <div>
                <Label>הגבלות תזונתיות</Label>
                <Input
                  value={
                    formData.healthProfile?.dietaryRestrictions?.join(", ") ||
                    ""
                  }
                  onChange={(e) =>
                    handleNestedChange(
                      "healthProfile",
                      "dietaryRestrictions",
                      e.target.value.split(",").map((item) => item.trim())
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="הפרד/י בפסיקים..."
                />
              </div>

              <div>
                <Label>פעילות גופנית</Label>
                <Select
                  value={formData.healthProfile?.physicalActivity}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "healthProfile",
                      "physicalActivity",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר רמת פעילות" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="נמוכה">נמוכה</SelectItem>
                    <SelectItem value="בינונית">בינונית</SelectItem>
                    <SelectItem value="גבוהה">גבוהה</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* ערכים אישיים ומעורבות קהילתית */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">
              ערכים ומעורבות קהילתית
            </CardTitle>
            <CardDescription>ערכים אישיים ותרומה לקהילה</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <div>
                <Label>חשיבות כיבוד הורים (1-5)</Label>
                <Slider
                  value={[formData.personalValues?.parentalRespect || 3]}
                  min={1}
                  max={5}
                  step={1}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "personalValues",
                      "parentalRespect",
                      value[0]
                    )
                  }
                  disabled={!isEditing}
                  className="mt-2"
                />
              </div>

              <div>
                <Label>התנדבות ומעורבות קהילתית</Label>
                <Textarea
                  value={formData.personalValues?.communityInvolvement || ""}
                  onChange={(e) =>
                    handleNestedChange(
                      "personalValues",
                      "communityInvolvement",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="תאר/י את מעורבותך בקהילה..."
                />
              </div>
              <div>
                <Label>תחומי התנדבות מועדפים</Label>
                <Select
                  value={formData.personalValues?.volunteeringPreferences}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "personalValues",
                      "volunteeringPreferences",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר תחום" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="חינוך">חינוך</SelectItem>
                    <SelectItem value="בריאות">בריאות</SelectItem>
                    <SelectItem value="רווחה">רווחה</SelectItem>
                    <SelectItem value="קשישים">קשישים</SelectItem>
                    <SelectItem value="נוער">נוער</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>גישה לניהול כספים</Label>
                <Select
                  value={formData.personalValues?.financialManagement}
                  onValueChange={(value) =>
                    handleNestedChange(
                      "personalValues",
                      "financialManagement",
                      value
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר גישה" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="שמרני">שמרני</SelectItem>
                    <SelectItem value="מאוזן">מאוזן</SelectItem>
                    <SelectItem value="נועז">נועז</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* שאיפות וציפיות */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">שאיפות וציפיות</CardTitle>
            <CardDescription>מטרות אישיות וציפיות לעתיד</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <Label>מטרות לחמש השנים הקרובות</Label>
                <Textarea
                  value={formData.futureGoals?.join("\n") || ""}
                  onChange={(e) =>
                    handleChange("futureGoals", e.target.value.split("\n"))
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="רשום/י כל מטרה בשורה נפרדת..."
                />
              </div>

              <div>
                <Label>ציפיות מהזוגיות</Label>
                <Textarea
                  value={
                    formData.lifestylePreferences?.relationshipExpectations ||
                    ""
                  }
                  onChange={(e) =>
                    handleNestedChange(
                      "lifestylePreferences",
                      "relationshipExpectations",
                      e.target.value
                    )
                  }
                  disabled={!isEditing}
                  className="mt-1"
                  placeholder="תאר/י את ציפיותיך מהזוגיות..."
                />
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default ExtendedProfileSection;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\sections\PhotosSection.tsx:
==================================================
import React, { useRef, useState, useEffect } from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";

// UI Components
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogDescription,
  DialogHeader,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { toast } from "sonner";

// Icons
import {
  Camera,
  Star,
  X,
  Loader2,
  ChevronLeft,
  ChevronRight,
  Upload,
  Trash2,
  AlertCircle,
} from "lucide-react";

// Types
import type { UserImage } from "@/types/next-auth";

interface PhotosSectionProps {
  images: UserImage[];
  isUploading: boolean;
  disabled?: boolean;
  maxImages?: number;
  onUpload: (file: File) => Promise<void>;
  onSetMain: (imageId: string) => Promise<void>;
  onDelete: (imageId: string) => Promise<void>;
}

const PhotosSection: React.FC<PhotosSectionProps> = ({
  images,
  isUploading,
  disabled = false,
  maxImages = 5,
  onUpload,
  onSetMain,
  onDelete,
}) => {
  // Refs
  const fileInputRef = useRef<HTMLInputElement>(null);

  // State
  const [selectedImage, setSelectedImage] = useState<string | null>(null);
  const [showImageViewer, setShowImageViewer] = useState(false);
  const [selectedViewerIndex, setSelectedViewerIndex] = useState<number | null>(
    null
  );
  const [isProcessing, setIsProcessing] = useState(false);
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [imageToDelete, setImageToDelete] = useState<string | null>(null);
  const [lastUploadedIndex, setLastUploadedIndex] = useState<number | null>(
    null
  );

  // Effect to show newly uploaded image
  useEffect(() => {
    if (lastUploadedIndex !== null) {
      setSelectedViewerIndex(lastUploadedIndex);
      setShowImageViewer(true);
      setLastUploadedIndex(null);
    }
  }, [lastUploadedIndex, images]);
  // File handling functions
  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file type
    const validTypes = ["image/jpeg", "image/png", "image/jpg"];
    if (!validTypes.includes(file.type)) {
      toast.error("סוג קובץ לא חוקי. ניתן להעלות רק תמונות מסוג JPG או PNG");
      return;
    }

    // Validate file size (5MB limit)
    const maxSize = 5 * 1024 * 1024; // 5MB in bytes
    if (file.size > maxSize) {
      toast.error("גודל הקובץ חייב להיות קטן מ-5MB");
      return;
    }

    try {
      setIsProcessing(true);
      await onUpload(file);

      // Set index to show the newly uploaded image
      const newIndex = images.length;
      setLastUploadedIndex(newIndex);

      // Set as main if it's the first image
      if (images.length === 0) {
        const uploadedImage = images[0];
        if (uploadedImage) {
          await onSetMain(uploadedImage.id);
        }
      }

      toast.success("התמונה הועלתה בהצלחה");
    } catch (error) {
      console.error("Error uploading image:", error);
      toast.error("שגיאה בהעלאת התמונה");
    } finally {
      setIsProcessing(false);
      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  };

  // Image viewer functions
  const handleImageClick = (index: number) => {
    setSelectedViewerIndex(index);
    setShowImageViewer(true);
  };

  const closeImageViewer = () => {
    setShowImageViewer(false);
    setSelectedViewerIndex(null);
  };

  const handleNextImage = () => {
    if (
      selectedViewerIndex !== null &&
      selectedViewerIndex < images.length - 1
    ) {
      setSelectedViewerIndex(selectedViewerIndex + 1);
    }
  };

  const handlePreviousImage = () => {
    if (selectedViewerIndex !== null && selectedViewerIndex > 0) {
      setSelectedViewerIndex(selectedViewerIndex - 1);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (selectedViewerIndex === null) return;

    switch (e.key) {
      case "ArrowRight":
        handlePreviousImage(); // RTL navigation
        break;
      case "ArrowLeft":
        handleNextImage(); // RTL navigation
        break;
      case "Escape":
        closeImageViewer();
        break;
    }
  };

  // Image actions
  const handleDeleteClick = async (imageId: string) => {
    try {
      // Check if this is the main image and there are other images
      const imageToDelete = images.find((img) => img.id === imageId);
      if (imageToDelete?.isMain && images.length > 1) {
        // Find another image to set as main
        const nextImage = images.find((img) => img.id !== imageId);
        if (nextImage) {
          await onSetMain(nextImage.id);
        }
      }

      await onDelete(imageId);
      setImageToDelete(null);
      closeImageViewer();
      toast.success("התמונה נמחקה בהצלחה");
    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error("שגיאה במחיקת התמונה");
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    try {
      await onSetMain(imageId);
      toast.success("התמונה הראשית עודכנה בהצלחה");
    } catch (error) {
      console.error("Error setting main image:", error);
      toast.error("שגיאה בעדכון התמונה הראשית");
    }
  };

  // Delete confirmation dialog
  const openDeleteConfirm = (imageId: string) => {
    setImageToDelete(imageId);
    setDeleteConfirmOpen(true);
  };

  const closeDeleteConfirm = () => {
    setImageToDelete(null);
    setDeleteConfirmOpen(false);
  };

  const confirmDelete = async () => {
    if (imageToDelete) {
      await handleDeleteClick(imageToDelete);
      closeDeleteConfirm();
    }
  };
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="text-xl font-bold">תמונות פרופיל</CardTitle>
            <CardDescription>
              העלה עד {maxImages} תמונות. תמונה ראשית תוצג בכרטיס הפרופיל.
            </CardDescription>
          </div>
          {!disabled && (
            <Button
              onClick={() => fileInputRef.current?.click()}
              disabled={
                disabled ||
                isUploading ||
                isProcessing ||
                images.length >= maxImages
              }
            >
              {isUploading || isProcessing ? (
                <Loader2 className="w-4 h-4 ml-2 animate-spin" />
              ) : (
                <Camera className="w-4 h-4 ml-2" />
              )}
              העלאת תמונה
            </Button>
          )}
        </div>
      </CardHeader>
      <CardContent>
        {/* Images Grid */}
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {/* Current Images */}
          {images.map((image, index) => (
            <div
              key={image.id}
              className="relative group aspect-square rounded-lg overflow-hidden cursor-pointer bg-gray-100"
              onClick={() => handleImageClick(index)}
            >
              <Image
                src={image.url}
                alt={`תמונת פרופיל ${index + 1}`}
                fill
                className="object-cover transition-transform group-hover:scale-105"
                sizes="(max-width: 768px) 50vw, (max-width: 1200px) 33vw, 25vw"
              />

              {/* Overlay Controls */}
              {!disabled && (
                <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity">
                  <div className="absolute top-2 right-2 flex gap-2">
                    <Button
                      variant="ghost"
                      size="icon"
                      className={cn(
                        "hover:bg-white/20",
                        image.isMain ? "text-yellow-500" : "text-white"
                      )}
                      onClick={(e) => {
                        e.stopPropagation();
                        !image.isMain && handleSetMainImage(image.id);
                      }}
                      disabled={image.isMain}
                      title={image.isMain ? "תמונה ראשית" : "הפוך לתמונה ראשית"}
                    >
                      <Star
                        className={cn(
                          "w-5 h-5",
                          image.isMain && "fill-yellow-500"
                        )}
                      />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="text-white hover:bg-white/20"
                      onClick={(e) => {
                        e.stopPropagation();
                        openDeleteConfirm(image.id);
                      }}
                      title="מחק תמונה"
                    >
                      <Trash2 className="w-5 h-5" />
                    </Button>
                  </div>
                </div>
              )}

              {/* Main Image Badge */}
              {image.isMain && (
                <Badge className="absolute top-2 left-2">ראשי</Badge>
              )}
            </div>
          ))}

          {/* Upload Placeholder */}
          {!disabled && images.length < maxImages && (
            <label className="relative aspect-square rounded-lg border-2 border-dashed border-gray-300 hover:border-primary cursor-pointer transition-colors">
              <input
                type="file"
                ref={fileInputRef}
                className="hidden"
                accept="image/jpeg,image/png,image/jpg"
                onChange={handleFileSelect}
                disabled={disabled || isUploading || isProcessing}
              />
              <div className="absolute inset-0 flex flex-col items-center justify-center">
                <Upload className="w-8 h-8 text-muted-foreground mb-2" />
                <span className="text-sm text-muted-foreground">
                  העלאת תמונה
                </span>
              </div>
            </label>
          )}

          {/* Empty State */}
          {images.length === 0 && (
            <div className="col-span-full text-center py-12 bg-muted/50 rounded-lg">
              <Camera className="w-12 h-12 mx-auto text-muted-foreground" />
              <p className="mt-4 text-muted-foreground">
                לא הועלו תמונות עדיין
              </p>
            </div>
          )}
        </div>

        {/* Delete Confirmation Dialog */}
        <AlertDialog
          open={deleteConfirmOpen}
          onOpenChange={setDeleteConfirmOpen}
        >
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>מחיקת תמונה</AlertDialogTitle>
              <AlertDialogDescription>
                האם את/ה בטוח/ה שברצונך למחוק את התמונה? פעולה זו לא ניתנת
                לביטול.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel onClick={closeDeleteConfirm}>
                ביטול
              </AlertDialogCancel>
              <AlertDialogAction
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                onClick={confirmDelete}
              >
                מחיקה
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {/* Image Viewer Dialog */}
        <Dialog open={showImageViewer} onOpenChange={closeImageViewer}>
          <DialogContent
            className="max-w-7xl h-[90vh] flex items-center justify-center p-0"
            onKeyDown={handleKeyPress}
          >
            <DialogHeader>
              <DialogTitle className="sr-only">תצוגת תמונה</DialogTitle>
              <DialogDescription className="sr-only">
                גלריית תמונות פרופיל
              </DialogDescription>
            </DialogHeader>

            {selectedViewerIndex !== null && images[selectedViewerIndex] && (
              <div className="relative w-full h-full">
                {/* Navigation Buttons */}
                {selectedViewerIndex > 0 && (
                  <Button
                    variant="ghost"
                    size="icon"
                    className="absolute left-4 top-1/2 transform -translate-y-1/2 z-10 bg-black/20 hover:bg-black/40"
                    onClick={(e) => {
                      e.stopPropagation();
                      handlePreviousImage();
                    }}
                  >
                    <ChevronLeft className="w-8 h-8" />
                  </Button>
                )}
                {selectedViewerIndex < images.length - 1 && (
                  <Button
                    variant="ghost"
                    size="icon"
                    className="absolute right-4 top-1/2 transform -translate-y-1/2 z-10 bg-black/20 hover:bg-black/40"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleNextImage();
                    }}
                  >
                    <ChevronRight className="w-8 h-8" />
                  </Button>
                )}

                {/* Main Image */}
                <div className="relative w-full h-full">
                  <Image
                    src={images[selectedViewerIndex].url}
                    alt={`תמונת פרופיל ${selectedViewerIndex + 1}`}
                    fill
                    className="object-contain"
                    sizes="(max-width: 2048px) 90vw, 85vw"
                    priority
                  />
                </div>

                {/* Image Counter */}
                <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/60 text-white px-3 py-1 rounded-full">
                  {selectedViewerIndex + 1} / {images.length}
                </div>
              </div>
            )}
          </DialogContent>
        </Dialog>
      </CardContent>
    </Card>
  );
};

export default PhotosSection;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\sections\PreferencesSection.tsx:
==================================================
// src/app/(authenticated)/profile/components/dashboard/PreferencesSection.tsx
import React, { useState, useEffect } from "react";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Settings, MapPin, Users, Book, Pencil, Save, X } from "lucide-react";
import { UserProfile, ContactPreference } from "@/types/next-auth";

interface PreferencesSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onChange: (data: Partial<UserProfile>) => void;
}

const PreferencesSection: React.FC<PreferencesSectionProps> = ({
  profile,
  isEditing,
  viewOnly = false,
  setIsEditing,
  onChange,
}) => {
  const [formData, setFormData] = useState<Partial<UserProfile>>({});
  const [initialData, setInitialData] = useState<Partial<UserProfile>>({});

  // Effect for handling initial data and profile updates
  useEffect(() => {
    if (profile) {
      // Helper function to convert null to undefined
      const nullToUndefined = <T,>(value: T | null): T | undefined =>
        value === null ? undefined : value;

      const newFormData: Partial<UserProfile> = {
        ...profile,
        // Handle numeric fields - explicitly convert null to undefined
        preferredAgeMin: nullToUndefined(profile.preferredAgeMin),
        preferredAgeMax: nullToUndefined(profile.preferredAgeMax),
        preferredHeightMin: nullToUndefined(profile.preferredHeightMin),
        preferredHeightMax: nullToUndefined(profile.preferredHeightMax),
        height: nullToUndefined(profile.height),

        // Handle reference fields
        referenceName1: profile.referenceName1 ?? "",
        referencePhone1: profile.referencePhone1 ?? "",
        referenceName2: profile.referenceName2 ?? "",
        referencePhone2: profile.referencePhone2 ?? "",

        // Handle array fields with empty array defaults
        preferredLocations: profile.preferredLocations ?? [],
        preferredReligiousLevels: profile.preferredReligiousLevels ?? [],
        preferredEducation: profile.preferredEducation ?? [],
        preferredOccupations: profile.preferredOccupations ?? [],

        // Handle other optional fields
        matchingNotes: profile.matchingNotes ?? "",
        contactPreference: profile.contactPreference ?? undefined,
        education: profile.education ?? "",
        occupation: profile.occupation ?? "",
      };

      console.log("Initialized form data:", newFormData);
      setFormData(newFormData);
      setInitialData(newFormData);
    }
  }, [profile]);

  // Debug current form data
  useEffect(() => {
    console.log("Current form data:", formData);
  }, [formData]);

  // Effect for handling edit mode changes
  useEffect(() => {
    if (!isEditing) {
      // When exiting edit mode, reset form data to initial data
      setFormData(initialData);
    }
  }, [isEditing, initialData]);

  const handleChange = <K extends keyof UserProfile>(
    field: K,
    value: UserProfile[K] | undefined
  ) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value !== undefined && value !== null ? value : prev[field],
    }));
  };

  const handleSave = () => {
    onChange(formData);
    setIsEditing(false);
    setInitialData(formData);
  };

  const handleCancel = () => {
    setFormData(initialData);
    setIsEditing(false);
  };

  return (
    <div className="relative min-h-screen bg-background">
      {/* Sticky Header */}
      <div className="sticky top-0 z-50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b">
        <div className="container mx-auto py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold">העדפות שידוך</h1>
              <p className="text-sm text-muted-foreground">
                נהל את העדפות השידוך שלך
              </p>
            </div>
            {!viewOnly && (
              <div className="flex gap-2">
                {!isEditing ? (
                  <Button
                    variant="outline"
                    onClick={() => setIsEditing(true)}
                    className="shadow-sm hover:shadow-md transition-shadow"
                  >
                    <Pencil className="w-4 h-4 ml-2" />
                    עריכה
                  </Button>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      onClick={handleCancel}
                      className="shadow-sm hover:shadow-md transition-shadow"
                    >
                      <X className="w-4 h-4 ml-2" />
                      ביטול
                    </Button>
                    <Button
                      variant="default"
                      onClick={handleSave}
                      className="shadow-sm hover:shadow-md transition-shadow"
                    >
                      <Save className="w-4 h-4 ml-2" />
                      שמירה
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="container mx-auto py-6 space-y-6">
        {/* Additional Preferences */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">תיאור כללי</CardTitle>
            <CardDescription>
              כתיבה זורמת על הבן זוג/בת זוג הרצוי/ה
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <div>
                <Label>תיאור</Label>
                {isEditing ? (
                  <Textarea
                    value={formData.matchingNotes || ""}
                    onChange={(e) =>
                      handleChange("matchingNotes", e.target.value)
                    }
                    placeholder="הוסף/י הערות והעדפות ..."
                    className="mt-2"
                  />
                ) : (
                  <p className="mt-2 whitespace-pre-wrap">
                    {formData.matchingNotes || "אין הערות "}
                  </p>
                )}
              </div>

              <div>
                <Label>אופן יצירת קשר מועדף</Label>
                {isEditing ? (
                  <Select
                    value={formData.contactPreference || undefined}
                    onValueChange={(value: string) => {
                      if (
                        value === "direct" ||
                        value === "matchmaker" ||
                        value === "both"
                      ) {
                        handleChange(
                          "contactPreference",
                          value as ContactPreference
                        );
                      }
                    }}
                  >
                    <SelectTrigger className="mt-2">
                      <SelectValue placeholder="בחר אפשרות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="direct">ישירות</SelectItem>
                      <SelectItem value="matchmaker">דרך השדכן/ית</SelectItem>
                      <SelectItem value="both">שתי האפשרויות</SelectItem>
                    </SelectContent>
                  </Select>
                ) : (
                  <p className="mt-2">
                    {(() => {
                      switch (formData.contactPreference) {
                        case "direct":
                          return "ישירות";
                        case "matchmaker":
                          return "דרך השדכן/ית";
                        case "both":
                          return "שתי האפשרויות";
                        default:
                          return "לא צוין אופן יצירת קשר מועדף";
                      }
                    })()}
                  </p>
                )}
              </div>
            </div>
          </CardContent>
        </Card>
        {/* Age & Height Preferences */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">
              העדפות גיל וגובה
            </CardTitle>
            <CardDescription>הגדר/י טווחי גיל וגובה מועדפים</CardDescription>
          </CardHeader>
          <CardContent>
            <div
              className="grid grid-cols-1 md:grid-cols-2 gap-6 grid-flow-col-dense"
              dir="rtl"
            >
              <div className="space-y-4">
                <Label>טווח גילאים</Label>
                <div className="flex gap-4">
                  <div>
                    <Input
                      type="number"
                      placeholder="מ-"
                      value={formData.preferredAgeMin || ""}
                      onChange={(e) =>
                        handleChange(
                          "preferredAgeMin",
                          parseInt(e.target.value)
                        )
                      }
                      disabled={!isEditing}
                    />
                    <span className="text-sm text-muted-foreground">
                      מינימום
                    </span>
                  </div>
                  <div>
                    <Input
                      type="number"
                      placeholder="עד-"
                      value={formData.preferredAgeMax || ""}
                      onChange={(e) =>
                        handleChange(
                          "preferredAgeMax",
                          parseInt(e.target.value)
                        )
                      }
                      disabled={!isEditing}
                    />
                    <span className="text-sm text-muted-foreground">
                      מקסימום
                    </span>
                  </div>
                </div>
              </div>

              <div className="space-y-4">
                <Label>טווח גבהים (בס"מ)</Label>
                <div className="flex gap-4">
                  <div>
                    <Input
                      type="number"
                      placeholder="מ-"
                      value={formData.preferredHeightMin || ""}
                      onChange={(e) =>
                        handleChange(
                          "preferredHeightMin",
                          parseInt(e.target.value)
                        )
                      }
                      disabled={!isEditing}
                    />
                    <span className="text-sm text-muted-foreground">
                      מינימום
                    </span>
                  </div>
                  <div>
                    <Input
                      type="number"
                      placeholder="עד-"
                      value={formData.preferredHeightMax || ""}
                      onChange={(e) =>
                        handleChange(
                          "preferredHeightMax",
                          parseInt(e.target.value)
                        )
                      }
                      disabled={!isEditing}
                    />
                    <span className="text-sm text-muted-foreground">
                      מקסימום
                    </span>
                  </div>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Location & Religious Preferences */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">
              העדפות מיקום ודת
            </CardTitle>
            <CardDescription>הגדר/י העדפות מיקום ורמת דתיות</CardDescription>
          </CardHeader>
          <CardContent>
            <div
              className="grid grid-cols-1 md:grid-cols-2 gap-6 grid-flow-col-dense"
              dir="rtl"
            >
              <div className="space-y-4">
                <Label>אזורי מגורים מועדפים</Label>
                {isEditing ? (
                  <div className="flex flex-wrap gap-2">
                    {["צפון", "מרכז", "דרום", "ירושלים", "יהודה ושומרון"].map(
                      (location) => (
                        <Button
                          key={location}
                          variant={
                            formData.preferredLocations?.includes(location)
                              ? "default"
                              : "outline"
                          }
                          onClick={() => {
                            const locations = formData.preferredLocations || [];
                            const newLocations = locations.includes(location)
                              ? locations.filter((l) => l !== location)
                              : [...locations, location];
                            handleChange("preferredLocations", newLocations);
                          }}
                          className="min-w-[100px]"
                        >
                          {location}
                        </Button>
                      )
                    )}
                  </div>
                ) : (
                  <div className="flex flex-wrap gap-2">
                    {formData.preferredLocations?.map((location) => (
                      <Badge key={location} variant="secondary">
                        {location}
                      </Badge>
                    )) || "לא צוינו אזורים מועדפים"}
                  </div>
                )}
              </div>

              <div className="space-y-4">
                <Label>רמות דתיות מועדפות</Label>
                {isEditing ? (
                  <div className="flex flex-wrap gap-2">
                    {["חרדי", "חרדי מודרני", "דתי", "דתי-לייט", "מסורתי"].map(
                      (level) => (
                        <Button
                          key={level}
                          variant={
                            formData.preferredReligiousLevels?.includes(level)
                              ? "default"
                              : "outline"
                          }
                          onClick={() => {
                            const levels =
                              formData.preferredReligiousLevels || [];
                            const newLevels = levels.includes(level)
                              ? levels.filter((l) => l !== level)
                              : [...levels, level];
                            handleChange("preferredReligiousLevels", newLevels);
                          }}
                          className="min-w-[100px]"
                        >
                          {level}
                        </Button>
                      )
                    )}
                  </div>
                ) : (
                  <div className="flex flex-wrap gap-2">
                    {formData.preferredReligiousLevels?.map((level) => (
                      <Badge key={level} variant="secondary">
                        {level}
                      </Badge>
                    )) || "לא צוינו רמות דתיות מועדפות"}
                  </div>
                )}
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Education & Occupation */}
        <Card>
          <CardHeader>
            <CardTitle className="text-xl font-bold">השכלה ותעסוקה</CardTitle>
            <CardDescription>העדפות בתחום ההשכלה והתעסוקה</CardDescription>
          </CardHeader>
          <CardContent>
            <div
              className="grid grid-cols-1 md:grid-cols-2 gap-6 grid-flow-col-dense"
              dir="rtl"
            >
              <div className="space-y-4">
                <Label>רמות השכלה מועדפות</Label>
                {isEditing ? (
                  <div className="flex flex-wrap gap-2">
                    {["תיכונית", "על תיכונית", "אקדמית", "תורנית"].map(
                      (education) => (
                        <Button
                          key={education}
                          variant={
                            formData.preferredEducation?.includes(education)
                              ? "default"
                              : "outline"
                          }
                          onClick={() => {
                            const educations =
                              formData.preferredEducation || [];
                            const newEducations = educations.includes(education)
                              ? educations.filter((e) => e !== education)
                              : [...educations, education];
                            handleChange("preferredEducation", newEducations);
                          }}
                          className="min-w-[100px]"
                        >
                          {education}
                        </Button>
                      )
                    )}
                  </div>
                ) : (
                  <div className="flex flex-wrap gap-2">
                    {formData.preferredEducation?.map((education) => (
                      <Badge key={education} variant="secondary">
                        {education}
                      </Badge>
                    )) || "לא צוינו רמות השכלה מועדפות"}
                  </div>
                )}
              </div>

              <div className="space-y-4">
                <Label>תחומי עיסוק מועדפים</Label>
                {isEditing ? (
                  <div className="flex flex-wrap gap-2">
                    {["עובד/ת", "סטודנט/ית", "אברך/אברכית", "עצמאי/ת"].map(
                      (occupation) => (
                        <Button
                          key={occupation}
                          variant={
                            formData.preferredOccupations?.includes(occupation)
                              ? "default"
                              : "outline"
                          }
                          onClick={() => {
                            const occupations =
                              formData.preferredOccupations || [];
                            const newOccupations = occupations.includes(
                              occupation
                            )
                              ? occupations.filter((o) => o !== occupation)
                              : [...occupations, occupation];
                            handleChange(
                              "preferredOccupations",
                              newOccupations
                            );
                          }}
                          className="min-w-[100px]"
                        >
                          {occupation}
                        </Button>
                      )
                    )}
                  </div>
                ) : (
                  <div className="flex flex-wrap gap-2">
                    {formData.preferredOccupations?.map((occupation) => (
                      <Badge key={occupation} variant="secondary">
                        {occupation}
                      </Badge>
                    )) || "לא צוינו תחומי עיסוק מועדפים"}
                  </div>
                )}
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default PreferencesSection;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\sections\ProfileSection.tsx:
==================================================
import React, { useState, useEffect } from "react";
import { Gender, AvailabilityStatus } from "@prisma/client";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Pencil, Save, X } from "lucide-react";
import { UserProfile } from "@/types/next-auth";
import { MultiSelect } from "@/components/ui/multi-select";
const languageOptions = [
  // שפות נפוצות
  { value: "hebrew", label: "עברית" },
  { value: "english", label: "אנגלית" },
  { value: "yiddish", label: "יידיש" },
  { value: "russian", label: "רוסית" },
  { value: "arabic", label: "ערבית" },
  { value: "french", label: "צרפתית" },
  // שאר השפות לפי א-ב
  { value: "amharic", label: "אמהרית" },
  { value: "italian", label: "איטלקית" },
  { value: "ukrainian", label: "אוקראינית" },
  { value: "spanish", label: "ספרדית" },
  { value: "portuguese", label: "פורטוגזית" },
  { value: "persian", label: "פרסית" },
  { value: "polish", label: "פולנית" },
  { value: "chinese", label: "סינית" },
  { value: "german", label: "גרמנית" },
  { value: "georgian", label: "גאורגית" },
  { value: "dutch", label: "הולנדית" },
  { value: "hungarian", label: "הונגרית" },
  { value: "turkish", label: "טורקית" },
  { value: "ladino", label: "לדינו" },
  { value: "romanian", label: "רומנית" },
];
interface ProfileSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  setIsEditing: (value: boolean) => void;
  viewOnly?: boolean;
  onSave: (data: Partial<UserProfile>) => void;
}

const ProfileSection: React.FC<ProfileSectionProps> = ({
  profile,
  isEditing,
  setIsEditing,
  viewOnly = false,
  onSave,
}) => {
  const [formData, setFormData] = useState<Partial<UserProfile>>({});
  const [loading, setLoading] = useState(true);
  const [initialData, setInitialData] = useState<Partial<UserProfile>>({});

  const fetchProfile = async () => {
    try {
      const response = await fetch("/api/profile");
      const data = await response.json();
      if (data.success && data.profile) {
        // Initialize all fields with data from database
        const profileData = {
          // Ensure all fields are initialized, even if null/undefined
          gender: data.profile.gender || "",
          birthDate: data.profile.birthDate || null,
          nativeLanguage: data.profile.nativeLanguage || "",
          additionalLanguages: data.profile.additionalLanguages || [],
          height: data.profile.height || null,
          maritalStatus: data.profile.maritalStatus || "",
          occupation: data.profile.occupation || "",
          education: data.profile.education || "",
          religiousLevel: data.profile.religiousLevel || "",
          address: data.profile.address || "",
          city: data.profile.city || "",
          origin: data.profile.origin || "",
          parentStatus: data.profile.parentStatus || "",
          siblings: data.profile.siblings || null,
          position: data.profile.position || null,
          referenceName1: data.profile.referenceName1 || "",
          referencePhone1: data.profile.referencePhone1 || "",
          referenceName2: data.profile.referenceName2 || "",
          referencePhone2: data.profile.referencePhone2 || "",
          isProfileVisible: data.profile.isProfileVisible || false,
          preferredMatchmakerGender:
            data.profile.preferredMatchmakerGender || "",
          availabilityStatus: data.profile.availabilityStatus || "AVAILABLE",
          availabilityNote: data.profile.availabilityNote || "",
          about: data.profile.about || "",
          hobbies: data.profile.hobbies || "",
          ...data.profile, // Include any additional fields from the database
        };

        setFormData(profileData);
        setInitialData(profileData);
      }
    } catch (error) {
      console.error("Failed to fetch profile:", error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Load initial data from database
    fetchProfile();
  }, []);

  // When profile prop changes or after initial fetch
  useEffect(() => {
    if (profile) {
      const mergedData = {
        ...formData, // Keep existing form data
        ...profile, // Override with profile data
        // Explicitly set all possible fields if they exist in either source
        gender: profile.gender || formData.gender,
        birthDate: profile.birthDate || formData.birthDate,
        nativeLanguage: profile.nativeLanguage || formData.nativeLanguage,
        additionalLanguages:
          profile.additionalLanguages || formData.additionalLanguages,
        height: profile.height || formData.height,
        maritalStatus: profile.maritalStatus || formData.maritalStatus,
        occupation: profile.occupation || formData.occupation,
        education: profile.education || formData.education,
        religiousLevel: profile.religiousLevel || formData.religiousLevel,
        address: profile.address || formData.address,
        city: profile.city || formData.city,
        origin: profile.origin || formData.origin,
        // Family information
        parentStatus: profile.parentStatus || formData.parentStatus,
        siblings: profile.siblings || formData.siblings,
        position: profile.position || formData.position,
        // References
        referenceName1: profile.referenceName1 || formData.referenceName1,
        referencePhone1: profile.referencePhone1 || formData.referencePhone1,
        referenceName2: profile.referenceName2 || formData.referenceName2,
        referencePhone2: profile.referencePhone2 || formData.referencePhone2,
        // Profile settings
        isProfileVisible: profile.isProfileVisible ?? formData.isProfileVisible,
        preferredMatchmakerGender:
          profile.preferredMatchmakerGender ||
          formData.preferredMatchmakerGender,
        availabilityStatus:
          profile.availabilityStatus || formData.availabilityStatus,
        availabilityNote: profile.availabilityNote || formData.availabilityNote,
        about: profile.about || formData.about,
        hobbies: profile.hobbies || formData.hobbies,
      };

      setFormData(mergedData);
      setInitialData(mergedData);
    }
  }, [profile]);

  const handleChange = (field: keyof UserProfile, value: any) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSave = () => {
    onSave(formData);
    setIsEditing(false);
    setInitialData(formData); // Update initialData after saving
  };

  const handleCancel = () => {
    setFormData((prev) => ({
      ...initialData,
      ...profile,
    }));
    setIsEditing(false);
  };

  if (loading) {
    return <div className="text-center p-4">טוען...</div>;
  }

  return (
    <div className="relative min-h-screen bg-background">
      {/* Sticky Header */}
      <div className="sticky top-0 z-50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b">
        <div className="container mx-auto py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold">פרופיל משתמש</h1>
              <p className="text-sm text-muted-foreground">
                נהל את פרטי הפרופיל שלך
              </p>
            </div>
            {!viewOnly && (
              <div className="flex gap-2">
                {!isEditing ? (
                  <Button
                    variant="outline"
                    onClick={() => setIsEditing(true)}
                    className="shadow-sm hover:shadow-md transition-shadow"
                  >
                    <Pencil className="w-4 h-4 ml-2" />
                    עריכה
                  </Button>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      onClick={handleCancel}
                      className="shadow-sm hover:shadow-md transition-shadow"
                    >
                      <X className="w-4 h-4 ml-2" />
                      ביטול
                    </Button>
                    <Button
                      variant="default"
                      onClick={handleSave}
                      className="shadow-sm hover:shadow-md transition-shadow"
                    >
                      <Save className="w-4 h-4 ml-2" />
                      שמירה
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="container mx-auto py-6 space-y-6">
        {/* כרטיס פרטים אישיים */}
        <Card className="shadow-sm">
          <CardHeader>
            <CardTitle className="text-xl font-bold">פרטים אישיים</CardTitle>
            <CardDescription>מידע בסיסי על המועמד</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {/* שדות קיימים */}
              <div>
                <Label>מגדר</Label>
                <Select
                  value={formData.gender || ""}
                  onValueChange={(value) =>
                    handleChange("gender", value as Gender)
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר מגדר" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="MALE">זכר</SelectItem>
                    <SelectItem value="FEMALE">נקבה</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>תאריך לידה</Label>
                <Input
                  type="date"
                  value={
                    formData.birthDate
                      ? new Date(formData.birthDate).toISOString().split("T")[0]
                      : ""
                  }
                  onChange={(e) =>
                    handleChange("birthDate", new Date(e.target.value))
                  }
                  disabled={!isEditing}
                  className="mt-1"
                />
              </div>
              <div>
                <Label>שפת אם</Label>
                <Select
                  value={formData.nativeLanguage || ""}
                  onValueChange={(value) =>
                    handleChange("nativeLanguage", value)
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר שפת אם" />
                  </SelectTrigger>
                  <SelectContent className="max-h-[300px]">
                    <div className="sticky top-0 p-2 bg-white border-b">
                      <Input placeholder="חפש שפה..." className="w-full" />
                    </div>
                    {languageOptions.map((lang) => (
                      <SelectItem key={lang.value} value={lang.value}>
                        {lang.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>שפות נוספות</Label>
                <Select
                  value={formData.additionalLanguages?.[0] || ""} // נשים רק את הערך הראשון בתור הערך המוצג
                  onValueChange={(value) => {
                    const currentLanguages = formData.additionalLanguages || [];
                    let newLanguages;

                    if (currentLanguages.includes(value)) {
                      // אם השפה כבר נבחרה - נסיר אותה
                      newLanguages = currentLanguages.filter(
                        (lang) => lang !== value
                      );
                    } else {
                      // אם השפה חדשה - נוסיף אותה
                      newLanguages = [...currentLanguages, value];
                    }

                    handleChange("additionalLanguages", newLanguages);
                  }}
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר שפות נוספות" />
                  </SelectTrigger>
                  <SelectContent className="max-h-[300px] overflow-y-auto">
                    {languageOptions.map((lang) => (
                      <SelectItem
                        key={lang.value}
                        value={lang.value}
                        className={
                          formData.additionalLanguages?.includes(lang.value)
                            ? "bg-gray-100"
                            : ""
                        }
                      >
                        {lang.label}
                        {formData.additionalLanguages?.includes(lang.value) &&
                          " ✓"}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {/* תצוגת השפות שנבחרו */}
                <div className="mt-2 flex flex-wrap gap-2">
                  {(formData.additionalLanguages || []).map((langValue) => {
                    const lang = languageOptions.find(
                      (l) => l.value === langValue
                    );
                    return lang ? (
                      <span
                        key={lang.value}
                        className="bg-gray-100 px-2 py-1 rounded-md text-sm"
                      >
                        {lang.label}
                        {!isEditing ? null : (
                          <button
                            onClick={() => {
                              const newLanguages =
                                formData.additionalLanguages?.filter(
                                  (l) => l !== langValue
                                ) || [];
                              handleChange("additionalLanguages", newLanguages);
                            }}
                            className="ml-2 text-gray-500 hover:text-gray-700"
                          >
                            ×
                          </button>
                        )}
                      </span>
                    ) : null;
                  })}
                </div>
              </div>
              <div>
                <Label>גובה</Label>
                <Input
                  type="number"
                  value={formData.height || ""}
                  onChange={(e) =>
                    handleChange("height", parseInt(e.target.value))
                  }
                  disabled={!isEditing}
                  className="mt-1"
                />
              </div>

              <div>
                <Label>מצב משפחתי</Label>
                <Select
                  value={formData.maritalStatus || ""}
                  onValueChange={(value) =>
                    handleChange("maritalStatus", value)
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר מצב משפחתי" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="single">רווק/ה</SelectItem>
                    <SelectItem value="divorced">גרוש/ה</SelectItem>
                    <SelectItem value="widowed">אלמן/ה</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              {/* שדות חדשים - מידע אישי */}
              <div>
                <Label>תעסוקה</Label>
                <Input
                  value={formData.occupation || ""}
                  onChange={(e) => handleChange("occupation", e.target.value)}
                  disabled={!isEditing}
                  placeholder="תעסוקה נוכחית"
                  className="mt-1"
                />
              </div>

              <div>
                <Label>השכלה</Label>
                <Input
                  value={formData.education || ""}
                  onChange={(e) => handleChange("education", e.target.value)}
                  disabled={!isEditing}
                  placeholder="השכלה"
                  className="mt-1"
                />
              </div>

              <div>
                <Label>רמת דתיות</Label>
                <Select
                  value={formData.religiousLevel || ""}
                  onValueChange={(value) =>
                    handleChange("religiousLevel", value)
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר רמת דתיות" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="חרדי">חרדי</SelectItem>
                    <SelectItem value="חרדי מודרני">חרדי מודרני</SelectItem>
                    <SelectItem value="דתי">דתי</SelectItem>
                    <SelectItem value="דתי-לייט">דתי-לייט</SelectItem>
                    <SelectItem value="מסורתי">מסורתי</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              {/* כתובת ומיקום */}
              <div>
                <Label>כתובת</Label>
                <Input
                  value={formData.address || ""}
                  onChange={(e) => handleChange("address", e.target.value)}
                  disabled={!isEditing}
                  placeholder="כתובת מגורים"
                  className="mt-1"
                />
              </div>

              <div>
                <Label>עיר</Label>
                <Input
                  value={formData.city || ""}
                  onChange={(e) => handleChange("city", e.target.value)}
                  disabled={!isEditing}
                  placeholder="עיר מגורים"
                  className="mt-1"
                />
              </div>

              <div>
                <Label>מוצא</Label>
                <Input
                  value={formData.origin || ""}
                  onChange={(e) => handleChange("origin", e.target.value)}
                  disabled={!isEditing}
                  placeholder="ארץ מוצא / עדה"
                  className="mt-1"
                />
              </div>
            </div>
          </CardContent>
        </Card>

        {/* כרטיס מידע משפחתי */}
        <Card className="shadow-sm">
          <CardHeader>
            <CardTitle className="text-xl font-bold">מידע משפחתי</CardTitle>
            <CardDescription>פרטים על המשפחה והרקע</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              <div>
                <Label>מצב משפחתי של ההורים</Label>
                <Select
                  value={formData.parentStatus || ""}
                  onValueChange={(value) => handleChange("parentStatus", value)}
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר מצב" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="נשואים">נשואים</SelectItem>
                    <SelectItem value="גרושים">גרושים</SelectItem>
                    <SelectItem value="אלמן">אלמן</SelectItem>
                    <SelectItem value="אלמנה">אלמנה</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>מספר אחים ואחיות</Label>
                <Input
                  type="number"
                  value={formData.siblings || ""}
                  onChange={(e) =>
                    handleChange("siblings", parseInt(e.target.value))
                  }
                  disabled={!isEditing}
                  className="mt-1"
                />
              </div>

              <div>
                <Label>מיקום בין האחים</Label>
                <Input
                  type="number"
                  value={formData.position || ""}
                  onChange={(e) =>
                    handleChange("position", parseInt(e.target.value))
                  }
                  disabled={!isEditing}
                  className="mt-1"
                />
              </div>
            </div>
          </CardContent>
        </Card>

        {/* כרטיס ממליצים */}
        <Card className="shadow-sm">
          <CardHeader>
            <CardTitle className="text-xl font-bold">ממליצים</CardTitle>
            <CardDescription>פרטי קשר של ממליצים</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* ממליץ ראשון */}
              <div className="space-y-4">
                <div>
                  <Label>שם ממליץ/ה 1</Label>
                  <Input
                    value={formData.referenceName1 || ""}
                    onChange={(e) =>
                      handleChange("referenceName1", e.target.value)
                    }
                    disabled={!isEditing}
                    placeholder="שם מלא"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label>טלפון ממליץ/ה 1</Label>
                  <Input
                    value={formData.referencePhone1 || ""}
                    onChange={(e) =>
                      handleChange("referencePhone1", e.target.value)
                    }
                    disabled={!isEditing}
                    placeholder="מספר טלפון"
                    className="mt-1"
                  />
                </div>
              </div>

              {/* ממליץ שני */}
              <div className="space-y-4">
                <div>
                  <Label>שם ממליץ/ה 2</Label>
                  <Input
                    value={formData.referenceName2 || ""}
                    onChange={(e) =>
                      handleChange("referenceName2", e.target.value)
                    }
                    disabled={!isEditing}
                    placeholder="שם מלא"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label>טלפון ממליץ/ה 2</Label>
                  <Input
                    value={formData.referencePhone2 || ""}
                    onChange={(e) =>
                      handleChange("referencePhone2", e.target.value)
                    }
                    disabled={!isEditing}
                    placeholder="מספר טלפון"
                    className="mt-1"
                  />
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* כרטיס הגדרות פרופיל */}
        <Card className="shadow-sm">
          <CardHeader>
            <CardTitle className="text-xl font-bold">הגדרות פרופיל</CardTitle>
            <CardDescription>הגדרות פרטיות וזמינות</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <div className="flex items-center justify-between">
                <div>
                  <Label>הצג פרופיל למשדכים</Label>
                  <p className="text-sm text-muted-foreground">
                    האם לאפשר למשדכים לצפות בפרופיל שלך
                  </p>
                </div>
                <Switch
                  checked={formData.isProfileVisible || false}
                  onCheckedChange={(checked) =>
                    handleChange("isProfileVisible", checked)
                  }
                  disabled={!isEditing}
                />
              </div>

              <div>
                <Label>מגדר מועדף למשדכ/ת</Label>
                <Select
                  value={formData.preferredMatchmakerGender || ""}
                  onValueChange={(value) =>
                    handleChange("preferredMatchmakerGender", value as Gender)
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר העדפה" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="MALE">משדך</SelectItem>
                    <SelectItem value="FEMALE">שדכנית</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>סטטוס זמינות</Label>
                <Select
                  value={formData.availabilityStatus || "AVAILABLE"}
                  onValueChange={(value) =>
                    handleChange(
                      "availabilityStatus",
                      value as AvailabilityStatus
                    )
                  }
                  disabled={!isEditing}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="בחר סטטוס" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="AVAILABLE">פנוי/ה</SelectItem>
                    <SelectItem value="UNAVAILABLE">לא פנוי/ה</SelectItem>
                    <SelectItem value="DATING">בתהליך היכרות</SelectItem>
                    <SelectItem value="ENGAGED">מאורס/ת</SelectItem>
                    <SelectItem value="MARRIED">נשוי/אה</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label>הערת זמינות</Label>
                <Textarea
                  value={formData.availabilityNote || ""}
                  onChange={(e) =>
                    handleChange("availabilityNote", e.target.value)
                  }
                  disabled={!isEditing}
                  placeholder="הוסף הערה לגבי הזמינות שלך..."
                  className="mt-1"
                />
              </div>

              <div className="space-y-4">
                <Label>תיאור אישי</Label>
                {isEditing ? (
                  <Textarea
                    value={formData.about || ""}
                    onChange={(e) => handleChange("about", e.target.value)}
                    className="mt-2"
                    placeholder="ספר/י קצת על עצמך..."
                  />
                ) : (
                  <p className="mt-2 whitespace-pre-wrap">
                    {formData.about || "אין תיאור"}
                  </p>
                )}
              </div>

              <div className="space-y-4">
                <Label>תחביבים</Label>
                {isEditing ? (
                  <Textarea
                    value={formData.hobbies || ""}
                    onChange={(e) => handleChange("hobbies", e.target.value)}
                    className="mt-2"
                    placeholder="פרט/י את תחביבייך..."
                  />
                ) : (
                  <p className="mt-2">
                    {formData.hobbies || "לא צוינו תחביבים"}
                  </p>
                )}
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default ProfileSection;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\sections\QuestionnaireResponsesSection.tsx:
==================================================
import React, { useState } from "react";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import {
  Heart,
  Users,
  User,
  Scroll,
  Book,
  CheckCircle,
  Clock,
  Pencil,
  X,
  Eye,
  EyeOff,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type {
  UserProfile,
  UserImage,
  QuestionnaireResponse,
  FormattedAnswer,
} from "@/types/next-auth";

interface QuestionnaireResponsesSectionProps {
  questionnaire: QuestionnaireResponse | null;
  onUpdate?: (world: string, questionId: string, value: any) => Promise<void>;
  isEditable?: boolean;
  viewMode?: "matchmaker" | "candidate";
}

const WORLDS = {
  values: {
    key: "values",
    title: "ערכים ואמונות",
    icon: Heart,
    color: "text-pink-500",
    bgColor: "bg-pink-50",
    borderColor: "border-pink-200",
  },
  personality: {
    key: "personality",
    title: "אישיות",
    icon: User,
    color: "text-blue-500",
    bgColor: "bg-blue-50",
    borderColor: "border-blue-200",
  },
  relationship: {
    key: "relationship",
    title: "זוגיות ומשפחה",
    icon: Users,
    color: "text-purple-500",
    bgColor: "bg-purple-50",
    borderColor: "border-purple-200",
  },
  religion: {
    key: "religion",
    title: "דת ומסורת",
    icon: Scroll,
    color: "text-indigo-500",
    bgColor: "bg-indigo-50",
    borderColor: "border-indigo-200",
  },
  partner: {
    key: "partner",
    title: "העדפות בן/בת זוג",
    icon: Heart,
    color: "text-red-500",
    bgColor: "bg-red-50",
    borderColor: "border-red-200",
  },
} as const;

const QuestionCard = ({
  question,
  answer,
  isEditing,
  onEdit,
  onVisibilityChange,
}: {
  question: string;
  answer: FormattedAnswer;
  isEditing: boolean;
  onEdit: (value: string) => void;
  onVisibilityChange: (isVisible: boolean) => void;
}) => {
  const [editValue, setEditValue] = useState(answer.displayText);
  const [isEditing2, setIsEditing2] = useState(false);

  const handleStartEdit = () => {
    setIsEditing2(true);
    setEditValue(answer.displayText);
  };

  const handleSave = () => {
    onEdit(editValue);
    setIsEditing2(false);
  };

  const handleCancel = () => {
    setEditValue(answer.displayText);
    setIsEditing2(false);
  };

  return (
    <div className="rounded-lg border bg-card p-4 shadow-sm">
      <div className="flex items-start justify-between gap-4">
        <div className="flex-1 min-w-0">
          <div className="flex items-center justify-between mb-4">
            <h4 className="font-medium text-base">{question}</h4>
            <div className="flex items-center gap-2" dir="ltr">
              <div
                className={cn(
                  "flex items-center gap-2 px-3 py-1.5 rounded-full text-sm shrink-0 flex-row-reverse",
                  answer.isVisible
                    ? "bg-primary/10 text-primary"
                    : "bg-muted text-muted-foreground"
                )}
              >
                {answer.isVisible ? (
                  <Eye className="h-4 w-4" />
                ) : (
                  <EyeOff className="h-4 w-4" />
                )}
                <span
                  className="text-xs font-medium whitespace-nowrap"
                  dir="rtl"
                >
                  {answer.isVisible ? "מוצג למועמדים" : "מוסתר"}
                </span>
                {isEditing && (
                  <Switch
                    checked={answer.isVisible ?? true}
                    onCheckedChange={onVisibilityChange}
                    className="data-[state=checked]:bg-primary data-[state=unchecked]:bg-muted-foreground/30"
                  />
                )}
              </div>
            </div>
          </div>

          {isEditing2 ? (
            <div className="space-y-2">
              <Textarea
                value={editValue}
                onChange={(e) => setEditValue(e.target.value)}
                className="min-h-[100px]"
                placeholder="הקלד/י את תשובתך כאן..."
              />
              <div className="flex justify-end gap-2">
                <Button size="sm" variant="outline" onClick={handleCancel}>
                  <X className="h-4 w-4 ml-1" />
                  ביטול
                </Button>
                <Button size="sm" onClick={handleSave}>
                  <CheckCircle className="h-4 w-4 ml-1" />
                  שמירה
                </Button>
              </div>
            </div>
          ) : (
            <div className="relative group overflow-hidden">
              <div className="p-3 bg-muted/30 rounded-md">
                <p className="text-sm break-words overflow-wrap-anywhere whitespace-pre-wrap">
                  {answer.displayText}
                </p>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <span className="text-xs text-muted-foreground block mt-2">
                        {answer.answeredAt}
                      </span>
                    </TooltipTrigger>
                    <TooltipContent dir="rtl">
                      <p>תאריך עדכון אחרון</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              {isEditing && (
                <Button
                  variant="ghost"
                  size="sm"
                  className="absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                  onClick={handleStartEdit}
                >
                  <Pencil className="h-4 w-4" />
                </Button>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

const WorldSection = ({
  title,
  icon: Icon,
  answers,
  isEditing,
  onEdit,
  onVisibilityChange,
  isCompleted,
  className,
}: {
  title: string;
  icon: React.ElementType;
  answers: FormattedAnswer[];
  isEditing: boolean;
  onEdit: (questionId: string, value: string) => void;
  onVisibilityChange: (questionId: string, isVisible: boolean) => void;
  isCompleted: boolean;
  className?: string;
}) => {
  return (
    <Card className={cn("overflow-hidden", className)}>
      <CardHeader className="p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div
              className={cn(
                "p-2 rounded-full",
                answers.length > 0 ? "bg-primary/10" : "bg-muted"
              )}
            >
              <Icon
                className={cn(
                  "h-5 w-5",
                  answers.length > 0 ? "text-primary" : "text-muted-foreground"
                )}
              />
            </div>
            <div>
              <CardTitle className="text-lg">{title}</CardTitle>
              <CardDescription>{answers.length} תשובות</CardDescription>
            </div>
          </div>
          {isCompleted && (
            <Badge variant="success" className="gap-1">
              <CheckCircle className="h-3 w-3" />
              הושלם
            </Badge>
          )}
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-0">
        {answers.length > 0 ? (
          <div className="space-y-4">
            {answers.map((answer) => (
              <QuestionCard
                key={answer.questionId}
                question={answer.question}
                answer={answer}
                isEditing={isEditing}
                onEdit={(value) => onEdit(answer.questionId, value)}
                onVisibilityChange={(isVisible) =>
                  onVisibilityChange(answer.questionId, isVisible)
                }
              />
            ))}
          </div>
        ) : (
          <div className="text-center py-8 text-muted-foreground">
            <Book className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>אין תשובות בחלק זה</p>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

const QuestionnaireResponsesSection: React.FC<
  QuestionnaireResponsesSectionProps
> = ({
  questionnaire,
  onUpdate,
  isEditable = false,
  viewMode = "candidate",
}) => {
  const [isEditing, setIsEditing] = useState(false);

  if (!questionnaire) {
    return (
      <div className="text-center py-8 text-muted-foreground">
        לא נמצא שאלון
      </div>
    );
  }

  const handleEdit = async (
    worldKey: string,
    questionId: string,
    value: string
  ) => {
    try {
      if (!value?.trim()) {
        toast.error("לא ניתן לשמור ערך ריק");
        return;
      }

      if (onUpdate) {
        console.log("Updating answer:", { worldKey, questionId, value });
        await onUpdate(worldKey, questionId, {
          type: "answer",
          value: value.trim(),
        });
        toast.success("התשובה עודכנה בהצלחה");
      }
    } catch (error) {
      console.error("Error updating answer:", error);
      toast.error("שגיאה בעדכון התשובה");
    }
  };

  const handleVisibilityChange = async (
    worldKey: string,
    questionId: string,
    isVisible: boolean
  ) => {
    try {
      if (onUpdate) {
        await onUpdate(worldKey, questionId, {
          type: "visibility",
          isVisible,
        });
        toast.success("הגדרות הנראות עודכנו בהצלחה");
      }
    } catch (error) {
      console.error("Error updating visibility:", error);
      toast.error("שגיאה בעדכון הגדרות הנראות");
    }
  };

  return (
    <div className="space-y-6">
      {/* Status Header */}
      <div className="flex items-center justify-between bg-card p-4 rounded-lg border">
        <div className="flex items-center gap-2">
          {questionnaire.completed ? (
            <CheckCircle className="h-5 w-5 text-green-500" />
          ) : (
            <Clock className="h-5 w-5 text-blue-500" />
          )}
          <div>
            <p className="font-medium">
              {questionnaire.completed ? "שאלון הושלם" : "שאלון בתהליך"}
            </p>
            <p className="text-sm text-muted-foreground">
              עודכן לאחרונה:{" "}
              {new Date(questionnaire.lastSaved).toLocaleDateString("he-IL")}
            </p>
          </div>
        </div>

        {isEditable && (
          <Button
            variant="outline"
            onClick={() => setIsEditing(!isEditing)}
            className="gap-2"
          >
            {isEditing ? (
              <>
                <X className="h-4 w-4" />
                סיום עריכה
              </>
            ) : (
              <>
                <Pencil className="h-4 w-4" />
                עריכת תשובות
              </>
            )}
          </Button>
        )}
      </div>

      {/* Worlds Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {Object.entries(WORLDS).map(([key, world]) => (
          <WorldSection
            key={key}
            title={world.title}
            icon={world.icon}
            answers={
              questionnaire.formattedAnswers?.[
                key as keyof typeof questionnaire.formattedAnswers
              ] ?? []
            }
            isEditing={isEditing}
            onEdit={(questionId, value) => handleEdit(key, questionId, value)}
            onVisibilityChange={(questionId, isVisible) =>
              handleVisibilityChange(key, questionId, isVisible)
            }
            isCompleted={
              questionnaire[
                `${key}Completed` as keyof QuestionnaireResponse
              ] as boolean
            }
            className={cn(world.bgColor, world.borderColor)}
          />
        ))}
      </div>
    </div>
  );
};

export default QuestionnaireResponsesSection;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\types\profile.ts:
==================================================
// src/components/shared/profile/types/profile.ts
import type { UserProfile, UserImage, QuestionnaireResponse } from "@/types/next-auth";
import type { Gender, AvailabilityStatus } from "@prisma/client";

// Interfaces for the main sections
export interface PhotosSectionProps {
  images: UserImage[];
  isUploading: boolean;
  disabled?: boolean;
  onUpload: (file: File) => Promise<void>;
  onSetMain: (imageId: string) => Promise<void>;
  onDelete: (imageId: string) => Promise<void>;
}

export interface ExtendedProfileSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onSave: (data: Partial<UserProfile>) => void;
}

export interface PreferencesSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onChange: (data: Partial<UserProfile>) => void;
}

export interface QuestionnaireResponsesSectionProps {
  questionnaire: QuestionnaireResponse | null;
  onUpdate?: (world: string, questionId: string, value: any) => Promise<void>;
  isEditable?: boolean;
  viewMode?: "matchmaker" | "candidate";
}

// Types for the extended profile data
export interface ExtendedProfileData {
  personalityTraits?: {
    temperament?: string;
    decisionMaking?: string;
    stressManagement?: string;
    communicationStyle?: string;
  };
  spiritualProfile?: {
    prayerStyle?: string;
    secularStudiesAttitude?: string;
    modestyLevel?: string;
    childrenEducationApproach?: string;
  };
  familyBackground?: {
    parentsSpiritualLevel?: string;
    parentsOccupations?: {
      father?: string;
      mother?: string;
    };
    familyDynamics?: string;
  };
  lifestylePreferences?: {
    careerAspiration?: string;
    futureStudyPlans?: string;
    livingPreferences?: {
      proximity?: string;
    };
    relationshipExpectations?: string;
  };
  healthProfile?: {
    generalHealth?: string;
    dietaryRestrictions?: string[];
    physicalActivity?: string;
  };
  personalValues?: {
    parentalRespect?: number;
    communityInvolvement?: string;
    volunteeringPreferences?: string;
    financialManagement?: string;
  };
  futureGoals?: string[];
  [key: string]: any;
}

// Additional utility types
export type ViewMode = "matchmaker" | "candidate";
export type CardSize = "sm" | "md" | "lg";

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\shared\shared\profile\types\questionnaire.ts:
==================================================
// src/components/shared/profile/types/questionnaire.ts
export interface FormattedAnswer {
  questionId: string;
  question: string;
  value: any;
  displayText: string;
  answeredAt: string;
  category?: string;
  isVisible: boolean;
}

export interface QuestionnaireResponse {
  id: string;
  userId: string;
  formattedAnswers: {
    values: FormattedAnswer[];
    personality: FormattedAnswer[];
    relationship: FormattedAnswer[];
    partner: FormattedAnswer[];
    religion: FormattedAnswer[];
  };
  valuesCompleted: boolean;
  personalityCompleted: boolean;
  relationshipCompleted: boolean;
  partnerCompleted: boolean;
  religionCompleted: boolean;
  worldsCompleted: string[];
  completed: boolean;
  startedAt: string | Date;
  completedAt?: string | Date;
  lastSaved: string | Date;
}

export interface QuestionnaireWorld {
    key: string;
    title: string;
    icon: React.ElementType;
    color: string;
    bgColor: string;
    borderColor: string;
  }
  
  export interface QuestionCardProps {
    question: string;
    answer: FormattedAnswer;
    isEditing: boolean;
    onEdit: (value: string) => void;
    onVisibilityChange: (isVisible: boolean) => void;
  }
  
  export interface WorldSectionProps {
    title: string;
    icon: React.ElementType;
    answers: FormattedAnswer[];
    isEditing: boolean;
    onEdit: (questionId: string, value: string) => void;
    onVisibilityChange: (questionId: string, isVisible: boolean) => void;
    isCompleted: boolean;
    className?: string;
  }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\suggestions\MatchSuggestionsContainer.tsx:
==================================================
"use client";

import React, { useState, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card } from "@/components/ui/card";
import { Clock, History, AlertCircle } from "lucide-react";
import { toast } from "sonner";
import { Alert, AlertDescription } from "@/components/ui/alert";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";

import SuggestionsList from "./list/SuggestionsList";

interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
}

interface MatchSuggestionsContainerProps {
  userId: string;
  className?: string;
}

const MatchSuggestionsContainer: React.FC<MatchSuggestionsContainerProps> = ({
  userId,
  className,
}) => {
  // States
  const [activeSuggestions, setActiveSuggestions] = useState<
    ExtendedMatchSuggestion[]
  >([]);
  const [historySuggestions, setHistorySuggestions] = useState<
    ExtendedMatchSuggestion[]
  >([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("active");
  const [viewMode] = useState<"grid" | "list">("grid");

  // Fetch suggestions
  useEffect(() => {
    const loadSuggestions = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // Load both active and history suggestions
        const [activeResponse, historyResponse] = await Promise.all([
          fetch(`/api/suggestions/active`),
          fetch(`/api/suggestions/history`),
        ]);

        if (!activeResponse.ok || !historyResponse.ok) {
          throw new Error("Failed to fetch suggestions");
        }

        const activeData = await activeResponse.json();
        const historyData = await historyResponse.json();

        setActiveSuggestions(activeData.suggestions);
        setHistorySuggestions(historyData.suggestions);
      } catch (error) {
        console.error("Error loading suggestions:", error);
        setError("אירעה שגיאה בטעינת ההצעות");
      } finally {
        setIsLoading(false);
      }
    };

    loadSuggestions();
  }, [userId]);

  // Handle suggestion status change
  const handleStatusChange = async (
    suggestionId: string,
    newStatus: string
  ) => {
    try {
      const response = await fetch(`/api/suggestions/${suggestionId}/status`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: newStatus }),
      });

      if (!response.ok) {
        throw new Error("Failed to update suggestion status");
      }

      // Update local state
      setActiveSuggestions((prev) =>
        prev.filter((suggestion) => suggestion.id !== suggestionId)
      );

      const updatedSuggestion = await response.json();
      setHistorySuggestions((prev) => [updatedSuggestion, ...prev]);
    } catch (error) {
      console.error("Error updating suggestion status:", error);
      throw error;
    }
  };

  return (
    <Card className={`p-6 ${className}`}>
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <div className="flex items-center justify-between mb-6">
          <TabsList>
            <TabsTrigger value="active" className="flex items-center gap-2">
              <Clock className="w-4 h-4" />
              הצעות פעילות
              {activeSuggestions.length > 0 && (
                <span className="px-2 py-0.5 rounded-full bg-primary text-primary-foreground text-xs">
                  {activeSuggestions.length}
                </span>
              )}
            </TabsTrigger>
            <TabsTrigger value="history" className="flex items-center gap-2">
              <History className="w-4 h-4" />
              היסטוריה
            </TabsTrigger>
          </TabsList>
        </div>

        {error && (
          <Alert variant="destructive" className="mb-6">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        <TabsContent value="active">
          <SuggestionsList
            suggestions={activeSuggestions}
            userId={userId}
            viewMode={viewMode}
            isLoading={isLoading}
            onStatusChange={handleStatusChange}
          />
        </TabsContent>

        <TabsContent value="history">
          <SuggestionsList
            suggestions={activeSuggestions}
            userId={userId}
            viewMode={viewMode}
            isLoading={isLoading}
            onStatusChange={handleStatusChange}
          />
        </TabsContent>
      </Tabs>
    </Card>
  );
};

export default MatchSuggestionsContainer;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\suggestions\cards\MinimalSuggestionCard.tsx:
==================================================
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
 User,
 MapPin,
 Briefcase,
 Calendar,
 Clock,
 UserCircle,
 Eye,
 CheckCircle,
 XCircle,
 MessageCircle,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";

interface ExtendedUserProfile extends UserProfile {
 user: {
   firstName: string;
   lastName: string;
   email: string;
 };
}

interface PartyInfo {
 id: string;
 email: string;
 firstName: string;
 lastName: string;
 profile: ExtendedUserProfile;
 images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
 matchmaker: {
   firstName: string;
   lastName: string;
 };
 firstParty: PartyInfo;
 secondParty: PartyInfo;
}

interface MinimalSuggestionCardProps {
 suggestion: ExtendedMatchSuggestion;
 userId: string;
 onClick: (suggestion: ExtendedMatchSuggestion) => void;
 onQuickAction?: (suggestion: ExtendedMatchSuggestion) => void;
 onApprove?: (suggestion: ExtendedMatchSuggestion) => void;
 className?: string;
 isHistory?: boolean;
}

const calculateAge = (birthDate: Date): number => {
 const today = new Date();
 const birth = new Date(birthDate);
 let age = today.getFullYear() - birth.getFullYear();
 const monthDiff = today.getMonth() - birth.getMonth();
 if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
   age--;
 }
 return age;
};

const getStatusInfo = (status: string) => {
 switch (status) {
   case "PENDING_FIRST_PARTY":
     return {
       label: "ממתין לתשובתך",
       className: "bg-yellow-100 text-yellow-800 border-yellow-200",
     };
   case "PENDING_SECOND_PARTY":
     return {
       label: "ממתין לתשובת הצד השני",
       className: "bg-blue-100 text-blue-800 border-blue-200",
     };
   case "FIRST_PARTY_APPROVED":
   case "SECOND_PARTY_APPROVED":
     return {
       label: "אישרת את ההצעה",
       className: "bg-green-100 text-green-800 border-green-200",
     };
   case "CONTACT_DETAILS_SHARED":
     return {
       label: "פרטי קשר שותפו",
       className: "bg-purple-100 text-purple-800 border-purple-200",
     };
   default:
     return {
       label: "בטיפול",
       className: "bg-gray-100 text-gray-800 border-gray-200",
     };
 }
};

const MinimalSuggestionCard: React.FC<MinimalSuggestionCardProps> = ({
 suggestion,
 userId,
 onClick,
 onQuickAction,
 onApprove,
 className,
 isHistory = false,
}) => {
 const targetParty = suggestion.firstPartyId === userId ? suggestion.secondParty : suggestion.firstParty;

 if (!targetParty) {
   return null;
 }

 const mainImage = targetParty.images?.find((img) => img.isMain);
 const age = targetParty.profile?.birthDate
   ? calculateAge(new Date(targetParty.profile.birthDate))
   : null;
 const statusInfo = getStatusInfo(suggestion.status);

 return (
   <Card
     className={`relative overflow-hidden cursor-pointer transition-all hover:shadow-lg ${
       className ?? ""
     }`}
     onClick={() => onClick(suggestion)}
   >
     <div className="relative h-48 bg-gradient-to-b from-blue-50 to-blue-100">
       {mainImage?.url ? (
         <img
           src={mainImage.url}
           alt={`${targetParty.firstName} ${targetParty.lastName}`}
           className="w-full h-full object-cover"
         />
       ) : (
         <div className="w-full h-full flex items-center justify-center">
           <User className="w-16 h-16 text-gray-400" />
         </div>
       )}

       <div className="absolute top-3 right-3">
         <Badge className={statusInfo.className}>{statusInfo.label}</Badge>
       </div>

       <div className="absolute bottom-3 right-3">
         <Badge variant="outline" className="bg-white/90">
           <UserCircle className="w-3 h-3 ml-1" />
           {suggestion.matchmaker.firstName} {suggestion.matchmaker.lastName}
         </Badge>
       </div>

       {!isHistory && (
         <div className="absolute bottom-3 left-3">
           <Button
             size="sm"
             variant="secondary"
             className="bg-white/90"
             onClick={(e) => {
               e.stopPropagation();
               onQuickAction?.(suggestion);
             }}
           >
             פעולות מהירות
           </Button>
         </div>
       )}

       {suggestion.decisionDeadline && (
         <div className="absolute bottom-12 left-3">
           <Badge variant="outline" className="bg-white/90">
             <Clock className="w-3 h-3 ml-1" />
             {formatDistanceToNow(new Date(suggestion.decisionDeadline), {
               addSuffix: true,
               locale: he,
             })}
           </Badge>
         </div>
       )}
     </div>

     <div className="p-4">
       <h3 className="text-lg font-semibold mb-2 text-right">
         {targetParty.firstName} {targetParty.lastName}
       </h3>

       <div className="space-y-2 text-gray-600 text-sm">
         {age && (
           <div className="flex items-center justify-end gap-2">
             <span>{age}</span>
             <Calendar className="w-4 h-4" />
           </div>
         )}

         {targetParty.profile.city && (
           <div className="flex items-center justify-end gap-2">
             <span>{targetParty.profile.city}</span>
             <MapPin className="w-4 h-4" />
           </div>
         )}

         {targetParty.profile.occupation && (
           <div className="flex items-center justify-end gap-2">
             <span>{targetParty.profile.occupation}</span>
             <Briefcase className="w-4 h-4" />
           </div>
         )}

         <div className="flex items-center justify-end gap-2 text-xs text-gray-400">
           <span>
             {`הוצע ${formatDistanceToNow(new Date(suggestion.createdAt), {
               addSuffix: true,
               locale: he,
             })}`}
           </span>
           <Clock className="w-3 h-3" />
         </div>

         {!isHistory && (
           <div className="grid grid-cols-2 gap-2 mt-4 pt-3 border-t border-gray-100">
             <Button
               size="sm"
               variant="default"
               className="w-full"
               onClick={(e) => {
                 e.stopPropagation();
                 onClick(suggestion);
               }}
             >
               <Eye className="w-4 h-4 ml-2" />
               צפייה בפרופיל
             </Button>

             <Button
               size="sm"
               variant="default"
               className="w-full bg-green-600 hover:bg-green-700"
               onClick={(e) => {
                 e.stopPropagation();
                 onApprove?.(suggestion);
               }}
             >
               <CheckCircle className="w-4 h-4 ml-2" />
               אישור הצעה
             </Button>

             <Button
               size="sm"
               variant="outline"
               className="w-full text-red-600 hover:text-red-700 hover:bg-red-50"
               onClick={(e) => {
                 e.stopPropagation();
                 onQuickAction?.(suggestion);
               }}
             >
               <XCircle className="w-4 h-4 ml-2" />
               דחיית הצעה
             </Button>

             <Button
               size="sm"
               variant="outline"
               className="w-full"
               onClick={(e) => {
                 e.stopPropagation();
                 onQuickAction?.(suggestion);
               }}
             >
               <MessageCircle className="w-4 h-4 ml-2" />
               שאלה לשדכן
             </Button>
           </div>
         )}
       </div>
     </div>
   </Card>
 );
};

export default MinimalSuggestionCard;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\suggestions\cards\SuggestionQuickView.tsx:
==================================================
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  User,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  MessageCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";

interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
}

interface SuggestionQuickViewProps {
  suggestion: ExtendedMatchSuggestion;
  userId?: string;
  onAction: (action: "approve" | "reject" | "ask" | "view") => void;
}

const SuggestionQuickView: React.FC<SuggestionQuickViewProps> = ({
  suggestion,
  userId,
  onAction,
}) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = userId
    ? suggestion.firstPartyId === userId
      ? suggestion.secondParty.profile
      : suggestion.firstParty.profile
    : suggestion.secondParty.profile;

  return (
    <div
      className="bg-white/95 backdrop-blur-sm p-4 rounded-lg shadow-lg flex flex-col"
      onClick={handleClick}
    >
      <div className="flex-1 space-y-4 text-right overflow-y-auto max-h-96">
        <div className="grid grid-cols-2 gap-3">
          {profile.height && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.height} ס״מ</span>
              <User className="w-4 h-4" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.maritalStatus}</span>
              <Heart className="w-4 h-4" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.religiousLevel}</span>
              <Scroll className="w-4 h-4" />
            </div>
          )}

          {profile.education && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.education}</span>
              <GraduationCap className="w-4 h-4" />
            </div>
          )}
        </div>

        {profile.about && (
          <div className="border-t border-gray-100 pt-3">
            <h4 className="text-sm font-medium mb-1">אודות:</h4>
            <p className="text-sm text-gray-600 leading-relaxed line-clamp-3">
              {profile.about}
            </p>
          </div>
        )}

        {suggestion.matchingReason && (
          <div className="border-t border-gray-100 pt-3">
            <h4 className="text-sm font-medium mb-1">סיבת ההצעה:</h4>
            <p className="text-sm text-gray-600 leading-relaxed line-clamp-3">
              {suggestion.matchingReason}
            </p>
          </div>
        )}

        <div className="border-t border-gray-100 pt-3 space-y-2">
          {profile.city && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.city}</span>
              <MapPin className="w-4 h-4" />
            </div>
          )}

          {profile.occupation && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.occupation}</span>
              <Briefcase className="w-4 h-4" />
            </div>
          )}
        </div>

        {suggestion.decisionDeadline && (
          <div className="border-t border-gray-100 pt-3">
            <div className="flex items-center justify-end gap-2 text-sm text-yellow-600">
              <span>
                נדרשת תשובה עד{" "}
                {new Date(suggestion.decisionDeadline).toLocaleDateString(
                  "he-IL"
                )}
              </span>
              <Clock className="w-4 h-4" />
            </div>
          </div>
        )}
      </div>

      <div className="grid grid-cols-2 gap-2 mt-4 pt-3 border-t border-gray-100">
        <Button
          variant="default"
          className="w-full"
          onClick={() => onAction("view")}
        >
          <Eye className="w-4 h-4 ml-2" />
          צפייה בפרופיל
        </Button>

        <Button
          variant="default"
          className="w-full bg-green-600 hover:bg-green-700"
          onClick={() => onAction("approve")}
        >
          <CheckCircle className="w-4 h-4 ml-2" />
          אישור הצעה
        </Button>

        <Button
          variant="outline"
          className="w-full text-red-600 hover:text-red-700 hover:bg-red-50"
          onClick={() => onAction("reject")}
        >
          <XCircle className="w-4 h-4 ml-2" />
          דחיית הצעה
        </Button>

        <Button
          variant="outline"
          className="w-full"
          onClick={() => onAction("ask")}
        >
          <MessageCircle className="w-4 h-4 ml-2" />
          שאלה לשדכן
        </Button>
      </div>
    </div>
  );
};

export default SuggestionQuickView;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\suggestions\dialogs\AskMatchmakerDialog.tsx:
==================================================
// src/app/components/suggestions/dialogs/AskMatchmakerDialog.tsx
"use client";

import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { MessageCircle } from "lucide-react";

interface AskMatchmakerDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (question: string) => Promise<void>;
  matchmakerName?: string;
}

export const AskMatchmakerDialog: React.FC<AskMatchmakerDialogProps> = ({
  isOpen,
  onClose,
  onSubmit,
  matchmakerName,
}) => {
  const [question, setQuestion] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async () => {
    if (!question.trim()) return;

    try {
      setIsSubmitting(true);
      await onSubmit(question);
      setQuestion("");
      onClose();
    } catch (error) {
      console.error("Error submitting question:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>
            שאלה ל{matchmakerName ? `שדכן ${matchmakerName}` : "שדכן"}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <Textarea
            value={question}
            onChange={(e) => setQuestion(e.target.value)}
            placeholder="הזן את שאלתך כאן..."
            className="min-h-[120px]"
          />
        </div>

        <DialogFooter>
          <Button
            type="button"
            variant="outline"
            onClick={onClose}
            disabled={isSubmitting}
          >
            ביטול
          </Button>
          <Button
            type="submit"
            onClick={handleSubmit}
            disabled={!question.trim() || isSubmitting}
          >
            <MessageCircle className="w-4 h-4 ml-2" />
            {isSubmitting ? "שולח..." : "שלח שאלה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\suggestions\list\SuggestionsList.tsx:
==================================================
import React, { useState, useEffect } from "react";
import { User } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ProfileCard } from "@/app/components/shared/shared/profile";
import { Skeleton } from "@/components/ui/skeleton";
import { toast } from "sonner";
import type { MatchSuggestion } from "@prisma/client";
import type {
  UserProfile,
  UserImage,
  QuestionnaireResponse,
} from "@/types/next-auth";

import MinimalSuggestionCard from "../cards/MinimalSuggestionCard";
import SuggestionQuickView from "../cards/SuggestionQuickView";
import { AskMatchmakerDialog } from "../dialogs/AskMatchmakerDialog";

interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  userId: string;
  isHistory?: boolean;
  viewMode: "grid" | "list";
  isLoading?: boolean;
  className?: string;
  onStatusChange?: (suggestionId: string, newStatus: string) => Promise<void>;
}

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions,
  isHistory = false,
  viewMode,
  isLoading = false,
  userId,
  className,
  onStatusChange,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] = useState<ExtendedMatchSuggestion | null>(null);
  const [quickActionSuggestion, setQuickActionSuggestion] = useState<ExtendedMatchSuggestion | null>(null);
  const [showAskDialog, setShowAskDialog] = useState(false);
  const [questionnaireResponse, setQuestionnaireResponse] = useState<QuestionnaireResponse | null>(null);

  useEffect(() => {
    const loadQuestionnaire = async () => {
      if (!selectedSuggestion) {
        setQuestionnaireResponse(null);
        return;
      }

      const targetParty = selectedSuggestion.firstPartyId === userId ? 
        selectedSuggestion.secondParty : selectedSuggestion.firstParty;

      try {
        const response = await fetch(`/api/profile/questionnaire?userId=${targetParty.id}`);
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          const formattedQuestionnaire = {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality: data.questionnaireResponse.formattedAnswers.personality || [],
              relationship: data.questionnaireResponse.formattedAnswers.relationship || [],
              partner: data.questionnaireResponse.formattedAnswers.partner || [],
              religion: data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
          setQuestionnaireResponse(formattedQuestionnaire);
        }
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
      }
    };

    loadQuestionnaire();
  }, [selectedSuggestion, userId]);

  const handleAction = async (action: "approve" | "reject" | "ask" | "view", suggestion: ExtendedMatchSuggestion) => {
    try {
      switch (action) {
        case "view":
          setSelectedSuggestion(suggestion);
          break;

        case "ask":
          setSelectedSuggestion(suggestion);
          setShowAskDialog(true);
          break;

        case "approve":
          if (onStatusChange) {
            const isFirstParty = suggestion.firstPartyId === userId;
            const newStatus = isFirstParty ? "FIRST_PARTY_APPROVED" : "SECOND_PARTY_APPROVED";
            await onStatusChange(suggestion.id, newStatus);
            toast.success("ההצעה אושרה בהצלחה");
          }
          break;

        case "reject":
          if (onStatusChange) {
            const isFirstParty = suggestion.firstPartyId === userId;
            const newStatus = isFirstParty ? "FIRST_PARTY_DECLINED" : "SECOND_PARTY_DECLINED";
            await onStatusChange(suggestion.id, newStatus);
            toast.success("ההצעה נדחתה");
          }
          break;
      }
    } catch (error) {
      console.error("Error handling suggestion action:", error);
      toast.error("אירעה שגיאה בעת ביצוע הפעולה");
    }
  };

  const handleSendQuestion = async (questionText: string) => {
    if (!selectedSuggestion) return;

    try {
      await fetch(`/api/suggestions/${selectedSuggestion.id}/inquiries`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ question: questionText }),
      });

      toast.success("השאלה נשלחה בהצלחה לשדכן");
      setShowAskDialog(false);
    } catch (error) {
      console.error("Error sending question:", error);
      toast.error("אירעה שגיאה בשליחת השאלה");
    }
  };

  if (isLoading) {
    return (
      <div className={`${viewMode === "grid" ? "grid grid-cols-1 md:grid-cols-2 gap-4" : "space-y-4"} ${className}`}>
        {Array.from({ length: 6 }).map((_, i) => (
          <Skeleton key={i} className="h-48 w-full" />
        ))}
      </div>
    );
  }

  if (suggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <User className="w-12 h-12 mb-4" />
        <p>{isHistory ? "אין הצעות בהיסטוריה" : "אין הצעות פעילות"}</p>
      </div>
    );
  }

  return (
    <>
      <div className={`${viewMode === "grid" ? "grid grid-cols-1 md:grid-cols-2 gap-4" : "space-y-4"} ${className}`}>
        {suggestions.map((suggestion) => (
          <div key={suggestion.id} className="relative">
            <MinimalSuggestionCard
              suggestion={suggestion}
              userId={userId}
              onClick={() => handleAction("view", suggestion)}
              onQuickAction={setQuickActionSuggestion}
              onApprove={() => handleAction("approve", suggestion)}
              isHistory={isHistory}
              className={viewMode === "list" ? "flex gap-4" : ""}
            />
          </div>
        ))}
      </div>

      <Dialog
        open={!!selectedSuggestion}
        onOpenChange={(open) => {
          if (!open) {
            setSelectedSuggestion(null);
            setQuestionnaireResponse(null);
          }
        }}
      >
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>פרטי המועמד/ת</DialogTitle>
          </DialogHeader>

          {selectedSuggestion && (
            <div className="space-y-6">
              <ProfileCard
                profile={{
                  ...(selectedSuggestion.firstPartyId === userId
                    ? selectedSuggestion.secondParty.profile
                    : selectedSuggestion.firstParty.profile),
                  user: {
                    firstName:
                      selectedSuggestion.firstPartyId === userId
                        ? selectedSuggestion.secondParty.firstName
                        : selectedSuggestion.firstParty.firstName,
                    lastName:
                      selectedSuggestion.firstPartyId === userId
                        ? selectedSuggestion.secondParty.lastName
                        : selectedSuggestion.firstParty.lastName,
                    email:
                      selectedSuggestion.firstPartyId === userId
                        ? selectedSuggestion.secondParty.email
                        : selectedSuggestion.firstParty.email,
                  },
                }}
                images={
                  selectedSuggestion.firstPartyId === userId
                    ? selectedSuggestion.secondParty.images
                    : selectedSuggestion.firstParty.images
                }
                questionnaire={questionnaireResponse}
                viewMode="candidate"
              />
            </div>
          )}
        </DialogContent>
      </Dialog>

      <Dialog
        open={!!quickActionSuggestion}
        onOpenChange={(open) => !open && setQuickActionSuggestion(null)}
      >
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>פעולות מהירות</DialogTitle>
          </DialogHeader>
          {quickActionSuggestion && (
            <SuggestionQuickView
              suggestion={quickActionSuggestion}
              onAction={(action) => {
                handleAction(action, quickActionSuggestion);
                if (action !== "view") {
                  setQuickActionSuggestion(null);
                }
              }}
            />
          )}
        </DialogContent>
      </Dialog>

      <AskMatchmakerDialog
        isOpen={showAskDialog}
        onClose={() => setShowAskDialog(false)}
        onSubmit={handleSendQuestion}
        matchmakerName={selectedSuggestion?.matchmaker.firstName}
      />
    </>
  );
};

export default SuggestionsList;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\config\fonts.ts:
==================================================
// src/app/config/fonts.ts
import localFont from "next/font/local";

export const geistSans = localFont({
  src: [
    {
      path: '../fonts/GeistVF.woff2',
      weight: '100 900',
      style: 'normal',
    }
  ],
  variable: '--font-geist-sans',
  display: 'swap',
  preload: true,
});

export const geistMono = localFont({
  src: [
    {
      path: '../fonts/GeistMonoVF.woff2',
      weight: '100 900',
      style: 'normal',
    }
  ],
  variable: '--font-geist-mono',
  display: 'swap',
  preload: true,
});

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\contexts\LanguageContext.tsx:
==================================================
// src/app/contexts/LanguageContext.tsx
"use client";

import React, { createContext, useContext, useState, useEffect } from "react";

type Language = "he" | "en";

interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

const LanguageContext = createContext<LanguageContextType | undefined>(
  undefined
);

export function useLanguage() {
  const context = useContext(LanguageContext);
  if (context === undefined) {
    throw new Error("useLanguage must be used within a LanguageProvider");
  }
  return context;
}

export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [language, setLanguage] = useState<Language>("he");
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
    const savedLanguage = localStorage.getItem("language") as Language;
    if (savedLanguage) {
      setLanguage(savedLanguage);
    }
  }, []);

  const handleSetLanguage = (lang: Language) => {
    setLanguage(lang);
    localStorage.setItem("language", lang);
  };

  if (!isClient) {
    return null;
  }

  return (
    <LanguageContext.Provider
      value={{ language, setLanguage: handleSetLanguage }}
    >
      {children}
    </LanguageContext.Provider>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\contexts\NotificationContext.tsx:
==================================================
// src/app/contexts/NotificationContext.tsx
import React, {
  createContext,
  useContext,
  useEffect,
  useRef,
  useState,
} from "react";
import { useSession } from "next-auth/react";
import type { Session } from "@/types/next-auth";
import type { NotificationCount } from "@/types/messages";

interface NotificationContextType {
  notifications: NotificationCount;
  refreshNotifications: () => Promise<void>;
}

const NotificationContext = createContext<NotificationContextType>({
  notifications: { availabilityRequests: 0, messages: 0, total: 0 },
  refreshNotifications: async () => {},
});

export const useNotifications = () => useContext(NotificationContext);

export function NotificationProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { data: session } = useSession() as { data: Session | null };
  const [notifications, setNotifications] = useState<NotificationCount>({
    availabilityRequests: 0,
    messages: 0,
    total: 0,
  });

  const pollingInterval = useRef<NodeJS.Timeout>();

  const fetchNotifications = async () => {
    try {
      const response = await fetch("/api/notifications");
      if (!response.ok) throw new Error("Failed to fetch notifications");
      const data = await response.json();
      setNotifications(data);
    } catch (error) {
      console.error("Error fetching notifications:", error);
    }
  };

  useEffect(() => {
    if (session?.user?.id) {
      // Initial fetch
      fetchNotifications();

      // Setup polling
      pollingInterval.current = setInterval(fetchNotifications, 30000);

      // Cleanup
      return () => {
        if (pollingInterval.current) {
          clearInterval(pollingInterval.current);
        }
      };
    }
  }, [session?.user?.id]);

  const value = {
    notifications,
    refreshNotifications: fetchNotifications,
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\fonts\GeistMonoVF.woff2:
==================================================
Error reading file C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\fonts\GeistMonoVF.woff2: 'utf-8' codec can't decode byte 0xee in position 18: invalid continuation byte

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\fonts\GeistVF.woff2:
==================================================
Error reading file C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\fonts\GeistVF.woff2: 'utf-8' codec can't decode byte 0xdc in position 11: invalid continuation byte

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\hooks\useMatchmaker.ts:
==================================================
// src/app/hooks/useMatchmaker.ts
import { useState, useEffect } from 'react';
import type { Client } from '@/app/types/matchmaker';
import type { Suggestion } from '@/app/types/suggestions';

export const useMatchmaker = () => {
  const [clients, setClients] = useState<Client[]>([]);
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // טעינת נתונים ראשונית
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const [clientsResponse, suggestionsResponse] = await Promise.all([
          fetch('/api/matchmaker/clients'),
          fetch('/api/matchmaker/suggestions')
        ]);

        if (!clientsResponse.ok) {
          throw new Error('שגיאה בטעינת רשימת המועמדים');
        }

        if (!suggestionsResponse.ok) {
          throw new Error('שגיאה בטעינת רשימת ההצעות');
        }

        const clientsData = await clientsResponse.json();
        console.log('Raw clients data:', clientsData); // לדיבוג

        // וידוא שהנתונים מכילים את השדות הנדרשים
        if (!clientsData || !clientsData.clients) {
          console.error('Invalid clients data structure:', clientsData);
          throw new Error('פורמט נתוני המועמדים אינו תקין');
        }

        // המרת הנתונים לפורמט הנכון
        const formattedClients: Client[] = Array.isArray(clientsData.clients) 
          ? clientsData.clients.map((client: any) => ({
              id: client.id,
              firstName: client.firstName,
              lastName: client.lastName,
              email: client.email,
              gender: client.gender,
              birthDate: client.birthDate,
              status: client.status,
              personalInfo: {
                height: client.profile?.height || null,
                maritalStatus: client.profile?.maritalStatus || null,
                occupation: client.profile?.occupation || null,
                education: client.profile?.education || null,
                religiousLevel: client.profile?.religiousLevel || null,
                city: client.profile?.city || null,
              },
              contactPreferences: [{
                method: client.profile?.contactPreference || 'EMAIL',
                value: client.email || ''
              }],
              location: client.profile?.city || '',
              lastActive: client.profile?.lastActive?.toISOString() || new Date().toISOString(),
              invitation: client.receivedInvitation ? {
                status: client.receivedInvitation.status,
                email: client.receivedInvitation.email,
                expiresAt: client.receivedInvitation.expires,
              } : undefined
            }))
          : [];

        console.log('Formatted clients:', formattedClients); // לדיבוג
        setClients(formattedClients);

        const suggestionsData = await suggestionsResponse.json();
        setSuggestions(Array.isArray(suggestionsData) ? suggestionsData : []);

      } catch (err) {
        console.error('Error loading matchmaker data:', err);
        setError(err instanceof Error ? err.message : 'שגיאה בטעינת הנתונים');
        setClients([]); // במקרה של שגיאה, נאתחל למערך ריק
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, []);

  // יצירת הצעת שידוך חדשה
  const createSuggestion = async (suggestionData: Partial<Suggestion>) => {
    try {
      const response = await fetch('/api/matchmaker/suggestions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(suggestionData),
      });

      if (!response.ok) {
        throw new Error('שגיאה ביצירת ההצעה');
      }

      const newSuggestion = await response.json();
      setSuggestions(prev => [...prev, newSuggestion]);
      return newSuggestion;
    } catch (err) {
      throw err;
    }
  };

  // עדכון הצעת שידוך קיימת
  const updateSuggestion = async (suggestionData: Partial<Suggestion>) => {
    try {
      const response = await fetch(`/api/matchmaker/suggestions/${suggestionData.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(suggestionData),
      });

      if (!response.ok) {
        throw new Error('שגיאה בעדכון ההצעה');
      }

      const updatedSuggestion = await response.json();
      setSuggestions(prev => 
        prev.map(suggestion => 
          suggestion.id === updatedSuggestion.id ? updatedSuggestion : suggestion
        )
      );
      return updatedSuggestion;
    } catch (err) {
      throw err;
    }
  };

  return {
    clients,
    suggestions,
    isLoading,
    error,
    createSuggestion,
    updateSuggestion,
  };
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\lib\auth.ts:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\lib\validation\auth.ts:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\questionnaire\page.tsx:
==================================================
// page.tsx
"use client";

import { useSession } from "next-auth/react";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { ArrowLeft, AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import MatchmakingQuestionnaire from "@/components/questionnaire/MatchmakingQuestionnaire";

export default function QuestionnairePage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [showQuestionnaire, setShowQuestionnaire] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleComplete = async () => {
    try {
      await router.push("/questionnaire/complete");
    } catch (err) {
      console.error("Error completing questionnaire:", err);
      setError("אירעה שגיאה בסיום השאלון. אנא נסה שוב.");
    }
  };

  if (status === "loading") {
    return (
      <div className="container mx-auto py-8 px-4">
        <Card className="max-w-4xl mx-auto">
          <CardContent className="p-8">
            <div className="text-center">טוען...</div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <Card className="max-w-4xl mx-auto">
        <CardHeader className="text-center">
          <CardTitle className="text-3xl font-bold">שאלון התאמה</CardTitle>
          <p className="text-gray-600 mt-2">
            המידע שתספק/י יעזור לנו למצוא את ההתאמה המיטבית עבורך
          </p>
        </CardHeader>

        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {!showQuestionnaire ? (
            <div className="text-center space-y-6">
              <div className="space-y-2 text-gray-600">
                <p>ברוכים הבאים לשאלון ההתאמה שלנו!</p>
                <p>
                  השאלון מסייע לנו להכיר אותך טוב יותר ולמצוא את ההתאמות הטובות
                  ביותר עבורך.
                </p>
                <p>זמן מילוי משוער: 20-30 דקות</p>
                <p>ניתן לשמור את ההתקדמות ולחזור בכל עת</p>
              </div>

              <div className="space-y-4">
                {!session ? (
                  <div className="p-4 bg-blue-50 rounded-lg">
                    <p className="text-blue-800 mb-4">
                      מומלץ להתחבר למערכת לפני מילוי השאלון כדי לשמור את התשובות
                      שלך
                    </p>
                    <div className="flex gap-4 justify-center">
                      <Link href="/auth/register">
                        <Button>הרשמה</Button>
                      </Link>
                      <Link href="/auth/signin">
                        <Button variant="outline">התחברות</Button>
                      </Link>
                    </div>
                  </div>
                ) : null}

                <Button
                  size="lg"
                  onClick={() => setShowQuestionnaire(true)}
                  className="mt-4"
                  disabled={isLoading}
                >
                  {isLoading ? "טוען..." : "התחל בשאלון"}
                  <ArrowLeft className="mr-2 h-5 w-5" />
                </Button>
              </div>
            </div>
          ) : (
            <MatchmakingQuestionnaire
              userId={session?.user?.id}
              onComplete={handleComplete}
            />
          )}
        </CardContent>
      </Card>
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\questionnaire\complete\page.tsx:
==================================================
// app/questionnaire/complete/page.tsx
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { CheckCircle2, ArrowRight } from "lucide-react";

export default function QuestionnairePage() {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/auth/signin");
    }
  }, [status, router]);

  if (status === "loading") {
    return (
      <div className="container mx-auto py-8 px-4">
        <Card className="max-w-xl mx-auto">
          <CardContent className="p-8">
            <div className="text-center">טוען...</div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <Card className="max-w-xl mx-auto bg-green-50 border-green-200">
        <CardHeader className="text-center pb-2">
          <div className="flex justify-center mb-4">
            <CheckCircle2 className="w-12 h-12 text-green-500" />
          </div>
          <CardTitle className="text-2xl">תודה על מילוי השאלון!</CardTitle>
        </CardHeader>

        <CardContent className="space-y-6 pt-4">
          <div className="text-center text-gray-600 space-y-2">
            <p>התשובות שלך נשמרו בהצלחה במערכת</p>
            <p>הצוות שלנו יעבור על התשובות ויחזור אליך בהקדם</p>
          </div>

          <Alert className="bg-blue-50 border-blue-200">
            <AlertDescription>
              בזמן שהצוות עובד על ההתאמות עבורך, תוכל/י להשלים את הפרופיל האישי
              שלך
            </AlertDescription>
          </Alert>

          <div className="flex justify-center pt-4">
            <Button
              onClick={() => router.push("/profile")}
              className="flex items-center"
            >
              המשך לפרופיל
              <ArrowRight className="mr-2 h-5 w-5" />
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\questionnaire\restore\page.tsx:
==================================================
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";

export default function QuestionnaireRestore() {
  const router = useRouter();
  const { data: session } = useSession();
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const restoreQuestionnaire = async () => {
      try {
        setIsProcessing(true);
        const savedData = localStorage.getItem("tempQuestionnaire");

        if (!savedData || !session?.user?.id) {
          router.push("/dashboard");
          return;
        }

        const questionnaireData = JSON.parse(savedData);
        // עדכון ה-userId לפי המשתמש שהתחבר
        questionnaireData.userId = session.user.id;

        const response = await fetch("/api/questionnaire", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(questionnaireData),
        });

        if (!response.ok) {
          throw new Error("Failed to save questionnaire");
        }

        // מחיקת הנתונים הזמניים מ-localStorage
        localStorage.removeItem("tempQuestionnaire");

        // ניווט לדף המתאים בהתאם למצב השאלון
        if (questionnaireData.completed) {
          router.push("/dashboard");
        } else {
          router.push("/questionnaire");
        }
      } catch (err) {
        console.error("Error restoring questionnaire:", err);
        setError("אירעה שגיאה בשחזור הנתונים. אנא נסה שוב.");
      } finally {
        setIsProcessing(false);
      }
    };

    if (session?.user) {
      restoreQuestionnaire();
    }
  }, [session, router]);

  if (error) {
    return (
      <div className="container mx-auto p-4 max-w-md">
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
        <div className="mt-4 flex justify-center">
          <Button onClick={() => router.push("/questionnaire")}>
            חזור לשאלון
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-4 max-w-md">
      <Card>
        <CardContent className="p-6 text-center">
          <Loader2 className="w-8 h-8 animate-spin mx-auto mb-4" />
          <p className="text-lg">משחזר את נתוני השאלון...</p>
          <p className="text-sm text-gray-500 mt-2">אנא המתן</p>
        </CardContent>
      </Card>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\types\matchmaker.ts:
==================================================
import type { Suggestion, CreateSuggestionData, SuggestionCommunication } from './suggestions';
import { Profile, AvailabilityStatus, Gender, UserStatus, User } from "@prisma/client";
export type { Gender, UserStatus };

// Status Types
export type ClientStatus = 'PENDING' | 'ACTIVE' | 'PAUSED' | 'INACTIVE';
export type InvitationStatus = 'PENDING' | 'ACCEPTED' | 'EXPIRED' | 'CANCELLED';

// Base Information Interfaces
export interface PersonalInfo {
  height?: number;
  maritalStatus?: string;
  occupation?: string;
  education?: string;
  religiousLevel?: string;
  origin?: string;
  city?: string;
  address?: string;
}

export interface FamilyInfo {
  parentStatus?: string;
  siblings?: number;
  position?: number;
}

export interface PrivacyPreferences {
  contactPreference?: string;
  isProfileVisible?: boolean;
  allowDirectMessages?: boolean;
  preferredMatchmakerGender?: Gender;
}

export interface References {
  referenceName1?: string;
  referencePhone1?: string;
  referenceName2?: string;
  referencePhone2?: string;
}

export interface ContactInfo {
  method: 'EMAIL' | 'PHONE' | 'WHATSAPP';
  value: string;
}

// Core Client Interfaces

export interface Client {
  id: string;
  firstName: string;
  lastName: string;
  email?: string;
  phone?: string;
  gender: Gender;
  birthDate: string;
  status: UserStatus;
  personalInfo?: {
    height?: number;
    maritalStatus?: string;
    occupation?: string;
    education?: string;
    religiousLevel?: string;
    city?: string;
  };
  profile?: Profile | null; 
  contactPreferences: ContactInfo[];
  location: string;
  lastActive: string;
}
export interface ExtendedClient extends Client {
  invitation?: {
    status: InvitationStatus;
    email?: string;
    expiresAt?: string;
  };
  latestInquiry?: {
    firstPartyResponse: boolean | null;
    secondPartyResponse: boolean | null;
    updatedAt: string;
    expiresAt: string;
  };
}
export interface Invitation {
  id: string;
  userId: string;
  matchmakerId: string;
  token: string;
  email: string;
  expires: Date;
  status: InvitationStatus;
  createdAt: Date;
  updatedAt: Date;
}

// נוסיף טיפוס חדש עבור תצוגת הזמנה מקוצרת
export interface InvitationDisplay {
  status: InvitationStatus;
  email?: string;
  expiresAt?: string;
}


// Form Data Interfaces
export interface CreateCandidateData {
  // Basic Information
  firstName: string;
  lastName: string;
  email?: string;
  phone?: string;
  gender: Gender;
  birthDate: string;
  status: UserStatus;
  sendInvitation: boolean;

  // Personal Information
  personalInfo: PersonalInfo;
  familyInfo: FamilyInfo;
  privacyPreferences: PrivacyPreferences;
  references: References;
  
  // Additional Information
  about?: string;
  matchingNotes?: string;
}

export interface FilterOptions {
  gender: 'all' | Gender;
  religiousLevel: string;
  status: 'all' | ClientStatus;
  hasInvitation: 'all' | 'sent' | 'pending' | 'accepted';
  ageRange: {
    min: number;
    max: number;
  };
}

export interface AvailabilityInquiry {
  id: string;
  matchmakerId: string;
  firstPartyId: string;
  secondPartyId: string;
  firstPartyResponse: boolean | null;
  secondPartyResponse: boolean | null;
  note: string | null;
  createdAt: Date;
  expiresAt: Date;
  matchmaker: User;
  firstParty: User;
  secondParty: User;
}
// Component Props Types
export interface ClientCardProps {
  client: ExtendedClient;
  onSuggest: (client: ExtendedClient) => void;
  onSendInvite: () => void;
  onCheckAvailability?: (client: ExtendedClient) => Promise<void>;
}

export interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  selectedClient: ExtendedClient | null;
  onSubmit: (data: any) => Promise<void>;
}

export interface SuggestionCardProps {
  suggestion: Suggestion;
  onSend: (suggestion: Suggestion, partyType: 'first' | 'second') => Promise<void>;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\types\suggestions.ts:
==================================================
import { 
  MatchSuggestionStatus, 
  Priority,
  Gender,
  AvailabilityStatus,
  UserRole,
  DateFeedback,
  MeetingStatus,
  Profile
} from '@prisma/client';

// Base suggestion data for creation
export interface CreateSuggestionData {
  matchmakerId: string;
  firstPartyId: string;
  secondPartyId: string;
  status?: MatchSuggestionStatus;
  priority?: Priority;
  decisionDeadline: Date;
  notes?: {
    internal?: string;
    forFirstParty?: string;
    forSecondParty?: string;
    matchingReason?: string;
    followUpNotes?: string;
  };
}

// Main suggestion type
export interface Suggestion {
  id: string;
  matchmakerId: string;
  firstPartyId: string;
  secondPartyId: string;
  status: MatchSuggestionStatus;
  priority: Priority;
  
  // Notes
  internalNotes?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  matchingReason?: string;
  followUpNotes?: string;
  
  // Deadlines & Timing
  responseDeadline?: Date;
  decisionDeadline?: Date;
  lastStatusChange?: Date;
  previousStatus?: MatchSuggestionStatus;
  
  // Activity Tracking
  lastActivity: Date;
  firstPartySent?: Date;
  firstPartyResponded?: Date;
  secondPartySent?: Date;
  secondPartyResponded?: Date;
  firstMeetingScheduled?: Date;
  closedAt?: Date;
  createdAt: Date;
  updatedAt: Date;

  // Relations
  matchmaker: {
    id: string;
    firstName: string;
    lastName: string;
    role: UserRole;
  };
  firstParty: PartyProfile;
  secondParty: PartyProfile;
  meetings: SuggestionMeeting[];
  statusHistory: SuggestionStatusHistory[];
  feedback: DateFeedback[];
  reviewedBy: PartyProfile[];
  approvedBy: PartyProfile[];
}

// Meeting type
export interface SuggestionMeeting {
  id: string;
  suggestionId: string;
  scheduledDate: Date;
  location?: string;
  status: MeetingStatus;
  notes?: string;
  feedback?: DateFeedback[];
  createdAt: Date;
  updatedAt: Date;
}

// Status history
export interface SuggestionStatusHistory {
  id: string;
  suggestionId: string;
  status: MatchSuggestionStatus;
  reason?: string;
  notes?: string;
  createdAt: Date;
}

// Profile type
export interface PartyProfile {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  profile?: Profile;
}

// Update type
export interface UpdateSuggestionData {
  id: string;
  status?: MatchSuggestionStatus;
  priority?: Priority;
  responseDeadline?: Date;
  decisionDeadline?: Date;
  notes?: {
    internal?: string;
    forFirstParty?: string;
    forSecondParty?: string;
    matchingReason?: string;
    followUpNotes?: string;
  };
}

// Response types
export interface SuggestionResponse {
  success: boolean;
  data?: Suggestion;
  error?: string;
}

export interface SuggestionsListResponse {
  success: boolean;
  data?: {
    suggestions: Suggestion[];
    total: number;
    page: number;
    pageSize: number;
  };
  error?: string;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\account-settings.tsx:
==================================================
"use client";

import React, { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { User, Mail, Key, Shield, Clock } from "lucide-react";
import { toast } from "sonner";
import { useSession } from "next-auth/react";
import { UserRole, UserStatus } from "@prisma/client";

interface AccountSettingsProps {
  user: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    role: UserRole;
    status: UserStatus;
    isVerified: boolean;
    lastLogin: Date | null;
    createdAt: Date;
  };
}

const PASSWORD_MIN_LENGTH = 8;

const AccountSettings: React.FC<AccountSettingsProps> = ({ user }) => {
  const { update: updateSession } = useSession();

  const [isEditingName, setIsEditingName] = useState(false);
  const [isChangingPassword, setIsChangingPassword] = useState(false);
  const [isSendingVerification, setIsSendingVerification] = useState(false);
  const [firstName, setFirstName] = useState(user?.firstName || "");
  const [lastName, setLastName] = useState(user?.lastName || "");
  const [currentPassword, setCurrentPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [verificationCode, setVerificationCode] = useState("");
  const [showVerificationInput, setShowVerificationInput] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const validatePassword = (password: string) => {
    if (password.length < PASSWORD_MIN_LENGTH) {
      throw new Error(`הסיסמה חייבת להכיל לפחות ${PASSWORD_MIN_LENGTH} תווים`);
    }
    if (!/[A-Z]/.test(password)) {
      throw new Error("הסיסמה חייבת להכיל לפחות אות גדולה באנגלית");
    }
    if (!/[a-z]/.test(password)) {
      throw new Error("הסיסמה חייבת להכיל לפחות אות קטנה באנגלית");
    }
    if (!/[0-9]/.test(password)) {
      throw new Error("הסיסמה חייבת להכיל לפחות ספרה אחת");
    }
  };

  const resetPasswordForm = () => {
    setCurrentPassword("");
    setNewPassword("");
    setConfirmPassword("");
    setVerificationCode("");
    setShowVerificationInput(false);
    setIsChangingPassword(false);
  };

  const sendVerificationEmail = async () => {
    setIsSendingVerification(true);
    try {
      const response = await fetch(`/api/auth/send-verification`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: user.email }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to send verification email");
      }

      toast.success("קוד אימות נשלח למייל שלך");
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "שגיאה בשליחת קוד אימות");
    } finally {
      setIsSendingVerification(false);
    }
  };

  const handleNameUpdate = async () => {
    if (!firstName.trim() || !lastName.trim()) {
      toast.error("נא למלא את כל השדות");
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch(`/api/profile/${user.id}/name`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ firstName, lastName }),
      });

      const data = await response.json();
      if (!response.ok) throw new Error(data.error || "Failed to update name");

      await updateSession();
      toast.success("השם עודכן בהצלחה");
      setIsEditingName(false);
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "שגיאה בעדכון השם");
    } finally {
      setIsLoading(false);
    }
  };

  const initiatePasswordChange = async () => {
    if (!currentPassword || !newPassword || !confirmPassword) {
      toast.error("נא למלא את כל השדות");
      return;
    }

    if (newPassword !== confirmPassword) {
      toast.error("הסיסמאות אינן תואמות");
      return;
    }

    try {
      validatePassword(newPassword);
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "שגיאה באימות הסיסמה");
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch(`/api/auth/initiate-password-change`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: user.id,
          currentPassword,
          newPassword,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to initiate password change");
      }

      setShowVerificationInput(true);
      toast.success("קוד אימות נשלח למייל שלך");
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "שגיאה באימות הסיסמה");
      resetPasswordForm();
    } finally {
      setIsLoading(false);
    }
  };

  const completePasswordChange = async () => {
    if (!verificationCode) {
      toast.error("נא להזין את קוד האימות");
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch(`/api/auth/complete-password-change`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: user.id,
          token: verificationCode,
          newPassword,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to complete password change");
      }

      toast.success("הסיסמה עודכנה בהצלחה");
      resetPasswordForm();
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "שגיאה בעדכון הסיסמה");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      <Card className="shadow-sm">
        <CardHeader className="border-b pb-3">
          <CardTitle className="text-xl">הגדרות חשבון</CardTitle>
          <CardDescription>נהל את פרטי החשבון והאבטחה שלך</CardDescription>
        </CardHeader>
        <CardContent className="divide-y">
          {/* Basic Info Section */}
          <div className="py-3">
            <div className="flex items-center justify-between mb-2">
              <div>
                <h3 className="text-base font-medium">פרטים בסיסיים</h3>
                <p className="text-sm text-muted-foreground">
                  השם והמייל המשמשים אותך באתר
                </p>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setIsEditingName(true)}
                disabled={isLoading}
              >
                עריכה
              </Button>
            </div>

            <div className="grid gap-2">
              <div className="flex items-center gap-2">
                <User className="w-4 h-4 text-muted-foreground shrink-0" />
                <div>
                  <p className="text-sm font-medium">שם מלא</p>
                  <p className="text-sm text-muted-foreground">
                    {user.firstName || "לא צוין"} {user.lastName || "לא צוין"}
                  </p>
                </div>
              </div>

              <div className="flex items-center gap-2">
                <Mail className="w-4 h-4 text-muted-foreground shrink-0" />
                <div className="flex items-center gap-2">
                  <div>
                    <p className="text-sm font-medium">כתובת מייל</p>
                    <p className="text-sm text-muted-foreground">{user.email}</p>
                  </div>
                  {!user.isVerified && (
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={sendVerificationEmail}
                      disabled={isSendingVerification}
                    >
                      שלח קוד אימות
                    </Button>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Account Status Section */}
          <div className="py-3">
            <h3 className="text-base font-medium mb-2">סטטוס חשבון</h3>
            <div className="grid gap-2">
              <div className="flex items-center gap-2">
                <Shield className="w-4 h-4 text-muted-foreground shrink-0" />
                <div>
                  <p className="text-sm font-medium">הרשאות</p>
                  <div className="flex gap-2 mt-1">
                    <Badge variant="outline">{user.role}</Badge>
                    <Badge variant={user.status === "ACTIVE" ? "success" : "warning"}>
                      {user.status}
                    </Badge>
                    <Badge variant={user.isVerified ? "success" : "destructive"}>
                      {user.isVerified ? "מאומת" : "לא מאומת"}
                    </Badge>
                  </div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                <Clock className="w-4 h-4 text-muted-foreground shrink-0" />
                <div>
                  <p className="text-sm font-medium">פרטי זמן</p>
                  <p className="text-sm text-muted-foreground">
                    נוצר ב: {new Date(user.createdAt).toLocaleDateString("he-IL")}
                    {user.lastLogin && ` • התחברות אחרונה: ${new Date(user.lastLogin).toLocaleDateString("he-IL")}`}
                  </p>
                </div>
              </div>
            </div>
          </div>

          {/* Security Section */}
          <div className="py-3">
            <div className="flex items-center justify-between mb-2">
              <div>
                <h3 className="text-base font-medium">אבטחה</h3>
                <p className="text-sm text-muted-foreground">
                  הגדרות אבטחה וסיסמה
                </p>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setIsChangingPassword(true)}
                disabled={isLoading}
              >
                שינוי סיסמה
              </Button>
            </div>

            <div className="flex items-center gap-2">
              <Key className="w-4 h-4 text-muted-foreground shrink-0" />
              <div>
                <p className="text-sm font-medium">אימות חשבון</p>
                <p className="text-sm text-muted-foreground">
                  {user.isVerified ? "החשבון מאומת" : "החשבון לא מאומת"}
                </p>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Edit Name Dialog */}
      <Dialog open={isEditingName} onOpenChange={setIsEditingName}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>עריכת שם</DialogTitle>
            <DialogDescription>עדכן את שמך כפי שיוצג באתר</DialogDescription>
          </DialogHeader>

          <div className="grid gap-3 py-3">
            <div className="space-y-1">
              <Label>שם פרטי</Label>
              <Input
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                disabled={isLoading}
              />
            </div>
            <div className="space-y-1">
              <Label>שם משפחה</Label>
              <Input
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                disabled={isLoading}
              />
            </div>
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setIsEditingName(false)}
              disabled={isLoading}
            >
              ביטול
            </Button>
            <Button onClick={handleNameUpdate} disabled={isLoading}>
              שמירה
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Change Password Dialog */}
      <Dialog
        open={isChangingPassword}
        onOpenChange={(open) => {
          if (!open) resetPasswordForm();
        }}
      >
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>שינוי סיסמה</DialogTitle>
            <DialogDescription>עדכן את סיסמת החשבון שלך</DialogDescription>
          </DialogHeader>

          {!showVerificationInput ? (
            <div className="grid gap-3 py-3">
              <div className="space-y-1">
                <Label>סיסמה נוכחית</Label>
                <Input
                  type="password"
                  value={currentPassword}
                  onChange={(e) => setCurrentPassword(e.target.value)}
                  disabled={isLoading}
                />
              </div>
              <div className="space-y-1">
                <Label>סיסמה חדשה</Label>
                <Input
                  type="password"
                  value={newPassword}
                  onChange={(e) => setNewPassword(e.target.value)}
                  disabled={isLoading}
                />
              </div>
              <div className="space-y-1">
                <Label>אימות סיסמה חדשה</Label>
                <Input
                  type="password"
                  value={confirmPassword}
                  onChange={(e) => setConfirmPassword(e.target.value)}
                  disabled={isLoading}
                />
              </div>

              <Alert>
                <AlertDescription>
                  לאחר אימות הסיסמה הנוכחית, יישלח קוד אימות למייל שלך
                </AlertDescription>
              </Alert>
            </div>
          ) : (
            <div className="grid gap-3 py-3">
              <div className="space-y-1">
                <Label>קוד אימות</Label>
                <Input
                  value={verificationCode}
                  onChange={(e) => setVerificationCode(e.target.value)}
                  placeholder="הזן את הקוד שנשלח למייל"
                  disabled={isLoading}
                />
              </div>
            </div>
          )}

          <DialogFooter>
            <Button
              variant="outline"
              onClick={resetPasswordForm}
              disabled={isLoading}
            >
              ביטול
            </Button>
            <Button
              onClick={
                showVerificationInput
                  ? completePasswordChange
                  : initiatePasswordChange
              }
              disabled={isLoading}
            >
              {showVerificationInput ? "אישור" : "המשך"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Password Requirements Alert */}
      {isChangingPassword && (
        <Alert className="mt-4">
          <AlertDescription>
            <h4 className="font-medium mb-1">דרישות הסיסמה:</h4>
            <ul className="text-sm space-y-1">
              <li>• לפחות {PASSWORD_MIN_LENGTH} תווים</li>
              <li>• אות גדולה באנגלית</li>
              <li>• אות קטנה באנגלית</li>
              <li>• מספר אחד לפחות</li>
            </ul>
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
};

export default AccountSettings;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\AvailabilityStatus.tsx:
==================================================
"use client";

import { useState, useEffect } from "react";
import { useSession, signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { AvailabilityStatus as AvailabilityStatusEnum } from "@prisma/client";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Textarea } from "@/components/ui/textarea";
import { AlertCircle, CheckCircle2 } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import type { Session } from "next-auth";

export default function AvailabilityStatus() {
  const { data: sessionData, update: updateSession } = useSession();
  const { data: session } = useSession() as { data: Session | null };

  const [showDialog, setShowDialog] = useState(false);
  const [showSuccessDialog, setShowSuccessDialog] = useState(false);
  const [status, setStatus] = useState<AvailabilityStatusEnum>(
    session?.user?.profile?.availabilityStatus ||
      AvailabilityStatusEnum.AVAILABLE
  );
  const [note, setNote] = useState(
    session?.user?.profile?.availabilityNote || ""
  );
  const [isUpdating, setIsUpdating] = useState(false);
  const [error, setError] = useState("");
  const [localStatus, setLocalStatus] = useState<AvailabilityStatusEnum | null>(
    null
  );
  const [localNote, setLocalNote] = useState<string | null>(null);

  useEffect(() => {
    if (session?.user?.profile?.availabilityStatus) {
      setStatus(session.user.profile.availabilityStatus);
      setNote(session.user.profile.availabilityNote || "");
    }
  }, [session]);

  const handleUpdate = async () => {
    try {
      setIsUpdating(true);
      setError("");

      setLocalStatus(status);
      setLocalNote(note);

      const response = await fetch("/api/profile/availability", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          availabilityStatus: status,
          availabilityNote: note || "",
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to update status");
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || "Server update failed");
      }

      await updateSession({
        user: {
          ...session?.user,
          profile: {
            ...session?.user?.profile,
            availabilityStatus: status,
            availabilityNote: note,
          },
        },
      });

      await signIn("credentials", {
        redirect: false,
        email: session?.user?.email,
        password: undefined,
      });

      setShowDialog(false);
      setShowSuccessDialog(true); // פתיחת דיאלוג ההצלחה החדש
    } catch (err) {
      console.error("Error in update:", err);
      setError(err instanceof Error ? err.message : "Failed to update status");

      setLocalStatus(null);
      setLocalNote(null);

      if (session?.user?.profile?.availabilityStatus) {
        setStatus(session.user.profile.availabilityStatus);
        setNote(session.user.profile.availabilityNote || "");
      }
    } finally {
      setIsUpdating(false);
    }
  };

  const displayStatus = localStatus || status;
  const displayNote = localNote || note;

  const getStatusColor = (status: AvailabilityStatusEnum) => {
    switch (status) {
      case AvailabilityStatusEnum.AVAILABLE:
        return "text-green-600 bg-green-50";
      case AvailabilityStatusEnum.UNAVAILABLE:
      case AvailabilityStatusEnum.DATING:
      case AvailabilityStatusEnum.ENGAGED:
      case AvailabilityStatusEnum.MARRIED:
        return "text-red-600 bg-red-50";
      default:
        return "text-gray-600 bg-gray-50";
    }
  };

  const getStatusDisplay = (status: AvailabilityStatusEnum): string => {
    switch (status) {
      case AvailabilityStatusEnum.AVAILABLE:
        return "פנוי/ה להצעות";
      case AvailabilityStatusEnum.UNAVAILABLE:
        return "לא פנוי/ה להצעות";
      case AvailabilityStatusEnum.DATING:
        return "בתהליך היכרות";
      case AvailabilityStatusEnum.ENGAGED:
        return "מאורס/ת";
      case AvailabilityStatusEnum.MARRIED:
        return "נשוי/אה";
      default:
        return "לא ידוע";
    }
  };

  if (!session?.user) return null;

  return (
    <>
      <Button
        variant="ghost"
        onClick={() => setShowDialog(true)}
        className={`flex items-center gap-2 ${getStatusColor(displayStatus)}`}
      >
        {displayStatus === AvailabilityStatusEnum.AVAILABLE ? (
          <CheckCircle2 className="w-4 h-4 text-green-600" />
        ) : (
          <AlertCircle className="w-4 h-4 text-red-600" />
        )}
        {getStatusDisplay(displayStatus)}
      </Button>

      <Dialog open={showDialog} onOpenChange={setShowDialog}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>עדכון סטטוס זמינות</DialogTitle>
          </DialogHeader>

          <div className="grid gap-4 py-4">
            <Select
              value={status}
              onValueChange={(value) =>
                setStatus(value as AvailabilityStatusEnum)
              }
              disabled={isUpdating}
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר סטטוס" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={AvailabilityStatusEnum.AVAILABLE}>
                  פנוי/ה להצעות
                </SelectItem>
                <SelectItem value={AvailabilityStatusEnum.UNAVAILABLE}>
                  לא פנוי/ה להצעות
                </SelectItem>
                <SelectItem value={AvailabilityStatusEnum.DATING}>
                  בתהליך היכרות
                </SelectItem>
                <SelectItem value={AvailabilityStatusEnum.ENGAGED}>
                  מאורס/ת
                </SelectItem>
                <SelectItem value={AvailabilityStatusEnum.MARRIED}>
                  נשוי/אה
                </SelectItem>
              </SelectContent>
            </Select>

            <Textarea
              placeholder="הערה (אופציונלי)"
              value={displayNote}
              onChange={(e) => setNote(e.target.value)}
              disabled={isUpdating}
            />
          </div>

          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <DialogFooter>
            <Button
              onClick={handleUpdate}
              disabled={isUpdating}
              className={
                status === AvailabilityStatusEnum.AVAILABLE
                  ? "bg-green-600 hover:bg-green-700"
                  : "bg-red-600 hover:bg-red-700"
              }
            >
              {isUpdating ? "מעדכן..." : "עדכון סטטוס"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <AlertDialog open={showSuccessDialog} onOpenChange={setShowSuccessDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>הסטטוס עודכן בהצלחה</AlertDialogTitle>
            <AlertDialogDescription>
              הסטטוס שלך עודכן בהצלחה במערכת.
              <br />
              <strong>שים/י לב:</strong> במידה ותרענן/י את הדף, יתכן שתראה/י
              זמנית את הסטטוס הקודם עד להתחברות מחדש.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogAction
            onClick={() => setShowSuccessDialog(false)}
            className="bg-green-600 hover:bg-green-700 text-white"
          >
            הבנתי
          </AlertDialogAction>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\HomePage.tsx:
==================================================
"use client";

import React from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { useSession } from "next-auth/react";
import Link from "next/link";
import {
  Heart,
  Users,
  Shield,
  MessageCircle,
  ArrowLeft,
  ClipboardList,
} from "lucide-react";
import { ClipboardCheck } from "lucide-react";
// Type definitions
interface FeatureCardProps {
  icon: React.ReactNode;
  title: string;
  description: string;
}

interface StepProps {
  number: string;
  title: string;
  description: string;
}

interface TestimonialCardProps {
  text: string;
  author: string;
}

// Component for feature cards
const FeatureCard: React.FC<FeatureCardProps> = ({
  icon,
  title,
  description,
}) => (
  <Card className="group relative overflow-hidden border-none shadow-lg transition-all duration-300 hover:shadow-2xl hover:-translate-y-1">
    <div className="absolute inset-0 bg-gradient-to-br from-blue-50 to-purple-50 opacity-0 group-hover:opacity-100 transition-opacity" />
    <CardContent className="relative p-8">
      <div className="mb-6 flex justify-center">
        <div className="p-3 rounded-xl bg-blue-50 group-hover:bg-blue-100 transition-colors">
          {icon}
        </div>
      </div>
      <h3 className="text-xl font-bold mb-3 text-gray-800">{title}</h3>
      <p className="text-gray-600 leading-relaxed">{description}</p>
    </CardContent>
  </Card>
);

// Modernized Step Component
const Step: React.FC<StepProps> = ({ number, title, description }) => (
  <div className="flex gap-6 items-start group">
    <div className="w-12 h-12 rounded-2xl bg-gradient-to-br from-blue-500 to-blue-600 text-white flex items-center justify-center flex-shrink-0 text-lg font-bold shadow-lg group-hover:scale-110 transition-transform">
      {number}
    </div>
    <div className="flex-1">
      <h3 className="text-xl font-bold mb-2 text-gray-800 group-hover:text-blue-600 transition-colors">
        {title}
      </h3>
      <p className="text-gray-600 leading-relaxed">{description}</p>
    </div>
  </div>
);

// Modernized Testimonial Card
const TestimonialCard: React.FC<TestimonialCardProps> = ({ text, author }) => (
  <Card className="group relative overflow-hidden border-none shadow-lg hover:shadow-2xl transition-all duration-300">
    <div className="absolute top-0 right-0 w-32 h-32 bg-gradient-to-br from-blue-100 to-purple-100 opacity-50 rounded-full transform translate-x-16 -translate-y-16" />
    <CardContent className="relative p-8">
      <div className="mb-6 text-4xl text-blue-400 font-serif">❝</div>
      <p className="text-gray-700 leading-relaxed text-lg mb-6">{text}</p>
      <div className="flex items-center">
        <div className="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-blue-600 flex items-center justify-center text-white font-bold">
          {author[0]}
        </div>
        <p className="mr-4 font-semibold text-gray-800">{author}</p>
      </div>
    </CardContent>
  </Card>
);

export default function HomePage() {
  const { data: session } = useSession();

  return (
    <div className="min-h-screen">
      {/* Hero Section - Now with more modern design */}
      <section className="relative py-24 overflow-hidden">
        <div className="absolute inset-0 bg-gradient-to-br from-blue-50 via-purple-50 to-white" />
        <div className="absolute top-0 right-0 w-96 h-96 bg-gradient-to-br from-blue-200 to-purple-200 rounded-full transform translate-x-1/2 -translate-y-1/2 opacity-20" />
        <div className="absolute bottom-0 left-0 w-64 h-64 bg-gradient-to-br from-blue-200 to-purple-200 rounded-full transform -translate-x-1/2 translate-y-1/2 opacity-20" />

        <div className="relative max-w-6xl mx-auto px-4 text-center">
          <h1 className="text-5xl md:text-6xl font-bold text-gray-800 mb-8 leading-tight">
            בניית קשר
            <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">
              {" "}
              משמעותי{" "}
            </span>
            על בסיס ערכים משותפים
          </h1>
          <p className="text-xl md:text-2xl text-gray-600 mb-12 max-w-3xl mx-auto leading-relaxed">
            אנו מחברים בין אנשים איכותיים המחפשים קשר רציני, תוך שמירה על ערכי
            המסורת והצניעות
          </p>

          {!session ? (
            <div className="flex flex-col sm:flex-row gap-4 justify-center items-center">
              <Link href="/auth/register">
                <Button
                  size="lg"
                  className="text-lg px-8 py-6 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 shadow-xl hover:shadow-2xl transition-all duration-300 rounded-xl"
                >
                  הרשמה למערכת
                  <ArrowLeft className="mr-2 h-5 w-5" />
                </Button>
              </Link>
             
              <Link href="/auth/signin">
                <Button
                  variant="outline"
                  size="lg"
                  className="text-lg px-8 py-6 border-2 hover:bg-gray-50 transition-colors duration-300 rounded-xl"
                >
                  התחברות
                </Button>
              </Link>
            </div>
          ) : (
            <Link href="/dashboard">
              <Button
                size="lg"
                className="text-lg px-8 py-6 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 shadow-xl hover:shadow-2xl transition-all duration-300 rounded-xl"
              >
                לאזור האישי
                <ArrowLeft className="mr-2 h-5 w-5" />
              </Button>
            </Link>
            
            
          )}
           <Link href="/questionnaire">
                <FeatureCard
                  icon={<ClipboardList className="w-8 h-8 text-blue-600" />}
                  title="שאלון התאמה"
                  description="מלא/י שאלון מקיף לקבלת הצעות שידוך מותאמות אישית"
                />
              </Link>
        </div>
      </section>

      {/* Features Section - With modern cards */}
      <section className="py-20 px-4 bg-white">
        <div className="max-w-6xl mx-auto">
          <div className="text-center mb-16">
            <h2 className="text-4xl font-bold text-gray-800 mb-4">
              למה
              <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">
                {" "}
                לבחור{" "}
              </span>
              במערכת שלנו?
            </h2>
            <div className="w-24 h-1 bg-gradient-to-r from-blue-600 to-purple-600 mx-auto rounded-full" />
          </div>

          <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-8">
            <FeatureCard
              icon={<Shield className="w-8 h-8 text-blue-600" />}
              title="פרטיות מלאה"
              description="שמירה קפדנית על פרטיות המשתמשים ואבטחת מידע מתקדמת"
            />
            <FeatureCard
              icon={<Users className="w-8 h-8 text-blue-600" />}
              title="התאמה מדויקת"
              description="מערכת חכמה המתאימה בין מועמדים על בסיס ערכים ושאיפות משותפות"
            />
            <FeatureCard
              icon={<Heart className="w-8 h-8 text-blue-600" />}
              title="ליווי אישי"
              description="צוות שדכנים מקצועי ומנוסה לאורך כל התהליך"
            />
            <FeatureCard
              icon={<MessageCircle className="w-8 h-8 text-blue-600" />}
              title="תקשורת בטוחה"
              description="פלטפורמה מאובטחת ליצירת קשר ראשוני בין המועמדים"
            />
          </div>
        </div>
      </section>

      {/* How It Works Section - With modern steps */}
      <section className="py-20 px-4 bg-gray-50 relative overflow-hidden">
        <div className="absolute inset-0 bg-gradient-to-br from-gray-50 to-blue-50 opacity-50" />
        <div className="relative max-w-4xl mx-auto">
          <div className="text-center mb-16">
            <h2 className="text-4xl font-bold text-gray-800 mb-4">
              <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">
                איך זה{" "}
              </span>
              עובד?
            </h2>
            <div className="w-24 h-1 bg-gradient-to-r from-blue-600 to-purple-600 mx-auto rounded-full" />
          </div>

          <div className="space-y-12">
            <Step
              number="1"
              title="הרשמה למערכת"
              description="מילוי פרופיל אישי מפורט והגדרת העדפות לחיפוש"
            />

            <Step
              number="2"
              title="קבלת הצעות מותאמות"
              description="המערכת מציעה התאמות פוטנציאליות על בסיס הפרופיל וההעדפות"
            />
            <Step
              number="3"
              title="יצירת קשר ראשוני"
              description="תקשורת ראשונית דרך המערכת או באמצעות שדכן/ית"
            />
            <Step
              number="4"
              title="בניית קשר משמעותי"
              description="ליווי מקצועי לאורך התהליך עד ליצירת הקשר המיוחל"
            />
          </div>
        </div>
      </section>

      {/* Testimonials Section - With modern cards */}
      <section className="py-20 px-4">
        <div className="max-w-6xl mx-auto">
          <div className="text-center mb-16">
            <h2 className="text-4xl font-bold text-gray-800 mb-4">
              סיפורי
              <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">
                {" "}
                הצלחה{" "}
              </span>
            </h2>
            <div className="w-24 h-1 bg-gradient-to-r from-blue-600 to-purple-600 mx-auto rounded-full" />
          </div>

          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
            <TestimonialCard
              text="בזכות המערכת הכרתי את בן זוגי. ההתאמה הייתה מדויקת והליווי היה מקצועי ורגיש"
              author="רחל, ירושלים"
            />
            <TestimonialCard
              text="השדכנית שליוותה אותי הבינה בדיוק מה אני מחפש והצליחה להתאים לי את שידוך חיי"
              author="משה, בני ברק"
            />
            <TestimonialCard
              text="המערכת עזרה לי למצוא את האחת בצורה צנועה ומכבדת. ממליץ בחום!"
              author="דוד, פתח תקווה"
            />
          </div>
        </div>
      </section>

      {/* Footer - With modern design */}
      <footer className="bg-gradient-to-br from-gray-900 to-gray-800 text-white py-16 px-4">
        <div className="max-w-6xl mx-auto">
          <div className="grid md:grid-cols-3 gap-12">
            <div>
              <h3 className="font-bold text-xl mb-6 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                ניווט מהיר
              </h3>
              <ul className="space-y-4">
                <li>
                  <Link
                    href="/about"
                    className="hover:text-blue-400 transition-colors"
                  >
                    אודות
                  </Link>
                </li>
                <li>
                  <Link
                    href="/contact"
                    className="hover:text-blue-400 transition-colors"
                  >
                    צור קשר
                  </Link>
                </li>
                <li>
                  <Link
                    href="/faq"
                    className="hover:text-blue-400 transition-colors"
                  >
                    שאלות נפוצות
                  </Link>
                </li>
              </ul>
            </div>
            <div>
              <h3 className="font-bold text-xl mb-6 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                מידע שימושי
              </h3>
              <ul className="space-y-4">
                <li>
                  <Link
                    href="/privacy"
                    className="hover:text-blue-400 transition-colors"
                  >
                    מדיניות פרטיות
                  </Link>
                </li>
                <li>
                  <Link
                    href="/terms"
                    className="hover:text-blue-400 transition-colors"
                  >
                    תנאי שימוש
                  </Link>
                </li>
                <li>
                  <Link
                    href="/accessibility"
                    className="hover:text-blue-400 transition-colors"
                  >
                    נגישות
                  </Link>
                </li>
              </ul>
            </div>
            <div>
              <h3 className="font-bold text-xl mb-6 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                יצירת קשר
              </h3>
              <ul className="space-y-4">
                <li className="flex items-center">
                  <span className="ml-2">📞</span>
                  <span>03-1234567</span>
                </li>
                <li className="flex items-center">
                  <span className="ml-2">📱</span>
                  <span>054-1234567</span>
                </li>
                <li className="flex items-center">
                  <span className="ml-2">✉️</span>
                  <span>info@example.com</span>
                </li>
              </ul>
            </div>
          </div>
          <div className="mt-12 pt-8 border-t border-gray-700">
            <div className="text-center">
              <div className="mb-4">
                <span className="inline-block px-4 py-2 rounded-full bg-gradient-to-r from-blue-500/10 to-purple-500/10 text-blue-400">
                  מחברים לבבות בדרך הנכונה
                </span>
              </div>
              <p className="text-gray-400">© כל הזכויות שמורות 2024</p>
            </div>
          </div>
        </div>
      </footer>

      {/* Floating Contact Button */}
      <div className="fixed bottom-8 left-8 z-50">
        <Button
          size="lg"
          className="rounded-full shadow-xl hover:shadow-2xl transition-all duration-300 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700"
        >
          <MessageCircle className="w-5 h-5 ml-2" />
          דברו איתנו
        </Button>
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\Providers.tsx:
==================================================
"use client";

import { SessionProvider } from "next-auth/react";
import { NotificationProvider } from "@/app/contexts/NotificationContext";

interface ProvidersProps {
  children: React.ReactNode;
}

const Providers: React.FC<ProvidersProps> = ({ children }) => {
  return (
    <SessionProvider>
      <NotificationProvider>{children}</NotificationProvider>
    </SessionProvider>
  );
};

export default Providers;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\UserSuggestions.tsx:
==================================================
"use client";

import React, { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import type { Session } from "next-auth";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Textarea } from "@/components/ui/textarea";
import {
  Heart,
  Clock,
  Check,
  X,
  RulerIcon,
  Calendar,
  MessageCircle,
  AlertCircle,
  Users,
  ThumbsUp,
  ThumbsDown,
  HourglassIcon,
  Briefcase,
  GraduationCap,
  User,
  MapPin,
  Ruler,
  Star,
} from "lucide-react";
import type { Suggestion } from "@/app/types/suggestions";
import type { MeetingFeedback } from "@/types/meetings";
import MeetingFeedbackDialog from "@/app/components/meetings/MeetingFeedbackDialog";

export default function UserSuggestions() {
  const { data: session } = useSession() as { data: Session | null };
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedSuggestion, setSelectedSuggestion] = useState<Suggestion | null>(null);
  const [showResponseDialog, setShowResponseDialog] = useState(false);
  const [showFeedbackDialog, setShowFeedbackDialog] = useState(false);
  const [response, setResponse] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    if (session?.user) {
      loadSuggestions();
    }
  }, [session]);

  const loadSuggestions = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch("/api/suggestions");
      if (!response.ok) {
        throw new Error("Failed to load suggestions");
      }

      const data = await response.json();
      const filteredSuggestions = data.filter((suggestion: Suggestion) => {
        const isSecondParty = suggestion.secondPartyId === session?.user?.id;
        return !(isSecondParty && suggestion.status === "PENDING_FIRST_PARTY");
      });
      setSuggestions(filteredSuggestions);
    } catch (err) {
      console.error("Error loading suggestions:", err);
      setError(err instanceof Error ? err.message : "Failed to load suggestions");
    } finally {
      setLoading(false);
    }
  };

  const handleResponse = async (approved: boolean) => {
    if (!selectedSuggestion) return;

    try {
      setIsSubmitting(true);
      const isFirstParty = selectedSuggestion.firstPartyId === session?.user?.id;

      const newStatus = isFirstParty
        ? approved
          ? "FIRST_PARTY_APPROVED"
          : "FIRST_PARTY_DECLINED"
        : approved
        ? "SECOND_PARTY_APPROVED"
        : "SECOND_PARTY_DECLINED";

      const res = await fetch(`/api/matchmaker/suggestions/${selectedSuggestion.id}/status`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          status: newStatus,
          note: response,
        }),
      });

      if (!res.ok) {
        throw new Error("Failed to update suggestion");
      }

      await loadSuggestions();
      setShowResponseDialog(false);
      setSelectedSuggestion(null);
      setResponse("");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to respond");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleMeetingFeedback = async (feedback: MeetingFeedback) => {
    if (!selectedSuggestion) return;

    try {
      setIsSubmitting(true);
      const lastMeeting = selectedSuggestion.meetings[selectedSuggestion.meetings.length - 1];

      const res = await fetch(
        `/api/matchmaker/suggestions/${selectedSuggestion.id}/meetings/${lastMeeting.id}/feedback`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(feedback),
        }
      );

      if (!res.ok) {
        throw new Error("Failed to submit feedback");
      }

      await loadSuggestions();
      setShowFeedbackDialog(false);
      setSelectedSuggestion(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to submit feedback");
    } finally {
      setIsSubmitting(false);
    }
  };

  const getStatusDisplay = (suggestion: Suggestion) => {
    const isFirstParty = session?.user?.id === suggestion.firstPartyId;

    const statusConfig = {
      PENDING_FIRST_PARTY: {
        text: isFirstParty ? "ממתין לתשובתך" : "ממתין לתשובת הצד הראשון",
        color: "bg-yellow-100 text-yellow-800",
        icon: <Clock className="w-4 h-4" />,
      },
      PENDING_SECOND_PARTY: {
        text: isFirstParty ? "ממתין לתשובת הצד השני" : "ממתין לתשובתך",
        color: "bg-yellow-100 text-yellow-800",
        icon: <Clock className="w-4 h-4" />,
      },
      CONTACT_DETAILS_SHARED: {
        text: "פרטי קשר נשלחו",
        color: "bg-blue-100 text-blue-800",
        icon: <Users className="w-4 h-4" />,
      },
      AWAITING_FIRST_DATE_FEEDBACK: {
        text: "נא למלא משוב על הפגישה",
        color: "bg-purple-100 text-purple-800",
        icon: <MessageCircle className="w-4 h-4" />,
      },
      THINKING_AFTER_DATE: {
        text: "בתהליך חשיבה",
        color: "bg-indigo-100 text-indigo-800",
        icon: <HourglassIcon className="w-4 h-4" />,
      },
      DATING: {
        text: "בתהליך היכרות",
        color: "bg-green-100 text-green-800",
        icon: <Heart className="w-4 h-4" />,
      },
      PROCEEDING_TO_SECOND_DATE: {
        text: "ממשיכים לדייט שני",
        color: "bg-green-100 text-green-800",
        icon: <ThumbsUp className="w-4 h-4" />,
      },
      ENDED_AFTER_FIRST_DATE: {
        text: "הסתיים אחרי דייט ראשון",
        color: "bg-red-100 text-red-800",
        icon: <ThumbsDown className="w-4 h-4" />,
      },
    };

    const config = statusConfig[suggestion.status as keyof typeof statusConfig] || {
      text: suggestion.status,
      color: "bg-gray-100 text-gray-800",
      icon: <AlertCircle className="w-4 w-4" />,
    };

    return (
      <div className={`flex items-center gap-2 px-3 py-1 rounded-full ${config.color}`}>
        {config.icon}
        <span className="text-sm">{config.text}</span>
      </div>
    );
  };

  const renderActionButtons = (suggestion: Suggestion) => {
    const isFirstParty = session?.user?.id === suggestion.firstPartyId;

    switch (suggestion.status) {
      case "PENDING_FIRST_PARTY":
        return isFirstParty ? (
          <div className="flex gap-2">
            <Button
              variant="default"
              onClick={() => {
                setSelectedSuggestion(suggestion);
                setShowResponseDialog(true);
              }}
              className="flex items-center gap-2 bg-green-600 hover:bg-green-700"
            >
              <Check className="h-4 w-4" />
              מעוניין/ת
            </Button>
            <Button
              variant="outline"
              onClick={() => {
                setSelectedSuggestion(suggestion);
                setShowResponseDialog(true);
              }}
              className="flex items-center gap-2 border-red-200 text-red-600 hover:bg-red-50"
            >
              <X className="h-4 w-4" />
              לא מעוניין/ת
            </Button>
          </div>
        ) : null;

      case "PENDING_SECOND_PARTY":
        return !isFirstParty ? (
          <div className="flex gap-2">
            <Button
              variant="default"
              onClick={() => {
                setSelectedSuggestion(suggestion);
                setShowResponseDialog(true);
              }}
              className="flex items-center gap-2 bg-green-600 hover:bg-green-700"
            >
              <Check className="h-4 w-4" />
              מעוניין/ת
            </Button>
            <Button
              variant="outline"
              onClick={() => {
                setSelectedSuggestion(suggestion);
                setShowResponseDialog(true);
              }}
              className="flex items-center gap-2 border-red-200 text-red-600 hover:bg-red-50"
            >
              <X className="h-4 w-4" />
              לא מעוניין/ת
            </Button>
          </div>
        ) : (
          <div className="text-sm text-gray-500">ממתין לתשובת הצד השני</div>
        );

      case "AWAITING_FIRST_DATE_FEEDBACK":
        return (
          <Button
            onClick={() => {
              setSelectedSuggestion(suggestion);
              setShowFeedbackDialog(true);
            }}
            className="flex items-center gap-2 w-full justify-center"
          >
            <MessageCircle className="h-4 w-4" />
            מילוי משוב פגישה
          </Button>
        );

      case "CONTACT_DETAILS_SHARED":
        const hasScheduledMeeting = suggestion.meetings.some(
          (m) => m.status === "SCHEDULED"
        );
        return hasScheduledMeeting ? null : (
          <div className="text-sm text-gray-600 text-center bg-blue-50 p-3 rounded-md">
            <Clock className="h-4 w-4 inline-block mr-2" />
            נא ליצור קשר לתיאום פגישה
          </div>
        );

      case "THINKING_AFTER_DATE":
        return (
          <div className="text-sm text-purple-600 text-center bg-purple-50 p-3 rounded-md">
            <HourglassIcon className="h-4 w-4 inline-block mr-2" />
            בתהליך חשיבה לאחר הפגישה
          </div>
        );

      case "PROCEEDING_TO_SECOND_DATE":
        return (
          <div className="text-sm text-green-600 text-center bg-green-50 p-3 rounded-md">
            <Calendar className="h-4 w-4 inline-block mr-2" />
            בתהליך תיאום פגישה שנייה
          </div>
        );

      case "ENDED_AFTER_FIRST_DATE":
        return (
          <div className="text-sm text-red-600 text-center bg-red-50 p-3 rounded-md">
            <X className="h-4 w-4 inline-block mr-2" />
            הסתיים לאחר פגישה ראשונה
          </div>
        );

      case "FIRST_PARTY_APPROVED":
        return isFirstParty ? (
          <div className="text-sm text-green-600 text-center bg-green-50 p-3 rounded-md">
            <Check className="h-4 w-4 inline-block mr-2" />
            אישרת את ההצעה, ממתין לצד השני
          </div>
        ) : null;

      default:
        return null;
    }
  };

  if (!session?.user) {
    return (
      <div className="container mx-auto py-8 px-4 text-center">
        <h1 className="text-2xl font-bold text-gray-800">אנא התחבר למערכת</h1>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">טוען...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      {suggestions.length === 0 ? (
        <Card>
          <CardContent className="p-6 text-center">
            <Users className="h-12 w-12 mx-auto mb-4 text-gray-400" />
            <h3 className="text-lg font-medium text-gray-900">אין הצעות שידוכים</h3>
            <p className="mt-2 text-sm text-gray-500">
              עדיין אין הצעות שידוכים פעילות עבורך
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {suggestions.map((suggestion) => (
            <Card key={suggestion.id} className="hover:shadow-lg transition-shadow">
              <CardContent className="p-6">
                {/* Status */}
                <div className="flex justify-between items-center mb-4">
                  {getStatusDisplay(suggestion)}
                  <Clock className="h-4 w-4 text-gray-400" />
                </div>

                {/* Suggestion Details */}
                <div className="space-y-4">
                  <div>
                  <h3 className="font-medium">
                      הצעה מאת {suggestion.matchmaker.firstName} {suggestion.matchmaker.lastName}
                    </h3>

                    {/* מידע על הצד השני */}
                    <div className="mt-4 space-y-2 bg-gray-50 p-4 rounded-lg">
                      <h4 className="font-medium text-lg mb-3">פרטי המועמד/ת:</h4>

                      <div className="grid grid-cols-2 gap-4 text-sm">
                        <div className="flex items-center">
                          <User className="w-4 h-4 text-gray-500 ml-2" />
                          <span className="text-gray-600">שם:</span>
                          <span className="font-medium mr-1">
                            {session?.user?.id === suggestion.firstPartyId
                              ? `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
                              : `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                          </span>
                        </div>

                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 text-gray-500 ml-2" />
                          <span className="text-gray-600">גיל:</span>
                          <span className="font-medium mr-1">
                            {session?.user?.id === suggestion.firstPartyId
                              ? suggestion.secondParty.profile?.age ?? "לא צוין"
                              : suggestion.firstParty.profile?.age ?? "לא צוין"}
                          </span>
                        </div>

                        <div className="flex items-center">
                          <RulerIcon className="w-4 h-4 text-gray-500 ml-2" />
                          <span className="text-gray-600">גובה:</span>
                          <span className="font-medium mr-1">
                            {session?.user?.id === suggestion.firstPartyId
                              ? `${suggestion.secondParty.profile?.height} ס"מ`
                              : `${suggestion.firstParty.profile?.height} ס"מ`}
                          </span>
                        </div>

                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 text-gray-500 ml-2" />
                          <span className="text-gray-600">עיר מגורים:</span>
                          <span className="font-medium mr-1">
                            {session?.user?.id === suggestion.firstPartyId
                              ? suggestion.secondParty.profile?.city
                              : suggestion.firstParty.profile?.city}
                          </span>
                        </div>

                        <div className="flex items-center">
                          <Star className="w-4 h-4 text-gray-500 ml-2" />
                          <span className="text-gray-600">רמת דתיות:</span>
                          <span className="font-medium mr-1">
                            {session?.user?.id === suggestion.firstPartyId
                              ? suggestion.secondParty.profile?.religiousLevel
                              : suggestion.firstParty.profile?.religiousLevel}
                          </span>
                        </div>

                        <div className="flex items-center">
                          <Heart className="w-4 h-4 text-gray-500 ml-2" />
                          <span className="text-gray-600">מצב משפחתי:</span>
                          <span className="font-medium mr-1">
                            {session?.user?.id === suggestion.firstPartyId
                              ? suggestion.secondParty.profile?.maritalStatus
                              : suggestion.firstParty.profile?.maritalStatus}
                          </span>
                        </div>
                      </div>

                      {/* הערות מהשדכן */}
                      {suggestion.notes && (
                        <div className="mt-4 p-3 bg-blue-50 rounded-md">
                          <h5 className="font-medium mb-2">הערות מהשדכן/ית:</h5>
                          <p className="text-gray-700">
                            {session?.user?.id === suggestion.firstPartyId
                              ? suggestion.notes.forFirstParty
                              : suggestion.notes.forSecondParty}
                          </p>
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Meetings */}
                  {suggestion.meetings.length > 0 && (
                    <div className="border-t pt-4">
                      <h4 className="text-sm font-medium mb-2">פגישות</h4>
                      {suggestion.meetings.map((meeting) => (
                        <div key={meeting.id} className="flex items-center justify-between text-sm">
                          <div className="flex items-center gap-2">
                            <Calendar className="h-4 w-4 text-gray-400" />
                            <span>
                              {new Date(meeting.scheduledDate).toLocaleDateString("he-IL")}
                            </span>
                          </div>
                          <span
                            className={`px-2 py-0.5 rounded-full text-xs ${
                              meeting.status === "COMPLETED"
                                ? "bg-green-100 text-green-800"
                                : meeting.status === "SCHEDULED"
                                ? "bg-blue-100 text-blue-800"
                                : "bg-gray-100 text-gray-800"
                            }`}
                          >
                            {meeting.status === "COMPLETED"
                              ? "הושלם"
                              : meeting.status === "SCHEDULED"
                              ? "מתוכנן"
                              : "בוטל"}
                          </span>
                        </div>
                      ))}
                    </div>
                  )}

                  {/* Action Buttons */}
                  <div className="mt-4">{renderActionButtons(suggestion)}</div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      {/* Response Dialog */}
      <AlertDialog open={showResponseDialog} onOpenChange={setShowResponseDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>תגובה להצעת השידוך</AlertDialogTitle>
            <AlertDialogDescription>
              אנא הוסף/י הערות או תגובה להצעה (אופציונלי)
            </AlertDialogDescription>
          </AlertDialogHeader>

          <Textarea
            value={response}
            onChange={(e) => setResponse(e.target.value)}
            placeholder="הערות או תגובה..."
            className="min-h-[100px]"
          />

          <AlertDialogFooter>
            <AlertDialogCancel
              onClick={() => {
                setShowResponseDialog(false);
                setSelectedSuggestion(null);
                setResponse("");
              }}
            >
              ביטול
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => handleResponse(false)}
              className="bg-red-600 hover:bg-red-700"
            >
              <X className="ml-2 h-4 w-4" />
              לא מעוניין/ת
            </AlertDialogAction>
            <AlertDialogAction
              onClick={() => handleResponse(true)}
              className="bg-green-600 hover:bg-green-700"
            >
              <Check className="ml-2 h-4 w-4" />
              מעוניין/ת
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Meeting Feedback Dialog */}
      <MeetingFeedbackDialog
        isOpen={showFeedbackDialog}
        onClose={() => {
          setShowFeedbackDialog(false);
          setSelectedSuggestion(null);
        }}
        onSubmit={handleMeetingFeedback}
        meetingId={
          selectedSuggestion?.meetings[selectedSuggestion.meetings.length - 1]?.id || ""
        }
      />

      {/* Error Dialog */}
      {error && (
        <AlertDialog open={!!error} onOpenChange={() => setError(null)}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>שגיאה</AlertDialogTitle>
              <AlertDialogDescription>{error}</AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogAction onClick={() => setError(null)}>
                הבנתי
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\layout\Navbar.tsx:
==================================================
"use client";


import { Bell } from "lucide-react";
import React, { useEffect, useState } from "react";
import Link from "next/link";
import { useSession, signOut } from "next-auth/react";
import { usePathname } from "next/navigation";
import { Button } from "@/components/ui/button";
import AvailabilityStatus from "@/components/AvailabilityStatus";
import { useLanguage } from "@/app/contexts/LanguageContext";
import { useNotifications } from "@/app/contexts/NotificationContext";
import {
 Home,
 Users,
 User,
 LogOut,
 LogIn,
 UserPlus,
 MessageCircle,
 Settings,
 Heart,
 ClipboardList,
} from "lucide-react";
import type { Session } from "next-auth";

interface NotificationCount {
 availabilityRequests: number;
 messages: number;
 total: number;
}

const Navbar = () => {
 const { data: session } = useSession() as { data: Session | null };
 const pathname = usePathname();
/*  const { notifications } = useNotifications(); */
 const isActive = (path: string) => pathname === path;
 const isMatchmaker = session?.user?.role === "MATCHMAKER";
 const { language, setLanguage } = useLanguage();

 const handleSignOut = () => {
   signOut({ callbackUrl: "/" });
 };

 const getInitials = () => {
   const fullName = session?.user?.name;
   if (!fullName) return "";

   const [firstName, lastName] = fullName.split(" ");
   return `${firstName?.[0] || ""}${lastName?.[0] || ""}`;
 };

 const LanguageToggle = () => (
   <Button
     variant="outline"
     size="sm"
     onClick={() => setLanguage(language === "he" ? "en" : "he")}
     className="min-w-[2.5rem] font-medium"
   >
     {language === "he" ? "EN" : "עב"}
   </Button>
 );

 return (
   <nav className="bg-white shadow-sm border-b sticky top-0 z-50">
     <div className="container mx-auto px-4">
       <div className="flex justify-between items-center h-16">
         <Link href="/" className="flex items-center space-x-2">
           <Heart className="h-6 w-6 text-indigo-600" />
           <span className="text-xl font-bold">מערכת שידוכים</span>
         </Link>

         <div className="flex items-center gap-2 md:gap-4">
           <Link href="/">
             <Button variant={isActive("/") ? "default" : "ghost"}>
               <Home className="ml-2 h-4 w-4" />
               דף הבית
             </Button>
           </Link>

           {session && (
             <>
               {isMatchmaker ? (
                 <>
                   <Link href="/matchmaker/dashboard">
                     <Button variant={isActive("/matchmaker/dashboard") ? "default" : "ghost"}>
                       <ClipboardList className="ml-2 h-4 w-4" />
                       לוח בקרה
                     </Button>
                   </Link>
                   <Link href="/matchmaker/suggestions">
                     <Button variant={isActive("/matchmaker/suggestions") ? "default" : "ghost"}>
                       <Heart className="ml-2 h-4 w-4" />
                       הצעות שידוך
                     </Button>
                   </Link>
                   <Link href="/matchmaker/clients">
                     <Button variant={isActive("/matchmaker/clients") ? "default" : "ghost"}>
                       <Users className="ml-2 h-4 w-4" />
                       מועמדים
                     </Button>
                   </Link>
                 </>
               ) : (
                 <>
                   <Link href="/matches">
                     <Button variant={isActive("/matches") ? "default" : "ghost"}>
                       <Users className="ml-2 h-4 w-4" />
                       שידוכים זמינים
                     </Button>
                   </Link>
                 </>
               )}

               <Link href="/messages">
                 <Button variant={isActive("/messages") ? "default" : "ghost"} className="relative">
                   <MessageCircle className="ml-2 h-4 w-4" />
                   הודעות
                  {/*  {notifications.total > 0 && (
                     <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs w-5 h-5 rounded-full flex items-center justify-center">
                       {notifications.total}
                     </span>
                   )} */}
                 </Button>
               </Link>
             </>
           )}
         </div>

         <div className="flex items-center gap-2">
           <LanguageToggle />

           {session ? (
             <>
               <AvailabilityStatus />
               <div className="border-l border-gray-200 h-6 mx-2" />
               <div className="flex items-center gap-2">
                 <div className="w-8 h-8 rounded-full bg-indigo-100 flex items-center justify-center text-indigo-600 font-semibold text-sm">
                   {getInitials()}
                 </div>
                 <Link href="/profile">
                   <Button variant={isActive("/profile") ? "default" : "ghost"}>
                     <User className="ml-2 h-4 w-4" />
                     פרופיל אישי
                   </Button>
                 </Link>
                 <Link href="/settings">
                   <Button variant={isActive("/settings") ? "default" : "ghost"}>
                     <Settings className="ml-2 h-4 w-4" />
                     הגדרות חשבון
                   </Button>
                 </Link>
                 <Button
                   variant="ghost"
                   onClick={handleSignOut}
                   className="whitespace-nowrap text-red-600 hover:text-red-700 hover:bg-red-50"
                 >
                   <LogOut className="ml-2 h-4 w-4" />
                   התנתקות
                 </Button>
               </div>
             </>
           ) : (
             <>
               <Link href="/auth/signin">
                 <Button variant="ghost">
                   <LogIn className="ml-2 h-4 w-4" />
                   התחברות
                 </Button>
               </Link>
               <Link href="/auth/register">
                 <Button
                   variant="default"
                   className="whitespace-nowrap bg-gradient-to-r from-indigo-600 to-indigo-700 hover:from-indigo-700 hover:to-indigo-800"
                 >
                   <UserPlus className="ml-2 h-4 w-4" />
                   הרשמה למערכת
                 </Button>
               </Link>
             </>
           )}
         </div>
       </div>
     </div>
   </nav>
 );
};

export default Navbar;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\matchmaker\AvailabilityCheckButton.tsx:
==================================================
// components/matchmaker/AvailabilityCheckButton.tsx

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { AlertCircle, Loader2 } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import type { Client } from "@/app/types/matchmaker";

interface Props {
  client: Client;
  onCheckAvailability: (clientId: string) => Promise<void>;
}

export default function AvailabilityCheckButton({ client, onCheckAvailability }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");

  const handleCheck = async () => {
    try {
      setIsLoading(true);
      setError("");
      await onCheckAvailability(client.id);
      setIsOpen(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to check availability");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      <Button
        onClick={() => setIsOpen(true)}
        variant="outline"
        className="w-full"
        disabled={isLoading}
      >
        <AlertCircle className="ml-2 h-4 w-4" />
        בדוק זמינות
      </Button>

      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>בדיקת זמינות</DialogTitle>
          </DialogHeader>

          <div className="py-4">
            <p>
              האם לשלוח בדיקת זמינות ל{client.firstName} {client.lastName}?
            </p>

            {error && (
              <Alert variant="destructive" className="mt-4">
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button onClick={handleCheck} disabled={isLoading}>
              {isLoading ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                "שלח בדיקה"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\matchmaker\AvailabilityInquiryResponse.tsx:
==================================================
// components/matchmaker/AvailabilityInquiryResponse.tsx

import { useEffect, useState } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2, CheckCircle, XCircle } from "lucide-react";
import type { AvailabilityInquiry } from "@prisma/client";

interface Props {
  inquiryId: string;
}
interface ExtendedInquiry extends AvailabilityInquiry {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: {
    firstName: string;
    lastName: string;
  };
  secondParty: {
    firstName: string;
    lastName: string;
  };
}
export default function AvailabilityInquiryResponse({ inquiryId }: Props) {
  const [inquiry, setInquiry] = useState<ExtendedInquiry | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [note, setNote] = useState("");
  const [error, setError] = useState("");

  useEffect(() => {
    loadInquiry();
  }, [inquiryId]);

  const loadInquiry = async () => {
    try {
      const response = await fetch(`/api/matchmaker/inquiries/${inquiryId}`);
      if (!response.ok) throw new Error("Failed to load inquiry");
      const data = await response.json();
      setInquiry(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load inquiry");
    } finally {
      setIsLoading(false);
    }
  };

  const handleResponse = async (isAvailable: boolean) => {
    try {
      setIsSubmitting(true);
      setError("");

      const response = await fetch(
        `/api/matchmaker/inquiries/${inquiryId}/respond`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ isAvailable, note }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to submit response");
      }

      // Redirect to matches page after successful response
      window.location.href = "/matches";
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to submit response"
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loader2 className="w-8 h-8 animate-spin" />
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <Card className="max-w-2xl mx-auto">
        <CardHeader>
          <CardTitle>בדיקת זמינות לשידוך</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          {inquiry && (
            <p className="text-gray-600">
              השדכן/ית {inquiry.matchmaker.firstName}{" "}
              {inquiry.matchmaker.lastName}
              מעוניין/ת לבדוק את זמינותך להצעת שידוך
            </p>
          )}

          <div className="space-y-4">
            <label className="block text-sm font-medium">
              הערות (אופציונלי):
            </label>
            <Textarea
              value={note}
              onChange={(e) => setNote(e.target.value)}
              placeholder="הוסף/י הערות..."
              className="w-full"
            />
          </div>

          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <div className="flex gap-4 justify-end">
            <Button
              variant="outline"
              onClick={() => handleResponse(false)}
              disabled={isSubmitting}
              className="bg-red-50 hover:bg-red-100 text-red-600"
            >
              <XCircle className="ml-2 h-4 w-4" />
              לא פנוי/ה כרגע
            </Button>
            <Button
              onClick={() => handleResponse(true)}
              disabled={isSubmitting}
              className="bg-green-600 hover:bg-green-700"
            >
              <CheckCircle className="ml-2 h-4 w-4" />
              פנוי/ה להצעות
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\MatchmakingQuestionnaire.tsx:
==================================================
// src/components/questionnaire/MatchmakingQuestionnaire.tsx

import React, { useState, useMemo, useEffect } from "react";
import { useRouter } from "next/navigation";
import QuestionnaireLayout from "./layout/QuestionnaireLayout";
import Welcome from "./onboarding/Welcome";
import TrackSelection from "./onboarding/TrackSelection";
import ValuesWorld from "./worlds/ValuesWorld";
import RelationshipWorld from "./worlds/RelationshipWorld";
import PersonalityWorld from "./worlds/PersonalityWorld";
import PartnerWorld from "./worlds/PartnerWorld";
import ReligionWorld from "./worlds/ReligionWorld";
import QuestionnaireCompletion from "./common/QuestionnaireCompletion";
import { useLanguage } from "@/app/contexts/LanguageContext";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { cn } from "@/lib/utils";
import { storageService } from "@/services/storageService";
import type {
  WorldId,
  UserTrack,
  QuestionnaireSubmission,
  MatchmakingQuestionnaireProps,
  QuestionnaireAnswer,
} from "./types/types";

const ONBOARDING_STEPS = {
  WELCOME: "WELCOME",
  TRACK_SELECTION: "TRACK_SELECTION",
  WORLDS: "WORLDS",
  COMPLETED: "COMPLETED",
} as const;

type OnboardingStep = keyof typeof ONBOARDING_STEPS;

const WORLD_ORDER: WorldId[] = [
  "PERSONALITY",
  "RELATIONSHIP",
  "VALUES",
  "RELIGION",
  "PARTNER",
];

export default function MatchmakingQuestionnaire({
  userId,
  onComplete,
}: MatchmakingQuestionnaireProps) {
  const router = useRouter();
  const { language } = useLanguage();
  const sessionId = useMemo(() => `session_${Date.now()}`, []);

  // Basic State
  const [currentStep, setCurrentStep] = useState<OnboardingStep>("WELCOME");
  const [currentWorld, setCurrentWorld] = useState<WorldId>("VALUES");
  const [userTrack, setUserTrack] = useState<UserTrack>("SECULAR");
  const [answers, setAnswers] = useState<QuestionnaireAnswer[]>([]);
  const [completedWorlds, setCompletedWorlds] = useState<WorldId[]>([]);
  const [startTime] = useState(() => new Date().toISOString());

  // Submission state
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastSaveAttempt, setLastSaveAttempt] = useState(Date.now());
  const [toast, setToast] = useState<{
    message: string;
    type: "success" | "error" | "info";
    isVisible: boolean;
  }>({
    message: "",
    type: "info",
    isVisible: false,
  });

  const showToast = (
    message: string,
    type: "success" | "error" | "info" = "info"
  ) => {
    setToast({ message, type, isVisible: true });
    setTimeout(() => {
      setToast((prev) => ({ ...prev, isVisible: false }));
    }, 3000);
  };
  // Load existing answers when component mounts
  useEffect(() => {
    const loadExistingAnswers = async () => {
      try {
        const response = await fetch("/api/questionnaire");
        const data = await response.json();

        if (data.success && data.data) {
          // Combine all answers from different worlds
          const allAnswers = [
            ...(data.data.valuesAnswers || []),
            ...(data.data.personalityAnswers || []),
            ...(data.data.relationshipAnswers || []),
            ...(data.data.partnerAnswers || []),
            ...(data.data.religionAnswers || []),
          ];

          // Update states
          setAnswers(allAnswers);
          setCompletedWorlds(data.data.worldsCompleted || []);
          setCurrentStep(data.data.completed ? "COMPLETED" : "WORLDS");
        }
      } catch (err) {
        console.error("Failed to load existing answers:", err);
        setError("אירעה שגיאה בטעינת התשובות הקיימות");
      }
    };

    if (userId) {
      loadExistingAnswers();
    }
  }, [userId]);

  const handleAnswer = (questionId: string, value: any) => {
    setError(null);
    const newAnswer: QuestionnaireAnswer = {
      questionId,
      worldId: currentWorld,
      value,
      answeredAt: new Date().toISOString(),
    };

    setAnswers((prev) => {
      const filtered = prev.filter((a) => a.questionId !== questionId);
      return [...filtered, newAnswer];
    });
  };

  const prepareSubmissionData = (): QuestionnaireSubmission => {
    const isCompleted = completedWorlds.length === WORLD_ORDER.length;
    return {
      userId: userId || sessionId,
      answers: answers,
      worldsCompleted: completedWorlds,
      completed: isCompleted,
      startedAt: startTime,
      completedAt: isCompleted ? new Date().toISOString() : undefined,
    };
  };

  const validateSubmission = (data: QuestionnaireSubmission): boolean => {
    if (!data.userId) return false;
    if (!Array.isArray(data.answers) || data.answers.length === 0) return false;
    if (!Array.isArray(data.worldsCompleted)) return false;
    if (typeof data.completed !== "boolean") return false;
    if (!data.startedAt) return false;
    if (data.completed && !data.completedAt) return false;
    return true;
  };

  const getNextWorld = (currentWorldId: WorldId): WorldId | null => {
    const currentIndex = WORLD_ORDER.indexOf(currentWorldId);
    if (currentIndex < WORLD_ORDER.length - 1) {
      return WORLD_ORDER[currentIndex + 1];
    }
    return null;
  };

  const handleWorldChange = (newWorld: WorldId) => {
    setCurrentWorld(newWorld);
    setError(null);
  };

  const handleWorldComplete = async (worldId: WorldId) => {
    try {
      if (!completedWorlds.includes(worldId)) {
        setCompletedWorlds((prev) => [...prev, worldId]);
      }

      const nextWorld = getNextWorld(worldId);
      if (!nextWorld) {
        setCurrentStep("COMPLETED");
      } else {
        setCurrentWorld(nextWorld);
      }
    } catch (err) {
      setError("אירעה שגיאה בשמירת ההתקדמות. אנא נסה שוב.");
      console.error("Error completing world:", err);
    }
  };

  const handleQuestionnaireComplete = async () => {
    setIsSaving(true);
    setError(null);

    try {
      const submissionData = prepareSubmissionData();

      if (!validateSubmission(submissionData)) {
        throw new Error("Invalid submission data");
      }

      // אם המשתמש לא מחובר, שומרים בlocal ומעבירים לדף התחברות
      if (!userId) {
        localStorage.setItem(
          "tempQuestionnaire",
          JSON.stringify(submissionData)
        );
        router.push("/auth/signin");
        return;
      }

      // שמירה בשרת
      const response = await fetch("/api/questionnaire", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(submissionData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to save questionnaire");
      }

      if (onComplete) {
        onComplete();
      }

      showToast("השאלון נשמר בהצלחה", "success");
    } catch (err) {
      console.error("Failed to save questionnaire:", err);
      setError(
        err instanceof Error
          ? err.message
          : "אירעה שגיאה בשמירת השאלון. אנא נסה שוב."
      );
      showToast("אירעה שגיאה בשמירת השאלון", "error");
    } finally {
      setIsSaving(false);
    }
  };

  function renderCurrentWorld() {
    const worldProps = {
      onAnswer: handleAnswer,
      onComplete: () => handleWorldComplete(currentWorld),
      onBack: () => router.push("/questionnaire/map"),
      answers: answers.filter((a) => a.worldId === currentWorld),
      isCompleted: completedWorlds.includes(currentWorld),
      language,
    };

    switch (currentWorld) {
      case "VALUES":
        return <ValuesWorld {...worldProps} />;
      case "RELATIONSHIP":
        return <RelationshipWorld {...worldProps} />;
      case "PERSONALITY":
        return <PersonalityWorld {...worldProps} />;
      case "PARTNER":
        return <PartnerWorld {...worldProps} />;
      case "RELIGION":
        return <ReligionWorld {...worldProps} />;
      default:
        return <div>עולם לא נמצא</div>;
    }
  }

  function renderCurrentStep() {
    switch (currentStep) {
      case "WELCOME":
        return (
          <Welcome
            onStart={() => setCurrentStep("TRACK_SELECTION")}
            onLearnMore={() => router.push("/about")}
            isLoggedIn={!!userId}
          />
        );

      case "TRACK_SELECTION":
        return (
          <TrackSelection
            onSelect={(track: UserTrack) => {
              setUserTrack(track);
              setCurrentStep("WORLDS");
            }}
            onBack={() => setCurrentStep("WELCOME")}
            selectedTrack={userTrack}
          />
        );

      case "WORLDS":
        return (
          <QuestionnaireLayout
            currentWorld={currentWorld}
            userTrack={userTrack}
            completedWorlds={completedWorlds}
            onWorldChange={handleWorldChange}
            onExit={() => router.push("/dashboard")}
            onSaveProgress={handleQuestionnaireComplete}
          >
            {renderCurrentWorld()}
          </QuestionnaireLayout>
        );

      case "COMPLETED":
        return (
          <QuestionnaireCompletion
            onSendToMatching={handleQuestionnaireComplete}
            isLoading={isSaving}
            isLoggedIn={!!userId}
          />
        );

      default:
        return <div>שגיאה בטעינת השלב</div>;
    }
  }

  return (
    <div
      className={cn("min-h-screen", language === "he" ? "dir-rtl" : "dir-ltr")}
    >
      {error && (
        <Alert variant="destructive" className="m-4">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {renderCurrentStep()}
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\utils.ts:
==================================================
import { 
    Question,
    QuestionType,
    Answer,
    SingleChoiceAnswer,
    MultiChoiceAnswer,
    ScaleAnswer,
    RankingAnswer,
    OpenTextAnswer,
    BudgetAllocationAnswer,
    IconChoiceAnswer,
    SliderAnswer,
    ScenarioAnswer,
    ComparisonAnswer,
    QuestionDepth,
    WorldId,
    QuestionnaireProgress,
    UserTrack,
    ProgressStatus
  } from './types';
  import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";
  // Type guards

  export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
  }
  function isOpenTextAnswer(answer: Answer): answer is OpenTextAnswer {
    return answer.type === 'openText';
  }
  
  function isMultiChoiceAnswer(answer: Answer): answer is MultiChoiceAnswer {
    return answer.type === 'multiChoice';
  }
  
  function isBudgetAllocationAnswer(answer: Answer): answer is BudgetAllocationAnswer {
    return answer.type === 'budgetAllocation';
  }
  
  // Interfaces
  interface Contradiction {
    questionIds: [string, string];
    severity: 'low' | 'medium' | 'high';
    description: string;
  }
  
  // בדיקת תקינות תשובה
  export const validateAnswer = (question: Question, value: unknown): string | null => {
    if (question.isRequired && !value) {
      return 'שדה חובה';
    }
  
    switch (question.type) {
      case 'openText': {
        const textValue = value as string;
        if (typeof textValue === 'string') {
          if (question.minLength && textValue.length < question.minLength) {
            return `מינימום ${question.minLength} תווים נדרש`;
          }
          if (question.maxLength && textValue.length > question.maxLength) {
            return `מקסימום ${question.maxLength} תווים מותר`;
          }
        }
        break;
      }
  
      case 'multiChoice': {
        const selections = value as string[];
        if (Array.isArray(selections)) {
          if (question.minSelections && selections.length < question.minSelections) {
            return `יש לבחור לפחות ${question.minSelections} אפשרויות`;
          }
          if (question.maxSelections && selections.length > question.maxSelections) {
            return `ניתן לבחור עד ${question.maxSelections} אפשרויות`;
          }
        }
        break;
      }
  
      case 'budgetAllocation': {
        const allocations = value as Record<string, number>;
        if (typeof allocations === 'object' && allocations !== null) {
          const total = Object.values(allocations).reduce(
            (sum: number, val: number) => sum + val,
            0
          );
          if (total !== question.totalPoints) {
            return `סך כל הנקודות חייב להיות ${question.totalPoints}`;
          }
        }
        break;
      }
    }
  
    return null;
  };
  
  // חישוב התקדמות בשאלון
  export const calculateProgress = (
    answers: Record<string, Answer>, 
    questions: Question[]
  ): number => {
    const totalRequired = questions.filter(q => q.isRequired).length;
    const answeredRequired = questions
      .filter(q => q.isRequired)
      .filter(q => answers[q.id]?.status === 'COMPLETE')
      .length;
  
    return Math.round((answeredRequired / totalRequired) * 100);
  };
  
  // בדיקת זמינות עולם תוכן
  export const isWorldAvailable = (
    worldId: WorldId,
    progress: QuestionnaireProgress,
    userTrack: UserTrack
  ): boolean => {
    const world = progress.worldProgress[worldId];
    if (!world) return false;
  
    const requiredWorlds = progress.navigation.availableWorlds;
    const hasCompletedRequired = requiredWorlds.every(
      requiredId => progress.worldProgress[requiredId]?.status === 'COMPLETED'
    );
  
    return hasCompletedRequired;
  };
  
  // חישוב זמן משוער לסיום
  export const estimateTimeRemaining = (
    progress: QuestionnaireProgress,
    averageTimePerQuestion: number
  ): number => {
    const totalQuestions = Object.values(progress.worldProgress).reduce(
      (sum: number, world) => sum + world.completion.basic.totalQuestions,
      0
    );
    
    const answeredQuestions = Object.values(progress.worldProgress).reduce(
      (sum: number, world) => sum + world.completion.basic.completedQuestions,
      0
    );
  
    return (totalQuestions - answeredQuestions) * averageTimePerQuestion;
  };
  
  // סינון שאלות לפי מסלול המשתמש
  export const filterQuestionsByTrack = (
    questions: Question[],
    userTrack: UserTrack
  ): Question[] => {
    return questions.filter(question => 
      !question.relevantTracks || question.relevantTracks.includes(userTrack)
    );
  };
  
  // בדיקת סתירות בתשובות
  export const checkAnswerConsistency = (
    answers: Record<string, Answer>
  ): Contradiction[] => {
    const contradictions: Contradiction[] = [];
    // הלוגיקה לזיהוי סתירות תתווסף כאן
    return contradictions;
  };
  
  // ניהול שמירה אוטומטית
  export const autoSaveInterval = 120000; // 2 דקות
  
  export const shouldTriggerAutoSave = (
    lastSaveTime: Date,
    currentTime: Date = new Date()
  ): boolean => {
    return currentTime.getTime() - lastSaveTime.getTime() >= autoSaveInterval;
  };
  
  interface AnalysisResult {
    completeness: number;
    thoughtfulness: number;
    consistency: number;
  }
  
  // עיבוד וניתוח תשובות
  export const analyzeAnswers = (
    answers: Record<string, Answer>
  ): AnalysisResult => {
    const totalAnswers = Object.keys(answers).length;
    const completeAnswers = Object.values(answers).filter(
      a => a.status === 'COMPLETE'
    ).length;
  
    const completeness = (completeAnswers / totalAnswers) * 100;
  
    const thoughtfulness = Object.values(answers).reduce((sum: number, answer) => {
      if (isOpenTextAnswer(answer) && typeof answer.value === 'string') {
        return sum + Math.min(answer.value.length / 100, 1);
      }
      return sum + 0.5;
    }, 0) / totalAnswers * 100;
  
    const contradictions = checkAnswerConsistency(answers);
    const consistency = Math.max(0, 100 - contradictions.length * 10);
  
    return {
      completeness,
      thoughtfulness,
      consistency
    };
  };
  
  // פונקציות עזר לניהול UI
  export const getDepthColor = (depth: QuestionDepth): string => {
    switch (depth) {
      case 'BASIC':
        return 'text-blue-500';
      case 'ADVANCED':
        return 'text-purple-500';
      case 'EXPERT':
        return 'text-green-500';
      default:
        return 'text-gray-500';
    }
  };
  
  export const formatTimeRemaining = (seconds: number): string => {
    if (seconds < 60) {
      return `${seconds} שניות`;
    }
    
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) {
      return `${minutes} דקות`;
    }
    
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return `${hours} שעות ו-${remainingMinutes} דקות`;
  };
  
  // ניהול התקדמות והמלצות
  export const getNextRecommendedQuestion = (
    currentQuestionId: string,
    answers: Record<string, Answer>,
    questions: Question[]
  ): string | null => {
    const currentIndex = questions.findIndex(q => q.id === currentQuestionId);
    if (currentIndex === -1) return null;
  
    for (let i = currentIndex + 1; i < questions.length; i++) {
      const question = questions[i];
      if (!question.dependsOn || 
          question.dependsOn.every(dependencyId => answers[dependencyId]?.status === 'COMPLETE')) {
        return question.id;
      }
    }
  
    return null;
  };
  
  // פונקציות עזר לפענוח והצגת נתונים
  export const getAnswerDisplayValue = (answer: Answer): string => {
    const value = answer.value;
    if (value === null || value === undefined) return '';
  
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return value.toString();
    if (typeof value === 'boolean') return value ? 'כן' : 'לא';
    if (Array.isArray(value)) return value.join(', ');
    if (typeof value === 'object') return JSON.stringify(value);
  
    return '';
  };
  
  export const getQuestionSummary = (question: Question, answer: Answer): string => {
    const value = getAnswerDisplayValue(answer);
    return `${question.question}: ${value}`;
  };
  
  // ניהול שגיאות
  export const handleQuestionnaireError = (error: Error): string => {
    console.error('Questionnaire error:', error);
    
    if (error.message.includes('validation')) {
      return 'נמצאה שגיאה באחת התשובות. אנא בדוק/י את הנתונים שהוזנו.';
    }
    
    if (error.message.includes('network')) {
      return 'אירעה שגיאת תקשורת. אנא בדוק/י את החיבור לאינטרנט ונסה/י שוב.';
    }
    
    return 'אירעה שגיאה. אנא נסה/י שוב מאוחר יותר.';
  };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\common\AnswerInput.tsx:
==================================================
import React, { useState, useEffect } from "react";
import { Slider } from "@/components/ui/slider";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Checkbox } from "@/components/ui/checkbox";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input"; // Added for multiSelectWithOther
import { Progress } from "@/components/ui/progress";
import { Card } from "@/components/ui/card";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Trash2, X, Plus } from "lucide-react";
import type {
  Question,
  Option,
  AnswerValue,
  AnswerInputProps,
} from "../types/types";
import { cn } from "@/lib/utils";

export default function AnswerInput({
  question,
  value,
  onChange,
  onClear,
  language = "he",
  showValidation = false,
  className = "",
}: AnswerInputProps) {
  const [internalValue, setInternalValue] = useState<any>(value);
  const [error, setError] = useState<string | null>(null);
  const [customValue, setCustomValue] = useState<string>(""); // Added for multiSelectWithOther

  useEffect(() => {
    setInternalValue(value);
  }, [value]);

  const handleValueChange = (newValue: any) => {
    // אם לוחצים על אותו ערך שכבר נבחר, מנקים את הבחירה
    if (newValue === internalValue) {
      handleClear();
      return;
    }

    setInternalValue(newValue);
    setError(null);
    onChange?.(newValue);
  };

  const handleClear = () => {
    // Set type-appropriate empty value
    let emptyValue: AnswerValue;
    switch (question.type) {
      case "multiChoice":
      case "multiSelect":
      case "multiSelectWithOther":
        emptyValue = [];
        break;
      case "budgetAllocation":
        emptyValue = {};
        break;
      case "openText":
        emptyValue = "";
        break;
      case "scale":
      case "singleChoice":
      case "scenario":
      case "iconChoice":
      default:
        emptyValue = undefined;
    }

    setInternalValue(emptyValue);
    setCustomValue(""); // Clear custom value for multiSelectWithOther
    setError(null);
    onChange?.(emptyValue);
  };

  const renderInput = () => {
    switch (question.type) {
      case "singleChoice":
        return (
          <div className="space-y-2">
            {question.options?.map((option) => (
              <div
                key={option.value}
                className={cn(
                  "p-3 border rounded-lg cursor-pointer transition-all",
                  "hover:bg-gray-50 flex items-center justify-between",
                  internalValue === option.value && "bg-blue-50 border-blue-500"
                )}
                onClick={() => handleValueChange(option.value)}
              >
                <div className="flex items-center gap-2">
                  {option.icon}
                  <span>{option.text}</span>
                </div>
                {internalValue === option.value && !question.isRequired && (
                  <X
                    className="w-4 h-4 text-gray-500 hover:text-red-500"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleClear();
                    }}
                  />
                )}
              </div>
            ))}
          </div>
        );

      case "multiChoice":
      case "multiSelect":
        const selectedValues = Array.isArray(internalValue)
          ? internalValue
          : [];
        return (
          <div className="space-y-2">
            {question.options?.map((option) => (
              <div
                key={option.value}
                className={cn(
                  "p-3 border rounded-lg cursor-pointer transition-all",
                  "hover:bg-gray-50 flex items-center justify-between",
                  selectedValues.includes(option.value) &&
                    "bg-blue-50 border-blue-500"
                )}
                onClick={() => {
                  const newValues = selectedValues.includes(option.value)
                    ? selectedValues.filter((v) => v !== option.value)
                    : [...selectedValues, option.value];
                  handleValueChange(newValues);
                }}
              >
                <div className="flex items-center gap-2">
                  {option.icon}
                  <span>{option.text}</span>
                </div>
              </div>
            ))}
          </div>
        );

      case "multiSelectWithOther":
        const selectedWithOtherValues = Array.isArray(internalValue)
          ? internalValue
          : [];
        return (
          <div className="space-y-4">
            {/* Regular options */}
            {question.options?.map((option) => (
              <div
                key={option.value}
                className={cn(
                  "p-3 border rounded-lg cursor-pointer transition-all",
                  "hover:bg-gray-50 flex items-center justify-between",
                  selectedWithOtherValues.includes(option.value) &&
                    "bg-blue-50 border-blue-500"
                )}
                onClick={() => {
                  const newValues = selectedWithOtherValues.includes(option.value)
                    ? selectedWithOtherValues.filter((v) => v !== option.value)
                    : [...selectedWithOtherValues, option.value];
                  handleValueChange(newValues);
                }}
              >
                <div className="flex items-center gap-2">
                  {option.icon}
                  <span>{option.text}</span>
                </div>
              </div>
            ))}
            
            {/* Custom input section */}
            <div className="space-y-2">
              <Label>אחר</Label>
              <div className="flex gap-2">
                <Input
                  value={customValue}
                  onChange={(e) => setCustomValue(e.target.value)}
                  placeholder="הוסף אפשרות אחרת..."
                  className="flex-1"
                />
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => {
                    if (customValue.trim()) {
                      const newValues = [...selectedWithOtherValues, `custom:${customValue.trim()}`];
                      handleValueChange(newValues);
                      setCustomValue("");
                    }
                  }}
                  disabled={!customValue.trim()}
                >
                  <Plus className="w-4 h-4" />
                </Button>
              </div>
            </div>

            {/* Custom values display */}
            <div className="space-y-2">
              {selectedWithOtherValues
                .filter(v => v.startsWith('custom:'))
                .map((customVal, index) => (
                  <div
                    key={index}
                    className="flex items-center justify-between p-2 bg-blue-50 rounded-lg"
                  >
                    <span>{customVal.replace('custom:', '')}</span>
                    <X
                      className="w-4 h-4 text-gray-500 hover:text-red-500 cursor-pointer"
                      onClick={() => {
                        const newValues = selectedWithOtherValues.filter(v => v !== customVal);
                        handleValueChange(newValues);
                      }}
                    />
                  </div>
                ))}
            </div>
          </div>
        );

      case "scenario":
        return (
          <div className="space-y-2">
            {question.options?.map((option, index) => (
              <div
                key={index}
                className={cn(
                  "p-4 border rounded-lg cursor-pointer transition-all",
                  "hover:bg-gray-50 flex items-center justify-between",
                  internalValue === (option.value || option.text) &&
                    "bg-blue-50 border-blue-500"
                )}
                onClick={() => handleValueChange(option.value || option.text)}
              >
                <div>
                  <div className="font-medium">{option.text}</div>
                  {option.description && (
                    <div className="text-sm text-gray-600 mt-1">
                      {option.description}
                    </div>
                  )}
                </div>
                {internalValue === (option.value || option.text) &&
                  !question.isRequired && (
                    <X
                      className="w-4 h-4 text-gray-500 hover:text-red-500"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleClear();
                      }}
                    />
                  )}
              </div>
            ))}
          </div>
        );

      case "iconChoice":
        return (
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {question.options?.map((option) => (
              <TooltipProvider key={option.value}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Card
                      className={cn(
                        "p-4 cursor-pointer transition-all hover:shadow-md relative",
                        "flex flex-col items-center gap-2 text-center",
                        internalValue === option.value &&
                          "ring-2 ring-blue-500 bg-blue-50"
                      )}
                      onClick={() => handleValueChange(option.value)}
                    >
                      {internalValue === option.value &&
                        !question.isRequired && (
                          <X
                            className="absolute top-2 right-2 w-4 h-4 text-gray-500 hover:text-red-500"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleClear();
                            }}
                          />
                        )}
                      <div className="text-3xl">{option.icon}</div>
                      <span className="text-sm font-medium">{option.text}</span>
                    </Card>
                  </TooltipTrigger>
                  {option.description && (
                    <TooltipContent>
                      <p>{option.description}</p>
                    </TooltipContent>
                  )}
                </Tooltip>
              </TooltipProvider>
            ))}
          </div>
        );

      case "openText":
        return (
          <div className="space-y-2">
            <Textarea
              value={internalValue as string}
              onChange={(e) => handleValueChange(e.target.value)}
              placeholder={question.placeholder}
              className="min-h-[100px]"
              maxLength={question.maxLength}
            />
            <div className="flex justify-between items-center">
              {question.maxLength && (
                <div className="text-sm text-gray-500">
                  {((internalValue as string) || "").length} /{" "}
                  {question.maxLength}
                </div>
              )}
              {internalValue && !question.isRequired && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={handleClear}
                  className="text-red-500 hover:text-red-700"
                >
                  <X className="w-4 h-4 mr-2" />
                  נקה טקסט
                </Button>
              )}
            </div>
          </div>
        );

      case "budgetAllocation":
        const values = (internalValue as Record<string, number>) || {};
        return (
          <div className="space-y-4">
            {question.categories?.map((category) => (
              <div key={category.label} className="space-y-2">
                <div className="flex justify-between items-center">
                  <Label className="flex items-center gap-2">
                    {category.icon}
                    {category.label}
                  </Label>
                  <span className="text-sm text-gray-500">
                    {(values[category.label] || 0).toFixed(0)}%
                  </span>
                </div>
                <Slider
                  value={[values[category.label] || 0]}
                  min={category.min}
                  max={category.max}
                  step={1}
                  onValueChange={(newValues) => {
                    handleValueChange({
                      ...values,
                      [category.label]: newValues[0],
                    });
                  }}
                />
              </div>
            ))}
            <div className="flex justify-between items-center">
              <div className="text-sm text-gray-500">
                סה"כ:{" "}
                {Object.values(values).reduce(
                  (sum, val) => sum + (val || 0),
                  0
                )}
                %
              </div>
              {Object.keys(values).length > 0 && !question.isRequired && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={handleClear}
                  className="text-red-500 hover:text-red-700"
                >
                  <X className="w-4 h-4 mr-2" />
                  אפס הכל
                </Button>
              )}
            </div>
          </div>
        );

      default:
        return <div>סוג שאלה לא נתמך: {question.type}</div>;
    }
  };

  return (
    <div className={cn("space-y-4", className)}>
      {renderInput()}
      {error && showValidation && (
        <p className="text-sm text-red-500">{error}</p>
      )}
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\common\InteractiveScale.tsx:
==================================================
import React, { useState, useCallback, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Star, Heart, ThumbsUp } from "lucide-react";

interface ScaleOption {
  value: number;
  label: string;
  description?: string;
  icon?: React.ReactNode;
}

interface InteractiveScaleProps {
  min?: number;
  max?: number;
  step?: number;
  defaultValue?: number;
  value?: number;
  onChange?: (value: number) => void;
  onComplete?: (value: number) => void;
  labels?: {
    min: string;
    max: string;
    middle?: string;
  };
  descriptions?: {
    min?: string;
    max?: string;
    middle?: string;
  };
  options?: ScaleOption[];
  mode?: "numeric" | "icons" | "hearts" | "stars" | "thumbs";
  size?: "sm" | "md" | "lg";
  showLabels?: boolean;
  showValue?: boolean;
  showTooltips?: boolean;
  isDisabled?: boolean;
  className?: string;
  required?: boolean;
  name?: string;
  error?: string;
}

const defaultIcons = {
  stars: Star,
  hearts: Heart,
  thumbs: ThumbsUp,
};

export default function InteractiveScale({
  min = 1,
  max = 10,
  step = 1,
  defaultValue,
  value: controlledValue,
  onChange,
  onComplete,
  labels,
  descriptions,
  options,
  mode = "numeric",
  size = "md",
  showLabels = true,
  showValue = true,
  showTooltips = true,
  isDisabled = false,
  className = "",
  required = false,
  name,
  error,
}: InteractiveScaleProps) {
  const [internalValue, setInternalValue] = useState<number | null>(
    defaultValue || null
  );
  const [hoveredValue, setHoveredValue] = useState<number | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  const value = controlledValue !== undefined ? controlledValue : internalValue;

  const handleValueChange = useCallback(
    (newValue: number) => {
      if (!isDisabled) {
        setInternalValue(newValue);
        onChange?.(newValue);
      }
    },
    [isDisabled, onChange]
  );

  const handleClick = useCallback(
    (clickedValue: number) => {
      handleValueChange(clickedValue);
      onComplete?.(clickedValue);
    },
    [handleValueChange, onComplete]
  );

  const handleKeyPress = useCallback(
    (event: React.KeyboardEvent, itemValue: number) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        handleClick(itemValue);
      }
    },
    [handleClick]
  );

  const handleMouseMove = useCallback(
    (event: MouseEvent) => {
      if (isDragging && containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const width = rect.width;
        const percentage = Math.max(0, Math.min(1, x / width));
        const range = max - min;
        const newValue =
          Math.round((percentage * range) / step) * step + min;
        handleValueChange(newValue);
        setHoveredValue(newValue);
      }
    },
    [isDragging, min, max, step, handleValueChange]
  );

  useEffect(() => {
    if (isDragging) {
      window.addEventListener("mousemove", handleMouseMove);
      window.addEventListener("mouseup", () => setIsDragging(false));
    }

    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", () => setIsDragging(false));
    };
  }, [isDragging, handleMouseMove]);

  const getScaleItems = () => {
    if (options) return options;

    const items: ScaleOption[] = [];
    for (let i = min; i <= max; i += step) {
      const item: ScaleOption = {
        value: i,
        label: i.toString(),
      };

      if (mode !== "numeric") {
        const Icon = defaultIcons[mode as keyof typeof defaultIcons];
        item.icon = <Icon className="w-5 h-5" />;
      }

      items.push(item);
    }
    return items;
  };

  const scaleItems = getScaleItems();
  const activeValue = hoveredValue !== null ? hoveredValue : value;

  const sizeClasses = {
    sm: "h-8 text-sm",
    md: "h-10 text-base",
    lg: "h-12 text-lg",
  };

  return (
    <div
      className={cn(
        "relative space-y-2",
        isDisabled && "opacity-50 cursor-not-allowed",
        className
      )}
    >
      <div
        ref={containerRef}
        className={cn(
          "relative flex items-center justify-between gap-1",
          sizeClasses[size]
        )}
        onMouseDown={() => !isDisabled && setIsDragging(true)}
      >
        {showLabels && labels && (
          <div className="absolute -top-6 left-0 right-0 flex justify-between text-sm text-gray-500">
            <span>{labels.min}</span>
            {labels.middle && <span>{labels.middle}</span>}
            <span>{labels.max}</span>
          </div>
        )}

        <div className="relative flex-1 flex items-center justify-between">
          <AnimatePresence>
            {scaleItems.map((item) => (
              <TooltipProvider key={item.value}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <motion.button
                      type="button"
                      className={cn(
                        "relative flex items-center justify-center",
                        "w-8 h-8 rounded-full transition-colors",
                        "focus:outline-none focus:ring-2 focus:ring-offset-2",
                        activeValue !== null &&
                          item.value <= activeValue &&
                          "bg-blue-500 text-white",
                        activeValue !== null &&
                          item.value > activeValue &&
                          "bg-gray-200",
                        isDisabled && "cursor-not-allowed"
                      )}
                      onClick={() => handleClick(item.value)}
                      onKeyDown={(e) => handleKeyPress(e, item.value)}
                      onMouseEnter={() =>
                        !isDisabled && setHoveredValue(item.value)
                      }
                      onMouseLeave={() => setHoveredValue(null)}
                      disabled={isDisabled}
                      aria-label={`Scale value ${item.value}`}
                      initial={{ scale: 0.8, opacity: 0 }}
                      animate={{ scale: 1, opacity: 1 }}
                      exit={{ scale: 0.8, opacity: 0 }}
                    >
                      {item.icon || item.label}
                    </motion.button>
                  </TooltipTrigger>
                  {showTooltips && item.description && (
                    <TooltipContent>
                      <p>{item.description}</p>
                    </TooltipContent>
                  )}
                </Tooltip>
              </TooltipProvider>
            ))}
          </AnimatePresence>
        </div>
      </div>

      {showValue && value !== null && (
        <div className="text-center text-sm text-gray-500">
          {`ערך נבחר: ${value}`}
        </div>
      )}

      {error && (
        <div className="text-sm text-red-500 mt-1">
          {error}
        </div>
      )}

      {required && (
        <input
          type="hidden"
          name={name}
          value={value || ""}
          required
          aria-hidden="true"
        />
      )}
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\common\QuestionCard.tsx:
==================================================
import React, { useState } from "react";
import {
  Card,
  CardHeader,
  CardContent,
  CardFooter,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { 
  Bookmark, 
  AlertCircle, 
  HelpCircle, 
  SkipForward,
  Star
} from "lucide-react";
import type {
  Question,
  Answer,
  AnswerValue,
  QuestionDepth,
} from "../types/types";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";

interface QuestionCardProps {
  question: Question;
  answer?: Answer;
  depth: QuestionDepth;
  isRequired?: boolean;
  onAnswer?: (value: AnswerValue) => void;
  onSkip?: () => void;
  onBookmark?: () => void;
  onHelp?: () => void;
  className?: string;
  validationError?: string;
  isDisabled?: boolean;
  children?: React.ReactNode;
  language?: string;
}

const depthColors = {
  BASIC: "border-blue-200 bg-blue-50",
  ADVANCED: "border-purple-200 bg-purple-50",
  EXPERT: "border-green-200 bg-green-50",
};

const depthLabels = {
  BASIC: "בסיסי",
  ADVANCED: "מתקדם",
  EXPERT: "מעמיק",
};

export default function QuestionCard({
  question,
  answer,
  depth,
  isRequired = false,
  onAnswer,
  onSkip,
  onBookmark,
  onHelp,
  className = "",
  validationError,
  isDisabled = false,
  children,
  language = "he",
}: QuestionCardProps) {
  const [isBookmarked, setIsBookmarked] = useState(false);
  const [showHelp, setShowHelp] = useState(false);

  const handleBookmark = () => {
    setIsBookmarked(!isBookmarked);
    onBookmark?.();
  };

  const handleHelp = () => {
    setShowHelp(!showHelp);
    onHelp?.();
  };

  return (
    <Card
      className={cn(
        "transition-all duration-200",
        depthColors[depth],
        isDisabled ? "opacity-60" : "hover:shadow-md",
        className
      )}
    >
      {/* Header Section */}
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <div className="flex items-center gap-2">
          <span
            className={cn(
              "text-xs px-2 py-1 rounded-full",
              depth === "BASIC"
                ? "bg-blue-100 text-blue-700"
                : depth === "ADVANCED"
                ? "bg-purple-100 text-purple-700"
                : "bg-green-100 text-green-700"
            )}
          >
            {depthLabels[depth]}
          </span>
          {isRequired && (
            <Badge variant="destructive" className="text-xs">
              חובה *
            </Badge>
          )}
        </div>

        <div className="flex items-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={handleBookmark}
            className={cn(
              "p-1",
              isBookmarked ? "text-yellow-500" : "text-gray-400"
            )}
          >
            <Bookmark className="w-4 h-4" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={handleHelp}
            className="p-1 text-gray-400"
          >
            <HelpCircle className="w-4 h-4" />
          </Button>
        </div>
      </CardHeader>

      {/* Content Section */}
      <CardContent className="pt-2">
        <div className="space-y-4">
          {/* Question Text */}
          <div className="text-lg font-medium">{question.question}</div>

          {/* Description if exists */}
          {question.description && (
            <p className="text-sm text-gray-600">{question.description}</p>
          )}

          {/* Help Text when shown */}
          {showHelp && question.metadata?.helpText && (
            <Alert className="bg-blue-50 border-blue-200">
              <AlertDescription className="text-sm text-blue-700">
                {question.metadata.helpText}
              </AlertDescription>
            </Alert>
          )}

          {/* Validation Error */}
          {validationError && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{validationError}</AlertDescription>
            </Alert>
          )}

          {/* Required Indicator */}
          {isRequired && (
            <div className="text-sm text-red-500 mb-2">
              * שאלת חובה
            </div>
          )}
          
          {/* Answer Component */}
          <div className="mt-4">{children}</div>
        </div>
      </CardContent>

      {/* Footer Section */}
      <CardFooter className="flex justify-between pt-4">
        <Button
          variant="ghost"
          size="sm"
          onClick={onSkip}
          disabled={isRequired || isDisabled}
          className={cn(
            "text-gray-500",
            (isRequired || isDisabled) && "opacity-50 cursor-not-allowed"
          )}
        >
          <SkipForward className="w-4 h-4 ml-2" />
          דלג
        </Button>

        {question.metadata?.estimatedTime && (
          <span className="text-sm text-gray-500">
            זמן מוערך: {question.metadata.estimatedTime} דקות
          </span>
        )}
      </CardFooter>
    </Card>
  );
   }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\common\QuestionnaireCompletion.tsx:
==================================================
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { Send, CheckCircle2 } from "lucide-react";

interface QuestionnaireCompletionProps {
  onSendToMatching: () => void;
  isLoading?: boolean;
  isLoggedIn?: boolean;
}

const QuestionnaireCompletion: React.FC<QuestionnaireCompletionProps> = ({
  onSendToMatching,
  isLoading = false,
  isLoggedIn = false,
}) => {
  return (
    <div className="max-w-xl mx-auto p-4">
      <Card className="bg-green-50 border-green-200">
        <CardHeader>
          <div className="flex justify-center mb-4">
            <CheckCircle2 className="w-12 h-12 text-green-500" />
          </div>
          <CardTitle className="text-2xl text-center">
            כל הכבוד! סיימת את השאלון
          </CardTitle>
          <CardDescription className="text-center">
            {isLoggedIn
              ? "התשובות שלך יעזרו לנו למצוא עבורך את ההתאמה הטובה ביותר"
              : "כדי לשמור את התשובות ולהתחיל בתהליך ההתאמה, יש להתחבר למערכת"}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {isLoggedIn ? (
            <>
              <div className="text-center text-gray-600">
                <p>כעת ניתן לשלוח את השאלון לצוות האיפיון שלנו</p>
                <p className="text-sm mt-2">
                  הצוות יעבור על התשובות ויתחיל בתהליך ההתאמה
                </p>
              </div>
              <Button
                className="w-full"
                size="lg"
                onClick={onSendToMatching}
                disabled={isLoading}
              >
                <Send className="w-5 h-5 ml-2" />
                {isLoading ? "שולח..." : "שלח לאיפיון"}
              </Button>
            </>
          ) : (
            <Button className="w-full" size="lg" onClick={onSendToMatching}>
              התחבר למערכת
            </Button>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default QuestionnaireCompletion;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\common\WorldIntro.tsx:
==================================================
import React from "react";
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Scroll, Heart, Users, User, ArrowRight } from "lucide-react";
import type { WorldId } from "../types/types";
import { cn } from "@/lib/utils";

interface WorldIntroProps {
  worldId: WorldId;
  title: string;
  description: string;
  estimatedTime: number;
  totalQuestions: number;
  requiredQuestions: number;
  depths: Array<"BASIC" | "ADVANCED" | "EXPERT">;
  onStart: () => void;
  className?: string;
}

const worldIcons = {
  RELIGION: Scroll,
  VALUES: Heart,
  RELATIONSHIP: Users,
  PERSONALITY: User,
  PARTNER: Heart,
} as const;

const worldStyles = {
  RELIGION: {
    bg: "bg-indigo-100",
    hover: "hover:bg-indigo-200",
    border: "border-indigo-300",
    text: "text-indigo-500",
  },
  VALUES: {
    bg: "bg-pink-100",
    hover: "hover:bg-pink-200",
    border: "border-pink-300",
    text: "text-pink-500",
  },
  RELATIONSHIP: {
    bg: "bg-purple-100",
    hover: "hover:bg-purple-200",
    border: "border-purple-300",
    text: "text-purple-500",
  },
  PERSONALITY: {
    bg: "bg-blue-100",
    hover: "hover:bg-blue-200",
    border: "border-blue-300",
    text: "text-blue-500",
  },
  PARTNER: {
    bg: "bg-pink-100",
    hover: "hover:bg-pink-200",
    border: "border-pink-300",
    text: "text-pink-500",
  },
} as const;

const depthInfo = {
  BASIC: {
    label: "שאלות בסיסיות",
    description: "שאלות חובה המהוות את הבסיס להיכרות",
    color: "text-blue-600",
  },
  ADVANCED: {
    label: "שאלות מתקדמות",
    description: "שאלות מומלצות להיכרות מעמיקה יותר",
    color: "text-purple-600",
  },
  EXPERT: {
    label: "שאלות מעמיקות",
    description: "שאלות העשרה לחיבור מעמיק במיוחד",
    color: "text-green-600",
  },
} as const;

export default function WorldIntro({
  worldId,
  title,
  description,
  estimatedTime,
  totalQuestions,
  requiredQuestions,
  depths,
  onStart,
  className = "",
}: WorldIntroProps) {
  const WorldIcon = worldIcons[worldId];

  const containerVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 },
  };

  return (
    <motion.div
      className={cn("max-w-2xl mx-auto p-4", className)}
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <Card className="overflow-hidden">
        <CardContent className="p-6 space-y-6">
          <motion.div
            variants={itemVariants}
            className="flex items-center gap-4"
          >
            <div className={cn("p-3 rounded-full", worldStyles[worldId].bg)}>
              <WorldIcon className={cn("w-8 h-8", worldStyles[worldId].text)} />
            </div>
            <div>
              <h2 className="text-2xl font-bold">{title}</h2>
              <p className="text-gray-500 mt-1">{description}</p>
            </div>
          </motion.div>

          <motion.div
            variants={itemVariants}
            className="grid grid-cols-3 gap-4"
          >
            <div className="text-center">
              <div className="text-2xl font-bold text-gray-800">
                {estimatedTime}
              </div>
              <div className="text-sm text-gray-500">דקות</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-gray-800">
                {totalQuestions}
              </div>
              <div className="text-sm text-gray-500">שאלות</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-gray-800">
                {requiredQuestions}
              </div>
              <div className="text-sm text-gray-500">שאלות חובה</div>
            </div>
          </motion.div>

          <motion.div variants={itemVariants} className="space-y-4">
            <h3 className="font-medium">רמות העומק בעולם זה:</h3>
            {depths.map((depth) => (
              <div
                key={depth}
                className="flex items-start gap-4 p-3 bg-gray-50 rounded-lg"
              >
                <div
                  className={cn(
                    "mt-1 w-2 h-2 rounded-full",
                    depth === "BASIC"
                      ? "bg-blue-500"
                      : depth === "ADVANCED"
                      ? "bg-purple-500"
                      : "bg-green-500"
                  )}
                />
                <div>
                  <h4 className={cn("font-medium", depthInfo[depth].color)}>
                    {depthInfo[depth].label}
                  </h4>
                  <p className="text-sm text-gray-600">
                    {depthInfo[depth].description}
                  </p>
                </div>
              </div>
            ))}
          </motion.div>

          <motion.div variants={itemVariants} className="pt-4">
            <Button onClick={onStart} className="w-full" size="lg">
              בוא/י נתחיל
              <ArrowRight className="w-5 h-5 mr-2" />
            </Button>
          </motion.div>
        </CardContent>
      </Card>
    </motion.div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\layout\NavigationBar.tsx:
==================================================
import React from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import {
  Save,
  LogOut,
  Settings,
  HelpCircle,
  Clock,
  AlertCircle,
} from "lucide-react";
import { WorldId } from "../types/worlds";
import type { QuestionnaireProgress } from "../types/progress";

interface NavigationBarProps {
  currentWorld: WorldId;
  progress: QuestionnaireProgress;
  onSave?: (progress: QuestionnaireProgress) => Promise<void>;
  onExit?: () => void;
  className?: string;
}

export default function NavigationBar({
  currentWorld,
  progress,
  onSave,
  onExit,
  className = "",
}: NavigationBarProps) {
  const totalProgress = Math.round(
    (progress.summary.completion.completionRate || 0) * 100
  );
  const estimatedTimeRemaining = Math.round(
    progress.summary.timeTracking.estimatedTimeRemaining / 60
  );
  const hasWarnings = progress.summary.qualityMetrics.contradictions.length > 0;

  return (
    <div
      className={`fixed top-0 left-0 right-0 bg-white border-b z-50 ${className}`}
    >
      <div className="container mx-auto px-4 h-16 flex items-center justify-between">
        {/* Left section - Progress & Time */}
        <div className="flex items-center gap-6">
          <div className="flex items-center gap-2">
            <Progress value={totalProgress} className="w-32" />
            <span className="text-sm text-gray-600">{totalProgress}%</span>
          </div>

          {estimatedTimeRemaining > 0 && (
            <div className="flex items-center gap-2 text-sm text-gray-600">
              <Clock className="w-4 h-4" />
              <span>כ-{estimatedTimeRemaining} דקות נותרו</span>
            </div>
          )}

          {hasWarnings && (
            <div className="flex items-center gap-2 text-amber-600">
              <AlertCircle className="w-4 h-4" />
              <span className="text-sm">יש לך תשובות שדורשות תשומת לב</span>
            </div>
          )}
        </div>

        {/* Right section - Actions */}
        <div className="flex items-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onSave?.(progress)}
            title="שמירה"
          >
            <Save className="w-4 h-4 ml-2" />
            שמירה
          </Button>

          <Button variant="ghost" size="sm" title="הגדרות">
            <Settings className="w-4 h-4" />
          </Button>

          <Button variant="ghost" size="sm" title="עזרה">
            <HelpCircle className="w-4 h-4" />
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={() => onExit?.()}
            className="mr-2"
          >
            <LogOut className="w-4 h-4 ml-2" />
            יציאה
          </Button>
        </div>
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\layout\ProgressTracker.tsx:
==================================================
import React from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { WorldCompletionStats } from "../types/progress";
import { Button } from "@/components/ui/button";
import {
  Heart,
  Users,
  User,
  Briefcase,
  CheckCircle2,
  AlertCircle,
  Clock,
  Lock,
} from "lucide-react";
import { WorldId, QuestionDepth } from "../types/worlds";
import type { QuestionnaireProgress } from "../types/progress";
import { cn } from "@/lib/utils";

interface ProgressTrackerProps {
  currentWorld: WorldId;
  progress: QuestionnaireProgress;
  onWorldSelect?: (worldId: WorldId) => void;
  className?: string;
}

const worldIcons = {
  VALUES: Heart,
  RELATIONSHIP: Users,
  PERSONALITY: User,
  GOALS: Briefcase,
};

const depthLabels: Record<QuestionDepth, string> = {
  BASIC: "בסיסי",
  ADVANCED: "מתקדם",
  EXPERT: "מעמיק",
};

export default function ProgressTracker({
  currentWorld,
  progress,
  onWorldSelect,
  className = "",
}: ProgressTrackerProps) {
  // Function to determine if a world is accessible
  const isWorldAccessible = (worldId: WorldId) => {
    const worldProgress = progress.worldProgress[worldId];
    if (!worldProgress) return false;

    // Check if all required worlds are completed
    const requiredWorlds = progress.navigation.availableWorlds;
    return requiredWorlds.includes(worldId);
  };

  // Function to get world completion status
  const getWorldCompletion = (worldId: WorldId): WorldCompletionStats => {
    const worldProgress = progress.worldProgress[worldId];
    if (!worldProgress) {
      return {
        basic: 0,
        advanced: 0,
        expert: 0,
        total: 0,
      };
    }

    const { completion } = worldProgress;
    const total = Math.round(
      ((completion.basic.completedQuestions +
        completion.advanced.completedQuestions +
        completion.expert.completedQuestions) /
        (completion.basic.totalQuestions +
          completion.advanced.totalQuestions +
          completion.expert.totalQuestions)) *
        100
    );

    return {
      basic: completion.basic.completionRate * 100,
      advanced: completion.advanced.completionRate * 100,
      expert: completion.expert.completionRate * 100,
      total: total,
    };
  };

  // Function to get world status icon
  const WorldStatusIcon = ({ worldId }: { worldId: WorldId }) => {
    const completion = getWorldCompletion(worldId);

    if (completion.total === 100) {
      return <CheckCircle2 className="w-5 h-5 text-green-500" />;
    }

    if (!isWorldAccessible(worldId)) {
      return <Lock className="w-5 h-5 text-gray-400" />;
    }

    if (worldId === currentWorld) {
      return <Clock className="w-5 h-5 text-blue-500" />;
    }

    const hasWarnings = progress.worldProgress[worldId]?.blockers.length > 0;
    if (hasWarnings) {
      return <AlertCircle className="w-5 h-5 text-amber-500" />;
    }

    return null;
  };

  return (
    <div className={cn("flex flex-col gap-4", className)}>
      {Object.entries(worldIcons).map(([worldId, Icon]) => {
        const isActive = currentWorld === worldId;
        const isAccessible = isWorldAccessible(worldId as WorldId);
        const completion = getWorldCompletion(worldId as WorldId);

        return (
          <Card
            key={worldId}
            className={cn(
              "transition-all duration-200",
              isActive ? "ring-2 ring-blue-500" : "",
              !isAccessible ? "opacity-50" : "",
              "hover:shadow-md"
            )}
          >
            <CardContent className="p-4">
              {/* World header */}
              <div className="flex items-center justify-between mb-4">
                <Button
                  variant={isActive ? "default" : "ghost"}
                  size="sm"
                  onClick={() =>
                    isAccessible && onWorldSelect?.(worldId as WorldId)
                  }
                  disabled={!isAccessible}
                  className="flex items-center gap-2"
                >
                  <Icon className="w-5 h-5" />
                  <span>{worldId}</span>
                </Button>
                <WorldStatusIcon worldId={worldId as WorldId} />
              </div>

              {/* Completion progress bars */}
              <div className="space-y-3">
                {Object.entries(depthLabels).map(([depth, label]) => (
                  <div key={depth} className="space-y-1">
                    <div className="flex justify-between text-sm text-gray-600">
                      <span>{label}</span>
                      <span>
                        {completion[
                          depth.toLowerCase() as keyof typeof completion
                        ].toFixed(0)}
                        %
                      </span>
                    </div>
                    <Progress
                      value={
                        completion[
                          depth.toLowerCase() as keyof typeof completion
                        ]
                      }
                      className={cn(
                        depth === "BASIC"
                          ? "bg-blue-100"
                          : depth === "ADVANCED"
                          ? "bg-purple-100"
                          : "bg-green-100"
                      )}
                    />
                  </div>
                ))}
              </div>

              {/* Warning messages if any */}
              {progress.worldProgress[worldId as WorldId]?.blockers.map(
                (blocker, index) => (
                  <div
                    key={index}
                    className="mt-3 text-sm text-amber-600 flex items-center gap-2"
                  >
                    <AlertCircle className="w-4 h-4" />
                    <span>{blocker.reason}</span>
                  </div>
                )
              )}
            </CardContent>
          </Card>
        );
      })}

      {/* Overall progress */}
      <Card className="mt-4">
        <CardContent className="p-4">
          <div className="flex justify-between items-center mb-2">
            <span className="font-medium">התקדמות כללית</span>
            <span className="text-sm text-gray-600">
              {progress.summary.completion.completionRate.toFixed(0)}%
            </span>
          </div>
          <Progress
            value={progress.summary.completion.completionRate * 100}
            className="h-3"
          />
        </CardContent>
      </Card>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\layout\QuestionnaireLayout.tsx:
==================================================
import React, { useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Heart,
  User,
  Users,
  Save,
  LogOut,
  Settings,
  HelpCircle,
  AlertCircle,
  Scroll,
  Loader2,
} from "lucide-react";
import type {
  WorldId,
  UserTrack,
  QuestionnaireLayoutProps,
} from "../types/types";
import { cn } from "@/lib/utils";

interface SimpleToastProps {
  message: string;
  type?: "success" | "error" | "info";
  onClose?: () => void;
  isVisible: boolean;
}

function SimpleToast({
  message,
  type = "info",
  onClose,
  isVisible,
}: SimpleToastProps) {
  if (!isVisible) return null;

  const baseClasses =
    "fixed bottom-4 left-4 p-4 rounded-md shadow-lg z-50 transition-all duration-300";
  const typeClasses = {
    success: "bg-green-500 text-white",
    error: "bg-red-500 text-white",
    info: "bg-blue-500 text-white",
  };

  return (
    <div className={cn(baseClasses, typeClasses[type])}>
      <div className="flex items-center justify-between">
        <p>{message}</p>
        {onClose && (
          <button
            onClick={onClose}
            className="ml-4 text-white hover:text-gray-200"
          >
            ×
          </button>
        )}
      </div>
    </div>
  );
}

const worldIcons = {
  PERSONALITY: User,
  VALUES: Heart,
  RELATIONSHIP: Users,
  PARTNER: Heart,
  RELIGION: Scroll,
} as const;

const worldLabels = {
  PERSONALITY: "אישיות",
  VALUES: "ערכים ואמונות",
  RELATIONSHIP: "זוגיות",
  PARTNER: "תכונות וערכים בבן/בת הזוג",
  RELIGION: "דת ומסורת",
} as const;

export default function QuestionnaireLayout({
  children,
  currentWorld,
  userTrack,
  completedWorlds,
  onWorldChange,
  onExit,
  onSaveProgress,
  language = "he",
}: QuestionnaireLayoutProps) {
  const [isSaving, setIsSaving] = useState(false);
  const [showExitPrompt, setShowExitPrompt] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [toast, setToast] = useState<{
    message: string;
    type: "success" | "error" | "info";
    isVisible: boolean;
  }>({
    message: "",
    type: "info",
    isVisible: false,
  });

  // Toast utilities
  const showToast = (
    message: string,
    type: "success" | "error" | "info" = "info"
  ) => {
    setToast({ message, type, isVisible: true });
    setTimeout(() => {
      setToast((prev) => ({ ...prev, isVisible: false }));
    }, 3000);
  };

  // Save functionality
  const handleSave = async () => {
    if (!onSaveProgress) {
      showToast("לא ניתן לשמור את השאלון כרגע", "error");
      return;
    }

    setIsSaving(true);
    setError(null);

    try {
      await onSaveProgress();
      showToast("השאלון נשמר בהצלחה", "success");
    } catch (err) {
      setError("אירעה שגיאה בשמירת השאלון");
      showToast("אירעה שגיאה בשמירת השאלון", "error");
    } finally {
      setIsSaving(false);
    }
  };

  // Setup RTL/LTR classes
  const isRTL = language === "he";
  const layoutClasses = cn(
    "flex h-screen overflow-hidden bg-gray-50",
    isRTL ? "flex-row-reverse" : "flex-row"
  );

  const sidebarClasses = cn(
    "w-80 bg-white overflow-y-auto",
    isRTL ? "border-l" : "border-r"
  );

  return (
    <div className={layoutClasses}>
      {/* Main content area */}
      <main className="flex-1 overflow-y-auto p-6">
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Save Button */}
        <div className="fixed top-4 left-4 z-50">
          <Button
            onClick={handleSave}
            disabled={isSaving}
            className="bg-green-600 hover:bg-green-700 text-white"
          >
            {isSaving ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                שומר...
              </>
            ) : (
              <>
                <Save className="w-4 h-4 mr-2" />
                שמור מצב נוכחי
              </>
            )}
          </Button>
        </div>

        {children}
      </main>

      {/* Navigation sidebar */}
      <nav className={sidebarClasses}>
        {/* Top navigation bar */}
        <div className="p-4 border-b">
          <div className="flex items-center justify-between">
            <Button variant="ghost" size="sm">
              <Settings className="w-4 h-4" />
            </Button>
            <Button variant="ghost" size="sm">
              <HelpCircle className="w-4 h-4" />
            </Button>
          </div>
        </div>

        {/* Worlds navigation */}
        <div className="p-4 space-y-4">
          {Object.entries(worldIcons).map(([worldId, Icon]) => {
            const isActive = currentWorld === worldId;
            const isCompleted = completedWorlds.includes(worldId as WorldId);

            return (
              <Card
                key={worldId}
                className={cn(
                  "transition-all duration-200",
                  isActive ? "ring-2 ring-blue-500" : "",
                  "hover:shadow-md cursor-pointer"
                )}
                onClick={() => onWorldChange(worldId as WorldId)}
              >
                <CardContent className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-2">
                      <Icon className="w-5 h-5" />
                      <span>
                        {worldLabels[worldId as keyof typeof worldLabels]}
                      </span>
                    </div>
                    {isCompleted && (
                      <AlertCircle className="w-4 h-4 text-green-500" />
                    )}
                  </div>
                </CardContent>
              </Card>
            );
          })}
        </div>

        {/* Bottom actions */}
        <div className="p-4 border-t mt-auto">
          <Button
            variant="outline"
            className="w-full"
            onClick={() => setShowExitPrompt(true)}
          >
            <LogOut className="w-4 h-4 me-2" />
            יציאה
          </Button>
        </div>
      </nav>

      {/* Exit Confirmation Dialog */}
      {showExitPrompt && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-xl max-w-md w-full mx-4">
            <h3 className="text-lg font-medium mb-4">
              האם אתה בטוח שברצונך לצאת?
            </h3>
            <p className="text-gray-600 mb-6">
              כל התשובות שלא נשמרו יאבדו. האם ברצונך לשמור לפני היציאה?
            </p>
            <div className="flex justify-end gap-4">
              <Button
                variant="outline"
                onClick={() => setShowExitPrompt(false)}
              >
                ביטול
              </Button>
              <Button
                variant="outline"
                onClick={async () => {
                  await handleSave();
                  onExit?.();
                }}
              >
                שמור וצא
              </Button>
              <Button
                variant="destructive"
                onClick={() => {
                  setShowExitPrompt(false);
                  onExit?.();
                }}
              >
                צא ללא שמירה
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Toast */}
      <SimpleToast
        message={toast.message}
        type={toast.type}
        isVisible={toast.isVisible}
        onClose={() => setToast((prev) => ({ ...prev, isVisible: false }))}
      />
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\layout\WorldsMap.tsx:
==================================================
import React, { useState } from "react";
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Scroll,
  Heart,
  Users,
  User,
  Briefcase,
  CheckCircle2,
  Lock,
  ArrowRight,
  AlertCircle,
} from "lucide-react";
import type { WorldId } from "../types/types";
import { cn } from "@/lib/utils";

interface WorldsMapProps {
  currentWorld: WorldId;
  completedWorlds: WorldId[];
  onWorldChange?: (worldId: WorldId) => void;
  className?: string;
}

const worldsConfig = {
 
  RELATIONSHIP: {
    icon: Users,
    color: "bg-purple-100 hover:bg-purple-200",
    borderColor: "border-purple-300",
    textColor: "text-purple-700",
    label: "זוגיות",
    description: "תפיסת הזוגיות והציפיות ממערכת היחסים",
  },
  VALUES: {
    icon: Heart,
    color: "bg-pink-100 hover:bg-pink-200",
    borderColor: "border-pink-300",
    textColor: "text-pink-700",
    label: "ערכים ואמונות",
    description: "עולם הערכים והאמונות שלך",
  },
  PERSONALITY: {
    icon: User,
    color: "bg-blue-100 hover:bg-blue-200",
    borderColor: "border-blue-300",
    textColor: "text-blue-700",
    label: "אישיות",
    description: "המאפיינים האישיותיים שלך",
  },
  PARTNER: {
    icon: Heart,
    color: "bg-pink-100 hover:bg-pink-200",
    borderColor: "border-pink-300",
    textColor: "text-pink-700",
    label: "פרטנר",
    description: "מה חשוב לך בבן/בת הזוג",
  },
  RELIGION: {
    icon: Scroll,
    color: "bg-purple-100 hover:bg-purple-200",
    borderColor: "border-purple-300",
    textColor: "text-purple-700",
    label: "דת ומסורת",
    description: "חיבור לדת, אמונה ומסורת ישראל",
  },
} as const;

const WORLD_ORDER: WorldId[] = [
  "PERSONALITY",
  "VALUES",
  "RELATIONSHIP",
  "PARTNER",
  "RELIGION",
];

export default function WorldsMap({
  currentWorld,
  completedWorlds,
  onWorldChange,
  className = "",
}: WorldsMapProps) {
  const [hoveredWorld, setHoveredWorld] = useState<WorldId | null>(null);

  const isWorldAccessible = (worldId: WorldId): boolean => {
    const currentIndex = WORLD_ORDER.indexOf(currentWorld);
    const targetIndex = WORLD_ORDER.indexOf(worldId);

    // The first world is always accessible
    if (targetIndex === 0) return true;

    // Can access if the previous world is completed
    const previousWorld = WORLD_ORDER[targetIndex - 1];
    return completedWorlds.includes(previousWorld);
  };

  return (
    <div className={cn("p-4 grid grid-cols-2 gap-4", className)}>
      {WORLD_ORDER.map((worldId) => {
        const config = worldsConfig[worldId];
        const Icon = config.icon;
        const isActive = currentWorld === worldId;
        const isCompleted = completedWorlds.includes(worldId);
        const isAccessible = isWorldAccessible(worldId);
        const isHovered = hoveredWorld === worldId;

        return (
          <motion.div
            key={worldId}
            initial={{ scale: 1 }}
            animate={{
              scale: isHovered ? 1.05 : 1,
              opacity: isAccessible ? 1 : 0.7,
            }}
            transition={{ duration: 0.2 }}
          >
            <Card
              className={cn(
                "transition-all duration-200 cursor-pointer",
                config.color,
                isActive && `ring-2 ring-${config.borderColor}`,
                "hover:shadow-lg"
              )}
              onClick={() => isAccessible && onWorldChange?.(worldId)}
              onMouseEnter={() => setHoveredWorld(worldId)}
              onMouseLeave={() => setHoveredWorld(null)}
            >
              <CardContent className="p-4 space-y-2">
                <div className="flex items-center justify-between">
                  <div
                    className={cn("flex items-center gap-2", config.textColor)}
                  >
                    <Icon className="w-6 h-6" />
                    <div>
                      <h3 className="font-medium">{config.label}</h3>
                      {isHovered && (
                        <p className="text-sm text-gray-600">
                          {config.description}
                        </p>
                      )}
                    </div>
                  </div>

                  {/* Status Icon */}
                  {isCompleted ? (
                    <CheckCircle2 className="w-5 h-5 text-green-500" />
                  ) : !isAccessible ? (
                    <Lock className="w-5 h-5 text-gray-400" />
                  ) : isActive ? (
                    <ArrowRight className="w-5 h-5 text-blue-500" />
                  ) : (
                    <AlertCircle className="w-5 h-5 text-gray-400" />
                  )}
                </div>

                {isHovered && isAccessible && !isCompleted && (
                  <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    className="text-sm text-gray-600 pt-2"
                  >
                    {isActive ? "ממשיך/ה בעולם זה" : "לחץ/י למעבר לעולם זה"}
                  </motion.div>
                )}
              </CardContent>
            </Card>
          </motion.div>
        );
      })}
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\onboarding\TrackSelection.tsx:
==================================================
import React, { useState } from "react";
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Scroll,
  Book,
  Heart,
  Sun,
  ArrowLeft,
  ArrowRight,
  Info,
  Star,
} from "lucide-react";
import type { UserTrack } from "../types/worlds";

interface TrackSelectionProps {
  onSelect: (track: UserTrack) => void;
  onBack: () => void;
  selectedTrack?: UserTrack;
}

interface TrackOption {
  id: UserTrack;
  title: string;
  description: string;
  icon: React.ReactNode;
  color: string;
  characteristics: string[];
  details: {
    traditions: string;
    lifestyle: string;
    community: string;
  };
}

const trackOptions: TrackOption[] = [
  {
    id: "SECULAR",
    title: "חילוני",
    description: "אורח חיים חופשי עם זיקה למסורת",
    icon: <Sun className="w-6 h-6" />,
    color: "bg-blue-500",
    characteristics: [
      "גמישות בשמירת מסורת",
      "פתיחות לאורח חיים מודרני",
      "חיבור לערכים יהודיים תרבותיים",
    ],
    details: {
      traditions: "שמירה על מסורות משפחתיות וחגים",
      lifestyle: "אורח חיים מודרני ופתוח",
      community: "חיבור לקהילה היהודית הרחבה",
    },
  },
  {
    id: "TRADITIONAL",
    title: "מסורתי",
    description: "שילוב בין מסורת למודרנה",
    icon: <Heart className="w-6 h-6" />,
    color: "bg-purple-500",
    characteristics: [
      "שמירת מסורת מתוך בחירה",
      "איזון בין דת לחיים מודרניים",
      "כבוד למנהגים ולמורשת",
    ],
    details: {
      traditions: "שמירת שבת וחגים באופן גמיש",
      lifestyle: "שילוב בין מסורת למודרניות",
      community: "קשר עם קהילות מגוונות",
    },
  },
  {
    id: "RELIGIOUS",
    title: "דתי",
    description: "אורח חיים על פי ההלכה",
    icon: <Book className="w-6 h-6" />,
    color: "bg-green-500",
    characteristics: [
      "מחויבות להלכה ולמצוות",
      "השקפת עולם תורנית",
      "שילוב תורה עם דרך ארץ",
    ],
    details: {
      traditions: "הקפדה על הלכה ומצוות",
      lifestyle: "חיים דתיים עם השתלבות בחברה",
      community: "חיבור לקהילה דתית",
    },
  },
  {
    id: "ORTHODOX",
    title: "חרדי",
    description: "הקפדה מלאה על קלה כבחמורה",
    icon: <Scroll className="w-6 h-6" />,
    color: "bg-red-500",
    characteristics: [
      "מחויבות מלאה לאורח חיים תורני",
      "הקפדה על קוצו של יו״ד",
      "לימוד תורה כדרך חיים",
    ],
    details: {
      traditions: "הקפדה מלאה על כל פרטי ההלכה",
      lifestyle: "אורח חיים תורני מובהק",
      community: "השתייכות לקהילה חרדית",
    },
  },
];

export default function TrackSelection({
  onSelect,
  onBack,
  selectedTrack,
}: TrackSelectionProps) {
  const [hoveredTrack, setHoveredTrack] = useState<UserTrack | null>(null);
  const [currentStep, setCurrentStep] = useState<1 | 2>(1);

  const containerVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        staggerChildren: 0.1,
      },
    },
  };

  const cardVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: {
      opacity: 1,
      x: 0,
      transition: { duration: 0.3 },
    },
  };

  const confirmSelection = () => {
    if (selectedTrack) {
      onSelect(selectedTrack);
    }
  };

  return (
    <motion.div
      className="min-h-screen p-6 bg-gradient-to-b from-gray-50 to-white"
      initial="hidden"
      animate="visible"
      variants={containerVariants}
    >
      <div className="max-w-4xl mx-auto space-y-8">
        {/* Header */}
        <div className="text-center space-y-4">
          <motion.div variants={cardVariants}>
            <h1 className="text-3xl font-bold">בחירת מסלול מותאם אישית</h1>
            <p className="text-gray-600">
              בחר/י את המסלול שמשקף בצורה הטובה ביותר את אורח חייך ואמונתך
            </p>
          </motion.div>

          <Alert className="bg-blue-50 border-blue-200">
            <Info className="w-4 h-4 text-blue-500" />
            <AlertDescription className="text-blue-700">
              בחירת המסלול תעזור לנו להתאים את השאלות והשידוכים המוצעים באופן
              מיטבי עבורך
            </AlertDescription>
          </Alert>
        </div>

        {/* Progress Steps */}
        <div className="flex justify-between items-center px-4">
          <div className="flex-1">
            <Progress value={currentStep === 1 ? 50 : 100} className="h-2" />
          </div>
          <div className="px-4 text-sm text-gray-500">
            שלב {currentStep} מתוך 2
          </div>
        </div>

        {currentStep === 1 ? (
          /* Track Selection Grid */
          <motion.div
            variants={cardVariants}
            className="grid grid-cols-1 md:grid-cols-2 gap-6"
          >
            {trackOptions.map((track) => (
              <Card
                key={track.id}
                className={`cursor-pointer transition-all duration-200 hover:shadow-lg ${
                  selectedTrack === track.id
                    ? "ring-2 ring-blue-500"
                    : "hover:border-blue-200"
                }`}
                onClick={() => {
                  setCurrentStep(2);
                  onSelect(track.id);
                }}
                onMouseEnter={() => setHoveredTrack(track.id)}
                onMouseLeave={() => setHoveredTrack(null)}
              >
                <CardContent className="p-6">
                  <div className="flex items-start space-x-4 rtl:space-x-reverse">
                    <div
                      className={`p-3 rounded-lg ${track.color} bg-opacity-10`}
                    >
                      {track.icon}
                    </div>
                    <div className="flex-1">
                      <h3 className="text-lg font-medium mb-2">
                        {track.title}
                      </h3>
                      <p className="text-gray-600 mb-4">{track.description}</p>
                      <ul className="space-y-2">
                        {track.characteristics.map((char, index) => (
                          <li
                            key={index}
                            className="flex items-center text-sm text-gray-600"
                          >
                            <Star className="w-4 h-4 ml-2 text-gray-400" />
                            {char}
                          </li>
                        ))}
                      </ul>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))}
          </motion.div>
        ) : (
          /* Confirmation Step */
          <motion.div variants={cardVariants} className="space-y-6">
            {selectedTrack && (
              <Card className="p-6">
                <h3 className="text-xl font-medium mb-4">
                  אישור בחירת מסלול{" "}
                  {trackOptions.find((t) => t.id === selectedTrack)?.title}
                </h3>
                <div className="space-y-4">
                  {Object.entries(
                    trackOptions.find((t) => t.id === selectedTrack)?.details ||
                      {}
                  ).map(([key, value]) => (
                    <div key={key} className="space-y-2">
                      <h4 className="font-medium">
                        {key === "traditions"
                          ? "מסורת"
                          : key === "lifestyle"
                          ? "אורח חיים"
                          : "קהילה"}
                      </h4>
                      <p className="text-gray-600">{value}</p>
                    </div>
                  ))}
                </div>
              </Card>
            )}
          </motion.div>
        )}

        {/* Navigation Buttons */}
        <motion.div
          variants={cardVariants}
          className="flex justify-between pt-6"
        >
          <Button
            variant="outline"
            onClick={() => {
              if (currentStep === 2) {
                setCurrentStep(1);
              } else {
                onBack();
              }
            }}
          >
            <ArrowRight className="w-4 h-4 ml-2" />
            {currentStep === 1 ? "חזרה" : "בחירה מחדש"}
          </Button>

          {currentStep === 2 && (
            <Button onClick={confirmSelection} disabled={!selectedTrack}>
              אישור והמשך
              <ArrowLeft className="w-4 h-4 mr-2" />
            </Button>
          )}
        </motion.div>
      </div>
    </motion.div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\onboarding\Welcome.tsx:
==================================================
import React, { useState } from "react";
import { motion } from "framer-motion";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Heart,
  Users,
  Search,
  ArrowRight,
  Star,
  Shield,
  Clock,
  AlertTriangle
} from "lucide-react";

interface WelcomeProps {
  onStart: () => void;
  onLearnMore: () => void;
  isLoggedIn?: boolean;
}

export default function Welcome({ onStart, onLearnMore, isLoggedIn }: WelcomeProps) {
  const [isHovered, setIsHovered] = useState(false);

  const containerVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.6,
        staggerChildren: 0.2,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 },
  };

  const features = [
    {
      icon: <Clock className="w-5 h-5 text-blue-500" />,
      title: "תהליך מותאם אישית",
      description: "השאלון מתאים את עצמו לקצב ולהעדפות שלך",
    },
    {
      icon: <Shield className="w-5 h-5 text-green-500" />,
      title: "פרטיות מלאה",
      description: "המידע שלך מאובטח ונשמר בצורה מוגנת",
    },
    {
      icon: <Star className="w-5 h-5 text-yellow-500" />,
      title: "התאמה מדויקת",
      description: "אלגוריתם חכם שמבין את הצרכים שלך",
    },
  ];

  return (
    <motion.div
      className="min-h-screen flex items-center justify-center p-4 bg-gradient-to-b from-blue-50 to-white"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <Card className="max-w-4xl w-full">
        <CardHeader className="text-center pb-2">
          <motion.div
            className="flex justify-center mb-6"
            variants={itemVariants}
          >
            <div className="relative">
              <Heart className="w-16 h-16 text-pink-500" />
              <Users className="w-10 h-10 text-blue-500 absolute -bottom-2 -right-2" />
              <Search className="w-8 h-8 text-purple-500 absolute -top-1 -right-3" />
            </div>
          </motion.div>
          <motion.div variants={itemVariants}>
            <CardTitle className="text-3xl mb-2">
              ברוכים הבאים לשאלון ההיכרות
            </CardTitle>
            <CardDescription className="text-lg">
              הצעד הראשון במסע למציאת הזיווג המתאים עבורך
            </CardDescription>
          </motion.div>
        </CardHeader>

        <CardContent className="space-y-8">
          {!isLoggedIn && (
            <motion.div variants={itemVariants}>
             <Alert variant="default" className="bg-yellow-50 border-yellow-200">
                <AlertTriangle className="h-4 w-4 text-yellow-600" />
                <AlertTitle className="text-yellow-800 font-medium">שים/י לב!</AlertTitle>
                <AlertDescription className="text-yellow-700">
                  <p className="mb-2">את/ה כרגע לא מחובר/ת למערכת.</p>
                  <p className="mb-2">ניתן למלא את השאלון גם ללא חשבון, אבל:</p>
                  <ul className="list-disc mr-6 space-y-1 mb-2">
                    <li>התשובות לא יישמרו במערכת</li>
                    <li>לא תוכל/י לחזור לשאלון בפעם אחרת</li>
                    <li>בסיום השאלון תוכל/י להוריד את הסיכום כקובץ PDF</li>
                  </ul>
                  <Button 
                    variant="link" 
                    className="p-0 h-auto text-blue-600 hover:text-blue-800" 
                    onClick={() => window.location.href = '/login'}
                  >
                    להתחברות למערכת לחץ/י כאן
                  </Button>
                </AlertDescription>
              </Alert>
            </motion.div>
          )}

          <motion.div
            variants={itemVariants}
            className="text-center text-gray-600 max-w-2xl mx-auto"
          >
            <p>
              השאלון שלנו מסייע לנו להכיר אותך טוב יותר ולהבין את הערכים,
              השאיפות והצרכים שלך. כך נוכל למצוא עבורך את ההתאמה הטובה ביותר.
            </p>
          </motion.div>

          <motion.div
            variants={itemVariants}
            className="grid md:grid-cols-3 gap-6"
          >
            {features.map((feature, index) => (
              <Card key={index} className="bg-white">
                <CardContent className="pt-6">
                  <div className="flex flex-col items-center text-center space-y-2">
                    <div className="p-3 bg-gray-50 rounded-full">
                      {feature.icon}
                    </div>
                    <h3 className="font-medium">{feature.title}</h3>
                    <p className="text-sm text-gray-500">
                      {feature.description}
                    </p>
                  </div>
                </CardContent>
              </Card>
            ))}
          </motion.div>

          <motion.div
            variants={itemVariants}
            className="bg-blue-50 p-6 rounded-lg"
          >
            <h3 className="font-medium mb-2">מה מחכה לך?</h3>
            <ul className="space-y-2 text-sm text-gray-600">
              <li className="flex items-center">
                <ArrowRight className="w-4 h-4 ml-2 text-blue-500" />
                כ-30 דקות של שאלון מעמיק ומחכים
              </li>
              <li className="flex items-center">
                <ArrowRight className="w-4 h-4 ml-2 text-blue-500" />
                אפשרות לעצור ולהמשיך בכל שלב
              </li>
              <li className="flex items-center">
                <ArrowRight className="w-4 h-4 ml-2 text-blue-500" />
                תובנות משמעותיות על עצמך
              </li>
            </ul>
          </motion.div>
        </CardContent>

        <CardFooter className="flex flex-col sm:flex-row gap-4 justify-center pt-6">
          <Button
            variant="outline"
            onClick={onLearnMore}
            className="w-full sm:w-auto"
          >
            למידע נוסף
          </Button>
          <Button
            onClick={onStart}
            className="w-full sm:w-auto"
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
          >
            <motion.div
              className="flex items-center"
              animate={{ x: isHovered ? 5 : 0 }}
              transition={{ duration: 0.2 }}
            >
              בוא/י נתחיל
              <ArrowRight className="w-5 h-5 mr-2" />
            </motion.div>
          </Button>
        </CardFooter>
      </Card>
    </motion.div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\directory_analysis.txt:
==================================================
מבנה התיקייה:
questions
  partner
    partnerBasicQuestions.tsx
    partnerDepthQuestions.tsx
  personality
    personalityQuestionsPartOne.tsx
    personalityQuestionsPartTwo.tsx
  relationship
    relationshipBasicsQuestions.tsx
    relationshipDepthQuestions.tsx
  religion
    faithQuestions.tsx
    practicalReligionQuestions.tsx
  values
    valuesQuestionsPartOne.tsx
    valuesQuestionsPartTwo.tsx

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\partner\partnerBasicQuestions.tsx:
==================================================
// partnerBasicQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Home,
  Users,
  Brain,
  Star,
  Sun,
  Moon,
  Target,
  MessageCircle,
  Smile,
  HandHeart,
  Gift,
  Globe,
  Music,
  Book,
  Clock,
  Map,
  Baby,
  Church,
  Brush,
  Coffee,
  Laugh,
} from "lucide-react";

export const partnerBasicQuestions: Question[] = [
  {
    id: "initial_attraction",
    category: "partner",
    subcategory: "basics",
    question: "מה הכי חשוב לך במבט ראשון אצל בת זוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Smile />,
        text: "חום ונעימות",
        value: "warmth",
        description: "אישיות מקבלת ומאירת פנים",
      },
      {
        icon: <Brain />,
        text: "אינטליגנציה",
        value: "intelligence",
        description: "חוכמה וסקרנות אינטלקטואלית",
      },
      {
        icon: <Heart />,
        text: "רגישות",
        value: "sensitivity",
        description: "עדינות ואכפתיות",
      },
      {
        icon: <Laugh />,
        text: "חוש הומור",
        value: "humor",
        description: "קלילות ויכולת לצחוק",
      },
    ],
  },
  {
    id: "partner_communication_style",
    category: "partner",
    subcategory: "basics",
    question: "איזה סגנון תקשורת היית רוצה שיהיה לבת הזוג שלך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "עמוקה ורגשית",
        value: "deep",
        description: "שיחות משמעותיות על רגשות וחיים",
      },
      {
        icon: <Coffee />,
        text: "קלילה ומשעשעת",
        value: "light",
        description: "תקשורת קלה וזורמת",
      },
      {
        icon: <Target />,
        text: "ישירה ועניינית",
        value: "direct",
        description: "תקשורת ברורה וממוקדת",
      },
      {
        icon: <HandHeart />,
        text: "תומכת ומכילה",
        value: "supportive",
        description: "הקשבה והכלה רגשית",
      },
    ],
  },
  {
    id: "partner_leisure",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תבלה את זמנה הפנוי?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Book />,
        text: "העשרה ולמידה",
        value: "learning",
      },
      {
        icon: <Users />,
        text: "פעילות חברתית",
        value: "social",
      },
      {
        icon: <Brush />,
        text: "יצירה ואומנות",
        value: "creative",
      },
      {
        icon: <Globe />,
        text: "טיולים וחוויות",
        value: "adventures",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "partner_family_approach",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה למשפחה היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "משפחתית מאוד",
        value: "very_family_oriented",
        description: "מעורבות גבוהה בחיי המשפחה",
      },
      {
        icon: <Home />,
        text: "מאוזנת",
        value: "balanced",
        description: "שילוב בין משפחה לעצמאות",
      },
      {
        icon: <Users />,
        text: "חברתית",
        value: "social",
        description: "דגש על קשרים חברתיים",
      },
      {
        icon: <Target />,
        text: "עצמאית",
        value: "independent",
        description: "שומרת על עצמאות אישית",
      },
    ],
  },
  {
    id: "partner_life_goals",
    category: "partner",
    subcategory: "basics",
    question: "אילו שאיפות היית רוצה שיהיו לבת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Star />,
        text: "הגשמה מקצועית",
        value: "career",
      },
      {
        icon: <Home />,
        text: "בניית משפחה",
        value: "family",
      },
      {
        icon: <Book />,
        text: "התפתחות אישית",
        value: "growth",
      },
      {
        icon: <Globe />,
        text: "השפעה חברתית",
        value: "impact",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "partner_emotional_expression",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תביע רגשות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "רגשית ופתוחה",
        value: "expressive",
        description: "ביטוי חופשי של רגשות",
      },
      {
        icon: <HandHeart />,
        text: "מאוזנת ויציבה",
        value: "balanced",
        description: "ביטוי רגשי מאוזן",
      },
      {
        icon: <Brain />,
        text: "מחושבת ושקולה",
        value: "thoughtful",
        description: "גישה רציונלית לרגשות",
      },
      {
        icon: <Sun />,
        text: "אופטימית ומעודדת",
        value: "positive",
        description: "דגש על חיוביות",
      },
    ],
  },
  {
    id: "partner_lifestyle",
    category: "partner",
    subcategory: "basics",
    question: "איזה סגנון חיים היית רוצה שיהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Globe />,
        text: "הרפתקני ודינמי",
        value: "adventurous",
        description: "חיים מלאי אקשן והרפתקאות",
      },
      {
        icon: <Home />,
        text: "יציב ומסודר",
        value: "stable",
        description: "חיים מאורגנים ויציבים",
      },
      {
        icon: <Music />,
        text: "יצירתי ואמנותי",
        value: "creative",
        description: "חיים של יצירה והבעה",
      },
      {
        icon: <Book />,
        text: "אינטלקטואלי",
        value: "intellectual",
        description: "חיים של למידה והעשרה",
      },
    ],
  },
  {
    id: "partner_social_style",
    category: "partner",
    subcategory: "basics",
    question: "איזה סגנון חברתי היית רוצה שיהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "חברותית מאוד",
        value: "very_social",
        description: "אוהבת להיות מוקפת באנשים",
      },
      {
        icon: <Home />,
        text: "מאוזנת חברתית",
        value: "balanced",
        description: "משלבת זמן חברתי ואישי",
      },
      {
        icon: <Heart />,
        text: "סלקטיבית",
        value: "selective",
        description: "מעדיפה חברויות קרובות ועמוקות",
      },
      {
        icon: <Book />,
        text: "שקטה ועצמאית",
        value: "independent",
        description: "מעדיפה זמן אישי",
      },
    ],
  },
  {
    id: "partner_values",
    category: "partner",
    subcategory: "basics",
    question: "אילו ערכים הכי חשוב לך שיהיו לבת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "אמפתיה וחמלה",
        value: "empathy",
      },
      {
        icon: <Target />,
        text: "יושרה ואמינות",
        value: "integrity",
      },
      {
        icon: <Star />,
        text: "שאפתנות",
        value: "ambition",
      },
      {
        icon: <HandHeart />,
        text: "נתינה ועזרה",
        value: "giving",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "partner_career_attitude",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לקריירה היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Star />,
        text: "שאפתנית מאוד",
        value: "ambitious",
        description: "מוכוונת הצלחה והישגים",
      },
      {
        icon: <Target />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת קריירה וחיים אישיים",
      },
      {
        icon: <Heart />,
        text: "מוכוונת משמעות",
        value: "meaningful",
        description: "מחפשת סיפוק והשפעה",
      },
      {
        icon: <Home />,
        text: "גמישה",
        value: "flexible",
        description: "מתאימה את העבודה לחיים",
      },
    ],
  },
  {
    id: "partner_decision_making",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תקבל החלטות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Brain />,
        text: "רציונלית",
        value: "rational",
        description: "מבוססת על ניתוח והיגיון",
      },
      {
        icon: <Heart />,
        text: "אינטואיטיבית",
        value: "intuitive",
        description: "מקשיבה לתחושות הבטן",
      },
      {
        icon: <Users />,
        text: "משתפת",
        value: "collaborative",
        description: "מתייעצת עם אחרים",
      },
      {
        icon: <Target />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת רגש והיגיון",
      },
    ],
  },
  {
    id: "partner_conflict_resolution",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמודד עם קונפליקטים?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "דיון פתוח",
        value: "open_discussion",
        description: "מעדיפה לדבר על הכל",
      },
      {
        icon: <HandHeart />,
        text: "פשרה והבנה",
        value: "compromise",
        description: "מחפשת פתרון מאוזן",
      },
      {
        icon: <Clock />,
        text: "זמן לעיבוד",
        value: "processing",
        description: "לוקחת זמן לחשיבה",
      },
      {
        icon: <Target />,
        text: "פתרון מעשי",
        value: "practical",
        description: "מחפשת פתרונות מעשיים",
      },
    ],
  },
  {
    id: "partner_religious_approach",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לדת ומסורת היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Church />,
        text: "מסורתית מאוד",
        value: "very_religious",
        description: "שומרת על מסורת וערכי דת",
      },
      {
        icon: <Star />,
        text: "מסורתית גמישה",
        value: "flexible_traditional",
        description: "משלבת מסורת עם מודרניות",
      },
      {
        icon: <Heart />,
        text: "חיבור רוחני",
        value: "spiritual",
        description: "מחוברת לערכים רוחניים",
      },
      {
        icon: <Sun />,
        text: "חילונית",
        value: "secular",
        description: "מנהלת אורח חיים חילוני",
      },
    ],
  },
  {
    id: "partner_personal_growth",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה להתפתחות אישית היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Book />,
        text: "לומדת תמיד",
        value: "constant_learner",
        description: "משקיעה בלמידה והתפתחות",
      },
      {
        icon: <Target />,
        text: "מכוונת מטרות",
        value: "goal_oriented",
        description: "מציבה ומשיגה יעדים",
      },
      {
        icon: <Heart />,
        text: "צמיחה רגשית",
        value: "emotional_growth",
        description: "מתפתחת מבחינה רגשית",
      },
      {
        icon: <Globe />,
        text: "פתוחה לחוויות",
        value: "open_minded",
        description: "פתוחה להתנסויות חדשות",
      },
    ],
  },
  {
    id: "partner_support_style",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמוך בך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <HandHeart />,
        text: "תמיכה רגשית",
        value: "emotional_support",
        description: "מקשיבה ומכילה רגשית",
      },
      {
        icon: <Target />,
        text: "תמיכה מעשית",
        value: "practical_support",
        description: "עוזרת במציאת פתרונות",
      },
      {
        icon: <Star />,
        text: "מעודדת צמיחה",
        value: "growth_support",
        description: "דוחפת להתפתח ולהתקדם",
      },
      {
        icon: <Sun />,
        text: "נוכחות תומכת",
        value: "presence",
        description: "פשוט נמצאת שם בשבילי",
      },
    ],
  },
  {
    id: "partner_intimacy_approach",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לקרבה ואינטימיות היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "רומנטית",
        value: "romantic",
        description: "מחפשת רומנטיקה ואינטימיות",
      },
      {
        icon: <MessageCircle />,
        text: "רגשית",
        value: "emotional",
        description: "מעדיפה חיבור רגשי עמוק",
      },
      {
        icon: <HandHeart />,
        text: "פיזית",
        value: "physical",
        description: "מעריכה מגע וקרבה פיזית",
      },
      {
        icon: <Target />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת בין כל סוגי הקרבה",
      },
    ],
  },
  {
    id: "partner_future_vision",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תראה את העתיד המשותף?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Map />,
        text: "מתכננת",
        value: "planner",
        description: "אוהבת לתכנן את העתיד",
      },
      {
        icon: <Globe />,
        text: "הרפתקנית",
        value: "adventurous",
        description: "פתוחה להזדמנויות חדשות",
      },
      {
        icon: <Home />,
        text: "יציבה",
        value: "stable",
        description: "מחפשת יציבות וביטחון",
      },
      {
        icon: <Star />,
        text: "שאפתנית",
        value: "ambitious",
        description: "מציבה יעדים גבוהים",
      },
    ],
  },
  {
    id: "partner_interests",
    category: "partner",
    subcategory: "basics",
    question: "אילו תחומי עניין היית רוצה שיהיו לבת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Book />,
        text: "אינטלקטואליים",
        value: "intellectual",
      },
      {
        icon: <Music />,
        text: "אומנות ותרבות",
        value: "arts",
      },
      {
        icon: <Globe />,
        text: "טיולים וטבע",
        value: "nature",
      },
      {
        icon: <Users />,
        text: "חברה וקהילה",
        value: "community",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "partner_independence",
    category: "partner",
    subcategory: "basics",
    question: "איזו רמת עצמאות היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Star />,
        text: "עצמאית מאוד",
        value: "very_independent",
        description: "אוהבת לעשות דברים לבד",
      },
      {
        icon: <Users />,
        text: "משלבת",
        value: "balanced",
        description: "משלבת עצמאות ושותפות",
      },
      {
        icon: <Heart />,
        text: "מחוברת",
        value: "connected",
        description: "מעדיפה לעשות דברים יחד",
      },
      {
        icon: <Target />,
        text: "גמישה",
        value: "flexible",
        description: "מתאימה את עצמה למצב",
      },
    ],
  },
  {
    id: "partner_emotions_handling",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמודד עם רגשות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "משתפת",
        value: "expressive",
        description: "מדברת על רגשות בפתיחות",
      },
      {
        icon: <Brain />,
        text: "מעבדת",
        value: "processing",
        description: "מעבדת רגשות בפנים",
      },
      {
        icon: <HandHeart />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת שיתוף ועיבוד",
      },
      {
        icon: <Target />,
        text: "פרקטית",
        value: "practical",
        description: "מתמקדת בפתרונות",
      },
    ],
  },
  {
    id: "partner_home_management",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לניהול הבית היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Home />,
        text: "מאורגנת",
        value: "organized",
        description: "אוהבת סדר וארגון",
      },
      {
        icon: <Heart />,
        text: "יוצרת אווירה",
        value: "atmosphere",
        description: "מתמקדת באווירה נעימה",
      },
      {
        icon: <Users />,
        text: "משתפת פעולה",
        value: "collaborative",
        description: "עובדת בשיתוף פעולה",
      },
      {
        icon: <Sun />,
        text: "גמישה",
        value: "flexible",
        description: "מסתגלת למצבים משתנים",
      },
    ],
  },
  {
    id: "partner_stress_handling",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמודד עם מצבי לחץ?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Target />,
        text: "פותרת בעיות",
        value: "problem_solver",
        description: "מתמקדת במציאת פתרונות",
      },
      {
        icon: <Heart />,
        text: "מבקשת תמיכה",
        value: "support_seeker",
        description: "משתפת ומבקשת עזרה",
      },
      {
        icon: <Sun />,
        text: "אופטימית",
        value: "optimistic",
        description: "שומרת על גישה חיובית",
      },
      {
        icon: <Brain />,
        text: "מתכננת",
        value: "planner",
        description: "מתכננת ומתארגנת מראש",
      },
    ],
  },
];

export default partnerBasicQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\partner\partnerDepthQuestions.tsx:
==================================================
// partnerDepthQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Brain,
  Star,
  Sun,
  Target,
  MessageCircle,
  HandHeart,
  Book,
  Globe,
  Home,
  Users,
  Map,
  Coffee,
  Music,
  Baby,
  Church,
} from "lucide-react";

export const partnerDepthQuestions: Question[] = [
  {
    id: "emotional_support_style",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתמוך בך ברגעים מאתגרים? תאר סיטואציה ספציפית ואיך היית רוצה שהיא תגיב",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על סוג התמיכה שאתה מחפש ואיך היית רוצה לחוות אותה...",
  },
  {
    id: "values_expression",
    category: "partner",
    subcategory: "depth",
    question:
      "אילו ערכים חשובים לך שבת הזוג תייצג בחייה? תן דוגמאות ספציפיות לאיך היית רוצה לראות ערכים אלו באים לידי ביטוי ביומיום",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "תאר את הערכים החשובים לך ואיך היית רוצה לראות אותם מתבטאים...",
  },
  {
    id: "intellectual_connection",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה סוג של חיבור אינטלקטואלי היית רוצה שיהיה ביניכם? על מה היית רוצה שתוכלו לדבר ולחשוב יחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על החיבור האינטלקטואלי שאתה מחפש...",
  },
  {
    id: "future_challenges",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שתתמודדו יחד עם אתגרים עתידיים? איזה סוג של שותפות היית רוצה ליצור בהתמודדות עם קשיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את סוג השותפות שהיית רוצה באתגרים...",
  },
  {
    id: "emotional_growth",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה לראות את בת הזוג מתפתחת מבחינה רגשית? איך הייתם יכולים לצמוח רגשית יחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על הצמיחה הרגשית שהיית רוצה לראות...",
  },
  {
    id: "life_goals_support",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתמוך במטרות החיים שלך? איזה תפקיד היית רוצה שהיא תיקח בהגשמת החלומות שלך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את התמיכה שהיית רוצה במטרות החיים שלך...",
  },
  {
    id: "shared_spirituality",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה חיבור רוחני היית רוצה שיהיה ביניכם? איך היית רוצה לחוות יחד את הצד הרוחני של החיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על החיבור הרוחני שהיית רוצה בזוגיות...",
  },
  {
    id: "conflict_resolution",
    category: "partner",
    subcategory: "depth",
    question:
      "כשיש חילוקי דעות, איך היית רוצה שבת הזוג תנהל את השיחה? תאר את הדרך האידיאלית בעיניך לפתרון קונפליקטים",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את הדרך הרצויה בעיניך לפתרון מחלוקות...",
  },
  {
    id: "quality_time",
    category: "partner",
    subcategory: "depth",
    question:
      "איך נראה בעיניך זמן איכות משמעותי עם בת זוג? אילו חוויות משותפות היית רוצה ליצור יחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את סוג הזמן המשותף שהיית רוצה...",
  },
  {
    id: "personal_growth_support",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתמוך בצמיחה האישית שלך? איזה מרחב היית רוצה לקבל להתפתחות עצמית בתוך הזוגיות?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על התמיכה שהיית רוצה בצמיחה האישית שלך...",
  },
  {
    id: "shared_dreams",
    category: "partner",
    subcategory: "depth",
    question:
      "אילו חלומות משותפים היית רוצה להגשים יחד? איך היית רוצה שתעבדו יחד להגשמת החלומות האלה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את החלומות המשותפים שהיית רוצה להגשים...",
  },
  {
    id: "emotional_intimacy",
    category: "partner",
    subcategory: "depth",
    question:
      "מה יוצר אצלך תחושה של קרבה רגשית אמיתית? איך היית רוצה לבנות ולטפח אינטימיות רגשית עם בת הזוג?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על הקרבה הרגשית שאתה מחפש...",
  },
  {
    id: "daily_partnership",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שהשותפות היומיומית ביניכם תיראה? אילו ערכים היית רוצה שינחו את החיים המשותפים שלכם?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את השותפות היומיומית שהיית רוצה...",
  },
  {
    id: "trust_building",
    category: "partner",
    subcategory: "depth",
    question:
      "מה בונה אצלך אמון בקשר? אילו התנהגויות או מאפיינים של בת הזוג יגרמו לך להרגיש שאתה יכול לתת בה אמון מלא?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על מה שבונה אצלך אמון בקשר...",
  },
  {
    id: "family_relationships",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתייחס למשפחה שלך? איזה סוג של קשר היית רוצה שייבנה בינה לבין המשפחה המורחבת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את היחסים המשפחתיים שהיית רוצה לראות...",
  },
  {
    id: "life_balance",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה איזון היית רוצה למצוא בין הזוגיות לשאר תחומי החיים? איך היית רוצה שבת הזוג תתמוך באיזון הזה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על האיזון שאתה מחפש בין תחומי החיים...",
  },
  {
    id: "mutual_growth",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה לראות את עצמכם צומחים וצומחים יחד לאורך השנים? איזה סוג של התפתחות משותפת היית רוצה ליצור?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את הצמיחה המשותפת שהיית רוצה לחוות...",
  },
  {
    id: "partner_independence",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה מרחב אישי היית רוצה שיהיה לכל אחד מכם בתוך הזוגיות? איך לדעתך צריך לאזן בין עצמאות לקרבה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על האיזון שאתה מחפש בין עצמאות וקרבה...",
  },
  {
    id: "relationship_success",
    category: "partner",
    subcategory: "depth",
    question:
      "מה נחשב בעיניך לזוגיות מוצלחת? אילו מרכיבים הכרחיים בעיניך לקשר ארוך טווח ומספק?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את תפיסתך לגבי זוגיות מוצלחת...",
  },
  {
    id: "life_philosophy",
    category: "partner",
    subcategory: "depth",
    question:
      "איזו השקפת עולם היית רוצה לחלוק עם בת הזוג? אילו ערכים ואמונות בסיסיות חשוב לך שיהיו משותפים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על השקפת העולם המשותפת שאתה מחפש...",
  },
];

export default partnerDepthQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\personality\personalityQuestionsPartOne.tsx:
==================================================
// personalityQuestionsPartOne.tsx
import { Question } from "../../types/types";
import {
  Sun,
  Moon,
  Cloud,
  Compass,
  Flower,
  Users,
  Book,
  Leaf,
  Coffee,
  Target,
  MessageCircle,
  HandHeart,
  Lightbulb,
  Brain,
  Map,
  Star,
  Heart,
  Music,
  Home,
  Edit,
  PenTool,
  Bike,
  Pizza,
  Camera,
  Globe,
  Gift,
  Watch,
  Phone,
} from "lucide-react";

export const personalityQuestionsPartOne: Question[] = [
  {
    id: "personality_description",
    category: "personality",
    subcategory: "depth",
    question: "ספר על עצמך ב10 משפטים",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "נשמח לשמוע עליך בכתיבה חופשית, כנה וזורמת",
  },
  {
    id: "personality_type",
    category: "personality",
    subcategory: "basics",
    question: "איך היית מגדיר/ה את האישיות שלך בצורה הכי מדוייקת?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Sun />,
        text: "אנרגטי/ת ופתוח/ה",
        value: "energetic",
        description: "אוהב/ת להיות במרכז העניינים ולהכיר אנשים חדשים",
      },
      {
        icon: <Moon />,
        text: "שקט/ה ומופנם/ת",
        value: "quiet",
        description: "מעדיף/ה מפגשים אינטימיים ושקט",
      },
      {
        icon: <Cloud />,
        text: "זורם/ת ומסתגל/ת",
        value: "adaptable",
        description: "גמיש/ה ומסתגל/ת בקלות למצבים חדשים",
      },
      {
        icon: <Compass />,
        text: "מוכוון/ת מטרה",
        value: "focused",
        description: "ממוקד/ת במטרות וביעדים",
      },
    ],
  },
  {
    id: "life_mission",
    category: "personality",
    subcategory: "depth",
    question: "מהי השליחות או המטרה שאת/ה מרגיש/ה שיש לך בחיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את החזון והשאיפות העמוקות שלך...",
  },
  {
    id: "social_settings",
    category: "personality",
    subcategory: "basics",
    question: "באיזו סביבה חברתית את/ה מרגיש/ה הכי בנוח?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "מסיבות גדולות",
        value: "parties",
        description: "אירועים חברתיים גדולים ותוססים",
      },
      {
        icon: <Coffee />,
        text: "מפגשים קטנים",
        value: "small_gatherings",
        description: "מפגשים אינטימיים עם חברים קרובים",
      },
      {
        icon: <Home />,
        text: "בילוי ביתי",
        value: "home",
        description: "ערבים שקטים בבית עם משפחה",
      },
      {
        icon: <Book />,
        text: "לבד או בזוג",
        value: "alone",
        description: "זמן איכות לבד או עם אדם קרוב",
      },
    ],
  },
  {
    id: "life_values",
    category: "personality",
    subcategory: "depth",
    question:
      "מהם שלושת הערכים החשובים ביותר בחייך ואיך הם באים לידי ביטוי ביומיום?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את הערכים שמנחים אותך והדוגמאות מחייך...",
  },
  {
    id: "free_time_activities",
    category: "personality",
    subcategory: "basics",
    question: "מה את/ה הכי אוהב/ת לעשות בזמן הפנוי?",
    type: "multiSelectWithOther",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Book />,
        text: "קריאה ולמידה",
        value: "reading",
      },
      {
        icon: <Bike />,
        text: "ספורט ופעילות גופנית",
        value: "sports",
      },
      {
        icon: <PenTool />,
        text: "יצירה ואומנות",
        value: "art",
      },
      {
        icon: <Music />,
        text: "מוזיקה ובידור",
        value: "music",
      },
      {
        icon: <Flower />,
        text: "טבע וגינון",
        value: "nature",
      },
      {
        icon: <Globe />,
        text: "טיולים ונסיעות",
        value: "travel",
      },
      {
        icon: <Edit />,
        text: "אחר",
        value: "other",
        allowFreeText: true,
        placeholder: "ספר/י לנו מה את/ה אוהב/ת לעשות...",
      },
    ],
    minSelections: 1,
    maxSelections: 3,
  },
  {
    id: "relationship_lessons",
    category: "personality",
    subcategory: "depth",
    question: "מה למדת על עצמך ממערכות היחסים המשמעותיות בחייך?(לאו דווקא זוגיות)",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י תובנות ולקחים ממערכות יחסים...",
  },
  {
    id: "communication_style",
    category: "personality",
    subcategory: "basics",
    question: " איזה סוג של שיח מועדף עליך ביום יום?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "קליל וכיפי",
        value: "fun",
        description: "שיח קליל שמעורב בצחוקים ואווירה כיפית",
      },
      {
        icon: <HandHeart />,
        text: "עמוק ומשמעותי",
        value: "sensitive",
        description: "שיח פורה ומשמעותי סביב ערכים",
      },
      {
        icon: <Lightbulb />,
        text: "רציני וענייני",
        value: "creative",
        description: "מדבר לעניין בלי יותר מדי חפירות",
      },
      {
        icon: <Brain />,
        text: "לא מרבה לדבר",
        value: "quiet",
        description: "שקט זה הדבר המועדף עליי",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "perfect_morning_detail",
    category: "personality",
    subcategory: "depth",
    question:
      "תאר/י את הבוקר המושלם שלך - משעת הקימה ועד הצהריים. מה כולל בוקר כזה ולמה דווקא הפעילויות האלו משמחות אותך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 50,
    maxLength: 500,
    placeholder: "תאר/י את סדר היום, הפעילויות והתחושות שעולות בך...",
  },
  {
    id: "daily_routine",
    category: "personality",
    subcategory: "basics",
    question: "איך את/ה מעדיף/ה לנהל את היום-יום?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Watch />,
        text: "שגרה מתוכננת",
        value: "structured",
        description: "לוח זמנים קבוע ומאורגן",
      },
      {
        icon: <Cloud />,
        text: "זרימה גמישה",
        value: "flexible",
        description: "התאמה לפי הצורך והמצב",
      },
      {
        icon: <Target />,
        text: "מוכוון משימות",
        value: "task_oriented",
        description: "התקדמות לפי יעדים",
      },
      {
        icon: <Sun />,
        text: "ספונטני ומשתנה",
        value: "spontaneous",
        description: "כל יום שונה ומפתיע",
      },
    ],
  },
  {
    id: "future_self",
    category: "personality",
    subcategory: "depth",
    question: "איך את/ה רואה את עצמך בעוד עשר שנים? מה השתנה ומה נשאר דומה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את החזון העתידי שלך...",
  },
];

export default personalityQuestionsPartOne;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\personality\personalityQuestionsPartTwo.tsx:
==================================================
// personalityQuestionsPartTwo.tsx
import { Question } from "../../types/types";
import {
  Brain,
  Heart,
  Star,
  Users,
  Book,
  Coffee,
  Target,
  Smile,
  Sun,
  Moon,
  Map,
  Compass,
  MessageCircle,
  HandHeart,
  Lightbulb,
  Leaf,
  Globe,
  Gift,
  Camera,
  Music,
  PenTool,
  Home,
  Cloud,
  Bike,
  Pizza,
  Watch,
  Phone,
} from "lucide-react";

export const personalityQuestionsPartTwo: Question[] = [
  {
    id: "life_challenges",
    category: "personality",
    subcategory: "depth",
    question: "מהו האתגר המשמעותי ביותר שהתגברת עליו ומה למדת ממנו על עצמך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder: "שתף/י את סיפור ההתמודדות והצמיחה...",
  },
  {
    id: "home_environment",
    category: "personality",
    subcategory: "basics",
    question: "איך את/ה אוהב/ת את סביבת המגורים שלך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Leaf />,
        text: "טבעי ומרגיע",
        value: "natural",
        description: "צמחים, אור טבעי ואווירה רגועה",
      },
      {
        icon: <Target />,
        text: "מינימליסטי ומסודר",
        value: "minimal",
        description: "נקי, מאורגן ופונקציונלי",
      },
      {
        icon: <Heart />,
        text: "חמים וביתי",
        value: "cozy",
        description: "נעים, מזמין ונוח",
      },
      {
        icon: <Star />,
        text: "מודרני ועיצובי",
        value: "modern",
        description: "סטייל עכשווי ואלמנטים עיצוביים",
      },
    ],
  },
  {
    id: "dinner_with_historical_figures",
    category: "personality",
    subcategory: "depth",
    question:
      "אם היית יכול/ה לארח לארוחת ערב שלושה אנשים מכל התקופות (חיים או היסטוריים), את מי היית מזמין/ה ומה היית רוצה ללמוד מהם?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 100,
    maxLength: 1000,
    placeholder: "ספר/י על האורחים שבחרת ומה היית רוצה לשוחח איתם...",
  },
  {
    id: "stress_relief",
    category: "personality",
    subcategory: "basics",
    question: "מה עוזר לך להירגע במצבי לחץ?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Music />,
        text: "מוזיקה ואומנות",
        value: "arts",
      },
      {
        icon: <Users />,
        text: "שיחה עם חברים",
        value: "social",
      },
      {
        icon: <Bike />,
        text: "פעילות גופנית",
        value: "exercise",
      },
      {
        icon: <Book />,
        text: "זמן שקט לבד",
        value: "alone_time",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "happiness_definition",
    category: "personality",
    subcategory: "depth",
    question: "מה משמעותו של אושר עבורך? מתי את/ה מרגיש/ה הכי מאושר/ת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי משמעות האושר...",
  },

  {
    id: "family_traditions",
    category: "personality",
    subcategory: "depth",
    question: "אילו מסורות משפחתיות חשובות לך במיוחד ולמה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "ספר/י על המסורות המשפחתיות המשמעותיות עבורך...",
  },
  {
    id: "organization_approach",
    category: "personality",
    subcategory: "basics",
    question: "איך את/ה מתייחס/ת לארגון וסדר?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Target />,
        text: "מסודר/ת ומאורגן/ת",
        value: "organized",
        description: "הכל במקום ומתוכנן",
      },
      {
        icon: <Cloud />,
        text: "גמיש/ה ומסתגל/ת",
        value: "flexible",
        description: "סדר עם גמישות",
      },
      {
        icon: <Star />,
        text: "יצירתי/ת ומשתנה",
        value: "creative",
        description: "סדר בתוך הכאוס",
      },
      {
        icon: <Heart />,
        text: "זורם/ת עם מה שיש",
        value: "flow",
        description: "פחות מתעסק/ת בארגון",
      },
    ],
  },
  {
    id: "conflict_resolution",
    category: "personality",
    subcategory: "depth",
    question: "(איך את/ה מתמודד/ת עם מחלוקות או קונפליקטים במערכות יחסים (לא דווקא זוגיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את הגישה שלך להתמודדות עם מחלוקות...",
  },
 
];

export default personalityQuestionsPartTwo;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\relationship\relationshipBasicsQuestions.tsx:
==================================================
// relationshipBasicsQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Home,
  Users,
  Calendar,
  Coffee,
  Sun,
  Moon,
  Target,
  MessageCircle,
  Smile,
  HandHeart,
  Gift,
  Globe,
  Music,
  Book,
  Clock,
  Star,
  Map,
  Baby,
  Phone,
  Wallet,
  Church,
  PenTool,
} from "lucide-react";

export const relationshipBasicsQuestions: Question[] = [
  {
    id: "relationship_type",
    category: "relationship",
    subcategory: "basics",
    question: "איזה סוג של קשר זוגי את/ה מחפש/ת?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "רומנטי ורגשי",
        value: "romantic",
        description: "דגש על חיבור רגשי עמוק ורומנטיקה"
      },
      {
        icon: <Home />,
        text: "יציב ובטוח",
        value: "stable",
        description: "בניית בית יציב ובטוח יחד"
      },
      {
        icon: <Globe />,
        text: "הרפתקני ודינמי",
        value: "adventurous",
        description: "חיים מלאי הרפתקאות וחוויות משותפות"
      },
      {
        icon: <Target />,
        text: "צומח ומתפתח",
        value: "growing",
        description: "התפתחות אישית וזוגית משותפת"
      }
    ]
  },
  {
    id: "daily_routine",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה מדמיין/ת את שגרת היום-יום הזוגית?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Sun />,
        text: "פעיל ודינמי",
        value: "active",
        description: "שגרה מלאה בפעילויות משותפות"
      },
      {
        icon: <Moon />,
        text: "רגוע ושליו",
        value: "calm",
        description: "שגרה שקטה ונינוחה"
      },
      {
        icon: <Coffee />,
        text: "מאוזן וגמיש",
        value: "balanced",
        description: "שילוב של פעילות ומנוחה"
      },
      {
        icon: <Clock />,
        text: "מתוכנן ומאורגן",
        value: "organized",
        description: "שגרה מסודרת עם תכנון משותף"
      }
    ]
  },
  {
    id: "communication_style",
    category: "relationship",
    subcategory: "basics",
    question: "מהו סגנון התקשורת המועדף עליך בזוגיות?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "שיחות עמוקות",
        value: "deep_talks"
      },
      {
        icon: <Smile />,
        text: "הומור וקלילות",
        value: "humor"
      },
      {
        icon: <HandHeart />,
        text: "מגע וחיבה",
        value: "physical"
      },
      {
        icon: <Target />,
        text: "תקשורת ישירה",
        value: "direct"
      }
    ],
    minSelections: 1,
    maxSelections: 2
  },
  {
    id: "leisure_time",
    category: "relationship",
    subcategory: "basics",
    question: "איך היית רוצה לבלות את זמן הפנאי המשותף?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Home />,
        text: "בילוי ביתי",
        value: "home"
      },
      {
        icon: <Globe />,
        text: "טיולים והרפתקאות",
        value: "adventures"
      },
      {
        icon: <Users />,
        text: "מפגשים חברתיים",
        value: "social"
      },
      {
        icon: <Book />,
        text: "תחביבים משותפים",
        value: "hobbies"
      }
    ],
    minSelections: 1,
    maxSelections: 2
  },
  {
    id: "family_vision",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את המשפחה העתידית?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Baby />,
        text: "משפחה גדולה",
        value: "large",
        description: "מספר ילדים ובית הומה"
      },
      {
        icon: <Home />,
        text: "משפחה קטנה",
        value: "small",
        description: "משפחה קטנה ואינטימית"
      },
      {
        icon: <Target />,
        text: "בשלבים",
        value: "gradual",
        description: "התפתחות הדרגתית לפי הזמן המתאים"
      },
      {
        icon: <Heart />,
        text: "פתוח לשינויים",
        value: "flexible",
        description: "גמישות בהתאם לנסיבות החיים"
      }
    ]
  },
  {
    id: "religious_approach",
    category: "relationship",
    subcategory: "basics",
    question: "מה היחס שלך לדת ומסורת בבית המשותף?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Church />,
        text: "מסורתי מאוד",
        value: "very_traditional",
        description: "שמירה קפדנית על מסורת והלכה"
      },
      {
        icon: <Star />,
        text: "מסורתי גמיש",
        value: "flexible_traditional",
        description: "שילוב מסורת עם גמישות מודרנית"
      },
      {
        icon: <Heart />,
        text: "חיבור רוחני",
        value: "spiritual",
        description: "חיבור לערכים ומשמעות ללא הקפדה דתית"
      },
      {
        icon: <Sun />,
        text: "חילוני",
        value: "secular",
        description: "אורח חיים חילוני"
      }
    ]
  },
  {
    id: "financial_approach",
    category: "relationship",
    subcategory: "basics",
    question: "מהי הגישה המועדפת עליך לניהול כספים בזוגיות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Wallet />,
        text: "ניהול משותף מלא",
        value: "shared",
        description: "קופה משותפת לכל ההוצאות"
      },
      {
        icon: <Target />,
        text: "איזון מתוכנן",
        value: "balanced",
        description: "חלוקה מסודרת של הוצאות"
      },
      {
        icon: <Map />,
        text: "הפרדה עם שיתוף",
        value: "separate_with_sharing",
        description: "חשבונות נפרדים עם הוצאות משותפות"
      },
      {
        icon: <Home />,
        text: "גמישות לפי יכולת",
        value: "flexible",
        description: "התאמה לפי היכולות של כל אחד"
      }
    ]
  },
  {
    id: "conflict_resolution",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה מעדיף/ה להתמודד עם מחלוקות בזוגיות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "שיחה מיידית",
        value: "immediate",
        description: "פתרון מיידי דרך דיון"
      },
      {
        icon: <Clock />,
        text: "זמן לעיבוד",
        value: "processing",
        description: "לקיחת זמן לחשיבה ועיבוד"
      },
      {
        icon: <HandHeart />,
        text: "גישור ופשרה",
        value: "compromise",
        description: "חיפוש פתרון מאוזן"
      },
      {
        icon: <Users />,
        text: "עזרה חיצונית",
        value: "external_help",
        description: "פתיחות לייעוץ מקצועי"
      }
    ]
  },
  {
    id: "shared_activities",
    category: "relationship",
    subcategory: "basics",
    question: "אילו פעילויות היית רוצה לשתף עם בן/בת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Globe />,
        text: "טיולים ונסיעות",
        value: "travel"
      },
      {
        icon: <Music />,
        text: "תרבות ואומנות",
        value: "culture"
      },
      {
        icon: <Book />,
        text: "למידה משותפת",
        value: "learning"
      },
      {
        icon: <Heart />,
        text: "ספורט ופעילות גופנית",
        value: "sports"
      }
    ],
    minSelections: 1,
    maxSelections: 3
  },
  {
    id: "personal_space",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את האיזון בין זמן משותף לזמן אישי בזוגיות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "רוב הזמן ביחד",
        value: "mostly_together",
        description: "העדפה לבילוי משותף"
      },
      {
        icon: <Target />,
        text: "איזון מתוכנן",
        value: "planned_balance",
        description: "חלוקה מסודרת של זמן"
      },
      {
        icon: <Home />,
        text: "עצמאות גמישה",
        value: "flexible_independence",
        description: "גמישות לפי הצורך"
      },
      {
        icon: <Map />,
        text: "עצמאות גבוהה",
        value: "high_independence",
        description: "שמירה על מרחב אישי משמעותי"
      }
    ]
  },
  {
    id: "relationship_progression",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את קצב התפתחות הקשר?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "התקדמות מהירה",
        value: "fast",
        description: "כשמרגישים - מתקדמים"
      },
      {
        icon: <Clock />,
        text: "התקדמות הדרגתית",
        value: "gradual",
        description: "צעד אחר צעד בקצב מתון"
      },
      {
        icon: <Map />,
        text: "לפי אבני דרך",
        value: "milestone_based",
        description: "התקדמות לפי יעדים מוגדרים"
      },
      {
        icon: <Sun />,
        text: "זרימה טבעית",
        value: "natural",
        description: "התקדמות אורגנית ללא תכנון"
      }
    ]
  },
  {
    id: "family_boundaries",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את הקשר עם המשפחות המורחבות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "מעורבות גבוהה",
        value: "high_involvement",
        description: "קשר הדוק ומעורבות משמעותית"
      },
      {
        icon: <Home />,
        text: "איזון בריא",
        value: "healthy_balance",
       // relationshipBasicsQuestions.tsx המשך...
       description: "קשר חם עם גבולות ברורים"
    },
    {
      icon: <Globe />,
      text: "קשר עצמאי",
      value: "independent",
      description: "שמירה על עצמאות הזוג"
    },
    {
      icon: <Map />,
      text: "גמישות מצבית",
      value: "situational",
      description: "התאמה לפי הצורך והמצב"
    }
  ]
},
{
  id: "life_values_alignment",
  category: "relationship",
  subcategory: "basics",
  question: "מה חשוב לך שיהיה משותף בין בני הזוג?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Church />,
      text: "ערכים ואמונות",
      value: "values"
    },
    {
      icon: <Target />,
      text: "מטרות חיים",
      value: "goals"
    },
    {
      icon: <Heart />,
      text: "תחומי עניין",
      value: "interests"
    },
    {
      icon: <Home />,
      text: "סגנון חיים",
      value: "lifestyle"
    }
  ],
  minSelections: 1,
  maxSelections: 3
},
{
  id: "future_challenges",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה מצפה להתמודד עם אתגרים עתידיים בזוגיות?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Users />,
      text: "התמודדות משותפת",
      value: "together",
      description: "פתרון בעיות יחד כצוות"
    },
    {
      icon: <MessageCircle />,
      text: "תקשורת פתוחה",
      value: "communication",
      description: "דיון פתוח על כל אתגר"
    },
    {
      icon: <Map />,
      text: "תכנון מראש",
      value: "planning",
      description: "הכנה והיערכות לאתגרים"
    },
    {
      icon: <HandHeart />,
      text: "גמישות ותמיכה",
      value: "support",
      description: "גמישות והסתגלות הדדית"
    }
  ]
},
{
  id: "career_balance",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה רואה את האיזון בין קריירה למשפחה?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Target />,
      text: "קריירה מרכזית",
      value: "career_focused",
      description: "דגש על התפתחות מקצועית"
    },
    {
      icon: <Home />,
      text: "משפחה במרכז",
      value: "family_focused",
      description: "עדיפות לחיי המשפחה"
    },
    {
      icon: <Star />,
      text: "איזון שווה",
      value: "balanced",
      description: "חלוקה מאוזנת בין השניים"
    },
    {
      icon: <Map />,
      text: "גמישות לפי תקופה",
      value: "flexible",
      description: "התאמה לפי שלבי החיים"
    }
  ]
},
{
  id: "decision_making",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה מעדיף/ה לקבל החלטות משותפות?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <MessageCircle />,
      text: "דיון משותף",
      value: "discussion",
      description: "החלטה משותפת אחרי דיון"
    },
    {
      icon: <Target />,
      text: "חלוקת תחומים",
      value: "divided",
      description: "כל אחד בתחומי האחריות שלו"
    },
    {
      icon: <Users />,
      text: "התייעצות חיצונית",
      value: "external",
      description: "פתיחות לעצות מאחרים"
    },
    {
      icon: <HandHeart />,
      text: "אינטואיציה וגמישות",
      value: "intuitive",
      description: "החלטה לפי תחושה והקשבה"
    }
  ]
},
{
  id: "relationship_goals",
  category: "relationship",
  subcategory: "basics",
  question: "מהם היעדים החשובים לך להשגה בחיי הזוגיות?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Heart />,
      text: "אינטימיות רגשית",
      value: "emotional"
    },
    {
      icon: <Home />,
      text: "יציבות ובטחון",
      value: "stability"
    },
    {
      icon: <Star />,
      text: "הגשמה עצמית",
      value: "fulfillment"
    },
    {
      icon: <Globe />,
      text: "חוויות משותפות",
      value: "experiences"
    }
  ],
  minSelections: 1,
  maxSelections: 3
},
{
  id: "relationship_expectations",
  category: "relationship",
  subcategory: "basics",
  question: "מהן הציפיות העיקריות שלך מבן/בת הזוג?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <HandHeart />,
      text: "תמיכה רגשית",
      value: "support"
    },
    {
      icon: <Target />,
      text: "שותפות מעשית",
      value: "partnership"
    },
    {
      icon: <MessageCircle />,
      text: "תקשורת פתוחה",
      value: "communication"
    },
    {
      icon: <Map />,
      text: "עצמאות והדדיות",
      value: "independence"
    }
  ],
  minSelections: 1,
  maxSelections: 3
},
{
  id: "lifestyle_preferences",
  category: "relationship",
  subcategory: "basics",
  question: "איזה סגנון חיים היית רוצה לבנות יחד?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Globe />,
      text: "דינמי והרפתקני",
      value: "dynamic",
      description: "חיים מלאי שינויים וחוויות"
    },
    {
      icon: <Home />,
      text: "יציב ומסורתי",
      value: "stable",
      description: "חיים שקטים ויציבים"
    },
    {
      icon: <Star />,
      text: "יצירתי וייחודי",
      value: "creative",
      description: "חיים מחוץ לקופסה"
    },
    {
      icon: <Target />,
      text: "מתוכנן ומאורגן",
      value: "organized",
      description: "חיים מסודרים ומתוכננים"
    }
  ]
},
{
  id: "quality_time",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה מעדיף/ה לבלות זמן איכות זוגי?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Home />,
      text: "רגעים שקטים בבית",
      value: "quiet_home"
    },
    {
      icon: <Globe />,
      text: "פעילויות וחוויות",
      value: "activities"
    },
    {
      icon: <MessageCircle />,
      text: "שיחות עמוקות",
      value: "conversations"
    },
    {
      icon: <Users />,
      text: "בילוי חברתי",
      value: "social"
    }
  ],
  minSelections: 1,
  maxSelections: 2
},
{
  id: "social_life",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה רואה את החיים החברתיים בזוגיות?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Users />,
      text: "חיי חברה עשירים",
      value: "very_social",
      description: "מפגשים חברתיים תכופים"
    },
    {
      icon: <Home />,
      text: "מעגל מצומצם",
      value: "close_circle",
      description: "התמקדות בחברים קרובים"
    },
    {
      icon: <Target />,
      text: "איזון חברתי",
      value: "balanced",
      description: "שילוב של זוגיות וחברה"
    },
    {
      icon: <Heart />,
      text: "זוגיות במרכז",
      value: "couple_focused",
      description: "התמקדות בזמן זוגי"
    }
  ]
}
];

export default relationshipBasicsQuestions;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\relationship\relationshipDepthQuestions.tsx:
==================================================
// relationshipDepthQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Home,
  Users,
  Brain,
  Star,
  Sun,
  Moon,
  Target,
  MessageCircle,
  HandHeart,
  Lightbulb,
  Globe,
  Gift,
  Map,
  Book,
  Compass,
  Calendar,
  Coffee,
  Baby,
  Church,
} from "lucide-react";

export const relationshipDepthQuestions: Question[] = [
  {
    id: "perfect_relationship_day",
    category: "relationship",
    subcategory: "depth",
    question:
      "תאר/י את היום המושלם בעיניך עם בן/בת הזוג. מהבוקר ועד הלילה - אילו רגעים ופעילויות יהפכו אותו למיוחד ולמה דווקא אלו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder:
      "שתף/י את החזון שלך ליום משותף מושלם, כולל הפעילויות, האווירה והרגשות שהיית רוצה לחוות...",
  },
  {
    id: "relationship_growth",
    category: "relationship",
    subcategory: "depth",
    question:
      "ספר/י על רגע משמעותי במערכת יחסים קודמת שלימד אותך משהו חשוב על עצמך ועל מה שאת/ה מחפש/ת בזוגיות. מה למדת מהחוויה הזו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "שתף/י את החוויה והתובנות שעלו ממנה לגבי עצמך ומה שחשוב לך בקשר...",
  },
  {
    id: "family_values",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם שלושת הערכים המרכזיים שהיית רוצה שינחו את המשפחה העתידית שלך? איך היית רוצה שהם יבואו לידי ביטוי בחיי היומיום?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "תאר/י את הערכים החשובים לך ואיך הם משתלבים בחזון המשפחתי שלך...",
  },
  {
    id: "partnership_vision",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה שותפות אידיאלית בזוגיות? ספר/י על החלוקה הרצויה של אחריות, קבלת החלטות ותמיכה הדדית",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי שותפות זוגית ואיך היא באה לידי ביטוי...",
  },
  {
    id: "conflict_handling",
    category: "relationship",
    subcategory: "depth",
    question:
      "תאר/י מצב של קונפליקט שהתמודדת איתו בעבר. מה למדת ממנו על הדרך שבה היית רוצה להתמודד עם מחלוקות בזוגיות?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את האתגר, דרך ההתמודדות והתובנות שלמדת ממנו...",
  },
  {
    id: "childhood_influence",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך הבית שבו גדלת השפיע על תפיסת הזוגיות שלך? מה היית רוצה לאמץ ומה היית רוצה לעשות אחרת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder:
      "שתף/י על ההשפעות מהבית, התובנות והשינויים שהיית רוצה ליצור...",
  },
  {
    id: "emotional_needs",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם הצרכים הרגשיים החשובים ביותר שלך בזוגיות? איך היית רוצה שבן/בת הזוג יבינו ויענו על צרכים אלו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "תאר/י את הצרכים הרגשיים שלך ואיך היית רוצה שיבואו לידי ביטוי...",
  },
  {
    id: "life_challenges",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך היית רוצה שהזוגיות שלך תתמודד עם אתגרי החיים הגדולים (כמו משברים, שינויים או קשיים)? מה חשוב לך בהתמודדות משותפת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי התמודדות זוגית עם אתגרים...",
  },
  {
    id: "family_dynamics",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך היית רוצה לבנות את הדינמיקה המשפחתית בבית שלך? ספר/י על האווירה, התקשורת והיחסים שהיית רוצה ליצור",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את החזון שלך לדינמיקה המשפחתית הרצויה...",
  },
  {
    id: "personal_growth",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה את הקשר בין צמיחה אישית לזוגיות? איך היית רוצה שהקשר יתמוך בהתפתחות האישית של כל אחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי האיזון בין צמיחה אישית וזוגית...",
  },
  {
    id: "life_dreams",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם החלומות הגדולים שהיית רוצה להגשים יחד עם בן/בת הזוג? איך את/ה רואה את החיים המשותפים תורמים להגשמת חלומות אלו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder: "תאר/י את החלומות המשותפים והדרך להגשמתם...",
  },
  {
    id: "intimacy_perspective",
    category: "relationship",
    subcategory: "depth",
    question:
      "מה משמעותה של אינטימיות עבורך בקשר זוגי? איך היית רוצה שהיא תבוא לידי ביטוי ברמה הרגשית והפיזית?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי אינטימיות בזוגיות...",
  },
  {
    id: "support_system",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה את מערכת התמיכה הזוגית? ספר/י על הדרכים בהן היית רוצה לתמוך ולהיתמך בקשר",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את תפיסתך לגבי תמיכה הדדית בזוגיות...",
  },
  {
    id: "cultural_traditions",
    category: "relationship",
    subcategory: "depth",
    question:
      "אילו מסורות תרבותיות או משפחתיות חשוב לך לשמר ולבנות בבית המשותף? מה המשמעות של מסורות אלו עבורך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י על המסורות החשובות לך והמשמעות שלהן...",
  },
  {
    id: "relationship_fears",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם הפחדים או החששות שלך בהקשר של זוגיות? איך היית רוצה להתמודד איתם יחד עם בן/בת הזוג?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את החששות שלך ואיך היית רוצה להתמודד איתם...",
  },
  {
    id: "future_vision",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה מדמיין/ת את חייכם המשותפים בעוד 20 שנה? מה היית רוצה שיישאר דומה ומה היית רוצה שישתנה ויתפתח?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder: "תאר/י את החזון שלך לעתיד המשותף...",
  },
  {
    id: "relationship_lessons",
    category: "relationship",
    subcategory: "depth",
    question:
      "מה הדבר המשמעותי ביותר שלמדת על עצמך ממערכות יחסים קודמות? איך זה משפיע על מה שאת/ה מחפש/ת היום?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את התובנות והלקחים שלמדת...",
  },
  {
    id: "change_handling",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה את היכולת של זוגיות להתמודד עם שינויים משמעותיים בחיים? מה חשוב לך בהתמודדות כזו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את תפיסתך לגבי התמודדות עם שינויים בזוגיות...",
  },
  {
    id: "relationship_growth",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך היית רוצה לראות את הזוגיות שלך מתפתחת וצומחת לאורך השנים? מה יעזור לה להישאר מרעננת ומתחדשת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את חזונך לצמיחה והתפתחות בזוגיות...",
  },
  {
    id: "success_definition",
    category: "relationship",
    subcategory: "depth",
    question:
      "מה מבחינתך מגדיר זוגיות מוצלחת? אילו איכויות או מאפיינים הכי חשובים לך בקשר ארוך טווח?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את תפיסתך לגבי זוגיות מוצלחת...",
  },
];

export default relationshipDepthQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\religion\faithQuestions.tsx:
==================================================
import { Question } from "../../types/types";

export const faithQuestions: Question[] = [
  // Spiritual and Religious Values
  {
    id: "spiritualMoment",
    category: "values",
    subcategory: "spiritual",
    question: "מהו הרגע הכי רוחני שחווית בחייך?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "ספר/י על חוויה משמעותית...",
    minLength: 20,
    maxLength: 500,
  },
  {
    id: "favoriteHoliday",
    category: "values",
    subcategory: "spiritual",
    question: "איזה חג יהודי הכי משמעותי עבורך?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "roshHashana", text: "ראש השנה" },
      { value: "yomKippur", text: "יום כיפור" },
      { value: "pesach", text: "פסח" },
      { value: "shavuot", text: "שבועות" },
    ],
  },

  // Personal Values
  {
    id: "coreValues",
    category: "values",
    subcategory: "personal",
    question: "מהם שלושת הערכים החשובים ביותר בחייך?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "honesty", text: "יושר ואמת" },
      { value: "family", text: "משפחה" },
      { value: "learning", text: "לימוד והתפתחות" },
      { value: "kindness", text: "חסד" },
      { value: "tradition", text: "מסורת" },
      { value: "success", text: "הצלחה" },
    ],
    minSelections: 1,
    maxSelections: 3,
  },
  {
    id: "lifeGoals",
    category: "values",
    subcategory: "personal",
    question: "מהי המטרה העיקרית שלך בחיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    placeholder: "שתף/י במטרות החיים שלך...",
    minLength: 30,
    maxLength: 500,
  },

  // Community Values
  {
    id: "communityRole",
    category: "values",
    subcategory: "community",
    question: "איזה תפקיד אתה רואה לעצמך בקהילה?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "leader", text: "מנהיג/מוביל" },
      { value: "supporter", text: "תומך ומסייע" },
      { value: "teacher", text: "מחנך/מלמד" },
      { value: "participant", text: "משתתף פעיל" },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "givingPhilosophy",
    category: "values",
    subcategory: "community",
    question: "מהי תפיסת עולמך בנושא נתינה וצדקה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    placeholder: "תאר/י את גישתך לנתינה...",
    minLength: 30,
    maxLength: 500,
  },

  // Future Values
  {
    id: "nextGeneration",
    category: "values",
    subcategory: "future",
    question: "מה הערכים החשובים ביותר שתרצה להעביר לדור הבא?",
    type: "multiSelect",
    depth: "EXPERT",
    isRequired: true,
    options: [
      { value: "torah", text: "תורה ומסורת" },
      { value: "ethics", text: "מוסר וערכים" },
      { value: "education", text: "חינוך והשכלה" },
      { value: "independence", text: "עצמאות" },
      { value: "community", text: "קהילתיות" },
    ],
    minSelections: 1,
    maxSelections: 3,
  },
  {
    id: "israelVision",
    category: "values",
    subcategory: "future",
    question: "מהו החזון שלך למדינת ישראל?",
    type: "openText",
    depth: "EXPERT",
    isRequired: true,
    placeholder: "שתף/י את חזונך...",
    minLength: 50,
    maxLength: 1000,
  }
];

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\religion\practicalReligionQuestions.tsx:
==================================================
import { Question } from "../../types/types";

export const practicalQuestions: Question[] = [
  // Basic Principles
  {
    id: "religiousWorldview",
    category: "religiousLifestyle",
    subcategory: "basicPrinciples",
    question: "מהי השקפת עולמך הדתית?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את תפיסת עולמך הדתית...",
    minLength: 20,
    maxLength: 500,
  },
  {
    id: "religiousIdentity",
    category: "religiousLifestyle",
    subcategory: "basicPrinciples",
    question: "איך אתה מגדיר את זהותך הדתית?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "charedi", text: "חרדי" },
      { value: "datiLeumi", text: "דתי לאומי" },
      { value: "masorti", text: "מסורתי" },
      { value: "other", text: "אחר" },
    ],
  },
  {
    id: "halachaImportance",
    category: "religiousLifestyle",
    subcategory: "basicPrinciples",
    question: "מה מקומה של ההלכה בחיי היומיום שלך?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את מקום ההלכה בחייך...",
    minLength: 20,
    maxLength: 500,
  },

  // Prayer and Learning
  {
    id: "minyanImportance",
    category: "religiousLifestyle",
    subcategory: "prayerAndLearning",
    question: "מהי חשיבות התפילה במניין בחייך?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "veryImportant", text: "חשוב מאוד - משתדל להתפלל כל תפילה במניין" },
      { value: "important", text: "חשוב - משתדל לפחות פעם ביום" },
      { value: "sometimes", text: "לעיתים - בעיקר בשבתות וחגים" },
      { value: "notImportant", text: "פחות חשוב לי" },
    ],
  },
  {
    id: "dailyLearning",
    category: "religiousLifestyle",
    subcategory: "prayerAndLearning",
    question: "איך נראה סדר הלימוד היומי שלך?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "dafYomi", text: "דף יומי" },
      { value: "halacha", text: "הלכה יומית" },
      { value: "parasha", text: "פרשת שבוע" },
      { value: "chassidut", text: "חסידות" },
      { value: "mussar", text: "מוסר" },
      { value: "other", text: "אחר" },
    ],
    minSelections: 1,
    maxSelections: 4,
  },
  
  // Shabbat and Holidays
  {
    id: "idealShabbat",
    category: "religiousLifestyle",
    subcategory: "shabbatAndHolidays",
    question: "איך נראית השבת האידיאלית בעיניך?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את השבת המושלמת עבורך...",
    minLength: 20,
    maxLength: 500,
  },
  {
    id: "shabbatRestrictions",
    category: "religiousLifestyle",
    subcategory: "shabbatAndHolidays",
    question: "מה יחסך לחומרות בהלכות שבת?",
    type: "multiSelect",
    depth: "ADVANCED",
    isRequired: false,
    options: [
      { value: "strict", text: "מחמיר בהלכות שבת" },
      { value: "basic", text: "שומר על ההלכות הבסיסיות" },
      { value: "flexible", text: "גמיש יותר בפרשנות" },
      { value: "situational", text: "תלוי במצב ובנסיבות" },
    ],
    minSelections: 1,
    maxSelections: 2,
  },

  // Kashrut and Halacha
  {
    id: "kashrutLevel",
    category: "religiousLifestyle",
    subcategory: "kashrutAndHalacha",
    question: "מה רמת ההקפדה שלך בכשרות?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "mehadrin", text: "מהדרין בלבד" },
      { value: "regular", text: "כשרות רגילה" },
      { value: "basic", text: "כשרות בסיסית" },
      { value: "flexible", text: "גמיש יותר" },
    ],
  },
  {
    id: "eatingOut",
    category: "religiousLifestyle",
    subcategory: "kashrutAndHalacha",
    question: "איך אתה מתייחס לאכילה מחוץ לבית?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "onlyKosher", text: "רק במסעדות כשרות" },
      { value: "familyHome", text: "אוכל בבתים של משפחה" },
      { value: "friendsHome", text: "אוכל אצל חברים" },
      { value: "flexible", text: "גמיש בהתאם לנסיבות" },
    ],
    minSelections: 1,
    maxSelections: 3,
  },

  // Modesty and Public Space
  {
    id: "modestyView",
    category: "religiousLifestyle",
    subcategory: "modestyAndPublic",
    question: "מהי השקפתך בענייני צניעות?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את תפיסתך בנושא צניעות...",
    minLength: 20,
    maxLength: 500,
  },
  {
    id: "genderSeparation",
    category: "religiousLifestyle",
    subcategory: "modestyAndPublic",
    question: "איך אתה מתייחס להפרדה בין גברים לנשים?",
    type: "singleChoice",
    depth: "ADVANCED",
    isRequired: true,
    options: [
      { value: "fullSeparation", text: "תומך בהפרדה מלאה" },
      { value: "situational", text: "תלוי בנסיבות ובמקום" },
      { value: "flexible", text: "גמיש יותר בנושא" },
      { value: "against", text: "מתנגד להפרדה" },
    ],
  },
];

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\values\valuesQuestionsPartOne.tsx:
==================================================
import { Question } from "../../types/types";
import {
  Scale,
  Heart,
  Users,
  Briefcase,
  Book,
  Globe,
  Target,
  Map,
  Leaf,
  Building,
  Gem,
  ScrollText,
  Sparkles,
  Construction,
  ShieldCheck,
  GraduationCap,
  Sword,
  Brain,
  Laptop,
  HandHeart,
  School,
  LibraryBig,
} from "lucide-react";

export const valuesQuestionsPartOne: Question[] = [
  {
    id: "military_service",
    category: "values",
    subcategory: "basics",
    question: "מהי הגישה שלך לשירות צבאי?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Sword />,
        text: "שירות קרבי מלא",
        value: "combat",
        description: "מאמין בתרומה משמעותית דרך שירות קרבי",
      },
      {
        icon: <Book />,
        text: " שילוב תורה עם צבא - הסדר",
        value: "hesder",
        description: "משלב בין לימוד תורה לשירות צבאי",
      },
      {
        icon: <LibraryBig />,
        text: "לימוד תורה",
        value: "torah",
        description: "מתמקד בלימוד תורה כדרך חיים",
      },
      {
        icon: <Laptop />,
        text: "תרומה משמעותית בכל דרך שהיא ",
        value: "tech",
        description: "תורם גם דרך יכולות טכנולוגיות ומקצועיות",
      },
    ],
  },
  {
    id: "economic_worldview",
    category: "values",
    subcategory: "basics",
    question: "מהי תפיסת העולם הכלכלית שלך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Gem />,
        text: "שאיפה להצלחה",
        value: "success",
        description: "מאמין בחשיבות ההצלחה הכלכלית",
      },
      {
        icon: <Scale />,
        text: "איזון והסתפקות",
        value: "balance",
        description: "מחפש איזון בין רווחה לערכים",
      },
      {
        icon: <Leaf />,
        text: "פשטות",
        value: "simplicity",
        description: "מעדיף חיים פשוטים וצנועים",
      },
      {
        icon: <Target />,
        text: "יעדים מדודים",
        value: "goals",
        description: " לפי צורך המשפחה - מציב ומשיג יעדים כלכליים מתוכננים",
      },
    ],
  },
  {
    id: "education_approach",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך ללימודי חול?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <School />,
        text: "לימודי ליבה מלאים",
        value: "full_core",
        description: "תומך בשילוב מלא של לימודי ליבה",
      },
      {
        icon: <Scale />,
        text: "שילוב מאוזן",
        value: "balanced",
        description: "משלב לימודי קודש וחול באופן מאוזן",
      },
      {
        icon: <Book />,
        text: "התמקדות בקודש",
        value: "torah_focus",
        description: "מעדיף להתמקד בלימודי קודש",
      },
      {
        icon: <Brain />,
        text: "למידה לפי צורך",
        value: "as_needed",
        description: "רוכש השכלה בהתאם לצרכים המעשיים",
      },
    ],
  },
  {
    id: "medical_approach",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך לרפואה ובריאות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Building />,
        text: "רפואה קונבנציונלית",
        value: "conventional",
        description: "מאמין ברפואה המערבית המסורתית",
      },
      {
        icon: <Leaf />,
        text: "רפואה משלימה",
        value: "alternative",
        description: "פתוח לשיטות ריפוי טבעיות",
      },
      {
        icon: <Scale />,
        text: "גישה משולבת",
        value: "integrated",
        description: "משלב בין שיטות טיפול שונות",
      },
      {
        icon: <Brain />,
        text: "מחקר עצמאי",
        value: "research",
        description: "חוקר ולומד לפני קבלת החלטות",
      },
    ],
  },
  {
    id: "career_priorities",
    category: "values",
    subcategory: "basics",
    question: "מה חשוב לך בקריירה?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <HandHeart />,
        text: "תרומה לחברה",
        value: "contribution",
        description: "עבודה שמשפיעה על החברה",
      },
      {
        icon: <Briefcase />,
        text: "יציבות כלכלית",
        value: "stability",
        description: "ביטחון תעסוקתי והכנסה יציבה",
      },
      {
        icon: <Target />,
        text: "הישגיות",
        value: "achievement",
        description: "התפתחות מקצועית והצלחה",
      },
      {
        icon: <Scale />,
        text: "איזון",
        value: "balance",
        description: "איזון בין קריירה לחיים אישיים",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
];

export default valuesQuestionsPartOne;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\values\valuesQuestionsPartTwo.tsx:
==================================================
import { Question } from "../../types/types";
import {
  Scale,
  Heart,
  Users,
  Globe,
  Target,
  Map,
  Leaf,
  Building,
  ScrollText,
  Construction,
  ShieldCheck,
  GraduationCap,
  Sword,
  Brain,
  Laptop,
  HandHeart,
  School,
  LibraryBig,
  Flag,
  Star,
  TreePine,
  Church,
  Briefcase,
} from "lucide-react";

export const valuesQuestionsPartTwo: Question[] = [
  {
    id: "state_religion",
    category: "values",
    subcategory: "depth",
    question: "מהי תפיסתך לגבי היחס בין דת ומדינה?",
    type: "iconChoice",
    depth: "ADVANCED",
    isRequired: true,
    options: [
      {
        icon: <Flag />,
        text: "הפרדה מלאה",
        value: "separation",
        description: "תומך בהפרדה בין דת ומדינה",
      },
      {
        icon: <Scale />,
        text: "איזון עדין",
        value: "balance",
        description: "מחפש איזון בין מסורת למודרנה",
      },
      {
        icon: <Church />,
        text: "זהות יהודית",
        value: "jewish_identity",
        description: "מעדיף שמירה על צביון יהודי מסורתי",
      },
      {
        icon: <Star />,
        text: "חופש בחירה",
        value: "freedom",
        description: "תומך בחופש בחירה אישי",
      },
    ],
  },
  {
    id: "environmental_view",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך לאיכות הסביבה?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <TreePine />,
        text: "אקטיביסט סביבתי",
        value: "activist",
        description: "פעיל בנושאי סביבה וקיימות",
      },
      {
        icon: <Leaf />,
        text: "מודעות בסיסית",
        value: "aware",
        description: "משתדל לשמור על הסביבה",
      },
      {
        icon: <Scale />,
        text: "איזון מעשי",
        value: "practical",
        description: "מאזן בין צרכים לסביבה",
      },
      {
        icon: <Target />,
        text: "מיקוד בהתפתחות",
        value: "development",
        description: "מעדיף פיתוח וקדמה",
      },
    ],
  },
  {
    id: "social_responsibility",
    category: "values",
    subcategory: "depth",
    question: "מהי תפיסתך לגבי אחריות חברתית?",
    type: "multiSelect",
    depth: "ADVANCED",
    isRequired: false,
    options: [
      {
        icon: <HandHeart />,
        text: "עזרה לזולת",
        value: "helping",
        description: "מאמין בעזרה הדדית וצדקה",
      },
      {
        icon: <Users />,
        text: "מעורבות קהילתית",
        value: "community",
        description: "פעיל בקהילה ובחברה",
      },
      {
        icon: <Globe />,
        text: "אחריות גלובלית",
        value: "global",
        description: "רואה אחריות כלפי העולם כולו",
      },
      {
        icon: <Construction />,
        text: "פיתוח חברתי",
        value: "development",
        description: "מאמין בפיתוח וקידום החברה",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    id: "shabbat_public",
    category: "values",
    subcategory: "depth",
    question: "איך צריך להיראות המרחב הציבורי בשבת?",
    type: "iconChoice",
    depth: "ADVANCED",
    isRequired: true,
    options: [
      {
        icon: <ScrollText />,
        text: "שמירה מסורתית",
        value: "traditional",
        description: "תומך בשמירת צביון השבת המסורתי",
      },
      {
        icon: <Scale />,
        text: "איזון מקומי",
        value: "local_balance",
        description: "תומך בהסדרה לפי אופי האזור",
      },
      {
        icon: <Star />,
        text: "חופש בחירה",
        value: "freedom",
        description: "תומך בחופש בחירה מלא",
      },
      {
        icon: <Map />,
        text: "הפרדה אזורית",
        value: "separation",
        description: "תומך בהפרדה בין אזורים שונים",
      },
    ],
  },
  {
    id: "technology_integration",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך לשילוב טכנולוגיה בחיים?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Laptop />,
        text: "אימוץ מלא",
        value: "full_adoption",
        description: "מאמץ חידושים טכנולוגיים",
      },
      {
        icon: <Scale />,
        text: "שילוב מבוקר",
        value: "controlled",
        description: "משלב טכנולוגיה באופן מאוזן",
      },
      {
        icon: <Brain />,
        text: "גישה ביקורתית",
        value: "critical",
        description: "בוחן כל חידוש בקפידה",
      },
      {
        icon: <Target />,
        text: "שימוש מינימלי",
        value: "minimal",
        description: "מעדיף להגביל שימוש בטכנולוגיה",
      },
    ],
  },
];

export default valuesQuestionsPartTwo;



==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\partner\partnerBasicQuestions.tsx:
==================================================
// partnerBasicQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Home,
  Users,
  Brain,
  Star,
  Sun,
  Moon,
  Target,
  MessageCircle,
  Smile,
  HandHeart,
  Gift,
  Globe,
  Music,
  Book,
  Clock,
  Map,
  Baby,
  Church,
  Brush,
  Coffee,
  Laugh,
} from "lucide-react";

export const partnerBasicQuestions: Question[] = [
  {
    worldId: "PARTNER",
    id: "initial_attraction",
    category: "partner",
    subcategory: "basics",
    question: "מה הכי חשוב לך במבט ראשון אצל בת זוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Smile />,
        text: "חום ונעימות",
        value: "warmth",
        description: "אישיות מקבלת ומאירת פנים",
      },
      {
        icon: <Brain />,
        text: "אינטליגנציה",
        value: "intelligence",
        description: "חוכמה וסקרנות אינטלקטואלית",
      },
      {
        icon: <Heart />,
        text: "רגישות",
        value: "sensitivity",
        description: "עדינות ואכפתיות",
      },
      {
        icon: <Laugh />,
        text: "חוש הומור",
        value: "humor",
        description: "קלילות ויכולת לצחוק",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_communication_style",
    category: "partner",
    subcategory: "basics",
    question: "איזה סגנון תקשורת היית רוצה שיהיה לבת הזוג שלך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "עמוקה ורגשית",
        value: "deep",
        description: "שיחות משמעותיות על רגשות וחיים",
      },
      {
        icon: <Coffee />,
        text: "קלילה ומשעשעת",
        value: "light",
        description: "תקשורת קלה וזורמת",
      },
      {
        icon: <Target />,
        text: "ישירה ועניינית",
        value: "direct",
        description: "תקשורת ברורה וממוקדת",
      },
      {
        icon: <HandHeart />,
        text: "תומכת ומכילה",
        value: "supportive",
        description: "הקשבה והכלה רגשית",
      },
    ],
  },
  {
    worldId: "PARTNER",
id: "partner_leisure",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תבלה את זמנה הפנוי?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Book />,
        text: "העשרה ולמידה",
        value: "learning",
      },
      {
        icon: <Users />,
        text: "פעילות חברתית",
        value: "social",
      },
      {
        icon: <Brush />,
        text: "יצירה ואומנות",
        value: "creative",
      },
      {
        icon: <Globe />,
        text: "טיולים וחוויות",
        value: "adventures",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    worldId: "PARTNER",
    id:  "partner_family_approach",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה למשפחה היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "משפחתית מאוד",
        value: "very_family_oriented",
        description: "מעורבות גבוהה בחיי המשפחה",
      },
      {
        icon: <Home />,
        text: "מאוזנת",
        value: "balanced",
        description: "שילוב בין משפחה לעצמאות",
      },
      {
        icon: <Users />,
        text: "חברתית",
        value: "social",
        description: "דגש על קשרים חברתיים",
      },
      {
        icon: <Target />,
        text: "עצמאית",
        value: "independent",
        description: "שומרת על עצמאות אישית",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_life_goals",
    category: "partner",
    subcategory: "basics",
    question: "אילו שאיפות היית רוצה שיהיו לבת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Star />,
        text: "הגשמה מקצועית",
        value: "career",
      },
      {
        icon: <Home />,
        text: "בניית משפחה",
        value: "family",
      },
      {
        icon: <Book />,
        text: "התפתחות אישית",
        value: "growth",
      },
      {
        icon: <Globe />,
        text: "השפעה חברתית",
        value: "impact",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    worldId: "PARTNER",
    id: "partner_emotional_expression",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תביע רגשות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "רגשית ופתוחה",
        value: "expressive",
        description: "ביטוי חופשי של רגשות",
      },
      {
        icon: <HandHeart />,
        text: "מאוזנת ויציבה",
        value: "balanced",
        description: "ביטוי רגשי מאוזן",
      },
      {
        icon: <Brain />,
        text: "מחושבת ושקולה",
        value: "thoughtful",
        description: "גישה רציונלית לרגשות",
      },
      {
        icon: <Sun />,
        text: "אופטימית ומעודדת",
        value: "positive",
        description: "דגש על חיוביות",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_lifestyle",
    category: "partner",
    subcategory: "basics",
    question: "איזה סגנון חיים היית רוצה שיהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Globe />,
        text: "הרפתקני ודינמי",
        value: "adventurous",
        description: "חיים מלאי אקשן והרפתקאות",
      },
      {
        icon: <Home />,
        text: "יציב ומסודר",
        value: "stable",
        description: "חיים מאורגנים ויציבים",
      },
      {
        icon: <Music />,
        text: "יצירתי ואמנותי",
        value: "creative",
        description: "חיים של יצירה והבעה",
      },
      {
        icon: <Book />,
        text: "אינטלקטואלי",
        value: "intellectual",
        description: "חיים של למידה והעשרה",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_social_style",
    category: "partner",
    subcategory: "basics",
    question: "איזה סגנון חברתי היית רוצה שיהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "חברותית מאוד",
        value: "very_social",
        description: "אוהבת להיות מוקפת באנשים",
      },
      {
        icon: <Home />,
        text: "מאוזנת חברתית",
        value: "balanced",
        description: "משלבת זמן חברתי ואישי",
      },
      {
        icon: <Heart />,
        text: "סלקטיבית",
        value: "selective",
        description: "מעדיפה חברויות קרובות ועמוקות",
      },
      {
        icon: <Book />,
        text: "שקטה ועצמאית",
        value: "independent",
        description: "מעדיפה זמן אישי",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_values",
    category: "partner",
    subcategory: "basics",
    question: "אילו ערכים הכי חשוב לך שיהיו לבת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "אמפתיה וחמלה",
        value: "empathy",
      },
      {
        icon: <Target />,
        text: "יושרה ואמינות",
        value: "integrity",
      },
      {
        icon: <Star />,
        text: "שאפתנות",
        value: "ambition",
      },
      {
        icon: <HandHeart />,
        text: "נתינה ועזרה",
        value: "giving",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    worldId: "PARTNER",
    id: "partner_career_attitude",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לקריירה היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Star />,
        text: "שאפתנית מאוד",
        value: "ambitious",
        description: "מוכוונת הצלחה והישגים",
      },
      {
        icon: <Target />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת קריירה וחיים אישיים",
      },
      {
        icon: <Heart />,
        text: "מוכוונת משמעות",
        value: "meaningful",
        description: "מחפשת סיפוק והשפעה",
      },
      {
        icon: <Home />,
        text: "גמישה",
        value: "flexible",
        description: "מתאימה את העבודה לחיים",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_decision_making",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תקבל החלטות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Brain />,
        text: "רציונלית",
        value: "rational",
        description: "מבוססת על ניתוח והיגיון",
      },
      {
        icon: <Heart />,
        text: "אינטואיטיבית",
        value: "intuitive",
        description: "מקשיבה לתחושות הבטן",
      },
      {
        icon: <Users />,
        text: "משתפת",
        value: "collaborative",
        description: "מתייעצת עם אחרים",
      },
      {
        icon: <Target />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת רגש והיגיון",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_conflict_resolution",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמודד עם קונפליקטים?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "דיון פתוח",
        value: "open_discussion",
        description: "מעדיפה לדבר על הכל",
      },
      {
        icon: <HandHeart />,
        text: "פשרה והבנה",
        value: "compromise",
        description: "מחפשת פתרון מאוזן",
      },
      {
        icon: <Clock />,
        text: "זמן לעיבוד",
        value: "processing",
        description: "לוקחת זמן לחשיבה",
      },
      {
        icon: <Target />,
        text: "פתרון מעשי",
        value: "practical",
        description: "מחפשת פתרונות מעשיים",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_religious_approach",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לדת ומסורת היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Church />,
        text: "מסורתית מאוד",
        value: "very_religious",
        description: "שומרת על מסורת וערכי דת",
      },
      {
        icon: <Star />,
        text: "מסורתית גמישה",
        value: "flexible_traditional",
        description: "משלבת מסורת עם מודרניות",
      },
      {
        icon: <Heart />,
        text: "חיבור רוחני",
        value: "spiritual",
        description: "מחוברת לערכים רוחניים",
      },
      {
        icon: <Sun />,
        text: "חילונית",
        value: "secular",
        description: "מנהלת אורח חיים חילוני",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_personal_growth",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה להתפתחות אישית היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Book />,
        text: "לומדת תמיד",
        value: "constant_learner",
        description: "משקיעה בלמידה והתפתחות",
      },
      {
        icon: <Target />,
        text: "מכוונת מטרות",
        value: "goal_oriented",
        description: "מציבה ומשיגה יעדים",
      },
      {
        icon: <Heart />,
        text: "צמיחה רגשית",
        value: "emotional_growth",
        description: "מתפתחת מבחינה רגשית",
      },
      {
        icon: <Globe />,
        text: "פתוחה לחוויות",
        value: "open_minded",
        description: "פתוחה להתנסויות חדשות",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_support_style",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמוך בך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <HandHeart />,
        text: "תמיכה רגשית",
        value: "emotional_support",
        description: "מקשיבה ומכילה רגשית",
      },
      {
        icon: <Target />,
        text: "תמיכה מעשית",
        value: "practical_support",
        description: "עוזרת במציאת פתרונות",
      },
      {
        icon: <Star />,
        text: "מעודדת צמיחה",
        value: "growth_support",
        description: "דוחפת להתפתח ולהתקדם",
      },
      {
        icon: <Sun />,
        text: "נוכחות תומכת",
        value: "presence",
        description: "פשוט נמצאת שם בשבילי",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_intimacy_approach",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לקרבה ואינטימיות היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "רומנטית",
        value: "romantic",
        description: "מחפשת רומנטיקה ואינטימיות",
      },
      {
        icon: <MessageCircle />,
        text: "רגשית",
        value: "emotional",
        description: "מעדיפה חיבור רגשי עמוק",
      },
      {
        icon: <HandHeart />,
        text: "פיזית",
        value: "physical",
        description: "מעריכה מגע וקרבה פיזית",
      },
      {
        icon: <Target />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת בין כל סוגי הקרבה",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_future_vision",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תראה את העתיד המשותף?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Map />,
        text: "מתכננת",
        value: "planner",
        description: "אוהבת לתכנן את העתיד",
      },
      {
        icon: <Globe />,
        text: "הרפתקנית",
        value: "adventurous",
        description: "פתוחה להזדמנויות חדשות",
      },
      {
        icon: <Home />,
        text: "יציבה",
        value: "stable",
        description: "מחפשת יציבות וביטחון",
      },
      {
        icon: <Star />,
        text: "שאפתנית",
        value: "ambitious",
        description: "מציבה יעדים גבוהים",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_interests",
    category: "partner",
    subcategory: "basics",
    question: "אילו תחומי עניין היית רוצה שיהיו לבת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Book />,
        text: "אינטלקטואליים",
        value: "intellectual",
      },
      {
        icon: <Music />,
        text: "אומנות ותרבות",
        value: "arts",
      },
      {
        icon: <Globe />,
        text: "טיולים וטבע",
        value: "nature",
      },
      {
        icon: <Users />,
        text: "חברה וקהילה",
        value: "community",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    worldId: "PARTNER",
    id: "partner_independence",
    category: "partner",
    subcategory: "basics",
    question: "איזו רמת עצמאות היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Star />,
        text: "עצמאית מאוד",
        value: "very_independent",
        description: "אוהבת לעשות דברים לבד",
      },
      {
        icon: <Users />,
        text: "משלבת",
        value: "balanced",
        description: "משלבת עצמאות ושותפות",
      },
      {
        icon: <Heart />,
        text: "מחוברת",
        value: "connected",
        description: "מעדיפה לעשות דברים יחד",
      },
      {
        icon: <Target />,
        text: "גמישה",
        value: "flexible",
        description: "מתאימה את עצמה למצב",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_emotions_handling",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמודד עם רגשות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "משתפת",
        value: "expressive",
        description: "מדברת על רגשות בפתיחות",
      },
      {
        icon: <Brain />,
        text: "מעבדת",
        value: "processing",
        description: "מעבדת רגשות בפנים",
      },
      {
        icon: <HandHeart />,
        text: "מאוזנת",
        value: "balanced",
        description: "משלבת שיתוף ועיבוד",
      },
      {
        icon: <Target />,
        text: "פרקטית",
        value: "practical",
        description: "מתמקדת בפתרונות",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_home_management",
    category: "partner",
    subcategory: "basics",
    question: "איזו גישה לניהול הבית היית רוצה שתהיה לבת הזוג?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Home />,
        text: "מאורגנת",
        value: "organized",
        description: "אוהבת סדר וארגון",
      },
      {
        icon: <Heart />,
        text: "יוצרת אווירה",
        value: "atmosphere",
        description: "מתמקדת באווירה נעימה",
      },
      {
        icon: <Users />,
        text: "משתפת פעולה",
        value: "collaborative",
        description: "עובדת בשיתוף פעולה",
      },
      {
        icon: <Sun />,
        text: "גמישה",
        value: "flexible",
        description: "מסתגלת למצבים משתנים",
      },
    ],
  },
  {
    worldId: "PARTNER",
    id: "partner_stress_handling",
    category: "partner",
    subcategory: "basics",
    question: "איך היית רוצה שבת הזוג תתמודד עם מצבי לחץ?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Target />,
        text: "פותרת בעיות",
        value: "problem_solver",
        description: "מתמקדת במציאת פתרונות",
      },
      {
        icon: <Heart />,
        text: "מבקשת תמיכה",
        value: "support_seeker",
        description: "משתפת ומבקשת עזרה",
      },
      {
        icon: <Sun />,
        text: "אופטימית",
        value: "optimistic",
        description: "שומרת על גישה חיובית",
      },
      {
        icon: <Brain />,
        text: "מתכננת",
        value: "planner",
        description: "מתכננת ומתארגנת מראש",
      },
    ],
  },
];

export default partnerBasicQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\partner\partnerDepthQuestions.tsx:
==================================================
// partnerDepthQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Brain,
  Star,
  Sun,
  Target,
  MessageCircle,
  HandHeart,
  Book,
  Globe,
  Home,
  Users,
  Map,
  Coffee,
  Music,
  Baby,
  Church,
} from "lucide-react";

export const partnerDepthQuestions: Question[] = [
  {
    worldId: "PARTNER",
    id: "emotional_support_style",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתמוך בך ברגעים מאתגרים? תאר סיטואציה ספציפית ואיך היית רוצה שהיא תגיב",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על סוג התמיכה שאתה מחפש ואיך היית רוצה לחוות אותה...",
  },
  {
    worldId: "PARTNER",
    id: "values_expression",
    category: "partner",
    subcategory: "depth",
    question:
      "אילו ערכים חשובים לך שבת הזוג תייצג בחייה? תן דוגמאות ספציפיות לאיך היית רוצה לראות ערכים אלו באים לידי ביטוי ביומיום",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "תאר את הערכים החשובים לך ואיך היית רוצה לראות אותם מתבטאים...",
  },
  {
    worldId: "PARTNER",
    id: "intellectual_connection",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה סוג של חיבור אינטלקטואלי היית רוצה שיהיה ביניכם? על מה היית רוצה שתוכלו לדבר ולחשוב יחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על החיבור האינטלקטואלי שאתה מחפש...",
  },
  {
    worldId: "PARTNER",
    id: "future_challenges",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שתתמודדו יחד עם אתגרים עתידיים? איזה סוג של שותפות היית רוצה ליצור בהתמודדות עם קשיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את סוג השותפות שהיית רוצה באתגרים...",
  },
  {
    worldId: "PARTNER",
    id: "emotional_growth",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה לראות את בת הזוג מתפתחת מבחינה רגשית? איך הייתם יכולים לצמוח רגשית יחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על הצמיחה הרגשית שהיית רוצה לראות...",
  },
  {
    worldId: "PARTNER",
    id: "life_goals_support",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתמוך במטרות החיים שלך? איזה תפקיד היית רוצה שהיא תיקח בהגשמת החלומות שלך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את התמיכה שהיית רוצה במטרות החיים שלך...",
  },
  {
    worldId: "PARTNER",
    id: "shared_spirituality",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה חיבור רוחני היית רוצה שיהיה ביניכם? איך היית רוצה לחוות יחד את הצד הרוחני של החיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על החיבור הרוחני שהיית רוצה בזוגיות...",
  },
  {
    worldId: "PARTNER",
    id: "conflict_resolution",
    category: "partner",
    subcategory: "depth",
    question:
      "כשיש חילוקי דעות, איך היית רוצה שבת הזוג תנהל את השיחה? תאר את הדרך האידיאלית בעיניך לפתרון קונפליקטים",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את הדרך הרצויה בעיניך לפתרון מחלוקות...",
  },
  {
    worldId: "PARTNER",
    id: "quality_time",
    category: "partner",
    subcategory: "depth",
    question:
      "איך נראה בעיניך זמן איכות משמעותי עם בת זוג? אילו חוויות משותפות היית רוצה ליצור יחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את סוג הזמן המשותף שהיית רוצה...",
  },
  {
    worldId: "PARTNER",
    id: "personal_growth_support",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתמוך בצמיחה האישית שלך? איזה מרחב היית רוצה לקבל להתפתחות עצמית בתוך הזוגיות?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על התמיכה שהיית רוצה בצמיחה האישית שלך...",
  },
  {
    worldId: "PARTNER",
    id: "shared_dreams",
    category: "partner",
    subcategory: "depth",
    question:
      "אילו חלומות משותפים היית רוצה להגשים יחד? איך היית רוצה שתעבדו יחד להגשמת החלומות האלה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את החלומות המשותפים שהיית רוצה להגשים...",
  },
  {
    worldId: "PARTNER",
    id: "emotional_intimacy",
    category: "partner",
    subcategory: "depth",
    question:
      "מה יוצר אצלך תחושה של קרבה רגשית אמיתית? איך היית רוצה לבנות ולטפח אינטימיות רגשית עם בת הזוג?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על הקרבה הרגשית שאתה מחפש...",
  },
  {
    worldId: "PARTNER",
    id: "daily_partnership",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שהשותפות היומיומית ביניכם תיראה? אילו ערכים היית רוצה שינחו את החיים המשותפים שלכם?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את השותפות היומיומית שהיית רוצה...",
  },
  {
    worldId: "PARTNER",
    id: "trust_building",
    category: "partner",
    subcategory: "depth",
    question:
      "מה בונה אצלך אמון בקשר? אילו התנהגויות או מאפיינים של בת הזוג יגרמו לך להרגיש שאתה יכול לתת בה אמון מלא?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על מה שבונה אצלך אמון בקשר...",
  },
  {
    worldId: "PARTNER",
    id: "family_relationships",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה שבת הזוג תתייחס למשפחה שלך? איזה סוג של קשר היית רוצה שייבנה בינה לבין המשפחה המורחבת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את היחסים המשפחתיים שהיית רוצה לראות...",
  },
  {
    worldId: "PARTNER",
    id: "life_balance",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה איזון היית רוצה למצוא בין הזוגיות לשאר תחומי החיים? איך היית רוצה שבת הזוג תתמוך באיזון הזה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על האיזון שאתה מחפש בין תחומי החיים...",
  },
  {
    worldId: "PARTNER",
    id: "mutual_growth",
    category: "partner",
    subcategory: "depth",
    question:
      "איך היית רוצה לראות את עצמכם צומחים וצומחים יחד לאורך השנים? איזה סוג של התפתחות משותפת היית רוצה ליצור?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את הצמיחה המשותפת שהיית רוצה לחוות...",
  },
  {
    worldId: "PARTNER",
    id: "partner_independence",
    category: "partner",
    subcategory: "depth",
    question:
      "איזה מרחב אישי היית רוצה שיהיה לכל אחד מכם בתוך הזוגיות? איך לדעתך צריך לאזן בין עצמאות לקרבה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על האיזון שאתה מחפש בין עצמאות וקרבה...",
  },
  {
    worldId: "PARTNER",
    id: "relationship_success",
    category: "partner",
    subcategory: "depth",
    question:
      "מה נחשב בעיניך לזוגיות מוצלחת? אילו מרכיבים הכרחיים בעיניך לקשר ארוך טווח ומספק?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר את תפיסתך לגבי זוגיות מוצלחת...",
  },
  {
    worldId: "PARTNER",
    id: "life_philosophy",
    category: "partner",
    subcategory: "depth",
    question:
      "איזו השקפת עולם היית רוצה לחלוק עם בת הזוג? אילו ערכים ואמונות בסיסיות חשוב לך שיהיו משותפים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף על השקפת העולם המשותפת שאתה מחפש...",
  },
];

export default partnerDepthQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\personality\personalityQuestionsPartOne.tsx:
==================================================
// personalityQuestionsPartOne.tsx
import { Question } from "../../types/types";
import {
  Sun,
  Moon,
  Cloud,
  Compass,
  Flower,
  Users,
  Book,
  Leaf,
  Coffee,
  Target,
  MessageCircle,
  HandHeart,
  Lightbulb,
  Brain,
  Map,
  Star,
  Heart,
  Music,
  Home,
  Edit,
  PenTool,
  Bike,
  Pizza,
  Camera,
  Globe,
  Gift,
  Watch,
  Phone,
} from "lucide-react";

export const personalityQuestionsPartOne: Question[] = [
  {
    worldId: "PERSONALITY",
    id: "personality_description",
    category: "personality",
    subcategory: "depth",
    question: "ספר על עצמך ב10 משפטים",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "נשמח לשמוע עליך בכתיבה חופשית, כנה וזורמת",
  },
  {
    worldId: "PERSONALITY",
    id: "personality_type",
    category: "personality",
    subcategory: "basics",
    question: "איך היית מגדיר/ה את האישיות שלך בצורה הכי מדוייקת?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Sun />,
        text: "אנרגטי/ת ופתוח/ה",
        value: "energetic",
        description: "אוהב/ת להיות במרכז העניינים ולהכיר אנשים חדשים",
      },
      {
        icon: <Moon />,
        text: "שקט/ה ומופנם/ת",
        value: "quiet",
        description: "מעדיף/ה מפגשים אינטימיים ושקט",
      },
      {
        icon: <Cloud />,
        text: "זורם/ת ומסתגל/ת",
        value: "adaptable",
        description: "גמיש/ה ומסתגל/ת בקלות למצבים חדשים",
      },
      {
        icon: <Compass />,
        text: "מוכוון/ת מטרה",
        value: "focused",
        description: "ממוקד/ת במטרות וביעדים",
      },
    ],
  },
  {
    worldId: "PERSONALITY",

    id: "life_mission",
    category: "personality",
    subcategory: "depth",
    question: "מהי השליחות או המטרה שאת/ה מרגיש/ה שיש לך בחיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את החזון והשאיפות העמוקות שלך...",
  },
  {
    worldId: "PERSONALITY",

    id: "social_settings",
    category: "personality",
    subcategory: "basics",
    question: "באיזו סביבה חברתית את/ה מרגיש/ה הכי בנוח?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "מסיבות גדולות",
        value: "parties",
        description: "אירועים חברתיים גדולים ותוססים",
      },
      {
        icon: <Coffee />,
        text: "מפגשים קטנים",
        value: "small_gatherings",
        description: "מפגשים אינטימיים עם חברים קרובים",
      },
      {
        icon: <Home />,
        text: "בילוי ביתי",
        value: "home",
        description: "ערבים שקטים בבית עם משפחה",
      },
      {
        icon: <Book />,
        text: "לבד או בזוג",
        value: "alone",
        description: "זמן איכות לבד או עם אדם קרוב",
      },
    ],
  },
  {
    worldId: "PERSONALITY",
    id: "life_values",
    category: "personality",
    subcategory: "depth",
    question:
      "מהם שלושת הערכים החשובים ביותר בחייך ואיך הם באים לידי ביטוי ביומיום?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את הערכים שמנחים אותך והדוגמאות מחייך...",
  },
  {
    worldId: "PERSONALITY",
    id: "free_time_activities",
    category: "personality",
    subcategory: "basics",
    question: "מה את/ה הכי אוהב/ת לעשות בזמן הפנוי?",
    type: "multiSelectWithOther",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Book />,
        text: "קריאה ולמידה",
        value: "reading",
      },
      {
        icon: <Bike />,
        text: "ספורט ופעילות גופנית",
        value: "sports",
      },
      {
        icon: <PenTool />,
        text: "יצירה ואומנות",
        value: "art",
      },
      {
        icon: <Music />,
        text: "מוזיקה ובידור",
        value: "music",
      },
      {
        icon: <Flower />,
        text: "טבע וגינון",
        value: "nature",
      },
      {
        icon: <Globe />,
        text: "טיולים ונסיעות",
        value: "travel",
      },
      {
        icon: <Edit />,
        text: "אחר",
        value: "other",
        allowFreeText: true,
        placeholder: "ספר/י לנו מה את/ה אוהב/ת לעשות...",
      },
    ],
    minSelections: 1,
    maxSelections: 3,
  },
  {
    worldId: "PERSONALITY",

    id: "relationship_lessons",
    category: "personality",
    subcategory: "depth",
    question:
      "מה למדת על עצמך ממערכות היחסים המשמעותיות בחייך?(לאו דווקא זוגיות)",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י תובנות ולקחים ממערכות יחסים...",
  },
  {
    worldId: "PERSONALITY",

    id: "communication_style",
    category: "personality",
    subcategory: "basics",
    question: " איזה סוג של שיח מועדף עליך ביום יום?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "קליל וכיפי",
        value: "fun",
        description: "שיח קליל שמעורב בצחוקים ואווירה כיפית",
      },
      {
        icon: <HandHeart />,
        text: "עמוק ומשמעותי",
        value: "sensitive",
        description: "שיח פורה ומשמעותי סביב ערכים",
      },
      {
        icon: <Lightbulb />,
        text: "רציני וענייני",
        value: "creative",
        description: "מדבר לעניין בלי יותר מדי חפירות",
      },
      {
        icon: <Brain />,
        text: "לא מרבה לדבר",
        value: "quiet",
        description: "שקט זה הדבר המועדף עליי",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    worldId: "PERSONALITY",
    id: "perfect_morning_detail",
    category: "personality",
    subcategory: "depth",
    question:
      "תאר/י את הבוקר המושלם שלך - משעת הקימה ועד הצהריים. מה כולל בוקר כזה ולמה דווקא הפעילויות האלו משמחות אותך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 50,
    maxLength: 500,
    placeholder: "תאר/י את סדר היום, הפעילויות והתחושות שעולות בך...",
  },
  {
    worldId: "PERSONALITY",
    id: "daily_routine",
    category: "personality",
    subcategory: "basics",
    question: "איך את/ה מעדיף/ה לנהל את היום-יום?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Watch />,
        text: "שגרה מתוכננת",
        value: "structured",
        description: "לוח זמנים קבוע ומאורגן",
      },
      {
        icon: <Cloud />,
        text: "זרימה גמישה",
        value: "flexible",
        description: "התאמה לפי הצורך והמצב",
      },
      {
        icon: <Target />,
        text: "מוכוון משימות",
        value: "task_oriented",
        description: "התקדמות לפי יעדים",
      },
      {
        icon: <Sun />,
        text: "ספונטני ומשתנה",
        value: "spontaneous",
        description: "כל יום שונה ומפתיע",
      },
    ],
  },
  {
    worldId: "PERSONALITY",
    id: "future_self",
    category: "personality",
    subcategory: "depth",
    question: "איך את/ה רואה את עצמך בעוד עשר שנים? מה השתנה ומה נשאר דומה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את החזון העתידי שלך...",
  },
];

export default personalityQuestionsPartOne;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\personality\personalityQuestionsPartTwo.tsx:
==================================================
// personalityQuestionsPartTwo.tsx
import { Question } from "../../types/types";
import {
  Brain,
  Heart,
  Star,
  Users,
  Book,
  Coffee,
  Target,
  Smile,
  Sun,
  Moon,
  Map,
  Compass,
  MessageCircle,
  HandHeart,
  Lightbulb,
  Leaf,
  Globe,
  Gift,
  Camera,
  Music,
  PenTool,
  Home,
  Cloud,
  Bike,
  Pizza,
  Watch,
  Phone,
} from "lucide-react";

export const personalityQuestionsPartTwo: Question[] = [
  {
    worldId: "PERSONALITY",

    id: "life_challenges",
    category: "personality",
    subcategory: "depth",
    question: "מהו האתגר המשמעותי ביותר שהתגברת עליו ומה למדת ממנו על עצמך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder: "שתף/י את סיפור ההתמודדות והצמיחה...",
  },
  {
    worldId: "PERSONALITY",

    id: "home_environment",
    category: "personality",
    subcategory: "basics",
    question: "איך את/ה אוהב/ת את סביבת המגורים שלך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Leaf />,
        text: "טבעי ומרגיע",
        value: "natural",
        description: "צמחים, אור טבעי ואווירה רגועה",
      },
      {
        icon: <Target />,
        text: "מינימליסטי ומסודר",
        value: "minimal",
        description: "נקי, מאורגן ופונקציונלי",
      },
      {
        icon: <Heart />,
        text: "חמים וביתי",
        value: "cozy",
        description: "נעים, מזמין ונוח",
      },
      {
        icon: <Star />,
        text: "מודרני ועיצובי",
        value: "modern",
        description: "סטייל עכשווי ואלמנטים עיצוביים",
      },
    ],
  },
  {
    worldId: "PERSONALITY",
    id: "dinner_with_historical_figures",
    category: "personality",
    subcategory: "depth",
    question:
      "אם היית יכול/ה לארח לארוחת ערב שלושה אנשים מכל התקופות (חיים או היסטוריים), את מי היית מזמין/ה ומה היית רוצה ללמוד מהם?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: false,
    minLength: 100,
    maxLength: 1000,
    placeholder: "ספר/י על האורחים שבחרת ומה היית רוצה לשוחח איתם...",
  },
  {
    worldId: "PERSONALITY",
    id: "stress_relief",
    category: "personality",
    subcategory: "basics",
    question: "מה עוזר לך להירגע במצבי לחץ?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Music />,
        text: "מוזיקה ואומנות",
        value: "arts",
      },
      {
        icon: <Users />,
        text: "שיחה עם חברים",
        value: "social",
      },
      {
        icon: <Bike />,
        text: "פעילות גופנית",
        value: "exercise",
      },
      {
        icon: <Book />,
        text: "זמן שקט לבד",
        value: "alone_time",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    worldId: "PERSONALITY",
    id: "happiness_definition",
    category: "personality",
    subcategory: "depth",
    question: "מה משמעותו של אושר עבורך? מתי את/ה מרגיש/ה הכי מאושר/ת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי משמעות האושר...",
  },

  {
    worldId: "PERSONALITY",
    id: "family_traditions",
    category: "personality",
    subcategory: "depth",
    question: "אילו מסורות משפחתיות חשובות לך במיוחד ולמה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "ספר/י על המסורות המשפחתיות המשמעותיות עבורך...",
  },
  {
    worldId: "PERSONALITY",
    id: "organization_approach",
    category: "personality",
    subcategory: "basics",
    question: "איך את/ה מתייחס/ת לארגון וסדר?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Target />,
        text: "מסודר/ת ומאורגן/ת",
        value: "organized",
        description: "הכל במקום ומתוכנן",
      },
      {
        icon: <Cloud />,
        text: "גמיש/ה ומסתגל/ת",
        value: "flexible",
        description: "סדר עם גמישות",
      },
      {
        icon: <Star />,
        text: "יצירתי/ת ומשתנה",
        value: "creative",
        description: "סדר בתוך הכאוס",
      },
      {
        icon: <Heart />,
        text: "זורם/ת עם מה שיש",
        value: "flow",
        description: "פחות מתעסק/ת בארגון",
      },
    ],
  },
  {
    worldId: "PERSONALITY",
    id: "conflict_resolution",
    category: "personality",
    subcategory: "depth",
    question: "(איך את/ה מתמודד/ת עם מחלוקות או קונפליקטים במערכות יחסים (לא דווקא זוגיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את הגישה שלך להתמודדות עם מחלוקות...",
  },
 
];

export default personalityQuestionsPartTwo;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\relationship\relationshipBasicsQuestions.tsx:
==================================================
// relationshipBasicsQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Home,
  Users,
  Calendar,
  Coffee,
  Sun,
  Moon,
  Target,
  MessageCircle,
  Smile,
  HandHeart,
  Gift,
  Globe,
  Music,
  Book,
  Clock,
  Star,
  Map,
  Baby,
  Phone,
  Wallet,
  Church,
  PenTool,
} from "lucide-react";

export const relationshipBasicsQuestions: Question[] = [
  {
    worldId: "RELATIONSHIP",

    id: "relationship_type",
    category: "relationship",
    subcategory: "basics",
    question: "איזה סוג של קשר זוגי את/ה מחפש/ת?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "רומנטי ורגשי",
        value: "romantic",
        description: "דגש על חיבור רגשי עמוק ורומנטיקה"
      },
      {
        icon: <Home />,
        text: "יציב ובטוח",
        value: "stable",
        description: "בניית בית יציב ובטוח יחד"
      },
      {
        icon: <Globe />,
        text: "הרפתקני ודינמי",
        value: "adventurous",
        description: "חיים מלאי הרפתקאות וחוויות משותפות"
      },
      {
        icon: <Target />,
        text: "צומח ומתפתח",
        value: "growing",
        description: "התפתחות אישית וזוגית משותפת"
      }
    ]
  },
  {

    worldId: "RELATIONSHIP",

    id: "daily_routine",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה מדמיין/ת את שגרת היום-יום הזוגית?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Sun />,
        text: "פעיל ודינמי",
        value: "active",
        description: "שגרה מלאה בפעילויות משותפות"
      },
      {
        icon: <Moon />,
        text: "רגוע ושליו",
        value: "calm",
        description: "שגרה שקטה ונינוחה"
      },
      {
        icon: <Coffee />,
        text: "מאוזן וגמיש",
        value: "balanced",
        description: "שילוב של פעילות ומנוחה"
      },
      {
        icon: <Clock />,
        text: "מתוכנן ומאורגן",
        value: "organized",
        description: "שגרה מסודרת עם תכנון משותף"
      }
    ]
  },
  {
    worldId: "RELATIONSHIP",

    id: "communication_style",
    category: "relationship",
    subcategory: "basics",
    question: "מהו סגנון התקשורת המועדף עליך בזוגיות?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "שיחות עמוקות",
        value: "deep_talks"
      },
      {
        icon: <Smile />,
        text: "הומור וקלילות",
        value: "humor"
      },
      {
        icon: <HandHeart />,
        text: "מגע וחיבה",
        value: "physical"
      },
      {
        icon: <Target />,
        text: "תקשורת ישירה",
        value: "direct"
      }
    ],
    minSelections: 1,
    maxSelections: 2
  },
  {
    worldId: "RELATIONSHIP",

    id: "leisure_time",
    category: "relationship",
    subcategory: "basics",
    question: "איך היית רוצה לבלות את זמן הפנאי המשותף?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Home />,
        text: "בילוי ביתי",
        value: "home"
      },
      {
        icon: <Globe />,
        text: "טיולים והרפתקאות",
        value: "adventures"
      },
      {
        icon: <Users />,
        text: "מפגשים חברתיים",
        value: "social"
      },
      {
        icon: <Book />,
        text: "תחביבים משותפים",
        value: "hobbies"
      }
    ],
    minSelections: 1,
    maxSelections: 2
  },
  {
    worldId: "RELATIONSHIP",

    id: "family_vision",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את המשפחה העתידית?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Baby />,
        text: "משפחה גדולה",
        value: "large",
        description: "מספר ילדים ובית הומה"
      },
      {
        icon: <Home />,
        text: "משפחה קטנה",
        value: "small",
        description: "משפחה קטנה ואינטימית"
      },
      {
        icon: <Target />,
        text: "בשלבים",
        value: "gradual",
        description: "התפתחות הדרגתית לפי הזמן המתאים"
      },
      {
        icon: <Heart />,
        text: "פתוח לשינויים",
        value: "flexible",
        description: "גמישות בהתאם לנסיבות החיים"
      }
    ]
  },
  {
    worldId: "RELATIONSHIP",

    id: "religious_approach",
    category: "relationship",
    subcategory: "basics",
    question: "מה היחס שלך לדת ומסורת בבית המשותף?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Church />,
        text: "מסורתי מאוד",
        value: "very_traditional",
        description: "שמירה קפדנית על מסורת והלכה"
      },
      {
        icon: <Star />,
        text: "מסורתי גמיש",
        value: "flexible_traditional",
        description: "שילוב מסורת עם גמישות מודרנית"
      },
      {
        icon: <Heart />,
        text: "חיבור רוחני",
        value: "spiritual",
        description: "חיבור לערכים ומשמעות ללא הקפדה דתית"
      },
      {
        icon: <Sun />,
        text: "חילוני",
        value: "secular",
        description: "אורח חיים חילוני"
      }
    ]
  },
  {
    worldId: "RELATIONSHIP",
id: "financial_approach",
    category: "relationship",
    subcategory: "basics",
    question: "מהי הגישה המועדפת עליך לניהול כספים בזוגיות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Wallet />,
        text: "ניהול משותף מלא",
        value: "shared",
        description: "קופה משותפת לכל ההוצאות"
      },
      {
        icon: <Target />,
        text: "איזון מתוכנן",
        value: "balanced",
        description: "חלוקה מסודרת של הוצאות"
      },
      {
        icon: <Map />,
        text: "הפרדה עם שיתוף",
        value: "separate_with_sharing",
        description: "חשבונות נפרדים עם הוצאות משותפות"
      },
      {
        icon: <Home />,
        text: "גמישות לפי יכולת",
        value: "flexible",
        description: "התאמה לפי היכולות של כל אחד"
      }
    ]
  },
  {
    worldId: "RELATIONSHIP",
id: "conflict_resolution",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה מעדיף/ה להתמודד עם מחלוקות בזוגיות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <MessageCircle />,
        text: "שיחה מיידית",
        value: "immediate",
        description: "פתרון מיידי דרך דיון"
      },
      {
        icon: <Clock />,
        text: "זמן לעיבוד",
        value: "processing",
        description: "לקיחת זמן לחשיבה ועיבוד"
      },
      {
        icon: <HandHeart />,
        text: "גישור ופשרה",
        value: "compromise",
        description: "חיפוש פתרון מאוזן"
      },
      {
        icon: <Users />,
        text: "עזרה חיצונית",
        value: "external_help",
        description: "פתיחות לייעוץ מקצועי"
      }
    ]
  },
  {
    worldId: "RELATIONSHIP",
id: "shared_activities",
    category: "relationship",
    subcategory: "basics",
    question: "אילו פעילויות היית רוצה לשתף עם בן/בת הזוג?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Globe />,
        text: "טיולים ונסיעות",
        value: "travel"
      },
      {
        icon: <Music />,
        text: "תרבות ואומנות",
        value: "culture"
      },
      {
        icon: <Book />,
        text: "למידה משותפת",
        value: "learning"
      },
      {
        icon: <Heart />,
        text: "ספורט ופעילות גופנית",
        value: "sports"
      }
    ],
    minSelections: 1,
    maxSelections: 3
  },
  {
    worldId: "RELATIONSHIP",
    id: "personal_space",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את האיזון בין זמן משותף לזמן אישי בזוגיות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "רוב הזמן ביחד",
        value: "mostly_together",
        description: "העדפה לבילוי משותף"
      },
      {
        icon: <Target />,
        text: "איזון מתוכנן",
        value: "planned_balance",
        description: "חלוקה מסודרת של זמן"
      },
      {
        icon: <Home />,
        text: "עצמאות גמישה",
        value: "flexible_independence",
        description: "גמישות לפי הצורך"
      },
      {
        icon: <Map />,
        text: "עצמאות גבוהה",
        value: "high_independence",
        description: "שמירה על מרחב אישי משמעותי"
      }
    ]
  },
  {
    worldId: "RELATIONSHIP",
id: "relationship_progression",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את קצב התפתחות הקשר?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Heart />,
        text: "התקדמות מהירה",
        value: "fast",
        description: "כשמרגישים - מתקדמים"
      },
      {
        icon: <Clock />,
        text: "התקדמות הדרגתית",
        value: "gradual",
        description: "צעד אחר צעד בקצב מתון"
      },
      {
        icon: <Map />,
        text: "לפי אבני דרך",
        value: "milestone_based",
        description: "התקדמות לפי יעדים מוגדרים"
      },
      {
        icon: <Sun />,
        text: "זרימה טבעית",
        value: "natural",
        description: "התקדמות אורגנית ללא תכנון"
      }
    ]
  },
  {
    worldId: "RELATIONSHIP",
    id: "family_boundaries",
    category: "relationship",
    subcategory: "basics",
    question: "איך את/ה רואה את הקשר עם המשפחות המורחבות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Users />,
        text: "מעורבות גבוהה",
        value: "high_involvement",
        description: "קשר הדוק ומעורבות משמעותית"
      },
      {
        icon: <Home />,
        text: "איזון בריא",
        value: "healthy_balance",
       // relationshipBasicsQuestions.tsx המשך...
       description: "קשר חם עם גבולות ברורים"
    },
    {
      icon: <Globe />,
      text: "קשר עצמאי",
      value: "independent",
      description: "שמירה על עצמאות הזוג"
    },
    {
      icon: <Map />,
      text: "גמישות מצבית",
      value: "situational",
      description: "התאמה לפי הצורך והמצב"
    }
  ]
},
{
  worldId: "RELATIONSHIP",
  id: "life_values_alignment",
  category: "relationship",
  subcategory: "basics",
  question: "מה חשוב לך שיהיה משותף בין בני הזוג?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Church />,
      text: "ערכים ואמונות",
      value: "values"
    },
    {
      icon: <Target />,
      text: "מטרות חיים",
      value: "goals"
    },
    {
      icon: <Heart />,
      text: "תחומי עניין",
      value: "interests"
    },
    {
      icon: <Home />,
      text: "סגנון חיים",
      value: "lifestyle"
    }
  ],
  minSelections: 1,
  maxSelections: 3
},
{
  worldId: "RELATIONSHIP",
  id: "future_challenges",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה מצפה להתמודד עם אתגרים עתידיים בזוגיות?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Users />,
      text: "התמודדות משותפת",
      value: "together",
      description: "פתרון בעיות יחד כצוות"
    },
    {
      icon: <MessageCircle />,
      text: "תקשורת פתוחה",
      value: "communication",
      description: "דיון פתוח על כל אתגר"
    },
    {
      icon: <Map />,
      text: "תכנון מראש",
      value: "planning",
      description: "הכנה והיערכות לאתגרים"
    },
    {
      icon: <HandHeart />,
      text: "גמישות ותמיכה",
      value: "support",
      description: "גמישות והסתגלות הדדית"
    }
  ]
},
{
  worldId: "RELATIONSHIP",
id: "career_balance",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה רואה את האיזון בין קריירה למשפחה?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Target />,
      text: "קריירה מרכזית",
      value: "career_focused",
      description: "דגש על התפתחות מקצועית"
    },
    {
      icon: <Home />,
      text: "משפחה במרכז",
      value: "family_focused",
      description: "עדיפות לחיי המשפחה"
    },
    {
      icon: <Star />,
      text: "איזון שווה",
      value: "balanced",
      description: "חלוקה מאוזנת בין השניים"
    },
    {
      icon: <Map />,
      text: "גמישות לפי תקופה",
      value: "flexible",
      description: "התאמה לפי שלבי החיים"
    }
  ]
},
{
  worldId: "RELATIONSHIP",
  id: "decision_making",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה מעדיף/ה לקבל החלטות משותפות?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <MessageCircle />,
      text: "דיון משותף",
      value: "discussion",
      description: "החלטה משותפת אחרי דיון"
    },
    {
      icon: <Target />,
      text: "חלוקת תחומים",
      value: "divided",
      description: "כל אחד בתחומי האחריות שלו"
    },
    {
      icon: <Users />,
      text: "התייעצות חיצונית",
      value: "external",
      description: "פתיחות לעצות מאחרים"
    },
    {
      icon: <HandHeart />,
      text: "אינטואיציה וגמישות",
      value: "intuitive",
      description: "החלטה לפי תחושה והקשבה"
    }
  ]
},
{
  worldId: "RELATIONSHIP",
  id: "relationship_goals",
  category: "relationship",
  subcategory: "basics",
  question: "מהם היעדים החשובים לך להשגה בחיי הזוגיות?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Heart />,
      text: "אינטימיות רגשית",
      value: "emotional"
    },
    {
      icon: <Home />,
      text: "יציבות ובטחון",
      value: "stability"
    },
    {
      icon: <Star />,
      text: "הגשמה עצמית",
      value: "fulfillment"
    },
    {
      icon: <Globe />,
      text: "חוויות משותפות",
      value: "experiences"
    }
  ],
  minSelections: 1,
  maxSelections: 3
},
{
  worldId: "RELATIONSHIP",
  id: "relationship_expectations",
  category: "relationship",
  subcategory: "basics",
  question: "מהן הציפיות העיקריות שלך מבן/בת הזוג?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <HandHeart />,
      text: "תמיכה רגשית",
      value: "support"
    },
    {
      icon: <Target />,
      text: "שותפות מעשית",
      value: "partnership"
    },
    {
      icon: <MessageCircle />,
      text: "תקשורת פתוחה",
      value: "communication"
    },
    {
      icon: <Map />,
      text: "עצמאות והדדיות",
      value: "independence"
    }
  ],
  minSelections: 1,
  maxSelections: 3
},
{
  worldId: "RELATIONSHIP",
id: "lifestyle_preferences",
  category: "relationship",
  subcategory: "basics",
  question: "איזה סגנון חיים היית רוצה לבנות יחד?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Globe />,
      text: "דינמי והרפתקני",
      value: "dynamic",
      description: "חיים מלאי שינויים וחוויות"
    },
    {
      icon: <Home />,
      text: "יציב ומסורתי",
      value: "stable",
      description: "חיים שקטים ויציבים"
    },
    {
      icon: <Star />,
      text: "יצירתי וייחודי",
      value: "creative",
      description: "חיים מחוץ לקופסה"
    },
    {
      icon: <Target />,
      text: "מתוכנן ומאורגן",
      value: "organized",
      description: "חיים מסודרים ומתוכננים"
    }
  ]
},
{
  worldId: "RELATIONSHIP",
id: "quality_time",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה מעדיף/ה לבלות זמן איכות זוגי?",
  type: "multiSelect",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Home />,
      text: "רגעים שקטים בבית",
      value: "quiet_home"
    },
    {
      icon: <Globe />,
      text: "פעילויות וחוויות",
      value: "activities"
    },
    {
      icon: <MessageCircle />,
      text: "שיחות עמוקות",
      value: "conversations"
    },
    {
      icon: <Users />,
      text: "בילוי חברתי",
      value: "social"
    }
  ],
  minSelections: 1,
  maxSelections: 2
},
{
  worldId: "RELATIONSHIP",
  id: "social_life",
  category: "relationship",
  subcategory: "basics",
  question: "איך את/ה רואה את החיים החברתיים בזוגיות?",
  type: "iconChoice",
  depth: "BASIC",
  isRequired: true,
  options: [
    {
      icon: <Users />,
      text: "חיי חברה עשירים",
      value: "very_social",
      description: "מפגשים חברתיים תכופים"
    },
    {
      icon: <Home />,
      text: "מעגל מצומצם",
      value: "close_circle",
      description: "התמקדות בחברים קרובים"
    },
    {
      icon: <Target />,
      text: "איזון חברתי",
      value: "balanced",
      description: "שילוב של זוגיות וחברה"
    },
    {
      icon: <Heart />,
      text: "זוגיות במרכז",
      value: "couple_focused",
      description: "התמקדות בזמן זוגי"
    }
  ]
}
];

export default relationshipBasicsQuestions;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\relationship\relationshipDepthQuestions.tsx:
==================================================
// relationshipDepthQuestions.tsx
import { Question } from "../../types/types";
import {
  Heart,
  Home,
  Users,
  Brain,
  Star,
  Sun,
  Moon,
  Target,
  MessageCircle,
  HandHeart,
  Lightbulb,
  Globe,
  Gift,
  Map,
  Book,
  Compass,
  Calendar,
  Coffee,
  Baby,
  Church,
} from "lucide-react";

export const relationshipDepthQuestions: Question[] = [
  {
    worldId: "RELATIONSHIP",

    id: "perfect_relationship_day",
    category: "relationship",
    subcategory: "depth",
    question:
      "תאר/י את היום המושלם בעיניך עם בן/בת הזוג. מהבוקר ועד הלילה - אילו רגעים ופעילויות יהפכו אותו למיוחד ולמה דווקא אלו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder:
      "שתף/י את החזון שלך ליום משותף מושלם, כולל הפעילויות, האווירה והרגשות שהיית רוצה לחוות...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "relationship_growth",
    category: "relationship",
    subcategory: "depth",
    question:
      "ספר/י על רגע משמעותי במערכת יחסים קודמת שלימד אותך משהו חשוב על עצמך ועל מה שאת/ה מחפש/ת בזוגיות. מה למדת מהחוויה הזו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "שתף/י את החוויה והתובנות שעלו ממנה לגבי עצמך ומה שחשוב לך בקשר...",
  },
  {
    worldId: "RELATIONSHIP",
id: "family_values",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם שלושת הערכים המרכזיים שהיית רוצה שינחו את המשפחה העתידית שלך? איך היית רוצה שהם יבואו לידי ביטוי בחיי היומיום?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "תאר/י את הערכים החשובים לך ואיך הם משתלבים בחזון המשפחתי שלך...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "partnership_vision",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה שותפות אידיאלית בזוגיות? ספר/י על החלוקה הרצויה של אחריות, קבלת החלטות ותמיכה הדדית",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי שותפות זוגית ואיך היא באה לידי ביטוי...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "conflict_handling",
    category: "relationship",
    subcategory: "depth",
    question:
      "תאר/י מצב של קונפליקט שהתמודדת איתו בעבר. מה למדת ממנו על הדרך שבה היית רוצה להתמודד עם מחלוקות בזוגיות?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את האתגר, דרך ההתמודדות והתובנות שלמדת ממנו...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "childhood_influence",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך הבית שבו גדלת השפיע על תפיסת הזוגיות שלך? מה היית רוצה לאמץ ומה היית רוצה לעשות אחרת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder:
      "שתף/י על ההשפעות מהבית, התובנות והשינויים שהיית רוצה ליצור...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "emotional_needs",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם הצרכים הרגשיים החשובים ביותר שלך בזוגיות? איך היית רוצה שבן/בת הזוג יבינו ויענו על צרכים אלו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder:
      "תאר/י את הצרכים הרגשיים שלך ואיך היית רוצה שיבואו לידי ביטוי...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "life_challenges",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך היית רוצה שהזוגיות שלך תתמודד עם אתגרי החיים הגדולים (כמו משברים, שינויים או קשיים)? מה חשוב לך בהתמודדות משותפת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי התמודדות זוגית עם אתגרים...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "family_dynamics",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך היית רוצה לבנות את הדינמיקה המשפחתית בבית שלך? ספר/י על האווירה, התקשורת והיחסים שהיית רוצה ליצור",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את החזון שלך לדינמיקה המשפחתית הרצויה...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "personal_growth",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה את הקשר בין צמיחה אישית לזוגיות? איך היית רוצה שהקשר יתמוך בהתפתחות האישית של כל אחד?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי האיזון בין צמיחה אישית וזוגית...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "life_dreams",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם החלומות הגדולים שהיית רוצה להגשים יחד עם בן/בת הזוג? איך את/ה רואה את החיים המשותפים תורמים להגשמת חלומות אלו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder: "תאר/י את החלומות המשותפים והדרך להגשמתם...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "intimacy_perspective",
    category: "relationship",
    subcategory: "depth",
    question:
      "מה משמעותה של אינטימיות עבורך בקשר זוגי? איך היית רוצה שהיא תבוא לידי ביטוי ברמה הרגשית והפיזית?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את תפיסתך לגבי אינטימיות בזוגיות...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "support_system",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה את מערכת התמיכה הזוגית? ספר/י על הדרכים בהן היית רוצה לתמוך ולהיתמך בקשר",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את תפיסתך לגבי תמיכה הדדית בזוגיות...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "cultural_traditions",
    category: "relationship",
    subcategory: "depth",
    question:
      "אילו מסורות תרבותיות או משפחתיות חשוב לך לשמר ולבנות בבית המשותף? מה המשמעות של מסורות אלו עבורך?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י על המסורות החשובות לך והמשמעות שלהן...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "relationship_fears",
    category: "relationship",
    subcategory: "depth",
    question:
      "מהם הפחדים או החששות שלך בהקשר של זוגיות? איך היית רוצה להתמודד איתם יחד עם בן/בת הזוג?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את החששות שלך ואיך היית רוצה להתמודד איתם...",
  },
  {
    worldId: "RELATIONSHIP",
id: "future_vision",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה מדמיין/ת את חייכם המשותפים בעוד 20 שנה? מה היית רוצה שיישאר דומה ומה היית רוצה שישתנה ויתפתח?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 1000,
    placeholder: "תאר/י את החזון שלך לעתיד המשותף...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "relationship_lessons",
    category: "relationship",
    subcategory: "depth",
    question:
      "מה הדבר המשמעותי ביותר שלמדת על עצמך ממערכות יחסים קודמות? איך זה משפיע על מה שאת/ה מחפש/ת היום?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את התובנות והלקחים שלמדת...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "change_handling",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך את/ה רואה את היכולת של זוגיות להתמודד עם שינויים משמעותיים בחיים? מה חשוב לך בהתמודדות כזו?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את תפיסתך לגבי התמודדות עם שינויים בזוגיות...",
  },
  {
    worldId: "RELATIONSHIP",
    id: "relationship_growth",
    category: "relationship",
    subcategory: "depth",
    question:
      "איך היית רוצה לראות את הזוגיות שלך מתפתחת וצומחת לאורך השנים? מה יעזור לה להישאר מרעננת ומתחדשת?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "שתף/י את חזונך לצמיחה והתפתחות בזוגיות...",
  },
  {
    worldId: "RELATIONSHIP",
id: "success_definition",
    category: "relationship",
    subcategory: "depth",
    question:
      "מה מבחינתך מגדיר זוגיות מוצלחת? אילו איכויות או מאפיינים הכי חשובים לך בקשר ארוך טווח?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    minLength: 100,
    maxLength: 800,
    placeholder: "תאר/י את תפיסתך לגבי זוגיות מוצלחת...",
  },
];

export default relationshipDepthQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\religion\faithQuestions.tsx:
==================================================
import { Question } from "../../types/types";

export const faithQuestions: Question[] = [
  // Spiritual and Religious Values
  {
    worldId: "RELIGION",  id: "spiritualMoment",
    category: "values",
    subcategory: "spiritual",
    question: "מהו הרגע הכי רוחני שחווית בחייך?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "ספר/י על חוויה משמעותית...",
    minLength: 20,
    maxLength: 500,
  },
  {
    worldId: "RELIGION",
      id: "favoriteHoliday",
    category: "values",
    subcategory: "spiritual",
    question: "איזה חג יהודי הכי משמעותי עבורך?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "roshHashana", text: "ראש השנה" },
      { value: "yomKippur", text: "יום כיפור" },
      { value: "pesach", text: "פסח" },
      { value: "shavuot", text: "שבועות" },
    ],
  },

  // Personal Values
  {
    worldId: "RELIGION",
    id: "coreValues",
    category: "values",
    subcategory: "personal",
    question: "מהם שלושת הערכים החשובים ביותר בחייך?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "honesty", text: "יושר ואמת" },
      { value: "family", text: "משפחה" },
      { value: "learning", text: "לימוד והתפתחות" },
      { value: "kindness", text: "חסד" },
      { value: "tradition", text: "מסורת" },
      { value: "success", text: "הצלחה" },
    ],
    minSelections: 1,
    maxSelections: 3,
  },
  {worldId: "RELIGION",
    id: "lifeGoals",
    category: "values",
    subcategory: "personal",
    question: "מהי המטרה העיקרית שלך בחיים?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    placeholder: "שתף/י במטרות החיים שלך...",
    minLength: 30,
    maxLength: 500,
  },

  // Community Values
  {worldId: "RELIGION",
    id: "communityRole",
    category: "values",
    subcategory: "community",
    question: "איזה תפקיד אתה רואה לעצמך בקהילה?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "leader", text: "מנהיג/מוביל" },
      { value: "supporter", text: "תומך ומסייע" },
      { value: "teacher", text: "מחנך/מלמד" },
      { value: "participant", text: "משתתף פעיל" },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {worldId: "RELIGION",
    id: "givingPhilosophy",
    category: "values",
    subcategory: "community",
    question: "מהי תפיסת עולמך בנושא נתינה וצדקה?",
    type: "openText",
    depth: "ADVANCED",
    isRequired: true,
    placeholder: "תאר/י את גישתך לנתינה...",
    minLength: 30,
    maxLength: 500,
  },

  // Future Values
  {worldId: "RELIGION",
    id: "nextGeneration",
    category: "values",
    subcategory: "future",
    question: "מה הערכים החשובים ביותר שתרצה להעביר לדור הבא?",
    type: "multiSelect",
    depth: "EXPERT",
    isRequired: true,
    options: [
      { value: "torah", text: "תורה ומסורת" },
      { value: "ethics", text: "מוסר וערכים" },
      { value: "education", text: "חינוך והשכלה" },
      { value: "independence", text: "עצמאות" },
      { value: "community", text: "קהילתיות" },
    ],
    minSelections: 1,
    maxSelections: 3,
  },
  {worldId: "RELIGION",
    id: "israelVision",
    category: "values",
    subcategory: "future",
    question: "מהו החזון שלך למדינת ישראל?",
    type: "openText",
    depth: "EXPERT",
    isRequired: true,
    placeholder: "שתף/י את חזונך...",
    minLength: 50,
    maxLength: 1000,
  }
];

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\religion\practicalReligionQuestions.tsx:
==================================================
import { Question } from "../../types/types";

export const practicalQuestions: Question[] = [
  // Basic Principles
  {worldId: "RELIGION",
    id: "religiousWorldview",
    category: "religiousLifestyle",
    subcategory: "basicPrinciples",
    question: "מהי השקפת עולמך הדתית?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את תפיסת עולמך הדתית...",
    minLength: 20,
    maxLength: 500,
  },
  {worldId: "RELIGION",
    id: "religiousIdentity",
    category: "religiousLifestyle",
    subcategory: "basicPrinciples",
    question: "איך אתה מגדיר את זהותך הדתית?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "charedi", text: "חרדי" },
      { value: "datiLeumi", text: "דתי לאומי" },
      { value: "masorti", text: "מסורתי" },
      { value: "other", text: "אחר" },
    ],
  },
  {worldId: "RELIGION",
    id: "halachaImportance",
    category: "religiousLifestyle",
    subcategory: "basicPrinciples",
    question: "מה מקומה של ההלכה בחיי היומיום שלך?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את מקום ההלכה בחייך...",
    minLength: 20,
    maxLength: 500,
  },

  // Prayer and Learning
  {worldId: "RELIGION",
    id: "minyanImportance",
    category: "religiousLifestyle",
    subcategory: "prayerAndLearning",
    question: "מהי חשיבות התפילה במניין בחייך?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "veryImportant", text: "חשוב מאוד - משתדל להתפלל כל תפילה במניין" },
      { value: "important", text: "חשוב - משתדל לפחות פעם ביום" },
      { value: "sometimes", text: "לעיתים - בעיקר בשבתות וחגים" },
      { value: "notImportant", text: "פחות חשוב לי" },
    ],
  },
  {worldId: "RELIGION",
    id: "dailyLearning",
    category: "religiousLifestyle",
    subcategory: "prayerAndLearning",
    question: "איך נראה סדר הלימוד היומי שלך?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "dafYomi", text: "דף יומי" },
      { value: "halacha", text: "הלכה יומית" },
      { value: "parasha", text: "פרשת שבוע" },
      { value: "chassidut", text: "חסידות" },
      { value: "mussar", text: "מוסר" },
      { value: "other", text: "אחר" },
    ],
    minSelections: 1,
    maxSelections: 4,
  },
  
  // Shabbat and Holidays
  {worldId: "RELIGION",
    id: "idealShabbat",
    category: "religiousLifestyle",
    subcategory: "shabbatAndHolidays",
    question: "איך נראית השבת האידיאלית בעיניך?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את השבת המושלמת עבורך...",
    minLength: 20,
    maxLength: 500,
  },
  {worldId: "RELIGION",
    id: "shabbatRestrictions",
    category: "religiousLifestyle",
    subcategory: "shabbatAndHolidays",
    question: "מה יחסך לחומרות בהלכות שבת?",
    type: "multiSelect",
    depth: "ADVANCED",
    isRequired: false,
    options: [
      { value: "strict", text: "מחמיר בהלכות שבת" },
      { value: "basic", text: "שומר על ההלכות הבסיסיות" },
      { value: "flexible", text: "גמיש יותר בפרשנות" },
      { value: "situational", text: "תלוי במצב ובנסיבות" },
    ],
    minSelections: 1,
    maxSelections: 2,
  },

  // Kashrut and Halacha
  {worldId: "RELIGION",
    id: "kashrutLevel",
    category: "religiousLifestyle",
    subcategory: "kashrutAndHalacha",
    question: "מה רמת ההקפדה שלך בכשרות?",
    type: "singleChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "mehadrin", text: "מהדרין בלבד" },
      { value: "regular", text: "כשרות רגילה" },
      { value: "basic", text: "כשרות בסיסית" },
      { value: "flexible", text: "גמיש יותר" },
    ],
  },
  {worldId: "RELIGION",
    id: "eatingOut",
    category: "religiousLifestyle",
    subcategory: "kashrutAndHalacha",
    question: "איך אתה מתייחס לאכילה מחוץ לבית?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "onlyKosher", text: "רק במסעדות כשרות" },
      { value: "familyHome", text: "אוכל בבתים של משפחה" },
      { value: "friendsHome", text: "אוכל אצל חברים" },
      { value: "flexible", text: "גמיש בהתאם לנסיבות" },
    ],
    minSelections: 1,
    maxSelections: 3,
  },

  // Modesty and Public Space
  {worldId: "RELIGION",
    id: "modestyView",
    category: "religiousLifestyle",
    subcategory: "modestyAndPublic",
    question: "מהי השקפתך בענייני צניעות?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "תאר/י את תפיסתך בנושא צניעות...",
    minLength: 20,
    maxLength: 500,
  },
  {worldId: "RELIGION",
    id: "genderSeparation",
    category: "religiousLifestyle",
    subcategory: "modestyAndPublic",
    question: "איך אתה מתייחס להפרדה בין גברים לנשים?",
    type: "singleChoice",
    depth: "ADVANCED",
    isRequired: true,
    options: [
      { value: "fullSeparation", text: "תומך בהפרדה מלאה" },
      { value: "situational", text: "תלוי בנסיבות ובמקום" },
      { value: "flexible", text: "גמיש יותר בנושא" },
      { value: "against", text: "מתנגד להפרדה" },
    ],
  },
];

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\values\valuesQuestionsPartOne.tsx:
==================================================
import { Question } from "../../types/types";
import {
  Scale,
  Heart,
  Users,
  Briefcase,
  Book,
  Globe,
  Target,
  Map,
  Leaf,
  Building,
  Gem,
  ScrollText,
  Sparkles,
  Construction,
  ShieldCheck,
  GraduationCap,
  Sword,
  Brain,
  Laptop,
  HandHeart,
  School,
  LibraryBig,
} from "lucide-react";

export const valuesQuestionsPartOne: Question[] = [
  {
    worldId: "VALUES",
    id: "military_service",
    category: "values",
    subcategory: "basics",
    question: "מהי הגישה שלך לשירות צבאי?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Sword />,
        text: "שירות קרבי מלא",
        value: "combat",
        description: "מאמין בתרומה משמעותית דרך שירות קרבי",
      },
      {
        icon: <Book />,
        text: " שילוב תורה עם צבא - הסדר",
        value: "hesder",
        description: "משלב בין לימוד תורה לשירות צבאי",
      },
      {
        icon: <LibraryBig />,
        text: "לימוד תורה",
        value: "torah",
        description: "מתמקד בלימוד תורה כדרך חיים",
      },
      {
        icon: <Laptop />,
        text: "תרומה משמעותית בכל דרך שהיא ",
        value: "tech",
        description: "תורם גם דרך יכולות טכנולוגיות ומקצועיות",
      },
    ],
  },
  {
    worldId: "VALUES",
    id: "economic_worldview",
    category: "values",
    subcategory: "basics",
    question: "מהי תפיסת העולם הכלכלית שלך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Gem />,
        text: "שאיפה להצלחה",
        value: "success",
        description: "מאמין בחשיבות ההצלחה הכלכלית",
      },
      {
        icon: <Scale />,
        text: "איזון והסתפקות",
        value: "balance",
        description: "מחפש איזון בין רווחה לערכים",
      },
      {
        icon: <Leaf />,
        text: "פשטות",
        value: "simplicity",
        description: "מעדיף חיים פשוטים וצנועים",
      },
      {
        icon: <Target />,
        text: "יעדים מדודים",
        value: "goals",
        description: " לפי צורך המשפחה - מציב ומשיג יעדים כלכליים מתוכננים",
      },
    ],
  },
  {
    worldId: "VALUES",
    id: "education_approach",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך ללימודי חול?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <School />,
        text: "לימודי ליבה מלאים",
        value: "full_core",
        description: "תומך בשילוב מלא של לימודי ליבה",
      },
      {
        icon: <Scale />,
        text: "שילוב מאוזן",
        value: "balanced",
        description: "משלב לימודי קודש וחול באופן מאוזן",
      },
      {
        icon: <Book />,
        text: "התמקדות בקודש",
        value: "torah_focus",
        description: "מעדיף להתמקד בלימודי קודש",
      },
      {
        icon: <Brain />,
        text: "למידה לפי צורך",
        value: "as_needed",
        description: "רוכש השכלה בהתאם לצרכים המעשיים",
      },
    ],
  },
  {
    worldId: "VALUES",
    id: "medical_approach",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך לרפואה ובריאות?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Building />,
        text: "רפואה קונבנציונלית",
        value: "conventional",
        description: "מאמין ברפואה המערבית המסורתית",
      },
      {
        icon: <Leaf />,
        text: "רפואה משלימה",
        value: "alternative",
        description: "פתוח לשיטות ריפוי טבעיות",
      },
      {
        icon: <Scale />,
        text: "גישה משולבת",
        value: "integrated",
        description: "משלב בין שיטות טיפול שונות",
      },
      {
        icon: <Brain />,
        text: "מחקר עצמאי",
        value: "research",
        description: "חוקר ולומד לפני קבלת החלטות",
      },
    ],
  },
  {
    worldId: "VALUES",
    id: "career_priorities",
    category: "values",
    subcategory: "basics",
    question: "מה חשוב לך בקריירה?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <HandHeart />,
        text: "תרומה לחברה",
        value: "contribution",
        description: "עבודה שמשפיעה על החברה",
      },
      {
        icon: <Briefcase />,
        text: "יציבות כלכלית",
        value: "stability",
        description: "ביטחון תעסוקתי והכנסה יציבה",
      },
      {
        icon: <Target />,
        text: "הישגיות",
        value: "achievement",
        description: "התפתחות מקצועית והצלחה",
      },
      {
        icon: <Scale />,
        text: "איזון",
        value: "balance",
        description: "איזון בין קריירה לחיים אישיים",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
];

export default valuesQuestionsPartOne;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\questions\values\valuesQuestionsPartTwo.tsx:
==================================================
import { Question } from "../../types/types";
import {
  Scale,
  Heart,
  Users,
  Globe,
  Target,
  Map,
  Leaf,
  Building,
  ScrollText,
  Construction,
  ShieldCheck,
  GraduationCap,
  Sword,
  Brain,
  Laptop,
  HandHeart,
  School,
  LibraryBig,
  Flag,
  Star,
  TreePine,
  Church,
  Briefcase,
} from "lucide-react";

export const valuesQuestionsPartTwo: Question[] = [
  {
    worldId: "VALUES",
    id: "state_religion",
    category: "values",
    subcategory: "depth",
    question: "מהי תפיסתך לגבי היחס בין דת ומדינה?",
    type: "iconChoice",
    depth: "ADVANCED",
    isRequired: true,
    options: [
      {
        icon: <Flag />,
        text: "הפרדה מלאה",
        value: "separation",
        description: "תומך בהפרדה בין דת ומדינה",
      },
      {
        icon: <Scale />,
        text: "איזון עדין",
        value: "balance",
        description: "מחפש איזון בין מסורת למודרנה",
      },
      {
        icon: <Church />,
        text: "זהות יהודית",
        value: "jewish_identity",
        description: "מעדיף שמירה על צביון יהודי מסורתי",
      },
      {
        icon: <Star />,
        text: "חופש בחירה",
        value: "freedom",
        description: "תומך בחופש בחירה אישי",
      },
    ],
  },
  {
    worldId: "VALUES",
    id: "environmental_view",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך לאיכות הסביבה?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <TreePine />,
        text: "אקטיביסט סביבתי",
        value: "activist",
        description: "פעיל בנושאי סביבה וקיימות",
      },
      {
        icon: <Leaf />,
        text: "מודעות בסיסית",
        value: "aware",
        description: "משתדל לשמור על הסביבה",
      },
      {
        icon: <Scale />,
        text: "איזון מעשי",
        value: "practical",
        description: "מאזן בין צרכים לסביבה",
      },
      {
        icon: <Target />,
        text: "מיקוד בהתפתחות",
        value: "development",
        description: "מעדיף פיתוח וקדמה",
      },
    ],
  },
  {
    worldId: "VALUES",
    id: "social_responsibility",
    category: "values",
    subcategory: "depth",
    question: "מהי תפיסתך לגבי אחריות חברתית?",
    type: "multiSelect",
    depth: "ADVANCED",
    isRequired: false,
    options: [
      {
        icon: <HandHeart />,
        text: "עזרה לזולת",
        value: "helping",
        description: "מאמין בעזרה הדדית וצדקה",
      },
      {
        icon: <Users />,
        text: "מעורבות קהילתית",
        value: "community",
        description: "פעיל בקהילה ובחברה",
      },
      {
        icon: <Globe />,
        text: "אחריות גלובלית",
        value: "global",
        description: "רואה אחריות כלפי העולם כולו",
      },
      {
        icon: <Construction />,
        text: "פיתוח חברתי",
        value: "development",
        description: "מאמין בפיתוח וקידום החברה",
      },
    ],
    minSelections: 1,
    maxSelections: 2,
  },
  {
    worldId: "VALUES",
    id: "shabbat_public",
    category: "values",
    subcategory: "depth",
    question: "איך צריך להיראות המרחב הציבורי בשבת?",
    type: "iconChoice",
    depth: "ADVANCED",
    isRequired: true,
    options: [
      {
        icon: <ScrollText />,
        text: "שמירה מסורתית",
        value: "traditional",
        description: "תומך בשמירת צביון השבת המסורתי",
      },
      {
        icon: <Scale />,
        text: "איזון מקומי",
        value: "local_balance",
        description: "תומך בהסדרה לפי אופי האזור",
      },
      {
        icon: <Star />,
        text: "חופש בחירה",
        value: "freedom",
        description: "תומך בחופש בחירה מלא",
      },
      {
        icon: <Map />,
        text: "הפרדה אזורית",
        value: "separation",
        description: "תומך בהפרדה בין אזורים שונים",
      },
    ],
  },
  {
    worldId: "VALUES",
    id: "technology_integration",
    category: "values",
    subcategory: "basics",
    question: "מהי גישתך לשילוב טכנולוגיה בחיים?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: false,
    options: [
      {
        icon: <Laptop />,
        text: "אימוץ מלא",
        value: "full_adoption",
        description: "מאמץ חידושים טכנולוגיים",
      },
      {
        icon: <Scale />,
        text: "שילוב מבוקר",
        value: "controlled",
        description: "משלב טכנולוגיה באופן מאוזן",
      },
      {
        icon: <Brain />,
        text: "גישה ביקורתית",
        value: "critical",
        description: "בוחן כל חידוש בקפידה",
      },
      {
        icon: <Target />,
        text: "שימוש מינימלי",
        value: "minimal",
        description: "מעדיף להגביל שימוש בטכנולוגיה",
      },
    ],
  },
];

export default valuesQuestionsPartTwo;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\types\types.ts:
==================================================
// Basic type definitions
export type WorldId = 
  | 'VALUES'        
  | 'RELATIONSHIP'  
  | 'PERSONALITY'   
  | 'PARTNER'
  | 'RELIGION';       

export type QuestionType = 
  | 'singleChoice'
  | 'multiChoice' 
  | 'multiSelect'
  | 'openText'
  | 'scale'
  | 'iconChoice'
  | 'budgetAllocation'
  | 'ranking'
  | 'scenario'
  | 'multiSelectWithOther'
  ;

export type QuestionDepth = 'BASIC' | 'ADVANCED' | 'EXPERT';

export type AnswerValue = 
  | string 
  | number 
  | string[] 
  | number[]
  | Record<string, number>
  | undefined;

export type AnswerStatus = 'COMPLETE' | 'PARTIAL' | 'SKIPPED';

// Interface definitions
export interface Option {
  value: string;
  text: string;
  icon?: React.ReactNode;
  description?: string;
  allowFreeText?: boolean;
  placeholder?:string;
}

export interface BudgetCategory {
  label: string;
  min: number;
  max: number;
  icon?: React.ReactNode;
  description?: string;
}

export interface QuestionMetadata {
  helpText?: string;
  estimatedTime?: number;
  tags?: string[];
}

export interface Question {
  worldId: string;
  id: string;
  category: string;
  subcategory?: string;
  question: string;
  type: QuestionType;
  depth: QuestionDepth;
  isRequired?: boolean;
  options?: Option[];
  placeholder?: string;
  minLength?: number;
  maxLength?: number;
  minSelections?: number;
  maxSelections?: number;
  description?: string;
  min?: number;
  max?: number;
  step?: number;
  categories?: BudgetCategory[];
  totalPoints?: number;
  metadata?: QuestionMetadata;
  items?: Option[]; // for ranking questions
}

// Answer-related interfaces
export interface QuestionnaireAnswer {
  questionId: string;
  worldId: WorldId;
  value: AnswerValue;
  answeredAt: string;
}

export interface Answer extends QuestionnaireAnswer {
  status?: AnswerStatus;
}

// Component Props interfaces
export interface WorldComponentProps {
  onAnswer: (questionId: string, value: AnswerValue) => void;
  onComplete: () => void;
  onBack: () => void;
  answers: QuestionnaireAnswer[];
  isCompleted?: boolean;
  language?: string;
}

export interface AnswerInputProps {
  question: Question;
  value?: AnswerValue;
  onChange?: (value: AnswerValue) => void;
  onClear?: () => void;  // Added this line
  language?: string;
  showValidation?: boolean;
  className?: string;
}

export interface QuestionnaireLayoutProps {
  children: React.ReactNode;
  currentWorld: WorldId;
  userTrack: UserTrack;  // הוספנו את זה
  completedWorlds: WorldId[];
  onWorldChange: (worldId: WorldId) => void;
  onExit?: () => void;
  language?: string;
  onSaveProgress?: () => Promise<void>;  // הוספת הפרופ החדש

}
export interface MatchmakingQuestionnaireProps {
  userId?: string;
  onComplete?: () => void;
  
}

// Data storage interfaces
export interface QuestionnaireSubmission {
  userId: string;
  answers: QuestionnaireAnswer[];
  worldsCompleted: WorldId[];
  completed: boolean;
  startedAt: string;
  completedAt?: string;
}

export type UserTrack = 
  | 'SECULAR'     // חילוני
  | 'TRADITIONAL' // מסורתי
  | 'RELIGIOUS'   // דתי
  | 'ORTHODOX';   // חרדי

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\worlds\PartnerWorld.tsx:
==================================================
import React, { useState } from "react";
import WorldIntro from "../common/WorldIntro";
import QuestionCard from "../common/QuestionCard";
import AnswerInput from "../common/AnswerInput";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { ArrowLeft, ArrowRight } from "lucide-react";
import type { WorldComponentProps } from "../types/types";
import type { Question } from "../types/types";
import { partnerBasicQuestions } from "../questions/partner/partnerBasicQuestions";
import { partnerDepthQuestions } from "../questions/partner/partnerDepthQuestions";
import { cn } from "@/lib/utils";

const allQuestions = [...partnerBasicQuestions, ...partnerDepthQuestions];

export default function PartnerWorld({
  onAnswer,
  onComplete,
  onBack,
  answers,
  isCompleted = false,
  language = "he",
}: WorldComponentProps) {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [isIntroComplete, setIsIntroComplete] = useState(false);
  const [validationErrors, setValidationErrors] = useState<
    Record<string, string>
  >({});

  const findAnswer = (questionId: string) => {
    return answers.find((a) => a.questionId === questionId)?.value;
  };

  const validateAnswer = (question: Question, value: any): string | null => {
    if (question.isRequired && !value) {
      return "נדרשת תשובה לשאלה זו";
    }
    return null;
  };

  const handleNext = () => {
    const currentQuestion = allQuestions[currentQuestionIndex];
    const value = findAnswer(currentQuestion.id);
    const error = validateAnswer(currentQuestion, value);

    if (error && currentQuestion.isRequired) {
      setValidationErrors({ ...validationErrors, [currentQuestion.id]: error });
      return;
    }

    if (currentQuestionIndex < allQuestions.length - 1) {
      setCurrentQuestionIndex((prev) => prev + 1);
    } else if (!isCompleted) {
      onComplete();
    }
  };

  if (!isIntroComplete) {
    return (
      <WorldIntro
        worldId="PARTNER"
        title="עולם הפרטנר"
        description="בואו נברר מה חשוב לך בבן/בת הזוג"
        estimatedTime={25}
        totalQuestions={allQuestions.length}
        requiredQuestions={allQuestions.filter((q) => q.isRequired).length}
        depths={["BASIC", "ADVANCED", "EXPERT"]}
        onStart={() => setIsIntroComplete(true)}
      />
    );
  }

  const currentQuestion = allQuestions[currentQuestionIndex];
  const progress = ((currentQuestionIndex + 1) / allQuestions.length) * 100;
  const currentValue = findAnswer(currentQuestion.id);

  return (
    <div className="max-w-2xl mx-auto p-4 space-y-6">
      <div className="space-y-4">
        {/* Question Navigation Bar */}
        <div className="flex items-center justify-between gap-2">
          <div className="flex-1 flex items-center gap-2 overflow-x-auto py-2">
            {allQuestions.map((_, index) => {
              const isAnswered = !!findAnswer(allQuestions[index].id);
              const isCurrent = index === currentQuestionIndex;

              return (
                <button
                  key={index}
                  onClick={() => setCurrentQuestionIndex(index)}
                  className={cn(
                    "w-8 h-8 rounded-full flex items-center justify-center text-sm transition-colors",
                    "hover:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-blue-500",
                    isCurrent && "ring-2 ring-blue-500",
                    isAnswered
                      ? "bg-blue-500 text-white"
                      : "bg-gray-100 text-gray-600"
                  )}
                >
                  {index + 1}
                </button>
              );
            })}
          </div>
          <span className="text-sm text-gray-500 whitespace-nowrap">
            {Math.round(progress)}%
          </span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      <QuestionCard
        question={currentQuestion}
        depth={currentQuestion.depth}
        isRequired={currentQuestion.isRequired}
        validationError={validationErrors[currentQuestion.id]}
        language={language}
      >
        <AnswerInput
          question={currentQuestion}
          value={currentValue}
          onChange={(value) => {
            setValidationErrors({
              ...validationErrors,
              [currentQuestion.id]: "",
            });
            onAnswer(currentQuestion.id, value);
          }}
          language={language}
        />
      </QuestionCard>

      <div className="flex justify-between pt-4">
        <Button
          variant="outline"
          onClick={() => {
            if (currentQuestionIndex > 0) {
              setCurrentQuestionIndex((prev) => prev - 1);
            } else {
              onBack();
            }
          }}
        >
          <ArrowRight className="w-4 h-4 ml-2" />
          {currentQuestionIndex === 0 ? "חזור למפה" : "שאלה קודמת"}
        </Button>

        {currentQuestionIndex < allQuestions.length - 1 ? (
          <Button onClick={handleNext}>
            שאלה הבאה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        ) : (
          !isCompleted && (
            <Button
              onClick={handleNext}
              disabled={allQuestions.some(
                (q) => q.isRequired && !findAnswer(q.id)
              )}
            >
              סיים עולם זה
              <ArrowLeft className="w-4 h-4 mr-2" />
            </Button>
          )
        )}
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\worlds\PersonalityWorld.tsx:
==================================================
import React, { useState } from "react";
import WorldIntro from "../common/WorldIntro";
import QuestionCard from "../common/QuestionCard";
import AnswerInput from "../common/AnswerInput";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { ArrowLeft, ArrowRight } from "lucide-react";
import { cn } from "@/lib/utils";
import type { WorldComponentProps, AnswerValue } from "../types/types";
import { personalityQuestionsPartOne } from "../questions/personality/personalityQuestionsPartOne";
import { personalityQuestionsPartTwo } from "../questions/personality/personalityQuestionsPartTwo";

// Combine all questions for the personality world
const allQuestions = [
  ...personalityQuestionsPartOne,
  ...personalityQuestionsPartTwo,
];

export default function PersonalityWorld({
  onAnswer,
  onComplete,
  onBack,
  answers,
  isCompleted = false,
  language = "he",
}: WorldComponentProps) {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [isIntroComplete, setIsIntroComplete] = useState(false);
  const [validationErrors, setValidationErrors] = useState<
    Record<string, string>
  >({});

  const findAnswer = (questionId: string) => {
    return answers.find((a) => a.questionId === questionId)?.value;
  };

  const validateAnswer = (question: any, value: any): string | null => {
    if (question.isRequired && !value) {
      return "נדרשת תשובה לשאלה זו";
    }

    switch (question.type) {
      case "openText": {
        const textValue = value as string;
        if (!textValue && !question.isRequired) return null;

        const trimmedLength = textValue?.trim().length || 0;
        if (
          question.minLength &&
          trimmedLength < question.minLength &&
          question.isRequired
        ) {
          return `התשובה חייבת להכיל לפחות ${question.minLength} תווים`;
        }
        if (question.maxLength && trimmedLength > question.maxLength) {
          return `התשובה לא יכולה להכיל יותר מ-${question.maxLength} תווים`;
        }
        break;
      }

      case "multiSelect":
      case "multiChoice": {
        const selectedValues = value as string[];
        if (!selectedValues?.length && !question.isRequired) return null;

        if (
          question.minSelections &&
          selectedValues.length < question.minSelections
        ) {
          return `יש לבחור לפחות ${question.minSelections} אפשרויות`;
        }
        if (
          question.maxSelections &&
          selectedValues.length > question.maxSelections
        ) {
          return `ניתן לבחור עד ${question.maxSelections} אפשרויות`;
        }
        break;
      }
    }

    return null;
  };

  const handleNext = () => {
    const currentQuestion = allQuestions[currentQuestionIndex];
    const value = findAnswer(currentQuestion.id);
    const error = validateAnswer(currentQuestion, value);

    if (error && currentQuestion.isRequired) {
      setValidationErrors({ ...validationErrors, [currentQuestion.id]: error });
      return;
    }

    if (currentQuestionIndex < allQuestions.length - 1) {
      setCurrentQuestionIndex((prev) => prev + 1);
    } else {
      onComplete();
    }
  };

  if (!isIntroComplete) {
    return (
      <WorldIntro
        worldId="PERSONALITY"
        title="עולם האישיות"
        description="בואו נגלה יחד את התכונות והמאפיינים הייחודיים שלך"
        estimatedTime={30}
        totalQuestions={allQuestions.length}
        requiredQuestions={allQuestions.filter((q) => q.isRequired).length}
        depths={["BASIC", "ADVANCED", "EXPERT"]}
        onStart={() => setIsIntroComplete(true)}
      />
    );
  }

  const currentQuestion = allQuestions[currentQuestionIndex];
  const progress = ((currentQuestionIndex + 1) / allQuestions.length) * 100;
  const currentValue = findAnswer(currentQuestion.id);

  const handleClearAnswer = () => {
    // Get appropriate empty value based on question type
    let emptyValue: AnswerValue;
    switch (currentQuestion.type) {
      case "multiChoice":
      case "multiSelect":
        emptyValue = [];
        break;
      case "budgetAllocation":
        emptyValue = {};
        break;
      case "scale":
        emptyValue = 0;
        break;
      default:
        emptyValue = "";
    }

    onAnswer(currentQuestion.id, emptyValue);
    setValidationErrors({
      ...validationErrors,
      [currentQuestion.id]: "",
    });
  };

  console.log({
    isCompleted,
    currentQuestionIndex,
    totalQuestions: allQuestions.length,
    isLastQuestion: currentQuestionIndex === allQuestions.length - 1,
  });

  return (
    <div className="max-w-2xl mx-auto p-4 space-y-6">
      <div className="space-y-4">
        {/* Question Navigation Bar */}
        <div className="flex items-center justify-between gap-2">
          <div className="flex-1 flex items-center gap-2 overflow-x-auto py-2">
            {allQuestions.map((_, index) => {
              const answer = findAnswer(allQuestions[index].id);
              const isAnswered =
                answer !== undefined &&
                answer !== null &&
                answer !== "" &&
                (Array.isArray(answer) ? answer.length > 0 : true) &&
                (typeof answer === "object" && !Array.isArray(answer)
                  ? Object.keys(answer).length > 0
                  : true);
              const isCurrent = index === currentQuestionIndex;
              const isRequired = allQuestions[index].isRequired;

              return (
                <div key={allQuestions[index].id} className="relative">
                  <button
                    onClick={() => setCurrentQuestionIndex(index)}
                    className={cn(
                      "w-8 h-8 rounded-full flex items-center justify-center text-sm transition-colors relative",
                      "hover:bg-blue-100 focus:outline-none",
                      isCurrent && "ring-2 ring-blue-500",
                      isAnswered
                        ? "bg-blue-500 text-white"
                        : "bg-gray-100 text-gray-600",
                      isRequired &&
                        !isAnswered &&
                        !isCurrent &&
                        "ring-2 ring-red-500"
                    )}
                    title={`שאלה ${index + 1}${isRequired ? " (חובה)" : ""}`}
                  >
                    {index + 1}
                    {isRequired && (
                      <span className="absolute -top-1 -right-1 w-2 h-2 rounded-full bg-red-500" />
                    )}
                  </button>
                </div>
              );
            })}
          </div>
          <span className="text-sm text-gray-500 whitespace-nowrap">
            {Math.round(progress)}%
          </span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      <QuestionCard
        question={currentQuestion}
        depth={currentQuestion.depth}
        isRequired={currentQuestion.isRequired}
        validationError={validationErrors[currentQuestion.id]}
        language={language}
      >
        <AnswerInput
          question={currentQuestion}
          value={currentValue}
          onChange={(value) => {
            setValidationErrors({
              ...validationErrors,
              [currentQuestion.id]: "",
            });
            onAnswer(currentQuestion.id, value);
          }}
          onClear={() => !currentQuestion.isRequired && handleClearAnswer()}
          language={language}
          showValidation={true}
        />
      </QuestionCard>

      <div className="flex justify-between pt-4">
        <Button
          variant="outline"
          onClick={() => {
            if (currentQuestionIndex > 0) {
              setCurrentQuestionIndex((prev) => prev - 1);
            } else {
              onBack();
            }
          }}
        >
          <ArrowRight className="w-4 h-4 ml-2" />
          {currentQuestionIndex === 0 ? "חזור למפה" : "שאלה קודמת"}
        </Button>

        {currentQuestionIndex < allQuestions.length - 1 ? (
          <Button onClick={handleNext}>
            שאלה הבאה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        ) : (
          <Button
            onClick={handleNext}
            disabled={allQuestions.some(
              (q) => q.isRequired && !findAnswer(q.id)
            )}
          >
            סיים עולם זה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        )}
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\worlds\RelationshipWorld.tsx:
==================================================
import React, { useState } from "react";
import WorldIntro from "../common/WorldIntro";
import QuestionCard from "../common/QuestionCard";
import AnswerInput from "../common/AnswerInput";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { ArrowLeft, ArrowRight } from "lucide-react";
import { cn } from "@/lib/utils";
import type { WorldComponentProps, AnswerValue } from "../types/types";
import { relationshipBasicsQuestions } from "../questions/relationship/relationshipBasicsQuestions";
import { relationshipDepthQuestions } from "../questions/relationship/relationshipDepthQuestions";

// Combine all questions for the relationship world
const allQuestions = [
  ...relationshipBasicsQuestions,
  ...relationshipDepthQuestions,
];

export default function RelationshipWorld({
  onAnswer,
  onComplete,
  onBack,
  answers,
  isCompleted = false,
  language = "he",
}: WorldComponentProps) {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [isIntroComplete, setIsIntroComplete] = useState(false);
  const [validationErrors, setValidationErrors] = useState<
    Record<string, string>
  >({});

  const findAnswer = (questionId: string) => {
    return answers.find((a) => a.questionId === questionId)?.value;
  };

  const validateAnswer = (question: any, value: any): string | null => {
    if (question.isRequired && !value) {
      return "נדרשת תשובה לשאלה זו";
    }

    switch (question.type) {
      case "openText": {
        const textValue = value as string;
        if (!textValue && !question.isRequired) return null;

        const trimmedLength = textValue?.trim().length || 0;
        if (
          question.minLength &&
          trimmedLength < question.minLength &&
          question.isRequired
        ) {
          return `התשובה חייבת להכיל לפחות ${question.minLength} תווים`;
        }
        if (question.maxLength && trimmedLength > question.maxLength) {
          return `התשובה לא יכולה להכיל יותר מ-${question.maxLength} תווים`;
        }
        break;
      }

      case "multiSelect":
      case "multiChoice": {
        const selectedValues = value as string[];
        if (!selectedValues?.length && !question.isRequired) return null;

        if (
          question.minSelections &&
          selectedValues.length < question.minSelections
        ) {
          return `יש לבחור לפחות ${question.minSelections} אפשרויות`;
        }
        if (
          question.maxSelections &&
          selectedValues.length > question.maxSelections
        ) {
          return `ניתן לבחור עד ${question.maxSelections} אפשרויות`;
        }
        break;
      }
    }

    return null;
  };

  const handleNext = () => {
    const currentQuestion = allQuestions[currentQuestionIndex];
    const value = findAnswer(currentQuestion.id);
    const error = validateAnswer(currentQuestion, value);

    if (error && currentQuestion.isRequired) {
      setValidationErrors({ ...validationErrors, [currentQuestion.id]: error });
      return;
    }

    if (currentQuestionIndex < allQuestions.length - 1) {
      setCurrentQuestionIndex((prev) => prev + 1);
    } else if (!isCompleted) {
      onComplete();
    }
  };

  if (!isIntroComplete) {
    return (
      <WorldIntro
        worldId="RELATIONSHIP"
        title="עולם הזוגיות והמשפחה"
        description="בואו נברר מה חשוב לך בקשר זוגי ומהן הציפיות שלך ממערכת יחסים ומשפחה"
        estimatedTime={25}
        totalQuestions={allQuestions.length}
        requiredQuestions={allQuestions.filter((q) => q.isRequired).length}
        depths={["BASIC", "ADVANCED", "EXPERT"]}
        onStart={() => setIsIntroComplete(true)}
      />
    );
  }

  const currentQuestion = allQuestions[currentQuestionIndex];
  const progress = ((currentQuestionIndex + 1) / allQuestions.length) * 100;
  const currentValue = findAnswer(currentQuestion.id);

  const handleClearAnswer = () => {
    // Get appropriate empty value based on question type
    let emptyValue: AnswerValue;
    switch (currentQuestion.type) {
      case "multiChoice":
      case "multiSelect":
        emptyValue = [];
        break;
      case "budgetAllocation":
        emptyValue = {};
        break;
      case "scale":
        emptyValue = 0;
        break;
      default:
        emptyValue = "";
    }

    onAnswer(currentQuestion.id, emptyValue);
    setValidationErrors({
      ...validationErrors,
      [currentQuestion.id]: "",
    });
  };

  return (
    <div className="max-w-2xl mx-auto p-4 space-y-6">
      <div className="space-y-4">
        {/* Question Navigation Bar */}
        <div className="flex items-center justify-between gap-2">
          <div className="flex-1 flex items-center gap-2 overflow-x-auto py-2">
            {allQuestions.map((_, index) => {
              const answer = findAnswer(allQuestions[index].id);
              const isAnswered =
                answer !== undefined &&
                answer !== null &&
                answer !== "" &&
                (Array.isArray(answer) ? answer.length > 0 : true) &&
                (typeof answer === "object" && !Array.isArray(answer)
                  ? Object.keys(answer).length > 0
                  : true);
              const isCurrent = index === currentQuestionIndex;
              const isRequired = allQuestions[index].isRequired;

              return (
                <div key={index} className="relative">
                  <button
                    onClick={() => setCurrentQuestionIndex(index)}
                    className={cn(
                      "w-8 h-8 rounded-full flex items-center justify-center text-sm transition-colors relative",
                      "hover:bg-blue-100 focus:outline-none",
                      isCurrent && "ring-2 ring-blue-500",
                      isAnswered
                        ? "bg-blue-500 text-white"
                        : "bg-gray-100 text-gray-600",
                      isRequired &&
                        !isAnswered &&
                        !isCurrent &&
                        "ring-2 ring-red-500"
                    )}
                    title={`שאלה ${index + 1}${isRequired ? " (חובה)" : ""}`}
                  >
                    {index + 1}
                    {isRequired && (
                      <span className="absolute -top-1 -right-1 w-2 h-2 rounded-full bg-red-500" />
                    )}
                  </button>
                </div>
              );
            })}
          </div>
          <span className="text-sm text-gray-500 whitespace-nowrap">
            {Math.round(progress)}%
          </span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      <QuestionCard
        question={currentQuestion}
        depth={currentQuestion.depth}
        isRequired={currentQuestion.isRequired}
        validationError={validationErrors[currentQuestion.id]}
        language={language}
      >
        <AnswerInput
          question={currentQuestion}
          value={currentValue}
          onChange={(value) => {
            setValidationErrors({
              ...validationErrors,
              [currentQuestion.id]: "",
            });
            onAnswer(currentQuestion.id, value);
          }}
          onClear={() => !currentQuestion.isRequired && handleClearAnswer()}
          language={language}
          showValidation={true}
        />
      </QuestionCard>

      <div className="flex justify-between pt-4">
        <Button
          variant="outline"
          onClick={() => {
            if (currentQuestionIndex > 0) {
              setCurrentQuestionIndex((prev) => prev - 1);
            } else {
              onBack();
            }
          }}
        >
          <ArrowRight className="w-4 h-4 ml-2" />
          {currentQuestionIndex === 0 ? "חזור למפה" : "שאלה קודמת"}
        </Button>

        {currentQuestionIndex < allQuestions.length - 1 ? (
          <Button onClick={handleNext}>
            שאלה הבאה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        ) : (
          !isCompleted && (
            <Button
              onClick={handleNext}
              disabled={allQuestions.some(
                (q) => q.isRequired && !findAnswer(q.id)
              )}
            >
              סיים עולם זה
              <ArrowLeft className="w-4 h-4 mr-2" />
            </Button>
          )
        )}
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\worlds\ReligionWorld.tsx:
==================================================
import React, { useState } from "react";
import WorldIntro from "../common/WorldIntro";
import QuestionCard from "../common/QuestionCard";
import AnswerInput from "../common/AnswerInput";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { ArrowLeft, ArrowRight } from "lucide-react";
import { cn } from "@/lib/utils";
import type { WorldComponentProps, AnswerValue } from "../types/types";
import { practicalQuestions } from "../questions/religion/practicalReligionQuestions";
import { faithQuestions } from "../questions/religion/faithQuestions";

// Combine all questions for the religion world
const allQuestions = [...practicalQuestions, ...faithQuestions];

export default function ReligionWorld({
  onAnswer,
  onComplete,
  onBack,
  answers,
  isCompleted = false,
  language = "he",
}: WorldComponentProps) {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [isIntroComplete, setIsIntroComplete] = useState(false);
  const [validationErrors, setValidationErrors] = useState<
    Record<string, string>
  >({});

  const findAnswer = (questionId: string) => {
    return answers.find((a) => a.questionId === questionId)?.value;
  };

  const validateAnswer = (question: any, value: any): string | null => {
    if (question.isRequired && !value) {
      return "נדרשת תשובה לשאלה זו";
    }

    switch (question.type) {
      case "openText": {
        const textValue = value as string;
        if (!textValue && !question.isRequired) return null;

        const trimmedLength = textValue?.trim().length || 0;
        if (
          question.minLength &&
          trimmedLength < question.minLength &&
          question.isRequired
        ) {
          return `התשובה חייבת להכיל לפחות ${question.minLength} תווים`;
        }
        if (question.maxLength && trimmedLength > question.maxLength) {
          return `התשובה לא יכולה להכיל יותר מ-${question.maxLength} תווים`;
        }
        break;
      }

      case "multiSelect":
      case "multiChoice": {
        const selectedValues = value as string[];
        if (!selectedValues?.length && !question.isRequired) return null;

        if (
          question.minSelections &&
          selectedValues.length < question.minSelections
        ) {
          return `יש לבחור לפחות ${question.minSelections} אפשרויות`;
        }
        if (
          question.maxSelections &&
          selectedValues.length > question.maxSelections
        ) {
          return `ניתן לבחור עד ${question.maxSelections} אפשרויות`;
        }
        break;
      }
    }

    return null;
  };

  const handleNext = () => {
    const currentQuestion = allQuestions[currentQuestionIndex];
    const value = findAnswer(currentQuestion.id);
    const error = validateAnswer(currentQuestion, value);

    if (error && currentQuestion.isRequired) {
      setValidationErrors({ ...validationErrors, [currentQuestion.id]: error });
      return;
    }

    if (currentQuestionIndex < allQuestions.length - 1) {
      setCurrentQuestionIndex((prev) => prev + 1);
    } else {
      onComplete();
    }
  };

  if (!isIntroComplete) {
    return (
      <WorldIntro
        worldId="RELIGION"
        title="עולם הדת והמסורת"
        description="בואו נברר יחד את תפיסת עולמך הדתית והקשר שלך למסורת"
        estimatedTime={35}
        totalQuestions={allQuestions.length}
        requiredQuestions={allQuestions.filter((q) => q.isRequired).length}
        depths={["BASIC", "ADVANCED", "EXPERT"]}
        onStart={() => setIsIntroComplete(true)}
      />
    );
  }

  const currentQuestion = allQuestions[currentQuestionIndex];
  const progress = ((currentQuestionIndex + 1) / allQuestions.length) * 100;
  const currentValue = findAnswer(currentQuestion.id);

  const handleClearAnswer = () => {
    let emptyValue: AnswerValue;
    switch (currentQuestion.type) {
      case "multiChoice":
      case "multiSelect":
        emptyValue = [];
        break;
      case "budgetAllocation":
        emptyValue = {};
        break;
      case "scale":
        emptyValue = 0;
        break;
      default:
        emptyValue = "";
    }

    onAnswer(currentQuestion.id, emptyValue);
    setValidationErrors({
      ...validationErrors,
      [currentQuestion.id]: "",
    });
  };

  console.log({
    isCompleted,
    currentQuestionIndex,
    totalQuestions: allQuestions.length,
    isLastQuestion: currentQuestionIndex === allQuestions.length - 1,
  });

  return (
    <div className="max-w-2xl mx-auto p-4 space-y-6">
      <div className="space-y-4">
        {/* Question Navigation Bar */}
        <div className="flex items-center justify-between gap-2">
          <div className="flex-1 flex items-center gap-2 overflow-x-auto py-2">
            {allQuestions.map((_, index) => {
              const answer = findAnswer(allQuestions[index].id);
              const isAnswered =
                answer !== undefined &&
                answer !== null &&
                answer !== "" &&
                (Array.isArray(answer) ? answer.length > 0 : true) &&
                (typeof answer === "object" && !Array.isArray(answer)
                  ? Object.keys(answer).length > 0
                  : true);
              const isCurrent = index === currentQuestionIndex;
              const isRequired = allQuestions[index].isRequired;

              return (
                <div key={allQuestions[index].id} className="relative">
                  <button
                    onClick={() => setCurrentQuestionIndex(index)}
                    className={cn(
                      "w-8 h-8 rounded-full flex items-center justify-center text-sm transition-colors relative",
                      "hover:bg-blue-100 focus:outline-none",
                      isCurrent && "ring-2 ring-blue-500",
                      isAnswered
                        ? "bg-blue-500 text-white"
                        : "bg-gray-100 text-gray-600",
                      isRequired &&
                        !isAnswered &&
                        !isCurrent &&
                        "ring-2 ring-red-500"
                    )}
                    title={`שאלה ${index + 1}${isRequired ? " (חובה)" : ""}`}
                  >
                    {index + 1}
                    {isRequired && (
                      <span className="absolute -top-1 -right-1 w-2 h-2 rounded-full bg-red-500" />
                    )}
                  </button>
                </div>
              );
            })}
          </div>
          <span className="text-sm text-gray-500 whitespace-nowrap">
            {Math.round(progress)}%
          </span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      <QuestionCard
        question={currentQuestion}
        depth={currentQuestion.depth}
        isRequired={currentQuestion.isRequired}
        validationError={validationErrors[currentQuestion.id]}
        language={language}
      >
        <AnswerInput
          question={currentQuestion}
          value={currentValue}
          onChange={(value) => {
            setValidationErrors({
              ...validationErrors,
              [currentQuestion.id]: "",
            });
            onAnswer(currentQuestion.id, value);
          }}
          onClear={() => !currentQuestion.isRequired && handleClearAnswer()}
          language={language}
          showValidation={true}
        />
      </QuestionCard>

      <div className="flex justify-between pt-4">
        <Button
          variant="outline"
          onClick={() => {
            if (currentQuestionIndex > 0) {
              setCurrentQuestionIndex((prev) => prev - 1);
            } else {
              onBack();
            }
          }}
        >
          <ArrowRight className="w-4 h-4 ml-2" />
          {currentQuestionIndex === 0 ? "חזור למפה" : "שאלה קודמת"}
        </Button>

        {currentQuestionIndex < allQuestions.length - 1 ? (
          <Button onClick={handleNext}>
            שאלה הבאה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        ) : (
          <Button
            onClick={handleNext}
            disabled={allQuestions.some(
              (q) => q.isRequired && !findAnswer(q.id)
            )}
          >
            סיים עולם זה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        )}
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\worlds\ValuesWorld.tsx:
==================================================
import React, { useState } from "react";
import WorldIntro from "../common/WorldIntro";
import QuestionCard from "../common/QuestionCard";
import AnswerInput from "../common/AnswerInput";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { ArrowLeft, ArrowRight } from "lucide-react";
import type { WorldComponentProps, AnswerValue } from "../types/types";
import { valuesQuestionsPartOne } from "../questions/values/valuesQuestionsPartOne";
import { valuesQuestionsPartTwo } from "../questions/values/valuesQuestionsPartTwo";
import { cn } from "@/lib/utils";

// Combine all questions for the values world
const allQuestions = [...valuesQuestionsPartOne, ...valuesQuestionsPartTwo];

export default function ValuesWorld({
  onAnswer,
  onComplete,
  onBack,
  answers,
  isCompleted = false,
  language = "he",
}: WorldComponentProps) {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [isIntroComplete, setIsIntroComplete] = useState(false);
  const [validationErrors, setValidationErrors] = useState<
    Record<string, string>
  >({});

  const findAnswer = (questionId: string) => {
    return answers.find((a) => a.questionId === questionId)?.value;
  };

  const validateAnswer = (question: any, value: any): string | null => {
    if (question.isRequired && !value) {
      return "נדרשת תשובה לשאלה זו";
    }

    switch (question.type) {
      case "openText": {
        const textValue = value as string;
        if (!textValue && !question.isRequired) return null;

        const trimmedLength = textValue?.trim().length || 0;
        if (
          question.minLength &&
          trimmedLength < question.minLength &&
          question.isRequired
        ) {
          return `התשובה חייבת להכיל לפחות ${question.minLength} תווים`;
        }
        if (question.maxLength && trimmedLength > question.maxLength) {
          return `התשובה לא יכולה להכיל יותר מ-${question.maxLength} תווים`;
        }
        break;
      }

      case "multiSelect":
      case "multiChoice": {
        const selectedValues = value as string[];
        if (!selectedValues?.length && !question.isRequired) return null;

        if (
          question.minSelections &&
          selectedValues.length < question.minSelections
        ) {
          return `יש לבחור לפחות ${question.minSelections} אפשרויות`;
        }
        if (
          question.maxSelections &&
          selectedValues.length > question.maxSelections
        ) {
          return `ניתן לבחור עד ${question.maxSelections} אפשרויות`;
        }
        break;
      }
    }

    return null;
  };

  const handleNext = () => {
    const currentQuestion = allQuestions[currentQuestionIndex];
    const value = findAnswer(currentQuestion.id);
    const error = validateAnswer(currentQuestion, value);

    if (error && currentQuestion.isRequired) {
      setValidationErrors({ ...validationErrors, [currentQuestion.id]: error });
      return;
    }

    if (currentQuestionIndex < allQuestions.length - 1) {
      setCurrentQuestionIndex((prev) => prev + 1);
    } else {
      onComplete();
    }
  };

  if (!isIntroComplete) {
    return (
      <WorldIntro
        worldId="VALUES"
        title="עולם הערכים והאמונות"
        description="בואו נברר יחד מהם הערכים והעקרונות המנחים בחייך"
        estimatedTime={40}
        totalQuestions={allQuestions.length}
        requiredQuestions={allQuestions.filter((q) => q.isRequired).length}
        depths={["BASIC", "ADVANCED", "EXPERT"]}
        onStart={() => setIsIntroComplete(true)}
      />
    );
  }

  const currentQuestion = allQuestions[currentQuestionIndex];
  const progress = ((currentQuestionIndex + 1) / allQuestions.length) * 100;
  const currentValue = findAnswer(currentQuestion.id);

  const handleClearAnswer = () => {
    let emptyValue: AnswerValue;
    switch (currentQuestion.type) {
      case "multiChoice":
      case "multiSelect":
        emptyValue = [];
        break;
      case "budgetAllocation":
        emptyValue = {};
        break;
      case "scale":
        emptyValue = 0;
        break;
      default:
        emptyValue = "";
    }

    onAnswer(currentQuestion.id, emptyValue);
    setValidationErrors({
      ...validationErrors,
      [currentQuestion.id]: "",
    });
  };

  console.log({
    isCompleted,
    currentQuestionIndex,
    totalQuestions: allQuestions.length,
    isLastQuestion: currentQuestionIndex === allQuestions.length - 1,
  });

  return (
    <div className="max-w-2xl mx-auto p-4 space-y-6">
      <div className="space-y-4">
        {/* Question Navigation Bar */}
        <div className="flex items-center justify-between gap-2">
          <div className="flex-1 flex items-center gap-2 overflow-x-auto py-2">
            {allQuestions.map((_, index) => {
              const answer = findAnswer(allQuestions[index].id);
              const isAnswered =
                answer !== undefined &&
                answer !== null &&
                answer !== "" &&
                (Array.isArray(answer) ? answer.length > 0 : true) &&
                (typeof answer === "object" && !Array.isArray(answer)
                  ? Object.keys(answer).length > 0
                  : true);
              const isCurrent = index === currentQuestionIndex;
              const isRequired = allQuestions[index].isRequired;

              return (
                <div key={allQuestions[index].id} className="relative">
                  <button
                    onClick={() => setCurrentQuestionIndex(index)}
                    className={cn(
                      "w-8 h-8 rounded-full flex items-center justify-center text-sm transition-colors relative",
                      "hover:bg-blue-100 focus:outline-none",
                      isCurrent && "ring-2 ring-blue-500",
                      isAnswered
                        ? "bg-blue-500 text-white"
                        : "bg-gray-100 text-gray-600",
                      isRequired &&
                        !isAnswered &&
                        !isCurrent &&
                        "ring-2 ring-red-500"
                    )}
                    title={`שאלה ${index + 1}${isRequired ? " (חובה)" : ""}`}
                  >
                    {index + 1}
                    {isRequired && (
                      <span className="absolute -top-1 -right-1 w-2 h-2 rounded-full bg-red-500" />
                    )}
                  </button>
                </div>
              );
            })}
          </div>
          <span className="text-sm text-gray-500 whitespace-nowrap">
            {Math.round(progress)}%
          </span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      <QuestionCard
        question={currentQuestion}
        depth={currentQuestion.depth}
        isRequired={currentQuestion.isRequired}
        validationError={validationErrors[currentQuestion.id]}
        language={language}
      >
        <AnswerInput
          question={currentQuestion}
          value={currentValue}
          onChange={(value) => {
            setValidationErrors({
              ...validationErrors,
              [currentQuestion.id]: "",
            });
            onAnswer(currentQuestion.id, value);
          }}
          onClear={() => !currentQuestion.isRequired && handleClearAnswer()}
          language={language}
          showValidation={true}
        />
      </QuestionCard>

      <div className="flex justify-between pt-4">
        <Button
          variant="outline"
          onClick={() => {
            if (currentQuestionIndex > 0) {
              setCurrentQuestionIndex((prev) => prev - 1);
            } else {
              onBack();
            }
          }}
        >
          <ArrowRight className="w-4 h-4 ml-2" />
          {currentQuestionIndex === 0 ? "חזור למפה" : "שאלה קודמת"}
        </Button>

        {currentQuestionIndex < allQuestions.length - 1 ? (
          <Button onClick={handleNext}>
            שאלה הבאה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        ) : (
          <Button
            onClick={handleNext}
            disabled={allQuestions.some(
              (q) => q.isRequired && !findAnswer(q.id)
            )}
          >
            סיים עולם זה
            <ArrowLeft className="w-4 h-4 mr-2" />
          </Button>
        )}
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\שאלות כלליות\educationCareer.tsx:
==================================================
"use client";
import React from "react";
import type { ReactNode } from "react";
import {
  Users,
  Heart,
  Coffee,
  HandHeart,
  Smile,
  Star,
  User,
  Phone,
  MessageCircle,
  Home,
  Globe,
  CalendarDays,
  Clock,
  Music,
  PartyPopper,
  Book,
  HeartHandshake,
  Laugh,
  Lightbulb,
  Bird,
  Sparkles,
  Crown,
  Sun,
  Moon,
  Cloud,
  Gift,
  Calendar,
} from "lucide-react";

const socialRelationsQuestions = [
  // שאלות פתיחה - Ice Breakers (20%)
  {
    id: "socialEnergy",
    category: "social",
    subcategory: "opening",
    question: "איך היית מתאר/ת את האנרגיה החברתית שלך?",
    type: "iconChoice",
    options: [
      { icon: <Sun />, text: "מאוד חברותי/ת", value: "veryOutgoing" },
      { icon: <Cloud />, text: "מאוזן/ת חברתית", value: "balanced" },
      { icon: <Moon />, text: "שקט/ה ומופנם/ת", value: "introvert" },
      { icon: <Star />, text: "משתנה לפי מצב", value: "variable" },
    ],
  },
  {
    id: "friendshipStyle",
    category: "social",
    subcategory: "opening",
    question: "איך את/ה מעדיף/ה לבלות עם חברים?",
    type: "scenario",
    options: [
      "מפגשים אינטימיים אחד על אחד",
      "בילויים קבוצתיים גדולים",
      "פעילויות משותפות ותחביבים",
      "שיחות עמוקות בקבוצה קטנה",
    ],
  },
];

export default socialRelationsQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\שאלות כלליות\familyBackground.tsx:
==================================================
"use client";
import React from "react";
import type { ReactNode } from "react";
import {
  Users,
  Home,
  Heart,
  Trees,
  Globe,
  Map,
  Book,
  Crown,
  Star,
  Scroll,
  Cake,
  Gift,
  Coffee,
  Utensils,
  Music,
  Camera,
  Bird,
  Sun,
  Moon,
  Calendar,
  Clock,
  Flower,
  HandHeart,
  Building,
  CircleDot,
  Sparkles,
  Laugh,
  Mountain,
  Phone,
} from "lucide-react";

const familyBackgroundQuestions = [
  // שאלות פתיחה - Ice Breakers (20%)
  {
    id: "familyTradition",
    category: "family",
    subcategory: "opening",
    question: "איזו מסורת משפחתית מיוחדת יש במשפחה שלך?",
    type: "iconChoice",
    options: [
      { icon: <Cake />, text: "חגיגות משפחתיות", value: "celebrations" },
      { icon: <Utensils />, text: "מתכונים מיוחדים", value: "recipes" },
      { icon: <Music />, text: "שירים ופיוטים", value: "songs" },
      { icon: <Scroll />, text: "סיפורי משפחה", value: "stories" },
    ],
  },
  {
    id: "familyGatherings",
    category: "family",
    subcategory: "opening",
    question: "איך נראים המפגשים המשפחתיים אצלכם?",
    type: "scenario",
    options: [
      "ארוחות שבת גדולות",
      "מפגשים ספונטניים תכופים",
      "אירועים בחגים בלבד",
      "טיולים משפחתיים משותפים",
    ],
  },
];

export default familyBackgroundQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\שאלות כלליות\lifestyleQuestions.tsx:
==================================================
"use client";
import React from "react";
import type { ReactNode } from "react";
import {
  Sun,
  Moon,
  Coffee,
  Utensils,
  Clock,
  Calendar,
  Heart,
  Users,
  Home,
  Briefcase,
  Book,
  User,
  Music,
  Plane,
  Bike,
  Dumbbell,
  Timer,
  Battery,
  Bed,
  Wallet,
  ShoppingBag,
  Tent,
  Tv,
  Smartphone,
  Pizza,
  Salad,
  Car,
  Train,
  Map,
  Globe,
  Sparkles,
} from "lucide-react";

const lifestyleQuestions = [
  // שאלות פתיחה - Ice Breakers (20%)
  {
    id: "morningRoutine",
    category: "lifestyle",
    subcategory: "opening",
    question: "איך נראה הבוקר האידיאלי שלך?",
    type: "iconChoice",
    options: [
      { icon: <Sun />, text: "קימה מוקדמת ופעילות", value: "active" },
      { icon: <Coffee />, text: "קפה ורוגע", value: "calm" },
      { icon: <Book />, text: "לימוד או קריאה", value: "study" },
      { icon: <Timer />, text: "מהיר ויעיל", value: "efficient" },
    ],
  },
  {
    id: "dailyEnergyPattern",
    category: "lifestyle",
    subcategory: "opening",
    question: "מתי את/ה במיטבך במהלך היום?",
    type: "multiSelect",
    options: [
      { icon: <Sun />, text: "בוקר מוקדם", value: "earlyMorning" },
      { icon: <Coffee />, text: "צהריים", value: "noon" },
      { icon: <Moon />, text: "ערב", value: "evening" },
      { icon: <Sparkles />, text: "לילה", value: "night" },
    ],
  },
  {
    id: "weekendStyle",
    category: "lifestyle",
    subcategory: "opening",
    question: "איך נראה סוף השבוע המושלם בעיניך?",
    type: "scenario",
    options: [
      "בילוי משפחתי מלא באירועים ופעילויות",
      "מנוחה מוחלטת בבית עם ספר טוב",
      "טיול בטבע וספורט",
      "בילוי חברתי ומפגשים",
    ],
  },

  // שאלות עומק - Core Lifestyle (50%)
  {
    id: "workLifeBalance",
    category: "lifestyle",
    subcategory: "core",
    question: "איך את/ה רואה את האיזון בין עבודה לחיים אישיים?",
    type: "budgetAllocation",
    totalPoints: 100,
    categories: [
      { label: "קריירה ועבודה", icon: <Briefcase /> },
      { label: "זמן משפחה", icon: <Heart /> },
      { label: "זמן אישי", icon: <User /> },
      { label: "תחביבים ופנאי", icon: <Music /> },
    ],
  },
];

export default lifestyleQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\שאלות כלליות\partnerPreferences.tsx:
==================================================
"use client";
import React from "react";
import type { ReactNode } from "react";
import {
  Heart,
  User,
  Users,
  Home,
  Book,
  Music,
  Coffee,
  Mountain,
  Target,
  Briefcase,
  Globe,
  Map,
  Brain,
  HeartHandshake,
  Smile,
  Star,
  Sun,
  Moon,
  Hand,
  Flower,
  Trees,
  Bird,
  Cloud,
  Compass,
  Crown,
  Gift,
  Gem,
  Key,
} from "lucide-react";

const partnerPreferences = [
  // שאלות פתיחה - Ice Breakers (20%)
  {
    id: "firstImpression",
    category: "partner",
    subcategory: "opening",
    question: "מה הדבר הראשון שמושך את תשומת לבך באדם חדש?",
    type: "iconChoice",
    options: [
      { icon: <Smile />, text: "חיוך וקלילות", value: "smile" },
      { icon: <Brain />, text: "אינטליגנציה", value: "intelligence" },
      { icon: <Heart />, text: "חום ונעימות", value: "warmth" },
      { icon: <Star />, text: "כריזמה", value: "charisma" },
    ],
  },
  {
    id: "idealDate",
    category: "partner",
    subcategory: "opening",
    question: "איך נראית הפגישה האידיאלית הראשונה בעיניך?",
    type: "scenario",
    options: [
      "שיחה מעמיקה בבית קפה שקט",
      "טיול בטבע או בפארק",
      "פעילות משותפת כמו סדנה או הרצאה",
      "ארוחת ערב במסעדה נעימה",
    ],
  },
  {
    id: "dealBreakers",
    category: "partner",
    subcategory: "opening",
    question: "מהם הדברים שהם 'קו אדום' מבחינתך בבן/בת זוג?",
    type: "multiSelect",
    options: [
      { icon: <Hand />, text: "חוסר כנות", value: "dishonesty" },
      { icon: <Cloud />, text: "עישון", value: "smoking" },
      { icon: <Target />, text: "חוסר שאיפות", value: "noAmbition" },
      { icon: <Heart />, text: "חוסר רגישות", value: "insensitivity" },
    ],
  },

  // שאלות עומק - Core Preferences (50%)
  {
    id: "lifeGoals",
    category: "partner",
    subcategory: "core",
    question: "איך היית רוצה שבן/בת הזוג יראה את החיים המשותפים?",
    type: "budgetAllocation",
    totalPoints: 100,
    categories: [
      { label: "קריירה והתפתחות", icon: <Briefcase /> },
      { label: "משפחה וילדים", icon: <Users /> },
      { label: "רוחניות ולימוד", icon: <Book /> },
      { label: "הנאות החיים", icon: <Sun /> },
    ],
  },
];

export default partnerPreferences;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\שאלות כלליות\personalityQuestions.tsx:
==================================================
import React from 'react';
import { 
  Brain, Smile, Target, Heart, User, 
  Star, HeartHandshake, Laugh 
} from 'lucide-react';
import type { Question } from "../types/types";

const personalityQuestions: Question[] = [
  {
    id: 'selfDescription',
    category: 'personality',
    subcategory: 'core',
    question: "איך היית מתאר/ת את עצמך במילה אחת?",
    type: 'singleChoice',
    depth: "BASIC",
    isRequired: true,
    options: [
      { 
        value: "deep", 
        text: "עמוק/ה ומעמיק/ה" 
      },
      { 
        value: "happy", 
        text: "שמח/ה ואופטימי/ת" 
      },
      { 
        value: "ambitious", 
        text: "ממוקד/ת ושאפתן/ית" 
      },
      { 
        value: "sensitive", 
        text: "רגיש/ה ואכפתי/ת" 
      }
    ]
  },
  {
    id: 'socialInteraction',
    category: 'personality',
    subcategory: 'social',
    question: "באירוע חברתי חדש, איך את/ה בדרך כלל מתנהג/ת?",
    type: 'singleChoice',
    depth: "BASIC",
    isRequired: true,
    options: [
      { value: "proactive", text: "מתערבב/ת מיד ויוצר/ת שיחות" },
      { value: "reactive", text: "מחכה שיפנו אליי" },
      { value: "selective", text: "מוצא/ת אדם אחד לדבר איתו" },
      { value: "observer", text: "נשאר/ת בשקט ומתבונן/ת" }
    ]
  },
  {
    id: 'emotionalResponse',
    category: 'personality',
    subcategory: 'emotional',
    question: "כשמשהו מרגש קורה, איך את/ה מגיב/ה?",
    type: 'multiChoice',
    depth: "ADVANCED",
    isRequired: false,
    options: [
      { value: "expressive", text: "מראה רגשות בחופשיות" },
      { value: "introspective", text: "מעבד/ת לעצמי בשקט" },
      { value: "sharing", text: "משתף/ת עם הקרובים" },
      { value: "composed", text: "שומר/ת על קור רוח" }
    ],
    minSelections: 1,
    maxSelections: 2
  },
  {
    id: 'stressManagement',
    category: 'personality',
    subcategory: 'coping',
    question: "איך את/ה מתמודד/ת עם מצבי לחץ?",
    type: 'singleChoice',
    depth: "ADVANCED",
    isRequired: true,
    options: [
      { value: "plan", text: "לוקח/ת צעד אחורה ומתכנן/ת" },
      { value: "act", text: "פועל/ת מיד לפתרון" },
      { value: "consult", text: "מתייעץ/ת עם אחרים" },
      { value: "calm", text: "מנסה להירגע ולהתמקד" }
    ],
    metadata: {
      helpText: "חשוב לענות בכנות על השאלה הזו כדי להבין את סגנון ההתמודדות שלך",
      estimatedTime: 2
    }
  },
  {
    id: 'personalityOpenQuestion',
    category: 'personality',
    subcategory: 'reflection',
    question: "ספר/י על אירוע שבו הרגשת שהאישיות שלך באה לידי ביטוי בצורה הטובה ביותר",
    type: 'openText',
    depth: "EXPERT",
    isRequired: false,
    minLength: 50,
    maxLength: 500,
    placeholder: "תאר/י את האירוע והסבר/י מה הוא מלמד על האישיות שלך..."
  }
];

export default personalityQuestions;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\שאלות כלליות\socialRelations.tsx:
==================================================
"use client";
import React from 'react';
import type { ReactNode } from 'react';
import {
  Users,
  Heart,
  Coffee,
  HandHeart,
  Smile,
  Star,
  User,
  Phone,
  MessageCircle,
  Home,
  Globe,
  CalendarDays,
  Clock,
  Music,
  PartyPopper,
  Book,
  HeartHandshake,
  Laugh,
  Lightbulb,
  Bird,
  Sparkles,
  Crown,
  Sun,
  Moon,
  Cloud,
  Gift,
  Calendar 
} from 'lucide-react';

const socialRelationsQuestions = [
  // שאלות פתיחה - Ice Breakers (20%)
  {
    id: 'socialEnergy',
    category: 'social',
    subcategory: 'opening',
    question: "איך היית מתאר/ת את האנרגיה החברתית שלך?",
    type: 'iconChoice',
    options: [
      { icon: <Sun />, text: "מאוד חברותי/ת", value: "veryOutgoing" },
      { icon: <Cloud />, text: "מאוזן/ת חברתית", value: "balanced" },
      { icon: <Moon />, text: "שקט/ה ומופנם/ת", value: "introvert" },
      { icon: <Star />, text: "משתנה לפי מצב", value: "variable" }
    ]
  },
  {
    id: 'friendshipStyle',
    category: 'social',
    subcategory: 'opening',
    question: "איך את/ה מעדיף/ה לבלות עם חברים?",
    type: 'scenario',
    options: [
      "מפגשים אינטימיים אחד על אחד",
      "בילויים קבוצתיים גדולים",
      "פעילויות משותפות ותחביבים",
      "שיחות עמוקות בקבוצה קטנה"
    ]
  },
  
];

export default socialRelationsQuestions;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\questionnaire\שאלות כלליות\valueQuestions.tsx:
==================================================
"use client";
import React from "react";
import type { ReactNode } from "react";
import {
  BookOpen,
  Scroll,
  Star,
  Heart,
  Book,
  Hand,
  HandHeart,
  Gem,
  Users,
  Home,
  Globe,
  Target,
  Brain,
  HeartHandshake,
  Flower,
  Mountain,
  Flame,
  User,
  Trees,
  Building2,
  Scale,
  Infinity,
} from "lucide-react";
import type { Question } from "../types/types";

const valueQuestions: Question[] = [
  {
    id: "spiritualMoment",
    category: "values",
    subcategory: "opening",
    question: "מהו הרגע הכי רוחני שחווית בחייך?",
    type: "openText",
    depth: "BASIC",
    isRequired: true,
    placeholder: "ספר/י על חוויה משמעותית...",
    minLength: 50,
    maxLength: 500,
  },
  {
    id: "favoriteHoliday",
    category: "values",
    subcategory: "opening",
    question: "איזה חג יהודי הכי משמעותי עבורך?",
    type: "iconChoice",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Flame size={24} />,
        text: "חנוכה",
        value: "hanukkah",
        description: "חג האור והניסים",
      },
      {
        icon: <Scroll size={24} />,
        text: "פסח",
        value: "pesach",
        description: "חג החירות",
      },
      {
        icon: <Star size={24} />,
        text: "ראש השנה",
        value: "roshHashana",
        description: "יום הדין והתחדשות",
      },
      {
        icon: <Mountain size={24} />,
        text: "שבועות",
        value: "shavuot",
        description: "זמן מתן תורתנו",
      },
    ],
  },
  {
    id: "spiritualActivity",
    category: "values",
    subcategory: "opening",
    question: "איזו פעילות רוחנית מדברת אליך?",
    type: "multiSelect",
    depth: "BASIC",
    isRequired: true,
    options: [
      {
        icon: <Hand size={24} />,
        text: "תפילה",
        value: "prayer",
        description: "חיבור אישי לבורא עולם",
      },
      {
        icon: <BookOpen size={24} />,
        text: "לימוד תורה",
        value: "torah",
        description: "העמקה בכתבי הקודש",
      },
      {
        icon: <Flower size={24} />,
        text: "מדיטציה",
        value: "meditation",
        description: "התבוננות פנימית ומודעות",
      },
      {
        icon: <HandHeart size={24} />,
        text: "התנדבות",
        value: "volunteering",
        description: "עזרה לזולת וחסד",
      },
    ],
    minSelections: 1,
    maxSelections: 3,
  },
  {
    id: "valuesPriorities",
    category: "values",
    subcategory: "priorities",
    question: "איך היית מחלק/ת את סדרי העדיפויות בחיים?",
    type: "budgetAllocation",
    depth: "ADVANCED",
    isRequired: true,
    totalPoints: 100,
    categories: [
      {
        label: "משפחה",
        icon: <Users />,
        min: 0,
        max: 100,
        description: "זמן ואנרגיה המוקדשים למשפחה",
      },
      {
        label: "רוחניות",
        icon: <Heart />,
        min: 0,
        max: 100,
        description: "התפתחות רוחנית ואמונה",
      },
      {
        label: "קריירה",
        icon: <Target />,
        min: 0,
        max: 100,
        description: "התפתחות מקצועית והגשמה",
      },
      {
        label: "חברה וקהילה",
        icon: <Globe />,
        min: 0,
        max: 100,
        description: "מעורבות חברתית וקהילתית",
      },
    ],
  },
  {
    id: "lifePhilosophy",
    category: "values",
    subcategory: "beliefs",
    question: "מהי תפיסת העולם שמנחה אותך בחיים?",
    type: "openText",
    depth: "EXPERT",
    isRequired: false,
    placeholder: "שתף/י את האמונות והערכים שמנחים אותך...",
    minLength: 100,
    maxLength: 1000,
    metadata: {
      helpText: "זו שאלה מעמיקה שמטרתה להבין את השקפת העולם הייחודית שלך",
      estimatedTime: 5,
    },
  },
];

export default valueQuestions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\accordion.tsx:
==================================================
import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";
import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = "AccordionTrigger";

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className={cn(
      "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
      className
    )}
    {...props}
  >
    <div className="pb-4 pt-0">{children}</div>
  </AccordionPrimitive.Content>
));
AccordionContent.displayName = "AccordionContent";

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\alert-dialog.tsx:
==================================================
// src/components/ui/alert-dialog.tsx
import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

const AlertDialog = AlertDialogPrimitive.Root;
const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;
const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, ...props }, ref) => (
  <button ref={ref} className={cn(buttonVariants(), className)} {...props} />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, ...props }, ref) => (
  <button
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\alert.tsx:
==================================================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\badge.tsx:
==================================================
// src/components/ui/badge.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        success:
          "border-transparent bg-green-500 text-white hover:bg-green-600",
        warning:
          "border-transparent bg-yellow-500 text-white hover:bg-yellow-600",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\button.tsx:
==================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\calendar.tsx:
==================================================
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"
import { he } from "date-fns/locale"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      dir="rtl"
      locale={he}
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute right-1",
        nav_button_next: "absolute left-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-r-md last:[&:has([aria-selected])]:rounded-l-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        PrevButton: () => <ChevronRight className="h-4 w-4" />,
        NextButton: () => <ChevronLeft className="h-4 w-4" />
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\card.tsx:
==================================================
import * as React from "react"
import { cn } from "@/lib/utils"

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {}

const CardFooter = React.forwardRef<HTMLDivElement, CardProps>((props, ref) => {
  const { className, ...rest } = props
  return (
    <div
      ref={ref}
      className={cn("flex items-center p-6 pt-0", className)}
      {...rest}
    />
  )
})

CardFooter.displayName = "CardFooter"

const Card = React.forwardRef<HTMLDivElement, CardProps>((props, ref) => {
  const { className, ...rest } = props
  return (
    <div
      ref={ref}
      className={cn(
        "rounded-xl border bg-card text-card-foreground shadow",
        className
      )}
      {...rest}
    />
  )
})

const CardHeader = React.forwardRef<HTMLDivElement, CardProps>((props, ref) => {
  const { className, ...rest } = props
  return (
    <div
      ref={ref}
      className={cn("flex flex-col space-y-1.5 p-6", className)}
      {...rest}
    />
  )
})

const CardTitle = React.forwardRef<HTMLHeadingElement, React.HTMLAttributes<HTMLHeadingElement>>(
  (props, ref) => {
    const { className, ...rest } = props
    return (
      <h3
        ref={ref}
        className={cn("font-semibold leading-none tracking-tight", className)}
        {...rest}
      />
    )
  }
)

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  (props, ref) => {
    const { className, ...rest } = props
    return (
      <p
        ref={ref}
        className={cn("text-sm text-muted-foreground", className)}
        {...rest}
      />
    )
  }
)

const CardContent = React.forwardRef<HTMLDivElement, CardProps>((props, ref) => {
  const { className, ...rest } = props
  return (
    <div 
      ref={ref} 
      className={cn("p-6 pt-0", className)} 
      {...rest} 
    />
  )
})

Card.displayName = "Card"
CardHeader.displayName = "CardHeader"
CardTitle.displayName = "CardTitle"
CardContent.displayName = "CardContent"
CardDescription.displayName = "CardDescription"

export { Card, CardHeader, CardTitle, CardContent, CardFooter, CardDescription }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\checkbox.tsx:
==================================================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\collapsible.tsx:
==================================================
// @/components/ui/collapsible.tsx
"use client";

import * as React from "react";
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\command.tsx:
==================================================
import * as React from "react";
import { DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { cn } from "@/lib/utils";
import { Dialog, DialogContent } from "@/components/ui/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Input
    ref={ref}
    className={cn(
      "flex h-10 w-full rounded-md bg-transparent px-3 py-2 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
      className
    )}
    {...props}
  />
));
CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));
CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));
CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
));
CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  />
));
CommandItem.displayName = CommandPrimitive.Item.displayName;
interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};
export {
  Command,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandDialog,
};


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\dialog.tsx:
==================================================
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { cn } from "@/lib/utils";
import { X } from "lucide-react";

const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = ({
  children,
  ...props
}: DialogPrimitive.DialogPortalProps) => (
  <DialogPrimitive.Portal {...props}>
    <div className="fixed inset-0 z-50 overflow-y-auto py-6">
      <div className="min-h-full flex items-center justify-center">
        {children}
      </div>
    </div>
  </DialogPrimitive.Portal>
);
DialogPortal.displayName = DialogPrimitive.Portal.displayName;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm transition-all duration-100 data-[state=closed]:animate-out data-[state=closed]:fade-out data-[state=open]:fade-in",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed z-50 grid w-full gap-4 rounded-lg border bg-background shadow-lg animate-in data-[state=open]:fade-in-90 data-[state=open]:slide-in-from-bottom-10 sm:zoom-in-90 data-[state=open]:sm:slide-in-from-bottom-0",
        "max-h-[85vh] overflow-y-auto mx-auto",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight text-center w-full",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\dropdown-menu.tsx:
==================================================
// @/components/ui/dropdown-menu.tsx
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\image-viewer.tsx:
==================================================
// src/components/ui/image-viewer.tsx
import React from "react";
import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight, X } from "lucide-react";
import Image from "next/image";

interface ImageViewerProps {
  images: { id: string; url: string; isMain?: boolean }[];
  selectedIndex: number | null;
  onClose: () => void;
  title?: string;
}

const ImageViewer: React.FC<ImageViewerProps> = ({
  images,
  selectedIndex,
  onClose,
  title = "תצוגת תמונה",
}) => {
  const handlePreviousImage = () => {
    if (selectedIndex !== null) {
      const newIndex =
        selectedIndex === 0 ? images.length - 1 : selectedIndex - 1;
      setCurrentIndex(newIndex);
    }
  };

  const handleNextImage = () => {
    if (selectedIndex !== null) {
      const newIndex =
        selectedIndex === images.length - 1 ? 0 : selectedIndex + 1;
      setCurrentIndex(newIndex);
    }
  };

  const [currentIndex, setCurrentIndex] = React.useState(selectedIndex);

  React.useEffect(() => {
    setCurrentIndex(selectedIndex);
  }, [selectedIndex]);

  if (selectedIndex === null || currentIndex === null) return null;

  return (
    <Dialog open={selectedIndex !== null} onOpenChange={onClose}>
      <DialogContent className="max-w-screen-lg h-screen flex items-center justify-center">
        <DialogTitle className="sr-only">{title}</DialogTitle>

        <Button
          variant="ghost"
          size="icon"
          className="absolute left-4 top-1/2 transform -translate-y-1/2"
          onClick={handlePreviousImage}
          aria-label="תמונה קודמת"
        >
          <ChevronLeft className="h-8 w-8" />
        </Button>

        <div className="relative w-full h-[80vh]">
          <Image
            src={images[currentIndex].url}
            alt={`תמונה ${currentIndex + 1} מתוך ${images.length}`}
            fill
            className="object-contain"
            priority
          />
        </div>

        <Button
          variant="ghost"
          size="icon"
          className="absolute right-4 top-1/2 transform -translate-y-1/2"
          onClick={handleNextImage}
          aria-label="תמונה הבאה"
        >
          <ChevronRight className="h-8 w-8" />
        </Button>

        <Button
          variant="ghost"
          size="icon"
          className="absolute right-4 top-4"
          onClick={onClose}
          aria-label="סגור תצוגת תמונה"
        >
          <X className="h-6 w-6" />
        </Button>
      </DialogContent>
    </Dialog>
  );
};

export default ImageViewer;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\input.tsx:
==================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\label.tsx:
==================================================
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);

type LabelElement = React.ElementRef<typeof LabelPrimitive.Root>;
type LabelProps = React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
  VariantProps<typeof labelVariants> & {
    className?: string;
  };

const Label = React.forwardRef<LabelElement, LabelProps>(
  ({ className, ...props }: LabelProps, ref) => (
    <LabelPrimitive.Root
      ref={ref}
      className={cn(labelVariants(), className)}
      {...props}
    />
  )
);

Label.displayName = "Label";

export { Label };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\loading-spinner.tsx:
==================================================
// src/components/ui/loading-spinner.tsx
import React from "react";
import { cn } from "@/lib/utils";
import { Loader2 } from "lucide-react";

interface LoadingSpinnerProps {
  className?: string;
  size?: "sm" | "md" | "lg";
}

const sizeClasses = {
  sm: "w-4 h-4",
  md: "w-8 h-8",
  lg: "w-12 h-12",
};

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  className,
  size = "md" 
}) => {
  return (
    <div className="flex items-center justify-center w-full min-h-[100px]">
      <Loader2 
        className={cn(
          "animate-spin text-primary",
          sizeClasses[size],
          className
        )} 
      />
    </div>
  );
};

export default LoadingSpinner;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\multi-select.tsx:
==================================================
"use client"

import * as React from "react"
import { Check, X } from "lucide-react"
import { cn } from "@/lib/utils"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"

export type Option = {
  value: string
  label: string
}

interface MultiSelectProps {
  options: Option[]
  selected: string[]
  onChange: (values: string[]) => void
  placeholder?: string
  className?: string
  disabled?: boolean
}

export function MultiSelect({
  options,
  selected,
  onChange,
  placeholder = "בחר פריטים...",
  className,
  disabled = false,
  ...props
}: MultiSelectProps) {
  const [open, setOpen] = React.useState(false)

  const handleUnselect = (value: string) => {
    onChange(selected.filter((item) => item !== value))
  }

  return (
    <Popover open={open} onOpenChange={setOpen} modal={true}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className={cn("w-full justify-between", className)}
          onClick={() => setOpen(!open)}
          disabled={disabled}
        >
          <div className="flex flex-wrap gap-1">
            {selected.length > 0 ? (
              selected.map((value) => (
                <Badge
                  key={value}
                  variant="secondary"
                  className="ml-1"
                  onClick={(e) => {
                    e.stopPropagation()
                    handleUnselect(value)
                  }}
                >
                  {options.find((opt) => opt.value === value)?.label || value}
                  <button
                    className="ml-1 ring-offset-background rounded-full outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleUnselect(value)
                      }
                    }}
                    onMouseDown={(e) => {
                      e.preventDefault()
                      e.stopPropagation()
                    }}
                    onClick={(e) => {
                      e.preventDefault()
                      e.stopPropagation()
                      handleUnselect(value)
                    }}
                  >
                    <X className="h-3 w-3 text-muted-foreground hover:text-foreground" />
                  </button>
                </Badge>
              ))
            ) : (
              <span className="text-muted-foreground">{placeholder}</span>
            )}
          </div>
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-full p-0" align="start">
        <Command className="w-full">
          <CommandInput placeholder={placeholder} />
          <CommandEmpty>לא נמצאו תוצאות.</CommandEmpty>
          <CommandGroup className="max-h-64 overflow-auto">
            {options.map((option) => (
              <CommandItem
                key={option.value}
                onSelect={() => {
                  onChange(
                    selected.includes(option.value)
                      ? selected.filter((item) => item !== option.value)
                      : [...selected, option.value]
                  )
                }}
              >
                <Check
                  className={cn(
                    "mr-2 h-4 w-4",
                    selected.includes(option.value)
                      ? "opacity-100"
                      : "opacity-0"
                  )}
                />
                {option.label}
              </CommandItem>
            ))}
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  )
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\popover.tsx:
==================================================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\ProfileModal.tsx:
==================================================
import React, { ReactNode } from 'react';
import { Dialog } from '@/components/ui/dialog';
import { DialogContent } from '@/components/ui/dialog';

interface ProfileModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: ReactNode;
}

const ProfileModal = ({ isOpen, onClose, children }: ProfileModalProps) => {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-h-[80vh] overflow-y-auto sm:max-w-2xl">
        {children}
      </DialogContent>
    </Dialog>
  );
};

export default ProfileModal;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\progress-indicator.tsx:
==================================================
import React from "react";

interface ProgressIndicatorProps {
  currentStep: number;
  totalSteps: number;
  className?: string;
}

export function ProgressIndicator({ 
  currentStep, 
  totalSteps, 
  className = "" 
}: ProgressIndicatorProps) {
  const percentage = ((currentStep + 1) / totalSteps) * 100;

  return (
    <div className={`w-full ${className}`}>
      <div className="flex justify-between mb-1 text-sm text-gray-500">
        <span>התקדמות</span>
        <span>{Math.round(percentage)}%</span>
      </div>
      <div className="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
        <div 
          className="h-full bg-gradient-to-r from-blue-500 to-blue-600 transition-all duration-300 ease-in-out"
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\progress.tsx:
==================================================
// components/ui/progress.tsx
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-gray-100",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-blue-600 transition-all"
      style={{ transform: `translateX(${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\radio-group.tsx:
==================================================
import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { cn } from "@/lib/utils";
import { Circle } from "lucide-react";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\resizable.tsx:
==================================================
// @/components/ui/resizable.tsx
"use client";

import { GripVertical } from "lucide-react";
import * as ResizablePrimitive from "react-resizable-panels";
import { cn } from "@/lib/utils";

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\scroll-area.tsx:
==================================================
// @/components/ui/scroll-area.tsx
"use client";

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "@/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\select.tsx:
==================================================
// src/components/ui/select.tsx
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";
import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
      dir="rtl"
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className
    )}
    {...props}
  >
    {children}
    <ChevronDown className="h-4 w-4 opacity-50" />
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      dir="rtl"
      className={cn(
        "relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.Viewport
        className={cn(
          "p-1 text-right", // הוספנו text-right
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    dir="rtl"
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectItem,
  SelectSeparator,
};


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\separator.tsx:
==================================================
import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={`shrink-0 bg-border ${
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]"
      } ${className}`}
      {...props}
    />
  )
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\SimpleToast.tsx:
==================================================
import React from 'react';
import { cn } from "@/lib/utils";

interface ToastProps {
  message: string;
  type?: 'success' | 'error' | 'info';
  onClose?: () => void;
  isVisible: boolean;
}

export function SimpleToast({ message, type = 'info', onClose, isVisible }: ToastProps) {
  if (!isVisible) return null;

  const baseClasses = "fixed bottom-4 left-4 p-4 rounded-md shadow-lg z-50 transition-all duration-300";
  const typeClasses = {
    success: "bg-green-500 text-white",
    error: "bg-red-500 text-white",
    info: "bg-blue-500 text-white"
  };

  return (
    <div className={cn(baseClasses, typeClasses[type])}>
      <div className="flex items-center justify-between">
        <p>{message}</p>
        {onClose && (
          <button
            onClick={onClose}
            className="ml-4 text-white hover:text-gray-200"
          >
            ×
          </button>
        )}
      </div>
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\skeleton.tsx:
==================================================
// @/components/ui/skeleton.tsx
"use client";

import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  );
}

export { Skeleton };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\slider.tsx:
==================================================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-gray-100">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))

Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\split-pane.tsx:
==================================================
// components/ui/split-pane.tsx
import React, { useState, useRef, useEffect, useCallback } from "react";
import { cn } from "@/lib/utils";

interface SplitPaneProps {
  children: [React.ReactNode, React.ReactNode];
  split?: "vertical" | "horizontal";
  defaultSize?: number;
  minSize?: number;
  maxSize?: number;
  onChange?: (size: number) => void;
  className?: string;
}

export function SplitPane({
  children,
  split = "vertical",
  defaultSize = 50,
  minSize = 20,
  maxSize = 80,
  onChange,
  className,
}: SplitPaneProps) {
  const [size, setSize] = useState(defaultSize);
  const [isDragging, setIsDragging] = useState(false);
  const splitPaneRef = useRef<HTMLDivElement>(null);
  const resizerRef = useRef<HTMLDivElement>(null);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsDragging(true);
  }, []);

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isDragging || !splitPaneRef.current) return;

      const rect = splitPaneRef.current.getBoundingClientRect();
      let newSize;

      if (split === "vertical") {
        newSize = ((e.clientX - rect.left) / rect.width) * 100;
      } else {
        newSize = ((e.clientY - rect.top) / rect.height) * 100;
      }

      newSize = Math.max(minSize, Math.min(maxSize, newSize));
      setSize(newSize);
      onChange?.(newSize);
    },
    [isDragging, split, minSize, maxSize, onChange]
  );

  useEffect(() => {
    if (isDragging) {
      window.addEventListener("mousemove", handleMouseMove);
      window.addEventListener("mouseup", handleMouseUp);
    } else {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    }

    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isDragging, handleMouseMove, handleMouseUp]);

  return (
    <div
      ref={splitPaneRef}
      className={cn(
        "flex",
        split === "vertical" ? "flex-row" : "flex-col",
        className
      )}
    >
      <div
        className={cn("overflow-auto", split === "vertical" ? "h-full" : "")}
        style={{
          [split === "vertical" ? "width" : "height"]: `${size}%`,
        }}
      >
        {children[0]}
      </div>

      <div
        ref={resizerRef}
        className={cn(
          "bg-gray-200 hover:bg-blue-500 transition-colors duration-150",
          "cursor-col-resize",
          split === "vertical" ? "w-1 my-1 hover:w-1" : "h-1 mx-1 hover:h-1",
          isDragging && "bg-blue-500"
        )}
        onMouseDown={handleMouseDown}
      />

      <div
        className={cn("overflow-auto", split === "vertical" ? "h-full" : "")}
        style={{
          [split === "vertical" ? "width" : "height"]: `${100 - size}%`,
        }}
      >
        {children[1]}
      </div>
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\stats-card.tsx:
==================================================
import React from 'react';
import { LucideIcon } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';

interface StatsCardProps {
  icon: LucideIcon;
  title: string;
  value: string;
}

const StatsCard = ({ icon: Icon, title, value }: StatsCardProps) => {
  // Special styling for availability status
  const isAvailabilityCard = title === "סטטוס פניות";
  const isAvailable = value?.toLowerCase() === "available";
  
  return (
    <Card className="overflow-hidden">
      <CardContent className="p-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4 space-x-reverse">
            <div className="p-2 bg-primary/10 rounded-full">
              <Icon className="w-5 h-5 text-primary" />
            </div>
            <div>
              <p className="text-sm font-medium text-muted-foreground">
                {title}
              </p>
              {isAvailabilityCard ? (
                <div className="mt-1">
                  <span className={`
                    inline-flex items-center px-3 py-1 rounded-full text-sm font-semibold
                    ${isAvailable ? 
                      'bg-green-100 text-green-800' : 
                      'bg-gray-100 text-gray-800'
                    }
                  `}>
                    {value || "לא צוין"}
                  </span>
                </div>
              ) : (
                <p className="text-2xl font-semibold mt-1">
                  {value || "לא צוין"}
                </p>
              )}
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default StatsCard;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\steps.tsx:
==================================================
import React from 'react'
import { LucideIcon } from 'lucide-react'

interface Step {
  title: string
  description: string
  icon: LucideIcon
}

interface StepsProps {
  steps: Step[]
  currentStep: number
}

export function Steps({ steps, currentStep }: StepsProps) {
  return (
    <div className="flex w-full">
      {steps.map((step, index) => {
        const Icon = step.icon
        const isActive = currentStep === index + 1
        const isCompleted = currentStep > index + 1

        return (
          <React.Fragment key={step.title}>
            <div className="flex flex-1 flex-col items-center">
              <div
                className={`flex h-10 w-10 items-center justify-center rounded-full border-2 ${
                  isActive
                    ? 'border-primary bg-primary text-primary-foreground'
                    : isCompleted
                    ? 'border-primary bg-primary text-primary-foreground'
                    : 'border-border bg-background'
                }`}
              >
                <Icon className="h-5 w-5" />
              </div>
              <div className="mt-2 text-center">
                <div className="text-sm font-medium">{step.title}</div>
                <div className="text-sm text-muted-foreground">
                  {step.description}
                </div>
              </div>
            </div>
            {index < steps.length - 1 && (
              <div className="flex flex-1 items-center">
                <div
                  className={`h-[2px] w-full ${
                    currentStep > index + 1 ? 'bg-primary' : 'bg-border'
                  }`}
                />
              </div>
            )}
          </React.Fragment>
        )
      })}
    </div>
  )
}

export type { Step }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\switch.tsx:
==================================================
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))

Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\tabs.tsx:
==================================================
// src/components/ui/tabs.tsx
"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    dir="rtl"
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    dir="rtl"
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    dir="rtl"
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\textarea.tsx:
==================================================
import * as React from "react";
import { cn } from "@/lib/utils";

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = "Textarea";

export { Textarea };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\timeline.tsx:
==================================================
// src/components/ui/timeline.tsx
import * as React from "react";
import { LucideIcon } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import { cn } from "@/lib/utils";

export interface TimelineItem {
  title: string;
  description?: string;
  date: Date;
  icon: LucideIcon;
  status?: "default" | "success" | "warning" | "error";
}

interface TimelineProps extends React.HTMLAttributes<HTMLDivElement> {
  items: TimelineItem[];
}

const statusStyles = {
  default: "bg-primary/10 text-primary",
  success: "bg-green-100 text-green-600",
  warning: "bg-yellow-100 text-yellow-600",
  error: "bg-red-100 text-red-600",
};

export function Timeline({ items, className, ...props }: TimelineProps) {
  return (
    <div className={cn("relative space-y-8", className)} {...props}>
      {items.map((item, index) => (
        <div key={index} className="flex gap-4 items-start">
          {/* Icon Container */}
          <div className="relative">
            <div
              className={cn(
                "w-8 h-8 rounded-full flex items-center justify-center",
                statusStyles[item.status || "default"]
              )}
            >
              {React.createElement(item.icon, { className: "w-4 h-4" })}
            </div>
            {index !== items.length - 1 && (
              <div className="absolute top-8 left-4 w-[2px] h-16 bg-gray-200" />
            )}
          </div>

          {/* Content */}
          <div className="flex-1">
            <div className="flex items-center justify-between">
              <h4 className="font-medium">{item.title}</h4>
              <time className="text-sm text-gray-500">
                {formatDistanceToNow(item.date, {
                  addSuffix: true,
                  locale: he,
                })}
              </time>
            </div>
            {item.description && (
              <p className="mt-1 text-sm text-gray-600">{item.description}</p>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\tooltip.tsx:
==================================================
// src/components/ui/tooltip.tsx

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\virtual-grid.tsx:
==================================================
// components/ui/virtual-grid.tsx
import React, { useEffect, useRef, useState } from 'react';
import { cn } from '@/lib/utils';

interface VirtualGridProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  className?: string;
  itemHeight?: number;
  itemWidth?: number;
  overscan?: number;
}

export function VirtualGrid<T>({
  items,
  renderItem,
  className,
  itemHeight = 300,
  itemWidth = 250,
  overscan = 5,
}: VirtualGridProps<T>) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });
  const [containerWidth, setContainerWidth] = useState(0);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const calculateVisibleItems = () => {
      const rect = container.getBoundingClientRect();
      setContainerWidth(rect.width);
      
      const itemsPerRow = Math.max(1, Math.floor(rect.width / itemWidth));
      const rowHeight = itemHeight;
      const totalRows = Math.ceil(items.length / itemsPerRow);
      
      const scrollTop = container.scrollTop;
      const viewportHeight = container.clientHeight;
      
      const startRow = Math.max(0, Math.floor(scrollTop / rowHeight) - overscan);
      const endRow = Math.min(
        totalRows,
        Math.ceil((scrollTop + viewportHeight) / rowHeight) + overscan
      );
      
      const start = startRow * itemsPerRow;
      const end = Math.min(items.length, (endRow + 1) * itemsPerRow);
      
      setVisibleRange({ start, end });
    };

    // Set up ResizeObserver
    const observer = new ResizeObserver(calculateVisibleItems);
    observer.observe(container);

    // Set up scroll listener
    container.addEventListener('scroll', calculateVisibleItems);
    calculateVisibleItems();

    // Cleanup
    return () => {
      observer.disconnect();
      container.removeEventListener('scroll', calculateVisibleItems);
    };
  }, [items.length, itemHeight, itemWidth, overscan]);

  const itemsPerRow = Math.max(1, Math.floor(containerWidth / itemWidth));
  const totalHeight = Math.ceil(items.length / itemsPerRow) * itemHeight;

  const visibleItems = items.slice(visibleRange.start, visibleRange.end);
  const paddingTop = Math.floor(visibleRange.start / itemsPerRow) * itemHeight;

  return (
    <div
      ref={containerRef}
      className={cn("overflow-auto h-full relative", className)}
      style={{ WebkitOverflowScrolling: 'touch' }}
    >
      <div
        style={{
          height: totalHeight,
          position: 'relative',
        }}
      >
        <div
          style={{
            position: 'absolute',
            top: paddingTop,
            display: 'grid',
            gridTemplateColumns: `repeat(auto-fill, minmax(${itemWidth}px, 1fr))`,
            gap: '1rem',
            width: '100%',
          }}
        >
          {visibleItems.map(renderItem)}
        </div>
      </div>
    </div>
  );
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\visually-hidden.tsx:
==================================================
import * as React from "react"
import { cn } from "@/lib/utils"

const VisuallyHidden = React.forwardRef<
  HTMLSpanElement,
  React.HTMLAttributes<HTMLSpanElement>
>(({ className, ...props }, ref) => {
  return (
    <span
      ref={ref}
      className={cn(
        "absolute w-[1px] h-[1px] p-0 -m-[1px] overflow-hidden clip-rect-0 border-0 whitespace-nowrap",
        className
      )}
      {...props}
    />
  )
})

VisuallyHidden.displayName = "VisuallyHidden"

export { VisuallyHidden }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\form\form.tsx:
==================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { Label } from "@/components/ui/label"
import { cn } from "@/lib/utils"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\toast\toast.d.ts:
==================================================
import * as React from "react"

export type ToastProps = {
  id?: string
  className?: string
  title?: React.ReactNode
  description?: React.ReactNode
  variant?: "default" | "destructive"
  action?: ToastActionElement
  open?: boolean
  onOpenChange?: (open: boolean) => void
}

export type ToastActionElement = React.ReactElement<{
  className?: string
  altText?: string
  onClick?: () => void
}>

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\toast\toaster.tsx:
==================================================
"use client"

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast/toast"
import { useToast } from "@/components/ui/toast/use-toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\components\ui\toast\use-toast.ts:
==================================================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\hooks\useInterval.ts:
==================================================
import { useEffect, useRef } from 'react';

export function useInterval(callback: () => void, delay: number | null) {
  const savedCallback = useRef<() => void>();

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    if (delay !== null) {
      const id = setInterval(() => {
        savedCallback.current?.();
      }, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\hooks\useQuestionnaireSave.ts:
==================================================
///hooks/useQuestionnaireSave.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { useSession } from 'next-auth/react';
import { questionnaireService } from '@/lib/services/questionnaireService';
import type { 
  QuestionnaireResponse,
  TempQuestionnaireSession,
  QuestionnaireUpdatePayload,
  QuestionnaireSessionState
} from '@/components/questionnaire/types/responses';

interface UseQuestionnaireSaveProps {
  initialData?: QuestionnaireResponse | TempQuestionnaireSession;
  autoSaveInterval?: number; // בשניות
  onSaveError?: (error: Error) => void;
}

export function useQuestionnaireSave({
  initialData,
  autoSaveInterval = 120, // ברירת מחדל - 2 דקות
  onSaveError
}: UseQuestionnaireSaveProps) {
  const { data: session } = useSession();
  const [sessionState, setSessionState] = useState<QuestionnaireSessionState>({
    isTemporary: !session,
    currentResponse: initialData,
    lastSaved: new Date(),
    hasUnsavedChanges: false,
    autoSaveInterval,
    version: 0
  });

  const pendingChanges = useRef<QuestionnaireUpdatePayload | null>(null);
  const autoSaveTimeout = useRef<NodeJS.Timeout>();

  // פונקציית השמירה העיקרית
  const saveChanges = useCallback(async (changes: QuestionnaireUpdatePayload, createVersion = false) => {
    try {
      let response;

      if (session?.user) {
        // משתמש מחובר - שמירה קבועה
        if (sessionState.currentResponse?.id) {
          if (createVersion) {
            response = await questionnaireService.createVersion(
              sessionState.currentResponse.id,
              changes,
              'Manual save'
            );
          } else {
            response = await questionnaireService.saveResponse(session.user.id, changes);
          }
        }
      } else {
        // משתמש לא מחובר - שמירה זמנית
        const sessionToken = (sessionState.currentResponse as TempQuestionnaireSession)?.sessionToken 
          || crypto.randomUUID();
        response = await questionnaireService.saveTempSession(sessionToken, changes);
      }

      setSessionState(prev => ({
        ...prev,
        currentResponse: response,
        lastSaved: new Date(),
        hasUnsavedChanges: false,
        version: createVersion ? prev.version + 1 : prev.version
      }));

      pendingChanges.current = null;
      return response;
    } catch (error) {
      onSaveError?.(error as Error);
      throw error;
    }
  }, [session, sessionState.currentResponse, onSaveError]);

  // שמירה אוטומטית
  const autoSave = useCallback(async () => {
    if (pendingChanges.current && sessionState.hasUnsavedChanges) {
      try {
        if (session?.user && sessionState.currentResponse?.id) {
          await questionnaireService.autoSave(
            sessionState.currentResponse.id,
            pendingChanges.current
          );
        }
        setSessionState(prev => ({
          ...prev,
          lastSaved: new Date(),
          hasUnsavedChanges: false
        }));
        pendingChanges.current = null;
      } catch (error) {
        console.error('Auto-save failed:', error);
      }
    }
  }, [session, sessionState.currentResponse, sessionState.hasUnsavedChanges]);

  // הגדרת טיימר לשמירה אוטומטית
  useEffect(() => {
    if (autoSaveInterval > 0) {
      autoSaveTimeout.current = setInterval(autoSave, autoSaveInterval * 1000);
      return () => {
        if (autoSaveTimeout.current) {
          clearInterval(autoSaveTimeout.current);
        }
      };
    }
  }, [autoSave, autoSaveInterval]);

  // עדכון שינויים
  const updateChanges = useCallback((changes: QuestionnaireUpdatePayload) => {
    pendingChanges.current = {
      ...(pendingChanges.current || {}),
      ...changes
    };
    setSessionState(prev => ({
      ...prev,
      hasUnsavedChanges: true
    }));
  }, []);

  // המרת סשן זמני לקבוע
  const convertToPermament = useCallback(async () => {
    if (!session?.user || !sessionState.isTemporary) return;

    try {
      const sessionToken = (sessionState.currentResponse as TempQuestionnaireSession).sessionToken;
      const response = await questionnaireService.convertTempToResponse(
        sessionToken,
        session.user.id
      );

      setSessionState(prev => ({
        ...prev,
        isTemporary: false,
        currentResponse: response,
        version: 0
      }));

      return response;
    } catch (error) {
      onSaveError?.(error as Error);
      throw error;
    }
  }, [session, sessionState.isTemporary, sessionState.currentResponse, onSaveError]);

  return {
    sessionState,
    saveChanges,
    updateChanges,
    convertToPermament,
    pendingChanges: !!pendingChanges.current
  };
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\auth.ts:
==================================================
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import prisma from "./prisma";
import { compare } from "bcryptjs";
import type { JWT } from "next-auth/jwt";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error("Missing credentials");
        }

        const user = await prisma.user.findUnique({
          where: { 
            email: credentials.email 
          },
          include: {
            profile: true,
            images: true,
            questionnaireResponses: {
              orderBy: {
                createdAt: 'desc'
              },
              take: 1
            }
          }
        });

        if (!user) {
          throw new Error("No user found");
        }

        const isPasswordValid = await compare(credentials.password, user.password);
        if (!isPasswordValid) {
          throw new Error("Invalid password");
        }

        const mainImage = user.images.find(img => img.isMain);

        await prisma.user.update({
          where: { id: user.id },
          data: { lastLogin: new Date() }
        });

        return {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          name: `${user.firstName} ${user.lastName}`,
          image: mainImage?.url || null,
          role: user.role,
          status: user.status,
          isVerified: user.isVerified,
          lastLogin: user.lastLogin,
          createdAt: user.createdAt,
          updatedAt: user.updatedAt,
          profile: user.profile,
          images: user.images,
          questionnaireResponses: user.questionnaireResponses
        };
      }
    })
  ],

  callbacks: {
    async jwt({ token, user }): Promise<JWT> {
      if (user) {
        token.id = user.id;
        token.email = user.email;
        token.firstName = user.firstName;
        token.lastName = user.lastName;
        token.name = user.name || null;
        token.picture = user.image || null;
        token.role = user.role;
        token.status = user.status;
        token.isVerified = user.isVerified;
        token.lastLogin = user.lastLogin;
        token.createdAt = user.createdAt;
        token.updatedAt = user.updatedAt;
        token.profile = user.profile;
        token.images = user.images;
        token.questionnaireResponses = user.questionnaireResponses;
      }
      return token;
    },

    async session({ session, token }) {
      if (session.user && token) {
        session.user.id = token.id;
        session.user.email = token.email as string;  // הוספנו as string
        session.user.firstName = token.firstName;
        session.user.lastName = token.lastName;
        session.user.name = token.name;
        session.user.image = token.picture;
        session.user.role = token.role;
        session.user.status = token.status;
        session.user.isVerified = token.isVerified;
        session.user.lastLogin = token.lastLogin;
        session.user.createdAt = token.createdAt;
        session.user.updatedAt = token.updatedAt;
        session.user.profile = token.profile;
        session.user.images = token.images;
        session.user.questionnaireResponses = token.questionnaireResponses;
      }
      return session;
    }
  },

  pages: {
    signIn: '/auth/signin',
    error: '/auth/error',
    newUser: '/auth/complete-registration',
    verifyRequest: '/auth/verify-request'
  },

  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60,
  },

  secret: process.env.NEXTAUTH_SECRET,
  jwt: {
    maxAge: 30 * 24 * 60 * 60,
  },
  useSecureCookies: process.env.NODE_ENV === "production",
};

export default authOptions;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\db.ts:
==================================================
// src/lib/db.ts
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

declare global {
  var prisma: undefined | ReturnType<typeof prismaClientSingleton>
}

export const db = globalThis.prisma ?? prismaClientSingleton()

if (process.env.NODE_ENV !== 'production') globalThis.prisma = db


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\prisma.ts:
==================================================
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

type PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClientSingleton | undefined
}

const prisma = globalForPrisma.prisma ?? prismaClientSingleton()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

export default prisma

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\tokens.ts:
==================================================
// src/lib/tokens.ts
import { randomBytes } from 'crypto';
import { promisify } from 'util';

const randomBytesAsync = promisify(randomBytes);

export const generateToken = async (length: number = 32): Promise<string> => {
  const buffer = await randomBytesAsync(length);
  return buffer.toString('hex');
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\utils.ts:
==================================================
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function calculateAge(birthDate: Date | string | null): number {
  if (!birthDate) return 0;
  
  const birth = new Date(birthDate);
  const today = new Date();
  
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  
  // If not had birthday this year yet, subtract one year
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  
  return age;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\email\emailService.ts:
==================================================
// src/lib/email/emailService.ts

import nodemailer from 'nodemailer';
import Handlebars from 'handlebars';
import { readFileSync } from 'fs';
import path from 'path';

// הגדרת טיפוסים
interface EmailConfig {
  to: string;
  subject: string;
  template: string;
  context: Record<string, any>;
}

interface AvailabilityCheckEmailParams {
  email: string;
  recipientName: string;
  matchmakerName: string;
  inquiryId: string;
}
interface WelcomeEmailParams {
  email: string;
  firstName: string;
  requiresVerification?: boolean;
  matchmakerAssigned?: boolean;
  matchmakerName?: string;
  dashboardUrl: string;
  supportEmail: string;
  unsubscribeUrl?: string;
  privacyNote?: boolean;
}

interface VerificationEmailParams {
  email: string;
  verificationLink: string;
  firstName?: string;
  expiresIn?: string;
}

interface InvitationEmailParams {
  email: string;
  invitationLink: string;
  matchmakerName: string;
  expiresIn?: string;
}

interface SuggestionEmailParams {
  email: string;
  recipientName: string;
  matchmakerName: string;
  suggestionDetails?: {
    age?: number;
    city?: string;
    occupation?: string;
    additionalInfo?: string | null;
  };
}
interface ContactDetailsEmailParams {
  email: string;
  recipientName: string;
  otherPartyName: string;
  otherPartyContact: {
    phone?: string;
    email?: string;
    whatsapp?: string;
  };
  matchmakerName: string;
  supportEmail?: string;
}
// טיפוס להקשר של התבנית
interface TemplateContext {
  [key: string]: unknown;
}
interface AvailabilityCheckEmailParams {
  email: string;
  recipientName: string;
  matchmakerName: string;
  inquiryId: string;
  baseUrl?: string;
}


class EmailService {
  private transporter: nodemailer.Transporter;
  private templateCache: Map<string, Handlebars.TemplateDelegate<TemplateContext>>;

  constructor() {
    // יצירת טרנספורטר nodemailer
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD,
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // אתחול מטמון התבניות
    this.templateCache = new Map();

    // הגדרת הלפרים של Handlebars
    Handlebars.registerHelper('formatDate', function(this: unknown, date: Date) {
      return new Date(date).toLocaleDateString('he-IL');
    });

    Handlebars.registerHelper('ifeq', function(
      this: unknown,
      a: unknown,
      b: unknown,
      options: Handlebars.HelperOptions
    ) {
      return (a === b) ? options.fn(this) : options.inverse(this);
    });
  }

  private async loadTemplate(templateName: string): Promise<Handlebars.TemplateDelegate<TemplateContext>> {
    const cached = this.templateCache.get(templateName);
    if (cached) {
      return cached;
    }

    try {
      const templatePath = path.join(process.cwd(), 'src/lib/email/templates', `${templateName}.hbs`);
      const templateContent = readFileSync(templatePath, 'utf-8');
      const template = Handlebars.compile<TemplateContext>(templateContent);
      this.templateCache.set(templateName, template);
      return template;
    } catch (error) {
      console.error(`Error loading template ${templateName}:`, error);
      throw new Error(`Failed to load email template: ${templateName}`);
    }
  }
 
  async sendAvailabilityCheck({
    email,
    recipientName,
    matchmakerName,
    inquiryId,
    baseUrl = process.env.NEXT_PUBLIC_BASE_URL
  }: AvailabilityCheckEmailParams): Promise<void> {
    await this.sendEmail({
      to: email,
      subject: 'בקשת בדיקת זמינות לשידוך',
      template: 'availability-check',
      context: {
        recipientName,
        matchmakerName,
        inquiryId,
        baseUrl
      }
    });
  }
  async sendEmail({ to, subject, template, context }: EmailConfig): Promise<void> {
    try {
      const compiledTemplate = await this.loadTemplate(template);
      const html = compiledTemplate(context);

      const mailOptions: nodemailer.SendMailOptions = {
        from: `${process.env.EMAIL_FROM_NAME} <${process.env.GMAIL_USER}>`,
        to,
        subject,
        html,
        headers: {
          'Content-Type': 'text/html; charset=UTF-8',
          'X-Priority': '1',
          'X-MSMAIL-Priority': 'High'
        }
      };

      const info = await this.transporter.sendMail(mailOptions);
      console.log('Email sent successfully:', info.messageId);
      
    } catch (error) {
      console.error('Error sending email:', error);
      throw new Error('Failed to send email');
    }
  }

  async sendWelcomeEmail({
    email,
    firstName,
    requiresVerification = false,
    matchmakerAssigned = false,
    matchmakerName = '',
    dashboardUrl,
    supportEmail,
    unsubscribeUrl,
    privacyNote = true
  }: WelcomeEmailParams): Promise<void> {
    await this.sendEmail({
      to: email,
      subject: 'ברוכים הבאים למערכת השידוכים',
      template: 'welcome',
      context: {
        firstName,
        requiresVerification,
        matchmakerAssigned,
        matchmakerName,
        dashboardUrl: `${process.env.NEXT_PUBLIC_BASE_URL}${dashboardUrl}`,
        supportEmail: supportEmail || process.env.SUPPORT_EMAIL,
        unsubscribeUrl,
        privacyNote,
        currentYear: new Date().getFullYear()
      }
    });
  }

  async sendVerificationEmail({
    email,
    verificationLink,
    firstName,
    expiresIn = '24 שעות'
  }: VerificationEmailParams): Promise<void> {
    // Construct the full verification URL
    const fullVerificationLink = `${process.env.NEXT_PUBLIC_BASE_URL}/auth/verify-email?token=${verificationLink}`;

    await this.sendEmail({
      to: email,
      subject: 'אימות כתובת האימייל שלך',
      template: 'email-verification',
      context: {
        firstName,
        verificationLink: fullVerificationLink,
        expiresIn,
        supportEmail: process.env.SUPPORT_EMAIL
      }
    });
  }

  async sendInvitation({
    email,
    invitationLink,
    matchmakerName,
    expiresIn = '7 ימים'
}: InvitationEmailParams): Promise<void> {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    await this.sendEmail({
        to: email,
        subject: 'הזמנה להצטרף למערכת השידוכים',
        template: 'invitation',
        context: {
            matchmakerName,
            baseUrl,
            token: invitationLink, // שולחים רק את הטוקן עצמו
            expiresIn
        }
    });
}
async sendContactDetailsEmail({
  email,
  recipientName,
  otherPartyName,
  otherPartyContact,
  matchmakerName,
  supportEmail = process.env.SUPPORT_EMAIL
}: ContactDetailsEmailParams): Promise<void> {
  await this.sendEmail({
    to: email,
    subject: 'פרטי קשר להצעת השידוך',
    template: 'share-contact-details',
    context: {
      recipientName,
      otherPartyName,
      otherPartyContact,
      matchmakerName,
      supportEmail
    }
  });
}

  async sendSuggestionNotification({
    email,
    recipientName,
    matchmakerName,
    suggestionDetails
  }: SuggestionEmailParams): Promise<void> {
    await this.sendEmail({
      to: email,
      subject: 'הצעת שידוך חדשה ממתינה לך',
      template: 'suggestion',
      context: {
        recipientName,
        matchmakerName,
        suggestionDetails,
        dashboardUrl: `${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions`,
        supportEmail: process.env.SUPPORT_EMAIL
      }
    });
  }

  async sendPasswordReset(email: string, resetLink: string): Promise<void> {
    const fullResetLink = `${process.env.NEXT_PUBLIC_BASE_URL}/reset-password?token=${resetLink}`;
    
    await this.sendEmail({
      to: email,
      subject: 'איפוס סיסמה',
      template: 'password-reset',
      context: {
        resetLink: fullResetLink,
        expiresIn: '1 שעה',
        supportEmail: process.env.SUPPORT_EMAIL
      }
    });
  }

  async verifyConnection(): Promise<boolean> {
    try {
      await this.transporter.verify();
      return true;
    } catch (error) {
      console.error('Email service connection error:', error);
      return false;
    }
  }
}

// יצוא singleton instance
export const emailService = new EmailService();

// טיפוסי ייצוא
export type {
  EmailConfig,
  WelcomeEmailParams,
  VerificationEmailParams,
  InvitationEmailParams,
  SuggestionEmailParams,
  TemplateContext,
  ContactDetailsEmailParams 
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\email\templates\availability-check.hbs:
==================================================
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .deadline {
            background-color: #FEF3C7;
            border-radius: 4px;
            padding: 10px;
            margin: 15px 0;
            color: #92400E;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>בקשת בדיקת זמינות</h1>
        </div>
        
        <div style="padding: 20px;">
            <h2>שלום {{recipientName}},</h2>
            
            <p>השדכן/ית {{matchmakerName}} חושב/ת על הצעת שידוך עבורך ומבקש/ת לוודא את זמינותך.</p>
            
            <p>נשמח אם תוכל/י לאשר את זמינותך דרך המערכת באחת משתי הדרכים:</p>
            
            <div style="text-align: center;">
             <a href="{{baseUrl}}/messages" class="button">
    כניסה למערכת למענה על הבקשה
</a>
            </div>

            <p>או דרך:</p>
            <ol>
                <li>כניסה למערכת</li>
                <li>לחיצה על "הודעות" בתפריט העליון</li>
                <li>מענה על בקשת הזמינות</li>
            </ol>

            <div class="deadline">
                <p>⏰ חשוב לדעת:</p>
                <ul>
                    <li>התשובה תקפה ל-24 שעות</li>
                    <li>תשובתך תעדכן את סטטוס הזמינות הכללי שלך במערכת</li>
                </ul>
            </div>
            
            <p>בברכה,<br>צוות מערכת השידוכים</p>
        </div>
    </div>
</body>
</html>

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\email\templates\email-verification.hbs:
==================================================
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid #f0f0f0;
        }
        .content {
            padding: 30px 20px;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
            text-align: center;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #f0f0f0;
            text-align: center;
            font-size: 14px;
            color: #666;
        }
        .info {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>אימות כתובת אימייל</h1>
        </div>
        
        <div class="content">
            {{#if firstName}}
            <h2>שלום {{firstName}}!</h2>
            {{else}}
            <h2>שלום!</h2>
            {{/if}}
            
            <p>תודה שנרשמת למערכת השידוכים שלנו. כדי להשלים את תהליך ההרשמה, אנא לחץ/י על הכפתור הבא:</p>
            
            <div style="text-align: center;">
                <a href="{{verificationLink}}" class="button">
                    אימות כתובת אימייל
                </a>
            </div>

            <div class="info">
                <p>⏰ שים/י לב: קישור זה תקף ל-{{expiresIn}}</p>
                <p>אם לא ביקשת לאמת את כתובת האימייל שלך, אנא התעלם/י מהודעה זו.</p>
            </div>

            <p>לאחר האימות, תוכל/י להשלים את פרטי הפרופיל שלך ולהתחיל להשתמש במערכת.</p>
        </div>

        <div class="footer">
            <p>בברכה,<br>צוות מערכת השידוכים</p>
            {{#if supportEmail}}
            <p>לתמיכה: {{supportEmail}}</p>
            {{/if}}
        </div>
    </div>
</body>
</html>

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\email\templates\invitation.hbs:
==================================================
<!-- src/lib/email/templates/invitation.hbs -->
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>שלום {{firstName}},</h2>
        <p>הוזמנת להצטרף למערכת השידוכים על ידי השדכן/ית {{matchmakerName}}.</p>
        <p>כדי להשלים את תהליך ההרשמה, אנא לחץ/י על הקישור הבא:</p>
        <a href="{{baseUrl}}/auth/complete-registration?token={{token}}" class="button"></a>להשלמת ההרשמה</a>
        <p>הקישור תקף ל-{{expiresIn}}.</p>
        <p>אם לא ביקשת להצטרף למערכת, אנא התעלם/י מהודעה זו.</p>
        <p>בברכה,<br>צוות מערכת השידוכים</p>
    </div>
</body>
</html>

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\email\templates\share-contact-details.hbs:
==================================================
// src/lib/email/templates/share-contact-details.hbs
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        .content {
            padding: 20px;
        }
        .contact-details {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .important-note {
            background-color: #fef3c7;
            border-right: 4px solid #f59e0b;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>פרטי קשר לפגישה ראשונה</h1>
        </div>
        
        <div class="content">
            <h2>שלום {{recipientName}}!</h2>
            
            <p>השדכן/ית {{matchmakerName}} אישר/ה את ההצעה ואתם יכולים ליצור קשר ראשוני!</p>

        <div class="contact-details">
  <h3>פרטי הקשר של {{otherPartyName}}:</h3>
  {{#if otherPartyContact.email}}
    <p>📧 אימייל: {{otherPartyContact.email}}</p>
  {{/if}}
  {{#if otherPartyContact.whatsapp}}
    <p>💬 וואטסאפ: {{otherPartyContact.whatsapp}}</p>
  {{/if}}
</div>

            <div class="important-note">
                <h4>🔔 שימו לב:</h4>
                <ul>
                    <li>מומלץ ליצור קשר תוך 24 שעות</li>
                    <li>אנא עדכנו את השדכן/ית על קביעת הפגישה</li>
                    <li>לאחר הפגישה, תתבקשו למלא משוב קצר במערכת</li>
                </ul>
            </div>

            <p>בהצלחה רבה! אנו מאחלים לכם פגישה טובה ומוצלחת.</p>
        </div>

        <div class="footer">
            <p>בברכה,<br>צוות מערכת השידוכים</p>
            <p>{{supportEmail}}</p>
        </div>
    </div>
</body>
</html>

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\email\templates\suggestion.hbs:
==================================================
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            padding: 20px;
            background-color: #4F46E5;
            color: white;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        .content {
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
            text-align: center;
        }
        .suggestion-details {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>הצעת שידוך חדשה!</h1>
        </div>
        <div class="content">
            <h2>שלום {{recipientName}}!</h2>
            
            <p>השדכן/ית {{matchmakerName}} שלח/ה לך הצעת שידוך חדשה.</p>
            
            {{#if suggestionDetails}}
                <div class="suggestion-details">
                    <h3>פרטי ההצעה:</h3>
                    {{#if suggestionDetails.additionalInfo}}
                        <p>{{suggestionDetails.additionalInfo}}</p>
                    {{/if}}
                </div>
            {{/if}}

            <p>
                לצפייה בהצעה המלאה ולמתן תשובה, אנא היכנס/י למערכת:
            </p>
            
            <div style="text-align: center;">
                <a href="{{dashboardUrl}}" class="button">
                    צפייה בהצעה
                </a>
            </div>

            <p class="note">
                <strong>לתשומת לבך:</strong> נשמח לקבל את תגובתך תוך 48 שעות.
            </p>
        </div>

        <div class="footer">
            <p>בברכה,<br>צוות מערכת השידוכים</p>
            {{#if supportEmail}}
                <p>לתמיכה: {{supportEmail}}</p>
            {{/if}}
        </div>
    </div>
</body>
</html>

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\email\templates\welcome.hbs:
==================================================
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #4F46E5;
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        .content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4F46E5;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
        .steps {
            background-color: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .step {
            margin-bottom: 15px;
            padding-right: 20px;
            position: relative;
        }
        .step:before {
            content: "✓";
            position: absolute;
            right: 0;
            color: #4F46E5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ברוכים הבאים למערכת השידוכים</h1>
        </div>
        <div class="content">
            <h2>שלום {{firstName}}!</h2>
            <p>תודה שבחרת להצטרף למערכת השידוכים שלנו. אנו שמחים לקחת חלק במסע החשוב שלך.</p>
            
            <div class="steps">
                <h3>השלבים הבאים:</h3>
                {{#if requiresVerification}}
                <div class="step">
                    <strong>אימות חשבון:</strong> נשלח אליך מייל נפרד עם קישור לאימות החשבון שלך.
                </div>
                {{/if}}
                <div class="step">
                    <strong>השלמת פרופיל:</strong> הוסף/י את כל הפרטים החשובים שיעזרו לנו למצוא את ההתאמה המושלמת עבורך.
                </div>
                <div class="step">
                    <strong>העדפות התאמה:</strong> הגדר/י את ההעדפות שלך לגבי בן/בת הזוג המיועד/ת.
                </div>
                {{#if matchmakerAssigned}}
                <div class="step">
                    <strong>השדכן/ית שלך:</strong> {{matchmakerName}} ילווה אותך בתהליך.
                </div>
                {{/if}}
            </div>

            <p>מה עכשיו?</p>
            <a href="{{dashboardUrl}}" class="button">כניסה למערכת</a>

            <p>טיפים חשובים:</p>
            <ul>
                <li>מלא/י את הפרופיל בצורה מפורטת ככל האפשר</li>
                <li>הוסף/י תמונה עדכנית לפרופיל</li>
                <li>הגדר/י את העדפות החיפוש שלך בקפידה</li>
                <li>עדכן/י את הסטטוס שלך באופן שוטף</li>
            </ul>

            {{#if privacyNote}}
            <p class="privacy-note">
                <strong>הערה חשובה:</strong> הפרופיל שלך יהיה גלוי רק למשתמשים מאומתים ולשדכנים מורשים במערכת.
            </p>
            {{/if}}
        </div>
        <div class="footer">
            <p>
                מערכת השידוכים | לכל שאלה ניתן ליצור קשר במייל {{supportEmail}}
                {{#if unsubscribeUrl}}
                | <a href="{{unsubscribeUrl}}">הסרה מרשימת התפוצה</a>
                {{/if}}
            </p>
        </div>
    </div>
</body>
</html>

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\services\availabilityService.ts:
==================================================
// src/lib/services/availabilityService.ts
import prisma from '@/lib/prisma';
import { AvailabilityStatus, Prisma } from '@prisma/client';
import { emailService } from '@/lib/email/emailService';

interface SendInquiryParams {
  matchmakerId: string;
  firstPartyId: string;
  secondPartyId?: string;
  note?: string;
}

interface UpdateInquiryResponse {
  inquiryId: string;
  userId: string;
  isAvailable: boolean;
  note?: string;
}

interface GetInquiriesOptions {
  status?: 'pending' | 'completed' | 'expired';
  orderBy?: 'createdAt' | 'updatedAt';
  limit?: number;
}

interface AvailabilityStats {
  available: number;
  unavailable: number;
  dating: number;
  pending: number;
}

export class AvailabilityService {
  static async sendAvailabilityInquiry({
    matchmakerId,
    firstPartyId,
    note
  }: SendInquiryParams) {
    try {
      console.log('Starting availability inquiry process', {
        matchmakerId,
        firstPartyId,
        note
      });

      // Check for existing active inquiry
      const existingInquiry = await prisma.availabilityInquiry.findFirst({
        where: {
          firstPartyId,
          expiresAt: {
            gt: new Date()
          }
        }
      });

      if (existingInquiry) {
        console.log('Found existing active inquiry:', existingInquiry);
        throw new Error('קיימת כבר בקשת זמינות פעילה');
      }

      // Create new inquiry
      console.log('Creating new inquiry...');
      const inquiry = await prisma.availabilityInquiry.create({
        data: {
          matchmakerId,
          firstPartyId,
          secondPartyId: firstPartyId,
          note,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
        },
        include: {
          firstParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          secondParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      });
      
      console.log('Successfully created inquiry:', inquiry);

      // Send email notification
      if (inquiry.firstParty.email) {
        console.log('Attempting to send email to:', inquiry.firstParty.email);
        
        try {
          await emailService.sendAvailabilityCheck({
            email: inquiry.firstParty.email,
            recipientName: `${inquiry.firstParty.firstName} ${inquiry.firstParty.lastName}`,
            matchmakerName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            inquiryId: inquiry.id
          });
          console.log('Email sent successfully');
        } catch (emailError) {
          console.error('Failed to send email:', emailError);
          // Continue even if email fails - we want the inquiry to be saved
        }
      } else {
        console.warn('No email found for first party');
      }

      return inquiry;

    } catch (error) {
      console.error('Error in sendAvailabilityInquiry:', error);
      throw error;
    }
  }

  static async updateInquiryResponse({
    inquiryId,
    userId,
    isAvailable,
    note
  }: UpdateInquiryResponse) {
    try {
      console.log('Starting to update inquiry response:', {
        inquiryId,
        userId,
        isAvailable,
        note
      });

      // Check if inquiry exists
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      });

      if (!inquiry) {
        console.log('Inquiry not found:', inquiryId);
        throw new Error('בקשת הזמינות לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);

      if (inquiry.expiresAt < new Date()) {
        console.log('Inquiry expired:', inquiry.expiresAt);
        throw new Error('תוקף הבקשה פג');
      }

      const isFirstParty = inquiry.firstPartyId === userId;
      const isSecondParty = inquiry.secondPartyId === userId;

      if (!isFirstParty && !isSecondParty) {
        console.log('Unauthorized response attempt. User:', userId);
        throw new Error('אין הרשאה לעדכן בקשה זו');
      }

      // Update both inquiry and profile in a transaction
      console.log('Updating inquiry and profile...');
      const result = await prisma.$transaction(async (tx) => {
        // Update user's profile
        const updatedProfile = await tx.profile.update({
          where: { userId },
          data: {
            availabilityStatus: isAvailable ? AvailabilityStatus.AVAILABLE : AvailabilityStatus.UNAVAILABLE,
            availabilityNote: note,
            availabilityUpdatedAt: new Date()
          }
        });
        console.log('Profile updated:', updatedProfile);

        // Update the inquiry
        const updatedInquiry = await tx.availabilityInquiry.update({
          where: { id: inquiryId },
          data: {
            ...(isFirstParty ? { firstPartyResponse: isAvailable } : { secondPartyResponse: isAvailable }),
            updatedAt: new Date()
          },
          include: {
            firstParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true
              }
            },
            secondParty: {
              select: {
                firstName: true,
                lastName: true,
                email: true,
                profile: true
              }
            },
            matchmaker: {
              select: {
                firstName: true,
                lastName: true,
                email: true
              }
            }
          }
        });
        console.log('Inquiry updated:', updatedInquiry);

        // Send notification to matchmaker
        if (inquiry.matchmaker.email) {
          await emailService.sendSuggestionNotification({
            email: inquiry.matchmaker.email,
            recipientName: `${inquiry.matchmaker.firstName} ${inquiry.matchmaker.lastName}`,
            matchmakerName: "המערכת",
            suggestionDetails: {
              additionalInfo: `${isFirstParty ? 'הצד הראשון' : 'הצד השני'} ${isAvailable ? 'זמין' : 'אינו זמין'} ${note ? `(הערה: ${note})` : ''}`
            }
          });
        }

        return updatedInquiry;
      });

      return result;

    } catch (error) {
      console.error('Error in updateInquiryResponse:', error);
      throw error;
    }
  }

  static async getInquiryById(inquiryId: string) {
    console.log('Fetching inquiry by ID:', inquiryId);
    try {
      const inquiry = await prisma.availabilityInquiry.findUnique({
        where: { id: inquiryId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      });

      if (!inquiry) {
        console.log('No inquiry found with ID:', inquiryId);
        throw new Error('הבקשה לא נמצאה');
      }

      console.log('Found inquiry:', inquiry);
      return inquiry;

    } catch (error) {
      console.error('Error in getInquiryById:', error);
      throw error;
    }
  }

  static async getAvailabilityStats(matchmakerId: string): Promise<AvailabilityStats> {
    console.log('Calculating availability stats for matchmaker:', matchmakerId);
    try {
      const stats = await prisma.profile.groupBy({
        by: ['availabilityStatus'],
        where: {
          user: {
            OR: [
              { firstPartyInquiries: { some: { matchmakerId } } },
              { secondPartyInquiries: { some: { matchmakerId } } }
            ]
          }
        },
        _count: true
      });

      console.log('Raw stats:', stats);

      const result = {
        available: stats.find(s => s.availabilityStatus === AvailabilityStatus.AVAILABLE)?._count || 0,
        unavailable: stats.find(s => s.availabilityStatus === AvailabilityStatus.UNAVAILABLE)?._count || 0,
        dating: stats.find(s => s.availabilityStatus === AvailabilityStatus.DATING)?._count || 0,
        pending: stats.find(s => s.availabilityStatus === null)?._count || 0
      };

      console.log('Processed stats:', result);
      return result;

    } catch (error) {
      console.error('Error in getAvailabilityStats:', error);
      throw error;
    }
  }

  static async getAllInquiries(
    userId: string,
    { status = 'pending', orderBy = 'createdAt', limit }: GetInquiriesOptions = {}
  ) {
    try {
      // Build the where clause based on status
      const where: Prisma.AvailabilityInquiryWhereInput = {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId }
        ],
        ...(status === 'pending' && {
          expiresAt: { gt: new Date() },
          OR: [
            { firstPartyResponse: null },
            { secondPartyResponse: null }
          ]
        }),
        ...(status === 'completed' && {
          firstPartyResponse: { not: null },
          secondPartyResponse: { not: null }
        }),
        ...(status === 'expired' && {
          expiresAt: { lt: new Date() }
        })
      };

      const validOrderBy = orderBy || 'createdAt';

      const inquiries = await prisma.availabilityInquiry.findMany({
        where,
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  availabilityStatus: true,
                  availabilityNote: true,
                  availabilityUpdatedAt: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        },
        orderBy: {
          [validOrderBy]: 'desc'
        },
        ...(limit ? { take: limit } : {})
      });

      return inquiries;

    } catch (error) {
      console.error('Error in getAllInquiries:', error);
      throw error;
    }
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\services\questionnaireService.ts:
==================================================
// src/lib/services/questionnaireService.ts
import type { 
    QuestionnaireResponse,
    QuestionnaireVersion,
    QuestionnaireAutosave,
    TempQuestionnaireSession,
    QuestionnaireUpdatePayload,
    QuestionnaireApiResponse,
    QuestionnaireMetadata,
    QuestionnaireAnalysis
  } from '@/components/questionnaire/types/responses';
  
  class QuestionnaireService {
    private static readonly AUTOSAVE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours
    private static readonly TEMP_SESSION_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days
    private static readonly API_BASE = '/api/questionnaire';
  
    // Helper method for API calls
    private async fetchApi<T>(
      endpoint: string, 
      options: RequestInit = {}
    ): Promise<QuestionnaireApiResponse<T>> {
      try {
        const response = await fetch(`${QuestionnaireService.API_BASE}${endpoint}`, {
          ...options,
          headers: {
            'Content-Type': 'application/json',
            ...options.headers,
          },
        });
  
        const data = await response.json();
  
        if (!data.success) {
          throw new Error(data.error.message);
        }
  
        return data;
      } catch (error) {
        console.error(`API Error (${endpoint}):`, error);
        throw error;
      }
    }
  
    // Save or update permanent response
    async saveResponse(userId: string, data: QuestionnaireUpdatePayload): Promise<QuestionnaireResponse> {
      const response = await this.fetchApi<QuestionnaireResponse>('', {
        method: 'POST',
        body: JSON.stringify({
          userId,
          ...data,
          metadata: {
            ...data.metadata,
            lastSaveType: 'manual',
            lastActiveTime: new Date(),
          },
        }),
      });
  
      return response.data!;
    }
  
    // Save temporary session for non-authenticated users
    async saveTempSession(
      sessionToken: string, 
      data: QuestionnaireUpdatePayload
    ): Promise<TempQuestionnaireSession> {
      const response = await this.fetchApi<TempQuestionnaireSession>('/temp', {
        method: 'POST',
        body: JSON.stringify({
          sessionToken,
          ...data,
          expiresAt: new Date(Date.now() + QuestionnaireService.TEMP_SESSION_EXPIRY),
          metadata: {
            ...data.metadata,
            lastSaveType: 'temporary',
            lastActiveTime: new Date(),
          },
        }),
      });
  
      return response.data!;
    }
  
    // Auto-save functionality
    async autoSave(
      responseId: string, 
      data: QuestionnaireUpdatePayload
    ): Promise<QuestionnaireAutosave> {
      const response = await this.fetchApi<QuestionnaireAutosave>('/autosave', {
        method: 'POST',
        body: JSON.stringify({
          responseId,
          ...data,
          expiresAt: new Date(Date.now() + QuestionnaireService.AUTOSAVE_EXPIRY),
          metadata: {
            ...data.metadata,
            lastSaveType: 'auto',
            lastActiveTime: new Date(),
          },
        }),
      });
  
      return response.data!;
    }
  
    // Version control
    async createVersion(
      responseId: string, 
      data: QuestionnaireUpdatePayload, 
      reason?: string
    ): Promise<QuestionnaireVersion> {
      const response = await this.fetchApi<QuestionnaireVersion>('/version', {
        method: 'POST',
        body: JSON.stringify({
          responseId,
          ...data,
          reason,
          metadata: {
            ...data.metadata,
            lastSaveType: 'version',
            lastActiveTime: new Date(),
          },
        }),
      });
  
      return response.data!;
    }
  
    // Convert temporary session to permanent
    async convertTempToResponse(
      sessionToken: string, 
      userId: string
    ): Promise<QuestionnaireResponse> {
      const response = await this.fetchApi<QuestionnaireResponse>('/convert', {
        method: 'POST',
        body: JSON.stringify({ sessionToken, userId }),
      });
  
      return response.data!;
    }
  
    // Fetch existing response
    async getResponse(responseId: string): Promise<QuestionnaireResponse> {
      const response = await this.fetchApi<QuestionnaireResponse>(`?responseId=${responseId}`);
      return response.data!;
    }
  
    // Get temporary session
    async getTempSession(sessionToken: string): Promise<TempQuestionnaireSession> {
      const response = await this.fetchApi<TempQuestionnaireSession>(`/temp/${sessionToken}`);
      return response.data!;
    }
  
    // Clean up expired data
    async cleanupExpiredData(): Promise<void> {
      await this.fetchApi('/cleanup', { method: 'POST' });
    }
  
    // Generate analysis
    async generateAnalysis(responseId: string): Promise<QuestionnaireAnalysis> {
      const response = await this.fetchApi<QuestionnaireAnalysis>(`/analysis/${responseId}`, {
        method: 'POST',
      });
      return response.data!;
    }
  
    // Update metadata
    async updateMetadata(
      responseId: string, 
      metadata: Partial<QuestionnaireMetadata>
    ): Promise<QuestionnaireResponse> {
      const response = await this.fetchApi<QuestionnaireResponse>(`/metadata/${responseId}`, {
        method: 'PATCH',
        body: JSON.stringify({ metadata }),
      });
      return response.data!;
    }
  
    // Mark questionnaire as completed
    async markCompleted(responseId: string): Promise<QuestionnaireResponse> {
      const response = await this.fetchApi<QuestionnaireResponse>(`/complete/${responseId}`, {
        method: 'POST',
      });
      return response.data!;
    }
  
 
async getStatistics(responseId: string): Promise<QuestionnaireStatistics> {
    const response = await this.fetchApi<QuestionnaireStatistics>(`/statistics/${responseId}`);
    
    if (!response.data) {
      throw new Error('Failed to fetch statistics');
    }
    
    // המרת ה-lastActive לאובייקט Date
    return {
      ...response.data,
      lastActive: new Date(response.data.lastActive)
    };
   }
  }
  
  export const questionnaireService = new QuestionnaireService();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\services\suggestionService.ts:
==================================================
//C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\services\suggestionService.ts
import prisma from '@/lib/prisma';
import { 
  MatchSuggestionStatus, 
  Priority,
  ContactMethod,
  FirstDateFeedbackStatus,
  Prisma
} from '@prisma/client';
import type { CreateSuggestionData } from '@/app/types/suggestions';
import { emailService } from '@/lib/email/emailService';

// Extended type for update data
interface UpdateSuggestionData {
  id: string;
  status?: MatchSuggestionStatus;
  priority?: Priority;
  responseDeadline?: Date | string;
  decisionDeadline?: Date | string;
  notes?: {
    internal?: string;
    forFirstParty?: string;
    forSecondParty?: string;
  };
  matchingCriteria?: Array<{
    key: string;
    weight: number;
    isRequired: boolean;
    score?: number | null;
    notes?: string | null;
  }>;
  externalReferences?: Array<{
    type: string;
    name: string;
    contactInfo: string;
    relationship: string;
    notes?: string | null;
  }>;
  communications?: {
    firstParty?: {
      method: ContactMethod;
      value: string;
      content?: string;
      isUrgent?: boolean;
      requiresResponse?: boolean;
    };
    secondParty?: {
      method: ContactMethod;
      value: string;
      content?: string;
      isUrgent?: boolean;
      requiresResponse?: boolean;
    };
  };
}

// Type for profile data
interface ProfileData {
  contactPreference?: string | null;
}

// Type for party data
interface PartyData {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  profile: ProfileData | null;
}

export class SuggestionService {
  static async createSuggestion(data: CreateSuggestionData) {
    // Delete everything inside the function and replace with:
    const suggestion = await prisma.$transaction(async (tx) => {
      const existingActiveSuggestion = await tx.matchSuggestion.findFirst({
        where: {
          OR: [
            { firstPartyId: data.firstPartyId },
            { secondPartyId: data.secondPartyId }
          ],
          AND: {
            status: {
              in: [
                'PENDING_FIRST_PARTY',
                'FIRST_PARTY_APPROVED',
                'PENDING_SECOND_PARTY'
              ] as MatchSuggestionStatus[]
            }
          }
        }
      });
  
      if (existingActiveSuggestion) {
        throw new Error('קיימת הצעה פעילה לאחד הצדדים');
      }
  
      const responseDeadline = new Date();
      responseDeadline.setHours(responseDeadline.getHours() + (data.deadlineInHours || 48));
  
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: data.matchmakerId,
          firstPartyId: data.firstPartyId,
          secondPartyId: data.secondPartyId,
          status: data.status || MatchSuggestionStatus.DRAFT,
          priority: data.priority || Priority.MEDIUM,
          internalNotes: data.notes?.internal || '',
          firstPartyNotes: data.notes?.forFirstParty || '',
          secondPartyNotes: data.notes?.forSecondParty || '',
          matchingReason: data.notes?.matchingReason || null,
          requiresRabbinicApproval: data.requiresRabbinicApproval || false,
          responseDeadline,
          lastActivity: new Date(),
          statusHistory: {
            create: {
              status: data.status || MatchSuggestionStatus.DRAFT,
              reason: 'Initial creation'
            }
          }
        },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  contactPreference: true
                }
              }
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  contactPreference: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              role: true
            }
          }
        }
      });
  
      // אם יש communications, יצירת רשומה בטבלת Communications
      if (data.communications?.firstParty) {
        await tx.communication.create({
          data: {
            suggestionId: newSuggestion.id,
            type: 'MESSAGE',
            content: data.communications.firstParty.content || '',
            partyId: data.firstPartyId,  
            metadata: {
              method: data.communications.firstParty.method,
              value: data.communications.firstParty.value,
              isUrgent: data.communications.firstParty.isUrgent || false
            }
          }
        });
      }
  
      if (newSuggestion.status === MatchSuggestionStatus.PENDING_FIRST_PARTY 
          && newSuggestion.firstParty.email) {
        try {
          await emailService.sendSuggestionNotification({
            email: newSuggestion.firstParty.email,
            recipientName: `${newSuggestion.firstParty.firstName} ${newSuggestion.firstParty.lastName}`,
            matchmakerName: `${newSuggestion.matchmaker.firstName} ${newSuggestion.matchmaker.lastName}`,
            suggestionDetails: {
              additionalInfo: data.notes?.forFirstParty
            }
          });
  
          await tx.matchSuggestion.update({
            where: { id: newSuggestion.id },
            data: { 
              firstPartySent: new Date(),
              lastActivity: new Date()
            }
          });
        } catch (emailError) {
          console.error('Failed to send notification email:', emailError);
        }
      }
  
      return newSuggestion;
    });
  
    return suggestion;
  }

  static async approveAndShareContacts(suggestionId: string, matchmakerId: string) {
    const suggestion = await prisma.$transaction(async (tx) => {
      const suggestion = await tx.matchSuggestion.findUnique({
        where: { id: suggestionId },
        include: {
          firstParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  contactPreference: true
                }
              }
            }
          },
          secondParty: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              profile: {
                select: {
                  contactPreference: true
                }
              }
            }
          },
          matchmaker: {
            select: {
              id: true,
              firstName: true,
              lastName: true
            }
          }
        }
      });

      if (!suggestion) {
        throw new Error('Suggestion not found');
      }

      if (suggestion.matchmakerId !== matchmakerId) {
        throw new Error('Unauthorized - only the matchmaker can approve and share contacts');
      }

      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
          lastActivity: new Date(),
          lastStatusChange: new Date(),
          previousStatus: suggestion.status,
          statusHistory: {
            create: {
              status: MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
              reason: 'Matchmaker approved and shared contact details'
            }
          }
        }
      });

      // Send contact details emails with null checks
      if (suggestion.firstParty.email && suggestion.secondParty.profile?.contactPreference) {
        await emailService.sendContactDetailsEmail({
          email: suggestion.firstParty.email,
          recipientName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
          otherPartyName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
          otherPartyContact: {
            whatsapp: suggestion.secondParty.profile.contactPreference
          },
          matchmakerName: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
        });
      }

      if (suggestion.secondParty.email && suggestion.firstParty.profile?.contactPreference) {
        await emailService.sendContactDetailsEmail({
          email: suggestion.secondParty.email,
          recipientName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
          otherPartyName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
          otherPartyContact: {
            whatsapp: suggestion.firstParty.profile.contactPreference
          },
          matchmakerName: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
        });
      }

      return updatedSuggestion;
    });

    return suggestion;
  }

  static async updateSuggestionStatus(suggestionId: string, newStatus: MatchSuggestionStatus, note?: string) {
    return await prisma.$transaction(async (tx) => {
      const suggestion = await tx.matchSuggestion.findUnique({
        where: { id: suggestionId },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true
            }
          }
        }
      });

      if (!suggestion) {
        throw new Error("Suggestion not found");
      }

      let targetStatus = newStatus;

      if (newStatus === "FIRST_PARTY_APPROVED") {
        targetStatus = "PENDING_SECOND_PARTY";
        
        // Send email to second party
        if (suggestion.secondParty.email) {
          await emailService.sendSuggestionNotification({
            email: suggestion.secondParty.email,
            recipientName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
            matchmakerName: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`,
            suggestionDetails: { additionalInfo: note }
          });
        }
      }
      
      else if (newStatus === "SECOND_PARTY_APPROVED") {
        targetStatus = "CONTACT_DETAILS_SHARED";
        await this.approveAndShareContacts(suggestionId, suggestion.matchmakerId);
      }

      return await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: targetStatus,
          lastActivity: new Date(),
          lastStatusChange: new Date(),
          statusHistory: {
            create: {
              status: targetStatus,
              reason: `Status updated to ${targetStatus}`,
              notes: note
            }
          }
        }
      });
    });
}


  static async updateFirstDateFeedback(
    suggestionId: string,
    partyId: string,
    feedback: {
      status: FirstDateFeedbackStatus;
      notes?: string;
    }
  ) {
    const suggestion = await prisma.$transaction(async (tx) => {
      const suggestion = await tx.matchSuggestion.findUnique({
        where: { id: suggestionId },
        include: {
          meetings: {
            orderBy: { scheduledDate: 'desc' },
            take: 1
          }
        }
      });

      if (!suggestion) {
        throw new Error('Suggestion not found');
      }

      const isFirstParty = suggestion.firstPartyId === partyId;
      const isSecondParty = suggestion.secondPartyId === partyId;

      if (!isFirstParty && !isSecondParty) {
        throw new Error('Unauthorized to provide feedback');
      }

      const lastMeeting = suggestion.meetings[0];
      if (!lastMeeting) {
        throw new Error('No meeting found for this suggestion');
      }

      // עדכון המשוב לפגישה
      await tx.suggestionMeeting.update({
        where: { id: lastMeeting.id },
        data: {
          ...(isFirstParty
            ? { firstPartyFeedbackStatus: feedback.status }
            : { secondPartyFeedbackStatus: feedback.status }),
          feedback: {
            ...(lastMeeting.feedback as any || {}),
            [isFirstParty ? 'firstParty' : 'secondParty']: {
              status: feedback.status,
              notes: feedback.notes,
              submittedAt: new Date()
            }
          }
        }
      });

      // עדכון סטטוס ההצעה בהתאם למשוב
      let newStatus: MatchSuggestionStatus;
      switch (feedback.status) {
        case FirstDateFeedbackStatus.SUCCESS_CONTINUE:
          newStatus = MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE;
          break;
        case FirstDateFeedbackStatus.NEED_TIME_TO_THINK:
          newStatus = MatchSuggestionStatus.THINKING_AFTER_DATE;
          break;
        case FirstDateFeedbackStatus.NOT_INTERESTED:
          newStatus = MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE;
          break;
      }

      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: newStatus,
          lastActivity: new Date(),
          lastStatusChange: new Date(),
          previousStatus: suggestion.status,
          statusHistory: {
            create: {
              status: newStatus,
              reason: `First date feedback received from ${isFirstParty ? 'first' : 'second'} party`
            }
          }
        },
        include: {
          firstParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true
            }
          },
          secondParty: {
            select: {
              firstName: true,
              lastName: true,
              email: true,
              profile: true
            }
          },
          matchmaker: {
            select: {
              firstName: true,
              lastName: true,
              role: true
            }
          },
          meetings: true,
          statusHistory: true
        }
      });

      return updatedSuggestion;
    });

    return suggestion;
  }

  static async getSuggestion(id: string) {
    return await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
            profile: true
          }
        },
        secondParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
            profile: true
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
            role: true,
            profile: true  // במקום matchmakerProfile
          }
        },
        communications: {
          where: {
            suggestionId: id  // במקום partyId
          }
        },
        statusHistory: true,
        meetings: true
      }
    });
  }

  static async getMatchmakerSuggestions(matchmakerId: string) {
    return await prisma.matchSuggestion.findMany({
      where: {
        matchmakerId,
      },
      include: {
        firstParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
            profile: true
          }
        },
        secondParty: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
            profile: true
          }
        },
        communications: true,
        statusHistory: true,
        matchingCriteria: true,
        externalReferences: true
      },
      orderBy: {
        lastActivity: 'desc'
      }
    });
  }

static async getUserSuggestions(userId: string) {
  return await prisma.matchSuggestion.findMany({
    where: {
      OR: [
        { firstPartyId: userId },
        { secondPartyId: userId }
      ]
    },
    include: {
      firstParty: {
        select: {
          firstName: true,
          lastName: true,
          email: true,
          profile: {
            select: {
              height: true,
              occupation: true,
              education: true,
              religiousLevel: true,
              city: true,
              maritalStatus: true,
              origin: true,
          
              // הוסף עוד שדות שתרצה להציג
            }
          }
        }
      },
      secondParty: {
        select: {
          firstName: true,
          lastName: true,
          email: true,
          profile: {
            select: {
              height: true,
              occupation: true,
              education: true,
              religiousLevel: true,
              city: true,
              maritalStatus: true,
              origin: true,
              // הוסף עוד שדות שתרצה להציג
            }
          }
        }
      },
      matchmaker: {
        select: {
          firstName: true,
          lastName: true,
          role: true
        }
      },
      communications: {
        where: {
          partyId: userId
        }
      },
      matchingCriteria: true,
      externalReferences: true,
    }
  });
}
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\lib\services\verificationService.ts:
==================================================
import prisma from '@/lib/prisma';
import { Verification, VerificationType, VerificationStatus, UserStatus } from '@prisma/client';
import crypto from 'crypto';

export class VerificationService {
  /**
   * מאמת טוקן ומעדכן את סטטוס המשתמש בהתאם
   */
  static async verifyToken(token: string, type: VerificationType): Promise<Verification> {
    // חיפוש רשומת אימות פעילה
    const verification = await prisma.verification.findFirst({
      where: { 
        token, 
        type,
        status: VerificationStatus.PENDING
      },
      include: {
        user: true
      }
    });

    // אם לא נמצאה רשומה פעילה, בדיקה אם הטוקן כבר נוצל
    if (!verification) {
      const usedToken = await prisma.verification.findFirst({
        where: { 
          token, 
          type,
          status: VerificationStatus.COMPLETED 
        }
      });
      
      if (usedToken) {
        throw new Error('הטוקן כבר נוצל. אנא התחבר למערכת.');
      }
      
      throw new Error('טוקן אימות לא תקין');
    }

    // בדיקת תוקף הטוקן
    if (verification.expiresAt < new Date()) {
      throw new Error('תוקף הטוקן פג');
    }

    // עדכון סטטוס האימות וסטטוס המשתמש בטרנזקציה אחת
    try {
      const result = await prisma.$transaction(async (tx) => {
        // עדכון רשומת האימות
        const updatedVerification = await tx.verification.update({
          where: { 
            id: verification.id 
          },
          data: {
            status: VerificationStatus.COMPLETED,
            completedAt: new Date(),
            attempts: {
              increment: 1
            }
          }
        });

        // עדכון סטטוס המשתמש
        await tx.user.update({
          where: { 
            id: verification.userId 
          },
          data: {
            isVerified: true,
            status: UserStatus.ACTIVE
          }
        });

        return updatedVerification;
      });

      return result;

    } catch (error) {
      console.error('Error during verification:', error);
      throw new Error('אירעה שגיאה בתהליך האימות');
    }
  }

  /**
   * מייצר טוקן אימות חדש
   */
  static async createVerificationToken(
    userId: string,
    type: VerificationType,
    expiresInHours: number = 24
  ): Promise<Verification> {
    try {
      // ביטול טוקנים קודמים שעדיין פעילים
      await prisma.verification.updateMany({
        where: {
          userId,
          type,
          status: VerificationStatus.PENDING
        },
        data: {
          status: VerificationStatus.EXPIRED  // שינוי מ-CANCELLED ל-EXPIRED
        }
      });

      // יצירת טוקן חדש
      return await prisma.verification.create({
        data: {
          userId,
          type,
          token: this.generateToken(),
          expiresAt: new Date(Date.now() + expiresInHours * 60 * 60 * 1000),
          status: VerificationStatus.PENDING,
          attempts: 0
        }
      });
    } catch (error) {
      console.error('Error creating verification token:', error);
      throw new Error('אירעה שגיאה ביצירת טוקן אימות');
    }
  }

  /**
   * מייצר טוקן אקראי
   */
  private static generateToken(): string {
    return crypto.randomUUID();
  }

  /**
   * בודק האם למשתמש יש אימות פעיל
   */
  static async hasActiveVerification(userId: string, type: VerificationType): Promise<boolean> {
    const activeVerification = await prisma.verification.findFirst({
      where: {
        userId,
        type,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date()
        }
      }
    });

    return !!activeVerification;
  }
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\services\storageService.ts:
==================================================
// src/services/storageService.ts

import { 
    QuestionnaireAnswer, 
    WorldId,
    UserTrack,
  } from '../components/questionnaire/types/types';
  
  // Interface definitions
  interface StorageProgress {
    answers: QuestionnaireAnswer[];
    currentStep: string;
    currentWorld: WorldId;
    userTrack: UserTrack;
    worldsCompleted: WorldId[];
    startedAt: string;
  }
  
  interface CompressedAnswer {
    q: string;        // questionId
    w?: WorldId;      // worldId (optional - only if different from previous)
    v: any;          // value
    t: number;       // timestamp delta in seconds
  }
  
  interface CompressedProgress {
    a: CompressedAnswer[];  // answers
    w: WorldId[];          // completed worlds
    s: string;            // current step
    cw: WorldId;          // current world
    ut: UserTrack;        // user track
    st: string;           // start time
  }
  
  interface StorageMetadata {
    chunks: number;
    startTime: string;
    lastSaved: string;
  }
  
  // Constants
  const STORAGE_KEYS = {
    META: 'questionnaire_meta',
    MINIMAL: 'questionnaire_minimal',
    CHUNK_PREFIX: 'questionnaire_chunk_'
  };
  
  const CHUNK_SIZE = 50;
  const SAVE_DELAY = 2000;
  
  // Main service object
  export const storageService = {
    /**
     * Compresses an array of answers
     */
    compressAnswers(answers: QuestionnaireAnswer[], startTime: string): CompressedAnswer[] {
      let lastWorld: WorldId | undefined;
      const baseTime = new Date(startTime).getTime();
      
      return answers.map(answer => {
        const compressed: CompressedAnswer = {
          q: answer.questionId,
          v: answer.value,
          t: Math.floor((new Date(answer.answeredAt).getTime() - baseTime) / 1000)
        };
  
        // Only store worldId if it changed
        if (answer.worldId !== lastWorld) {
          compressed.w = answer.worldId;
          lastWorld = answer.worldId;
        }
  
        return compressed;
      });
    },
  
    /**
     * Decompresses an array of compressed answers
     */
    decompressAnswers(compressed: CompressedAnswer[], startTime: string): QuestionnaireAnswer[] {
      let lastWorld: WorldId = 'VALUES'; // default world
      const baseTime = new Date(startTime).getTime();
  
      return compressed.map(ans => ({
        questionId: ans.q,
        worldId: (ans.w || lastWorld) as WorldId,
        value: ans.v,
        answeredAt: new Date(baseTime + (ans.t * 1000)).toISOString()
      }));
    },
  
    /**
     * Saves the complete questionnaire progress
     */
    async saveProgress(progress: StorageProgress): Promise<void> {
      try {
        // Prepare metadata
        const metadata: StorageMetadata = {
          startTime: progress.startedAt,
          lastSaved: new Date().toISOString(),
          chunks: 0
        };
  
        // Compress answers
        const compressedAnswers = this.compressAnswers(progress.answers, metadata.startTime);
        
        // Split into chunks
        const chunks: CompressedAnswer[][] = [];
        for (let i = 0; i < compressedAnswers.length; i += CHUNK_SIZE) {
          chunks.push(compressedAnswers.slice(i, i + CHUNK_SIZE));
        }
  
        metadata.chunks = chunks.length;
  
        // Save metadata
        localStorage.setItem(STORAGE_KEYS.META, JSON.stringify({
          metadata,
          currentStep: progress.currentStep,
          currentWorld: progress.currentWorld,
          userTrack: progress.userTrack,
          worldsCompleted: progress.worldsCompleted
        }));
  
        // Save each chunk separately
        chunks.forEach((chunk, index) => {
          localStorage.setItem(
            `${STORAGE_KEYS.CHUNK_PREFIX}${index}`, 
            JSON.stringify(chunk)
          );
        });
  
      } catch (error) {
        console.error('Error saving progress:', error);
        // Fallback to minimal save
        this.saveMinimal(progress);
      }
    },
  
    /**
     * Saves minimal progress information (fallback)
     */
    saveMinimal(progress: Partial<StorageProgress>): void {
      try {
        localStorage.setItem(STORAGE_KEYS.MINIMAL, JSON.stringify({
          currentStep: progress.currentStep,
          currentWorld: progress.currentWorld,
          worldsCompleted: progress.worldsCompleted
        }));
      } catch (error) {
        console.error('Failed to save minimal progress:', error);
      }
    },
  
    /**
     * Loads complete questionnaire progress
     */
    loadProgress(): StorageProgress | null {
      try {
        // Try loading full progress first
        const metaString = localStorage.getItem(STORAGE_KEYS.META);
        if (!metaString) {
          return this.loadMinimal();
        }
  
        const meta = JSON.parse(metaString);
        const allAnswers: CompressedAnswer[] = [];
  
        // Load all chunks
        for (let i = 0; i < meta.metadata.chunks; i++) {
          const chunkString = localStorage.getItem(`${STORAGE_KEYS.CHUNK_PREFIX}${i}`);
          if (chunkString) {
            allAnswers.push(...JSON.parse(chunkString));
          }
        }
  
        return {
          answers: this.decompressAnswers(allAnswers, meta.metadata.startTime),
          currentStep: meta.currentStep,
          currentWorld: meta.currentWorld as WorldId,
          userTrack: meta.userTrack as UserTrack,
          worldsCompleted: meta.worldsCompleted as WorldId[],
          startedAt: meta.metadata.startTime
        };
  
      } catch (error) {
        console.error('Error loading progress:', error);
        return this.loadMinimal();
      }
    },
  
    /**
     * Loads minimal progress information
     */
    loadMinimal(): StorageProgress | null {
      try {
        const minimal = localStorage.getItem(STORAGE_KEYS.MINIMAL);
        if (!minimal) return null;
  
        const parsed = JSON.parse(minimal);
        
        // Return full object with default values
        return {
          currentStep: parsed.currentStep,
          currentWorld: parsed.currentWorld as WorldId,
          worldsCompleted: parsed.worldsCompleted as WorldId[],
          // Default values for missing fields
          answers: [],
          userTrack: 'SECULAR' as UserTrack,
          startedAt: new Date().toISOString()
        };
      } catch (error) {
        console.error('Error loading minimal progress:', error);
        return null;
      }
    },
  
    /**
     * Clears all stored progress data
     */
    clearProgress(): void {
      try {
        const keys = [];
        // Find all questionnaire-related keys
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key?.startsWith('questionnaire_')) {
            keys.push(key);
          }
        }
        // Remove all found keys
        keys.forEach(key => localStorage.removeItem(key));
      } catch (error) {
        console.error('Error clearing progress:', error);
      }
    }
  };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\services\suggestions.ts:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\availability.ts:
==================================================
import { AvailabilityStatus } from "@prisma/client";

export interface AvailabilityInquiryResponse {
  isAvailable: boolean;
  note?: string;
}

export interface AvailabilityStats {
  available: number;
  unavailable: number;
  dating: number;
  pending: number;
}

export interface AvailabilityNotification {
  id: string;
  type: 'INQUIRY_RESPONSE' | 'INQUIRY_RECEIVED';
  status: 'UNREAD' | 'READ';
  createdAt: Date;
}

export interface AvailabilityFilter {
  status: AvailabilityStatus | "all";
  includeNoResponse: boolean;
  timeframe?: 'today' | 'week' | 'month' | 'all';
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\cloudinary.d.ts:
==================================================
interface CloudinaryResult {
    secure_url: string;
    public_id: string;
  }
  
  declare module 'cloudinary' {
    export const v2: {
      config: (config: {
        cloud_name: string;
        api_key: string;
        api_secret: string;
      }) => void;
      uploader: {
        upload_stream: (
          options: {
            folder?: string;
            resource_type?: string;
          },
          callback: (error: Error | null, result: CloudinaryResult | null) => void
        ) => any;
        destroy: (publicId: string) => Promise<any>;
      };
    };
  }

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\meetings.ts:
==================================================
import { SuggestionMeeting, MeetingStatus, MeetingType, Prisma } from '@prisma/client';

// טיפוס בסיסי למשוב שתואם את המבנה ב-Prisma
export type MeetingFeedback = Prisma.JsonObject & {
  content: string;
  rating?: number;
  continueInterest: boolean;
  nextMeetingScheduled?: boolean;
  privateNotes?: string;
};

// הרחבת טיפוס הפגישה
export interface ExtendedMeeting extends SuggestionMeeting {
  firstPartyFeedback: MeetingFeedback | null;
  secondPartyFeedback: MeetingFeedback | null;
}



==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\messages.ts:
==================================================
import { AvailabilityInquiry, User, Profile } from '@prisma/client';

export interface ExtendedInquiry extends AvailabilityInquiry {
    matchmaker: {
      firstName: string;
      lastName: string;
    };
    firstParty: {
      firstName: string;
      lastName: string;
      email: string;
      profile: Profile | null;
    };
  }

export interface NotificationCount {
  availabilityRequests: number;
  messages: number;
  total: number;
}

export interface MessageFilters {
  status?: 'pending' | 'completed' | 'expired';
  timeframe?: 'today' | 'week' | 'month' | 'all';
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\next-auth.d.ts:
==================================================
  import type {
    Profile as PrismaProfile,
    UserImage as PrismaUserImage,
    AvailabilityStatus,
    Gender,
    UserRole,
    UserStatus,
    QuestionnaireResponse as PrismaQuestionnaireResponse
  } from '@prisma/client';
  import { DefaultUser } from 'next-auth';

  export interface User extends DefaultUser {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    name: string | null;
    image: string | null;
    role: UserRole;
    status: UserStatus;
    isVerified: boolean;
    lastLogin: Date | null;
    createdAt: Date;
    updatedAt: Date;
    profile: UserProfile | null;
    images: UserImage[];
    questionnaireResponses: QuestionnaireResponse[];
  }

  export interface Verification {
    metadata?: {
      hashedNewPassword?: string;
      [key: string]: any;
    }
  }

  export interface JWT {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    name: string | null;
    picture: string | null;
    role: UserRole;
    status: UserStatus;
    isVerified: boolean;
    lastLogin: Date | null;
    createdAt: Date;
    updatedAt: Date;
    profile: UserProfile | null;
    images: UserImage[];
    questionnaireResponses: QuestionnaireResponse[];
  }

  export interface UserProfile extends PrismaProfile {
    id: string;
    userId: string;
    gender: Gender;
    birthDate: Date;
    nativeLanguage?: string | null;
    additionalLanguages: string[];
    height: number | null;
    maritalStatus?: string;
    occupation?: string;
    education?: string;
    address?: string;
    city?: string;
    origin?: string;
    religiousLevel?: string;
    about?: string;
    hobbies?: string;
    parentStatus?: string;
    siblings?: number;
    position?: number;
    preferredAgeMin?: number;
    preferredAgeMax?: number;
    preferredHeightMin?: number;
    preferredHeightMax?: number;
    preferredReligiousLevels: string[];
    preferredLocations: string[];
    preferredEducation: string[];
    preferredOccupations: string[];
    contactPreference?: string;
    referenceName1?: string;
    referencePhone1?: string;
    referenceName2?: string;
    referencePhone2?: string;
    isProfileVisible: boolean;
    preferredMatchmakerGender?: Gender;
    matchingNotes?: string;
    verifiedBy?: string;
    availabilityStatus: AvailabilityStatus;
    availabilityNote?: string;
    availabilityUpdatedAt?: Date;
    createdAt: Date;
    updatedAt: Date;
    lastActive?: Date;
    user:{ 
      email: string;
      firstName: string;
      lastName: string;
    }
 
  
  }

  export interface UserImage extends PrismaUserImage {
    id: string;
    url: string;
    isMain: boolean;
    cloudinaryPublicId: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
  }

  export interface FormattedAnswer {
    questionId: string;
    question: string;
    value: any;
    displayText: string;
    answeredAt: string;
    category?: string;
    isVisible: boolean;
  }

  export interface QuestionnaireResponse extends PrismaQuestionnaireResponse {
    id: string;
    userId: string;
    valuesAnswers: any;
    personalityAnswers: any;
    relationshipAnswers: any;
    partnerAnswers: any;
    religionAnswers: any;
    formattedAnswers?: {
      values: FormattedAnswer[];
      personality: FormattedAnswer[];
      relationship: FormattedAnswer[];
      partner: FormattedAnswer[];
      religion: FormattedAnswer[];
    };
    valuesCompleted: boolean;
    personalityCompleted: boolean;
    relationshipCompleted: boolean;
    partnerCompleted: boolean;
    religionCompleted: boolean;
    worldsCompleted: string[];
    completed: boolean;
    startedAt: string | Date;
    completedAt: Date | null;
    lastSaved: string | Date;
    createdAt: string | Date;
    updatedAt: string | Date;
  }

  export interface Session {
    user: User;
  }

  export { Gender, UserRole, UserStatus, AvailabilityStatus };


  declare module 'next-auth' {
    interface Session extends DefaultSession {
      user: {
        id: string;
        email: string;
        firstName: string;
        lastName: string;
        name: string | null;
        image: string | null;
        role: UserRole;
        status: UserStatus;
        isVerified: boolean;
        lastLogin: Date | null;
        createdAt: Date;
        updatedAt: Date;
        profile: PrismaProfile | null;
        images: PrismaUserImage[];
        questionnaireResponses: PrismaQuestionnaireResponse[];
      }
    }

    interface User extends DefaultUser {
      id: string;
      firstName: string;
      lastName: string;
      role: UserRole;
      status: UserStatus;
      isVerified: boolean;
      lastLogin: Date | null;
      createdAt: Date;
      updatedAt: Date;
      profile: PrismaProfile | null;
      images: PrismaUserImage[];
      questionnaireResponses: PrismaQuestionnaireResponse[];
    }
  }

  declare module 'next-auth/jwt' {
    interface JWT {
      id: string;
      email?: string | null;
      firstName: string;
      lastName: string;
      name: string | null;
      picture: string | null;
      role: UserRole;
      status: UserStatus;
      isVerified: boolean;
      lastLogin: Date | null;
      createdAt: Date;
      updatedAt: Date;
      profile: PrismaProfile | null;
      images: PrismaUserImage[];
      questionnaireResponses: PrismaQuestionnaireResponse[];
      sub?: string;
    }
  }

  export type ContactPreference = "direct" | "matchmaker" | "both";

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\profile-extended.ts:
==================================================
// types/profile-extended.ts

import { Gender, AvailabilityStatus } from '@prisma/client';

import { UserProfile } from '@/types/next-auth';


export interface PersonalityTraits {
  temperament: 'מופנם' | 'מעורב' | 'חברותי';
  decisionMaking: 'ספונטני' | 'מתוכנן' | 'משולב';
  communicationStyle: 'ישיר' | 'עקיף' | 'דיפלומטי';
  stressManagement: 'רגוע' | 'לחוץ' | 'משתנה';
}

export interface SpiritualProfile {
  prayerStyle: 'ספרד' | 'אשכנז' | 'תימני' | 'אחר';
  communityType: string;
  secularStudiesAttitude: 'חיובי' | 'שלילי' | 'מסויג';
  modestyLevel: 'מחמיר' | 'מקובל' | 'מודרני';
  childrenEducationApproach: string;
}

export interface FamilyBackground {
  parentsSpiritualLevel: string;
  parentsOccupations: {
    father: string;
    mother: string;
  };
  financialSupport: boolean;
  familyValues: string[];
  familyDynamics: string;
}
export interface ExtendedProfileData {
    personalityTraits?: PersonalityTraits;
    spiritualProfile?: SpiritualProfile;
    familyBackground?: FamilyBackground;
    lifestylePreferences?: LifestylePreferences;
    healthProfile?: HealthProfile;
    personalValues?: PersonalValues;
    specialSkills?: string[];
    futureGoals?: string[];
    expectedSupport?: {
      financial: boolean;
      housing: boolean;
      other: string;
    };
  }
  
export interface LifestylePreferences {
  careerAspiration: string;
  futureStudyPlans: string;
  spouseWorkAttitude: string;
  relationshipExpectations: string; // הוספת שדה חסר
  livingPreferences: {
    location: string;
    proximity: 'קרוב למשפחה' | 'קרוב לקהילה' | 'גמיש';
  };
  financialPriorities: string[];
}

export interface HealthProfile {
  generalHealth: string;
  dietaryRestrictions: string[];
  physicalActivity: string;
  allergies: string[];
  medicalConsiderations: string;
}

export interface PersonalValues {
  parentalRespect: 1 | 2 | 3 | 4 | 5;
  careerPriority: 1 | 2 | 3 | 4 | 5;
  financialManagement: string;
  militaryServiceStance: string;
  volunteeringPreferences: string; // הוספת שדה חסר
  volunteeringInterests: string[];
  communityInvolvement: string;
}

export interface ExtendedUserProfile extends UserProfile {
  personalityTraits: PersonalityTraits;
  spiritualProfile: SpiritualProfile;
  familyBackground: FamilyBackground;
  lifestylePreferences: LifestylePreferences;
  healthProfile: HealthProfile;
  personalValues: PersonalValues;
  specialSkills: string[];
  futureGoals: string[];
  expectedSupport: {
    financial: boolean;
    housing: boolean;
    other: string;
  };
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\profile.ts:
==================================================
// src/types/profile.ts
import { AvailabilityStatus } from "@prisma/client";

export interface UpdateAvailabilityRequest {
  availabilityStatus: AvailabilityStatus;
  availabilityNote?: string | null;
}

export interface ApiResponse<T = any> {
  success: boolean;
  profile?: T;
  error?: string;
}

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\types\suggestions.ts:
==================================================
import { 
  MatchSuggestionStatus, 
  Priority, 
  MeetingStatus,
  UserRole,
  Gender,
  AvailabilityStatus,
  Profile as PrismaProfile,
  User,
  Meeting,
} from '@prisma/client';

import type {
  UserProfile,
  UserImage,
  QuestionnaireResponse,
  FormattedAnswer,
} from "@/types/next-auth";



export interface SuggestionParty extends User {
  profile: UserProfile;
  images: UserImage[];
}

// Rest of the interfaces remain the same
export interface CreateSuggestionData {
  matchmakerId: string;
  firstPartyId: string;
  secondPartyId: string;
  status?: MatchSuggestionStatus;
  priority?: Priority;
  decisionDeadline: Date;
  notes?: {
    internal?: string;
    forFirstParty?: string;
    forSecondParty?: string;
    matchingReason?: string;
    followUpNotes?: string;
  };
}

export interface SuggestionMeeting {
  id: string;
  suggestionId: string;
  scheduledDate: Date;
  location?: string;
  status: MeetingStatus;
  notes?: string;
  feedback?: DateFeedback[];
  createdAt: Date;
  updatedAt: Date;
}

export interface SuggestionStatusHistory {
  id: string;
  suggestionId: string;
  status: MatchSuggestionStatus;
  reason?: string;
  notes?: string;
  createdAt: Date;
}

export interface DateFeedback {
  id: string;
  suggestionId: string;
  partyId: string;
  meetingId: string;
  meetingNumber: number;
  feedback: string;
  status: string;
  nextSteps?: string;
  createdAt: Date;
}

export interface Suggestion {
  id: string;
  matchmakerId: string;
  firstPartyId: string;
  secondPartyId: string;
  status: MatchSuggestionStatus;
  priority: Priority;
  category: 'ACTIVE' | 'PENDING' | 'HISTORY';
  internalNotes?: string | null;
  firstPartyNotes?: string | null;
  secondPartyNotes?: string | null;
  matchingReason?: string | null;
  followUpNotes?: string | null;
  
  responseDeadline?: Date | null;
  decisionDeadline?: Date | null;
  lastStatusChange?: Date | null;
  previousStatus?: MatchSuggestionStatus | null;
  
  lastActivity: Date;
  firstPartySent?: Date | null;
  firstPartyResponded?: Date | null;
  secondPartySent?: Date | null;
  secondPartyResponded?: Date | null;
  firstMeetingScheduled?: Date | null;
  closedAt?: Date | null;
  createdAt: Date;
  updatedAt: Date;

  matchmaker?: User;
  firstParty: SuggestionParty;
  secondParty: SuggestionParty;
  meetings?: Meeting[];
  statusHistory: SuggestionStatusHistory[];
  feedback?: DateFeedback[];
  reviewedBy?: User[];
  approvedBy?: User[];
}

export interface UpdateSuggestionStatusData {
  status: MatchSuggestionStatus;
  reason?: string;
  notes?: string;
}

export interface UpdateSuggestionData {
  id: string;
  status?: MatchSuggestionStatus;
  priority?: Priority;
  responseDeadline?: Date;
  decisionDeadline?: Date;
  notes?: {
    internal?: string;
    forFirstParty?: string;
    forSecondParty?: string;
    matchingReason?: string;
    followUpNotes?: string;
  };
}

export interface SuggestionFilters {
  status?: MatchSuggestionStatus[];
  priority?: Priority[];
  dateRange?: {
    start: Date;
    end: Date;
  };
  matchmakerId?: string;
  partyId?: string;
  requiresAction?: boolean;
  hasDeadlinePassed?: boolean;
  searchTerm?: string;
}

export interface SuggestionResponse {
  success: boolean;
  data?: Suggestion;
  error?: string;
}

export interface SuggestionsListResponse {
  success: boolean;
  data?: {
    suggestions: Suggestion[];
    total: number;
    page: number;
    pageSize: number;
  };
  error?: string;
}

export interface SuggestionStats {
  total: number;
  activeCount: number;
  pendingCount: number;
  successCount: number;
  byStatus: Record<MatchSuggestionStatus, number>;
  byPriority: Record<Priority, number>;
  averageResponseTime: number;
  successRate: number;
}

export default {
  MatchSuggestionStatus,
  Priority,
  MeetingStatus
};

export const getSuggestionCategory = (status: MatchSuggestionStatus) => {
  switch (status) {
    case 'DRAFT':
    case 'AWAITING_MATCHMAKER_APPROVAL':
    case 'PENDING_FIRST_PARTY':
    case 'PENDING_SECOND_PARTY':
      return 'PENDING';
    
    case 'FIRST_PARTY_DECLINED':
    case 'SECOND_PARTY_DECLINED':
    case 'MATCH_DECLINED':
    case 'ENDED_AFTER_FIRST_DATE':
    case 'ENGAGED':
    case 'MARRIED':
    case 'EXPIRED':
    case 'CLOSED':
    case 'CANCELLED':
      return 'HISTORY';
    
    default:
      return 'ACTIVE';
  }
};

