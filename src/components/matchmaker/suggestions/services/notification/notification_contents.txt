################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification
# Generated on: 2025-08-28 17:09:36
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification\NotificationService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/NotificationService.ts

import { MatchSuggestionStatus } from '@prisma/client';
import { SuggestionWithParties } from '../suggestions/StatusTransitionService';

export type RecipientInfo = {
  email: string;
  phone?: string; // Phone number with international prefix, e.g.: +972501234567
  name: string;
};

export type NotificationContent = {
  subject: string;
  body: string;
  htmlBody?: string; // HTML version for email
};

export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
  channels: NotificationChannel[];
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
  priority?: 'high' | 'normal' | 'low';
  attachments?: Array<{
    filename: string;
    content: Buffer | string;
    contentType: string;
  }>;
  customMessage?: string;
  metadata?: Record<string, unknown>;
};

export interface NotificationAdapter {
  canSendTo(recipient: RecipientInfo): boolean;
  send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean>;
  getChannelType(): NotificationChannel;
}

export class NotificationService {
  private static instance: NotificationService;
  private adapters: Map<NotificationChannel, NotificationAdapter> = new Map();

  private constructor() {}

  public static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  public registerAdapter(adapter: NotificationAdapter): void {
    this.adapters.set(adapter.getChannelType(), adapter);
    console.log(`Registered ${adapter.getChannelType()} adapter`);
  }

  public async sendNotification(
    recipient: RecipientInfo,
    content: NotificationContent,
    options: NotificationOptions
  ): Promise<Record<NotificationChannel, boolean>> {
    const results: Record<NotificationChannel, boolean> = {} as Record<NotificationChannel, boolean>;
    console.log(`Attempting to send notification to ${recipient.name} via channels:`, options.channels);

    for (const channel of options.channels) {
      const adapter = this.adapters.get(channel);
      if (!adapter) {
        console.warn(`No adapter registered for channel: ${channel}`);
        results[channel] = false;
        continue;
      }

      if (!adapter.canSendTo(recipient)) {
        console.warn(`Cannot send to recipient via ${channel}: missing required info`);
        results[channel] = false;
        continue;
      }

      try {
        console.log(`Sending ${channel} notification to ${recipient.name}`);
        results[channel] = await adapter.send(recipient, content);
        console.log(`${channel} notification sent successfully: ${results[channel]}`);
      } catch (error) {
        console.error(`Error sending notification via ${channel}:`, error);
        results[channel] = false;
      }
    }

    return results;
  }

  // Dedicated method for handling suggestion-related notifications
  public async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
    options: Partial<NotificationOptions> = {}
  ): Promise<void> {
    console.log(`Processing notifications for suggestion ${suggestion.id} with status ${suggestion.status}`);
    
    const templateContent = this.getSuggestionTemplate(suggestion, options.customMessage);
    if (!templateContent) {
      console.log(`No template found for status ${suggestion.status} - skipping notification`);
      return;
    }
  
    const recipientsWithChannels = this.getRecipientsForSuggestion(suggestion);
    console.log(`Found ${recipientsWithChannels.length} potential recipients`);
  
    for (const { recipient, preferredChannels } of recipientsWithChannels) {
      // Filter recipients based on notifyParties if provided
      if (options.notifyParties) {
        const recipientType = this.getRecipientType(recipient, suggestion);
        if (!recipientType || !options.notifyParties.includes(recipientType)) {
          console.log(`Skipping recipient ${recipient.name} (${recipientType}) - not in notifyParties`, options.notifyParties);
          continue;
        }
      }
      
      const channelsToUse = options.channels || preferredChannels || ['email'];
      console.log(`Sending notification to ${recipient.name} via channels:`, channelsToUse);
      
      await this.sendNotification(
        recipient,
        templateContent,
        { ...options, channels: channelsToUse }
      );
    }
    
    console.log(`Finished processing notifications for suggestion ${suggestion.id}`);
  }

  // Helper method to determine recipient type
  private getRecipientType(
    recipient: RecipientInfo, 
    suggestion: SuggestionWithParties
  ): 'first' | 'second' | 'matchmaker' | null {
    if (recipient.email === suggestion.firstParty.email) {
      return 'first';
    } else if (recipient.email === suggestion.secondParty.email) {
      return 'second';
    } else if (recipient.email === suggestion.matchmaker.email) {
      return 'matchmaker';
    }
    return null;
  }

  private getSuggestionTemplate(
    suggestion: SuggestionWithParties,
    customMessage?: string
  ): NotificationContent | null {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    // If there's a custom message, use it instead of the template
    if (customMessage) {
      const reviewUrl = `${baseUrl}/suggestions/${suggestion.id}/review`;
      return {
        subject: "עדכון בהצעת שידוך",
        body: `שלום,\n\n${customMessage}\n\nלצפייה בפרטי ההצעה: ${reviewUrl}\n\nבברכה,\nמערכת השידוכים`,
        htmlBody: `
          <div dir="rtl">
            <h2>שלום,</h2>
            <p>${customMessage}</p>
            <p>לצפייה בפרטי ההצעה: <a href="${reviewUrl}">לחץ כאן</a></p>
            <p>בברכה,<br>מערכת השידוכים</p>
          </div>
        `
      };
    }
    
    // Otherwise use the template based on status
    switch (suggestion.status) {
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.firstParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.firstParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בהצעה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.\n\nההצעה תועבר כעת באופן אוטומטי לצד השני.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.</p><p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.secondParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nהצד הראשון כבר אישר את ההצעה.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.secondParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>הצד הראשון כבר אישר את ההצעה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בפרטי ההצעה ומענה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.\n\nשני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.</p><p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
    
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Prepare contact details with multi-line support
        const firstPartyDetails = this.formatUserDetails(suggestion.firstParty);
        const secondPartyDetails = this.formatUserDetails(suggestion.secondParty);
        
        return {
          subject: 'פרטי קשר להצעת השידוך',
          body: `ברכות! שני הצדדים אישרו את הצעת השידוך.\n\nפרטי הקשר של הצד הראשון:\n${firstPartyDetails}\n\nפרטי הקשר של הצד השני:\n${secondPartyDetails}\n\nאנא צרו קשר בהקדם לתיאום פגישה ראשונה.\n\nבהצלחה!`,
          htmlBody: `<div dir="rtl"><h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2><p>פרטי הקשר של הצד הראשון:</p><pre>${firstPartyDetails}</pre><p>פרטי הקשר של הצד השני:</p><pre>${secondPartyDetails}</pre><p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p><p>בהצלחה!</p></div>`
        };
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return {
          subject: 'בקשה למשוב על הפגישה הראשונה',
          body: `שלום,\n\nנשמח לקבל את המשוב שלך על הפגישה הראשונה.\n\nלשליחת המשוב: ${baseUrl}/suggestions/${suggestion.id}/feedback\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום,</h2><p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/feedback">לשליחת המשוב</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
        return {
          subject: 'בקשת זמן למחשבה לאחר הפגישה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nאחד הצדדים ביקש זמן למחשבה לאחר הפגישה.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.DATING:
        return {
          subject: 'עדכון סטטוס - בתהליך היכרות',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהזוג נמצא בתהליך היכרות.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הזוג נמצא בתהליך היכרות.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.ENGAGED:
        return {
          subject: 'מזל טוב! - אירוסין',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.MARRIED:
        return {
          subject: 'מזל טוב! - חתונה',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.EXPIRED:
        return {
          subject: 'הצעת השידוך פגה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהצעת השידוך פגה עקב חוסר מענה במועד.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הצעת השידוך פגה עקב חוסר מענה במועד.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      default:
        // For other statuses, return null to skip notification
        console.log(`No template defined for status: ${suggestion.status}`);
        return null;
    }
  }

  private getRecipientsForSuggestion(suggestion: SuggestionWithParties): Array<{
    recipient: RecipientInfo;
    preferredChannels: NotificationChannel[];
  }> {
    const recipients: Array<{
      recipient: RecipientInfo;
      preferredChannels: NotificationChannel[];
    }> = [];
    
    // Logic to determine recipients based on suggestion status
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email'] // Email only for drafts
        });
        break;
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.firstParty.email,
            phone: suggestion.firstParty.phone || undefined,
            name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.secondParty.email,
            phone: suggestion.secondParty.phone || undefined,
            name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email']
          }
        );
        break;
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        // Send to both parties
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;
      
      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;

      default:
        // Default: send to matchmaker only
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email']
        });
        break;
    }

    return recipients;
  }

  // Helper function to format contact details
  private formatUserDetails(user: { 
    firstName: string; 
    lastName: string; 
    email: string; 
    phone?: string | null 
  }): string {
    const details = [
      `שם: ${user.firstName} ${user.lastName}`,
      `אימייל: ${user.email}`,
    ];

    if (user.phone) {
      details.push(`טלפון: ${user.phone}`);
    }

    return details.join('\n');
  }
}

export const notificationService = NotificationService.getInstance();
--- End of Content for NotificationService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification\initNotifications.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/initNotifications.ts

import { notificationService } from './NotificationService';
import { emailAdapter } from './adapters/EmailAdapter';
import { whatsAppAdapter } from './adapters/WhatsAppAdapter';

// Define notification channel type
export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
    channels: NotificationChannel[];
    notifyParties?: ('first' | 'second' | 'matchmaker')[];
    customMessage?: string;
  };

/**
 * Initializes the notification service by registering all available adapters
 * @returns The initialized notification service
 */
export function initNotificationService() {
  // Register adapters
  notificationService.registerAdapter(emailAdapter);
  notificationService.registerAdapter(whatsAppAdapter);
  
  console.log('Notification service initialized with email and WhatsApp adapters');
  
  return notificationService;
}
--- End of Content for initNotifications.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification\notification_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification\adapters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification\adapters\EmailAdapter.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/adapters/EmailAdapter.ts

import { NotificationAdapter, NotificationChannel, RecipientInfo, NotificationContent } from '../NotificationService';
import nodemailer from 'nodemailer';

export class EmailAdapter implements NotificationAdapter {
  private static instance: EmailAdapter;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure the transporter exactly like in EmailService
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER || '',
        pass: process.env.GMAIL_APP_PASSWORD || '',
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on initialization
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig(): Promise<void> {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw, to allow the system to continue even if verification fails
    }
  }

  public static getInstance(): EmailAdapter {
    if (!EmailAdapter.instance) {
      EmailAdapter.instance = new EmailAdapter();
    }
    return EmailAdapter.instance;
  }

  public getChannelType(): NotificationChannel {
    return 'email';
  }

  public canSendTo(recipient: RecipientInfo): boolean {
    return !!recipient.email;
  }

  public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
    try {
      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME || 'מערכת השידוכים'} <${process.env.GMAIL_USER || ''}>`,
        to: recipient.email,
        subject: content.subject,
        text: content.body,
        html: content.htmlBody || content.body.replace(/\n/g, '<br>'),
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
        to: recipient.email,
        subject: content.subject
      });

      return true;
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        recipient: recipient.email,
        subject: content.subject
      });
      return false;
    }
  }
}

export const emailAdapter = EmailAdapter.getInstance();
--- End of Content for EmailAdapter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\components\matchmaker\suggestions\services\notification\adapters\WhatsAppAdapter.ts
--------------------------------------------------------------------------------
Content:
// lib/WhatsAppAdapter.ts
import {
  NotificationAdapter,
  NotificationChannel,
  RecipientInfo,
  NotificationContent as BaseNotificationContent
} from '../NotificationService'; // Assuming NotificationService.ts exists in the same directory
import twilio from 'twilio';
// Import the specific type for message creation options if available
import { MessageListInstanceCreateOptions } from 'twilio/lib/rest/api/v2010/account/message';

// --- Define an extended NotificationContent interface ---
// This adds the optional adapter-specific data structure
interface NotificationContent extends BaseNotificationContent {
  _adapterSpecificData?: {
      contentSid?: string;
      contentVariables?: string; // Should be a JSON string
      // Add other potential adapter-specific fields here
  };
}
// --- End Interface Extension ---

// --- Type Guard for Twilio-like Errors ---
interface PotentialTwilioError {
  code?: number | string;
  message?: string;
  // Add other potential properties like 'status', 'moreInfo', etc. if needed
}

/**
* Type guard to check if an unknown error object might be a Twilio API error
* by checking for the presence of 'code' or 'message' properties.
* @param error The unknown value caught in a catch block.
* @returns True if the error object has properties common to Twilio errors, false otherwise.
*/
function isPotentialTwilioError(error: unknown): error is PotentialTwilioError {
  // Check if it's a non-null object and has either 'code' or 'message' property
  return typeof error === 'object' && error !== null && ('code' in error || 'message' in error);
}
// --- End Type Guard ---

// --- Helper: Logger (optional but recommended) ---
// Using Record<string, unknown> or object instead of any
const logger = {
info: (message: string, meta?: Record<string, unknown> | object) => {
  console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
warn: (message: string, meta?: Record<string, unknown> | object) => {
  console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
error: (message: string, meta?: Record<string, unknown> | object) => {
  let logMeta = meta || {};
  // If the meta object itself is an Error, extract relevant info
  if (meta instanceof Error) {
      logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
  } else if (isPotentialTwilioError(meta)) {
      // If it's potentially a Twilio error passed directly
      logMeta = { code: meta.code, message: meta.message, ...meta };
  }
  console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', service: 'WhatsAppAdapter', message, ...logMeta }));
},
};
// --- End Logger ---


export class WhatsAppAdapter implements NotificationAdapter {
// Singleton instance
private static instance: WhatsAppAdapter;
// Twilio client instance (typed)
private client: twilio.Twilio | null = null;
// Configured Twilio WhatsApp sender number
private fromNumber: string = '';

/**
 * Private constructor to enforce singleton pattern.
 * Initializes the Twilio client using environment variables.
 */
private constructor() {
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  this.fromNumber = process.env.TWILIO_WHATSAPP_NUMBER || ''; // Get number from env

  // Validate configuration
  if (!accountSid || !authToken || !this.fromNumber) {
    logger.error('Missing Twilio configuration details', {
        hasSid: !!accountSid,
        hasToken: !!authToken,
        hasWhatsAppNumber: !!this.fromNumber,
        detail: "WhatsApp notifications will be unavailable."
    });
    // Do not throw, allow graceful degradation if possible
  } else {
    try {
      // Initialize Twilio client
      this.client = twilio(accountSid, authToken);
      logger.info('Twilio client initialized successfully', { fromWhatsAppNumber: this.fromNumber });
    } catch (error: unknown) { // Catch as unknown
      logger.error('Failed to initialize Twilio client during constructor', { error });
      this.client = null; // Ensure client is null on initialization failure
    }
  }
}

/**
 * Gets the singleton instance of the WhatsAppAdapter.
 * @returns The WhatsAppAdapter instance.
 */
public static getInstance(): WhatsAppAdapter {
  if (!WhatsAppAdapter.instance) {
    WhatsAppAdapter.instance = new WhatsAppAdapter();
  }
  return WhatsAppAdapter.instance;
}

/**
 * Returns the channel type handled by this adapter.
 * @returns The notification channel type ('whatsapp').
 */
public getChannelType(): NotificationChannel {
  return 'whatsapp';
}

/**
 * Checks if this adapter is capable of sending a notification to the given recipient.
 * Requires a valid phone number, an initialized Twilio client, and a configured 'from' number.
 * @param recipient Information about the recipient.
 * @returns True if the adapter can send, false otherwise.
 */
public canSendTo(recipient: RecipientInfo): boolean {
  const hasValidPhone = !!recipient.phone && recipient.phone.length > 8; // Basic validation
  const isClientReady = this.client !== null;
  const hasFromNumber = this.fromNumber !== '';
  const canSend = hasValidPhone && isClientReady && hasFromNumber;

  if (!canSend) {
      let reason = 'Unknown';
      if (!hasValidPhone) reason = 'Invalid or missing phone number';
      else if (!isClientReady) reason = 'Twilio client not initialized';
      else if (!hasFromNumber) reason = 'Twilio "from" number not configured';
      logger.warn('Cannot send WhatsApp message due to configuration or recipient data', {
          reason: reason,
          recipientPhone: recipient.phone // Log phone for debugging
      });
  }
  return canSend;
}

/**
 * Formats a phone number into E.164 standard without the leading '+'.
 * Required for Twilio's `to` parameter when prefixed with `whatsapp:`.
 * Handles Israeli numbers starting with '0'.
 * Example: 0501234567 -> 972501234567
 * @param phone The phone number string to format.
 * @returns The formatted phone number string.
 */
private formatPhoneNumber(phone: string): string {
  // Remove all non-digit characters
  let cleaned = phone.replace(/\D/g, '');
  // Prepend country code for Israeli numbers if '0' prefix exists
  if (cleaned.startsWith('0')) {
    cleaned = '972' + cleaned.substring(1);
  }
  // Remove leading '+' if present (it's added later in the `whatsapp:` prefix)
  if (cleaned.startsWith('+')) {
    cleaned = cleaned.substring(1);
  }
  return cleaned;
}

/**
 * Sends a notification via WhatsApp using the Twilio API.
 * Prefers using template messages if configured via `_adapterSpecificData`.
 * Falls back to raw text messages otherwise (less reliable for business-initiated messages).
 * @param recipient Information about the recipient.
 * @param content The notification content, potentially including adapter-specific data.
 * @returns A promise that resolves to true if the message was successfully queued by Twilio, false otherwise.
 */
public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
  logger.info('Attempting to send WhatsApp message', {
    recipientPhone: recipient.phone,
    fromNumber: this.fromNumber,
    hasClient: !!this.client,
    contentSid: content._adapterSpecificData?.contentSid,
    hasContentVariables: !!content._adapterSpecificData?.contentVariables,
  });

  // --- Pre-send Checks ---
  if (!this.client) {
    logger.error('Twilio client not initialized. Cannot send WhatsApp message.');
    return false;
  }
  if (!recipient.phone) {
    logger.error('Recipient phone number is missing. Cannot send WhatsApp message.');
    return false;
  }
  if (!this.fromNumber) {
      logger.error('Twilio "from" WhatsApp number is not configured. Cannot send message.');
      return false;
  }
  // --- End Pre-send Checks ---


  try {
    // --- Format Numbers ---
    const toNumberE164 = this.formatPhoneNumber(recipient.phone);
    // Ensure 'from' number has '+' prefix for the whatsapp: schema
    const fromWhatsAppFormatted = `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`;
    // Ensure 'to' number has '+' prefix for the whatsapp: schema
    const toWhatsAppFormatted = `whatsapp:+${toNumberE164}`;

    logger.info(`Formatted numbers for sending via Twilio`, { from: fromWhatsAppFormatted, to: toWhatsAppFormatted });
    // --- End Format Numbers ---


    // --- Prepare Message Payload ---
    let messagePayload: MessageListInstanceCreateOptions;
    const adapterData = content._adapterSpecificData;

    if (adapterData?.contentSid && adapterData?.contentVariables) {
       // **Use Template Messaging**
       logger.info(`Preparing WhatsApp template message`, { contentSid: adapterData.contentSid });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          contentSid: adapterData.contentSid, // The approved template SID
          contentVariables: adapterData.contentVariables, // JSON string of variables {"1": "value1", "2": "value2"}
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    } else {
       // **Use Raw Text Messaging (Fallback)**
       // Note: This might fail if outside the 24-hour customer service window
       // or if WhatsApp/Twilio policies require templates for this type of message.
       const bodyText = content.body || content.subject || 'הודעה ממערכת השידוכים'; // Determine fallback content
       logger.warn(`Preparing raw text WhatsApp message (using fallback, might fail)`, { bodyLength: bodyText.length });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          body: bodyText, // The actual text message content
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    }
    // --- End Prepare Message Payload ---


    // --- Send Message via Twilio API ---
    logger.info("Sending message payload to Twilio API", { payload: messagePayload }); // Be cautious logging full payload in production if sensitive
    const message = await this.client.messages.create(messagePayload);
    // --- End Send Message ---


    // --- Log Success ---
    // The message status here is typically 'queued' or 'sending'. Delivery confirmation is asynchronous.
    logger.info('WhatsApp message request processed successfully by Twilio', {
      messageSid: message.sid,
      status: message.status,
      to: toWhatsAppFormatted,
      from: fromWhatsAppFormatted,
      price: message.price, // Log cost if available
      priceUnit: message.priceUnit,
      errorCode: message.errorCode, // Log if Twilio detected an error immediately
      errorMessage: message.errorMessage,
    });
    // We return true because Twilio accepted the request. Delivery is not guaranteed at this point.
    return true;
    // --- End Log Success ---

  } catch (error: unknown) { // Catch error as unknown
    // --- Handle Errors ---
    let errorMessage = 'Unknown error occurred while sending WhatsApp message.';
    let errorCode: number | string | undefined;

    // Use the type guard to safely access potential error properties
    if (isPotentialTwilioError(error)) {
        errorCode = error.code;
        errorMessage = error.message || errorMessage;
    } else if (error instanceof Error) {
        // Standard JavaScript Error
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        // Simple string error
        errorMessage = error;
    }

    // Log detailed error information
    logger.error('Failed to send WhatsApp message via Twilio', {
      errorCode,
      errorMessage,
      recipient: `whatsapp:+${this.formatPhoneNumber(recipient.phone)}`, // Log formatted number for debugging
      from: `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`,
      // Pass the original error object for full details in structured logs
      errorDetails: error
    });

    // Specific handling/logging for common, informative errors
    if (errorCode === 63018 || errorCode === 21614) { // Common codes for non-WhatsApp/incapable numbers
         logger.error(`Recipient number appears invalid or not registered on WhatsApp.`, { phone: recipient.phone, errorCode });
         // Consider adding logic here: maybe mark the user's number as invalid? Notify admin?
    } else if (errorCode === 63016) { // Common code for failing outside the 24-hour window without a template
          logger.warn(`Failed to send non-template message outside 24-hour window.`, { phone: recipient.phone, errorCode });
    }

    return false; // Indicate that sending failed
    // --- End Handle Errors ---
  }
}
}

// Export the singleton instance for use in other parts of the application
export const whatsAppAdapter = WhatsAppAdapter.getInstance();
--- End of Content for WhatsAppAdapter.ts ---

