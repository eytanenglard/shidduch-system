################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app
# Generated on: 2025-07-20 11:14:35
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\app_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\favicon.ico
--------------------------------------------------------------------------------
[Content: This is likely a binary file or uses an encoding other than UTF-8. Content not displayed as text.]

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\globals.css
--------------------------------------------------------------------------------
Content:
/* 1. Tailwind CSS Directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 2. Base Layer: משתני עיצוב (Theming) וסגנונות בסיס */
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }

  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }

  html[dir="rtl"] {
    overflow-x: hidden;
  }

  html[dir="rtl"] body {
    width: 100%;
    overflow-x: hidden;
  }
}

/* 3. Components Layer: סגנונות לרכיבים מותאמים אישית */
@layer components {
  .btn-refined-gradient {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem;
    border-radius: 0.75rem;
    font-weight: 500;
    color: white;
    background-image: linear-gradient(135deg, #22d3ee, #f472b6);
    border: none;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
    transition: all 0.2s ease-in-out;
    cursor: pointer;
  }

  .btn-refined-gradient:hover {
    background-image: linear-gradient(135deg, #06b6d4, #ec4899);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.12), 0 2px 3px rgba(0, 0, 0, 0.08);
    transform: translateY(-1px);
  }

  .btn-refined-gradient svg {
    width: 1.125rem;
    height: 1.125rem;
  }

  .wizard-content { min-height: 400px; position: relative; overflow: hidden; }
  .form-step-enter { opacity: 0; transform: translateX(var(--enter-translate, 100%)); }
  .form-step-enter-active { opacity: 1; transform: translateX(0%); transition: opacity 300ms, transform 300ms; }
  .form-step-exit { opacity: 1; transform: translateX(0%); }
  .form-step-exit-active { opacity: 0; transform: translateX(var(--exit-translate, -100%)); transition: opacity 300ms, transform 300ms; }
  .gender-filter-panel { border-radius: 0.5rem; padding: 0.75rem; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); border-width: 1px; }
  .male-filter-panel { border-color: #dbeaff; background-color: #f5f9ff; }
  .female-filter-panel { border-color: #f2e6ff; background-color: #faf5ff; }

  /* Enhanced Suggestions Components */
  .btn-gradient-primary {
    background: linear-gradient(135deg, #06b6d4 0%, #10b981 100%);
    transition: all 0.3s ease;
  }

  .btn-gradient-primary:hover {
    background: linear-gradient(135deg, #0891b2 0%, #059669 100%);
    transform: translateY(-1px);
    box-shadow: 0 10px 15px -3px rgba(6, 182, 212, 0.3);
  }

  .btn-gradient-secondary {
    background: linear-gradient(135deg, #3b82f6 0%, #06b6d4 100%);
    transition: all 0.3s ease;
  }

  .btn-gradient-secondary:hover {
    background: linear-gradient(135deg, #2563eb 0%, #0891b2 100%);
    transform: translateY(-1px);
    box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
  }

  .badge-gradient-success {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
    border: none;
  }

  .badge-gradient-pending {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: white;
    border: none;
  }

  .badge-gradient-info {
    background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
    color: white;
    border: none;
  }

  .glass-effect {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .image-overlay-gradient {
    background: linear-gradient(
      to top,
      rgba(0, 0, 0, 0.7) 0%,
      rgba(0, 0, 0, 0.3) 50%,
      transparent 100%
    );
  }
}

/* 4. Utilities Layer: כלי עזר מותאמים אישית ותיקוני RTL */
@layer utilities {
  .dir-rtl { direction: rtl; }
  .dir-ltr { direction: ltr; }
  .force-ltr { direction: ltr !important; }
  .force-rtl { direction: rtl !important; }
  .progress-green [data-state="progress"] { background-color: hsl(142 76% 36%); }
  .progress-blue [data-state="progress"] { background-color: hsl(221 83% 53%); }
  .progress-amber [data-state="progress"] { background-color: hsl(45 93% 47%); }
  [data-radix-popper-content-wrapper] { direction: ltr; }
  .dir-rtl .button-icon { margin-left: 0.5rem; margin-right: 0; }
  .dir-ltr .button-icon { margin-right: 0.5rem; margin-left: 0; }
  .dir-rtl .form-step-enter { --enter-translate: -100%; }
  .dir-rtl .form-step-exit-active { --exit-translate: 100%; }
  .dir-rtl .wizard-navigation { margin-left: 0; margin-right: auto; }
  .dir-rtl .wizard-controls { flex-direction: row-reverse; }
  .dir-rtl .dropdown-menu { transform-origin: top right; }
  .dir-ltr .dropdown-menu { transform-origin: top left; }
  .dir-rtl .toast { right: auto; left: 1rem; }
  .dir-ltr .toast { left: auto; right: 1rem; }
  [dir="rtl"] .select-value { text-align: right; }
  .slider, .rtl-slider-container { direction: ltr !important; }
  .rtl-number-display { direction: ltr; display: inline-block; text-align: center; }

  /* Enhanced Suggestions Utilities */
  .animate-fade-in-up {
    animation: fade-in-up 0.6s ease-out forwards;
  }

  .animate-mobile-match-point {
    animation: mobile-match-point-appear 0.5s ease-out forwards;
  }

  .animate-scale-in {
    animation: scale-in 0.3s ease-out forwards;
  }

  .animate-shimmer {
    animation: shimmer 2s infinite;
  }

  .animate-pulse-subtle {
    animation: pulse-subtle 2s ease-in-out infinite;
  }

  .animate-urgent-pulse {
    animation: urgent-pulse 1.5s infinite;
  }

  .animate-gentle-shake {
    animation: gentle-shake 0.3s ease-in-out;
  }

  .animate-corner-fill {
    animation: corner-fill 0.5s ease-out forwards;
  }

  .card-hover-elegant {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .card-hover-elegant:hover {
    transform: translateY(-4px);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  }

  .scrollbar-elegant {
    scrollbar-width: thin;
    scrollbar-color: rgba(6, 182, 212, 0.3) transparent;
  }

  .scrollbar-elegant::-webkit-scrollbar {
    width: 6px;
  }

  .scrollbar-elegant::-webkit-scrollbar-track {
    background: transparent;
  }

  .scrollbar-elegant::-webkit-scrollbar-thumb {
    background: rgba(6, 182, 212, 0.3);
    border-radius: 3px;
  }

  .scrollbar-elegant::-webkit-scrollbar-thumb:hover {
    background: rgba(6, 182, 212, 0.5);
  }

  .glow-effect {
    box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
  }

  .status-transition {
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  .bg-suggestion-gradient {
    background: linear-gradient(135deg, 
      rgba(99, 102, 241, 0.05) 0%, 
      rgba(139, 92, 246, 0.05) 25%,
      rgba(59, 130, 246, 0.05) 50%,
      rgba(6, 182, 212, 0.05) 75%,
      rgba(16, 185, 129, 0.05) 100%);
  }

  .bg-gradient-header {
    background: linear-gradient(135deg, 
      rgba(6, 182, 212, 0.08) 0%, 
      rgba(255, 255, 255, 0.95) 50%, 
      rgba(16, 185, 129, 0.08) 100%
    );
  }

  .text-shadow-elegant {
    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .backdrop-blur-elegant {
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }

  .focus-elegant:focus {
    outline: none;
    ring: 2px;
    ring-color: rgba(6, 182, 212, 0.5);
    ring-offset: 2px;
  }

  .border-elegant {
    border: 1px solid rgba(6, 182, 212, 0.2);
  }

  .border-elegant-hover:hover {
    border-color: rgba(6, 182, 212, 0.4);
  }

  .loading-skeleton {
    background: linear-gradient(
      90deg,
      rgba(6, 182, 212, 0.1) 25%,
      rgba(6, 182, 212, 0.2) 50%,
      rgba(6, 182, 212, 0.1) 75%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
  }

  .min-h-suggestion-card {
    min-height: 400px;
  }

  .min-h-suggestion-modal {
    min-height: 600px;
  }

  .spacing-suggestion {
    padding: 1.5rem;
  }

  /* Status indicators */
  .status-indicator {
    position: relative;
  }

  .status-indicator::before {
    content: '';
    position: absolute;
    top: -2px;
    right: -2px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    border: 2px solid white;
  }

  .status-indicator.status-active::before {
    background-color: #10b981;
  }

  .status-indicator.status-pending::before {
    background-color: #f59e0b;
    animation: pulse-subtle 2s infinite;
  }

  .status-indicator.status-inactive::before {
    background-color: #6b7280;
  }
}

/* 5. Keyframes for Animations */
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes gradient-anim { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
@keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-25px); } }
@keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

/* Hero Section Synergy Visualization Animations */
@keyframes synergy-enter-left { from { opacity: 0; transform: translate(-30px, -50%); } to { opacity: 1; transform: translate(0, -50%); } }
@keyframes synergy-enter-right { from { opacity: 0; transform: translate(30px, -50%); } to { opacity: 1; transform: translate(0, -50%); } }
@keyframes draw-line { to { stroke-dashoffset: 0; } }
@keyframes match-point-appear { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 70% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

/* Enhanced Suggestions Keyframes */
@keyframes fade-in-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes mobile-match-point-appear {
  from {
    transform: scale(0.8);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes pulse-subtle {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.8;
    transform: scale(1.02);
  }
}

@keyframes urgent-pulse {
  0%, 100% {
    background-color: rgb(249 115 22);
    box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.7);
  }
  50% {
    background-color: rgb(234 88 12);
    box-shadow: 0 0 0 8px rgba(249, 115, 22, 0);
  }
}

@keyframes gentle-shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-1px); }
  75% { transform: translateX(1px); }
}

@keyframes corner-fill {
  from {
    clip-path: polygon(0 0, 0 0, 0 100%, 0% 100%);
  }
  to {
    clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
  }
}

/* 6. Animation Utility Classes */
.animate-gradient { animation: gradient-anim 4s ease infinite; }
.animate-gradient-slow { animation: gradient-anim 15s ease infinite; }
.animate-float-slow { animation: float 8s ease-in-out infinite; }
.group-hover\:animate-shimmer { animation: shimmer 2s infinite; }

/* Hero Section Animation Classes */
.animate-synergy-enter-left { animation: synergy-enter-left 0.8s ease-out forwards 0.2s; }
.animate-synergy-enter-right { animation: synergy-enter-right 0.8s ease-out forwards 0.2s; }

.path-draw {
  stroke-dasharray: 500;
  stroke-dashoffset: 500;
  animation: draw-line 1.2s ease-out forwards 0.5s;
}

.animate-match-point-appear {
  animation: match-point-appear 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards 1.7s;
}

/* 7. Responsive Optimizations */
@media (max-width: 768px) {
  .animate-fade-in-up {
    animation-duration: 0.4s;
  }
  
  .card-hover-elegant:hover {
    transform: translateY(-2px);
  }

  .spacing-suggestion {
    padding: 2rem;
  }
}

/* 8. Dark Mode Support */
@media (prefers-color-scheme: dark) {
  .glass-effect {
    background: rgba(17, 24, 39, 0.95);
    border: 1px solid rgba(75, 85, 99, 0.3);
  }
  
  .scrollbar-elegant::-webkit-scrollbar-thumb {
    background: rgba(156, 163, 175, 0.3);
  }

  .bg-suggestion-gradient {
    background: linear-gradient(135deg, 
      rgba(6, 182, 212, 0.1) 0%, 
      rgba(17, 24, 39, 1) 25%, 
      rgba(16, 185, 129, 0.1) 100%
    );
  }
}

/* 9. Print Styles */
@media print {
  .no-print {
    display: none !important;
  }
  
  .card-hover-elegant {
    box-shadow: none !important;
    transform: none !important;
  }
}
--- End of Content for globals.css ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\layout.tsx
--------------------------------------------------------------------------------
Content:
import { Inter } from "next/font/google";
import "./globals.css";
import { metadata as siteMetadata } from "./metadata";
import { cookies } from "next/headers";
import Providers from "@/components/Providers";
import Navbar from "@/components/layout/Navbar";
import { LanguageProvider } from "@/app/contexts/LanguageContext";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
  display: "swap",
});

export const metadata = siteMetadata;

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const cookieStore = await cookies();
  const defaultLanguage = cookieStore.get("language")?.value || "he";
  const isRTL = defaultLanguage === "he";

  return (
    <html
      lang={defaultLanguage}
      dir={isRTL ? "rtl" : "ltr"}
      className={isRTL ? "dir-rtl" : "dir-ltr"}
      suppressHydrationWarning
    >
      <body
        className={`${inter.variable} antialiased`}
        suppressHydrationWarning
      >
        <Providers>
          <LanguageProvider>
            <div
              className={`min-h-screen flex flex-col ${
                isRTL ? "dir-rtl" : "dir-ltr"
              }`}
              dir={isRTL ? "rtl" : "ltr"}
            >
              <Navbar />
              <main className="flex-1 w-full">{children}</main>
            </div>
          </LanguageProvider>
        </Providers>
      </body>
    </html>
  );
}
--- End of Content for layout.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\metadata.ts
--------------------------------------------------------------------------------
Content:
import type { Metadata } from "next/types";

export const metadata: Metadata = {
  title: "מערכת שידוכים",
  description: "מערכת שידוכים המיועדת לציבור הדתי והחרדי",
};
--- End of Content for metadata.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\page.tsx
--------------------------------------------------------------------------------
Content:
import HomePage from "@/components/HomePage/HomePage";

export default function Page() {
  return <HomePage />;
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\matches\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import { useSession } from "next-auth/react";
import MatchSuggestionsContainer from "@/app/components/suggestions/MatchSuggestionsContainer";
import { Skeleton } from "@/components/ui/skeleton";

export default function MatchesPage() {
  const { data: session, status } = useSession();

  if (status === "loading") {
    return (
      <div className="container mx-auto p-6 space-y-4">
        <Skeleton className="h-48 w-full" />
        <Skeleton className="h-48 w-full" />
      </div>
    );
  }

  if (!session?.user?.id) {
    return <div>לא מורשה לצפות בדף זה</div>;
  }

  return <MatchSuggestionsContainer userId={session.user.id} />;
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\matchmaker
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\matchmaker\clients
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\matchmaker\clients\page.tsx
--------------------------------------------------------------------------------
Content:
import CandidatesManager from "@/app/components/matchmaker/new/CandidatesManager/index";

export default function ClientsPage() {
  return <CandidatesManager />;
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\matchmaker\suggestions\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { Suspense } from "react";
import MatchmakerDashboard from "@/app/components/matchmaker/suggestions/container/MatchmakerDashboard";
import { Card, CardContent } from "@/components/ui/card";

export default function SuggestionsPage() {
  return (
    <div className="min-h-screen bg-background">
      <Suspense
        fallback={
          <Card className="m-4">
            <CardContent className="p-6">
              <div className="flex justify-center items-center">
                <div className="text-xl">טוען...</div>
              </div>
            </CardContent>
          </Card>
        }
      >
        <MatchmakerDashboard />
      </Suspense>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\messages
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\messages\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import MessagesPage from "@/app/components/messages/MessagesPage";
import { Card } from "@/components/ui/card";
import { Loader2 } from "lucide-react";
import { Suspense } from "react";

export default function Messages() {
  return (
    <Suspense
      fallback={
        <Card className="m-4">
          <div className="flex justify-center items-center p-8">
            <Loader2 className="h-8 w-8 animate-spin" />
          </div>
        </Card>
      }
    >
      <MessagesPage />
    </Suspense>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { Suspense } from "react";
import UnifiedProfileDashboard from "./components/dashboard/UnifiedProfileDashboard";
import { useSearchParams } from "next/navigation";
import { Loader2 } from "lucide-react";

// A small wrapper to handle Suspense for useSearchParams
const ProfilePageContent = () => {
  const searchParams = useSearchParams();
  const viewOnly = searchParams.get("viewOnly") === "true";
  const userId = searchParams.get("userId") || undefined;
  const initialTab = searchParams.get("tab") || "overview"; // Get initial tab

  return (
    <div className="min-h-screen bg-background" dir="rtl">
      <UnifiedProfileDashboard 
        viewOnly={viewOnly} 
        userId={userId} 
        initialTab={initialTab} 
      />
    </div>
  );
};

const ProfilePage = () => {
  return (
    <Suspense fallback={
      <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-cyan-50 via-white to-pink-50">
        <div className="flex items-center gap-2 text-lg text-cyan-600">
          <Loader2 className="animate-spin h-6 w-6" />
          <span>טוען פרופיל...</span>
        </div>
      </div>
    }>
      <ProfilePageContent />
    </Suspense>
  );
};

export default ProfilePage;
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\components
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\components\advisor
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\components\advisor\AIProfileAdvisorDialog.tsx
--------------------------------------------------------------------------------
Content:
// src/app/(authenticated)/profile/components/advisor/AIProfileAdvisorDialog.tsx
"use client";

import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Loader2, Sparkles, AlertTriangle } from 'lucide-react';
import { toast } from 'sonner';

// נייבא את הקומפוננטה שתציג את התוצאות (ניצור אותה בשלב הבא)
import AnalysisResultDisplay from './AnalysisResultDisplay'; 
import type { AiProfileAnalysisResult } from '@/lib/services/aiService';

interface AIProfileAdvisorDialogProps {
  userId: string;
}

export const AIProfileAdvisorDialog: React.FC<AIProfileAdvisorDialogProps> = ({ userId }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [analysis, setAnalysis] = useState<AiProfileAnalysisResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // פונקציה שתופעל כשהמשתמש ילחץ על הכפתור ותתחיל את התהליך
  const handleGetAnalysis = async () => {
    // אם כבר יש ניתוח, פשוט נפתח את הדיאלוג בלי לקרוא שוב ל-API
    if (analysis) {
      setIsOpen(true);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/ai/analyze-my-profile', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        // אין צורך לשלוח userId, ה-API יקח אותו מהסשן
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'שגיאה בקבלת ניתוח הפרופיל.');
      }

      setAnalysis(result.data);

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'אירעה שגיאה לא צפויה.';
      setError(errorMessage);
      toast.error('שגיאה בתהליך הניתוח', {
        description: errorMessage,
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    // איפוס המצב כאשר הדיאלוג נסגר
    if (!open) {
      // לא מאפסים את ה-analysis כדי לשמור אותו בזיכרון לפתיחה הבאה
      setError(null);
      // setIsLoading(false); // הטעינה כבר אמורה להסתיים
    }
  };
  
  // כאשר הדיאלוג נפתח לראשונה (אין עדיין ניתוח) - נפעיל את הפונקציה
  const handleTriggerClick = () => {
    if (!analysis && !isLoading) {
      handleGetAnalysis();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>
        <Button
          onClick={handleTriggerClick}
          variant="outline"
          size="lg"
          className="rounded-full border-2 border-purple-300 bg-purple-50 text-purple-700 hover:bg-purple-100 hover:border-purple-400 transition-all duration-300 shadow-sm hover:shadow-lg group w-full max-w-sm"
        >
          <Sparkles className="w-5 h-5 ml-2 text-purple-500 transition-transform duration-500 group-hover:rotate-12 group-hover:scale-110" />
          <span>קבל ניתוח וטיפים לשיפור הפרופיל</span>
        </Button>
      </DialogTrigger>
      
      <DialogContent 
        className="max-w-4xl w-[95vw] h-[90vh] flex flex-col p-0"
        dir="rtl"
      >
        <DialogHeader className="p-4 border-b">
          <DialogTitle className="flex items-center gap-2 text-xl">
            <Sparkles className="w-6 h-6 text-purple-500" />
            <span>יועץ הפרופיל החכם שלך</span>
          </DialogTitle>
          <DialogDescription>
            ניתוח מבוסס AI שיעזור לך להציג את עצמך בצורה הטובה ביותר ולמצוא התאמות מדויקות יותר.
          </DialogDescription>
        </DialogHeader>

        <div className="flex-grow overflow-y-auto p-4 md:p-6 bg-slate-50/50">
          {isLoading ? (
            <div className="flex flex-col items-center justify-center h-full text-center">
              <Loader2 className="w-12 h-12 text-purple-500 animate-spin mb-4" />
              <p className="text-lg font-semibold text-gray-700">ה-AI שלנו מנתח את הפרופיל שלך...</p>
              <p className="text-sm text-gray-500 mt-2">זה עשוי לקחת מספר שניות. תודה על סבלנותך.</p>
            </div>
          ) : error ? (
            <div className="flex flex-col items-center justify-center h-full text-center">
              <Alert variant="destructive" className="max-w-md">
                <AlertTriangle className="h-5 w-5" />
                <AlertTitle>אופס, משהו השתבש</AlertTitle>
                <AlertDescription>
                  <p>לא הצלחנו להשלים את ניתוח הפרופיל כרגע.</p>
                  <p className="text-xs mt-2">{error}</p>
                </AlertDescription>
              </Alert>
              <Button onClick={handleGetAnalysis} variant="outline" className="mt-4">
                נסה שוב
              </Button>
            </div>
          ) : analysis ? (
            // כאן נרנדר את קומפוננטת התצוגה כשיהיו לנו תוצאות
            <AnalysisResultDisplay analysis={analysis} />
          ) : (
             // מצב התחלתי, לפני שהטעינה החלה (למקרה שהדיאלוג נפתח בדרך אחרת)
             <div className="flex items-center justify-center h-full">
                <p>לחץ על הכפתור כדי להתחיל את הניתוח.</p>
             </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default AIProfileAdvisorDialog;
--- End of Content for AIProfileAdvisorDialog.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\components\advisor\AnalysisResultDisplay.tsx
--------------------------------------------------------------------------------
Content:
// src/app/(authenticated)/profile/components/advisor/AnalysisResultDisplay.tsx
"use client";

import React from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Lightbulb, CheckCircle2, AlertCircle, XCircle, Camera, User, Search, Target } from 'lucide-react';
import { AiProfileAnalysisResult } from '@/lib/services/aiService';
import { cn } from '@/lib/utils';

interface AnalysisResultDisplayProps {
  analysis: AiProfileAnalysisResult;
}

// קומפוננטה קטנה לעיצוב כרטיס טיפ
const TipCard: React.FC<{ area: string; tip: string }> = ({ area, tip }) => (
  <div className="p-4 rounded-lg bg-yellow-50/70 border border-yellow-200/80 flex items-start gap-4">
    <div className="flex-shrink-0 mt-1">
      <Lightbulb className="w-5 h-5 text-yellow-600" />
    </div>
    <div>
      <p className="font-semibold text-sm text-yellow-800">{area}</p>
      <p className="text-sm text-yellow-900 mt-1">{tip}</p>
    </div>
  </div>
);

// קומפוננטה קטנה לעיצוב שורת דוח
const ReportItem: React.FC<{ area: string; status: 'COMPLETE' | 'PARTIAL' | 'MISSING'; feedback: string }> = ({ area, status, feedback }) => {
  const statusConfig = {
    COMPLETE: { icon: CheckCircle2, color: "text-green-600", text: "הושלם" },
    PARTIAL: { icon: AlertCircle, color: "text-amber-600", text: "חלקי" },
    MISSING: { icon: XCircle, color: "text-red-600", text: "חסר" },
  };

  const { icon: Icon, color, text } = statusConfig[status];

  return (
    <div className="flex items-start gap-3 p-3 border-b last:border-b-0">
      <div className="flex-shrink-0 mt-1">
        <Icon className={cn("w-5 h-5", color)} />
      </div>
      <div className="flex-1">
        <div className="flex justify-between items-center">
          <p className="font-medium text-sm text-slate-800">{area}</p>
          <Badge variant="outline" className={cn("text-xs font-mono", color.replace('text-', 'border-').replace('-600', '-300'))}>
            {text}
          </Badge>
        </div>
        <p className="text-sm text-slate-600 mt-1">{feedback}</p>
      </div>
    </div>
  );
};


const AnalysisResultDisplay: React.FC<AnalysisResultDisplayProps> = ({ analysis }) => {
  return (
    <div className="w-full">
      <Tabs defaultValue="summary" className="w-full">
        <TabsList className="grid w-full grid-cols-2 md:grid-cols-4 h-auto p-1.5 bg-slate-200/70 rounded-lg">
          <TabsTrigger value="summary">סיכום</TabsTrigger>
          <TabsTrigger value="completeness">השלמת פרופיל</TabsTrigger>
          <TabsTrigger value="tips">טיפים לשיפור</TabsTrigger>
          <TabsTrigger value="photos">פידבק על תמונות</TabsTrigger>
        </TabsList>

        <div className="mt-4">
          <TabsContent value="summary" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2 text-lg">
                    <User className="text-blue-500"/>
                    מי אני? (סיכום AI)
                </CardTitle>
                <CardDescription>כך ה-AI מבין את האישיות שלך על סמך מה שסיפרת.</CardDescription>
              </CardHeader>
              <CardContent>
                <p className="text-slate-700 whitespace-pre-wrap leading-relaxed">
                  {analysis.personalitySummary}
                </p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2 text-lg">
                    <Target className="text-green-500"/>
                    את מי אני מחפש/ת? (סיכום AI)
                </CardTitle>
                <CardDescription>סיכום ההעדפות שלך לבן/בת הזוג האידיאלי/ת.</CardDescription>
              </CardHeader>
              <CardContent>
                <p className="text-slate-700 whitespace-pre-wrap leading-relaxed">
                  {analysis.lookingForSummary}
                </p>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="completeness">
             <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2 text-lg">
                  <CheckCircle2 className="text-indigo-500"/>
                  דוח השלמת פרופיל
                </CardTitle>
                <CardDescription>סקירה של החלקים שהושלמו בפרופיל שלך ואלו שעדיין דורשים התייחסות.</CardDescription>
              </CardHeader>
              <CardContent className="p-0">
                 <div className="space-y-0 divide-y">
                    {analysis.completenessReport.map((item, index) => (
                      <ReportItem key={index} {...item} />
                    ))}
                 </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="tips">
             <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2 text-lg">
                  <Lightbulb className="text-yellow-500"/>
                  המלצות וטיפים לשיפור
                </CardTitle>
                <CardDescription>הצעות קונקרטיות שיעזרו לך לשדרג את הפרופיל ולמשוך התאמות טובות יותר.</CardDescription>
              </CardHeader>
              <CardContent className="space-y-3">
                {analysis.actionableTips.map((tip, index) => (
                  <TipCard key={index} area={tip.area} tip={tip.tip} />
                ))}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="photos">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2 text-lg">
                  <Camera className="text-rose-500"/>
                  ניתוח גלריית התמונות
                </CardTitle>
                 <CardDescription>התייחסות לכמות התמונות והמלצות כלליות. ה-AI אינו רואה את תוכן התמונות.</CardDescription>
              </CardHeader>
              <CardContent>
                  <div className="p-4 rounded-lg bg-rose-50/70 border border-rose-200/80 flex flex-col items-center text-center gap-3">
                     <p className="text-4xl font-bold text-rose-600">{analysis.photoFeedback.imageCount}</p>
                     <p className="text-sm font-medium text-rose-800">תמונות הועלו</p>
                     <p className="text-sm text-rose-900 mt-1 max-w-md">
                        {analysis.photoFeedback.feedback}
                     </p>
                  </div>
              </CardContent>
            </Card>
          </TabsContent>
        </div>
      </Tabs>
    </div>
  );
};

export default AnalysisResultDisplay;
--- End of Content for AnalysisResultDisplay.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\components\dashboard
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\components\dashboard\ProfileChecklist.tsx
--------------------------------------------------------------------------------
Content:
// src/app/(authenticated)/profile/components/dashboard/ProfileChecklist.tsx

"use client";

import React, { useState, useMemo } from 'react';
import Link from 'next/link';
import { Progress } from "@/components/ui/progress";
import { Button } from '@/components/ui/button';
import { CheckCircle, User, BookOpen, Camera, Target, ChevronUp, ChevronDown, Sparkles, Edit3 } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from "@/lib/utils";
import type { User as SessionUserType } from '@/types/next-auth';
import type { QuestionnaireResponse } from '@/types/next-auth';

// Helper Types & Constants
const QUESTION_COUNTS: Record<'VALUES' | 'PERSONALITY' | 'RELATIONSHIP' | 'PARTNER' | 'RELIGION', number> = {
    VALUES: 19, PERSONALITY: 19, RELATIONSHIP: 19, PARTNER: 17, RELIGION: 19
};

const WORLD_NAMES_MAP = {
    values: 'ערכים', personality: 'אישיות', relationship: 'זוגיות', partner: 'פרטנר', religion: 'דת ומסורת'
} as const;

type WorldKey = keyof typeof WORLD_NAMES_MAP;

interface ChecklistItemProps {
    id: string;
    isCompleted: boolean;
    title: string;
    description: string;
    link?: string;
    onClick?: () => void;
    icon: React.ElementType;
    missingItems?: string[];
    worldProgress?: { world: string; completed: number; total: number; isDone: boolean }[];
    isActive: boolean;
    setActiveItemId: React.Dispatch<React.SetStateAction<string | null>>;
}

const ChecklistItem: React.FC<ChecklistItemProps> = ({
    id, isCompleted, title, description, link, onClick, icon: Icon,
    missingItems, worldProgress, isActive, setActiveItemId
}) => {
    const canExpand = (missingItems && missingItems.length > 0) || (worldProgress && worldProgress.length > 0);
    const isExpanded = isActive && canExpand;

    const handleInteraction = () => {
        if (isCompleted) return;
        if (onClick) {
            onClick();
        } else if (canExpand && !link) {
            setActiveItemId(prev => (prev === id ? null : id));
        }
    };
    
    const cardContent = (
      <>
        <div className="relative w-full flex justify-center mb-3">
            <div className={cn(
                "relative flex items-center justify-center w-14 h-14 rounded-2xl transition-all duration-300 transform group-hover:scale-110",
                isCompleted ? "bg-emerald-100 shadow-emerald-500/10" : "bg-cyan-100 shadow-cyan-500/10"
            )}>
                <Icon className={cn("w-7 h-7 transition-colors duration-300", isCompleted ? "text-emerald-500" : "text-cyan-600")} />
            </div>
            {isCompleted && (
                <motion.div initial={{ scale: 0, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} transition={{ type: "spring", stiffness: 400, damping: 20, delay: 0.2 }} className="absolute -top-1 -right-1">
                    <CheckCircle className="w-5 h-5 text-emerald-500 bg-white rounded-full p-0.5" fill="white" />
                </motion.div>
            )}
        </div>
        <h4 className={cn("font-bold text-sm text-center transition-colors", isCompleted ? 'text-gray-400 line-through' : 'text-gray-800')}>{title}</h4>
        {!isCompleted && <p className="text-xs text-center text-gray-500 mt-1 leading-tight h-8">{description}</p>}
      </>
    );

    const interactiveContent = (
      link && !isCompleted ? (
        <Link href={link} passHref legacyBehavior>
          <a className="block h-full w-full">{cardContent}</a>
        </Link>
      ) : (
        <button onClick={handleInteraction} className="h-full w-full text-left" disabled={isCompleted}>{cardContent}</button>
      )
    );

    return (
        <motion.div
            layout
            onMouseEnter={() => canExpand && setActiveItemId(id)}
            className={cn(
                "relative flex flex-col rounded-2xl transition-all duration-300 group overflow-hidden",
                isCompleted ? 'bg-white/40' : 'bg-white/70 shadow-md',
                isExpanded && "shadow-xl bg-white"
            )}
        >
            <div className={cn("p-4", !isCompleted && "cursor-pointer")}>
                {interactiveContent}
            </div>
            <AnimatePresence>
                {isExpanded && (
                    <motion.div layout initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }} transition={{ duration: 0.3, ease: 'easeInOut' }} className="overflow-hidden">
                        <div className="bg-slate-50/70 border-t border-slate-200 px-4 py-3 text-sm">
                            <h4 className="font-semibold text-xs mb-2 text-gray-800">מה חסר להשלמת השלב?</h4>
                            {missingItems && (<ul className="list-disc pr-4 space-y-1.5 text-gray-600 text-xs">{missingItems.map(item => <li key={item}>{item}</li>)}</ul>)}
                            {worldProgress && (<div className="space-y-2">{worldProgress.map(world => (<div key={world.world} className="flex items-center justify-between text-xs"><span className={cn("font-medium", world.isDone ? "text-emerald-600" : "text-gray-700")}>{world.world}</span><div className="flex items-center gap-2"><span className="font-mono text-xs">{world.completed}/{world.total}</span>{world.isDone && <CheckCircle className="h-4 w-4 text-emerald-500" />}</div></div>))}</div>)}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </motion.div>
    );
};

interface ProfileChecklistProps {
  user: SessionUserType;
  hasSeenPreview: boolean;
  onPreviewClick: () => void;
  questionnaireResponse: QuestionnaireResponse | null;
}

export const ProfileChecklist: React.FC<ProfileChecklistProps> = ({ user, onPreviewClick, hasSeenPreview, questionnaireResponse }) => {
    const [isMinimized, setIsMinimized] = useState(false);
    const [activeItemId, setActiveItemId] = useState<string | null>(null);

    const getMissingItems = useMemo(() => {
        const p = user.profile;
        if (!p) return { personalDetails: [], partnerPreferences: [] };
        return {
            personalDetails: [
                (!p.about || p.about.trim().length < 100) && 'כתיבת "קצת עליי" (100+ תווים)',
                !p.height && 'גובה', !p.maritalStatus && 'מצב משפחתי', !p.city && 'עיר מגורים',
                !p.occupation && 'עיסוק', !p.educationLevel && 'רמת השכלה', !p.origin && 'מוצא/עדה',
                !p.religiousLevel && 'רמה דתית', !p.serviceType && 'סוג שירות צבאי/לאומי',
                (!p.profileHobbies || p.profileHobbies.length === 0) && 'תחביבים',
                (!p.profileCharacterTraits || p.profileCharacterTraits.length === 0) && 'תכונות אופי',
            ].filter((item): item is string => !!item),
            
            partnerPreferences: [
                (!p.preferredAgeMin || !p.preferredAgeMax) && 'טווח גילאים מועדף',
                (!p.preferredHeightMin || !p.preferredHeightMax) && 'טווח גובה מועדף',
                (!p.preferredReligiousLevels || p.preferredReligiousLevels.length === 0) && 'רמות דתיות מועדפות',
                (!p.preferredLocations || p.preferredLocations.length === 0) && 'אזורי מגורים מועדפים',
                (!p.preferredMaritalStatuses || p.preferredMaritalStatuses.length === 0) && 'מצב משפחתי מועדף',
                (p.preferredShomerNegiah === null || p.preferredShomerNegiah === undefined) && 'העדפת שמירת נגיעה',
                (p.preferredPartnerHasChildren === null || p.preferredPartnerHasChildren === undefined) && 'העדפה לגבי ילדים מקשר קודם',
                (!p.preferredCharacterTraits || p.preferredCharacterTraits.length === 0) && 'תכונות אופי מועדפות',
                (!p.preferredHobbies || p.preferredHobbies.length === 0) && 'תחביבים מועדפים',
            ].filter((item): item is string => !!item),
        };
    }, [user.profile]);

    const questionnaireProgress = useMemo(() => {
        const getAnswerCountFromJsonArray = (jsonValue: unknown): number => {
            if (Array.isArray(jsonValue)) return jsonValue.length;
            return 0;
        };

        if (!questionnaireResponse) {
            return (Object.keys(WORLD_NAMES_MAP) as WorldKey[]).map(key => ({
                world: WORLD_NAMES_MAP[key],
                completed: 0,
                total: QUESTION_COUNTS[key.toUpperCase() as keyof typeof QUESTION_COUNTS],
                isDone: false,
            }));
        }

        const qr = questionnaireResponse;
        return (Object.keys(WORLD_NAMES_MAP) as WorldKey[]).map(key => {
            const uppercaseKey = key.toUpperCase() as keyof typeof QUESTION_COUNTS;
            const answersFieldKey = `${key}Answers` as keyof QuestionnaireResponse;
            const completedCount = getAnswerCountFromJsonArray(qr[answersFieldKey]);
            return {
                world: WORLD_NAMES_MAP[key],
                completed: completedCount,
                total: QUESTION_COUNTS[uppercaseKey],
                isDone: qr.worldsCompleted?.includes(uppercaseKey) ?? false,
            };
        });
    }, [questionnaireResponse]);

    const questionnaireCompleted = questionnaireResponse?.completed ?? false;
    
    const tasks = [
        { id: 'photo', isCompleted: (user.images?.length ?? 0) >= 3, title: 'העלאת תמונות', description: 'הכרטיס ביקור הראשוני שלך.', link: '/profile?tab=photos', icon: Camera, missingItems: (user.images?.length ?? 0) < 3 ? [`נדרשות לפחות 3 תמונות (הועלו: ${user.images?.length ?? 0})`] : [] },
        { id: 'personal_details', isCompleted: getMissingItems.personalDetails.length === 0, title: 'פרטים אישיים', description: 'הבסיס להכיר אותך לעומק.', link: '/profile?tab=overview', icon: User, missingItems: getMissingItems.personalDetails },
        { id: 'partner_preferences', isCompleted: getMissingItems.partnerPreferences.length === 0, title: 'העדפות בן/בת זוג', description: 'לדייק את מי שמחפשים.', link: '/profile?tab=preferences', icon: Target, missingItems: getMissingItems.partnerPreferences },
        { id: 'questionnaire', isCompleted: questionnaireCompleted, title: 'שאלון התאמה', description: 'המפתח להתאמות AI.', link: '/questionnaire', icon: BookOpen, worldProgress: questionnaireProgress ?? undefined },
        { id: 'review', isCompleted: hasSeenPreview, title: 'תצוגה מקדימה', description: 'לראות איך אחרים רואים אותך.', onClick: onPreviewClick, icon: Edit3, missingItems: !hasSeenPreview ? ['יש לצפות בתצוגה המקדימה של הפרופיל'] : [] },
    ];
    
    // ✅✅✅ לוגיקת חישוב אחוזי ההתקדמות החדשה ✅✅✅
    const completionPercentage = useMemo(() => {
        const QUESTIONNAIRE_WEIGHT = 20; // 20% מהציון הכולל
        const OTHER_TASKS_WEIGHT = 80;   // 80% מהציון הכולל

        // --- חלק 1: חישוב תרומת השאלון (0-20%) ---
        const totalQuestions = Object.values(QUESTION_COUNTS).reduce((sum, count) => sum + count, 0);
        const answeredQuestions = questionnaireProgress.reduce((sum, world) => sum + world.completed, 0);
        const questionnaireContribution = totalQuestions > 0
            ? (answeredQuestions / totalQuestions) * QUESTIONNAIRE_WEIGHT
            : 0;

        // --- חלק 2: חישוב תרומת שאר המשימות (0-80%) ---
        const p = user.profile;
        const otherTasksStatus: boolean[] = [];

        // משימה 1: תמונות
        otherTasksStatus.push((user.images?.length ?? 0) >= 3);

        // 11 משימות של פרטים אישיים
        if (p) {
            otherTasksStatus.push(!!(p.about && p.about.trim().length >= 100));
            otherTasksStatus.push(!!p.height);
            otherTasksStatus.push(!!p.maritalStatus);
            otherTasksStatus.push(!!p.city);
            otherTasksStatus.push(!!p.occupation);
            otherTasksStatus.push(!!p.educationLevel);
            otherTasksStatus.push(!!p.origin);
            otherTasksStatus.push(!!p.religiousLevel);
            otherTasksStatus.push(!!p.serviceType);
            otherTasksStatus.push(!!(p.profileHobbies && p.profileHobbies.length > 0));
            otherTasksStatus.push(!!(p.profileCharacterTraits && p.profileCharacterTraits.length > 0));
        } else {
            otherTasksStatus.push(...Array(11).fill(false)); // אם אין פרופיל, כל המשימות לא הושלמו
        }
        
        // 9 משימות של העדפות בן/בת זוג
        if (p) {
            otherTasksStatus.push(!!(p.preferredAgeMin && p.preferredAgeMax));
            otherTasksStatus.push(!!(p.preferredHeightMin && p.preferredHeightMax));
            otherTasksStatus.push(!!(p.preferredReligiousLevels && p.preferredReligiousLevels.length > 0));
            otherTasksStatus.push(!!(p.preferredLocations && p.preferredLocations.length > 0));
            otherTasksStatus.push(!!(p.preferredMaritalStatuses && p.preferredMaritalStatuses.length > 0));
            otherTasksStatus.push(p.preferredShomerNegiah !== null && p.preferredShomerNegiah !== undefined);
            otherTasksStatus.push(p.preferredPartnerHasChildren !== null && p.preferredPartnerHasChildren !== undefined);
            otherTasksStatus.push(!!(p.preferredCharacterTraits && p.preferredCharacterTraits.length > 0));
            otherTasksStatus.push(!!(p.preferredHobbies && p.preferredHobbies.length > 0));
        } else {
             otherTasksStatus.push(...Array(9).fill(false)); // אם אין פרופיל, כל המשימות לא הושלמו
        }
        
        // משימה אחרונה: צפייה בתצוגה מקדימה
        otherTasksStatus.push(hasSeenPreview);
        
        const totalOtherTasks = otherTasksStatus.length;
        const completedOtherTasks = otherTasksStatus.filter(isCompleted => isCompleted).length;
        
        const otherTasksContribution = totalOtherTasks > 0
            ? (completedOtherTasks / totalOtherTasks) * OTHER_TASKS_WEIGHT
            : 0;

        // --- חלק 3: חישוב סופי ---
        return Math.round(questionnaireContribution + otherTasksContribution);

    }, [user, questionnaireProgress, hasSeenPreview]);

    const isAllComplete = completionPercentage >= 100;

    return (
        <AnimatePresence>
            <motion.div layout initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, height: 0, transition: { duration: 0.4 } }} transition={{ duration: 0.5, ease: "easeOut" }} className="mb-8 rounded-3xl shadow-xl border border-white/50 bg-white/70 backdrop-blur-md overflow-hidden">
                <div className="p-4 sm:p-6">
                    <div className="md:flex md:items-center md:justify-between">
                        <div className="flex-1 text-center md:text-right">
                             <h2 className="text-xl font-bold text-slate-800 flex items-center justify-center md:justify-start gap-2">
                                {isAllComplete && <Sparkles className="w-6 h-6 text-amber-500" />}
                                {isAllComplete ? `כל הכבוד, ${user.firstName}! הפרופיל שלך מושלם!` : `ברוך הבא, ${user.firstName}! בוא נכין את הפרופיל שלך להצלחה`}
                            </h2>
                            <AnimatePresence initial={false}>
                                {!isMinimized && (<motion.p initial={{ opacity: 0, height: 0, marginTop: 0 }} animate={{ opacity: 1, height: 'auto', marginTop: '0.25rem' }} exit={{ opacity: 0, height: 0, marginTop: 0 }} className="text-slate-600 text-sm md:text-base overflow-hidden">{isAllComplete ? 'השלמת את כל השלבים. פרופיל עשיר הוא המפתח למציאת ההתאמה המדויקת ביותר.' : 'השלמת הצעדים הבאים תקדם אותך משמעותית למציאת התאמה.'}</motion.p>)}
                            </AnimatePresence>
                        </div>
                        <div className="mt-4 md:mt-0 md:w-auto lg:w-1/3 flex items-center gap-4">
                             <div className="flex-1">
                                <div className="flex justify-between items-center text-sm mb-1">
                                    <span className="font-medium text-gray-700">השלמת הפרופיל</span>
                                    <span className="font-bold text-cyan-600">{completionPercentage}%</span>
                                </div>
                                <Progress value={completionPercentage} className="h-2 bg-slate-200/70" />
                            </div>
                            <Button variant="ghost" size="icon" className="text-slate-500 hover:bg-slate-200/50 rounded-full flex-shrink-0" onClick={() => setIsMinimized(!isMinimized)} aria-label={isMinimized ? "הרחב" : "מזער"}>
                                {isMinimized ? <ChevronDown className="h-5 w-5" /> : <ChevronUp className="h-5 w-5" />}
                            </Button>
                        </div>
                    </div>
                    <AnimatePresence initial={false}>
                        {!isMinimized && (
                            <motion.div key="checklist-content" initial={{ height: 0, opacity: 0 }} animate={{ height: "auto", opacity: 1, transition: { opacity: { delay: 0.1 } } }} exit={{ height: 0, opacity: 0, transition: { duration: 0.3 } }} className="overflow-hidden" onMouseLeave={() => setActiveItemId(null)}>
                                <div className="mt-6 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4">
                                    {tasks.map((task) => (<ChecklistItem key={task.id} {...task} isActive={activeItemId === task.id} setActiveItemId={setActiveItemId} />))}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </motion.div>
        </AnimatePresence>
    );
};
--- End of Content for ProfileChecklist.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\profile\components\dashboard\UnifiedProfileDashboard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/(authenticated)/profile/components/dashboard/UnifiedProfileDashboard.tsx
"use client";

import React, { useState, useEffect, useCallback } from "react";
import { useSession } from "next-auth/react";
import Link from 'next/link';
import { useRouter } from "next/navigation";
import { toast } from "sonner";
import { cn } from "@/lib/utils";
import type { User as SessionUserType } from '@/types/next-auth';

import { ProfileChecklist } from "./ProfileChecklist";
// --- 1. ייבוא הקומפוננטה החדשה של יועץ ה-AI ---
import { AIProfileAdvisorDialog } from "../advisor/AIProfileAdvisorDialog";

// UI Components
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogTrigger } from "@/components/ui/dialog";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";

// Shared Profile Components
import {
  ProfileCard,
  PhotosSection,
  PreferencesSection,
  ProfileSection,
  QuestionnaireResponsesSection,
} from "@/app/components/profile";

// Icons
import { Eye, Loader2, Sparkles } from "lucide-react"; // הוספתי Sparkles לאייקונים

// Types
import type {
  UserProfile,
  UserImage,
  QuestionnaireResponse,
  UpdateValue,
} from "@/types/next-auth";

interface UnifiedProfileDashboardProps {
  viewOnly?: boolean;
  userId?: string;
  initialTab?: string;
}

const UnifiedProfileDashboard: React.FC<UnifiedProfileDashboardProps> = ({
  viewOnly = false,
  userId,
  initialTab = "overview",
}) => {
  const { data: session, status: sessionStatus, update: updateSession } = useSession();
  const router = useRouter();
  
  const [profileData, setProfileData] = useState<UserProfile | null>(null);
  const [images, setImages] = useState<UserImage[]>([]);
  const [questionnaireResponse, setQuestionnaireResponse] = useState<QuestionnaireResponse | null>(null);
  const [activeTab, setActiveTab] = useState(initialTab);
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState("");
  const [previewOpen, setPreviewOpen] = useState(false);

  const [hasSeenPreview, setHasSeenPreview] = useState(
    session?.user?.profile?.hasViewedProfilePreview || false
  );

  useEffect(() => {
    setActiveTab(initialTab);
  }, [initialTab]);

  const handleTabChange = (newTab: string) => {
    setActiveTab(newTab);
    router.push(`/profile?tab=${newTab}`, { scroll: false });
  };
  
  const isOwnProfile = !userId || (session?.user?.id === userId);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    setError("");
    try {
      const profileUrl = userId ? `/api/profile?userId=${userId}` : "/api/profile";
      const profileResponse = await fetch(profileUrl);
      const profileJson = await profileResponse.json();

      if (!profileResponse.ok || !profileJson.success) {
        throw new Error(profileJson.message || "Failed to load profile");
      }
      setProfileData(profileJson.profile);
      setImages(profileJson.images || []);
      if (profileJson.profile?.hasViewedProfilePreview) {
        setHasSeenPreview(true);
      }

      const questionnaireUrl = userId ? `/api/profile/questionnaire?userId=${userId}` : "/api/profile/questionnaire";
      const questionnaireFetchResponse = await fetch(questionnaireUrl);
      
      if (questionnaireFetchResponse.status === 404) {
        console.log("No questionnaire response found for user, setting to null.");
        setQuestionnaireResponse(null);
      } else if (questionnaireFetchResponse.ok) {
        const questionnaireJson = await questionnaireFetchResponse.json();
        if (questionnaireJson.success) {
          setQuestionnaireResponse(questionnaireJson.questionnaireResponse);
        } else {
          console.warn("Could not load questionnaire. Reason:", questionnaireJson.message);
          setQuestionnaireResponse(null);
        }
      } else {
        console.error("Failed to fetch questionnaire data. Status:", questionnaireFetchResponse.status);
        setQuestionnaireResponse(null);
      }

    } catch (err: unknown) {
      console.error("Failed to load profile data:", err);
      let errorMessage = "שגיאה בטעינת הנתונים";
      if (err instanceof Error) {
        errorMessage = err.message || errorMessage;
      }
      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    if (sessionStatus === 'authenticated') {
        loadData();
    }
  }, [sessionStatus, loadData]);

  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible' && sessionStatus === 'authenticated') {
        console.log("Tab is visible again, refetching data...");
        loadData();
      }
    };
    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [loadData, sessionStatus]);

  const handlePreviewClick = async () => {
    setPreviewOpen(true);
    if (!hasSeenPreview) {
      try {
        const response = await fetch('/api/profile/viewed-preview', {
          method: 'POST',
        });
        if (!response.ok) {
          throw new Error('Failed to update preview status');
        }
        setHasSeenPreview(true);
        toast.success("תודה! שלב 'הצפייה בתצוגה' הושלם.");
        await updateSession();
      } catch (error) {
        console.error("Error in handlePreviewClick:", error);
        toast.error("שגיאה בעדכון סטטוס הצפייה בתצוגה המקדימה.");
      }
    }
  };

  const handleSave = async (formData: Partial<UserProfile>) => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/profile/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await response.json();
      if (data.success && data.profile) {
        await updateSession();
        setProfileData(data.profile);
        setIsEditing(false);
        toast.success("הפרופיל עודכן בהצלחה");
        setError("");
      } else {
        setError(data.message || "שגיאה בעדכון הפרופיל");
        toast.error(data.message || "שגיאה בעדכון הפרופיל");
      }
    } catch (err) {
      console.error("Save error:", err);
      setError("שגיאה בעדכון הפרופיל");
      toast.error("שגיאה בעדכון הפרופיל");
    } finally {
      setIsLoading(false);
    }
  };

  const handleImageUpload = async (file: File) => {
    const formData = new FormData();
    formData.append("file", file);
    setIsLoading(true);
    try {
      const response = await fetch("/api/profile/images", {
        method: "POST",
        body: formData,
      });
      const data = await response.json();
      if (data.success) {
        setImages((prev) => [...prev, data.image]);
        await updateSession();
        toast.success("התמונה הועלתה בהצלחה");
        setError("");
      } else {
        setError(data.message || "שגיאה בהעלאת התמונה");
        toast.error(data.message || "שגיאה בהעלאת התמונה");
      }
    } catch (err) {
      console.error("Upload error:", err);
      setError("שגיאה בהעלאת התמונה");
      toast.error("שגיאה בהעלאת התמונה");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    setIsLoading(true);
    try {
      const response = await fetch(`/api/profile/images/${imageId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ isMain: true }),
      });
      const data = await response.json();
      if (data.success) {
        setImages(data.images);
        await updateSession();
        toast.success("התמונה הראשית עודכנה בהצלחה");
        setError("");
      } else {
        setError(data.message || "שגיאה בעדכון התמונה הראשית");
        toast.error(data.message || "שגיאה בעדכון התמונה הראשית");
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteImage = async (imageId: string) => {
    setIsLoading(true);
    try {
      const response = await fetch(`/api/profile/images/${imageId}`, {
        method: "DELETE",
      });
      const data = await response.json();
      if (data.success) {
        setImages((prev) => prev.filter((img) => img.id !== imageId));
        await updateSession();
        toast.success("התמונה נמחקה בהצלחה");
        setError("");
      } else {
        setError(data.message || "שגיאה במחיקת התמונה");
        toast.error(data.message || "שגיאה במחיקת התמונה");
      }
    } catch (err) {
      console.error("Delete image error:", err);
      setError("שגיאה במחיקת התמונה");
      toast.error("שגיאה במחיקת התמונה");
    } finally {
      setIsLoading(false);
    }
  };

  const handleQuestionnaireUpdate = async (world: string, questionId: string, value: UpdateValue) => {
    setIsLoading(true);
    try {
      const payload = { worldKey: world, questionId: questionId, value };
      const response = await fetch("/api/profile/questionnaire", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const data = await response.json();
      if (data.success) {
        setQuestionnaireResponse(data.data);
        toast.success("השאלון עודכן בהצלחה");
        setError("");
      } else {
        setError(data.message || "שגיאה בעדכון השאלון");
        toast.error(data.message || "שגיאה בעדכון השאלון");
      }
    } catch (err) {
      console.error("Failed to update questionnaire:", err);
      setError("שגיאה בעדכון השאלון");
      toast.error("שגיאה בעדכון השאלון");
    } finally {
      setIsLoading(false);
    }
  };
  
  if (isLoading && !profileData) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-cyan-50 via-white to-pink-50" dir="rtl">
        <div className="flex items-center gap-2 text-lg text-cyan-600">
          <Loader2 className="animate-spin h-6 w-6" />
          <span>טוען נתונים...</span>
        </div>
      </div>
    );
  }

  if (error && !profileData) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-red-50 via-white to-orange-50 p-4" dir="rtl">
        <Alert variant="destructive" className="max-w-md mx-auto">
          <AlertDescription className="text-center">{error}</AlertDescription>
        </Alert>
      </div>
    );
  }

  const user = session?.user as SessionUserType | undefined;
  
  return (
    <div className="relative min-h-screen w-full" dir="rtl">
      <div className="absolute inset-0 bg-gradient-to-br from-cyan-50 via-white to-pink-50 animate-gradient-slow -z-10" style={{ backgroundSize: "400% 400%" }} />
      <div className="absolute inset-0 opacity-10 bg-[radial-gradient(#06b6d4_1px,transparent_1px)] [background-size:30px_30px] -z-10"></div>
      <div className="relative max-w-7xl mx-auto py-8 sm:py-12 px-4 sm:px-6 lg:px-8 z-10">
        <div className="space-y-6 md:space-y-8">
          {error && <Alert variant="destructive"><AlertDescription>{error}</AlertDescription></Alert>}

          {isOwnProfile && user && (
            <>
              <ProfileChecklist 
                  user={{ ...user, images: images }}
                  hasSeenPreview={hasSeenPreview}
                  onPreviewClick={handlePreviewClick}
                  questionnaireResponse={questionnaireResponse}
              />
              {/* --- 2. הוספת הקומפוננטה החדשה כאן --- */}
              <div className="my-6 md:my-8 text-center">
                <AIProfileAdvisorDialog userId={user.id} />
              </div>
            </>
          )}

          {!viewOnly && isOwnProfile && (
            <div className="flex justify-center my-6 md:my-8">
              <div id="onboarding-target-preview-profile" className="flex justify-center my-6 md:my-8">
                <Dialog open={previewOpen} onOpenChange={setPreviewOpen}>
                  <DialogTrigger asChild>
                    <Button onClick={handlePreviewClick} variant="outline" size="lg" className="px-8 py-3 text-base sm:text-lg gap-2 rounded-full border-2 border-cyan-200 text-cyan-600 hover:bg-cyan-50 hover:border-cyan-400 transition-all duration-300 shadow-sm hover:shadow-md">
                      תצוגה מקדימה של הפרופיל <Eye className="w-5 h-5 sm:w-6 sm:h-6" />
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="w-[95vw] max-w-6xl max-h-[90vh] overflow-y-auto p-6 bg-white/95 backdrop-blur-md rounded-3xl shadow-2xl border-none" dir="rtl">
                    {profileData ? <ProfileCard profile={profileData} images={images} questionnaire={questionnaireResponse} viewMode="candidate" /> : <p className="text-center text-gray-500 py-10">טוען תצוגה מקדימה...</p>}
                  </DialogContent>
                </Dialog>
              </div>
            </div>
          )}
          
          <Tabs value={activeTab} onValueChange={handleTabChange} className="w-full">
            <div className="flex justify-center mb-6 md:mb-8">
              <ScrollArea dir="rtl" className="w-auto max-w-full">
                <TabsList className="h-auto p-1.5 bg-white/70 backdrop-blur-sm rounded-full shadow-md gap-1 inline-flex flex-nowrap">
                  <TabsTrigger value="overview" className="px-3 sm:px-6 py-1.5 sm:py-2 rounded-full text-xs sm:text-base font-medium text-gray-600 data-[state=active]:bg-gradient-to-r data-[state=active]:from-cyan-100 data-[state=active]:to-pink-100 data-[state=active]:text-cyan-700 data-[state=active]:shadow-inner transition-all duration-300 whitespace-nowrap">פרטים כלליים</TabsTrigger>
                  <TabsTrigger value="photos" className="px-3 sm:px-6 py-1.5 sm:py-2 rounded-full text-xs sm:text-base font-medium text-gray-600 data-[state=active]:bg-gradient-to-r data-[state=active]:from-cyan-100 data-[state=active]:to-pink-100 data-[state=active]:text-cyan-700 data-[state=active]:shadow-inner transition-all duration-300 whitespace-nowrap">תמונות</TabsTrigger>
                  <TabsTrigger value="preferences" className="px-3 sm:px-6 py-1.5 sm:py-2 rounded-full text-xs sm:text-base font-medium text-gray-600 data-[state=active]:bg-gradient-to-r data-[state=active]:from-cyan-100 data-[state=active]:to-pink-100 data-[state=active]:text-cyan-700 data-[state=active]:shadow-inner transition-all duration-300 whitespace-nowrap">העדפות</TabsTrigger>
                  <TabsTrigger value="questionnaire" className="px-3 sm:px-6 py-1.5 sm:py-2 rounded-full text-xs sm:text-base font-medium text-gray-600 data-[state=active]:bg-gradient-to-r data-[state=active]:from-cyan-100 data-[state=active]:to-pink-100 data-[state=active]:text-cyan-700 data-[state=active]:shadow-inner transition-all duration-300 whitespace-nowrap">שאלון</TabsTrigger>
                </TabsList>
                <ScrollBar orientation="horizontal" className="mt-1" />
              </ScrollArea>
            </div>
            <div className="bg-white/80 backdrop-blur-lg rounded-3xl shadow-xl p-6 md:p-8 lg:p-10 transition-all duration-300 ease-in-out">
              <TabsContent value="overview" id="onboarding-target-edit-profile" className="focus-visible:ring-0 focus-visible:ring-offset-0">
                {profileData ? <ProfileSection profile={profileData} isEditing={isEditing} setIsEditing={setIsEditing} onSave={handleSave} viewOnly={viewOnly || !isOwnProfile} /> : <p className="text-center text-gray-500 py-10">טוען סקירה כללית...</p>}
              </TabsContent>
              <TabsContent value="photos" id="onboarding-target-photos" className="focus-visible:ring-0 focus-visible:ring-offset-0">
                <PhotosSection images={images} isUploading={isLoading} disabled={viewOnly || !isOwnProfile} onUpload={handleImageUpload} onSetMain={handleSetMainImage} onDelete={handleDeleteImage} />
              </TabsContent>
              <TabsContent value="preferences" id="onboarding-target-preferences" className="focus-visible:ring-0 focus-visible:ring-offset-0">
                {profileData ? <PreferencesSection profile={profileData} isEditing={isEditing} setIsEditing={setIsEditing} onChange={handleSave} viewOnly={viewOnly || !isOwnProfile} /> : <p className="text-center text-gray-500 py-10">טוען העדפות...</p>}
              </TabsContent>
              <TabsContent value="questionnaire" id="onboarding-target-questionnaire-tab" className="focus-visible:ring-0 focus-visible:ring-offset-0">
                {questionnaireResponse ? <QuestionnaireResponsesSection questionnaire={questionnaireResponse} onUpdate={handleQuestionnaireUpdate} isEditable={!viewOnly && isOwnProfile} /> : <div className="text-center py-12 text-gray-500">{isLoading ? "טוען שאלון..." : "לא מולאו תשובות לשאלון."}{!isLoading && isOwnProfile && (<Button asChild variant="link" className="mt-2 text-cyan-600"><Link href="/questionnaire"> למילוי השאלון</Link></Button>)}</div>}
              </TabsContent>
            </div>
          </Tabs>
        </div>
      </div>
    </div>
  );
};

export default UnifiedProfileDashboard;
--- End of Content for UnifiedProfileDashboard.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\settings
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\(authenticated)\settings\page.tsx
--------------------------------------------------------------------------------
Content:
// --- START OF FILE page.tsx ---

"use client";

import { useSession } from "next-auth/react";
import AccountSettings from "@/components/account-settings";

export default function SettingsPage() {
  const { data: session, status } = useSession();

  if (status === "loading") return <div>Loading...</div>;
  if (status === "unauthenticated") return <div>Access Denied</div>;
  // It's good practice to check session?.user as well, though useSession types often guarantee it if status is "authenticated"
  if (!session?.user) return <div>Error: No user data or session invalid</div>;

  const userData = {
    id: session.user.id,
    email: session.user.email, // Assuming email is always present and a string
    firstName: session.user.firstName, // Assuming firstName is always present and a string
    lastName: session.user.lastName, // Assuming lastName is always present and a string
    role: session.user.role,
    status: session.user.status,
    isVerified: session.user.isVerified,
    lastLogin: session.user.lastLogin ?? null, // Fix: Convert undefined to null
    createdAt: session.user.createdAt,
  };

  return <AccountSettings user={userData} />;
}
// --- END OF FILE page.tsx ---
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * מטפל בבקשות POST לניתוח פרופיל המשתמש באמצעות AI.
 * הפונקציה מאמתת את המשתמש, יוצרת פרופיל נרטיבי מקיף,
 * שולחת אותו לניתוח AI, ומחזירה את התוצאה המובנית.
 */
export async function POST(req: Request) {
  try {
    // שלב 1: אימות משתמש
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    console.log(`[API analyze-my-profile] התחלת ניתוח עבור משתמש: ${userId}`);

    // שלב 2: ודא שהמשתמש והפרופיל קיימים לפני יצירת הנרטיב
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] לא נמצא פרופיל עבור משתמש: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // שלב 3: יצירת פרופיל נרטיבי מקיף
    // שימוש חוזר בלוגיקה הקיימת והמצוינת מ-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] נכשל ביצירת פרופיל נרטיבי עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }
    console.log(`[API analyze-my-profile] פרופיל נרטיבי נוצר בהצלחה. שולח לניתוח AI...`);

    // שלב 4: שליחת הנרטיב לניתוח AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] שירות ה-AI לא החזיר תוצאה עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }
    console.log(`[API analyze-my-profile] ניתוח AI התקבל בהצלחה.`);

    // שלב 5: החזרת התוצאה ללקוח
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * מטפל בבקשות POST לניתוח הצעת שידוך עבור המשתמש המחובר.
 * הפונקציה מאמתת את המשתמש, מאחזרת את הפרופיל שלו ואת הפרופיל של המשתמש המוצע,
 * יוצרת פרופילים נרטיביים עבור שניהם, שולחת אותם לניתוח AI מותאם למשתמש,
 * ומחזירה את התוצאה המובנית.
 */
export async function POST(req: Request) {
  try {
    // 1. אימות וקבלת המשתמש הנוכחי
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. קבלת ID של המשתמש המוצע מגוף הבקשה
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }

    console.log(`[API analyze-suggestion] התחלת ניתוח הצעה עבור משתמש: ${currentUserId} מול ${suggestedUserId}`);

    // 3. ודא ששני הפרופילים קיימים
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] אחד הפרופילים או שניהם לא נמצאו. נמצאו: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. יצירת פרופילים נרטיביים עבור שני המשתמשים במקביל
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] נכשל ביצירת פרופיל נרטיבי עבור אחד המשתמשים.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }
    console.log(`[API analyze-suggestion] שני הפרופילים הנרטיביים נוצרו בהצלחה. שולח לניתוח AI...`);

    // 5. שליחת הנרטיבים לניתוח AI מותאם למשתמש
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] שירות ה-AI לא החזיר תוצאת ניתוח הצעה.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }
    console.log(`[API analyze-suggestion] ניתוח הצעה התקבל בהצלחה.`);

    // 6. החזרת התוצאה ללקוח
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * פונקציית עזר שמריצה את תהליך העדכון ברקע
 * ומדפיסה לוג מפורט בסיומו.
 * @param userIds - מערך מזהי המשתמשים לעדכון
 * @param adminId - מזהה האדמין שהפעיל את התהליך
 */
async function runBulkUpdateAndLog(userIds: string[], adminId: string) {
  const totalUsers = userIds.length;
  // הודעת התחלה ברורה לתהליך הרקע
  console.log(`\n\n======================================================================`);
  console.log(`[AI Bulk Update - BG] Starting background process for ${totalUsers} users.`);
  console.log(`                 Initiated by admin: ${adminId}`);
  console.log(`======================================================================\n`);

  try {
    // נשתמש ב-Promise.allSettled כדי להמתין לסיום כל העדכונים, גם אם חלקם נכשלים
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // איסוף מזהי המשתמשים שנכשלו (אם יש כאלה)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // הדפסת סיכום מפורט
    console.log(`\n======================================================================`);
    console.log(`[AI Bulk Update - BG] Process Finished. Final Summary:`);
    console.log(`----------------------------------------------------------------------`);
    console.log(`  Total profiles to update: ${totalUsers}`);
    console.log(`  ✅ Successfully updated:    ${successCount}`);
    console.log(`  ❌ Failed to update:        ${failedCount}`);
    if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // במקרה של שגיאה קריטית בתהליך הרקע עצמו
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // כאן הלוג המקורי נשאר, כדי שתראה שה-API הופעל
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds, adminId).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth
# Generated on: 2025-06-24 07:23:34
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// הסר את הלוגים או הפעל אותם רק בסביבת פיתוח
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// פונקציה שבודקת אם ה-metadata מכיל את הסיסמה המוצפנת
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // וידוא שהטוקן הוא מספרי בן 6 ספרות
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "קוד אימות לא תקין. נדרש קוד בן 6 ספרות." },
        { status: 400 }
      );
    }

    // מציאת הטוקן
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "קוד לא תקף או שפג תוקפו" },
        { status: 400 }
      );
    }

    // בדיקה שהמטא-דאטה תקין ומכיל את הסיסמה המוצפנת
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "מידע אימות חסר או לא תקין, אנא התחל את התהליך מחדש" },
        { status: 400 }
      );
    }

    // כעת ניתן לגשת ל-hashedNewPassword בבטחה, המטא-דאטה אומת
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // עדכון הסיסמה והשלמת האימות
    await db.$transaction([
      // עדכון סיסמה
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // עדכון סטטוס האימות
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "הסיסמה עודכנה בהצלחה"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בהשלמת שינוי הסיסמה" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // ודא שהנתיב הזה נכון ומצביע על קובץ authOptions שלך
import prisma from '@/lib/prisma'; // ודא שהנתיב הזה נכון
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus } from '@prisma/client'; // ייבוא Gender ו-UserStatus

// Zod Schema - כולל phone לאימות מהלקוח
const completeProfileSchema = z.object({
  // --- הוספת שם פרטי ושם משפחה ---
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),
  // --- סוף הוספה ---
  phone: z.string().regex(/^0\d{9}$/, "Invalid phone number format (e.g., 0501234567)"),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });
  console.log("[API /api/auth/complete-profile] Request Headers:", JSON.stringify(headersObject, null, 2));

  // !!! הסר את זה בסביבת Production !!!
  // console.log("[API /api/auth/complete-profile] DEBUG: NEXTAUTH_SECRET value (first 5 chars):", process.env.NEXTAUTH_SECRET?.substring(0, 5) || "NOT SET");

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    console.log("[API /api/auth/complete-profile] Session object from getServerSession:", JSON.stringify(session, null, 2));

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);
    console.log(`[API /api/auth/complete-profile] User email from session: ${session.user.email}`);

    if (session.user.isPhoneVerified) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} phone is ALREADY verified according to session. Proceeding, but this might indicate a flow issue.`);
    }
    if (session.user.isProfileComplete) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} profile is ALREADY complete according to session. Proceeding, but this might indicate a flow issue.`);
    }

    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
        console.log("[API /api/auth/complete-profile] Request body parsed successfully:", JSON.stringify(body, null, 2));
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    const {
        // --- הוספת שם פרטי ושם משפחה ---
        firstName,
        lastName,
        // --- סוף הוספה ---
        phone,
        gender,
        birthDate,
        maritalStatus,
        height,
        occupation,
        education
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);
    console.log("[API /api/auth/complete-profile] Data to be saved:", JSON.stringify(validation.data, null, 2));

    const updatedUser = await prisma.$transaction(async (tx) => {
      console.log(`[API /api/auth/complete-profile] Inside transaction for user ${userId}. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted for user ${userId}.`);

      console.log(`[API /api/auth/complete-profile] Updating User record for user ${userId} (names, phone, isProfileComplete, status)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          // --- הוספת שם פרטי ושם משפחה ---
          firstName: firstName,
          lastName: lastName,
          // --- סוף הוספה ---
          phone: phone,
          isProfileComplete: true,
          // אם המשתמש מגיע לכאן, סביר להניח שאימות המייל הושלם (אם היה כזה).
          // לכן, הסטטוס צריך לעבור ל-PENDING_PHONE_VERIFICATION.
          // אם אימות הטלפון הוא אופציונלי או לא השלב הבא המיידי, ייתכן ו-ACTIVE הוא הסטטוס הנכון.
          status: UserStatus.PENDING_PHONE_VERIFICATION, // ודא שזה הסטטוס הנכון בהתאם לזרימה
          updatedAt: new Date(),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true
         }
      });
      console.log(`[API /api/auth/complete-profile] User record updated for user ${userId}. New profile status: isProfileComplete=${user.isProfileComplete}, isPhoneVerified=${user.isPhoneVerified}, status=${user.status}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    console.log("[API /api/auth/complete-profile] Returning success response with user data:", JSON.stringify({ message: "Profile completed successfully", user: updatedUser }, null, 2));
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error during processing:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Known Request Error - Code: ${error.code}`);
        console.error("[API /api/auth/complete-profile] Prisma Error Meta:", error.meta);
        console.error("[API /api/auth/complete-profile] Prisma Error Message:", error.message);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone') && target?.includes('User')) {
                 return NextResponse.json({ error: 'מספר טלפון זה כבר רשום במערכת.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error (Prisma Validation Error).' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- הוספה ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- סוף הוספה ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "קישור לא תקין או שפג תוקפו. אנא בקש מהשדכן לשלוח הזמנה חדשה." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // עדכון הסיסמה, סטטוס המשתמש, וסטטוס האימות בטרנזקציה אחת
    await prisma.$transaction(async (tx) => {
      // עדכון סיסמה, אימות מייל, וסטטוס המשתמש
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- הוספה ---
          isVerified: true, // המייל אומת מכיוון שהמשתמש הגיע מהקישור
          status: UserStatus.PENDING_PHONE_VERIFICATION, // העבר את המשתמש לשלב הבא
          // isProfileComplete נשאר false כי הוא עדיין צריך למלא פרטים
          // --- סוף הוספה ---
        },
      });

      // עדכון סטטוס האימות (הטוקן נוצל)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "החשבון הוגדר בהצלחה! כעת ניתן להתחבר עם הסיסמה החדשה." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "אירעה שגיאה בהגדרת החשבון." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `שגיאת מסד נתונים בעת מחיקת המשתמש (קוד: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || 'שגיאה במחיקת החשבון.', status: 400 };
    }

    return { message: 'אירעה שגיאה בלתי צפויה במחיקת החשבון.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. לא זוהתה סשן פעיל.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: 'החשבון נמחק בהצלחה.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: 'המשתמש המבוקש למחיקה לא נמצא.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: Request) {
  try {
    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    // הוספת בדיקה: אם למשתמש אין סיסמה (למשל, נרשם דרך OAuth)
    if (!user.password) {
      return NextResponse.json(
        { error: "לא הוגדרה סיסמה לחשבון זה. ייתכן שנרשמת באמצעות שירות חיצוני." },
        { status: 400 }
      );
    }

    // בדיקת סיסמה נוכחית
    // כעת, user.password מובטח להיות string
    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "סיסמה נוכחית שגויה" },
        { status: 400 }
      );
    }

    // הצפנת הסיסמה החדשה
    const hashedNewPassword = await hash(newPassword, 12);

    // יצירת קוד אימות בן 6 ספרות באמצעות שירות האימות
    // שינוי שם הפונקציה והוספת פרמטר target
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email, // הוספת user.email כפרמטר target
      24 // תקף ל-24 שעות (expiresInHours)
    );

    // שמירת הסיסמה המוצפנת במטא-דאטה של האימות
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // שליחת מייל עם קוד האימות
    await emailService.sendPasswordReset(user.email, verification.token);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בתהליך שינוי הסיסמה" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/register/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, UserRole, UserStatus, Prisma, VerificationType, UserSource  } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 

const prisma = new PrismaClient();

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
        // For now, we'll keep it.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
}

function handleError(error: unknown): { message: string; status: number } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: 'משתמש עם כתובת אימייל זו כבר קיים במערכת.', status: 409 };
          }
          return { message: `משתמש עם פרטים אלה כבר קיים במערכת (קוד ${error.code}).`, status: 409 };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `שגיאת תלות בנתונים (שדה: ${fieldName || 'לא ידוע'}). אנא נסה שנית.`, status: 500};
        }
        case 'P2014': return { message: 'שגיאה בנתונים שהוזנו.', status: 400 };
        default: 
            return { message: `שגיאה בשמירת הנתונים (קוד שגיאת DB: ${error.code}).`, status: 500 };
      }
    }
    if (error instanceof Error) {
       if (error.message === 'משתמש עם כתובת אימייל זו כבר קיים במערכת.') {
           return { message: error.message, status: 409 };
       }
       if (['חסרים פרטים חובה', 'כתובת אימייל לא תקינה', 'הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר'].includes(error.message)) {
           return { message: error.message, status: 400 };
       }
       if (error.message.includes('אירעה שגיאה ביצירת קוד אימות') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: 'אירעה שגיאה ביצירת רשומת האימות עקב בעיית תלות. אנא נסה שנית.', status: 500 };
       }
      return { message: error.message, status: 400 }; 
    }
    return { message: 'אירעה שגיאה בלתי צפויה.', status: 500 };
}


export async function POST(req: Request) {
  logger.info('Initial registration process initiated');

  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('חסרים פרטים חובה');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('כתובת אימייל לא תקינה');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('משתמש עם כתובת אימייל זו כבר קיים במערכת.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(), 
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });
    
    let emailSentSuccess = false;
    const emailOtpExpiryText = "שעה אחת"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
      await emailService.sendVerificationEmail({
        email: result.user.email,
        verificationCode: result.generatedOtp, 
        firstName: result.user.firstName,
        expiresIn: emailOtpExpiryText 
      });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = 'החשבון נוצר בהצלחה. ';
    if (emailSentSuccess) {
        responseMessage += `נשלח קוד אימות לכתובת הדוא"ל שלך (${result.user.email}). אנא הזן את הקוד כדי להמשיך.`;
    } else {
        responseMessage += 'הייתה בעיה בשליחת קוד האימות. תוכל לבקש קוד חדש במסך הבא או לפנות לתמיכה.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { userId: result.user.id });
    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id, 
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType, UserStatus, VerificationStatus } from '@prisma/client'; // Added VerificationStatus
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

const prisma = new PrismaClient(); // Consider using your global prisma instance if you have one at @/lib/prisma

const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "כתובת מייל לא תקינה" }),
});

// Helper for logging (consistent with your existing logs)
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string; // <--- הוספה של המאפיין החסר
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus; // For logging user or verification status
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: Request) {
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined; // Define type for requestBody
  try {
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "כתובת מייל לא תקינה" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    logger.info('Processing password reset request', { action, email: normalizedEmail });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    const genericSuccessMessage = 'אם קיימת כתובת מייל זו במערכת וניתן לאפס עבורה סיסמה, קוד אימות נשלח כעת.';

    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING, // Use VerificationStatus enum
        },
        data: {
            status: VerificationStatus.EXPIRED, // Use VerificationStatus enum
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60
    );
    // Now this log line is valid because verificationId is in LogMetadata
    logger.info('Password reset OTP created in VerificationService', { action, userId: user.id, verificationId: passwordResetVerification.id });

    try {
      await emailService.sendPasswordResetOtpEmail({
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: `${expiresInMinutes} דקות`,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message, stack: (process.env.NODE_ENV === 'development' ? error.stack : undefined) } : String(error),
    });

    return NextResponse.json(
      { success: false, error: 'אירעה שגיאה בתהליך. אנא נסה שנית מאוחר יותר.' },
      { status: 500 }
    );
  } finally {
    // Only disconnect if prisma instance was created locally in this file
    // If using a global instance from @/lib/prisma, it's usually managed globally
    // await prisma.$disconnect().catch(e => logger.error('Failed to disconnect Prisma in request-password-reset', { error: e }));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Adjust path if needed
import prisma from '@/lib/prisma'; // Adjust path if needed
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService'; // Adjust path if needed
import { VerificationType } from '@prisma/client'; // Import necessary enums/types

// --- Configuration ---
// How long (in seconds) the user must wait between resend requests
const RESEND_RATE_LIMIT_SECONDS = 60;

// --- Helper: Logger (optional but recommended) ---
const logger = {
    info: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...(meta || {}) }));
    },
    warn: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...(meta || {}) }));
    },
    error: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      // במקרה של שגיאה, נרצה אולי לטפל ב-meta בצורה שונה אם הוא אובייקט Error
      let logMeta = meta || {};
      if (meta instanceof Error) {
          // אם ה-meta הוא אובייקט Error, נרצה אולי לפרק אותו
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
  };
// --- End Helper ---


// --- Main POST Handler ---
export async function POST() {
    logger.info("Resend phone code request received");

    // 1. --- Authentication Check ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });
    // --- End Authentication Check ---

    try {
        // 2. --- Find Last Pending Verification ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING', // Only find codes that haven't been used, expired, or failed
            },
            orderBy: {
                createdAt: 'desc' // Get the most recent one if multiple exist (shouldn't happen often with cleanup)
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            // This could mean the user is already verified, the code expired and wasn't updated, etc.
            // Provide a generic message.
            return NextResponse.json({ error: 'לא נמצאה בקשת אימות פעילה. ייתכן שכבר אימתת את מספרך או שהקוד פג תוקף.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });
        // --- End Find Last Pending Verification ---


        // 3. --- Rate Limiting Check ---
        const now = new Date();
        // Use 'createdAt' as the timestamp of the last *send attempt* for pending codes
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: `אנא המתן ${timeLeft} שניות לפני בקשת קוד חדש.` }, { status: 429 }); // Too Many Requests
        }
        logger.info("Rate limit check passed", { userId });
        // --- End Rate Limiting Check ---


        // 4. --- Determine Target Phone and User Name ---
        // Initialize with 'let' to allow modification in fallback
        let targetPhone = lastVerification.target;
        // Try to get name from session first for personalization
        let userFirstName = session.user.firstName || ''; // Use empty string as fallback

        // Fallback: If target phone wasn't stored in verification, fetch from User model
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true } // Select only needed fields
             });
             if (!user?.phone) {
                // This is a more critical error, shouldn't happen if registration flow is correct
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                // Don't expose internal details, give a generic error
                return NextResponse.json({ error: 'שגיאה: לא ניתן לאתר את מספר הטלפון לשליחת הקוד.' }, { status: 500 });
             }
             targetPhone = user.phone; // Assign the fetched phone number
             userFirstName = user.firstName || ''; // Update first name if fetched
             logger.info("Successfully fetched phone number from user model as fallback", { userId });
        }

        // Final check to ensure we have a phone number
        if (!targetPhone) {
             logger.error(`Target phone is still null/undefined after fallback for user ${userId}.`);
             return NextResponse.json({ error: 'שגיאה: לא ניתן לקבוע את מספר הטלפון ליצירת קשר.' }, { status: 500 });
        }
        // --- End Determine Target Phone ---


        // 5. --- Generate New OTP ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // New 10-minute expiration
        logger.info("Generated new OTP", { userId });
        // --- End Generate New OTP ---


        // 6. --- Update Verification Record ---
        // Update the *existing* pending record with the new code, expiry, reset attempts, and timestamp
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // Reset attempts count for the new code
                createdAt: new Date() // Update timestamp to reflect this new send attempt (for rate limiting)
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });
        // --- End Update Verification Record ---


        // 7. --- Send New OTP via WhatsApp ---
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName // Pass name for personalization
        );

        if (!otpSent) {
            // Log the failure but still return a potentially helpful message to the user
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            // Let the user know there was an issue, maybe suggest trying again later
            return NextResponse.json({ error: 'שליחת קוד האימות החדש באמצעות WhatsApp נכשלה. אנא נסה שוב בעוד מספר רגעים.' }, { status: 500 });
        }
        // --- End Send New OTP ---


        // 8. --- Success Response ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: 'קוד אימות חדש נשלח בהצלחה באמצעות WhatsApp.' }, { status: 200 });
        // --- End Success Response ---

    } catch (error: unknown) { // Catch errors as unknown
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id, // Log userId if available
            error: error instanceof Error ? { name: error.name, message: error.message, stack: error.stack } : String(error)
        });
        // Return a generic server error response
        return NextResponse.json({ error: 'אירעה שגיאה פנימית בשרת. נסה שוב מאוחר יותר.' }, { status: 500 });
    } finally {
        // Disconnect Prisma client if necessary (depends on Prisma setup)
        // await prisma.$disconnect();
        // logger.info("Database connection closed (if applicable)");
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:

import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { randomBytes } from "crypto";
import { emailService } from "@/lib/email/emailService";
import { VerificationType } from "@prisma/client";

export async function POST(req: Request) {
  try {
    const { email, type } = await req.json();

    if (!email || !type) {
      return NextResponse.json(
        { error: "חסרים פרטים נדרשים" },
        { status: 400 }
      );
    }

    // מציאת המשתמש
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { error: "לא נמצא משתמש עם כתובת האימייל הזו" },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { error: "המשתמש כבר מאומת" },
        { status: 400 }
      );
    }

    // יצירת טוקן אימות חדש
    const verification = await prisma.verification.create({
      data: {
        userId: user.id,
        type: type as VerificationType,
        token: randomBytes(32).toString('hex'),
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // תוקף ל-24 שעות
        status: 'PENDING',
        attempts: 0
      }
    });

    // שליחת מייל אימות חדש
    // *** התיקון כאן: שימוש ב-verificationCode במקום verificationLink ***
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: verification.token, // שונה מ-verificationLink
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({
      success: true,
      message: "מייל אימות חדש נשלח בהצלחה"
    });

  } catch (error) {
    console.error('Resend verification error:', error);
    const errorMessage = error instanceof Error ? error.message : "שגיאה בשליחת מייל האימות";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-verification-code/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType, UserStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';

const prisma = new PrismaClient();

// Updated LogMetadata type
type LogMetadata = {
  email?: string;
  error?: unknown;
  timestamp?: string; // Note: logger already adds a timestamp. This allows overriding or adding a specific one.
  userId?: string;
  verificationId?: string; // Added to fix the error
  status?: UserStatus;     // Added for metadata in a logger.warn call
  isVerified?: boolean;    // Added for metadata in a logger.warn call
};

// Updated logger object with 'warn' method
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })) // Added 'warn' method
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: Request) {
  let requestBody: ResendCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });


    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: 'חסרה כתובת אימייל.' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    logger.info('Attempting to resend verification code', { email: normalizedEmail });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail }); // Now valid
      return NextResponse.json({ success: false, error: 'משתמש עם כתובת אימייל זו אינו רשום.' }, { status: 404 });
    }

    // ודא שהמשתמש עדיין צריך לאמת אימייל
    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        // This log call now correctly uses properties defined in LogMetadata
        logger.warn('User email already verified or not pending email verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: 'כתובת האימייל כבר מאומתת או שאינה ממתינה לאימות.' }, { status: 400 });
    }
    
    // יצירת קוד אימות חדש ושליחתו
    const expiresInHoursForOtp = 1; // תוקף של שעה
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email, // השתמש באימייל מהמשתמש (שכבר מנורמל)
      expiresInHoursForOtp
    );
    // This log call now correctly uses verificationId defined in LogMetadata
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });


    // שליחת המייל עם הקוד החדש
    const emailOtpExpiryText = "שעה אחת"; // התאם ל-expiresInHoursForOtp
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    return NextResponse.json({
      success: true,
      message: `קוד אימות חדש נשלח לכתובת ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = 'אירעה שגיאה בשליחה חוזרת של הקוד.';
    const errorStatus = 500;

    if (error instanceof Error) {
        if (error.message === 'אירעה שגיאה ביצירת קוד אימות') {
            errorMessage = error.message; // השתמש בהודעה הספציפית מהשירות
        }
        // אפשר להוסיף טיפול בשגיאות ספציפיות אחרות משירות המייל למשל
    }
    

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect();
    logger.info('Database connection closed for resend-verification-code');
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType} from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService'; // For password change confirmation
import { hash } from 'bcryptjs';
import { z } from 'zod';

const prisma = new PrismaClient();

const resetPasswordSchema = z.object({
  email: z.string().email({ message: "כתובת מייל לא תקינה" }),
  otp: z.string().length(6, { message: "קוד האימות חייב להכיל 6 ספרות" }).regex(/^\d+$/, { message: "קוד אימות יכול להכיל ספרות בלבד" }),
  newPassword: z.string().min(8, { message: "הסיסמה חייבת להכיל לפחות 8 תווים" })
    .regex(/[a-z]/, { message: "הסיסמה חייבת להכיל לפחות אות קטנה אחת באנגלית" })
    .regex(/[A-Z]/, { message: "הסיסמה חייבת להכיל לפחות אות גדולה אחת באנגלית" })
    .regex(/[0-9]/, { message: "הסיסמה חייבת להכיל לפחות ספרה אחת" }),
});

// Helper for logging
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: Request) {
  const action = "reset-password-with-otp";
  let requestBody;

  try {
    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid input for password reset', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "נתונים לא תקינים.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];
      
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });

    // Step 1: Verify the OTP using VerificationService
    // This should not mark the verification as 'COMPLETED' yet for PASSWORD_RESET type.
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    // If verifyCode doesn't throw an error, it means the OTP is valid (not expired, not too many attempts, exists).
    // It returns { success: true, message: 'Code verified.', userId: '...', id: '...' }
    
   if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      // This scenario should ideally be handled by verifyCode throwing an error.
      // If verifyCode is changed to return success:false instead of throwing for some cases, handle here.
      logger.error('OTP verification failed or did not return expected data', { 
        action, 
        email: normalizedEmail, 
        error: verificationResult // Changed 'result' to 'error'
      });
      throw new Error(verificationResult.message || 'שגיאה באימות הקוד.');
    }
    
    const userId = verificationResult.userId;
    const verificationId = verificationResult.id; // ID of the verification record

    logger.info('OTP verified successfully for password reset', { action, email: normalizedEmail, userId, verificationId });

    // Step 2: Hash the new password
    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    // Step 3: Update the user's password in the database
    await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
        // Optional: Reset login attempts if you track them, or other security measures
      },
    });
    logger.info('User password updated in database', { action, userId });

    // Step 4: Explicitly mark the verification record as COMPLETED
    await VerificationService.completeVerification(verificationId);
    logger.info('Password reset verification record marked as completed', { action, verificationId });

    // Step 5: Optional - Send password change confirmation email
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { email: true, firstName: true } });
    if (user) {
        try {
            await emailService.sendPasswordChangedConfirmationEmail({
                email: user.email,
                firstName: user.firstName,
            });
            logger.info('Password change confirmation email sent', { action, userId });
        } catch (emailError) {
            logger.error('Failed to send password change confirmation email', {
                action,
                userId,
                error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
            });
            // Non-critical error for the overall success of password reset, proceed
        }
    }

    return NextResponse.json({ success: true, message: 'הסיסמה אופסה בהצלחה. כעת תוכל להתחבר עם הסיסמה החדשה.' }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = typeof requestBody === 'object' && requestBody && 'email' in requestBody ? String(requestBody.email) : undefined;
    logger.error('Error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message, stack: (process.env.NODE_ENV === 'development' ? error.stack : undefined) } : String(error),
    });

    let errorMessage = 'אירעה שגיאה באיפוס הסיסמה.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        'הקוד כבר נוצל.', // This shouldn't happen if completeVerification is called after successful password update.
        'תוקף הקוד פג. אנא בקש קוד חדש.',
        'קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.',
        'קוד אימות שגוי.',
        'חרגת ממספר ניסיונות האימות המותר. אנא בקש קוד חדש.',
        'שגיאה פנימית: אימות הקוד הצליח אך לא נמצא משתמש משויך.',
        'שגיאה פנימית: רשומת האימות אינה משויכת למשתמש.' // from verifyCode
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
        if (error.message.includes("פג תוקפו")) errorStatus = 410; // Gone
        if (error.message.includes("חרגת ממספר ניסיונות")) errorStatus = 429; // Too Many Requests
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => logger.error('Failed to disconnect Prisma in reset-password API', { error: e }));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST() {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. קבל את פרטי המשתמש מה-DB (בעיקר מספר הטלפון)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // שגיאה זו לא אמורה לקרות אם המשתמש הגיע לכאן דרך השלמת פרופיל
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. יצירת OTP חדש
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 דקות תפוגה

        // 3. שמירת/עדכון רשומת האימות
        // מחק רשומות קודמות לאותו משתמש כדי למנוע בלבול
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // צור רשומה חדשה
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. שליחת ה-OTP בוואטסאפ
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // החזר שגיאה כדי שהקליינט יוכל להציג הודעה מתאימה
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
export const runtime = 'nodejs';

import { NextResponse } from "next/server";
import { PrismaClient, VerificationType } from "@prisma/client";
import { generateToken } from "@/lib/tokens";
import { emailService } from "@/lib/email/emailService";

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { email } = await req.json();
    
    if (!email) {
      return NextResponse.json({ error: "אימייל הוא שדה חובה" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return NextResponse.json({ error: "משתמש לא נמצא" }, { status: 404 });
    }

    await prisma.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.EMAIL,
        status: "PENDING"
      },
      data: { status: "EXPIRED" }
    });

    const token = await generateToken();
    const verification = await prisma.verification.create({
      data: {
        token,
        userId: user.id,
        type: VerificationType.EMAIL,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
        status: "PENDING"
      }
    });

    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: verification.token, // Changed from verificationLink to verificationCode
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({ success: true }, { status: 200 });

  } catch (error) {
    console.error('Error sending verification:', error);
    return NextResponse.json({ error: "שגיאה בשליחת קוד האימות" }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().regex(/^0\d{9}$/, "Invalid phone number format (e.g., 0501234567)"),
});

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. בדוק שהמספר החדש לא תפוס על ידי משתמש מאומת אחר
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } // לא המשתמש הנוכחי
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: 'מספר הטלפון כבר רשום ופעיל במערכת עבור משתמש אחר.' }, { status: 409 }); // Conflict
          }

        // 2. עדכן את מספר הטלפון של המשתמש
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // קח את השם המעודכן אם צריך
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. צור OTP חדש
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 דקות תפוגה

        // 4. צור/עדכן רשומת אימות עבור המספר החדש
        // בטל רשומות קודמות אם היו
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // סמן קודמים כפגי תוקף
         });
         // צור רשומה חדשה
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // המספר החדש
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. שלח את ה-OTP למספר החדש
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // החזר שגיאה, ייתכן שהמספר החדש לא תקין בוואטסאפ
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // הגדרת error כ-unknown
        console.error("API update-and-resend: An error occurred:", error);

        // טיפול בשגיאות ספציפיות
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // שגיאת כפילות - למרות שבדקנו, ייתכן מצב race condition
            return NextResponse.json({ error: 'מספר הטלפון כבר רשום במערכת.' }, { status: 409 });
        }

        // שגיאה כללית
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextResponse } from 'next/server';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId כאן יכול להיות string או undefined אם הוא לא קיים במטאדאטה
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: Request) {
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: 'חסרים פרטי אימייל או קוד.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `פורמט קוד לא תקין. הקוד צריך להכיל ${OTP_LENGTH_FROM_SERVICE} ספרות.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- התיקון מתחיל כאן ---
    // וודא ש-userId קיים והוא מחרוזת לפני שנמשיך
    // סביר להניח ש-verificationResult.userId יכול להיות string | null
    // על פי ההגדרה של VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // זרוק שגיאה שתטופל בלוק ה-catch הכללי, או טפל בה באופן ספציפי יותר
      // שגיאה זו מצביעה על בעיה לוגית פנימית אם הקוד אומת אך אין משתמש משויך
      throw new Error('שגיאה פנימית: לא נמצא משתמש משויך לאימות לאחר אימות קוד מוצלח.');
    }
    
    // כעת, לאחר הבדיקה, TypeScript יכול להסיק (או שנוכל להצהיר במפורש)
    // ש-userId הוא string.
    const userId: string = verificationResult.userId; 
    // --- סוף התיקון ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, // כאן userId מובטח להיות string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: 'כתובת האימייל אומתה בהצלחה! מתבצעת התחברות אוטומטית...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = 'אירעה שגיאה באימות הקוד.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        'הקוד כבר נוצל.', 
        'תוקף הקוד פג. אנא בקש קוד חדש.', 
        'קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.', 
        'קוד אימות שגוי.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === 'שגיאה פנימית: לא נמצא משתמש משויך לאימות.' || 
                 error.message === 'שגיאה פנימית: לא נמצא משתמש משויך לאימות לאחר אימות קוד מוצלח.') { // הוספת השגיאה החדשה אם רוצים טיפול מיוחד
        errorMessage = 'אירעה שגיאה פנימית. אנא נסה שנית מאוחר יותר.';
        // errorStatus נשאר 500 כברירת מחדל לשגיאות פנימיות, או שתשנה לפי הצורך
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus } from '@prisma/client';
import { z } from 'zod';

const verifyCodeSchema = z.object({
  code: z.string().length(6, "Verification code must be 6 digits").regex(/^\d+$/, "Invalid code format"),
});

// Define Max Attempts
const MAX_VERIFICATION_ATTEMPTS = 5;

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = verifyCodeSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { code } = validation.data;

        // 1. מצא את רשומת האימות הרלוונטית
        const verification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc' // קח את הרשומה האחרונה
            }
        });

        if (!verification) {
            return NextResponse.json({ error: 'No pending verification found or already verified.' }, { status: 404 });
        }

        // 2. בדוק אם פג תוקף
        if (new Date() > verification.expiresAt) {
            // עדכן את סטטוס הרשומה ל-EXPIRED
            await prisma.verification.update({
                where: { id: verification.id },
                data: { status: 'EXPIRED' }
            });
            return NextResponse.json({ error: 'Verification code expired.' }, { status: 410 }); // 410 Gone
        }

        // 3. בדוק מספר ניסיונות
        if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
             // עדכן סטטוס ל-FAILED אם עבר את המגבלה
            await prisma.verification.update({
                where: { id: verification.id },
                data: { status: 'FAILED' }
            });
            return NextResponse.json({ error: 'Too many verification attempts.' }, { status: 429 }); // 429 Too Many Requests
        }

        // 4. השווה את הקודים
        if (verification.token !== code) {
            // עדכן מספר ניסיונות
            await prisma.verification.update({
                where: { id: verification.id },
                data: { attempts: { increment: 1 } }
            });
            const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - (verification.attempts + 1);
            return NextResponse.json({ error: `Invalid verification code. ${attemptsLeft} attempts remaining.` }, { status: 400 });
        }

        // 5. אימות הצליח! עדכן את המשתמש ואת רשומת האימות
        const [, updatedUser] = await prisma.$transaction([
            prisma.verification.update({
                where: { id: verification.id },
                data: {
                    status: 'COMPLETED',
                    completedAt: new Date(),
                    attempts: verification.attempts + 1
                 }
            }),
            prisma.user.update({
                where: { id: userId },
                data: {
                    isPhoneVerified: true,
                    isProfileComplete: true, // לאחר אימות טלפון, הפרופיל נחשב שלם
                    status: UserStatus.ACTIVE, // הפוך את המשתמש לפעיל
                    updatedAt: new Date(),
                },
                select: { // החזר רק את המידע הנדרש לעדכון הסשן
                    id: true,
                    isPhoneVerified: true,
                    isProfileComplete: true,
                    status: true,
                 }
            })
        ]);

        console.log(`API verify-phone-code: Phone verified successfully for user ${userId}`);

        // החזר את פרטי המשתמש המעודכנים כדי שהקליינט יוכל לעדכן את הסשן
        return NextResponse.json({
             message: 'Phone number verified successfully!',
             user: updatedUser // מכיל isPhoneVerified, isProfileComplete, status
             }, { status: 200 });

    } catch (error) {
        console.error("API verify-phone-code: An error occurred:", error);
        if (error instanceof z.ZodError) { // Catch potential Zod errors during validation
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

--- End of Content for auth_contents.txt ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// הסר את הלוגים או הפעל אותם רק בסביבת פיתוח
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// פונקציה שבודקת אם ה-metadata מכיל את הסיסמה המוצפנת
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // וידוא שהטוקן הוא מספרי בן 6 ספרות
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "קוד אימות לא תקין. נדרש קוד בן 6 ספרות." },
        { status: 400 }
      );
    }

    // מציאת הטוקן
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "קוד לא תקף או שפג תוקפו" },
        { status: 400 }
      );
    }

    // בדיקה שהמטא-דאטה תקין ומכיל את הסיסמה המוצפנת
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "מידע אימות חסר או לא תקין, אנא התחל את התהליך מחדש" },
        { status: 400 }
      );
    }

    // כעת ניתן לגשת ל-hashedNewPassword בבטחה, המטא-דאטה אומת
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // עדכון הסיסמה והשלמת האימות
    await db.$transaction([
      // עדכון סיסמה
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // עדכון סטטוס האימות
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "הסיסמה עודכנה בהצלחה"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בהשלמת שינוי הסיסמה" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // ודא שהנתיב הזה נכון ומצביע על קובץ authOptions שלך
import prisma from '@/lib/prisma'; // ודא שהנתיב הזה נכון
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus } from '@prisma/client'; // ייבוא Gender ו-UserStatus

// Zod Schema - כולל phone לאימות מהלקוח
const completeProfileSchema = z.object({
  // --- הוספת שם פרטי ושם משפחה ---
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),
  // --- סוף הוספה ---
  phone: z.string().regex(/^0\d{9}$/, "Invalid phone number format (e.g., 0501234567)"),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });
  console.log("[API /api/auth/complete-profile] Request Headers:", JSON.stringify(headersObject, null, 2));

  // !!! הסר את זה בסביבת Production !!!
  // console.log("[API /api/auth/complete-profile] DEBUG: NEXTAUTH_SECRET value (first 5 chars):", process.env.NEXTAUTH_SECRET?.substring(0, 5) || "NOT SET");

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    console.log("[API /api/auth/complete-profile] Session object from getServerSession:", JSON.stringify(session, null, 2));

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);
    console.log(`[API /api/auth/complete-profile] User email from session: ${session.user.email}`);

    if (session.user.isPhoneVerified) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} phone is ALREADY verified according to session. Proceeding, but this might indicate a flow issue.`);
    }
    if (session.user.isProfileComplete) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} profile is ALREADY complete according to session. Proceeding, but this might indicate a flow issue.`);
    }

    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
        console.log("[API /api/auth/complete-profile] Request body parsed successfully:", JSON.stringify(body, null, 2));
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    const {
        // --- הוספת שם פרטי ושם משפחה ---
        firstName,
        lastName,
        // --- סוף הוספה ---
        phone,
        gender,
        birthDate,
        maritalStatus,
        height,
        occupation,
        education
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);
    console.log("[API /api/auth/complete-profile] Data to be saved:", JSON.stringify(validation.data, null, 2));

    const updatedUser = await prisma.$transaction(async (tx) => {
      console.log(`[API /api/auth/complete-profile] Inside transaction for user ${userId}. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted for user ${userId}.`);

      console.log(`[API /api/auth/complete-profile] Updating User record for user ${userId} (names, phone, isProfileComplete, status)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          // --- הוספת שם פרטי ושם משפחה ---
          firstName: firstName,
          lastName: lastName,
          // --- סוף הוספה ---
          phone: phone,
          isProfileComplete: true,
          // אם המשתמש מגיע לכאן, סביר להניח שאימות המייל הושלם (אם היה כזה).
          // לכן, הסטטוס צריך לעבור ל-PENDING_PHONE_VERIFICATION.
          // אם אימות הטלפון הוא אופציונלי או לא השלב הבא המיידי, ייתכן ו-ACTIVE הוא הסטטוס הנכון.
          status: UserStatus.PENDING_PHONE_VERIFICATION, // ודא שזה הסטטוס הנכון בהתאם לזרימה
          updatedAt: new Date(),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true
         }
      });
      console.log(`[API /api/auth/complete-profile] User record updated for user ${userId}. New profile status: isProfileComplete=${user.isProfileComplete}, isPhoneVerified=${user.isPhoneVerified}, status=${user.status}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    console.log("[API /api/auth/complete-profile] Returning success response with user data:", JSON.stringify({ message: "Profile completed successfully", user: updatedUser }, null, 2));
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error during processing:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Known Request Error - Code: ${error.code}`);
        console.error("[API /api/auth/complete-profile] Prisma Error Meta:", error.meta);
        console.error("[API /api/auth/complete-profile] Prisma Error Message:", error.message);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone') && target?.includes('User')) {
                 return NextResponse.json({ error: 'מספר טלפון זה כבר רשום במערכת.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error (Prisma Validation Error).' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- הוספה ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- סוף הוספה ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "קישור לא תקין או שפג תוקפו. אנא בקש מהשדכן לשלוח הזמנה חדשה." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // עדכון הסיסמה, סטטוס המשתמש, וסטטוס האימות בטרנזקציה אחת
    await prisma.$transaction(async (tx) => {
      // עדכון סיסמה, אימות מייל, וסטטוס המשתמש
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- הוספה ---
          isVerified: true, // המייל אומת מכיוון שהמשתמש הגיע מהקישור
          status: UserStatus.PENDING_PHONE_VERIFICATION, // העבר את המשתמש לשלב הבא
          // isProfileComplete נשאר false כי הוא עדיין צריך למלא פרטים
          // --- סוף הוספה ---
        },
      });

      // עדכון סטטוס האימות (הטוקן נוצל)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "החשבון הוגדר בהצלחה! כעת ניתן להתחבר עם הסיסמה החדשה." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "אירעה שגיאה בהגדרת החשבון." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `שגיאת מסד נתונים בעת מחיקת המשתמש (קוד: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || 'שגיאה במחיקת החשבון.', status: 400 };
    }

    return { message: 'אירעה שגיאה בלתי צפויה במחיקת החשבון.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. לא זוהתה סשן פעיל.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: 'החשבון נמחק בהצלחה.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: 'המשתמש המבוקש למחיקה לא נמצא.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: Request) {
  try {
    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    // הוספת בדיקה: אם למשתמש אין סיסמה (למשל, נרשם דרך OAuth)
    if (!user.password) {
      return NextResponse.json(
        { error: "לא הוגדרה סיסמה לחשבון זה. ייתכן שנרשמת באמצעות שירות חיצוני." },
        { status: 400 }
      );
    }

    // בדיקת סיסמה נוכחית
    // כעת, user.password מובטח להיות string
    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "סיסמה נוכחית שגויה" },
        { status: 400 }
      );
    }

    // הצפנת הסיסמה החדשה
    const hashedNewPassword = await hash(newPassword, 12);

    // יצירת קוד אימות בן 6 ספרות באמצעות שירות האימות
    // שינוי שם הפונקציה והוספת פרמטר target
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email, // הוספת user.email כפרמטר target
      24 // תקף ל-24 שעות (expiresInHours)
    );

    // שמירת הסיסמה המוצפנת במטא-דאטה של האימות
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // שליחת מייל עם קוד האימות
    await emailService.sendPasswordReset(user.email, verification.token);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בתהליך שינוי הסיסמה" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/register/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, UserRole, UserStatus, Prisma, VerificationType, UserSource  } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 

const prisma = new PrismaClient();

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
        // For now, we'll keep it.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
}

function handleError(error: unknown): { message: string; status: number } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: 'משתמש עם כתובת אימייל זו כבר קיים במערכת.', status: 409 };
          }
          return { message: `משתמש עם פרטים אלה כבר קיים במערכת (קוד ${error.code}).`, status: 409 };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `שגיאת תלות בנתונים (שדה: ${fieldName || 'לא ידוע'}). אנא נסה שנית.`, status: 500};
        }
        case 'P2014': return { message: 'שגיאה בנתונים שהוזנו.', status: 400 };
        default: 
            return { message: `שגיאה בשמירת הנתונים (קוד שגיאת DB: ${error.code}).`, status: 500 };
      }
    }
    if (error instanceof Error) {
       if (error.message === 'משתמש עם כתובת אימייל זו כבר קיים במערכת.') {
           return { message: error.message, status: 409 };
       }
       if (['חסרים פרטים חובה', 'כתובת אימייל לא תקינה', 'הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר'].includes(error.message)) {
           return { message: error.message, status: 400 };
       }
       if (error.message.includes('אירעה שגיאה ביצירת קוד אימות') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: 'אירעה שגיאה ביצירת רשומת האימות עקב בעיית תלות. אנא נסה שנית.', status: 500 };
       }
      return { message: error.message, status: 400 }; 
    }
    return { message: 'אירעה שגיאה בלתי צפויה.', status: 500 };
}


export async function POST(req: Request) {
  logger.info('Initial registration process initiated');

  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('חסרים פרטים חובה');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('כתובת אימייל לא תקינה');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('משתמש עם כתובת אימייל זו כבר קיים במערכת.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(), 
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });
    
    let emailSentSuccess = false;
    const emailOtpExpiryText = "שעה אחת"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
      await emailService.sendVerificationEmail({
        email: result.user.email,
        verificationCode: result.generatedOtp, 
        firstName: result.user.firstName,
        expiresIn: emailOtpExpiryText 
      });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = 'החשבון נוצר בהצלחה. ';
    if (emailSentSuccess) {
        responseMessage += `נשלח קוד אימות לכתובת הדוא"ל שלך (${result.user.email}). אנא הזן את הקוד כדי להמשיך.`;
    } else {
        responseMessage += 'הייתה בעיה בשליחת קוד האימות. תוכל לבקש קוד חדש במסך הבא או לפנות לתמיכה.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { userId: result.user.id });
    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id, 
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType, UserStatus, VerificationStatus } from '@prisma/client'; // Added VerificationStatus
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

const prisma = new PrismaClient(); // Consider using your global prisma instance if you have one at @/lib/prisma

const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "כתובת מייל לא תקינה" }),
});

// Helper for logging (consistent with your existing logs)
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string; // <--- הוספה של המאפיין החסר
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus; // For logging user or verification status
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: Request) {
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined; // Define type for requestBody
  try {
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "כתובת מייל לא תקינה" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    logger.info('Processing password reset request', { action, email: normalizedEmail });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    const genericSuccessMessage = 'אם קיימת כתובת מייל זו במערכת וניתן לאפס עבורה סיסמה, קוד אימות נשלח כעת.';

    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING, // Use VerificationStatus enum
        },
        data: {
            status: VerificationStatus.EXPIRED, // Use VerificationStatus enum
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60
    );
    // Now this log line is valid because verificationId is in LogMetadata
    logger.info('Password reset OTP created in VerificationService', { action, userId: user.id, verificationId: passwordResetVerification.id });

    try {
      await emailService.sendPasswordResetOtpEmail({
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: `${expiresInMinutes} דקות`,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message, stack: (process.env.NODE_ENV === 'development' ? error.stack : undefined) } : String(error),
    });

    return NextResponse.json(
      { success: false, error: 'אירעה שגיאה בתהליך. אנא נסה שנית מאוחר יותר.' },
      { status: 500 }
    );
  } finally {
    // Only disconnect if prisma instance was created locally in this file
    // If using a global instance from @/lib/prisma, it's usually managed globally
    // await prisma.$disconnect().catch(e => logger.error('Failed to disconnect Prisma in request-password-reset', { error: e }));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Adjust path if needed
import prisma from '@/lib/prisma'; // Adjust path if needed
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService'; // Adjust path if needed
import { VerificationType } from '@prisma/client'; // Import necessary enums/types

// --- Configuration ---
// How long (in seconds) the user must wait between resend requests
const RESEND_RATE_LIMIT_SECONDS = 60;

// --- Helper: Logger (optional but recommended) ---
const logger = {
    info: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...(meta || {}) }));
    },
    warn: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...(meta || {}) }));
    },
    error: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      // במקרה של שגיאה, נרצה אולי לטפל ב-meta בצורה שונה אם הוא אובייקט Error
      let logMeta = meta || {};
      if (meta instanceof Error) {
          // אם ה-meta הוא אובייקט Error, נרצה אולי לפרק אותו
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
  };
// --- End Helper ---


// --- Main POST Handler ---
export async function POST() {
    logger.info("Resend phone code request received");

    // 1. --- Authentication Check ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });
    // --- End Authentication Check ---

    try {
        // 2. --- Find Last Pending Verification ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING', // Only find codes that haven't been used, expired, or failed
            },
            orderBy: {
                createdAt: 'desc' // Get the most recent one if multiple exist (shouldn't happen often with cleanup)
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            // This could mean the user is already verified, the code expired and wasn't updated, etc.
            // Provide a generic message.
            return NextResponse.json({ error: 'לא נמצאה בקשת אימות פעילה. ייתכן שכבר אימתת את מספרך או שהקוד פג תוקף.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });
        // --- End Find Last Pending Verification ---


        // 3. --- Rate Limiting Check ---
        const now = new Date();
        // Use 'createdAt' as the timestamp of the last *send attempt* for pending codes
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: `אנא המתן ${timeLeft} שניות לפני בקשת קוד חדש.` }, { status: 429 }); // Too Many Requests
        }
        logger.info("Rate limit check passed", { userId });
        // --- End Rate Limiting Check ---


        // 4. --- Determine Target Phone and User Name ---
        // Initialize with 'let' to allow modification in fallback
        let targetPhone = lastVerification.target;
        // Try to get name from session first for personalization
        let userFirstName = session.user.firstName || ''; // Use empty string as fallback

        // Fallback: If target phone wasn't stored in verification, fetch from User model
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true } // Select only needed fields
             });
             if (!user?.phone) {
                // This is a more critical error, shouldn't happen if registration flow is correct
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                // Don't expose internal details, give a generic error
                return NextResponse.json({ error: 'שגיאה: לא ניתן לאתר את מספר הטלפון לשליחת הקוד.' }, { status: 500 });
             }
             targetPhone = user.phone; // Assign the fetched phone number
             userFirstName = user.firstName || ''; // Update first name if fetched
             logger.info("Successfully fetched phone number from user model as fallback", { userId });
        }

        // Final check to ensure we have a phone number
        if (!targetPhone) {
             logger.error(`Target phone is still null/undefined after fallback for user ${userId}.`);
             return NextResponse.json({ error: 'שגיאה: לא ניתן לקבוע את מספר הטלפון ליצירת קשר.' }, { status: 500 });
        }
        // --- End Determine Target Phone ---


        // 5. --- Generate New OTP ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // New 10-minute expiration
        logger.info("Generated new OTP", { userId });
        // --- End Generate New OTP ---


        // 6. --- Update Verification Record ---
        // Update the *existing* pending record with the new code, expiry, reset attempts, and timestamp
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // Reset attempts count for the new code
                createdAt: new Date() // Update timestamp to reflect this new send attempt (for rate limiting)
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });
        // --- End Update Verification Record ---


        // 7. --- Send New OTP via WhatsApp ---
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName // Pass name for personalization
        );

        if (!otpSent) {
            // Log the failure but still return a potentially helpful message to the user
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            // Let the user know there was an issue, maybe suggest trying again later
            return NextResponse.json({ error: 'שליחת קוד האימות החדש באמצעות WhatsApp נכשלה. אנא נסה שוב בעוד מספר רגעים.' }, { status: 500 });
        }
        // --- End Send New OTP ---


        // 8. --- Success Response ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: 'קוד אימות חדש נשלח בהצלחה באמצעות WhatsApp.' }, { status: 200 });
        // --- End Success Response ---

    } catch (error: unknown) { // Catch errors as unknown
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id, // Log userId if available
            error: error instanceof Error ? { name: error.name, message: error.message, stack: error.stack } : String(error)
        });
        // Return a generic server error response
        return NextResponse.json({ error: 'אירעה שגיאה פנימית בשרת. נסה שוב מאוחר יותר.' }, { status: 500 });
    } finally {
        // Disconnect Prisma client if necessary (depends on Prisma setup)
        // await prisma.$disconnect();
        // logger.info("Database connection closed (if applicable)");
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:

import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { randomBytes } from "crypto";
import { emailService } from "@/lib/email/emailService";
import { VerificationType } from "@prisma/client";

export async function POST(req: Request) {
  try {
    const { email, type } = await req.json();

    if (!email || !type) {
      return NextResponse.json(
        { error: "חסרים פרטים נדרשים" },
        { status: 400 }
      );
    }

    // מציאת המשתמש
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { error: "לא נמצא משתמש עם כתובת האימייל הזו" },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { error: "המשתמש כבר מאומת" },
        { status: 400 }
      );
    }

    // יצירת טוקן אימות חדש
    const verification = await prisma.verification.create({
      data: {
        userId: user.id,
        type: type as VerificationType,
        token: randomBytes(32).toString('hex'),
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // תוקף ל-24 שעות
        status: 'PENDING',
        attempts: 0
      }
    });

    // שליחת מייל אימות חדש
    // *** התיקון כאן: שימוש ב-verificationCode במקום verificationLink ***
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: verification.token, // שונה מ-verificationLink
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({
      success: true,
      message: "מייל אימות חדש נשלח בהצלחה"
    });

  } catch (error) {
    console.error('Resend verification error:', error);
    const errorMessage = error instanceof Error ? error.message : "שגיאה בשליחת מייל האימות";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-verification-code/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType, UserStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';

const prisma = new PrismaClient();

// Updated LogMetadata type
type LogMetadata = {
  email?: string;
  error?: unknown;
  timestamp?: string; // Note: logger already adds a timestamp. This allows overriding or adding a specific one.
  userId?: string;
  verificationId?: string; // Added to fix the error
  status?: UserStatus;     // Added for metadata in a logger.warn call
  isVerified?: boolean;    // Added for metadata in a logger.warn call
};

// Updated logger object with 'warn' method
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })) // Added 'warn' method
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: Request) {
  let requestBody: ResendCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });


    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: 'חסרה כתובת אימייל.' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    logger.info('Attempting to resend verification code', { email: normalizedEmail });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail }); // Now valid
      return NextResponse.json({ success: false, error: 'משתמש עם כתובת אימייל זו אינו רשום.' }, { status: 404 });
    }

    // ודא שהמשתמש עדיין צריך לאמת אימייל
    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        // This log call now correctly uses properties defined in LogMetadata
        logger.warn('User email already verified or not pending email verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: 'כתובת האימייל כבר מאומתת או שאינה ממתינה לאימות.' }, { status: 400 });
    }
    
    // יצירת קוד אימות חדש ושליחתו
    const expiresInHoursForOtp = 1; // תוקף של שעה
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email, // השתמש באימייל מהמשתמש (שכבר מנורמל)
      expiresInHoursForOtp
    );
    // This log call now correctly uses verificationId defined in LogMetadata
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });


    // שליחת המייל עם הקוד החדש
    const emailOtpExpiryText = "שעה אחת"; // התאם ל-expiresInHoursForOtp
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    return NextResponse.json({
      success: true,
      message: `קוד אימות חדש נשלח לכתובת ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = 'אירעה שגיאה בשליחה חוזרת של הקוד.';
    const errorStatus = 500;

    if (error instanceof Error) {
        if (error.message === 'אירעה שגיאה ביצירת קוד אימות') {
            errorMessage = error.message; // השתמש בהודעה הספציפית מהשירות
        }
        // אפשר להוסיף טיפול בשגיאות ספציפיות אחרות משירות המייל למשל
    }
    

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect();
    logger.info('Database connection closed for resend-verification-code');
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType} from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService'; // For password change confirmation
import { hash } from 'bcryptjs';
import { z } from 'zod';

const prisma = new PrismaClient();

const resetPasswordSchema = z.object({
  email: z.string().email({ message: "כתובת מייל לא תקינה" }),
  otp: z.string().length(6, { message: "קוד האימות חייב להכיל 6 ספרות" }).regex(/^\d+$/, { message: "קוד אימות יכול להכיל ספרות בלבד" }),
  newPassword: z.string().min(8, { message: "הסיסמה חייבת להכיל לפחות 8 תווים" })
    .regex(/[a-z]/, { message: "הסיסמה חייבת להכיל לפחות אות קטנה אחת באנגלית" })
    .regex(/[A-Z]/, { message: "הסיסמה חייבת להכיל לפחות אות גדולה אחת באנגלית" })
    .regex(/[0-9]/, { message: "הסיסמה חייבת להכיל לפחות ספרה אחת" }),
});

// Helper for logging
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: Request) {
  const action = "reset-password-with-otp";
  let requestBody;

  try {
    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid input for password reset', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "נתונים לא תקינים.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];
      
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });

    // Step 1: Verify the OTP using VerificationService
    // This should not mark the verification as 'COMPLETED' yet for PASSWORD_RESET type.
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    // If verifyCode doesn't throw an error, it means the OTP is valid (not expired, not too many attempts, exists).
    // It returns { success: true, message: 'Code verified.', userId: '...', id: '...' }
    
   if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      // This scenario should ideally be handled by verifyCode throwing an error.
      // If verifyCode is changed to return success:false instead of throwing for some cases, handle here.
      logger.error('OTP verification failed or did not return expected data', { 
        action, 
        email: normalizedEmail, 
        error: verificationResult // Changed 'result' to 'error'
      });
      throw new Error(verificationResult.message || 'שגיאה באימות הקוד.');
    }
    
    const userId = verificationResult.userId;
    const verificationId = verificationResult.id; // ID of the verification record

    logger.info('OTP verified successfully for password reset', { action, email: normalizedEmail, userId, verificationId });

    // Step 2: Hash the new password
    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    // Step 3: Update the user's password in the database
    await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
        // Optional: Reset login attempts if you track them, or other security measures
      },
    });
    logger.info('User password updated in database', { action, userId });

    // Step 4: Explicitly mark the verification record as COMPLETED
    await VerificationService.completeVerification(verificationId);
    logger.info('Password reset verification record marked as completed', { action, verificationId });

    // Step 5: Optional - Send password change confirmation email
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { email: true, firstName: true } });
    if (user) {
        try {
            await emailService.sendPasswordChangedConfirmationEmail({
                email: user.email,
                firstName: user.firstName,
            });
            logger.info('Password change confirmation email sent', { action, userId });
        } catch (emailError) {
            logger.error('Failed to send password change confirmation email', {
                action,
                userId,
                error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
            });
            // Non-critical error for the overall success of password reset, proceed
        }
    }

    return NextResponse.json({ success: true, message: 'הסיסמה אופסה בהצלחה. כעת תוכל להתחבר עם הסיסמה החדשה.' }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = typeof requestBody === 'object' && requestBody && 'email' in requestBody ? String(requestBody.email) : undefined;
    logger.error('Error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message, stack: (process.env.NODE_ENV === 'development' ? error.stack : undefined) } : String(error),
    });

    let errorMessage = 'אירעה שגיאה באיפוס הסיסמה.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        'הקוד כבר נוצל.', // This shouldn't happen if completeVerification is called after successful password update.
        'תוקף הקוד פג. אנא בקש קוד חדש.',
        'קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.',
        'קוד אימות שגוי.',
        'חרגת ממספר ניסיונות האימות המותר. אנא בקש קוד חדש.',
        'שגיאה פנימית: אימות הקוד הצליח אך לא נמצא משתמש משויך.',
        'שגיאה פנימית: רשומת האימות אינה משויכת למשתמש.' // from verifyCode
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
        if (error.message.includes("פג תוקפו")) errorStatus = 410; // Gone
        if (error.message.includes("חרגת ממספר ניסיונות")) errorStatus = 429; // Too Many Requests
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => logger.error('Failed to disconnect Prisma in reset-password API', { error: e }));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST() {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. קבל את פרטי המשתמש מה-DB (בעיקר מספר הטלפון)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // שגיאה זו לא אמורה לקרות אם המשתמש הגיע לכאן דרך השלמת פרופיל
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. יצירת OTP חדש
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 דקות תפוגה

        // 3. שמירת/עדכון רשומת האימות
        // מחק רשומות קודמות לאותו משתמש כדי למנוע בלבול
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // צור רשומה חדשה
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. שליחת ה-OTP בוואטסאפ
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // החזר שגיאה כדי שהקליינט יוכל להציג הודעה מתאימה
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
export const runtime = 'nodejs';

import { NextResponse } from "next/server";
import { PrismaClient, VerificationType } from "@prisma/client";
import { generateToken } from "@/lib/tokens";
import { emailService } from "@/lib/email/emailService";

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { email } = await req.json();
    
    if (!email) {
      return NextResponse.json({ error: "אימייל הוא שדה חובה" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return NextResponse.json({ error: "משתמש לא נמצא" }, { status: 404 });
    }

    await prisma.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.EMAIL,
        status: "PENDING"
      },
      data: { status: "EXPIRED" }
    });

    const token = await generateToken();
    const verification = await prisma.verification.create({
      data: {
        token,
        userId: user.id,
        type: VerificationType.EMAIL,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
        status: "PENDING"
      }
    });

    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: verification.token, // Changed from verificationLink to verificationCode
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({ success: true }, { status: 200 });

  } catch (error) {
    console.error('Error sending verification:', error);
    return NextResponse.json({ error: "שגיאה בשליחת קוד האימות" }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().regex(/^0\d{9}$/, "Invalid phone number format (e.g., 0501234567)"),
});

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. בדוק שהמספר החדש לא תפוס על ידי משתמש מאומת אחר
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } // לא המשתמש הנוכחי
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: 'מספר הטלפון כבר רשום ופעיל במערכת עבור משתמש אחר.' }, { status: 409 }); // Conflict
          }

        // 2. עדכן את מספר הטלפון של המשתמש
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // קח את השם המעודכן אם צריך
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. צור OTP חדש
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 דקות תפוגה

        // 4. צור/עדכן רשומת אימות עבור המספר החדש
        // בטל רשומות קודמות אם היו
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // סמן קודמים כפגי תוקף
         });
         // צור רשומה חדשה
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // המספר החדש
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. שלח את ה-OTP למספר החדש
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // החזר שגיאה, ייתכן שהמספר החדש לא תקין בוואטסאפ
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // הגדרת error כ-unknown
        console.error("API update-and-resend: An error occurred:", error);

        // טיפול בשגיאות ספציפיות
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // שגיאת כפילות - למרות שבדקנו, ייתכן מצב race condition
            return NextResponse.json({ error: 'מספר הטלפון כבר רשום במערכת.' }, { status: 409 });
        }

        // שגיאה כללית
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextResponse } from 'next/server';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId כאן יכול להיות string או undefined אם הוא לא קיים במטאדאטה
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: Request) {
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: 'חסרים פרטי אימייל או קוד.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `פורמט קוד לא תקין. הקוד צריך להכיל ${OTP_LENGTH_FROM_SERVICE} ספרות.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- התיקון מתחיל כאן ---
    // וודא ש-userId קיים והוא מחרוזת לפני שנמשיך
    // סביר להניח ש-verificationResult.userId יכול להיות string | null
    // על פי ההגדרה של VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // זרוק שגיאה שתטופל בלוק ה-catch הכללי, או טפל בה באופן ספציפי יותר
      // שגיאה זו מצביעה על בעיה לוגית פנימית אם הקוד אומת אך אין משתמש משויך
      throw new Error('שגיאה פנימית: לא נמצא משתמש משויך לאימות לאחר אימות קוד מוצלח.');
    }
    
    // כעת, לאחר הבדיקה, TypeScript יכול להסיק (או שנוכל להצהיר במפורש)
    // ש-userId הוא string.
    const userId: string = verificationResult.userId; 
    // --- סוף התיקון ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, // כאן userId מובטח להיות string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: 'כתובת האימייל אומתה בהצלחה! מתבצעת התחברות אוטומטית...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = 'אירעה שגיאה באימות הקוד.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        'הקוד כבר נוצל.', 
        'תוקף הקוד פג. אנא בקש קוד חדש.', 
        'קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.', 
        'קוד אימות שגוי.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === 'שגיאה פנימית: לא נמצא משתמש משויך לאימות.' || 
                 error.message === 'שגיאה פנימית: לא נמצא משתמש משויך לאימות לאחר אימות קוד מוצלח.') { // הוספת השגיאה החדשה אם רוצים טיפול מיוחד
        errorMessage = 'אירעה שגיאה פנימית. אנא נסה שנית מאוחר יותר.';
        // errorStatus נשאר 500 כברירת מחדל לשגיאות פנימיות, או שתשנה לפי הצורך
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus } from '@prisma/client';
import { z } from 'zod';

const verifyCodeSchema = z.object({
  code: z.string().length(6, "Verification code must be 6 digits").regex(/^\d+$/, "Invalid code format"),
});

// Define Max Attempts
const MAX_VERIFICATION_ATTEMPTS = 5;

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = verifyCodeSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { code } = validation.data;

        // 1. מצא את רשומת האימות הרלוונטית
        const verification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc' // קח את הרשומה האחרונה
            }
        });

        if (!verification) {
            return NextResponse.json({ error: 'No pending verification found or already verified.' }, { status: 404 });
        }

        // 2. בדוק אם פג תוקף
        if (new Date() > verification.expiresAt) {
            // עדכן את סטטוס הרשומה ל-EXPIRED
            await prisma.verification.update({
                where: { id: verification.id },
                data: { status: 'EXPIRED' }
            });
            return NextResponse.json({ error: 'Verification code expired.' }, { status: 410 }); // 410 Gone
        }

        // 3. בדוק מספר ניסיונות
        if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
             // עדכן סטטוס ל-FAILED אם עבר את המגבלה
            await prisma.verification.update({
                where: { id: verification.id },
                data: { status: 'FAILED' }
            });
            return NextResponse.json({ error: 'Too many verification attempts.' }, { status: 429 }); // 429 Too Many Requests
        }

        // 4. השווה את הקודים
        if (verification.token !== code) {
            // עדכן מספר ניסיונות
            await prisma.verification.update({
                where: { id: verification.id },
                data: { attempts: { increment: 1 } }
            });
            const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - (verification.attempts + 1);
            return NextResponse.json({ error: `Invalid verification code. ${attemptsLeft} attempts remaining.` }, { status: 400 });
        }

        // 5. אימות הצליח! עדכן את המשתמש ואת רשומת האימות
        const [, updatedUser] = await prisma.$transaction([
            prisma.verification.update({
                where: { id: verification.id },
                data: {
                    status: 'COMPLETED',
                    completedAt: new Date(),
                    attempts: verification.attempts + 1
                 }
            }),
            prisma.user.update({
                where: { id: userId },
                data: {
                    isPhoneVerified: true,
                    isProfileComplete: true, // לאחר אימות טלפון, הפרופיל נחשב שלם
                    status: UserStatus.ACTIVE, // הפוך את המשתמש לפעיל
                    updatedAt: new Date(),
                },
                select: { // החזר רק את המידע הנדרש לעדכון הסשן
                    id: true,
                    isPhoneVerified: true,
                    isProfileComplete: true,
                    status: true,
                 }
            })
        ]);

        console.log(`API verify-phone-code: Phone verified successfully for user ${userId}`);

        // החזר את פרטי המשתמש המעודכנים כדי שהקליינט יוכל לעדכן את הסשן
        return NextResponse.json({
             message: 'Phone number verified successfully!',
             user: updatedUser // מכיל isPhoneVerified, isProfileComplete, status
             }, { status: 200 });

    } catch (error) {
        console.error("API verify-phone-code: An error occurred:", error);
        if (error instanceof z.ZodError) { // Catch potential Zod errors during validation
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\availability
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\availability\check
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\availability\check\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/availability/check/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { clientId } = await req.json();

    const result = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId: clientId,
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error("Error checking availability:", error);
    return NextResponse.json(
      { error: "Failed to check availability" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\chat
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\chat\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/chat/route.ts

import { NextRequest, NextResponse } from "next/server";
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";
import nodemailer from 'nodemailer';

// --- START: Knowledge Base ---
const knowledgeBase = [
  // ... (כל מאגר הידע נשאר ללא שינוי)
  // --- General & About Matchpoint ---
  {
    question: "מה זה מאצ'פוינט? מה אתם עושים?",
    answer: "מאצ'פוינט (Match Point) היא מערכת שידוכים מתקדמת המיועדת לרווקים ורווקות מהציבור הדתי המחפשים קשר רציני לטווח ארוך. אנו משלבים טכנולוגיית בינה מלאכותית (AI) עם ליווי אישי של שדכנים מקצועיים כדי לספק הצעות מדויקות ואיכותיות המבוססות על ערכים עמוקים והתאמה אישיותית."
  },
  {
    question: "מי המייסדים של החברה?",
    answer: "המייסדים שלנו הם דינה אנגלרד, שדכנית ראשית עם ניסיון עשיר, ואיתן אנגלרד, יזם טכנולוגי ומנכ\"ל החברה, שפיתח את הפלטפורמה הטכנולוגית הייחודית שלנו."
  },
  {
    question: "למי השירות שלכם מיועד?",
    answer: "השירות שלנו מיועד לרווקים ורווקות יהודים מכל הזרמים (דתי-לאומי, חרדי, אורתודוקסי-מודרני, מסורתי ועוד) שמחפשים קשר משמעותי למטרת נישואין. אנו פונים למי שנמאס לו מאפליקציות היכרויות שטחיות ומחפש תהליך רציני, דיסקרטי ויעיל יותר."
  },
  {
    question: "במה אתם שונים מאפליקציות היכרויות או שדכנים אחרים?",
    answer: "הייחוד שלנו הוא השילוב המושלם בין טכנולוגיה למגע אנושי. בניגוד לאפליקציות 'סוואיפ', אצלנו הפרטיות היא ערך עליון והפרופיל שלך גלוי רק לשדכנים. בניגוד לשדכנים מסורתיים, אנו משתמשים ב-AI לניתוח מעל 50 ממדי התאמה, מה שמאפשר לשדכנים שלנו לנהל מאגר גדול יותר ביעילות ולמצוא התאמות מדויקות יותר. כך אנחנו מציעים את הטוב משני העולמות: יעילות ודיוק טכנולוגי לצד הבנה וליווי אנושי."
  },
  // --- Process & Questionnaire ---
  {
    question: "איך התהליך עובד?",
    answer: "התהליך מתחיל בהרשמה ומילוי פרופיל אישי. לאחר מכן, תתבקש/י למלא שאלון מקיף המחולק לחמישה 'עולמות': אישיות, ערכים, זוגיות, העדפות לפרטנר ודת. התשובות שלך מנותחות על ידי מערכת ה-AI שלנו ונסקרות על ידי שדכן אישי. השדכן, בסיוע המערכת, מציע לך התאמות פוטנציאליות. רק לאחר הסכמה הדדית, ובתיווך השדכן, נוצר קשר ראשוני."
  },
  {
    question: "מה זה השאלון ומהם ה'עולמות'?",
    answer: "השאלון שלנו הוא כלי מעמיק שנועד להכיר אותך לעומק. הוא מחולק לחמישה 'עולמות' נושאיים: 'עולם האישיות' (מי אני), 'עולם הערכים' (מה מניע אותי), 'עולם הזוגיות' (מה אני מחפש/ת בקשר), 'עולם הפרטנר' (מי מתאים לי), ו'עולם הדת והמסורת'. מילוי השאלון אורך כ-30-40 דקות, אך ניתן לעשות זאת בחלקים."
  },
  {
    question: "האם אני חייב/ת למלא את כל השאלון בבת אחת?",
    answer: "בהחלט לא. המערכת שומרת את התקדמותך באופן אוטומטי, כך שתוכל/י לעצור בכל שלב ולחזור להשלים את השאלון בזמנך החופשי."
  },
  {
    question: "האם אפשר להירשם כאורח/ת בלי לפתוח חשבון?",
    answer: "כן, ניתן למלא את השאלון גם ללא חשבון כדי להתרשם, אך חשוב לדעת שבמקרה כזה התשובות לא יישמרו במערכת ולא נוכל להציע לך שידוכים. כדי לשמור את ההתקדמות ולהיכנס למאגר, יש צורך בהרשמה והתחברות."
  },
  // --- Pricing & Fees ---
  {
    question: "מה המחיר של השירות? כמה זה עולה?",
    answer: "המודל העסקי שלנו מבוסס על הצלחה. ההרשמה למערכת ומילוי הפרופיל והשאלונים הם ללא עלות. דמי הצלחה בסך 4,000 ש\"ח (כולל מע\"מ) נגבים רק במקרה של חתונה הנובעת משידוך ישיר דרך המערכת שלנו. בנוסף, קיימת אפשרות לחבילת הצעות נוספות וליווי מורחב בתשלום חד-פעמי של 350 ש\"ח."
  },
  {
    question: "האם יש תשלומים חודשיים?",
    answer: "לא, אין אצלנו דמי מנוי חודשיים. התשלום העיקרי הוא דמי הצלחה, רק כאשר מוצאים את הזיווג ומתחתנים. ישנה אפשרות לרכישה חד-פעמית של חבילת הצעות נוספות אם תרצה/י בכך."
  },
  // --- Privacy & Security ---
  {
    question: "מי יכול לראות את המידע והתמונות שלי?",
    answer: "הפרטיות שלך היא ערך עליון עבורנו. בניגוד לאפליקציות אחרות, הפרופיל שלך אינו ציבורי ואינו גלוי למשתמשים אחרים. רק צוות השדכנים המורשה של מאצ'פוינט יכול לצפות בפרופיל המלא שלך. כאשר מוצעת לך התאמה, הצד השני יראה רק פרטים כלליים ותמציתיים. פרטים מלאים ותמונות נחשפים רק לאחר הסכמה הדדית ובהדרגה, בתיווך השדכן."
  },
  {
    question: "איך אתם מאבטחים את המידע שלי?",
    answer: "אנו משתמשים באמצעי אבטחה מתקדמים, כולל הצפנת מידע מקצה לקצה (SSL/TLS), הצפנת סיסמאות, בקרות גישה מבוססות תפקידים, וחומות אש. המידע שלך מאוחסן בשרתים מאובטחים של ספקים מובילים בעולם."
  },
  // --- Features for Matchmakers ---
  {
    question: "אילו כלים יש לשדכנים במערכת?",
    answer: "השדכנים שלנו משתמשים בכלים מתקדמים לניהול מועמדים, כולל: 'Split View' להשוואה נוחה בין גברים לנשים, פאנל פילטרים מפורט, יכולת להוסיף מועמדים באופן ידני, וכלי ניתוח התאמות מבוססי AI."
  },
  {
    question: "איך ה-AI עוזר לשדכנים?",
    answer: "ה-AI מסייע לשדכנים בכמה דרכים: ראשית, הוא מנתח פרופילים על פי עשרות ממדים כדי להציף התאמות פוטנציאליות שהעין האנושית עלולה לפספס. שנית, השדכן יכול לבחור 'מועמד מטרה', והמערכת תמצא עבורו את ההתאמות הטובות ביותר מהמאגר, ממוינות לפי ציון התאמה. לבסוף, כלי 'ניתוח ההתאמה' מספק לשדכן סיכום מפורט על נקודות החוזק והאתגרים הפוטנציאליים בכל שידוך."
  },
  {
    question: "האם שדכן יכול לערוך את הפרופיל שלי?",
    answer: "כן, אחד היתרונות של הליווי האישי הוא שהשדכן יכול לסייע לך להציג את עצמך בצורה הטובה ביותר. הוא יכול לערוך את הפרופיל, לנהל את התמונות, ולעדכן פרטים כדי למקסם את סיכויי ההתאמה שלך."
  },
  // --- Success & Miscellaneous ---
  {
    question: "כמה זמן לוקח למצוא התאמה?",
    answer: "זה משתנה מאדם לאדם, אך בזכות השילוב של טכנולוגיה וליווי אישי, התהליך אצלנו יעיל ומהיר יותר מהממוצע. בעוד הממוצע בשוק עומד על כ-2.5 שנים, רוב המשתמשים שלנו מוצאים התאמות מוצלחות תוך 6-12 חודשים."
  },
  {
    question: "האם יש לכם גם אירועים או מפגשים?",
    answer: "כן, אנו מארגנים מגוון אירועים קהילתיים כמו מפגשים חברתיים, סדנאות והרצאות. זוהי הזדמנות מצוינת להכיר אנשים חדשים בסביבה נעימה ותומכת. חברי המערכת מקבלים גישה מועדפת לאירועים אלו."
  },
  {
    question: "מה קורה אחרי שנמצאה התאמה?",
    answer: "לאחר הסכמה הדדית, השדכן המלווה יוצר את הקשר הראשוני ביניכם, בדרך כלל על ידי העברת מספרי טלפון. השדכן ממשיך ללוות אתכם, נותן עצות ומקבל משוב לאחר הפגישות כדי לסייע לקשר להתקדם בצורה הטובה ביותר."
  },
];
// --- END: Knowledge base section ---

const knowledgeContext = knowledgeBase
  .map(item => `שאלה: ${item.question}\nתשובה: ${item.answer}`)
  .join('\n\n');

// Initialize the Generative AI client
const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);

const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
];

export async function POST(req: NextRequest) {
  try {
    const { message, type, userEmail } = await req.json();

    if (!message || typeof message !== "string") {
      return NextResponse.json({ error: "Message is required" }, { status: 400 });
    }

    // Handle email sending logic
    if (type === 'email') {
      if (!userEmail || typeof userEmail !== "string") {
        return NextResponse.json({ error: "User email is required for this action" }, { status: 400 });
      }

      const transporter = nodemailer.createTransport({
        service: process.env.EMAIL_SERVICE || 'gmail',
        auth: {
          user: process.env.GMAIL_USER || process.env.EMAIL_USER,
          pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
        },
        tls: {
          rejectUnauthorized: process.env.NODE_ENV === 'production',
        }
      });

      const mailOptions = {
        from: `"${process.env.EMAIL_FROM_NAME || 'Match Point Chatbot'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to: "jewish.matchpoint@gmail.com",
        subject: "פנייה חדשה מהצ'אט-בוט באתר Match Point",
        replyTo: userEmail, // Critical for easy replies
        html: `
          <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6;">
            <h2 style="color: #0891b2;">התקבלה הודעה חדשה מהצ'אט-בוט באתר:</h2>
            <p><strong>מאת:</strong> <a href="mailto:${userEmail}">${userEmail}</a></p>
            <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
              <p style="margin: 0;">${message.replace(/\n/g, '<br>')}</p>
            </div>
            <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
              זוהי הודעה אוטומטית. ניתן להשיב למייל זה ישירות כדי לענות לפונה.
            </p>
          </div>
        `,
      };

      await transporter.sendMail(mailOptions);
      return NextResponse.json({ reply: "תודה! הודעתך נשלחה בהצלחה. צוות Match Point ייצור איתך קשר בהקדם." });
    }

    // Default behavior: process question with AI
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash", safetySettings });

    const prompt = `
      אתה עוזר וירטואלי מועיל וידידותי של אתר השידוכים "Match Point". 
      תפקידך הוא לענות על שאלות משתמשים בעברית, בצורה תמציתית, ברורה ומנומסת.
      עליך לבסס את תשובתך אך ורק על מאגר הידע שסופק לך.
      אם השאלה נוגעת לנושא שאינו מופיע במאגר הידע, ענה: "זו שאלה מצוינת, אך אין לי תשובה מוכנה במאגר. איך תרצה/י להמשיך?".

      --- מאגר הידע ---
      ${knowledgeContext}
      --- סוף מאגר הידע ---

      שאלת המשתמש: "${message}"

      תשובה:
    `;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text();

    if (text.includes("אין לי תשובה מוכנה במאגר")) {
        return NextResponse.json({
            reply: text,
            isFallback: true,
            actions: [
                { type: 'email', label: 'שלח/י פניה במייל' },
            ]
        });
    }

    return NextResponse.json({ reply: text });

  } catch (error) {
    console.error("Error in /api/chat route:", error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ error: "Internal Server Error", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/contact/route.ts
import { NextRequest, NextResponse } from "next/server";
import nodemailer from 'nodemailer';
import { z } from 'zod';

// Zod schema for validating the contact form data
const contactSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters long" }),
  email: z.string().email({ message: "Invalid email address" }),
  message: z.string().min(10, { message: "Message must be at least 10 characters long" }),
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Validate the request body
    const validationResult = contactSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: "Invalid input", details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { name, email, message } = validationResult.data;

    // Configure the email transporter using environment variables
    const transporter = nodemailer.createTransport({
      service: process.env.EMAIL_SERVICE || 'gmail',
      auth: {
        user: process.env.GMAIL_USER || process.env.EMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
      },
      tls: {
        rejectUnauthorized: process.env.NODE_ENV === 'production',
      }
    });

    // Define the email options
    const mailOptions = {
      from: `"${process.env.EMAIL_FROM_NAME || 'Match Point Contact Form'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
      to: "jewish.matchpoint@gmail.com", // Your support/admin email address
      subject: `פנייה חדשה מאתר Match Point - ${name}`,
      replyTo: email, // This allows you to reply directly to the user
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6;">
          <h2 style="color: #0891b2;">התקבלה הודעה חדשה מטופס יצירת הקשר באתר:</h2>
          <p><strong>מאת:</strong> ${name} (<a href="mailto:${email}">${email}</a>)</p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;" />
          <h3 style="color: #333;">תוכן ההודעה:</h3>
          <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
            <p style="margin: 0; white-space: pre-wrap;">${message.replace(/\n/g, '<br>')}</p>
          </div>
          <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
            זוהי הודעה אוטומטית. ניתן להשיב למייל זה ישירות כדי לענות לפונה.
          </p>
        </div>
      `,
    };

    // Send the email
    await transporter.sendMail(mailOptions);

    // Return a success response
    return NextResponse.json({ success: true, message: "ההודעה נשלחה בהצלחה." });

  } catch (error) {
    console.error("Error in /api/contact route:", error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal Server Error", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus, UserSource } from "@prisma/client";

// Define different types of suggestion statuses for clear logic
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT', // A draft is also a form of pending that doesn't block
];

// This is the type for the object we will attach to the user
type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
        return new NextResponse(
            JSON.stringify({ error: 'Unauthorized - Matchmaker or Admin access required' }),
            { status: 403 }
        );
    }
    
    // Fetch all candidates with their full profile and images
    const users = await prisma.user.findMany({
        where: {
            status: { notIn: ['BLOCKED', 'INACTIVE'] },
            role: 'CANDIDATE',
            profile: { isNot: null }
        },
        select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            source: true,
            createdAt: true,
            isVerified: true,
            isProfileComplete: true, // Also fetch this field
            images: {
                select: { id: true, url: true, isMain: true },
                orderBy: [{isMain: 'desc'}, {createdAt: 'asc'}]
            },
            profile: true // Fetch the full profile object
        }
    });

    // Enhance each user with information about their current suggestion status
    const usersWithSuggestionInfo = await Promise.all(
      users.map(async (user) => {
        // First, check for a BLOCKING suggestion
        let suggestion = await prisma.matchSuggestion.findFirst({
          where: {
            OR: [{ firstPartyId: user.id }, { secondPartyId: user.id }],
            status: { in: BLOCKING_SUGGESTION_STATUSES },
          },
          include: {
            firstParty: { select: { id: true, firstName: true, lastName: true } },
            secondParty: { select: { id: true, firstName: true, lastName: true } },
          },
        });

        let suggestionType: 'BLOCKED' | 'PENDING' | null = null;
        if (suggestion) {
            suggestionType = 'BLOCKED';
        } else {
            // If no blocking suggestion, check for a PENDING one
            suggestion = await prisma.matchSuggestion.findFirst({
                where: {
                    OR: [{ firstPartyId: user.id }, { secondPartyId: user.id }],
                    status: { in: PENDING_SUGGESTION_STATUSES },
                },
                 include: {
                    firstParty: { select: { id: true, firstName: true, lastName: true } },
                    secondParty: { select: { id: true, firstName: true, lastName: true } },
                },
            });
            if (suggestion) {
                suggestionType = 'PENDING';
            }
        }
        
        // **THE FIX IS HERE**: Define the variable with the correct type that allows null or the object
        let suggestionInfo: SuggestionStatusInfo | null = null;

        if (suggestion && suggestionType) {
          const otherParty = suggestion.firstPartyId === user.id
            ? suggestion.secondParty
            : suggestion.firstParty;
          
          suggestionInfo = {
            status: suggestionType,
            suggestionId: suggestion.id,
            withCandidateName: `${otherParty.firstName} ${otherParty.lastName}`,
          };
        }
        
        return {
          ...user,
          suggestionStatus: suggestionInfo,
        };
      })
    );
    
    // Format the final list to ensure date consistency for the client
    const formattedUsers = usersWithSuggestionInfo.map(user => {
      // The profile might be null if the select query changes, so we handle it safely
      const profile = user.profile;

      return {
        // Spread all top-level user properties
        ...user,
        // Override profile to format dates to ISO strings for JSON safety
        profile: profile ? {
          ...profile,
          birthDate: profile.birthDate.toISOString(), 
          availabilityUpdatedAt: profile.availabilityUpdatedAt?.toISOString() || null,
          createdAt: profile.createdAt.toISOString(),
          updatedAt: profile.updatedAt.toISOString(),
          lastActive: profile.lastActive?.toISOString() || null,
        } : null, // handle case where profile could be null
      };
    });

    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: formattedUsers,
        count: formattedUsers.length
      }),
      { status: 200 }
    );

  } catch (error: unknown) {  
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);
    
    return new NextResponse(
      JSON.stringify({ 
        success: false,
        error: "An error occurred while fetching candidates.",
        details: errorMessage
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client"; // הוספתי Prisma עבור סוגי שגיאות
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. ייבוא

// פונקציית GET הקיימת שלך
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker or admin
    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true, // Added to fetch candidate's role
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }] // Main image first
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: { // Include user basic details
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role, // Include role in user object
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

// פונקציית PATCH הקיימת שלך
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // Only Matchmakers or Admins can edit
    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const { id: candidateIdToUpdate } = params; // ID of the candidate to update

    const candidateExists = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true } // Fetch role to prevent non-admins from editing admins
    });

    if (!candidateExists) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Prevent non-admin matchmakers from editing admin profiles (if desired)
    if (candidateExists.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }


    const profileData = await req.json();

    // Ensure numeric fields are numbers or null
    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    numericFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        } else if (profileData[field] !== null) {
            profileData[field] = parseInt(profileData[field], 10);
            if (isNaN(profileData[field])) {
                // Or throw an error if invalid number is critical
                console.warn(`Invalid number for ${field}: ${profileData[field]}, setting to null`);
                profileData[field] = null;
            }
        }
    });
    
    // Ensure enum fields are valid enum values or null
    const enumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus'];
    enumFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        }
        // Add specific enum validation here if needed, though Prisma handles this on write
    });

    // Ensure boolean fields are booleans or null
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious', 'preferredHasChildrenFromPrevious', 'isProfileVisible'];
    booleanFields.forEach(field => {
        if (profileData[field] === undefined) {
            profileData[field] = null; // Or a default boolean if appropriate
        } else if (typeof profileData[field] !== 'boolean' && profileData[field] !== null) {
             // Attempt to convert common string representations
            if (profileData[field] === 'true') profileData[field] = true;
            else if (profileData[field] === 'false') profileData[field] = false;
            else profileData[field] = null; // Default to null if not clearly boolean
        }
    });

    // Ensure array fields are arrays
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies'];
    arrayFields.forEach(field => {
        if (profileData[field] === undefined || profileData[field] === null) {
            profileData[field] = []; // Default to empty array
        } else if (!Array.isArray(profileData[field])) {
            console.warn(`Field ${field} is not an array, attempting to convert or defaulting to empty.`);
            // Basic attempt to convert comma-separated string or single value to array
            if (typeof profileData[field] === 'string' && profileData[field].includes(',')) {
                profileData[field] = profileData[field].split(',').map((s: string) => s.trim());
            } else if (typeof profileData[field] === 'string' && profileData[field].trim() !== '') {
                 profileData[field] = [profileData[field].trim()];
            } else {
                profileData[field] = [];
            }
        }
    });
    
    // Separate data for User model and Profile model if needed,
    // but current PATCH seems to only update Profile.

    const updatedProfile = await prisma.profile.update({
      where: { userId: candidateIdToUpdate },
      data: {
        ...profileData,
        updatedAt: new Date(), // Explicitly set updatedAt
        lastActive: new Date() // Also update lastActive
      }
    });
  // --- START OF NEW CODE ---
    // 2. הפעלת עדכון פרופיל ה-AI ברקע עבור המועמד שעודכן
    updateUserAiProfile(candidateIdToUpdate).catch(err => {
        console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
    });
    // --- END OF NEW CODE ---
    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });
  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        // Handle specific Prisma errors
        if (error.code === 'P2002') { // Unique constraint failed
            errorMessage = `שגיאה: נראה שאחד השדות שהזנת (כמו מייל או טלפון אם רלוונטי לפרופיל) כבר קיים במערכת עבור משתמש אחר. (${error.meta?.target})`;
            statusCode = 409; // Conflict
        } else if (error.code === 'P2025') { // Record to update not found
            errorMessage = "הפרופיל או המועמד המבוקש לעדכון לא נמצא.";
            statusCode = 404;
        } else {
            errorMessage = `שגיאת מסד נתונים (קוד ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        errorMessage = `שגיאת ולידציה בעדכון הפרופיל: ${error.message}`;
        statusCode = 400; // Bad Request
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

// פונקציית DELETE החדשה
export async function DELETE(
  req: NextRequest, // NextRequest is fine here, not used for body
  { params }: { params: { id: string } }
) {
  const candidateIdToDelete = params.id; // Changed from params.candidateId to params.id to match your GET/PATCH
  const timestamp = new Date().toISOString();
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. לא זוהתה סשן פעיל או הרשאה.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  // Only ADMINs can delete candidates
  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. נדרשת הרשאת אדמין.' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: 'מזהה מועמד (candidateId) חסר.' },
        { status: 400 }
    );
  }

  // Prevent admin from deleting themselves via this endpoint
  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: 'מנהל אינו יכול למחוק את חשבונו האישי דרך ממשק זה. השתמש בהגדרות חשבון אישיות.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true } // Select role to log and potentially prevent deleting other admins
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: 'המועמד המבוקש למחיקה לא נמצא.' },
        { status: 404 }
      );
    }

    // Optional: Prevent an admin from deleting another admin (unless explicitly allowed)
    // if (candidateToDelete.role === UserRole.ADMIN) {
    //   console.warn(`[${timestamp}] Admin ${performingUserId} attempting to delete another Admin ${candidateToDelete.id} (${candidateToDelete.email}). This might be restricted.`);
    //   return NextResponse.json(
    //     { success: false, error: 'לא ניתן למחוק חשבון אדמין אחר דרך ממשק זה כרגע.' },
    //     { status: 403 }
    //   );
    // }

    // onDelete: Cascade in your schema should handle related data (Profile, Images, Accounts, etc.)
    // Verify this carefully for all related models.
    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: 'המועמד נמחק בהצלחה.' },
      { status: 200 } // OK
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') { // Record to delete not found.
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: 'המועמד המבוקש למחיקה לא נמצא (שגיאת Prisma).'},
                { status: 404 }
            );
        }
        // Log other Prisma known errors
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `שגיאת מסד נתונים במחיקת המועמד (קוד: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `שגיאת ולידציה במחיקת המועמד: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : 'שגיאה לא ידועה בעת מחיקת המועמד.';
    return NextResponse.json(
      {
        success: false,
        error: 'אירעה שגיאה במחיקת המועמד. נסה שוב מאוחר יותר.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary, UploadApiOptions } from "cloudinary";

// Define Cloudinary upload result type
type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
  [key: string]: unknown;
};

// Check for required environment variables
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Validate environment variables
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  // Configure Cloudinary only if all values are defined
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get candidate ID from params
    const { id } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Process the form data
    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    // Check if Cloudinary is properly configured
    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error - image upload service unavailable" },
        { status: 500 }
      );
    }

    // Convert file to base64 for Cloudinary upload
    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const base64Image = buffer.toString('base64');
    const dataURI = `data:${image.type};base64,${base64Image}`;

    // Upload to Cloudinary using the upload_stream method
    const uploadResult = await new Promise<CloudinaryUploadResult>((resolve, reject) => {
      const uploadOptions: UploadApiOptions = {
        folder: `shidduch-system/users/${id}`,
        resource_type: "image",
        transformation: [
          { width: 1000, height: 1000, crop: "limit" },
          { quality: "auto:good" }
        ]
      };
      
      const uploadStream = cloudinary.uploader.upload_stream(
        uploadOptions,
        (error, result) => {
          if (error) reject(error);
          else if (result) resolve(result as CloudinaryUploadResult);
          else reject(new Error('No result from Cloudinary upload'));
        }
      );
      
      // Convert the dataURI to buffer and pipe it to the upload stream
      const bufferData = Buffer.from(dataURI.replace(/^data:image\/\w+;base64,/, ''), 'base64');
      uploadStream.end(bufferData);
    });

    // Check if this is the first image, to make it the main image
    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    // Create image record in database
    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0 // Make it main if it's the first image
      }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client"; // ודא ש-ADMIN מוגדר כאן ב-enum שלך
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Check if required environment variables are set
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: cloudName as string,
  api_key: apiKey as string,
  api_secret: apiSecret as string,
});

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CORRECTED CODE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN]; // Explicitly type the array

    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CORRECTED CODE ----

    // Get params
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Find the image
    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    // Check if this is the main image and there are other images
    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      // If there are other images, set the most recent one as main
      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
        // Continue with DB deletion even if Cloudinary fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get params
    const { id, imageId } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Verify image exists and belongs to candidate
    const imageToSetMain = await prisma.userImage.findFirst({ // Renamed variable for clarity
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) { // Used the new variable name
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    // Start a transaction to update main image
    await prisma.$transaction([
      // First, unset all other images as main for this user
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId } // Don't unset the one we are about to set
        },
        data: { isMain: false }
      }),
      
      // Then, set the specified image as main
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";

export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "כתובת אימייל תקינה היא שדה חובה." }, { status: 400 });
    }

    const normalizedEmail = email.toLowerCase();

    // Find the candidate to invite. We fetch their current email to compare.
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    // If the candidate's email is already the one we're trying to set,
    // we can just resend the invite without a DB update.
    if (candidate.email === normalizedEmail) {
        // Here, we can just resend the invite. For simplicity, we'll proceed,
        // but a dedicated "resend" logic would be cleaner.
        console.log(`Email ${normalizedEmail} is already set for candidate ${candidateId}. Proceeding to send invite.`);
    }

    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      72 // Token valid for 72 hours
    );

    // This transaction will now attempt to update the email.
    // The catch block below will handle the unique constraint violation if it occurs.
    await prisma.$transaction(async (tx) => {
      // Only update the email if it's different from the current one.
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }

      // Invalidate previous setup tokens for this user
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id },
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    // Send the email with the correct token
    await emailService.sendAccountSetupEmail({
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "השדכן/ית שלך",
      setupToken: setupToken,
      expiresIn: "3 ימים",
    });

    return NextResponse.json({ success: true, message: "הזמנה להגדרת חשבון נשלחה בהצלחה." });

  } catch (error) {
    console.error("Error sending account setup invite:", error);
    
    // --- START: Enhanced Error Handling ---
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // Check for unique constraint violation (P2002)
      if (error.code === 'P2002') {
        // The 'target' field in the error metadata tells us which field caused the violation.
        const target = error.meta?.target as string[] | undefined;
        if (target?.includes('email')) {
          return NextResponse.json(
            { success: false, error: "כתובת אימייל זו כבר משויכת לחשבון אחר." },
            { status: 409 } // 409 Conflict is the appropriate status code
          );
        }
      }
      // Handle other potential database errors
      return NextResponse.json({ success: false, error: "שגיאת מסד נתונים." }, { status: 500 });
    }
    // --- END: Enhanced Error Handling ---

    let errorMessage = "An unexpected error occurred.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

// Define the type for Cloudinary upload result for clarity
type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// Helper function to upload image to Cloudinary
async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await request.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "משתמש עם כתובת אימייל זו כבר קיים במערכת." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
   status: UserStatus.PENDING_EMAIL_VERIFICATION, // הסטטוס הנכון. המשתמש צריך לפעול על המייל כדי להמשיך
    isVerified: false,                             // המייל עדיין לא אומת
    isProfileComplete: false,                      // הפרופיל בהחלט לא שלם
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: {
            gender,
            birthDate,
            birthDateIsApproximate,
            manualEntryText,
            availabilityStatus: 'AVAILABLE',
          },
        },
      },
      include: {
        profile: true,
      },
    });

    // --- START OF FIX ---
    // 1. Define the type for the image data objects that will be created.
    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    // 2. Explicitly type the array upon initialization to avoid the 'never[]' type inference.
    const uploadedImageData: UserImageCreateInput[] = [];
    // --- END OF FIX ---

    if (images && images.length > 0) {
      // (Optional but good practice) File validation loop
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) { // 5MB limit
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          // 3. Push an object that matches the defined type.
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        // 4. The `createMany` call is now simpler and type-safe.
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\inquiries
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\inquiries\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import prisma from "@/lib/prisma"; // Added prisma
import { UserRole } from "@prisma/client"; // Added UserRole

export async function GET(
  req: Request, // req is not used, consider removing if not planned for future use
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    // ---- START OF CHANGE ----
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized - Not logged in" }, { status: 401 });
    }

    // Fetch user role for permission check
    const performingUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    // Additionally, a user involved in the inquiry should be able to see it.
    // This needs more context on how AvailabilityService.getInquiryById checks permissions.
    // For now, limiting to Matchmaker/Admin.
    // You might need to adjust this if users (CANDIDATE) should see their own inquiries via this route.
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
        // Before returning 403, check if the user is part of the inquiry if that's a requirement
        // For simplicity, the original request was about ADMIN access to MATCHMAKER functions.
        return NextResponse.json(
            { error: 'Unauthorized - Matchmaker or Admin access required to view this inquiry' },
            { status: 403 }
        );
    }
    // ---- END OF CHANGE ----

    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    // Potentially, AvailabilityService.getInquiryById already handles ownership/role checks.
    // If so, the above check might be redundant or could be simplified.
    // If 'inquiry' is null and no error was thrown, it means not found or no permission from service.
    if (!inquiry) {
        return NextResponse.json({ error: "Inquiry not found or access denied" }, { status: 404 });
    }
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    let message = "Failed to fetch inquiry";
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
import { type NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

// הגדרת טיפוס גנרי עבור הפרמטרים
type RouteSegment<T> = (
  request: NextRequest,
  params: { params: T }
) => Promise<NextResponse> | NextResponse;

// יצירת פונקציית הטיפול בבקשה
const handler: RouteSegment<{ id: string }> = async (request, { params }) => {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { isAvailable, note } = await request.json();

    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note
    });

    return NextResponse.json(updatedInquiry);
  } catch (error) {
    console.error("Error updating inquiry response:", error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : "Failed to update response"
      },
      { status: 500 }
    );
  }
};

// יצוא הפונקציה כ-POST handler
export const POST = handler;
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, Prisma, UserRole } from "@prisma/client";
import { suggestionService } from "@/app/components/matchmaker/suggestions/services/suggestions/SuggestionService";
import type { CreateSuggestionData } from "@/types/suggestions";

const getSuggestionCategory = (status: MatchSuggestionStatus) => {
  switch (status) {
    case 'DRAFT':
    case 'AWAITING_MATCHMAKER_APPROVAL':
    case 'PENDING_FIRST_PARTY':
    case 'PENDING_SECOND_PARTY':
      return 'PENDING';
    
    case 'FIRST_PARTY_DECLINED':
    case 'SECOND_PARTY_DECLINED':
    case 'MATCH_DECLINED':
    case 'ENDED_AFTER_FIRST_DATE':
    case 'ENGAGED':
    case 'MARRIED':
    case 'EXPIRED':
    case 'CLOSED':
    case 'CANCELLED':
      return 'HISTORY';
    
    default:
      return 'ACTIVE';
  }
};

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id || !session.user.role) {
        return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const allowedRolesToCreate: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRolesToCreate.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: "Unauthorized - Matchmaker or Admin access required to create suggestions" }, { status: 403 });
    }
    
    const data = await req.json();
    
    const suggestionData: CreateSuggestionData = {
      ...data,
      matchmakerId: session.user.id,
    };

    const newSuggestion = await suggestionService.createSuggestion(suggestionData);
    
    return NextResponse.json(newSuggestion);
    
  } catch (error) {
    console.error('Error creating suggestion:', error);
    let message = 'Failed to create suggestion';
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions); 
    
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const priority = searchParams.get("priority");
    const timeframe = searchParams.get("timeframe");

    const where: Prisma.MatchSuggestionWhereInput = {};
    
    // ---- START OF FIX ----
    // שינינו את הלוגיקה כדי לטפל נכון בהרשאות
    if (session.user.role === UserRole.MATCHMAKER) {
        // שדכן רואה רק את ההצעות שהוא יצר
        where.matchmakerId = session.user.id;
    } else if (session.user.role === UserRole.CANDIDATE) {
        // מועמד רואה רק הצעות שהוא צד בהן
        where.OR = [
            { firstPartyId: session.user.id },
            { secondPartyId: session.user.id }
        ];
    }
    // אם המשתמש הוא ADMIN, לא נוסיף סינון לפי מזהה משתמש, וכך הוא יראה את כל ההצעות.
    // ---- END OF FIX ----

    if (status) where.status = status as MatchSuggestionStatus;
    if (priority) where.priority = priority as Prisma.EnumPriorityFieldUpdateOperationsInput["set"];
    
    if (timeframe) {
      const date = new Date();
      switch (timeframe) {
        case 'today':
          date.setHours(0, 0, 0, 0);
          where.createdAt = { gte: date };
          break;
        case 'week':
          date.setDate(date.getDate() - 7);
          where.createdAt = { gte: date };
          break;
        case 'month':
          date.setMonth(date.getMonth() - 1);
          where.createdAt = { gte: date };
          break;
      }
    }

    const suggestions = await prisma.matchSuggestion.findMany({
      where,
      include: {
        firstParty: {
          select: { id: true, email: true, firstName: true, lastName: true, status: true, isVerified: true, images: { select: { id: true, url: true, isMain: true }, orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] }, profile: true }
        },
        secondParty: {
          select: { id: true, email: true, firstName: true, lastName: true, status: true, isVerified: true, images: { select: { id: true, url: true, isMain: true }, orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] }, profile: true }
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true, role: true }
        },
        statusHistory: { orderBy: { createdAt: 'desc' } },
        meetings: { orderBy: { createdAt: 'desc' } }
      },
      orderBy: { lastActivity: 'desc' }
    });

    const formattedSuggestions = suggestions.map(suggestion => ({
      ...suggestion,
      category: getSuggestionCategory(suggestion.status),
      firstParty: {
        ...suggestion.firstParty,
        profile: suggestion.firstParty.profile ? {
          ...suggestion.firstParty.profile,
          birthDate: suggestion.firstParty.profile.birthDate?.toISOString(),
          lastActive: suggestion.firstParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: suggestion.firstParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: suggestion.firstParty.profile.createdAt?.toISOString(),
          updatedAt: suggestion.firstParty.profile.updatedAt?.toISOString()
        } : null
      },
      secondParty: {
        ...suggestion.secondParty,
        profile: suggestion.secondParty.profile ? {
          ...suggestion.secondParty.profile,
          birthDate: suggestion.secondParty.profile.birthDate?.toISOString(),
          lastActive: suggestion.secondParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: suggestion.secondParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: suggestion.secondParty.profile.createdAt?.toISOString(),
          updatedAt: suggestion.secondParty.profile.updatedAt?.toISOString()
        } : null
      },
      statusHistory: suggestion.statusHistory.map(history => ({
        ...history,
        createdAt: history.createdAt.toISOString()
      })),
      meetings: suggestion.meetings.map(meeting => ({
        ...meeting,
        scheduledDate: meeting.scheduledDate.toISOString(),
        createdAt: meeting.createdAt.toISOString(),
        updatedAt: meeting.updatedAt.toISOString()
      })),
      responseDeadline: suggestion.responseDeadline?.toISOString(),
      decisionDeadline: suggestion.decisionDeadline?.toISOString(),
      lastStatusChange: suggestion.lastStatusChange?.toISOString(),
      firstPartySent: suggestion.firstPartySent?.toISOString(),
      firstPartyResponded: suggestion.firstPartyResponded?.toISOString(),
      secondPartySent: suggestion.secondPartySent?.toISOString(),
      secondPartyResponded: suggestion.secondPartyResponded?.toISOString(),
      firstMeetingScheduled: suggestion.firstMeetingScheduled?.toISOString(),
      closedAt: suggestion.closedAt?.toISOString(),
      createdAt: suggestion.createdAt.toISOString(),
      updatedAt: suggestion.updatedAt.toISOString(),
      lastActivity: suggestion.lastActivity.toISOString()
    }));
    
    // =================  LOGGING START (Improved) =================
    console.log(`[API GET /suggestions] User: ${session.user.id} (Role: ${session.user.role}). Found ${suggestions.length} suggestions matching query.`);
    if (suggestions.length > 0) {
        console.log(`[API GET /suggestions] Example suggestion being sent (ID: ${suggestions[0].id}, Status: ${suggestions[0].status})`);
    }
    // =================   LOGGING END   =================

    return NextResponse.json(formattedSuggestions);
    
  } catch (error) {
    console.error('Error fetching suggestions:', error);
    let message = 'Failed to fetch suggestions';
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { SuggestionService } from "@/app/components/matchmaker/suggestions/services/suggestions/SuggestionService";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // וידוא משתמש מחובר
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    // וידוא הרשאות שדכן
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const suggestionId = params.id;
    const data = await req.json();
    
    const suggestionService = SuggestionService.getInstance();
    
    try {
      // שימוש בשירות עדכון הצעה
      const updatedSuggestion = await suggestionService.updateSuggestion(
        suggestionId,
        session.user.id,
        {
          id: suggestionId,
          priority: data.priority,
          notes: {
            internal: data.internalNotes,
            forFirstParty: data.firstPartyNotes,
            forSecondParty: data.secondPartyNotes,
            matchingReason: data.matchingReason,
            followUpNotes: data.followUpNotes
          },
          decisionDeadline: data.decisionDeadline ? new Date(data.decisionDeadline) : undefined,
          responseDeadline: data.responseDeadline ? new Date(data.responseDeadline) : undefined
        }
      );
      
      return NextResponse.json({
        success: true,
        data: updatedSuggestion
      });
      
    } catch (serviceError: unknown) {
        console.error("Error from suggestion service:", serviceError);
        
        if (serviceError instanceof Error) {
          return NextResponse.json(
            { success: false, error: serviceError.message || "Failed to update suggestion" },
            { status: serviceError.message.includes("Unauthorized") ? 403 : 400 }
          );
        }
        
        // במקרה של שגיאה שאינה מסוג Error
        return NextResponse.json(
          { success: false, error: "Failed to update suggestion" },
          { status: 400 }
        );
      }
  } catch (error) {
    console.error("Error updating suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // וידוא שמשתמש מחובר
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // וידוא הרשאות שדכן או אדמין
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;

    // וידוא קיום ההצעה
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // בדיקת הרשאות ספציפיות - רק השדכן שיצר את ההצעה או אדמין יכולים למחוק
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to delete this suggestion" },
        { status: 403 }
      );
    }

    // מחיקת רכיבים קשורים בנפרד במקום בטרנזקציה
    // 1. מחיקת רשומות היסטוריה
    await prisma.suggestionStatusHistory.deleteMany({
      where: { suggestionId }
    });

    // 2. מחיקת משוב פגישות אם קיים
    await prisma.dateFeedback.deleteMany({
      where: { suggestionId }
    });

    // 3. מחיקת פגישות קשורות (אם יש)
    await prisma.meeting.deleteMany({
      where: { suggestionId }
    });

    // 4. מחיקת שאלות/פניות אם קיימות
    await prisma.suggestionInquiry.deleteMany({
      where: { suggestionId }
    });

    // 5. הסרת קשרים בטבלאות קשר רבים-לרבים (אם יש)
    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        approvedBy: {
          set: []
        },
        reviewedBy: {
          set: []
        }
      }
    });

    // 6. מחיקת ההצעה עצמה
    await prisma.matchSuggestion.delete({
      where: { id: suggestionId }
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully"
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    
    // החזרת פרטי שגיאה אם קיימים
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete suggestion", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/message/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { initNotificationService } from "@/app/components/matchmaker/suggestions/services/notification/initNotifications";

// Initialize the notification service
const notificationService = initNotificationService();


export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;
    const { partyType, messageType, content } = await req.json();

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for this suggestion
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to send messages for this suggestion" },
        { status: 403 }
      );
    }

    // Define which parties will receive the message
    const notifyParties: ('first' | 'second')[] = [];
    
    if (partyType === "first" || partyType === "both") {
      notifyParties.push('first');
    }
    
    if (partyType === "second" || partyType === "both") {
      notifyParties.push('second');
    }

     console.log(`Message request received for suggestion ${suggestionId}, will be handled through transactions`);

    // Log the message in the system
    await prisma.$transaction(async (tx) => {
      try {
        // Update the lastActivity field in the suggestion
        await tx.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            lastActivity: new Date(),
          },
        });
        
        // Add a record to the status history
        await tx.suggestionStatusHistory.create({
          data: {
            suggestionId,
            status: suggestion.status as MatchSuggestionStatus,
            notes: `הודעה נשלחה מאת השדכן: ${messageType} - ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`,
          },
        });
    
        // שליחת ההודעה רק אחרי העדכון בדאטהבייס
        await notificationService.handleSuggestionStatusChange(
          suggestion, 
          {
            channels: ['email', 'whatsapp'],
            notifyParties,
            customMessage: content
          }
        );
      } catch (txError) {
        console.error("Transaction error:", txError);
        throw txError;
      }
    });

    return NextResponse.json({
      success: true,
      message: "Messages sent successfully",
      recipients: notifyParties
    });
  } catch (error) {
    console.error("Error sending message:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send message" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/remind/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { initNotificationService } from "@/app/components/matchmaker/suggestions/services/notification/initNotifications";

// Initialize the notification service
const notificationService = initNotificationService();

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for this suggestion
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to send reminders for this suggestion" },
        { status: 403 }
      );
    }
    
    // Define parties that will receive the reminder
    const notifyParties: ('first' | 'second')[] = [];
    let sentCount = 0;
    
    if (partyType === "first" || partyType === "both") {
      if (suggestion.status === MatchSuggestionStatus.PENDING_FIRST_PARTY) {
        notifyParties.push('first');
        sentCount++;
      }
    }
    
    if (partyType === "second" || partyType === "both") {
      if (suggestion.status === MatchSuggestionStatus.PENDING_SECOND_PARTY) {
        notifyParties.push('second');
        sentCount++;
      }
    }
    
    // Construct reminder content
    const reminderContent = `זוהי תזכורת ידידותית שהצעת שידוך מאת ${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} ממתינה לתשובתך. לצפייה בפרטי ההצעה ומענה, אנא לחץ/י על הקישור.`;
    
    // Check if we have applicable recipients
    if (sentCount === 0) {
      return NextResponse.json({
        success: false,
        error: "No applicable recipients for reminder in current status"
      }, { status: 400 });
    }

    // Update the last activity timestamp in the suggestion
    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        lastActivity: new Date(),
      },
    });

    // Log the reminder to history
    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId,
        status: suggestion.status,
        notes: `תזכורת נשלחה ל${partyType === "first" ? "צד ראשון" : partyType === "second" ? "צד שני" : "שני הצדדים"} על ידי ${session.user.firstName} ${session.user.lastName}`,
      },
    });
    
    // רק לאחר העדכון בדאטהבייס - שלח את ההודעה
    await notificationService.handleSuggestionStatusChange(
      suggestion,
      {
        channels: ['email', 'whatsapp'],
        notifyParties,
        customMessage: reminderContent
      }
    );
    
    return NextResponse.json({
      success: true,
      message: "Reminder sent successfully",
      recipientCount: sentCount
    });
  } catch (error) {
    console.error("Error sending reminder:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send reminder" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/resend/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { StatusTransitionService } from "@/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";

// Initialize the notification service

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for resending
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to resend this suggestion" },
        { status: 403 }
      );
    }

    const statusTransitionService = StatusTransitionService.getInstance();
    let updatedSuggestion = suggestion;
    const transitionNotes = `הצעה נשלחה מחדש ע"י ${session.user.firstName} ${session.user.lastName}`;
    
    // Update suggestion status to the appropriate status for resending
    if (partyType === "both" || partyType === "first") {
      // Resend to first party
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_FIRST_PARTY,
        `${transitionNotes} - לצד ראשון`,
        {
          sendNotifications: true,
          notifyParties: ['first']
        }
      );
      
      // If this is just for the first party, update the sent time
      if (partyType === "first") {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            firstPartySent: new Date(),
            lastActivity: new Date()
          }
        });
      }
    }
    
    if (partyType === "both" || partyType === "second") {
      // Resend to second party (directly or after the first)
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        `${transitionNotes} - לצד שני`,
        {
          sendNotifications: true,
          notifyParties: ['second']
        }
      );
      
      // Update the sent time
      await prisma.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          secondPartySent: new Date(),
          lastActivity: new Date()
        }
      });
    }

    return NextResponse.json({
      success: true,
      message: `Suggestion successfully resent to ${partyType === "first" ? "first party" : partyType === "second" ? "second party" : "both parties"}`,
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error resending suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to resend suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/share-contact/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { StatusTransitionService } from "@/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for sharing contact details
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to share contact details for this suggestion" },
        { status: 403 }
      );
    }

    // Verify suggestion is in appropriate status for sharing contact details
    if (
      suggestion.status !== MatchSuggestionStatus.FIRST_PARTY_APPROVED &&
      suggestion.status !== MatchSuggestionStatus.SECOND_PARTY_APPROVED &&
      suggestion.status !== MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL
    ) {
      return NextResponse.json({
        success: false,
        error: "Suggestion is not in a valid status for sharing contact details"
      }, { status: 400 });
    }

    // Update suggestion status to CONTACT_DETAILS_SHARED using the StatusTransitionService
    // This will automatically trigger notifications to both parties with contact details
    const statusTransitionService = StatusTransitionService.getInstance();
    const updatedSuggestion = await statusTransitionService.transitionStatus(
      suggestion,
      MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
      `פרטי קשר שותפו בין ${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} ל${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} ע"י ${session.user.firstName} ${session.user.lastName}`,
      {
        sendNotifications: true,
        notifyParties: ['first', 'second', 'matchmaker']
      }
    );

    return NextResponse.json({
      success: true,
      message: "Contact details shared successfully",
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error sharing contact details:", error);
    return NextResponse.json(
      { success: false, error: "Failed to share contact details" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { z } from "zod";

// Schema for validating status update data
const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

/**
 * PATCH endpoint for updating suggestion status
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. Verify permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    // 3. Validate request data
    const body = await req.json();
    console.log("Received status update request:", body);
    
    const validationResult = updateStatusSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error:", validationResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid request data", 
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }
    
    const { status, notes } = validationResult.data;

    // 4. Verify suggestion exists
    const suggestionId = params.id;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 5. Verify permission on specific suggestion
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to update this suggestion" },
        { status: 403 }
      );
    }

    // 6. Calculate category based on new status
    const getCategory = (status: MatchSuggestionStatus) => {
      switch (status) {
        case "DRAFT":
        case "AWAITING_MATCHMAKER_APPROVAL":
        case "PENDING_FIRST_PARTY":
        case "PENDING_SECOND_PARTY":
          return "PENDING";
        
        case "FIRST_PARTY_DECLINED":
        case "SECOND_PARTY_DECLINED":
        case "MATCH_DECLINED":
        case "ENDED_AFTER_FIRST_DATE":
        case "ENGAGED":
        case "MARRIED":
        case "EXPIRED":
        case "CLOSED":
        case "CANCELLED":
          return "HISTORY";
        
        default:
          return "ACTIVE";
      }
    };

    // 7. Update status in a transaction
    const result = await prisma.$transaction(async (tx) => {
      // Save previous status
      const previousStatus = suggestion.status;

      // Update the suggestion
      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status,
          previousStatus: previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          category: getCategory(status),
          
          // Update additional fields based on new status
          ...(status === MatchSuggestionStatus.CLOSED ? { closedAt: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_FIRST_PARTY ? { firstPartySent: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY ? { secondPartySent: new Date() } : {}),
        },
      });

      // Add status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes: notes || `סטטוס שונה ל-${status} על ידי ${session.user.firstName} ${session.user.lastName}`,
        },
      });

      return updatedSuggestion;
    });

    // 8. Return success response
    return NextResponse.json({
      success: true,
      message: "Status updated successfully",
      suggestion: {
        id: result.id,
        status: result.status,
        previousStatus: result.previousStatus,
        lastStatusChange: result.lastStatusChange,
        category: result.category,
      },
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    // Return detailed error message if available
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to update status", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint for fetching suggestion history
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse URL parameters
    const searchParams = new URL(req.url).searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 50;

    // 3. Check viewing permissions
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        matchmakerId: true,
        firstPartyId: true,
        secondPartyId: true,
      }
    });
    
    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    
    // Check if user has permission to view this suggestion
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return NextResponse.json({ error: "Not authorized to view this suggestion" }, { status: 403 });
    }
    
    // 4. Build history query
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(startDate && {
          createdAt: {
            gte: new Date(startDate),
            ...(endDate && {
              lte: new Date(endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            secondParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            matchmaker: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc" as const,
      },
      take: limit,
    };

    // 5. Fetch status change history
    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    // 6. Format results
    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { error: "Failed to fetch history", details: errorMessage },
      { status: 500 }
    );
  }
}

/**
 * HEAD endpoint for getting status summary
 */
export async function HEAD(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new Response(null, { status: 401 });
    }

    // 2. Fetch suggestion details
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      }
    });

    if (!suggestion) {
      return new Response(null, { status: 404 });
    }

    // 3. Check viewing permissions
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return new Response(null, { status: 403 });
    }

    // 4. Prepare headers
    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    // Add lastStatusChange header only if it exists
    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\notifications
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\notifications\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Session } from "next-auth";

export async function GET() {
  try {
    // ההמרה לטיפוס Session תשתמש כעת בטיפוס המורחב מ-next-auth
    const session = await getServerSession(authOptions) as Session | null;
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // בדיקת התראות זמינות
    const pendingInquiries = await prisma.availabilityInquiry.count({
      where: {
        OR: [
          { 
            firstPartyId: session.user.id,
            firstPartyResponse: null,
            expiresAt: { gt: new Date() }
          },
          { 
            secondPartyId: session.user.id,
            secondPartyResponse: null,
            expiresAt: { gt: new Date() }
          }
        ]
      },
    });

    // בעתיד נוסיף ספירה של הודעות שלא נקראו
    const unreadMessages = 0;
    const total = pendingInquiries + unreadMessages;

    return NextResponse.json({
      availabilityRequests: pendingInquiries,
      messages: unreadMessages,
      total: total
    });

  } catch (error) {
    console.error("Error fetching notifications:", error);
    return NextResponse.json(
      { error: "Failed to fetch notifications" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\profile_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile
# Generated on: 2025-06-22 16:41:26
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\profile_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/route.ts (GET handler)

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, HeadCoveringType, KippahType, ServiceType } from "@prisma/client"; // Import enums if needed for casting
import type { UserProfile } from "@/types/next-auth";

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    let targetUserId: string;
    if (requestedUserId) {
      targetUserId = requestedUserId;
    } else if (session.user.id) {
      targetUserId = session.user.id;
    } else {
       return NextResponse.json(
        { success: false, message: 'User ID not found in session' },
        { status: 400 }
      );
    }

    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            id: true,
            userId: true,
            gender: true,
            birthDate: true,
            nativeLanguage: true,
            additionalLanguages: true,
            height: true,
            city: true,
            origin: true,
            aliyaCountry: true,
            aliyaYear: true,
            maritalStatus: true,
            hasChildrenFromPrevious: true,
            parentStatus: true,
            siblings: true,
            position: true,
            educationLevel: true,
            education: true,
            occupation: true,
            serviceType: true,
            serviceDetails: true,
            religiousLevel: true,
            shomerNegiah: true,
            headCovering: true,
            kippahType: true,
            profileCharacterTraits: true,
            profileHobbies: true,
            about: true,
            matchingNotes: true,
            preferredAgeMin: true,
            preferredAgeMax: true,
            preferredHeightMin: true,
            preferredHeightMax: true,
            preferredReligiousLevels: true,
            preferredLocations: true,
            preferredEducation: true,
            preferredOccupations: true,
            contactPreference: true,
            isProfileVisible: true,
            preferredMatchmakerGender: true,
            availabilityStatus: true,
            availabilityNote: true,
            availabilityUpdatedAt: true,
            preferredMaritalStatuses: true,
            preferredOrigins: true,
            preferredServiceTypes: true,
            preferredHeadCoverings: true,
            preferredKippahTypes: true,
            preferredShomerNegiah: true,
            preferredHasChildrenFromPrevious: true,
            preferredCharacterTraits: true,
            preferredHobbies: true,
            preferredAliyaStatus: true,
            createdAt: true,
            updatedAt: true,
            lastActive: true,
            verifiedBy: true,
            hasViewedProfilePreview: true, // <--- תיקון 1: הוסף את השדה לשליפה
          }
        },
        images: {
          select: {
            id: true,
            url: true,
            isMain: true,
            createdAt: true,
            cloudinaryPublicId: true,
            updatedAt: true,
          }
        }
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        console.error(`Profile data not found for user ID: ${targetUserId}`);
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    if (!dbProfile.birthDate) {
        console.error(`birthDate is null or undefined for profile ID: ${dbProfile.id}`);
        return NextResponse.json(
            { success: false, message: 'Data integrity issue: birthDate is missing for the profile.' },
            { status: 500 }
        );
    }

    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType as ServiceType | null || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering as HeadCoveringType | null || undefined,
      kippahType: dbProfile.kippahType as KippahType | null || undefined,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      about: dbProfile.about || "",
      matchingNotes: dbProfile.matchingNotes || "",
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      isProfileVisible: dbProfile.isProfileVisible,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender as Gender | null || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [],
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredHasChildrenFromPrevious: dbProfile.preferredHasChildrenFromPrevious ?? undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, // <--- תיקון 2: הוסף את השדה לאובייקט
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };
    
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};
// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// GET - Fetch all images for a user
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: { 
        user: {
          email: session.user.email 
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error("[GetImages] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch images" },
      { status: 500 }
    );
  }
}

// POST - Upload a new image
export async function POST(req: Request) {
  try {
    console.log("[Upload] Starting upload process");
    
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error("[Upload] Authentication failed - No user session");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: { images: true },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    if (user.images.length >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { error: "Maximum number of images reached" },
        { status: 400 }
      );
    }

    const formData = await req.formData();
    const file = formData.get("file") as File;
    
    if (!file) {
      console.error("[Upload] No file provided in request");
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    // Validate file
    const validTypes = ["image/jpeg", "image/png", "image/jpg"];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        { error: "Invalid file type. Only JPG and PNG are allowed" },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { error: "File size must be less than 5MB" },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    try {
      const uploadPromise = new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          {
            folder: "profile-images",
            resource_type: "image",
          },
          (error, result) => {
            if (error) reject(error);
            else resolve(result);
          }
        );
        uploadStream.end(buffer);
      });

      const result = await uploadPromise as CloudinaryUploadResult;

      const image = await prisma.userImage.create({
        data: {
          userId: user.id,
          url: result.secure_url,
          cloudinaryPublicId: result.public_id,
          isMain: user.images.length === 0,
        },
      });

      return NextResponse.json({ success: true, image });
    } catch (cloudinaryError) {
      console.error("[Upload] Cloudinary upload failed:", cloudinaryError);
      return NextResponse.json(
        { error: "Failed to upload image to cloud storage" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("[Upload] General error:", error);
    return NextResponse.json(
      { error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;
    
    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Delete from Cloudinary if cloudinaryPublicId exists
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
        // Continue with database deletion even if Cloudinary deletion fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId },
    });

    // If this was the main image, set another image as main if available
    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;

    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Reset all user's images to non-main
    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    // Set the selected image as main
    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    // Get updated images list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// --- START OF FILE route.ts ---

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth"; // ודא שהנתיב הזה נכון
import prisma from "@/lib/prisma"; // ודא שהנתיב הזה נכון
import { Prisma } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. ייבוא

// ודא שהנתיבים האלה נכונים לקבצי השאלות שלך
import { valuesQuestions } from "@/components/questionnaire/questions/values/valuesQuestions";
import { personalityQuestions } from "@/components/questionnaire/questions/personality/personalityQuestions";
import { relationshipQuestions } from "@/components/questionnaire/questions/relationship/relationshipQuestions";
import { partnerQuestions } from "@/components/questionnaire/questions/partner/partnerQuestions";
import { religionQuestions } from "@/components/questionnaire/questions/religion/religionQuestions";


// Combine all questions into a single array
const allQuestions = [
  ...valuesQuestions,
  ...personalityQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
];

// Define key types
type WorldKey = 'values' | 'personality' | 'relationship' | 'partner' | 'religion';
type DbWorldKey = 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers';

// Key mapping utility
const KEY_MAPPING: Record<WorldKey, DbWorldKey> = {
  values: 'valuesAnswers',
  personality: 'personalityAnswers',
  relationship: 'relationshipAnswers',
  partner: 'partnerAnswers',
  religion: 'religionAnswers'
};

function getDbKey(worldKey: WorldKey): DbWorldKey {
  return KEY_MAPPING[worldKey];
}

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible?: boolean;
}

interface UpdateData {
  type: 'answer' | 'visibility';
  value?: Prisma.JsonValue; // התאמה לשימוש ב- Prisma.JsonValue גם כאן
  isVisible?: boolean;
}

interface FormattedAnswer {
  questionId: string;
  question: string;
  value: Prisma.JsonValue;
  displayText: string;
  answeredAt: string;
  category?: string;
  isVisible?: boolean;
}

type FormattedAnswersType = Record<WorldKey, FormattedAnswer[]>;

const valueTranslations: Record<string, string> = {
  'combat': 'קרבי',
  'intelligence': 'אינטליגנציה',
  'stable': 'יציב',
  'yes': 'כן',
  'no': 'לא',
  'religious': 'דתי',
  'traditional': 'מסורתי',
  'secular': 'חילוני',
  'male': 'גבר',
  'female': 'אישה',
  'both': 'שניהם',
  'high': 'גבוהה',
  'medium': 'בינונית',
  'low': 'נמוכה'
  // Add other translations as needed based on your actual values
};

function getQuestionLabel(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.question || questionId;
}

function getQuestionCategory(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.category || question?.worldId.toLowerCase() || '';
}


function formatValue(value: Prisma.JsonValue): string {
  if (typeof value === 'boolean') {
    return value ? 'כן' : 'לא';
  }

  if (Array.isArray(value)) {
    return value.map(v => valueTranslations[String(v)] || String(v)).join(', ');
  }

  if (typeof value === 'object' && value !== null) {
    return JSON.stringify(value);
  }

  const stringValue = String(value);
  return valueTranslations[stringValue] || stringValue;
}

function isValidAnswerObject(item: Prisma.JsonValue): item is Prisma.JsonObject & {
  questionId: string | number;
  value: Prisma.JsonValue;
  answeredAt: string | number;
  isVisible?: boolean;
} {
  return typeof item === 'object' &&
         item !== null &&
         'questionId' in item &&
         'value' in item &&
         item.value !== undefined &&
         'answeredAt' in item;
}

function safeParseJson(value: Prisma.JsonValue | null): JsonAnswerData[] {
   if (Array.isArray(value)) {
     return value
       .filter(isValidAnswerObject)
       .map(item => ({
         questionId: String(item.questionId),
         value: item.value,
         answeredAt: String(item.answeredAt),
         isVisible: Boolean(item.isVisible ?? true)
       }));
   }
   return [];
}

function formatAnswers(answers: Prisma.JsonValue | null): FormattedAnswer[] {
  const parsedAnswers = safeParseJson(answers);

  return parsedAnswers.map(answer => {
    const displayText = formatValue(answer.value);
    const category = getQuestionCategory(answer.questionId);

    return {
      questionId: answer.questionId,
      question: getQuestionLabel(answer.questionId),
      value: answer.value,
      displayText,
      category,
      isVisible: answer.isVisible,
      answeredAt: new Date(answer.answeredAt).toLocaleDateString('he-IL', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    };
  }).sort((a, b) => a.questionId.localeCompare(b.questionId));
}


export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const userId = url.searchParams.get('userId') || session.user.id;

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });

    if (!questionnaireResponse) {
       return NextResponse.json({
          success: true,
          questionnaireResponse: null
       });
    }

    const formattedAnswers: Partial<FormattedAnswersType> = {};

    (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(worldKey => {
       const dbKey = getDbKey(worldKey);
       if (questionnaireResponse[dbKey]) {
           formattedAnswers[worldKey] = formatAnswers(questionnaireResponse[dbKey]);
       } else {
           formattedAnswers[worldKey] = [];
       }
    });

    const completeFormattedAnswers = formattedAnswers as FormattedAnswersType;

    const formattedResponse = {
      ...questionnaireResponse,
      formattedAnswers: completeFormattedAnswers
    };

    if (userId !== session.user.id) {
       Object.keys(formattedResponse.formattedAnswers).forEach((worldKey) => {
           const key = worldKey as WorldKey;
           if (formattedResponse.formattedAnswers[key]) {
               formattedResponse.formattedAnswers[key] =
                 formattedResponse.formattedAnswers[key].filter(answer => answer.isVisible !== false);
           }
       });
    }

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedResponse
    });

  } catch (error) {
    console.error('Error in GET /api/profile/questionnaire:', error);
    return NextResponse.json({ success: false, error: "Failed to fetch questionnaire" }, { status: 500 });
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       console.log("PATCH /api/profile/questionnaire - Unauthorized: No session or user ID.");
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
        const userId = session.user.id; // <-- הגדרת userId
     console.log(`PATCH /api/profile/questionnaire - Authorized for user: ${session.user.id}`);

     const body = await req.json();
     // =================================================================
     // === לוג עיקרי לבדיקת גוף הבקשה שהשרת מקבל ===
     console.log("PATCH /api/profile/questionnaire - Received body:", JSON.stringify(body, null, 2));
     // =================================================================

     // ננסה לגשת לשדות ישירות מ-body לצורך הלוגים, לפני ה-destructuring
     const receivedWorldKey = body.worldKey;
     const receivedQuestionId = body.questionId;
     const receivedValueObject = body.value;
     const receivedValueType = body.value?.type;

     // Destructuring and type assertion (assuming body structure is correct)
     const { worldKey, questionId, value } = body as {
       worldKey: WorldKey;
       questionId: string;
       value: UpdateData;
     };

     // Validate input
     if (!worldKey || !questionId || !value || !value.type) {
        // === לוג מפורט יותר אם הבדיקה הזו נכשלת ===
        console.error("PATCH /api/profile/questionnaire - Invalid request body. Validation failed. Details:", {
            rawReceivedBody: body, // מדפיס את כל מה שהתקבל
            expectedWorldKey: worldKey, // הערך לאחר destructuring
            expectedQuestionId: questionId, // הערך לאחר destructuring
            expectedValueObject: value, // הערך לאחר destructuring
            isWorldKeyTruthyInBody: !!receivedWorldKey,
            isQuestionIdTruthyInBody: !!receivedQuestionId,
            isValueObjectTruthyInBody: !!receivedValueObject,
            isValueTypeTruthyInBody: !!receivedValueType,
        });
        // =====================================================
        return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
     }

     if (!KEY_MAPPING[worldKey]) {
         console.error(`PATCH /api/profile/questionnaire - Invalid world key: ${worldKey}`);
         return NextResponse.json({ success: false, error: "Invalid world key" }, { status: 400 });
     }

     const dbKey = getDbKey(worldKey);

     console.log(`PATCH /api/profile/questionnaire - Processing update for worldKey: ${worldKey}, questionId: ${questionId}, dbKey: ${dbKey}, updateType: ${value.type}`);

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       console.error(`PATCH /api/profile/questionnaire - Questionnaire not found for user ID: ${session.user.id}`);
       return NextResponse.json({ success: false, error: "שאלון לא נמצא" }, { status: 404 });
     }
     console.log(`PATCH /api/profile/questionnaire - Found questionnaire ID: ${questionnaire.id} for user.`);

     const currentAnswers = safeParseJson(questionnaire[dbKey]);
     const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
     const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

     let updatedAnswer: JsonAnswerData;

     if (value.type === 'visibility') {
        console.log(`PATCH /api/profile/questionnaire - Handling 'visibility' update.`);
        if (!existingAnswer) {
          console.error(`PATCH /api/profile/questionnaire - Cannot update visibility for non-existent answer. Question ID: ${questionId}`);
          return NextResponse.json({ success: false, error: "לא נמצאה תשובה לעדכון נראות" }, { status: 404 });
        }
        if (typeof value.isVisible !== 'boolean') {
             console.error(`PATCH /api/profile/questionnaire - Invalid visibility value: ${value.isVisible}. Must be boolean.`);
             return NextResponse.json({ success: false, error: "ערך נראות לא תקין" }, { status: 400 });
        }
        updatedAnswer = {
          ...existingAnswer,
          isVisible: value.isVisible,
          answeredAt: new Date().toISOString()
        };
        console.log(`PATCH /api/profile/questionnaire - Visibility updated for question ${questionId} to ${value.isVisible}.`);
     } else if (value.type === 'answer') {
       console.log(`PATCH /api/profile/questionnaire - Handling 'answer' update.`);
       if (value.value === undefined) { // אפשר להוסיף בדיקה יותר מחמירה אם value.value הוא null או מחרוזת ריקה, תלוי בדרישות
            console.error(`PATCH /api/profile/questionnaire - Answer value is missing.`);
            return NextResponse.json({ success: false, error: "ערך תשובה חסר" }, { status: 400 });
       }
       updatedAnswer = {
         questionId,
         value: value.value, // ה-type של value.value כבר אמור להיות Prisma.JsonValue לפי UpdateData
         isVisible: existingAnswer?.isVisible ?? true,
         answeredAt: new Date().toISOString()
       };
       console.log(`PATCH /api/profile/questionnaire - Answer updated for question ${questionId}. New value (type ${typeof value.value}): ${JSON.stringify(value.value)}`);
     } else {
         console.error(`PATCH /api/profile/questionnaire - Invalid update type: ${value.type}`);
         return NextResponse.json({ success: false, error: "סוג עדכון לא תקין" }, { status: 400 });
     }

     const updatedAnswers = [...currentAnswers];
     if (existingAnswerIndex !== -1) {
         updatedAnswers[existingAnswerIndex] = updatedAnswer;
     } else if (value.type === 'answer') {
         updatedAnswers.push(updatedAnswer);
         console.log(`PATCH /api/profile/questionnaire - New answer added for question ${questionId}.`);
     } else if (value.type === 'visibility' && existingAnswerIndex === -1) {
        // זה לא אמור לקרות כי כבר בדקנו !existingAnswer למעלה עבור visibility
        console.error(`PATCH /api/profile/questionnaire - Logic error: Trying to update visibility for a new answer that wasn't added.`);
        return NextResponse.json({ success: false, error: "שגיאה לוגית בעדכון נראות" }, { status: 500 });
     }


     console.log(`PATCH /api/profile/questionnaire - Attempting to update database with new answers for dbKey ${dbKey}.`);
     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });
          // --- START OF NEW CODE ---
     // 2. הפעלת עדכון פרופיל ה-AI לאחר עדכון תשובות לשאלון
     updateUserAiProfile(userId).catch(err => {
        console.error(`[AI Profile Trigger - Questionnaire Update] Failed to update AI profile in the background for user ${userId}:`, err);
     });
     // --- END OF NEW CODE ---
     console.log(`PATCH /api/profile/questionnaire - Database update successful for questionnaire ID: ${updated.id}.`);

     const formattedAnswers: Partial<FormattedAnswersType> = {};
     (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(key => {
       const currentDbKey = getDbKey(key);
        if (updated[currentDbKey]) {
            formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
        } else {
            formattedAnswers[key] = [];
        }
     });

     const completeFormattedAnswers = formattedAnswers as FormattedAnswersType;

     const formattedResponse = {
       ...updated,
       formattedAnswers: completeFormattedAnswers
     };

     console.log("PATCH /api/profile/questionnaire - Update process completed successfully. Returning formatted response.");
     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error('Prisma Error Details:', { code: error.code, meta: error.meta, clientVersion: error.clientVersion });
            return NextResponse.json({ success: false, error: "שגיאת מסד נתונים" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           console.error('JSON Parsing Error in PATCH request body:', error.message);
           return NextResponse.json({ success: false, error: "גוף הבקשה אינו JSON תקין" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "שגיאה בעדכון השאלון" }, { status: 500 });
   }
}
// --- END OF FILE route.ts ---
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/update/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  Profile, // Import Prisma's Profile type
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. ייבוא

// Helper to convert to number or null
const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

// Helper to convert to Date or error if invalid for required fields
const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

// Helper to convert to Date or null for optional fields
const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

// Helper to convert empty string or null to null, otherwise return the string
const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};

export async function PUT(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    let body;
    try {
      body = await req.json();
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    // Ensure all fields from UserProfile that can be updated are destructured
    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      about,
      parentStatus,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious, // This is for the user themselves
      profileCharacterTraits,
      profileHobbies, // User's own hobbies
      aliyaCountry,
      aliyaYear,
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      // This is the preference about the partner's children status
      preferredHasChildrenFromPrevious, // This field should now exist in Prisma schema
      preferredCharacterTraits, // Preference for partner's traits
      preferredHobbies,         // Preference for partner's hobbies (ensure distinct from profileHobbies if needed)
      preferredAliyaStatus, // If you have this field for preferences
          hasViewedProfilePreview, // <--- תיקון 1: קליטת הערך החדש

    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status & Background (User's own) ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious; // User's own
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education, Occupation & Service (User's own) ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion & Lifestyle (User's own) ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (body.hasOwnProperty('kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (body.hasOwnProperty('headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits & Hobbies (User's own) ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || []; // User's own hobbies

    // --- About & Additional Info ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    
    // --- Preferences (related to matching partner) ---
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah); // Assuming it's a string like "yes", "no" that needs to be nullable
    
    // This is the CRITICAL FIX: Use the correct field name that exists in Prisma schema
    if (preferredHasChildrenFromPrevious !== undefined) {
      dataToUpdate.preferredHasChildrenFromPrevious = preferredHasChildrenFromPrevious; // This should now work if field added to schema
    }

    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || []; // Preference for partner
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || []; // Preference for partner's hobbies
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);

    // --- Profile Management ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
   if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      if (!body.hasOwnProperty('availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    if (body.hasOwnProperty('availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // --- Perform the database update ---
    let updatedProfileRecord: Profile | null = null;
    if (Object.keys(dataToUpdate).length > 0) {
      try {
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
        
        // --- START OF NEW CODE ---
        // 2. הפעלת עדכון פרופיל ה-AI ברקע לאחר עדכון מוצלח
        updateUserAiProfile(userId).catch(err => {
            console.error(`[AI Profile Trigger - Profile Update] Failed to update AI profile in the background for user ${userId}:`, err);
        });
        // --- END OF NEW CODE ---
      } catch (dbError) {
        console.error('Prisma profile update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // Construct the response, ensuring all UserProfile fields are mapped
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, // Assuming Prisma.Profile.gender is Gender, not Gender | null
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      about: dbProfile.about || "",
      parentStatus: dbProfile.parentStatus || undefined,
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, // User's own
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], // User's own
      profileHobbies: dbProfile.profileHobbies || [],                 // User's own
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], // Cast if Prisma returns string[] but UserProfile expects ServiceType[]
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined, // Assuming it's string in Prisma (like "yes", "no")
      preferredHasChildrenFromPrevious: dbProfile.preferredHasChildrenFromPrevious ?? undefined, // Preference, should exist now
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], // Partner preference
      preferredHobbies: dbProfile.preferredHobbies || [],                 // Partner preference
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
            hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, // <--- תיקון 3: הוספת השדה לאובייקט התגובה

      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('Profile update route error:', error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for profile_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/route.ts (GET handler)

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, HeadCoveringType, KippahType, ServiceType } from "@prisma/client"; // Import enums if needed for casting
import type { UserProfile } from "@/types/next-auth";

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    let targetUserId: string;
    if (requestedUserId) {
      targetUserId = requestedUserId;
    } else if (session.user.id) {
      targetUserId = session.user.id;
    } else {
       return NextResponse.json(
        { success: false, message: 'User ID not found in session' },
        { status: 400 }
      );
    }

    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // <--- FIX 1: Select the isProfileComplete field from the User model.
        profile: {
          select: {
            id: true,
            userId: true,
            gender: true,
            birthDate: true,
            nativeLanguage: true,
            additionalLanguages: true,
            height: true,
            city: true,
            origin: true,
            aliyaCountry: true,
            aliyaYear: true,
            maritalStatus: true,
            hasChildrenFromPrevious: true,
            parentStatus: true,
            siblings: true,
            position: true,
            educationLevel: true,
            education: true,
            occupation: true,
            serviceType: true,
            serviceDetails: true,
            religiousLevel: true,
            shomerNegiah: true,
            headCovering: true,
            kippahType: true,
            profileCharacterTraits: true,
            profileHobbies: true,
            about: true,
            matchingNotes: true,
            preferredAgeMin: true,
            preferredAgeMax: true,
            preferredHeightMin: true,
            preferredHeightMax: true,
            preferredReligiousLevels: true,
            preferredLocations: true,
            preferredEducation: true,
            preferredOccupations: true,
            contactPreference: true,
            isProfileVisible: true,
            preferredMatchmakerGender: true,
            availabilityStatus: true,
            availabilityNote: true,
            availabilityUpdatedAt: true,
            preferredMaritalStatuses: true,
            preferredOrigins: true,
            preferredServiceTypes: true,
            preferredHeadCoverings: true,
            preferredKippahTypes: true,
            preferredShomerNegiah: true,
            preferredHasChildrenFromPrevious: true,
            preferredCharacterTraits: true,
            preferredHobbies: true,
            preferredAliyaStatus: true,
            createdAt: true,
            updatedAt: true,
            lastActive: true,
            verifiedBy: true,
            hasViewedProfilePreview: true,
          }
        },
        images: {
          select: {
            id: true,
            url: true,
            isMain: true,
            createdAt: true,
            cloudinaryPublicId: true,
            updatedAt: true,
          }
        }
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        console.error(`Profile data not found for user ID: ${targetUserId}`);
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    if (!dbProfile.birthDate) {
        console.error(`birthDate is null or undefined for profile ID: ${dbProfile.id}`);
        return NextResponse.json(
            { success: false, message: 'Data integrity issue: birthDate is missing for the profile.' },
            { status: 500 }
        );
    }

    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType as ServiceType | null || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering as HeadCoveringType | null || undefined,
      kippahType: dbProfile.kippahType as KippahType | null || undefined,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      about: dbProfile.about || "",
      matchingNotes: dbProfile.matchingNotes || "",
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete, // <--- FIX 2: Add the property to the response object.
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender as Gender | null || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [],
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredHasChildrenFromPrevious: dbProfile.preferredHasChildrenFromPrevious ?? undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };
    
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};
// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// GET - Fetch all images for a user
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: { 
        user: {
          email: session.user.email 
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error("[GetImages] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch images" },
      { status: 500 }
    );
  }
}

// POST - Upload a new image
export async function POST(req: Request) {
  try {
    console.log("[Upload] Starting upload process");
    
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error("[Upload] Authentication failed - No user session");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: { images: true },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    if (user.images.length >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { error: "Maximum number of images reached" },
        { status: 400 }
      );
    }

    const formData = await req.formData();
    const file = formData.get("file") as File;
    
    if (!file) {
      console.error("[Upload] No file provided in request");
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    // Validate file
    const validTypes = ["image/jpeg", "image/png", "image/jpg"];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        { error: "Invalid file type. Only JPG and PNG are allowed" },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { error: "File size must be less than 5MB" },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    try {
      const uploadPromise = new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          {
            folder: "profile-images",
            resource_type: "image",
          },
          (error, result) => {
            if (error) reject(error);
            else resolve(result);
          }
        );
        uploadStream.end(buffer);
      });

      const result = await uploadPromise as CloudinaryUploadResult;

      const image = await prisma.userImage.create({
        data: {
          userId: user.id,
          url: result.secure_url,
          cloudinaryPublicId: result.public_id,
          isMain: user.images.length === 0,
        },
      });

      return NextResponse.json({ success: true, image });
    } catch (cloudinaryError) {
      console.error("[Upload] Cloudinary upload failed:", cloudinaryError);
      return NextResponse.json(
        { error: "Failed to upload image to cloud storage" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("[Upload] General error:", error);
    return NextResponse.json(
      { error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;
    
    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Delete from Cloudinary if cloudinaryPublicId exists
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
        // Continue with database deletion even if Cloudinary deletion fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId },
    });

    // If this was the main image, set another image as main if available
    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;

    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Reset all user's images to non-main
    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    // Set the selected image as main
    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    // Get updated images list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// --- START OF FILE route.ts ---

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth"; // ודא שהנתיב הזה נכון
import prisma from "@/lib/prisma"; // ודא שהנתיב הזה נכון
import { Prisma } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. ייבוא

// ודא שהנתיבים האלה נכונים לקבצי השאלות שלך
import { valuesQuestions } from "@/components/questionnaire/questions/values/valuesQuestions";
import { personalityQuestions } from "@/components/questionnaire/questions/personality/personalityQuestions";
import { relationshipQuestions } from "@/components/questionnaire/questions/relationship/relationshipQuestions";
import { partnerQuestions } from "@/components/questionnaire/questions/partner/partnerQuestions";
import { religionQuestions } from "@/components/questionnaire/questions/religion/religionQuestions";


// Combine all questions into a single array
const allQuestions = [
  ...valuesQuestions,
  ...personalityQuestions,
  ...relationshipQuestions,
  ...partnerQuestions,
  ...religionQuestions
];

// Define key types
type WorldKey = 'values' | 'personality' | 'relationship' | 'partner' | 'religion';
type DbWorldKey = 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers';

// Key mapping utility
const KEY_MAPPING: Record<WorldKey, DbWorldKey> = {
  values: 'valuesAnswers',
  personality: 'personalityAnswers',
  relationship: 'relationshipAnswers',
  partner: 'partnerAnswers',
  religion: 'religionAnswers'
};

function getDbKey(worldKey: WorldKey): DbWorldKey {
  return KEY_MAPPING[worldKey];
}

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible?: boolean;
}

interface UpdateData {
  type: 'answer' | 'visibility';
  value?: Prisma.JsonValue; // התאמה לשימוש ב- Prisma.JsonValue גם כאן
  isVisible?: boolean;
}

interface FormattedAnswer {
  questionId: string;
  question: string;
  value: Prisma.JsonValue;
  displayText: string;
  answeredAt: string;
  category?: string;
  isVisible?: boolean;
}

type FormattedAnswersType = Record<WorldKey, FormattedAnswer[]>;

const valueTranslations: Record<string, string> = {
  'combat': 'קרבי',
  'intelligence': 'אינטליגנציה',
  'stable': 'יציב',
  'yes': 'כן',
  'no': 'לא',
  'religious': 'דתי',
  'traditional': 'מסורתי',
  'secular': 'חילוני',
  'male': 'גבר',
  'female': 'אישה',
  'both': 'שניהם',
  'high': 'גבוהה',
  'medium': 'בינונית',
  'low': 'נמוכה'
  // Add other translations as needed based on your actual values
};

function getQuestionLabel(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.question || questionId;
}

function getQuestionCategory(questionId: string): string {
  const question = allQuestions.find(q => q.id === questionId);
  return question?.category || question?.worldId.toLowerCase() || '';
}


function formatValue(value: Prisma.JsonValue): string {
  if (typeof value === 'boolean') {
    return value ? 'כן' : 'לא';
  }

  if (Array.isArray(value)) {
    return value.map(v => valueTranslations[String(v)] || String(v)).join(', ');
  }

  if (typeof value === 'object' && value !== null) {
    return JSON.stringify(value);
  }

  const stringValue = String(value);
  return valueTranslations[stringValue] || stringValue;
}

function isValidAnswerObject(item: Prisma.JsonValue): item is Prisma.JsonObject & {
  questionId: string | number;
  value: Prisma.JsonValue;
  answeredAt: string | number;
  isVisible?: boolean;
} {
  return typeof item === 'object' &&
         item !== null &&
         'questionId' in item &&
         'value' in item &&
         item.value !== undefined &&
         'answeredAt' in item;
}

function safeParseJson(value: Prisma.JsonValue | null): JsonAnswerData[] {
   if (Array.isArray(value)) {
     return value
       .filter(isValidAnswerObject)
       .map(item => ({
         questionId: String(item.questionId),
         value: item.value,
         answeredAt: String(item.answeredAt),
         isVisible: Boolean(item.isVisible ?? true)
       }));
   }
   return [];
}

function formatAnswers(answers: Prisma.JsonValue | null): FormattedAnswer[] {
  const parsedAnswers = safeParseJson(answers);

  return parsedAnswers.map(answer => {
    const displayText = formatValue(answer.value);
    const category = getQuestionCategory(answer.questionId);

    return {
      questionId: answer.questionId,
      question: getQuestionLabel(answer.questionId),
      value: answer.value,
      displayText,
      category,
      isVisible: answer.isVisible,
      answeredAt: new Date(answer.answeredAt).toLocaleDateString('he-IL', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    };
  }).sort((a, b) => a.questionId.localeCompare(b.questionId));
}


export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const userId = url.searchParams.get('userId') || session.user.id;

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });

    if (!questionnaireResponse) {
       return NextResponse.json({
          success: true,
          questionnaireResponse: null
       });
    }

    const formattedAnswers: Partial<FormattedAnswersType> = {};

    (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(worldKey => {
       const dbKey = getDbKey(worldKey);
       if (questionnaireResponse[dbKey]) {
           formattedAnswers[worldKey] = formatAnswers(questionnaireResponse[dbKey]);
       } else {
           formattedAnswers[worldKey] = [];
       }
    });

    const completeFormattedAnswers = formattedAnswers as FormattedAnswersType;

    const formattedResponse = {
      ...questionnaireResponse,
      formattedAnswers: completeFormattedAnswers
    };

    if (userId !== session.user.id) {
       Object.keys(formattedResponse.formattedAnswers).forEach((worldKey) => {
           const key = worldKey as WorldKey;
           if (formattedResponse.formattedAnswers[key]) {
               formattedResponse.formattedAnswers[key] =
                 formattedResponse.formattedAnswers[key].filter(answer => answer.isVisible !== false);
           }
       });
    }

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedResponse
    });

  } catch (error) {
    console.error('Error in GET /api/profile/questionnaire:', error);
    return NextResponse.json({ success: false, error: "Failed to fetch questionnaire" }, { status: 500 });
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       console.log("PATCH /api/profile/questionnaire - Unauthorized: No session or user ID.");
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
        const userId = session.user.id; // <-- הגדרת userId
     console.log(`PATCH /api/profile/questionnaire - Authorized for user: ${session.user.id}`);

     const body = await req.json();
     // =================================================================
     // === לוג עיקרי לבדיקת גוף הבקשה שהשרת מקבל ===
     console.log("PATCH /api/profile/questionnaire - Received body:", JSON.stringify(body, null, 2));
     // =================================================================

     // ננסה לגשת לשדות ישירות מ-body לצורך הלוגים, לפני ה-destructuring
     const receivedWorldKey = body.worldKey;
     const receivedQuestionId = body.questionId;
     const receivedValueObject = body.value;
     const receivedValueType = body.value?.type;

     // Destructuring and type assertion (assuming body structure is correct)
     const { worldKey, questionId, value } = body as {
       worldKey: WorldKey;
       questionId: string;
       value: UpdateData;
     };

     // Validate input
     if (!worldKey || !questionId || !value || !value.type) {
        // === לוג מפורט יותר אם הבדיקה הזו נכשלת ===
        console.error("PATCH /api/profile/questionnaire - Invalid request body. Validation failed. Details:", {
            rawReceivedBody: body, // מדפיס את כל מה שהתקבל
            expectedWorldKey: worldKey, // הערך לאחר destructuring
            expectedQuestionId: questionId, // הערך לאחר destructuring
            expectedValueObject: value, // הערך לאחר destructuring
            isWorldKeyTruthyInBody: !!receivedWorldKey,
            isQuestionIdTruthyInBody: !!receivedQuestionId,
            isValueObjectTruthyInBody: !!receivedValueObject,
            isValueTypeTruthyInBody: !!receivedValueType,
        });
        // =====================================================
        return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
     }

     if (!KEY_MAPPING[worldKey]) {
         console.error(`PATCH /api/profile/questionnaire - Invalid world key: ${worldKey}`);
         return NextResponse.json({ success: false, error: "Invalid world key" }, { status: 400 });
     }

     const dbKey = getDbKey(worldKey);

     console.log(`PATCH /api/profile/questionnaire - Processing update for worldKey: ${worldKey}, questionId: ${questionId}, dbKey: ${dbKey}, updateType: ${value.type}`);

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       console.error(`PATCH /api/profile/questionnaire - Questionnaire not found for user ID: ${session.user.id}`);
       return NextResponse.json({ success: false, error: "שאלון לא נמצא" }, { status: 404 });
     }
     console.log(`PATCH /api/profile/questionnaire - Found questionnaire ID: ${questionnaire.id} for user.`);

     const currentAnswers = safeParseJson(questionnaire[dbKey]);
     const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
     const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

     let updatedAnswer: JsonAnswerData;

     if (value.type === 'visibility') {
        console.log(`PATCH /api/profile/questionnaire - Handling 'visibility' update.`);
        if (!existingAnswer) {
          console.error(`PATCH /api/profile/questionnaire - Cannot update visibility for non-existent answer. Question ID: ${questionId}`);
          return NextResponse.json({ success: false, error: "לא נמצאה תשובה לעדכון נראות" }, { status: 404 });
        }
        if (typeof value.isVisible !== 'boolean') {
             console.error(`PATCH /api/profile/questionnaire - Invalid visibility value: ${value.isVisible}. Must be boolean.`);
             return NextResponse.json({ success: false, error: "ערך נראות לא תקין" }, { status: 400 });
        }
        updatedAnswer = {
          ...existingAnswer,
          isVisible: value.isVisible,
          answeredAt: new Date().toISOString()
        };
        console.log(`PATCH /api/profile/questionnaire - Visibility updated for question ${questionId} to ${value.isVisible}.`);
     } else if (value.type === 'answer') {
       console.log(`PATCH /api/profile/questionnaire - Handling 'answer' update.`);
       if (value.value === undefined) { // אפשר להוסיף בדיקה יותר מחמירה אם value.value הוא null או מחרוזת ריקה, תלוי בדרישות
            console.error(`PATCH /api/profile/questionnaire - Answer value is missing.`);
            return NextResponse.json({ success: false, error: "ערך תשובה חסר" }, { status: 400 });
       }
       updatedAnswer = {
         questionId,
         value: value.value, // ה-type של value.value כבר אמור להיות Prisma.JsonValue לפי UpdateData
         isVisible: existingAnswer?.isVisible ?? true,
         answeredAt: new Date().toISOString()
       };
       console.log(`PATCH /api/profile/questionnaire - Answer updated for question ${questionId}. New value (type ${typeof value.value}): ${JSON.stringify(value.value)}`);
     } else {
         console.error(`PATCH /api/profile/questionnaire - Invalid update type: ${value.type}`);
         return NextResponse.json({ success: false, error: "סוג עדכון לא תקין" }, { status: 400 });
     }

     const updatedAnswers = [...currentAnswers];
     if (existingAnswerIndex !== -1) {
         updatedAnswers[existingAnswerIndex] = updatedAnswer;
     } else if (value.type === 'answer') {
         updatedAnswers.push(updatedAnswer);
         console.log(`PATCH /api/profile/questionnaire - New answer added for question ${questionId}.`);
     } else if (value.type === 'visibility' && existingAnswerIndex === -1) {
        // זה לא אמור לקרות כי כבר בדקנו !existingAnswer למעלה עבור visibility
        console.error(`PATCH /api/profile/questionnaire - Logic error: Trying to update visibility for a new answer that wasn't added.`);
        return NextResponse.json({ success: false, error: "שגיאה לוגית בעדכון נראות" }, { status: 500 });
     }


     console.log(`PATCH /api/profile/questionnaire - Attempting to update database with new answers for dbKey ${dbKey}.`);
     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });
          // --- START OF NEW CODE ---
     // 2. הפעלת עדכון פרופיל ה-AI לאחר עדכון תשובות לשאלון
     updateUserAiProfile(userId).catch(err => {
        console.error(`[AI Profile Trigger - Questionnaire Update] Failed to update AI profile in the background for user ${userId}:`, err);
     });
     // --- END OF NEW CODE ---
     console.log(`PATCH /api/profile/questionnaire - Database update successful for questionnaire ID: ${updated.id}.`);

     const formattedAnswers: Partial<FormattedAnswersType> = {};
     (Object.keys(KEY_MAPPING) as WorldKey[]).forEach(key => {
       const currentDbKey = getDbKey(key);
        if (updated[currentDbKey]) {
            formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
        } else {
            formattedAnswers[key] = [];
        }
     });

     const completeFormattedAnswers = formattedAnswers as FormattedAnswersType;

     const formattedResponse = {
       ...updated,
       formattedAnswers: completeFormattedAnswers
     };

     console.log("PATCH /api/profile/questionnaire - Update process completed successfully. Returning formatted response.");
     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error('Prisma Error Details:', { code: error.code, meta: error.meta, clientVersion: error.clientVersion });
            return NextResponse.json({ success: false, error: "שגיאת מסד נתונים" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           console.error('JSON Parsing Error in PATCH request body:', error.message);
           return NextResponse.json({ success: false, error: "גוף הבקשה אינו JSON תקין" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "שגיאה בעדכון השאלון" }, { status: 500 });
   }
}
// --- END OF FILE route.ts ---
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/update/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  Profile, // Import Prisma's Profile type
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. ייבוא

// Helper to convert to number or null
const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

// Helper to convert to Date or error if invalid for required fields
const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

// Helper to convert to Date or null for optional fields
const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

// Helper to convert empty string or null to null, otherwise return the string
const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};

export async function PUT(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    let body;
    try {
      body = await req.json();
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    // Ensure all fields from UserProfile that can be updated are destructured
    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      about,
      parentStatus,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious, // This is for the user themselves
      profileCharacterTraits,
      profileHobbies, // User's own hobbies
      aliyaCountry,
      aliyaYear,
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      // This is the preference about the partner's children status
      preferredHasChildrenFromPrevious, // This field should now exist in Prisma schema
      preferredCharacterTraits, // Preference for partner's traits
      preferredHobbies,         // Preference for partner's hobbies (ensure distinct from profileHobbies if needed)
      preferredAliyaStatus, // If you have this field for preferences
          hasViewedProfilePreview, // <--- תיקון 1: קליטת הערך החדש

    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status & Background (User's own) ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious; // User's own
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education, Occupation & Service (User's own) ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion & Lifestyle (User's own) ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (body.hasOwnProperty('kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (body.hasOwnProperty('headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits & Hobbies (User's own) ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || []; // User's own hobbies

    // --- About & Additional Info ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    
    // --- Preferences (related to matching partner) ---
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah); // Assuming it's a string like "yes", "no" that needs to be nullable
    
    // This is the CRITICAL FIX: Use the correct field name that exists in Prisma schema
    if (preferredHasChildrenFromPrevious !== undefined) {
      dataToUpdate.preferredHasChildrenFromPrevious = preferredHasChildrenFromPrevious; // This should now work if field added to schema
    }

    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || []; // Preference for partner
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || []; // Preference for partner's hobbies
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);

    // --- Profile Management ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
   if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      if (!body.hasOwnProperty('availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    if (body.hasOwnProperty('availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // --- Perform the database update ---
    let updatedProfileRecord: Profile | null = null;
    if (Object.keys(dataToUpdate).length > 0) {
      try {
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
        
        // --- START OF NEW CODE ---
        // 2. הפעלת עדכון פרופיל ה-AI ברקע לאחר עדכון מוצלח
        updateUserAiProfile(userId).catch(err => {
            console.error(`[AI Profile Trigger - Profile Update] Failed to update AI profile in the background for user ${userId}:`, err);
        });
        // --- END OF NEW CODE ---
      } catch (dbError) {
        console.error('Prisma profile update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // Construct the response, ensuring all UserProfile fields are mapped
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, // Assuming Prisma.Profile.gender is Gender, not Gender | null
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      about: dbProfile.about || "",
      parentStatus: dbProfile.parentStatus || undefined,
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
            isProfileComplete: refreshedUserWithProfile.isProfileComplete,

      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, // User's own
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], // User's own
      profileHobbies: dbProfile.profileHobbies || [],                 // User's own
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], // Cast if Prisma returns string[] but UserProfile expects ServiceType[]
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined, // Assuming it's string in Prisma (like "yes", "no")
      preferredHasChildrenFromPrevious: dbProfile.preferredHasChildrenFromPrevious ?? undefined, // Preference, should exist now
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], // Partner preference
      preferredHobbies: dbProfile.preferredHobbies || [],                 // Partner preference
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
            hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, // <--- תיקון 3: הוספת השדה לאובייקט התגובה

      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('Profile update route error:', error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { Prisma } from "@prisma/client";

function isPrismaError(error: unknown): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

const WORLD_IDS = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;

const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const baseAnswerSchema = z.object({
  questionId: z.string().min(1),
  worldId: WorldId,
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number())
  ]),
  answeredAt: z.string().datetime()
});

type QuestionAnswer = z.infer<typeof baseAnswerSchema>;

const QuestionnaireAnswer = baseAnswerSchema;

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional()
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

function groupAnswersByWorld(answers: QuestionnaireSubmission["answers"]) {
  return answers.reduce<Record<string, QuestionAnswer[]>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer: QuestionAnswer = {
      questionId: answer.questionId,
      worldId: answer.worldId,
      value: answer.value,
      answeredAt: answer.answeredAt
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);
    
    return acc;
  }, {});
}

function validateSubmissionData(data: unknown): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);
  
  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    const transformedData = questionnaire ? {
      ...questionnaire,
      valuesAnswers: questionnaire.valuesAnswers || [],
      personalityAnswers: questionnaire.personalityAnswers || [],
      relationshipAnswers: questionnaire.relationshipAnswers || [],
      partnerAnswers: questionnaire.partnerAnswers || [],
      religionAnswers: questionnaire.religionAnswers || [],
    } : null;

    return NextResponse.json({
      success: true,
      data: transformedData
    });

  } catch (error: unknown) {
    console.error("Error fetching questionnaire:", {
      message: isError(error) ? error.message : "Unknown error occurred",
      stack: process.env.NODE_ENV === 'development' ? error : undefined
    });

    return NextResponse.json({
      error: "אירעה שגיאה בטעינת השאלון",
      details: process.env.NODE_ENV === 'development' ? error : undefined
    }, { status: 500 });
  }
}

type Answer = {
  questionId: string;
  worldId: WorldId;
  value: string | number | string[] | number[] | Record<string, number>;
  answeredAt: string;
};

type MergedAnswers = {
  valuesAnswers: Answer[];
  personalityAnswers: Answer[];
  relationshipAnswers: Answer[];
  partnerAnswers: Answer[];
  religionAnswers: Answer[];
};

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "נדרשת התחברות" }, { status: 401 });
    }

    const rawBody = await req.json();
    
    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers: rawBody.answers?.filter((answer: Answer) => 
        answer && 
        answer.questionId && 
        answer.worldId && 
        answer.value !== undefined && 
        answer.value !== null && 
        answer.value !== ''
      ) ?? []
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: isError(error) ? error.message : 'Unknown validation error'
      }, { status: 400 });
    }

    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    const result = await prisma.$transaction(async (prisma) => {
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' }
      });

      const mergedAnswers: MergedAnswers = {
        valuesAnswers: [...(existingResponse?.valuesAnswers as Answer[] || []), ...(answersGroupedByWorld.valuesAnswers || [])],
        personalityAnswers: [...(existingResponse?.personalityAnswers as Answer[] || []), ...(answersGroupedByWorld.personalityAnswers || [])],
        relationshipAnswers: [...(existingResponse?.relationshipAnswers as Answer[] || []), ...(answersGroupedByWorld.relationshipAnswers || [])],
        partnerAnswers: [...(existingResponse?.partnerAnswers as Answer[] || []), ...(answersGroupedByWorld.partnerAnswers || [])],
        religionAnswers: [...(existingResponse?.religionAnswers as Answer[] || []), ...(answersGroupedByWorld.religionAnswers || [])]
      };

      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof MergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce((acc: Answer[], curr: Answer) => {
            const existingIndex = acc.findIndex(a => a.questionId === curr.questionId);
            if (existingIndex >= 0) {
              if (new Date(curr.answeredAt) > new Date(acc[existingIndex].answeredAt)) {
                acc[existingIndex] = curr;
              }
            } else {
              acc.push(curr);
            }
            return acc;
          }, []);
          mergedAnswers[worldKey as keyof MergedAnswers] = uniqueAnswers;
        }
      }

      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt ? new Date(validatedData.completedAt) : null,
          valuesCompleted: validatedData.worldsCompleted.includes("VALUES"),
          personalityCompleted: validatedData.worldsCompleted.includes("PERSONALITY"),
          relationshipCompleted: validatedData.worldsCompleted.includes("RELATIONSHIP"),
          partnerCompleted: validatedData.worldsCompleted.includes("PARTNER"),
          religionCompleted: validatedData.worldsCompleted.includes("RELIGION"),
          lastSaved: new Date()
        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt ? new Date(validatedData.completedAt) : null,
          valuesCompleted: validatedData.worldsCompleted.includes("VALUES"),
          personalityCompleted: validatedData.worldsCompleted.includes("PERSONALITY"),
          relationshipCompleted: validatedData.worldsCompleted.includes("RELATIONSHIP"),
          partnerCompleted: validatedData.worldsCompleted.includes("PARTNER"),
          religionCompleted: validatedData.worldsCompleted.includes("RELIGION"),
          lastSaved: new Date()
        }
      });

      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: "ACTIVE" }
        });
      }

      return savedQuestionnaire;
    });

    return NextResponse.json({
      success: true,
      data: result
    });

  } catch (error: unknown) {
    const errorMessage = isError(error) ? error.message : "Unknown error occurred";
    const errorStack = isError(error) ? error.stack : undefined;

    console.error("Error details:", {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined
    });

    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון - משתמש לא קיים",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 400 });
        case 'P2002':
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון - רשומה כבר קיימת",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 409 });
        default:
          return NextResponse.json({
            error: "שגיאה בשמירת השאלון",
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }, { status: 500 });
      }
    }

    return NextResponse.json({
      error: "אירעה שגיאה בשמירת השאלון",
      details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\questionnaire\complete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const requiredWorlds = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;
    const allWorldsCompleted = requiredWorlds.every(
      world => validatedData.worldsCompleted.includes(world)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "לא כל העולמות הושלמו"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: "לא נמצא שאלון להשלמה"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
      prisma.user.update({
        where: { id: session.user.id },
        data: { status: "ACTIVE" }
      })
    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "אירעה שגיאה בהשלמת השאלון"
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\questionnaire\world
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\questionnaire\world\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/questionnaire/world/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { Prisma } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

// Define the WorldId type and validation schema
const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);
type WorldId = z.infer<typeof WorldId>;

// Schema for a single answer within a world submission
const answerSchema = z.object({
  questionId: z.string().min(1),
  value: z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
    z.null(),
    z.undefined()
  ]).optional(),
  answeredAt: z.string().datetime().transform((str) => new Date(str)), // Convert to Date object
  isVisible: z.boolean().default(true),
});

// Main schema for submitting answers for a whole world
const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(answerSchema),
});

type AnswerPayload = z.infer<typeof answerSchema>;

export async function PUT(req: Request) {
  try {
    // 1. Authenticate user
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. Parse and validate request body
    const body = await req.json();
    const validationResult = worldAnswersSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error in /questionnaire/world:", validationResult.error);
      return NextResponse.json({ success: false, error: "Invalid request data", details: validationResult.error.flatten() }, { status: 400 });
    }
    const { worldId, answers: newAnswers } = validationResult.data;
    
    // Map worldId to the corresponding DB field name
    const dbAnswersKey = `${worldId.toLowerCase()}Answers` as keyof Prisma.QuestionnaireResponseCreateInput;
    const dbCompletedKey = `${worldId.toLowerCase()}Completed` as keyof Prisma.QuestionnaireResponseCreateInput;

    // 3. Upsert the questionnaire response
    const updatedQuestionnaire = await prisma.$transaction(async (tx) => {
      // Find the existing response for the user
      const existingResponse = await tx.questionnaireResponse.findFirst({
        where: { userId },
      });

      // Prepare the JSON data for the answers
      const newAnswersJson = newAnswers.map(ans => ({
        ...ans,
        answeredAt: ans.answeredAt.toISOString(), // Ensure date is stored as string
      })) as unknown as Prisma.JsonArray; // Cast to Prisma.JsonArray

      // Create or update the questionnaire
      const questionnaire = await tx.questionnaireResponse.upsert({
        where: { id: existingResponse?.id || 'new-response-placeholder' }, // a dummy id for create case
        create: {
          userId,
          startedAt: new Date(),
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: [worldId],
        },
        update: {
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson, // Replace all answers for this world
          [dbCompletedKey]: true,
          worldsCompleted: {
            push: worldId, // Add to the array of completed worlds
          },
        },
      });
      return questionnaire;
    });

    // 4. Trigger the AI profile update in the background
    updateUserAiProfile(userId).catch(err => {
        console.error(`[AI Profile Trigger - World Update] Failed to update AI profile for user ${userId} after updating world ${worldId}:`, err);
    });

    // 5. Return success response
    return NextResponse.json({
      success: true,
      message: `Successfully saved answers for world: ${worldId}`,
      data: updatedQuestionnaire,
    });

  } catch (error: unknown) {
    console.error("Error in PUT /api/questionnaire/world:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json({ success: false, error: "Validation error", details: error.issues }, { status: 400 });
    }
    
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.string().refine((val) => !isNaN(Date.parse(val)), { // Validate as date string
    message: "Invalid date format for decisionDeadline",
  }).transform((val) => new Date(val)), // Transform to Date object
});

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) { // Check for user.id and user.role
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for POST ----
    // 2. Role verification (only matchmakers or admins can create suggestions)
    const allowedCreatorRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedCreatorRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to create suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE for POST ----

    // 3. Parse and validate request body
    const body = await req.json();
    const validationResult = createSuggestionSchema.safeParse(body);

    if (!validationResult.success) {
        return NextResponse.json(
            { error: "Validation error", details: validationResult.error.errors },
            { status: 400 }
        );
    }
    const validatedData = validationResult.data;


    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
                MatchSuggestionStatus.FIRST_PARTY_DECLINED, // Added
                MatchSuggestionStatus.SECOND_PARTY_DECLINED, // Added
                MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // Added
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: `Active or pending suggestion (ID: ${existingSuggestion.id}, Status: ${existingSuggestion.status}) already exists between these parties` },
        { status: 409 } // Conflict
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id, // The user creating is the matchmaker
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline,
          firstPartySent: new Date(),
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Initialize lastActivity
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion); // Consider passing the full suggestion object

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion, // Return the created suggestion object
    }, { status: 201 }); // HTTP 201 Created
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    // Handle Prisma unique constraint errors specifically if needed
    // if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {}
    
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for PATCH (General permission) ----
    const allowedUpdaterRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN, UserRole.CANDIDATE]; // CANDIDATE can update if they are a party
    if (!allowedUpdaterRoles.includes(session.user.role as UserRole)) {
        return NextResponse.json({ error: "Forbidden - Insufficient permissions to update suggestion status" }, { status: 403 });
    }
    // ---- END OF CHANGE for PATCH ----

    const body = await req.json();
    const { suggestionId, status, notes } = body; // Assuming status and notes are part of body

    // Validate incoming data (basic example)
    if (!suggestionId || !status) {
        return NextResponse.json({ error: "Missing suggestionId or status" }, { status: 400 });
    }
    if (!Object.values(MatchSuggestionStatus).includes(status as MatchSuggestionStatus)) {
        return NextResponse.json({ error: "Invalid status value" }, { status: 400 });
    }


    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true, // Include matchmaker for permission checks
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // ---- Specific permission check for PATCH ----
    // An ADMIN can update any suggestion.
    // A MATCHMAKER can update suggestions they created.
    // A CANDIDATE can update suggestions they are a party to (firstPartyId or secondPartyId).
    const isUserAdmin = session.user.role === UserRole.ADMIN;
    const isUserMatchmakerOwner = session.user.role === UserRole.MATCHMAKER && suggestion.matchmakerId === session.user.id;
    const isUserParty = session.user.role === UserRole.CANDIDATE && (suggestion.firstPartyId === session.user.id || suggestion.secondPartyId === session.user.id);

    if (!isUserAdmin && !isUserMatchmakerOwner && !isUserParty) {
        return NextResponse.json({ error: "Forbidden - You do not have permission to update this specific suggestion's status." }, { status: 403 });
    }
    // ---- End specific permission check ----


    // 3. Validate status transition (using your existing helper)
    const isValidTransition = validateStatusTransition(suggestion.status, status as MatchSuggestionStatus);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: `Invalid status transition from ${suggestion.status} to ${status}` },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status as MatchSuggestionStatus,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Update lastActivity
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            // closedAt: new Date(), // Typically, CONTACT_DETAILS_SHARED doesn't mean closed
          }),
          ...(status === MatchSuggestionStatus.CLOSED && { // Explicitly set closedAt for CLOSED status
            closedAt: new Date(),
          }),
        },
      });

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status: status as MatchSuggestionStatus,
          notes: notes || `Status changed to ${status} by user ${session.user.id}`, // Add more context to notes
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    // This logic might be better suited in a service layer or triggered by events
    // For example, if status is FIRST_PARTY_APPROVED, you might automatically transition to PENDING_SECOND_PARTY
    // and send notifications.
    // if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
    //   // TODO: Transition to PENDING_SECOND_PARTY and notify
    // } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
    //   // TODO: Transition to CONTACT_DETAILS_SHARED and notify
    // }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    if (error instanceof z.ZodError) { // Handle Zod validation errors if you add more validation
        return NextResponse.json(
            { error: "Validation error for status update", details: error.errors },
            { status: 400 }
        );
    }
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY, MatchSuggestionStatus.CANCELLED],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL, // Often matchmaker confirms before sharing
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED, // Or directly share
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [ // Matchmaker action after both parties approve
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.MATCH_DECLINED, // Matchmaker can decide not to proceed
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.MEETING_PENDING, // Or AWAITING_FIRST_DATE_FEEDBACK
        MatchSuggestionStatus.DATING, // If they skip formal feedback and start dating
        MatchSuggestionStatus.CLOSED, // If one party decides not to proceed after contact
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE, // If feedback leads to this
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [ // This might be too granular, DATNG might cover it
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK, // For feedback after 2nd date etc.
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // If it ends after 2nd date
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [ // This status might be redundant if AWAITING_FIRST_DATE_FEEDBACK is used
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [ // Similar to MEETING_PENDING
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [ // This is often equivalent to CONTACT_DETAILS_SHARED or DATNG
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENGAGED, // Could jump here
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED, // If dating ends
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CLOSED, // If engagement breaks
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [MatchSuggestionStatus.CLOSED], // Or just stay MARRIE
    EXPIRED: [MatchSuggestionStatus.CLOSED],
    CLOSED: [], // No transitions from CLOSED typically, except maybe reopening
    CANCELLED: [MatchSuggestionStatus.CLOSED] // Or just stay CANCELLED
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions
# Generated on: 2025-07-10 05:46:50
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.string().refine((val) => !isNaN(Date.parse(val)), { // Validate as date string
    message: "Invalid date format for decisionDeadline",
  }).transform((val) => new Date(val)), // Transform to Date object
});

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) { // Check for user.id and user.role
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for POST ----
    // 2. Role verification (only matchmakers or admins can create suggestions)
    const allowedCreatorRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedCreatorRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to create suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE for POST ----

    // 3. Parse and validate request body
    const body = await req.json();
    const validationResult = createSuggestionSchema.safeParse(body);

    if (!validationResult.success) {
        return NextResponse.json(
            { error: "Validation error", details: validationResult.error.errors },
            { status: 400 }
        );
    }
    const validatedData = validationResult.data;


    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
                MatchSuggestionStatus.FIRST_PARTY_DECLINED, // Added
                MatchSuggestionStatus.SECOND_PARTY_DECLINED, // Added
                MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // Added
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: `Active or pending suggestion (ID: ${existingSuggestion.id}, Status: ${existingSuggestion.status}) already exists between these parties` },
        { status: 409 } // Conflict
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id, // The user creating is the matchmaker
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline,
          firstPartySent: new Date(),
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Initialize lastActivity
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion); // Consider passing the full suggestion object

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion, // Return the created suggestion object
    }, { status: 201 }); // HTTP 201 Created
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    // Handle Prisma unique constraint errors specifically if needed
    // if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {}
    
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for PATCH (General permission) ----
    const allowedUpdaterRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN, UserRole.CANDIDATE]; // CANDIDATE can update if they are a party
    if (!allowedUpdaterRoles.includes(session.user.role as UserRole)) {
        return NextResponse.json({ error: "Forbidden - Insufficient permissions to update suggestion status" }, { status: 403 });
    }
    // ---- END OF CHANGE for PATCH ----

    const body = await req.json();
    const { suggestionId, status, notes } = body; // Assuming status and notes are part of body

    // Validate incoming data (basic example)
    if (!suggestionId || !status) {
        return NextResponse.json({ error: "Missing suggestionId or status" }, { status: 400 });
    }
    if (!Object.values(MatchSuggestionStatus).includes(status as MatchSuggestionStatus)) {
        return NextResponse.json({ error: "Invalid status value" }, { status: 400 });
    }


    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true, // Include matchmaker for permission checks
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // ---- Specific permission check for PATCH ----
    // An ADMIN can update any suggestion.
    // A MATCHMAKER can update suggestions they created.
    // A CANDIDATE can update suggestions they are a party to (firstPartyId or secondPartyId).
    const isUserAdmin = session.user.role === UserRole.ADMIN;
    const isUserMatchmakerOwner = session.user.role === UserRole.MATCHMAKER && suggestion.matchmakerId === session.user.id;
    const isUserParty = session.user.role === UserRole.CANDIDATE && (suggestion.firstPartyId === session.user.id || suggestion.secondPartyId === session.user.id);

    if (!isUserAdmin && !isUserMatchmakerOwner && !isUserParty) {
        return NextResponse.json({ error: "Forbidden - You do not have permission to update this specific suggestion's status." }, { status: 403 });
    }
    // ---- End specific permission check ----


    // 3. Validate status transition (using your existing helper)
    const isValidTransition = validateStatusTransition(suggestion.status, status as MatchSuggestionStatus);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: `Invalid status transition from ${suggestion.status} to ${status}` },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status as MatchSuggestionStatus,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Update lastActivity
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            // closedAt: new Date(), // Typically, CONTACT_DETAILS_SHARED doesn't mean closed
          }),
          ...(status === MatchSuggestionStatus.CLOSED && { // Explicitly set closedAt for CLOSED status
            closedAt: new Date(),
          }),
        },
      });

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status: status as MatchSuggestionStatus,
          notes: notes || `Status changed to ${status} by user ${session.user.id}`, // Add more context to notes
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    // This logic might be better suited in a service layer or triggered by events
    // For example, if status is FIRST_PARTY_APPROVED, you might automatically transition to PENDING_SECOND_PARTY
    // and send notifications.
    // if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
    //   // TODO: Transition to PENDING_SECOND_PARTY and notify
    // } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
    //   // TODO: Transition to CONTACT_DETAILS_SHARED and notify
    // }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    if (error instanceof z.ZodError) { // Handle Zod validation errors if you add more validation
        return NextResponse.json(
            { error: "Validation error for status update", details: error.errors },
            { status: 400 }
        );
    }
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY, MatchSuggestionStatus.CANCELLED],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL, // Often matchmaker confirms before sharing
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED, // Or directly share
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [ // Matchmaker action after both parties approve
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.MATCH_DECLINED, // Matchmaker can decide not to proceed
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.MEETING_PENDING, // Or AWAITING_FIRST_DATE_FEEDBACK
        MatchSuggestionStatus.DATING, // If they skip formal feedback and start dating
        MatchSuggestionStatus.CLOSED, // If one party decides not to proceed after contact
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE, // If feedback leads to this
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [ // This might be too granular, DATNG might cover it
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK, // For feedback after 2nd date etc.
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // If it ends after 2nd date
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [ // This status might be redundant if AWAITING_FIRST_DATE_FEEDBACK is used
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [ // Similar to MEETING_PENDING
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [ // This is often equivalent to CONTACT_DETAILS_SHARED or DATNG
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENGAGED, // Could jump here
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED, // If dating ends
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CLOSED, // If engagement breaks
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [MatchSuggestionStatus.CLOSED], // Or just stay MARRIE
    EXPIRED: [MatchSuggestionStatus.CLOSED],
    CLOSED: [], // No transitions from CLOSED typically, except maybe reopening
    CANCELLED: [MatchSuggestionStatus.CLOSED] // Or just stay CANCELLED
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

// Helper function to include all necessary fields for a party
const partySelect = {
  id: true,
  email: true,
  firstName: true,
  lastName: true,
  profile: true,
  images: {
    select: {
      id: true,
      url: true,
      isMain: true,
    },
    orderBy: { isMain: "desc" as const },
  },
};

export async function GET(req: Request, { params }: { params: { id: string } }) {
  const suggestionId = params.id;
  // --- לוג 1: התחלת טיפול בבקשה ---
  console.log(`[API GET /suggestions/${suggestionId}] Request received.`);

  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      // --- לוג 2: שגיאת אימות ---
      console.warn(`[API GET /suggestions/${suggestionId}] Unauthorized access attempt: No session or user ID.`);
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // --- לוג 3: פרטי משתמש מאומת ---
    console.log(`[API GET /suggestions/${suggestionId}] User authenticated: ID=${session.user.id}, Role=${session.user.role}`);

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        firstParty: { select: partySelect },
        secondParty: { select: partySelect },
        statusHistory: {
          orderBy: { createdAt: "desc" as const },
        },
      },
    });

    if (!suggestion) {
      // --- לוג 4: הצעה לא נמצאה ---
      console.warn(`[API GET /suggestions/${suggestionId}] Suggestion not found in database.`);
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // --- לוג 5: הצעה נמצאה בהצלחה ---
    console.log(`[API GET /suggestions/${suggestionId}] Found suggestion. Status: ${suggestion.status}, Matchmaker: ${suggestion.matchmakerId}`);

    // Authorization check: User must be one of the parties or the matchmaker or an admin
    const isAuthorized =
      session.user.id === suggestion.firstPartyId ||
      session.user.id === suggestion.secondPartyId ||
      session.user.id === suggestion.matchmakerId ||
      session.user.role === UserRole.ADMIN;

    if (!isAuthorized) {
      // --- לוג 6: שגיאת הרשאה ---
      console.warn(`[API GET /suggestions/${suggestionId}] Forbidden access. User ${session.user.id} is not a party, the matchmaker, or an admin.`);
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // --- לוג 7: הרשאה תקינה ---
    console.log(`[API GET /suggestions/${suggestionId}] User ${session.user.id} is authorized to view.`);

    // Fetch the questionnaire for the "other" party
    const targetPartyId =
      suggestion.firstPartyId === session.user.id
        ? suggestion.secondPartyId
        : suggestion.firstPartyId;

    // --- לוג 8: שליפת שאלון עבור הצד השני ---
    console.log(`[API GET /suggestions/${suggestionId}] Fetching questionnaire for targetPartyId: ${targetPartyId}.`);

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: { userId: targetPartyId },
      orderBy: { createdAt: 'desc' }
    });

    // --- לוג 9: תוצאת שליפת השאלון ---
    if (questionnaireResponse) {
        console.log(`[API GET /suggestions/${suggestionId}] Found questionnaire for targetPartyId: ${targetPartyId}. Questionnaire ID: ${questionnaireResponse.id}`);
    } else {
        console.warn(`[API GET /suggestions/${suggestionId}] No questionnaire found for targetPartyId: ${targetPartyId}.`);
    }

    // Combine all data into a single response object
    const fullSuggestionData = {
      ...suggestion,
      secondPartyQuestionnaire: questionnaireResponse || null, // Naming this consistently
    };

    // --- לוג 10: סיכום המידע לפני שליחה ---
    console.log(`[API GET /suggestions/${suggestionId}] Preparing to send final data. Suggestion ID: ${fullSuggestionData.id}, Status: ${fullSuggestionData.status}, Questionnaire present: ${!!fullSuggestionData.secondPartyQuestionnaire}`);
    // אם תרצה לראות את כל האובייקט, תוכל להסיר את ההערה מהשורה הבאה, אך שים לב שהפלט יהיה ארוך מאוד
    // console.log(`[API GET /suggestions/${suggestionId}] Full data object:`, JSON.stringify(fullSuggestionData, null, 2));


    return NextResponse.json({
      success: true,
      suggestion: fullSuggestionData,
    });
  } catch (error) {
    // --- לוג 11: טיפול בשגיאות כלליות ---
    console.error(`[API GET /suggestions/${suggestionId}] Critical error fetching suggestion:`, error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest, // req is not used, can be removed if not needed
  context: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const suggestionId = context.params.id;

    // בדיקה שההצעה קיימת
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // ---- START OF CHANGE ----
    // הרשאות:
    // 1. אדמין יכול למחוק כל הצעה.
    // 2. שדכן יכול למחוק רק הצעה שהוא יצר.
    const userRole = session.user.role as UserRole;
    const isOwner = suggestion.matchmakerId === session.user.id;

    if (userRole === UserRole.ADMIN) {
      // Admin can delete any suggestion
    } else if (userRole === UserRole.MATCHMAKER && isOwner) {
      // Matchmaker can delete their own suggestion
    } else {
      // Any other case is forbidden
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to delete this suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE ----

    // מחיקת ההצעה וכל הנתונים הקשורים אליה (ודא ש-onDelete: Cascade מוגדר בסכמה אם רלוונטי)
    // אם אין Cascade, יש למחוק רשומות קשורות ידנית קודם.
    // הסדר הנוכחי שלך נראה טוב אם אין Cascade על הכל.
    await prisma.$transaction(async (tx) => { // Changed to async for await inside
      // מחיקת היסטוריית סטטוסים
      await tx.suggestionStatusHistory.deleteMany({
        where: { suggestionId },
      });
      // מחיקת שאלות
      await tx.suggestionInquiry.deleteMany({
        where: { suggestionId },
      });
      // מחיקת פגישות (אם קיימות וקשורות ישירות)
      await tx.meeting.deleteMany({
        where: { suggestionId },
      });
      // Consider other related data like DateFeedback
      await tx.dateFeedback.deleteMany({
        where: { suggestionId },
      });

      // הסרת קשרים בטבלאות קשר רבים-לרבים (אם יש)
      // לדוגמה, אם יש קשר approvedBy, reviewedBy ב-MatchSuggestion
      await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          approvedBy: { set: [] }, // Assuming relation exists
          reviewedBy: { set: [] }, // Assuming relation exists
        }
      });
      
      // מחיקת ההצעה עצמה
      await tx.matchSuggestion.delete({
        where: { id: suggestionId },
      });
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully",
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    // Consider more specific error handling (e.g., Prisma errors)
    return NextResponse.json(
      { error: "Internal server error during suggestion deletion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\inquiries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/inquiries/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { InquiryStatus, UserRole } from "@prisma/client";
import type { Session } from "next-auth"; // --- START OF FIX: Import the Session type ---

// --- START OF FIX: Define a specific type for the session parameter ---
type AuthSession = Session | null;
// --- END OF FIX ---

// Helper function for authorization check
// --- START OF FIX: Use the specific type for the session parameter ---
async function checkPermissions(suggestionId: string, session: AuthSession) {
// --- END OF FIX ---
  if (!session?.user?.id) {
    throw new Error("Unauthorized");
  }

  const suggestion = await prisma.matchSuggestion.findUnique({
    where: { id: suggestionId },
    select: { firstPartyId: true, secondPartyId: true, matchmakerId: true },
  });

  if (!suggestion) {
    throw new Error("Suggestion not found");
  }

  const isAuthorized =
    session.user.id === suggestion.firstPartyId ||
    session.user.id === suggestion.secondPartyId ||
    session.user.id === suggestion.matchmakerId ||
    session.user.role === UserRole.ADMIN;

  if (!isAuthorized) {
    throw new Error("Forbidden");
  }

  return { suggestion, userId: session.user.id, userRole: session.user.role as UserRole };
}

/**
 * GET: Fetch all inquiries for a specific suggestion.
 * Users can only see inquiries for suggestions they are a part of.
 */
export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    await checkPermissions(params.id, session);

    const inquiries = await prisma.suggestionInquiry.findMany({
      where: { suggestionId: params.id },
      include: {
        fromUser: { select: { id: true, firstName: true, lastName: true } },
        toUser: { select: { id: true, firstName: true, lastName: true } },
      },
      orderBy: { createdAt: "asc" },
    });

    return NextResponse.json({ success: true, inquiries });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error fetching inquiries:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * POST: Create a new inquiry (question) for a suggestion.
 * A user (candidate) sends a question to the matchmaker.
 */
export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const { suggestion, userId } = await checkPermissions(params.id, session);

    const { question } = await req.json();
    if (!question || typeof question !== 'string' || question.trim().length === 0) {
      return NextResponse.json({ error: "Question content is required" }, { status: 400 });
    }

    const inquiry = await prisma.suggestionInquiry.create({
      data: {
        suggestionId: params.id,
        fromUserId: userId,
        toUserId: suggestion.matchmakerId, // Questions always go to the matchmaker
        question,
        status: InquiryStatus.PENDING,
      },
    });
    
    // TODO: Add notification to matchmaker about the new question

    return NextResponse.json({ success: true, inquiry });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error creating inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * PATCH: Answer an inquiry.
 * Only the matchmaker (or an admin) can answer an inquiry.
 */
export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const { userRole, userId } = await checkPermissions(params.id, session); // params.id is suggestionId

    if (userRole !== UserRole.MATCHMAKER && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: Only matchmakers or admins can answer inquiries." }, { status: 403 });
    }

    const { inquiryId, answer } = await req.json();
    if (!inquiryId || !answer || typeof answer !== 'string' || answer.trim().length === 0) {
      return NextResponse.json({ error: "Inquiry ID and answer content are required" }, { status: 400 });
    }

    const inquiryToUpdate = await prisma.suggestionInquiry.findUnique({
        where: { id: inquiryId },
    });

    if (!inquiryToUpdate) {
        return NextResponse.json({ error: "Inquiry not found." }, { status: 404 });
    }

    // Security check: Make sure the matchmaker answering is the one the question was sent to.
    if (inquiryToUpdate.toUserId !== userId && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: You are not the recipient of this inquiry." }, { status: 403 });
    }

    const updatedInquiry = await prisma.suggestionInquiry.update({
      where: { id: inquiryId },
      data: {
        answer,
        status: InquiryStatus.ANSWERED,
        answeredAt: new Date(),
      },
    });
    
    // TODO: Add notification to the user who asked the question

    return NextResponse.json({ success: true, inquiry: updatedInquiry });
  } catch (error) {
     if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error answering inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// Full path: src/app/api/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { MatchSuggestionStatus, MatchSuggestion, UserRole } from "@prisma/client";
import { statusTransitionService } from "@/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";

// Validation schema for status update
const statusUpdateSchema = z.object({
  status: z.enum([
    "DRAFT",
    "PENDING_FIRST_PARTY",
    "FIRST_PARTY_APPROVED",
    "FIRST_PARTY_DECLINED",
    "PENDING_SECOND_PARTY",
    "SECOND_PARTY_APPROVED",
    "SECOND_PARTY_DECLINED",
    "AWAITING_MATCHMAKER_APPROVAL",
    "CONTACT_DETAILS_SHARED",
    "AWAITING_FIRST_DATE_FEEDBACK",
    "THINKING_AFTER_DATE",
    "PROCEEDING_TO_SECOND_DATE",
    "ENDED_AFTER_FIRST_DATE",
    "MEETING_PENDING",
    "MEETING_SCHEDULED",
    "MATCH_APPROVED",
    "MATCH_DECLINED",
    "DATING",
    "ENGAGED",
    "MARRIED",
    "EXPIRED",
    "CLOSED",
    "CANCELLED"
  ] as const),
  notes: z.string().optional(),
  feedback: z.string().optional(),
  meetingDate: z.string().optional(),
  customMessage: z.string().optional(),
});

export async function PATCH(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    // Extract parameters
    const params = await context.params;
    const suggestionId = params.id;

    // Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Parse and validate request body
    const body = await req.json();
    
    try {
      const validatedData = statusUpdateSchema.parse(body);
      
      // Fetch current suggestion with related parties
      const suggestion = await prisma.matchSuggestion.findUnique({
        where: { id: suggestionId },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      if (!suggestion) {
        return NextResponse.json(
          { error: "Suggestion not found" },
          { status: 404 }
        );
      }

      // --- START OF CHANGE ---
      // Check if a candidate is trying to approve a suggestion while another one is already active.
      const isCandidateApproval =
        session.user.role === UserRole.CANDIDATE &&
        (validatedData.status === MatchSuggestionStatus.FIRST_PARTY_APPROVED ||
         validatedData.status === MatchSuggestionStatus.SECOND_PARTY_APPROVED);

      if (isCandidateApproval) {
        const activeProcessStatuses: MatchSuggestionStatus[] = [
          "FIRST_PARTY_APPROVED",
          "SECOND_PARTY_APPROVED",
          "AWAITING_MATCHMAKER_APPROVAL",
          "CONTACT_DETAILS_SHARED",
          "AWAITING_FIRST_DATE_FEEDBACK",
          "THINKING_AFTER_DATE",
          "PROCEEDING_TO_SECOND_DATE",
          "MEETING_PENDING",
          "MEETING_SCHEDULED",
          "MATCH_APPROVED",
          "DATING",
          "ENGAGED",
        ];

        const existingActiveSuggestion = await prisma.matchSuggestion.findFirst({
          where: {
            id: { not: suggestionId }, // Exclude the current suggestion being updated
            OR: [
              { firstPartyId: session.user.id },
              { secondPartyId: session.user.id },
            ],
            status: { in: activeProcessStatuses },
          },
        });

        if (existingActiveSuggestion) {
          return NextResponse.json(
            { error: "לא ניתן לאשר הצעה חדשה כאשר ישנה הצעה אחרת בתהליך פעיל." },
            { status: 409 } // 409 Conflict
          );
        }
      }
      // --- END OF CHANGE ---

      // Validate user permissions
      if (
        suggestion.firstPartyId !== session.user.id &&
        suggestion.secondPartyId !== session.user.id &&
        suggestion.matchmakerId !== session.user.id
      ) {
        return NextResponse.json(
          { error: "Unauthorized to update this suggestion" },
          { status: 403 }
        );
      }

      // Define transition options based on the type of update
      const transitionOptions = {
        sendNotifications: true,
        customMessage: validatedData.customMessage,
        notifyParties: ['first', 'second', 'matchmaker'] as ('first' | 'second' | 'matchmaker')[]
      };

      // Handle special cases for different status updates
      if (validatedData.status === "CONTACT_DETAILS_SHARED" && 
          validatedData.feedback && 
          validatedData.notes) {
        await createMeetingIfNecessary(suggestionId, validatedData);
      }

      // Process automatic secondary actions for certain status changes
      const secondaryAction = determineSecondaryAction(suggestion.status, validatedData.status);

      // Update suggestion status
      let updatedSuggestion = await statusTransitionService.transitionStatus(
        suggestion,
        validatedData.status as MatchSuggestionStatus,
        validatedData.notes,
        transitionOptions
      );

      // Process any secondary action if needed
      if (secondaryAction) {
        try {
          updatedSuggestion = await statusTransitionService.transitionStatus(
            updatedSuggestion,
            secondaryAction,
            `Automatic transition after ${validatedData.status}`,
            { 
              ...transitionOptions,
              customMessage: `התבצע מעבר אוטומטי לסטטוס ${statusTransitionService.getStatusLabel(secondaryAction)}`
            }
          );
        } catch (secondaryActionError) {
          console.warn("Warning: Secondary status transition failed:", secondaryActionError);
          // Continue with the response even if secondary action fails
        }
      }

      // Update party profiles if needed (e.g., changing availability status)
      await updateProfilesIfNeeded(validatedData.status as MatchSuggestionStatus, suggestion);

      return NextResponse.json({
        success: true,
        suggestion: updatedSuggestion,
      });

    } catch (validationError) {
      if (validationError instanceof z.ZodError) {
        return NextResponse.json({
          error: "Validation error",
          details: validationError.errors
        }, { status: 400 });
      }
      throw validationError;
    }

  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json(
      { 
        error: "Internal server error",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

// Helper function to determine if a secondary action should be taken
function determineSecondaryAction(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): MatchSuggestionStatus | null {
  // Automatic transitions

const automaticTransitions: Partial<Record<MatchSuggestionStatus, MatchSuggestionStatus>> = {    FIRST_PARTY_APPROVED: MatchSuggestionStatus.PENDING_SECOND_PARTY,
    SECOND_PARTY_APPROVED: MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
    FIRST_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
    SECOND_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
  };

  return automaticTransitions[newStatus] || null;
}

// Helper function to create a meeting record if needed
async function createMeetingIfNecessary(
  suggestionId: string,
  data: z.infer<typeof statusUpdateSchema>
) {
  if (data.meetingDate) {
    // Create a meeting record
    await prisma.meeting.create({
      data: {
        suggestionId,
        scheduledDate: new Date(data.meetingDate),
        status: "SCHEDULED",
        notes: data.notes || "Automatically created when contact details were shared",
      }
    });
  }
}

// Helper function to update profiles if needed
async function updateProfilesIfNeeded(
  newStatus: MatchSuggestionStatus,
  suggestion: MatchSuggestion,
) {
  // Special handling for ENGAGED and MARRIED statuses
  if (newStatus === "ENGAGED" || newStatus === "MARRIED") {
    const availabilityStatus = newStatus === "ENGAGED" ? "ENGAGED" : "MARRIED";
    
    // Update both profiles with the new status
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: {
          availabilityStatus,
          availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`,
          availabilityUpdatedAt: new Date()
        }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: {
          availabilityStatus,
          availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`,
          availabilityUpdatedAt: new Date()
        }
      })
    ]);
  }
  
  // For DATING status, mark both profiles as unavailable
  if (newStatus === "DATING") {
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: {
          availabilityStatus: "DATING",
          availabilityNote: "Currently in a dating process",
          availabilityUpdatedAt: new Date()
        }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: {
          availabilityStatus: "DATING",
          availabilityNote: "Currently in a dating process",
          availabilityUpdatedAt: new Date()
        }
      })
    ]);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth"; // Assuming next-auth/next might be more common for app router, but this works.
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "PENDING_FIRST_PARTY",
                "FIRST_PARTY_APPROVED",
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,
                
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
      
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,

                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
             
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({
      success: true,
      suggestions: activeSuggestions,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    // It's good practice to type the error if possible, e.g., if (error instanceof Error)
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json(
      { error: errorMessage }, // More specific error message if available
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth"; // Using 'next-auth' is fine
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserProfile } from "@/types/next-auth"; // Import for potential explicit typing if needed

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "FIRST_PARTY_DECLINED",
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,
                
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
         
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,

                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,

                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        updatedAt: "desc", // Changed from createdAt in previous example, make sure this is intended for history
      },
    });

    // Typing the suggestion before mapping for better intellisense and safety
    // This assumes the structure returned by Prisma matches what's expected by UserProfile
    // and related types.
    const formattedSuggestions = historySuggestions.map(suggestion => {
      // Ensure profile exists before trying to spread it, or handle potential null case
      // Prisma's `include` with `select` guarantees `profile` exists if the relation does,
      // but if `firstParty` or `secondParty` could be null (e.g., if the user was deleted),
      // you'd need to handle that. Here, they are expected to be non-null.
      
      const firstPartyProfile = suggestion.firstParty.profile as UserProfile | null;
      const secondPartyProfile = suggestion.secondParty.profile as UserProfile | null;

      return {
        ...suggestion,
        firstParty: {
            ...suggestion.firstParty,
            profile: firstPartyProfile ? { // Add user sub-object to firstParty.profile if it's part of UserProfile type
                ...firstPartyProfile,
                user: {
                    id: suggestion.firstParty.id,
                    firstName: suggestion.firstParty.firstName,
                    lastName: suggestion.firstParty.lastName,
                    email: suggestion.firstParty.email,
                }
            } : null,
        },
        secondParty: {
          ...suggestion.secondParty,
          profile: secondPartyProfile ? {
            ...secondPartyProfile,
            user: { // This structure matches the UserProfile.user field
              id: suggestion.secondParty.id,
              firstName: suggestion.secondParty.firstName,
              lastName: suggestion.secondParty.lastName,
              email: suggestion.secondParty.email,
            }
          } : null,
        }
      };
    });

    return NextResponse.json({
      success: true,
      suggestions: formattedSuggestions,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for suggestions_contents.txt ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

// Helper function to include all necessary fields for a party
const partySelect = {
  id: true,
  email: true,
  firstName: true,
  lastName: true,
  profile: true,
  images: {
    select: {
      id: true,
      url: true,
      isMain: true,
    },
    orderBy: { isMain: "desc" as const },
  },
};

export async function GET(req: Request, { params }: { params: { id: string } }) {
  const suggestionId = params.id;
  // --- לוג 1: התחלת טיפול בבקשה ---
  console.log(`[API GET /suggestions/${suggestionId}] Request received.`);

  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      // --- לוג 2: שגיאת אימות ---
      console.warn(`[API GET /suggestions/${suggestionId}] Unauthorized access attempt: No session or user ID.`);
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // --- לוג 3: פרטי משתמש מאומת ---
    console.log(`[API GET /suggestions/${suggestionId}] User authenticated: ID=${session.user.id}, Role=${session.user.role}`);

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        firstParty: { select: partySelect },
        secondParty: { select: partySelect },
        statusHistory: {
          orderBy: { createdAt: "desc" as const },
        },
      },
    });

    if (!suggestion) {
      // --- לוג 4: הצעה לא נמצאה ---
      console.warn(`[API GET /suggestions/${suggestionId}] Suggestion not found in database.`);
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // --- לוג 5: הצעה נמצאה בהצלחה ---
    console.log(`[API GET /suggestions/${suggestionId}] Found suggestion. Status: ${suggestion.status}, Matchmaker: ${suggestion.matchmakerId}`);

    // Authorization check: User must be one of the parties or the matchmaker or an admin
    const isAuthorized =
      session.user.id === suggestion.firstPartyId ||
      session.user.id === suggestion.secondPartyId ||
      session.user.id === suggestion.matchmakerId ||
      session.user.role === UserRole.ADMIN;

    if (!isAuthorized) {
      // --- לוג 6: שגיאת הרשאה ---
      console.warn(`[API GET /suggestions/${suggestionId}] Forbidden access. User ${session.user.id} is not a party, the matchmaker, or an admin.`);
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // --- לוג 7: הרשאה תקינה ---
    console.log(`[API GET /suggestions/${suggestionId}] User ${session.user.id} is authorized to view.`);

    // Fetch the questionnaire for the "other" party
    const targetPartyId =
      suggestion.firstPartyId === session.user.id
        ? suggestion.secondPartyId
        : suggestion.firstPartyId;

    // --- לוג 8: שליפת שאלון עבור הצד השני ---
    console.log(`[API GET /suggestions/${suggestionId}] Fetching questionnaire for targetPartyId: ${targetPartyId}.`);

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: { userId: targetPartyId },
      orderBy: { createdAt: 'desc' }
    });

    // --- לוג 9: תוצאת שליפת השאלון ---
    if (questionnaireResponse) {
        console.log(`[API GET /suggestions/${suggestionId}] Found questionnaire for targetPartyId: ${targetPartyId}. Questionnaire ID: ${questionnaireResponse.id}`);
    } else {
        console.warn(`[API GET /suggestions/${suggestionId}] No questionnaire found for targetPartyId: ${targetPartyId}.`);
    }

    // Combine all data into a single response object
    const fullSuggestionData = {
      ...suggestion,
      secondPartyQuestionnaire: questionnaireResponse || null, // Naming this consistently
    };

    // --- לוג 10: סיכום המידע לפני שליחה ---
    console.log(`[API GET /suggestions/${suggestionId}] Preparing to send final data. Suggestion ID: ${fullSuggestionData.id}, Status: ${fullSuggestionData.status}, Questionnaire present: ${!!fullSuggestionData.secondPartyQuestionnaire}`);
    // אם תרצה לראות את כל האובייקט, תוכל להסיר את ההערה מהשורה הבאה, אך שים לב שהפלט יהיה ארוך מאוד
    // console.log(`[API GET /suggestions/${suggestionId}] Full data object:`, JSON.stringify(fullSuggestionData, null, 2));


    return NextResponse.json({
      success: true,
      suggestion: fullSuggestionData,
    });
  } catch (error) {
    // --- לוג 11: טיפול בשגיאות כלליות ---
    console.error(`[API GET /suggestions/${suggestionId}] Critical error fetching suggestion:`, error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest, // req is not used, can be removed if not needed
  context: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const suggestionId = context.params.id;

    // בדיקה שההצעה קיימת
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // ---- START OF CHANGE ----
    // הרשאות:
    // 1. אדמין יכול למחוק כל הצעה.
    // 2. שדכן יכול למחוק רק הצעה שהוא יצר.
    const userRole = session.user.role as UserRole;
    const isOwner = suggestion.matchmakerId === session.user.id;

    if (userRole === UserRole.ADMIN) {
      // Admin can delete any suggestion
    } else if (userRole === UserRole.MATCHMAKER && isOwner) {
      // Matchmaker can delete their own suggestion
    } else {
      // Any other case is forbidden
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to delete this suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE ----

    // מחיקת ההצעה וכל הנתונים הקשורים אליה (ודא ש-onDelete: Cascade מוגדר בסכמה אם רלוונטי)
    // אם אין Cascade, יש למחוק רשומות קשורות ידנית קודם.
    // הסדר הנוכחי שלך נראה טוב אם אין Cascade על הכל.
    await prisma.$transaction(async (tx) => { // Changed to async for await inside
      // מחיקת היסטוריית סטטוסים
      await tx.suggestionStatusHistory.deleteMany({
        where: { suggestionId },
      });
      // מחיקת שאלות
      await tx.suggestionInquiry.deleteMany({
        where: { suggestionId },
      });
      // מחיקת פגישות (אם קיימות וקשורות ישירות)
      await tx.meeting.deleteMany({
        where: { suggestionId },
      });
      // Consider other related data like DateFeedback
      await tx.dateFeedback.deleteMany({
        where: { suggestionId },
      });

      // הסרת קשרים בטבלאות קשר רבים-לרבים (אם יש)
      // לדוגמה, אם יש קשר approvedBy, reviewedBy ב-MatchSuggestion
      await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          approvedBy: { set: [] }, // Assuming relation exists
          reviewedBy: { set: [] }, // Assuming relation exists
        }
      });
      
      // מחיקת ההצעה עצמה
      await tx.matchSuggestion.delete({
        where: { id: suggestionId },
      });
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully",
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    // Consider more specific error handling (e.g., Prisma errors)
    return NextResponse.json(
      { error: "Internal server error during suggestion deletion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\inquiries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/inquiries/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { InquiryStatus, UserRole } from "@prisma/client";
import type { Session } from "next-auth"; // --- START OF FIX: Import the Session type ---

// --- START OF FIX: Define a specific type for the session parameter ---
type AuthSession = Session | null;
// --- END OF FIX ---

// Helper function for authorization check
// --- START OF FIX: Use the specific type for the session parameter ---
async function checkPermissions(suggestionId: string, session: AuthSession) {
// --- END OF FIX ---
  if (!session?.user?.id) {
    throw new Error("Unauthorized");
  }

  const suggestion = await prisma.matchSuggestion.findUnique({
    where: { id: suggestionId },
    select: { firstPartyId: true, secondPartyId: true, matchmakerId: true },
  });

  if (!suggestion) {
    throw new Error("Suggestion not found");
  }

  const isAuthorized =
    session.user.id === suggestion.firstPartyId ||
    session.user.id === suggestion.secondPartyId ||
    session.user.id === suggestion.matchmakerId ||
    session.user.role === UserRole.ADMIN;

  if (!isAuthorized) {
    throw new Error("Forbidden");
  }

  return { suggestion, userId: session.user.id, userRole: session.user.role as UserRole };
}

/**
 * GET: Fetch all inquiries for a specific suggestion.
 * Users can only see inquiries for suggestions they are a part of.
 */
export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    await checkPermissions(params.id, session);

    const inquiries = await prisma.suggestionInquiry.findMany({
      where: { suggestionId: params.id },
      include: {
        fromUser: { select: { id: true, firstName: true, lastName: true } },
        toUser: { select: { id: true, firstName: true, lastName: true } },
      },
      orderBy: { createdAt: "asc" },
    });

    return NextResponse.json({ success: true, inquiries });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error fetching inquiries:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * POST: Create a new inquiry (question) for a suggestion.
 * A user (candidate) sends a question to the matchmaker.
 */
export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const { suggestion, userId } = await checkPermissions(params.id, session);

    const { question } = await req.json();
    if (!question || typeof question !== 'string' || question.trim().length === 0) {
      return NextResponse.json({ error: "Question content is required" }, { status: 400 });
    }

    const inquiry = await prisma.suggestionInquiry.create({
      data: {
        suggestionId: params.id,
        fromUserId: userId,
        toUserId: suggestion.matchmakerId, // Questions always go to the matchmaker
        question,
        status: InquiryStatus.PENDING,
      },
    });
    
    // TODO: Add notification to matchmaker about the new question

    return NextResponse.json({ success: true, inquiry });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error creating inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * PATCH: Answer an inquiry.
 * Only the matchmaker (or an admin) can answer an inquiry.
 */
export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const { userRole, userId } = await checkPermissions(params.id, session); // params.id is suggestionId

    if (userRole !== UserRole.MATCHMAKER && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: Only matchmakers or admins can answer inquiries." }, { status: 403 });
    }

    const { inquiryId, answer } = await req.json();
    if (!inquiryId || !answer || typeof answer !== 'string' || answer.trim().length === 0) {
      return NextResponse.json({ error: "Inquiry ID and answer content are required" }, { status: 400 });
    }

    const inquiryToUpdate = await prisma.suggestionInquiry.findUnique({
        where: { id: inquiryId },
    });

    if (!inquiryToUpdate) {
        return NextResponse.json({ error: "Inquiry not found." }, { status: 404 });
    }

    // Security check: Make sure the matchmaker answering is the one the question was sent to.
    if (inquiryToUpdate.toUserId !== userId && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: You are not the recipient of this inquiry." }, { status: 403 });
    }

    const updatedInquiry = await prisma.suggestionInquiry.update({
      where: { id: inquiryId },
      data: {
        answer,
        status: InquiryStatus.ANSWERED,
        answeredAt: new Date(),
      },
    });
    
    // TODO: Add notification to the user who asked the question

    return NextResponse.json({ success: true, inquiry: updatedInquiry });
  } catch (error) {
     if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error answering inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// Full path: src/app/api/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { MatchSuggestionStatus, MatchSuggestion, UserRole } from "@prisma/client";
import { statusTransitionService } from "@/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";

// Validation schema for status update
const statusUpdateSchema = z.object({
  status: z.enum([
    "DRAFT",
    "PENDING_FIRST_PARTY",
    "FIRST_PARTY_APPROVED",
    "FIRST_PARTY_DECLINED",
    "PENDING_SECOND_PARTY",
    "SECOND_PARTY_APPROVED",
    "SECOND_PARTY_DECLINED",
    "AWAITING_MATCHMAKER_APPROVAL",
    "CONTACT_DETAILS_SHARED",
    "AWAITING_FIRST_DATE_FEEDBACK",
    "THINKING_AFTER_DATE",
    "PROCEEDING_TO_SECOND_DATE",
    "ENDED_AFTER_FIRST_DATE",
    "MEETING_PENDING",
    "MEETING_SCHEDULED",
    "MATCH_APPROVED",
    "MATCH_DECLINED",
    "DATING",
    "ENGAGED",
    "MARRIED",
    "EXPIRED",
    "CLOSED",
    "CANCELLED"
  ] as const),
  notes: z.string().optional(),
  feedback: z.string().optional(),
  meetingDate: z.string().optional(),
  customMessage: z.string().optional(),
});

export async function PATCH(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    // Extract parameters
    const params = await context.params;
    const suggestionId = params.id;

    // Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Parse and validate request body
    const body = await req.json();
    
    try {
      const validatedData = statusUpdateSchema.parse(body);
      
      // Fetch current suggestion with related parties
      const suggestion = await prisma.matchSuggestion.findUnique({
        where: { id: suggestionId },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      if (!suggestion) {
        return NextResponse.json(
          { error: "Suggestion not found" },
          { status: 404 }
        );
      }

      // --- START OF CHANGE ---
      // Check if a candidate is trying to approve a suggestion while another one is already active.
      const isCandidateApproval =
        session.user.role === UserRole.CANDIDATE &&
        (validatedData.status === MatchSuggestionStatus.FIRST_PARTY_APPROVED ||
         validatedData.status === MatchSuggestionStatus.SECOND_PARTY_APPROVED);

      if (isCandidateApproval) {
        const activeProcessStatuses: MatchSuggestionStatus[] = [
          "FIRST_PARTY_APPROVED",
          "SECOND_PARTY_APPROVED",
          "AWAITING_MATCHMAKER_APPROVAL",
          "CONTACT_DETAILS_SHARED",
          "AWAITING_FIRST_DATE_FEEDBACK",
          "THINKING_AFTER_DATE",
          "PROCEEDING_TO_SECOND_DATE",
          "MEETING_PENDING",
          "MEETING_SCHEDULED",
          "MATCH_APPROVED",
          "DATING",
          "ENGAGED",
        ];

        const existingActiveSuggestion = await prisma.matchSuggestion.findFirst({
          where: {
            id: { not: suggestionId }, // Exclude the current suggestion being updated
            OR: [
              { firstPartyId: session.user.id },
              { secondPartyId: session.user.id },
            ],
            status: { in: activeProcessStatuses },
          },
        });

        if (existingActiveSuggestion) {
          return NextResponse.json(
            { error: "לא ניתן לאשר הצעה חדשה כאשר ישנה הצעה אחרת בתהליך פעיל." },
            { status: 409 } // 409 Conflict
          );
        }
      }
      // --- END OF CHANGE ---

      // Validate user permissions
      if (
        suggestion.firstPartyId !== session.user.id &&
        suggestion.secondPartyId !== session.user.id &&
        suggestion.matchmakerId !== session.user.id
      ) {
        return NextResponse.json(
          { error: "Unauthorized to update this suggestion" },
          { status: 403 }
        );
      }

      // Define transition options based on the type of update
      const transitionOptions = {
        sendNotifications: true,
        customMessage: validatedData.customMessage,
        notifyParties: ['first', 'second', 'matchmaker'] as ('first' | 'second' | 'matchmaker')[]
      };

      // Handle special cases for different status updates
      if (validatedData.status === "CONTACT_DETAILS_SHARED" && 
          validatedData.feedback && 
          validatedData.notes) {
        await createMeetingIfNecessary(suggestionId, validatedData);
      }

      // Process automatic secondary actions for certain status changes
      const secondaryAction = determineSecondaryAction(suggestion.status, validatedData.status);

      // Update suggestion status
      let updatedSuggestion = await statusTransitionService.transitionStatus(
        suggestion,
        validatedData.status as MatchSuggestionStatus,
        validatedData.notes,
        transitionOptions
      );

      // Process any secondary action if needed
      if (secondaryAction) {
        try {
          updatedSuggestion = await statusTransitionService.transitionStatus(
            updatedSuggestion,
            secondaryAction,
            `Automatic transition after ${validatedData.status}`,
            { 
              ...transitionOptions,
              customMessage: `התבצע מעבר אוטומטי לסטטוס ${statusTransitionService.getStatusLabel(secondaryAction)}`
            }
          );
        } catch (secondaryActionError) {
          console.warn("Warning: Secondary status transition failed:", secondaryActionError);
          // Continue with the response even if secondary action fails
        }
      }

      // Update party profiles if needed (e.g., changing availability status)
      await updateProfilesIfNeeded(validatedData.status as MatchSuggestionStatus, suggestion);

      return NextResponse.json({
        success: true,
        suggestion: updatedSuggestion,
      });

    } catch (validationError) {
      if (validationError instanceof z.ZodError) {
        return NextResponse.json({
          error: "Validation error",
          details: validationError.errors
        }, { status: 400 });
      }
      throw validationError;
    }

  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json(
      { 
        error: "Internal server error",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

// Helper function to determine if a secondary action should be taken
function determineSecondaryAction(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): MatchSuggestionStatus | null {
  // Automatic transitions

const automaticTransitions: Partial<Record<MatchSuggestionStatus, MatchSuggestionStatus>> = {    FIRST_PARTY_APPROVED: MatchSuggestionStatus.PENDING_SECOND_PARTY,
    SECOND_PARTY_APPROVED: MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
    FIRST_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
    SECOND_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
  };

  return automaticTransitions[newStatus] || null;
}

// Helper function to create a meeting record if needed
async function createMeetingIfNecessary(
  suggestionId: string,
  data: z.infer<typeof statusUpdateSchema>
) {
  if (data.meetingDate) {
    // Create a meeting record
    await prisma.meeting.create({
      data: {
        suggestionId,
        scheduledDate: new Date(data.meetingDate),
        status: "SCHEDULED",
        notes: data.notes || "Automatically created when contact details were shared",
      }
    });
  }
}

// Helper function to update profiles if needed
async function updateProfilesIfNeeded(
  newStatus: MatchSuggestionStatus,
  suggestion: MatchSuggestion,
) {
  // Special handling for ENGAGED and MARRIED statuses
  if (newStatus === "ENGAGED" || newStatus === "MARRIED") {
    const availabilityStatus = newStatus === "ENGAGED" ? "ENGAGED" : "MARRIED";
    
    // Update both profiles with the new status
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: {
          availabilityStatus,
          availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`,
          availabilityUpdatedAt: new Date()
        }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: {
          availabilityStatus,
          availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`,
          availabilityUpdatedAt: new Date()
        }
      })
    ]);
  }
  
  // For DATING status, mark both profiles as unavailable
  if (newStatus === "DATING") {
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: {
          availabilityStatus: "DATING",
          availabilityNote: "Currently in a dating process",
          availabilityUpdatedAt: new Date()
        }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: {
          availabilityStatus: "DATING",
          availabilityNote: "Currently in a dating process",
          availabilityUpdatedAt: new Date()
        }
      })
    ]);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth"; // Assuming next-auth/next might be more common for app router, but this works.
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "PENDING_FIRST_PARTY",
                "FIRST_PARTY_APPROVED",
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "PENDING_SECOND_PARTY",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED"
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,
                
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
      
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,

                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
             
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({
      success: true,
      suggestions: activeSuggestions,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    // It's good practice to type the error if possible, e.g., if (error instanceof Error)
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json(
      { error: errorMessage }, // More specific error message if available
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth"; // Using 'next-auth' is fine
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserProfile } from "@/types/next-auth"; // Import for potential explicit typing if needed

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          {
            firstPartyId: session.user.id,
            status: {
              in: [
                "FIRST_PARTY_DECLINED",
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
          {
            secondPartyId: session.user.id,
            status: {
              in: [
                "SECOND_PARTY_DECLINED",
                "MATCH_DECLINED",
                "CLOSED",
                "CANCELLED",
              ],
            },
          },
        ],
      },
      include: {
        statusHistory: {
          orderBy: {
            createdAt: 'desc'
          }
        },
        matchmaker: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,
                
                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,
         
                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            profile: {
              select: {
                gender: true,
                birthDate: true,
                nativeLanguage: true,
                additionalLanguages: true,
                height: true,
                maritalStatus: true,
                occupation: true,
                education: true, // תיאור טקסטואלי
                educationLevel: true, // רמת השכלה מובנית - נוסף
                // address: true, // הוסר מ-UserProfile
                city: true,
                origin: true,
                religiousLevel: true,
                about: true,
                // hobbies: true, // הוסר (הוחלף ב-profileHobbies)

                // --- שדות חדשים מ-UserProfile ---
                shomerNegiah: true,
                serviceType: true,
                serviceDetails: true,
                headCovering: true, // לנשים
                kippahType: true, // לגברים
                hasChildrenFromPrevious: true,
                profileCharacterTraits: true,
                profileHobbies: true,
                aliyaCountry: true,
                aliyaYear: true,

                parentStatus: true,
                siblings: true,
                position: true,
                preferredAgeMin: true,
                preferredAgeMax: true,
                preferredHeightMin: true,
                preferredHeightMax: true,
                preferredReligiousLevels: true,
                preferredLocations: true,
                preferredEducation: true,
                preferredOccupations: true,
                contactPreference: true,

                isProfileVisible: true,
                preferredMatchmakerGender: true,
                matchingNotes: true,
                verifiedBy: true,
                availabilityStatus: true,
                availabilityNote: true,
                availabilityUpdatedAt: true,
                createdAt: true,
                updatedAt: true,
                lastActive: true,
              },
            },
            images: {
              select: {
                id: true,
                url: true,
                isMain: true,
                cloudinaryPublicId: true,
                createdAt: true,
                updatedAt: true,
              },
            },
          },
        },
      },
      orderBy: {
        updatedAt: "desc", // Changed from createdAt in previous example, make sure this is intended for history
      },
    });

    // Typing the suggestion before mapping for better intellisense and safety
    // This assumes the structure returned by Prisma matches what's expected by UserProfile
    // and related types.
    const formattedSuggestions = historySuggestions.map(suggestion => {
      // Ensure profile exists before trying to spread it, or handle potential null case
      // Prisma's `include` with `select` guarantees `profile` exists if the relation does,
      // but if `firstParty` or `secondParty` could be null (e.g., if the user was deleted),
      // you'd need to handle that. Here, they are expected to be non-null.
      
      const firstPartyProfile = suggestion.firstParty.profile as UserProfile | null;
      const secondPartyProfile = suggestion.secondParty.profile as UserProfile | null;

      return {
        ...suggestion,
        firstParty: {
            ...suggestion.firstParty,
            profile: firstPartyProfile ? { // Add user sub-object to firstParty.profile if it's part of UserProfile type
                ...firstPartyProfile,
                user: {
                    id: suggestion.firstParty.id,
                    firstName: suggestion.firstParty.firstName,
                    lastName: suggestion.firstParty.lastName,
                    email: suggestion.firstParty.email,
                }
            } : null,
        },
        secondParty: {
          ...suggestion.secondParty,
          profile: secondPartyProfile ? {
            ...secondPartyProfile,
            user: { // This structure matches the UserProfile.user field
              id: suggestion.secondParty.id,
              firstName: suggestion.secondParty.firstName,
              lastName: suggestion.secondParty.lastName,
              email: suggestion.secondParty.email,
            }
          } : null,
        }
      };
    });

    return NextResponse.json({
      success: true,
      suggestions: formattedSuggestions,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\user
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\user\accept-terms
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\user\accept-terms\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/accept-terms/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // ודא שהנתיב ל-authOptions נכון
import prisma from "@/lib/prisma";

export async function POST() {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const userId = session.user.id;

    // בדוק אם המשתמש כבר אישר את התנאים כדי למנוע עדכונים מיותרים
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { termsAndPrivacyAcceptedAt: true },
    });

    if (user?.termsAndPrivacyAcceptedAt) {
      return NextResponse.json({ success: true, message: 'Terms already accepted' });
    }

    // עדכן את המשתמש עם חתימת זמן ההסכמה
    await prisma.user.update({
      where: { id: userId },
      data: {
        termsAndPrivacyAcceptedAt: new Date(),
      },
    });

    // אין צורך להחזיר את הסשן המעודכן כאן, הלקוח ירענן אותו עם update()
    return NextResponse.json({ success: true, message: 'Terms accepted successfully' });

  } catch (error) {
    console.error('Error accepting terms:', error);
    let errorMessage = 'An unexpected error occurred';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\user\complete-onboarding
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\api\user\complete-onboarding\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/complete-onboarding/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth"; // ודא שהנתיב נכון לקובץ ה-auth שלך
import prisma from "@/lib/prisma"; // ודא שהנתיב נכון לקובץ ה-prisma client שלך

export async function POST(req: Request) {
  try {
    // 1. אימות הסשן של המשתמש בצד השרת
    const session = await getServerSession(authOptions);

    // 2. בדיקה אם המשתמש מחובר
    if (!session || !session.user || !session.user.id) {
      console.warn("[API/complete-onboarding] Unauthorized attempt: No session found.");
      return NextResponse.json(
        { success: false, error: "Unauthorized: User not authenticated." },
        { status: 401 }
      );
    }

    const userId = session.user.id;
    console.log(`[API/complete-onboarding] Received request for user ID: ${userId}`);

    // 3. עדכון מסד הנתונים
    // אנו בודקים אם המשתמש כבר השלים את הסיור כדי למנוע כתיבות מיותרות ל-DB
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { hasCompletedOnboarding: true }
    });

    if (user?.hasCompletedOnboarding) {
      console.log(`[API/complete-onboarding] User ${userId} has already completed onboarding. No update needed.`);
      return NextResponse.json(
        { success: true, message: "Onboarding was already completed." },
        { status: 200 }
      );
    }
    
    // אם לא הושלם, עדכן את הדגל ל-true
    await prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        hasCompletedOnboarding: true,
      },
    });

    console.log(`[API/complete-onboarding] Successfully updated hasCompletedOnboarding for user ID: ${userId}`);

    // 4. החזרת תגובת הצלחה
    return NextResponse.json(
      { success: true, message: "Onboarding status updated successfully." },
      { status: 200 }
    );

  } catch (error) {
    console.error("[API/complete-onboarding] Error:", error);

    // טיפול בשגיאות כלליות
    let errorMessage = "An internal server error occurred.";
    if (error instanceof Error) {
      errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\auth_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth
# Generated on: 2025-06-24 07:22:23
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\auth_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\error
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\error\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useSearchParams } from "next/navigation";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";

export default function ErrorPage() {
  const searchParams = useSearchParams();
  const error = searchParams.get("error");
  const router = useRouter();

  const getErrorMessage = (error: string) => {
    switch (error) {
      case "Signin":
        return "נסה להתחבר שוב";
      case "OAuthSignin":
        return "נסה להתחבר שוב";
      case "OAuthCallback":
        return "שגיאה בתהליך ההתחברות";
      case "OAuthCreateAccount":
        return "שגיאה ביצירת החשבון";
      case "EmailCreateAccount":
        return "שגיאה ביצירת החשבון";
      case "Callback":
        return "שגיאה בתהליך ההתחברות";
      case "OAuthAccountNotLinked":
        return "החשבון כבר מקושר למשתמש אחר";
      case "EmailSignin":
        return "בדוק את תיבת הדואר שלך";
      case "CredentialsSignin":
        return "פרטי ההתחברות שגויים";
      default:
        return "שגיאה בתהליך ההתחברות";
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl font-bold text-red-600">
            שגיאה
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <p className="text-gray-600">
            {error ? getErrorMessage(error) : "שגיאה לא ידועה"}
          </p>
          <Button
            onClick={() => router.push("/auth/signin")}
            className="w-full"
          >
            חזרה לדף ההתחברות
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\forgot-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\forgot-password\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/auth/forgot-password/page.tsx
import ForgotPasswordForm from "@/app/components/auth/ForgotPasswordForm";
import { ArrowLeft } from "lucide-react"; // Assuming you use lucide-react
import Link from "next/link";

export default function ForgotPasswordPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 sm:p-8">
        <Link
            href="/"
            className="absolute top-4 left-4 rtl:right-4 rtl:left-auto text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm z-20"
        >
            <ArrowLeft className="h-4 w-4 transform rtl:rotate-180" /> {/* Corrected for RTL if needed */}
            חזרה לדף הבית
        </Link>
      <ForgotPasswordForm />
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\google-callback
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\google-callback\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/auth/google-callback/page.tsx

"use client";

import { useEffect, useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { SessionProvider, getSession } from "next-auth/react";
import {
  RegistrationProvider,
  useRegistration,
} from "@/app/components/auth/RegistrationContext";
import RegisterSteps from "@/app/components/auth/RegisterSteps";
import { User } from "@/types/next-auth";
import { CheckCircle, Loader2, XCircle } from "lucide-react";

const GoogleCallbackContent = () => {
  const router = useRouter();
  const [status, setStatus] = useState<
    "loading" | "success" | "register" | "error"
  >("loading");
  const [error, setError] = useState<string>("");
  const [sessionChecked, setSessionChecked] = useState(false);
  const [retryCount, setRetryCount] = useState(0);
  const { setGoogleSignup, data: registrationData } = useRegistration();

  const checkSessionAndProceed = useCallback(async () => {
    console.log("Attempting to fetch session manually using getSession()...");
    setStatus("loading");
    setError("");

    try {
      const session = await getSession();
      console.log("getSession() result:", session);
      setSessionChecked(true);

      if (session?.user) {
        const currentUser = session.user as User;
        console.log("Manual session check successful. User data:", {
          id: currentUser.id,
          email: currentUser.email,
          isProfileComplete: currentUser.isProfileComplete,
        });

        if (currentUser.isProfileComplete) {
          console.log(
            `User ${currentUser.email} profile complete. Setting status to 'success' then redirecting to /profile.`
          );
          setStatus("success");
          setTimeout(() => {
            console.log("Redirecting to /profile after delay.");
            router.replace("/profile");
          }, 3000);
        } else {
          console.log(
            `User ${currentUser.email} profile incomplete. Initializing registration steps.`
          );
          if (
            currentUser.email &&
            currentUser.firstName &&
            currentUser.lastName
          ) {
            const googleData = {
              email: currentUser.email,
              firstName: currentUser.firstName,
              lastName: currentUser.lastName,
            };
            console.log("Calling setGoogleSignup with:", googleData);
            try {
              setGoogleSignup(googleData);
              console.log(
                "setGoogleSignup called successfully. Setting status to 'register'."
              );
              setStatus("register");
            } catch (contextError) {
              console.error("Error calling setGoogleSignup:", contextError);
              setError("שגיאה באתחול תהליך ההרשמה.");
              setStatus("error");
            }
          } else {
            console.error("Missing essential Google data after getSession.");
            setError("פרטים חסרים מ-Google. נסה שוב או הירשם ידנית.");
            setStatus("error");
          }
        }
      } else {
        console.error(
          "Manual session check failed (getSession returned null or no user)."
        );
        if (retryCount < 3) {
          console.log(`Retrying session check (${retryCount + 1}/3)...`);
          setRetryCount(retryCount + 1);
          setTimeout(() => checkSessionAndProceed(), 1000);
          return;
        }
        setError("לא ניתן היה לאמת את ההתחברות מול השרת. נסה שוב.");
        setStatus("error");
      }
    } catch (err) {
      console.error("Error calling getSession():", err);
      setError("אירעה שגיאה בבדיקת ההתחברות מול השרת.");
      setStatus("error");
    }
  }, [router, setGoogleSignup, retryCount]);

  useEffect(() => {
    if (!sessionChecked) {
      checkSessionAndProceed();
    }
  }, [sessionChecked, checkSessionAndProceed]);

  if (status === "loading") {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 text-center">
        <Loader2 className="h-16 w-16 animate-spin text-cyan-600 mb-4" />
        <h2 className="text-xl font-semibold text-gray-700">
          מאמת התחברות Google...
        </h2>
        <p className="text-gray-500 mt-2">אנא המתן...</p>
      </div>
    );
  }

  if (status === "error") {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
        <div className="max-w-md w-full bg-white rounded-xl shadow-lg p-6 border-t-4 border-red-500">
          <div className="text-center text-red-500 mb-4">
            <XCircle className="w-12 h-12 mx-auto mb-3" />
            <h2 className="text-xl font-bold">שגיאה בתהליך</h2>
          </div>
          <p className="text-gray-600 text-center mb-6">{error}</p>
          <div className="flex justify-center">
            <button
              onClick={() => router.push("/auth/signin")}
              className="py-2 px-6 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 text-white rounded-lg shadow-md transition-all duration-300"
            >
              חזרה להתחברות
            </button>
          </div>
        </div>
      </div>
    );
  }

  if (status === "success") {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
        <div className="bg-white p-8 rounded-xl shadow-xl text-center max-w-md w-full">
          <CheckCircle className="h-16 w-16 text-green-500 mx-auto mb-4" />
          <h1 className="text-2xl font-bold text-gray-800">
            התחברת בהצלחה עם Google!
          </h1>
          <p className="text-gray-600 mt-3">
            החשבון שלך אומת, מיד תועבר לפרופיל שלך.
          </p>
          <p className="text-gray-500 mt-1">אנא המתן...</p>
          <Loader2 className="h-6 w-6 text-gray-400 animate-spin mx-auto mt-5" />
        </div>
      </div>
    );
  }

  if (status === "register") {
    console.log(
      "Rendering RegisterSteps component via 'register' status. Current registration step:",
      registrationData.step
    );
    return <RegisterSteps />;
  }

  return (
    <div className="min-h-screen flex items-center justify-center">
      מצב לא צפוי...
    </div>
  );
};

export default function GoogleCallbackPage() {
  return (
    <SessionProvider>
      <RegistrationProvider>
        <GoogleCallbackContent />
      </RegistrationProvider>
    </SessionProvider>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\register\page.tsx
--------------------------------------------------------------------------------
Content:
import RegisterSteps from "@/app/components/auth/RegisterSteps";

export default function RegisterPage() {
  return <RegisterSteps />;
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\reset-password\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/auth/reset-password/page.tsx
import ResetPasswordForm from "@/app/components/auth/ResetPasswordForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Suspense } from "react"; // Import Suspense

// A wrapper component to allow useSearchParams in a Client Component
function ResetPasswordPageContent() {
    return <ResetPasswordForm />;
}

export default function ResetPasswordPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 sm:p-8">
      <Link
        href="/"
        className="absolute top-4 left-4 rtl:right-4 rtl:left-auto text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm z-20"
      >
        <ArrowLeft className="h-4 w-4 transform rtl:rotate-180" />
        חזרה לדף הבית
      </Link>
      {/* Wrap the client component that uses useSearchParams with Suspense */}
      <Suspense fallback={<div>טוען...</div>}>
        <ResetPasswordPageContent />
      </Suspense>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\setup-account
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\setup-account\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/auth/setup-account/page.tsx
"use client";

import React, { useState, useEffect, Suspense } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { toast } from 'sonner';
import { Loader2, KeyRound, CheckCircle } from "lucide-react";

function SetupAccountForm() {
  const searchParams = useSearchParams();
  const router = useRouter(); 
  
  const [token, setToken] = useState<string | null>(null);
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);

  useEffect(() => {
    const tokenFromUrl = searchParams.get('token');
    if (tokenFromUrl) {
      setToken(tokenFromUrl);
    } else {
      setError("קישור הגדרת החשבון אינו תקין או חסר. אנא השתמש בקישור שנשלח אליך במייל.");
    }
  }, [searchParams]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    if (password.length < 8) {
      setError("הסיסמה חייבת להכיל לפחות 8 תווים.");
      return;
    }
    if (password !== confirmPassword) {
      setError("הסיסמאות אינן תואמות.");
      return;
    }
    
    setIsLoading(true);

    try {
      const response = await fetch('/api/auth/complete-setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token, password }),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.error || 'שגיאה בהגדרת החשבון.');
      }

      setSuccess(true);
      toast.success("החשבון הוגדר בהצלחה! הנך מועבר/ת להשלמת הפרופיל.");

      // --- START: התיקון המרכזי ---
      // נשתמש ב-window.location.assign כדי לכפות רענון מלא והפניה.
      // זה מבטיח שה-Middleware יקבל את הסשן המעודכן ביותר.
      // נוסיף השהיה קטנה כדי שהמשתמש יראה את הודעת ההצלחה.
      setTimeout(() => {
        window.location.assign('/profile'); 
      }, 1500); // 1.5 שניות
      // --- END: התיקון המרכזי ---

    } catch (err) {
      setError(err instanceof Error ? err.message : 'אירעה שגיאה בלתי צפויה.');
      setIsLoading(false); 
    }
  };
  
  if (success) {
    return (
        <Card className="w-full max-w-md mx-auto text-center">
            <CardHeader>
                <div className="mx-auto bg-green-100 rounded-full p-3 w-fit">
                    <CheckCircle className="h-10 w-10 text-green-600" />
                </div>
                <CardTitle className="mt-4">החשבון הוגדר בהצלחה!</CardTitle>
            </CardHeader>
            <CardContent>
                <p className="text-muted-foreground">הסיסמה נקבעה. הנך מועבר/ת אוטומטית לשלב הבא של השלמת הפרופיל.</p>
                <Loader2 className="mt-4 h-6 w-6 animate-spin mx-auto" />
            </CardContent>
        </Card>
    );
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>הגדרת חשבון וקביעת סיסמה</CardTitle>
        <CardDescription>
          שלב אחרון לפני שתוכל/י להתחיל. אנא בחר/י סיסמה לחשבונך.
        </CardDescription>
      </CardHeader>
      <CardContent>
        {!token ? (
            <div className="text-red-500 text-center p-4 bg-red-50 rounded-md">{error}</div>
        ) : (
            <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <Label htmlFor="password">סיסמה חדשה</Label>
                <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                />
                <p className="text-xs text-muted-foreground mt-1">לפחות 8 תווים, כולל אותיות ומספרים.</p>
            </div>
            <div>
                <Label htmlFor="confirmPassword">אישור סיסמה</Label>
                <Input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                />
            </div>
            {error && <p className="text-sm font-medium text-destructive">{error}</p>}
             <CardFooter className="p-0 pt-4">
                 <Button type="submit" className="w-full" disabled={isLoading}>
                    {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <KeyRound className="mr-2 h-4 w-4" />}
                    {isLoading ? 'מגדיר סיסמה...' : 'הגדר סיסמה והמשך'}
                </Button>
            </CardFooter>
            </form>
        )}
      </CardContent>
    </Card>
  );
}

// Suspense Boundary for useSearchParams
export default function SetupAccountPage() {
    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4">
            <Suspense fallback={<Loader2 className="h-8 w-8 animate-spin" />}>
                <SetupAccountForm />
            </Suspense>
        </div>
    );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\signin
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\signin\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { signIn } from "next-auth/react";
import { useSession } from "next-auth/react";
import { SessionProvider } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Mail, Lock, AlertCircle, ArrowLeft } from "lucide-react";
import Link from "next/link";

// Signin form component
const SignInForm = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { data: session, status } = useSession();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);

  // Get error message from URL if exists
  useEffect(() => {
    const errorMessage = searchParams.get("error");
    if (errorMessage) {
      switch (errorMessage) {
        case "CredentialsSignin":
          setError("אימייל או סיסמה אינם נכונים");
          break;
        default:
          setError("אירעה שגיאה, נסה שנית");
      }
    }
  }, [searchParams]);

  // If user is already logged in, redirect to profile
  useEffect(() => {
    if (session?.user) {
      router.push("/profile");
    }
  }, [session, router]);

  // Handle email/password sign in
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!email || !password) {
      setError("אנא הזן אימייל וסיסמה");
      return;
    }

    try {
      setError("");
      setIsLoading(true);

      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("אימייל או סיסמה אינם נכונים");
        console.error("Sign-in error:", result.error);
      } else {
        router.push("/profile");
      }
    } catch (err) {
      console.error("Unexpected sign-in error:", err);
      setError("אירעה שגיאה בהתחברות, נסה שנית");
    } finally {
      setIsLoading(false);
    }
  };

  // Handle Google sign in
  const handleGoogleSignIn = async () => {
    try {
      setIsGoogleLoading(true);
      setError("");

      // Store this information for potential fallback
      localStorage.setItem("signin_started", "true");

      // NextAuth will handle the redirect
      await signIn("google");
    } catch (error) {
      console.error("Google sign-in error:", error);
      setError("אירעה שגיאה בהתחברות עם גוגל");
      setIsGoogleLoading(false);
    }
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
        <div className="mb-4 w-16 h-16 border-4 border-t-4 border-cyan-500 border-t-pink-500 rounded-full animate-spin"></div>
        <h2 className="text-xl font-medium text-gray-700">טוען...</h2>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
      {/* Back to home button */}
      <button
        onClick={() => router.push("/")}
        className="absolute top-4 left-4 text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm"
      >
        <ArrowLeft className="h-4 w-4" />
        חזרה לדף הבית
      </button>

      <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
        {/* Decorative elements */}
        <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>

        <div className="p-6 sm:p-8">
          <div className="text-center mb-6">
            <h1 className="text-2xl font-bold text-gray-800 mb-2">
              התחברות למערכת
            </h1>
            <p className="text-gray-600">
              ברוכים השבים! המשיכו למצוא את השידוך המושלם
            </p>
          </div>

          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg flex items-center gap-2">
              <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0" />
              <p className="text-red-600 text-sm">{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-4 mb-6">
            <div className="space-y-1">
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700"
              >
                אימייל
              </label>
              <div className="relative">
                <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <input
                  type="email"
                  id="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  placeholder="you@example.com"
                />
              </div>
            </div>

            <div className="space-y-1">
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700"
              >
                סיסמה
              </label>
              <div className="relative">
                <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <input
                  type="password"
                  id="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  placeholder="הסיסמה שלך"
                />
              </div>
              <div className="flex justify-end">
                <Link
                  href="/auth/forgot-password"
                  className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline mt-1"
                >
                  שכחת סיסמה?
                </Link>
              </div>
            </div>

            <Button
              type="submit"
              disabled={isLoading}
              className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2 relative overflow-hidden"
            >
              {isLoading ? (
                <>
                  <div className="h-4 w-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                  מתחבר...
                </>
              ) : (
                <>
                  {/* Button shimmer effect */}
                  <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
                  <span>התחברות</span>
                </>
              )}
            </Button>
          </form>

          <div className="relative mb-6">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">או</span>
            </div>
          </div>

          <Button
            onClick={handleGoogleSignIn}
            disabled={isGoogleLoading}
            variant="outline"
            size="lg"
            className="w-full relative border-2 border-gray-300 hover:border-gray-400 py-3 rounded-xl flex items-center justify-center gap-3 group"
          >
            {isGoogleLoading ? (
              <div className="animate-spin h-5 w-5 border-2 border-gray-500 rounded-full border-t-transparent" />
            ) : (
              <>
                <svg className="h-5 w-5" viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                    fill="#4285F4"
                  />
                  <path
                    d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                    fill="#34A853"
                  />
                  <path
                    d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                    fill="#FBBC05"
                  />
                  <path
                    d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                    fill="#EA4335"
                  />
                </svg>
                <span className="text-gray-700 font-medium">
                  התחברות עם Google
                </span>
              </>
            )}
          </Button>

          <div className="mt-6 text-center">
            <p className="text-gray-600 text-sm">
              אין לך חשבון עדיין?{" "}
              <Link
                href="/auth/register"
                className="text-cyan-600 font-medium hover:text-cyan-700 hover:underline"
              >
                הרשמה עכשיו
              </Link>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

// Export the page with provider
export default function SignInPage() {
  return (
    <SessionProvider>
      <SignInForm />
    </SessionProvider>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\update-phone
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\update-phone\page.tsx
--------------------------------------------------------------------------------
Content:
// app/auth/update-phone/page.tsx
'use client';

import { useState, useCallback } from 'react'; // Added useCallback
import { useRouter } from 'next/navigation';
import { useSession } from 'next-auth/react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { AlertCircle, Loader2, Phone } from 'lucide-react';
import Link from 'next/link';

const UpdatePhonePage = () => {
    const router = useRouter();
    const { status: sessionStatus } = useSession();
    const [newPhone, setNewPhone] = useState('');
    const [error, setError] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const handleSubmit = useCallback(async (e: React.FormEvent) => {
        e.preventDefault(); // Prevent default form submission
        setError(null); // Clear previous errors

        // Basic phone number format validation
        if (!/^0\d{9}$/.test(newPhone)) {
            setError("פורמט מספר הטלפון אינו תקין (לדוגמה: 0501234567).");
            return;
        }

        setIsLoading(true);
        try {
            const response = await fetch('/api/auth/update-and-resend-code', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ newPhone }),
            });

            const result = await response.json();

            if (!response.ok) {
                // Use error message from API if available
                throw new Error(result.error || 'עדכון מספר הטלפון נכשל.');
            }

            // Success! Redirect back to the verification page to enter the new code
            console.log("Phone updated, redirecting back to verify page.");
            router.push('/auth/verify-phone');

        } catch (err: unknown) { // Catch error as unknown
             // Type check the error before accessing properties
             if (err instanceof Error) {
                 setError(err.message);
             } else {
                 setError('אירעה שגיאה בלתי צפויה בעת עדכון מספר הטלפון.');
             }
        } finally {
            setIsLoading(false); // Stop loading indicator
        }
    }, [newPhone, router]); // Dependencies for useCallback

    // --- Session Handling & Loading State ---
    if (sessionStatus === 'loading') {
        return (
             <div className="min-h-screen flex items-center justify-center">
                 <Loader2 className="h-8 w-8 animate-spin text-cyan-600" />
                 <span className="ml-2">טוען נתונים...</span>
             </div>
         );
    }
     if (sessionStatus === 'unauthenticated') {
         // If user somehow gets here unauthenticated, redirect to signin
         router.push('/auth/signin?callbackUrl=/auth/update-phone');
         return null; // Return null while redirecting
    }
    // --- End Session Handling ---


    // --- Render Component ---
    return (
        <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
            <div className="w-full max-w-sm bg-white rounded-xl shadow-xl p-6 sm:p-8 space-y-6"> {/* Adjusted padding */}
                <div className="text-center">
                    <h1 className="text-2xl font-bold text-gray-800">עדכון מספר טלפון</h1>
                    <p className="text-gray-600 mt-2 text-sm sm:text-base"> {/* Adjusted text size */}
                        הזן/י את מספר הטלפון הנכון שלך.
                        <br />קוד אימות חדש יישלח אליו באמצעות WhatsApp.
                    </p>
                </div>

                {/* Error Alert */}
                {error && (
                    <Alert variant="destructive">
                        <AlertCircle className="h-4 w-4" />
                        <AlertTitle>שגיאה</AlertTitle>
                        <AlertDescription>{error}</AlertDescription>
                    </Alert>
                )}

                {/* Update Phone Form */}
                <form onSubmit={handleSubmit} className="space-y-4">
                    <div>
                        <label htmlFor="phone" className="block text-sm font-medium text-gray-700 mb-1 text-right">
                            מספר טלפון חדש
                        </label>
                         <div className="relative">
                            {/* Icon on the right for RTL */}
                            <Phone className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5 pointer-events-none" />
                            <Input
                                type="tel" // Use tel type for better mobile experience
                                id="phone"
                                name="phone"
                                value={newPhone}
                                onChange={(e) => setNewPhone(e.target.value)}
                                placeholder="0501234567"
                                className="w-full pr-10 pl-3 py-2 border border-gray-300 rounded-md focus:ring-cyan-500 focus:border-cyan-500 shadow-sm text-right" // Added text-right
                                required
                                disabled={isLoading}
                                dir="ltr" // Keep input direction LTR for phone numbers
                                autoComplete="tel" // Add autocomplete hint
                            />
                         </div>
                    </div>

                    <Button type="submit" disabled={isLoading} className="w-full py-3"> {/* Added py-3 */}
                        {isLoading ? <Loader2 className="animate-spin h-5 w-5" /> : 'עדכן ושלח קוד חדש'}
                    </Button>
                </form>

                 {/* Link back to Verification Page */}
                 <div className="text-center mt-4">
                     <Link href="/auth/verify-phone" className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline">
                         חזרה לאימות קוד
                     </Link>
                 </div>
            </div>
        </div>
    );
};

export default UpdatePhonePage;
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-email\page.tsx
--------------------------------------------------------------------------------
Content:
// /auth/verify-email/page.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useSession } from "next-auth/react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2 } from "lucide-react";

interface VerificationState {
  status: "pending" | "verifying" | "success" | "error";
  message: string;
}

export default function VerifyEmailPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { data: session } = useSession();

  const navigationTimeoutIdRef = useRef<NodeJS.Timeout | null>(null);

  // Ref to ensure the API call logic runs only once after the component has "settled" from StrictMode effects.
  const verificationApiCallMadeRef = useRef(false);

  const [verification, setVerification] = useState<VerificationState>({
    status: "pending",
    message: "",
  });

  const [isResending, setIsResending] = useState(false);

  const handleResendVerification = async () => {
    // ... (same as before)
    const emailFromQuery = searchParams.get("email");
    if (!emailFromQuery) {
      setVerification({
        status: "error",
        message: "לא ניתן לשלוח מחדש ללא כתובת אימייל.",
      });
      return;
    }
    setIsResending(true);
    setVerification({ status: "pending", message: "" });
    try {
      const response = await fetch("/api/auth/resend-verification", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: emailFromQuery, type: "EMAIL" }),
      });
      const data = await response.json();
      if (!response.ok)
        throw new Error(data.error || "שגיאה בשליחת מייל האימות מחדש");
      setVerification({
        status: "pending",
        message: "מייל אימות חדש נשלח בהצלחה. אנא בדוק את תיבת הדואר.",
      });
    } catch (error) {
      setVerification({
        status: "error",
        message:
          error instanceof Error
            ? error.message
            : "שגיאה בשליחת מייל האימות מחדש",
      });
    } finally {
      setIsResending(false);
    }
  };

  useEffect(() => {
    let isEffectMounted = true; // Tracks if the current effect instance is still mounted
    const controller = new AbortController();

    const processVerification = async () => {
      if (verificationApiCallMadeRef.current) {
        console.log(
          "VerifyEmailPage: API call already made or in progress, skipping."
        );
        return;
      }
      verificationApiCallMadeRef.current = true; // Mark that we are making the call

      const rawTokenParam = searchParams.get("token");
      const emailFromQuery = searchParams.get("email");
      let actualToken: string | null = null;

      console.log("VerifyEmailPage: Raw token from URL:", rawTokenParam);
      if (rawTokenParam) {
        // ... (token extraction logic)
        if (
          rawTokenParam.includes("://") &&
          rawTokenParam.includes("?token=")
        ) {
          try {
            const nestedUrl = new URL(rawTokenParam);
            actualToken = nestedUrl.searchParams.get("token");
            console.log(
              "VerifyEmailPage: Extracted token from nested URL:",
              actualToken
            );
          } catch (error) {
            console.warn(
              "VerifyEmailPage: Could not parse rawTokenParam as a URL:",
              rawTokenParam,
              error
            );
            actualToken = rawTokenParam;
          }
        } else {
          actualToken = rawTokenParam;
          console.log(
            "VerifyEmailPage: Using raw token directly:",
            actualToken
          );
        }
      }

      if (!actualToken) {
        if (emailFromQuery) {
          console.log(
            "VerifyEmailPage: No token, but email found. Setting to pending."
          );
          if (isEffectMounted)
            setVerification({
              status: "pending",
              message: "שלחנו מייל אימות לכתובת:",
            });
        } else {
          console.log(
            "VerifyEmailPage: No token and no email. Setting to error."
          );
          if (isEffectMounted)
            setVerification({
              status: "error",
              message: "קישור האימות אינו תקין (חסר מידע נדרש).",
            });
        }
        return; // Stop further processing
      }

      if (isEffectMounted)
        setVerification({ status: "verifying", message: "" });
      console.log(
        "VerifyEmailPage: ==> Attempting API verification for token:",
        actualToken
      );

      // Session check
      if (
        session?.user?.email &&
        emailFromQuery &&
        session.user.email !== emailFromQuery
      ) {
        console.warn(
          "VerifyEmailPage: User logged in with different email. Aborting."
        );
        if (isEffectMounted)
          setVerification({
            status: "error",
            message:
              "אתה מחובר עם חשבון מייל אחר. אנא התנתק ונסה שוב את הלינק.",
          });
        return;
      }

      try {
        const response = await fetch("/api/auth/verify", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: actualToken, type: "EMAIL" }),
          signal: controller.signal,
        });

        let data;
        try {
          data = await response.json();
        } catch (jsonError) {
          console.error(
            "VerifyEmailPage (API): Failed to parse JSON response.",
            jsonError
          );
          if (response.ok && response.status !== 204)
            throw new Error("תגובה לא תקינה מהשרת (JSON parsing failed).");
          else if (!response.ok)
            throw new Error("תגובה לא תקינה מהשרת במהלך האימות.");
        }

        if (controller.signal.aborted) {
          console.log("VerifyEmailPage (API): Fetch aborted by cleanup.");
          return;
        }

        if (!response.ok) {
          const errorMessage =
            data?.error || `שגיאה באימות החשבון (סטטוס ${response.status})`;
          throw new Error(errorMessage);
        }

        console.log("VerifyEmailPage (API): Verification successful.");
        if (isEffectMounted) {
          setVerification({
            status: "success",
            message: "החשבון אומת בהצלחה!",
          });
          navigationTimeoutIdRef.current = setTimeout(() => {
            if (isEffectMounted) {
              // Check mount status again before navigating
              console.log("VerifyEmailPage: Navigating now to /auth/signin.");
              router.push("/auth/signin");
            } else {
              console.log(
                "VerifyEmailPage: Effect unmounted before navigation timeout."
              );
            }
          }, 1500);
        }
      } catch (error: unknown) {
        if (controller.signal.aborted) {
          // Check if the error is due to our own abort
          console.log(
            "VerifyEmailPage (API) [catch]: Fetch aborted by controller during operation."
          );
        } else if (isEffectMounted) {
          console.error(
            "VerifyEmailPage (API) [catch]: Error during API verification:",
            error
          );
          let errorMessage = "שגיאה באימות החשבון";
          if (error instanceof Error) {
            if (error.message.includes("הטוקן כבר נוצל"))
              errorMessage =
                "הטוקן הזה כבר נוצל לאימות. אם נרשמת בהצלחה, נסה להתחבר.";
            else if (error.message.includes("תוקף הטוקן פג"))
              errorMessage =
                "תוקף קישור האימות פג. אנא נסה לשלוח מייל אימות מחדש.";
            else if (error.message.includes("תגובה לא תקינה מהשרת"))
              errorMessage = error.message;
            else errorMessage = error.message;
          } else {
            errorMessage = "אירעה שגיאה לא צפויה במהלך האימות.";
          }
          setVerification({ status: "error", message: errorMessage });
        }
      }
    };

    processVerification();

    return () => {
      console.log(
        "VerifyEmailPage (useEffect cleanup): Cleaning up. Aborting API call."
      );
      isEffectMounted = false; // Mark that this effect instance is being cleaned up
      controller.abort();
      if (navigationTimeoutIdRef.current) {
        clearTimeout(navigationTimeoutIdRef.current);
        console.log(
          "VerifyEmailPage (useEffect cleanup): Cleared navigation timeout."
        );
      }
      // Do NOT reset verificationApiCallMadeRef.current here.
      // It should ensure the logic runs only once per component true lifecycle.
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, router, session]); // Dependencies

  // ... (JSX remains the same)
  return (
    <div className="min-h-screen flex items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardContent className="p-6 space-y-4">
          {verification.status === "pending" && (
            <div className="text-center space-y-4">
              <h2 className="text-xl font-semibold">אימות חשבון</h2>
              {verification.message && (
                <Alert
                  variant="default"
                  className="text-sm text-center bg-blue-50 border-blue-200 text-blue-800"
                >
                  <AlertDescription>
                    {verification.message ||
                      (searchParams.get("email")
                        ? "שלחנו מייל אימות לכתובת:"
                        : "טוען מידע...")}
                  </AlertDescription>
                </Alert>
              )}
              {!verification.message && searchParams.get("email") && (
                <p>שלחנו מייל אימות לכתובת:</p>
              )}
              <p className="font-medium">
                {searchParams.get("email") || "לא צוינה כתובת"}
              </p>
              <p>אנא בדקו את תיבת הדואר שלכם ולחצו על הקישור לאימות החשבון.</p>
              {searchParams.get("email") && (
                <Button
                  onClick={handleResendVerification}
                  disabled={isResending}
                  className="mt-4"
                >
                  {isResending ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" /> שולח
                      מייל חדש...
                    </>
                  ) : (
                    "שלח מייל אימות מחדש"
                  )}
                </Button>
              )}
            </div>
          )}
          {verification.status === "verifying" && (
            <div className="flex flex-col items-center space-y-4">
              <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
              <p className="text-gray-600">מאמת את החשבון...</p>
            </div>
          )}
          {verification.status === "success" && (
            <div className="text-center space-y-4">
              <h2 className="text-xl font-semibold text-green-600">
                {verification.message}
              </h2>
              <p className="text-gray-600">
                החשבון אומת בהצלחה. מעביר אותך להתחברות...
              </p>
              <Loader2 className="h-6 w-6 animate-spin mx-auto mt-4 text-gray-400" />
            </div>
          )}
          {verification.status === "error" && (
            <div className="space-y-4">
              <Alert variant="destructive">
                <AlertDescription>{verification.message}</AlertDescription>
              </Alert>
              {searchParams.get("email") &&
                !verification.message.includes("הטוקן הזה כבר נוצל") &&
                !verification.message.includes("מחובר עם חשבון מייל אחר") &&
                (verification.message.includes("תוקף קישור האימות פג") ||
                  verification.message.includes(
                    "שגיאה בשליחת מייל האימות מחדש"
                  ) ||
                  (verification.message.includes("שגיאה באימות החשבון") &&
                    !verification.message.includes(
                      "פורמט קישור האימות אינו תקין"
                    ) &&
                    !verification.message.includes("תגובה לא תקינה מהשרת")) ||
                  verification.message.includes("תגובה לא תקינה מהשרת")) && (
                  <div className="flex justify-center">
                    <Button
                      onClick={handleResendVerification}
                      disabled={isResending}
                      variant="outline"
                      className="mt-2"
                    >
                      {isResending ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" /> שולח
                          מייל חדש...
                        </>
                      ) : (
                        "נסה לשלוח מייל אימות מחדש"
                      )}
                    </Button>
                  </div>
                )}
              <div className="flex justify-center mt-4">
                <Button onClick={() => router.push("/auth/signin")}>
                  חזור לדף ההתחברות
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-phone
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-phone\page.tsx
--------------------------------------------------------------------------------
Content:
// app/auth/verify-phone/page.tsx
"use client";

import { useState, useEffect, useRef, useCallback, FormEvent } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, Loader2, CheckCircle } from "lucide-react"; // Mail or Info icon could be added if needed
import Link from "next/link";

const OTP_LENGTH = 6;

const VerifyPhonePage = () => {
  const router = useRouter();
  const {
    data: session,
    status: sessionStatus,
    update: updateSession,
  } = useSession();
  const [code, setCode] = useState<string[]>(new Array(OTP_LENGTH).fill(""));
  const [error, setError] = useState<string | null>(null);
  const [verifySuccessMessage, setVerifySuccessMessage] = useState<string | null>(null); // Renamed from successMessage
  const [resendInfoMessage, setResendInfoMessage] = useState<string | null>(null); // New state for resend info
  const [isLoading, setIsLoading] = useState(false); // For verify code submission
  const [isResending, setIsResending] = useState(false); // For resend code submission
  const [resendDisabled, setResendDisabled] = useState(false);
  const [resendTimer, setResendTimer] = useState(0);
  const inputRefs = useRef<(HTMLInputElement | null)[]>([]);

  // --- Resend Timer Logic ---
  useEffect(() => {
    let interval: NodeJS.Timeout | null = null;
    if (resendDisabled && resendTimer > 0) {
      interval = setInterval(() => {
        setResendTimer((prev) => Math.max(0, prev - 1));
      }, 1000);
    } else if (resendTimer === 0 && resendDisabled) {
      setResendDisabled(false);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [resendDisabled, resendTimer]);

  const startResendTimer = useCallback(() => {
    setResendDisabled(true);
    setResendTimer(60);
  }, []);
  // --- End Resend Timer Logic ---

  // --- Input Handling (Focus and Backspace) ---
  const handleInputChange = useCallback(
    (index: number, value: string) => {
      if (!/^\d*$/.test(value)) return;

      const newCode = [...code];
      newCode[index] = value.slice(-1);
      setCode(newCode);

      if (value && index < OTP_LENGTH - 1 && inputRefs.current[index + 1]) {
        inputRefs.current[index + 1]?.focus();
      }
    },
    [code]
  );

  const handleKeyDown = useCallback(
    (index: number, e: React.KeyboardEvent<HTMLInputElement>) => {
      if (
        e.key === "Backspace" &&
        !code[index] &&
        index > 0 &&
        inputRefs.current[index - 1]
      ) {
        inputRefs.current[index - 1]?.focus();
      }
    },
    [code]
  );

  useEffect(() => {
    if (inputRefs.current[0]) {
      inputRefs.current[0]?.focus();
    }
  }, []);
  // --- End Input Handling ---

  // --- API Calls ---
  const handleVerifyCode = useCallback(
    async (e: FormEvent) => {
      e.preventDefault();
      setError(null);
      setVerifySuccessMessage(null);
      setResendInfoMessage(null); // Clear resend info message as well

      const otp = code.join("");
      if (otp.length !== OTP_LENGTH) {
        setError(`אנא הזן את הקוד בן ${OTP_LENGTH} הספרות במלואו.`);
        return;
      }

      setIsLoading(true);
      try {
        console.log("[VerifyPhonePage] Verifying code:", otp);
        const response = await fetch("/api/auth/verify-phone-code", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ code: otp }),
        });

        const result = await response.json();

        if (!response.ok) {
          throw new Error(result.error || "אימות הקוד נכשל. אנא נסה שנית.");
        }

        console.log(
          "[VerifyPhonePage] Code verified successfully. Result:",
          result
        );
        setVerifySuccessMessage("מספר הטלפון אומת בהצלחה! מעדכן את הפרופיל שלך...");

        console.log(
          "[VerifyPhonePage] Current session before update:",
          session
        );
        await updateSession({
          isPhoneVerified: true,
          isProfileComplete: true,
          status: "ACTIVE",
        });
        console.log(
          "[VerifyPhonePage] Session update initiated. Performing full page redirect to /profile."
        );

        window.location.href = "/profile";
      } catch (err: unknown) {
        const errorMessage =
          err instanceof Error
            ? err.message
            : "אירעה שגיאה בלתי צפויה במהלך האימות.";
        console.error(
          "[VerifyPhonePage] Error during verification:",
          errorMessage,
          err
        );
        setError(errorMessage);
        setCode(new Array(OTP_LENGTH).fill(""));
        if (inputRefs.current[0]) inputRefs.current[0]?.focus();
        setIsLoading(false);
      }
    },
    [code, updateSession, session]
  );

  const handleResendCode = useCallback(async () => {
    if (resendDisabled || isResending) return;
    setError(null);
    setVerifySuccessMessage(null); // Clear main success message
    setResendInfoMessage(null); // Clear previous resend info
    setIsResending(true);

    try {
      console.log("[VerifyPhonePage] Resending code...");
      const response = await fetch("/api/auth/resend-phone-code", {
        method: "POST",
      });
      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "שליחת קוד חדש נכשלה.");
      }

      setResendInfoMessage("קוד חדש נשלח אליך באמצעות WhatsApp."); // Use new state for info
      startResendTimer();
    } catch (err: unknown) {
      const errorMessage =
        err instanceof Error
          ? err.message
          : "אירעה שגיאה בלתי צפויה בעת שליחת קוד חדש.";
      setError(errorMessage);
    } finally {
      setIsResending(false);
    }
  }, [isResending, resendDisabled, startResendTimer]);
  // --- End API Calls ---

  // --- Session Handling ---
  useEffect(() => {
    console.log(
      "[VerifyPhonePage] Session useEffect triggered. Status:",
      sessionStatus,
      "Session:",
      session
    );

    if (sessionStatus === "authenticated") {
      if (session?.user?.isPhoneVerified && session?.user?.isProfileComplete) {
        if (window.location.pathname === "/auth/verify-phone") {
          console.log(
            "[VerifyPhonePage] User already verified and on verify-phone page. Redirecting to /profile via router.push."
          );
          router.push("/profile");
        }
      } else if (session?.user && !session.user.isPhoneVerified) {
        console.log(
          "[VerifyPhonePage] Authenticated, but phone not yet verified. User should stay on this page."
        );
      }
    } else if (sessionStatus === "unauthenticated") {
      console.log("[VerifyPhonePage] Unauthenticated. Redirecting to signin.");
      router.push("/auth/signin?callbackUrl=/auth/verify-phone");
    }
  }, [sessionStatus, session, router]);

  // --- Loading State ---
  if (sessionStatus === "loading") {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
        <div className="flex items-center">
          <Loader2 className="h-8 w-8 animate-spin text-cyan-600" />
          <span className="ml-2 text-gray-700">טוען נתונים...</span>
        </div>
      </div>
    );
  }
  // --- End Loading State ---

  // --- Helper Function for Displaying Phone ---
  const getHiddenPhone = () => {
    const phone = session?.user?.phone;
    if (!phone) return "הטלפון שלך";
    if (phone.length >= 10) {
      return `${phone.substring(0, 3)}••••${phone.substring(phone.length - 3)}`;
    }
    return "הטלפון שלך";
  };
  // --- End Helper Function ---

  // --- Render Component ---
  const disableFormInputsAndVerifyButton = isLoading || !!verifySuccessMessage;
  const disableResendButton = isResending || resendDisabled || !!verifySuccessMessage;


  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
      <div className="w-full max-w-md bg-white rounded-xl shadow-xl p-6 sm:p-8 space-y-6 text-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-800">אימות מספר טלפון</h1>
          <p className="text-gray-600 mt-2 text-sm sm:text-base">
            כמעט סיימנו! שלחנו קוד בן {OTP_LENGTH} ספרות באמצעות WhatsApp למספר{" "}
            <span className="font-medium text-gray-700">
              {getHiddenPhone()}
            </span>
            .
            <br />
            הזן/י אותו להשלמת ההרשמה.
          </p>
        </div>
        
        {error && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        {!error && verifySuccessMessage && (
          <Alert
            variant="default"
            className="bg-green-50 border-green-200 text-green-700"
          >
            <CheckCircle className="h-4 w-4 text-green-600" />
            <AlertTitle>הצלחה</AlertTitle>
            <AlertDescription>{verifySuccessMessage}</AlertDescription>
          </Alert>
        )}
        {!error && !verifySuccessMessage && resendInfoMessage && (
          <Alert
            variant="default"
            className="bg-green-50 border-green-200 text-green-700" // Reusing success style for info
          >
            <CheckCircle className="h-4 w-4 text-green-600" /> {/* Or a different icon like Info if preferred */}
            <AlertTitle>הודעה</AlertTitle>
            <AlertDescription>{resendInfoMessage}</AlertDescription>
          </Alert>
        )}

        <form onSubmit={handleVerifyCode} className="space-y-6">
          <div className="flex justify-center gap-2 sm:gap-3" dir="ltr">
            {code.map((digit, index) => (
              <Input
                key={index}
                ref={(el: HTMLInputElement | null) => {
                  inputRefs.current[index] = el;
                }}
                type="text"
                inputMode="numeric"
                pattern="\d{1}"
                maxLength={1}
                value={digit}
                onChange={(e) => handleInputChange(index, e.target.value)}
                onKeyDown={(e) => handleKeyDown(index, e)}
                className="w-10 h-12 sm:w-12 sm:h-14 text-center text-xl sm:text-2xl font-semibold border-2 border-gray-300 focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500 rounded-md shadow-sm transition-colors disabled:opacity-50 disabled:bg-gray-100"
                disabled={disableFormInputsAndVerifyButton}
                required
                aria-label={`ספרה ${index + 1}`}
              />
            ))}
          </div>

          <Button
            type="submit"
            disabled={
              disableFormInputsAndVerifyButton ||
              code.join("").length !== OTP_LENGTH
            }
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 text-white"
          >
            {isLoading ? (
              <Loader2 className="animate-spin h-5 w-5 mx-auto" />
            ) : (
              "אימות קוד"
            )}
          </Button>
        </form>
        <div className="text-sm text-gray-600 space-y-2">
          <div>
            לא קיבלת את הקוד?{" "}
            <Button
              type="button"
              variant="link"
              onClick={handleResendCode}
              disabled={disableResendButton}
              className="p-0 h-auto text-cyan-600 hover:text-cyan-700 disabled:text-gray-400 disabled:no-underline"
            >
              {isResending
                ? "שולח שוב..."
                : resendDisabled
                ? `שלח קוד חדש (${resendTimer} שניות)`
                : "שלח קוד חדש"}
            </Button>
          </div>
          <div>
            <Link
              href="/auth/update-phone"
              className={`text-cyan-600 hover:text-cyan-700 hover:underline ${
                disableFormInputsAndVerifyButton // Use the more specific disabling logic
                  ? "pointer-events-none text-gray-400"
                  : ""
              }`}
              aria-disabled={disableFormInputsAndVerifyButton}
              tabIndex={disableFormInputsAndVerifyButton ? -1 : undefined}
            >
              האם מספר הטלפון שגוי?
            </Link>
          </div>
        </div>
        <div className="mt-4 border-t border-gray-200 pt-4">
          <Link
            href="/auth/signin"
            className={`text-xs text-gray-500 hover:text-gray-600 ${
              disableFormInputsAndVerifyButton // Use the more specific disabling logic
                ? "pointer-events-none opacity-50"
                : ""
            }`}
            aria-disabled={disableFormInputsAndVerifyButton}
            tabIndex={disableFormInputsAndVerifyButton ? -1 : undefined}
          >
            חזרה להתחברות
          </Link>
        </div>
      </div>
    </div>
  );
};

export default VerifyPhonePage;
--- End of Content for page.tsx ---

--- End of Content for auth_contents.txt ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\error
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\error\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useSearchParams } from "next/navigation";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";

export default function ErrorPage() {
  const searchParams = useSearchParams();
  const error = searchParams.get("error");
  const router = useRouter();

  const getErrorMessage = (error: string) => {
    switch (error) {
      case "Signin":
        return "נסה להתחבר שוב";
      case "OAuthSignin":
        return "נסה להתחבר שוב";
      case "OAuthCallback":
        return "שגיאה בתהליך ההתחברות";
      case "OAuthCreateAccount":
        return "שגיאה ביצירת החשבון";
      case "EmailCreateAccount":
        return "שגיאה ביצירת החשבון";
      case "Callback":
        return "שגיאה בתהליך ההתחברות";
      case "OAuthAccountNotLinked":
        return "החשבון כבר מקושר למשתמש אחר";
      case "EmailSignin":
        return "בדוק את תיבת הדואר שלך";
      case "CredentialsSignin":
        return "פרטי ההתחברות שגויים";
      default:
        return "שגיאה בתהליך ההתחברות";
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl font-bold text-red-600">
            שגיאה
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <p className="text-gray-600">
            {error ? getErrorMessage(error) : "שגיאה לא ידועה"}
          </p>
          <Button
            onClick={() => router.push("/auth/signin")}
            className="w-full"
          >
            חזרה לדף ההתחברות
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\forgot-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\forgot-password\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/auth/forgot-password/page.tsx
import ForgotPasswordForm from "@/app/components/auth/ForgotPasswordForm";
import { ArrowLeft } from "lucide-react"; // Assuming you use lucide-react
import Link from "next/link";

export default function ForgotPasswordPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 sm:p-8">
        <Link
            href="/"
            className="absolute top-4 left-4 rtl:right-4 rtl:left-auto text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm z-20"
        >
            <ArrowLeft className="h-4 w-4 transform rtl:rotate-180" /> {/* Corrected for RTL if needed */}
            חזרה לדף הבית
        </Link>
      <ForgotPasswordForm />
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\register\page.tsx
--------------------------------------------------------------------------------
Content:
import RegisterSteps from "@/app/components/auth/RegisterSteps";

export default function RegisterPage() {
  return <RegisterSteps />;
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\reset-password\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/auth/reset-password/page.tsx
import ResetPasswordForm from "@/app/components/auth/ResetPasswordForm";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Suspense } from "react"; // Import Suspense

// A wrapper component to allow useSearchParams in a Client Component
function ResetPasswordPageContent() {
    return <ResetPasswordForm />;
}

export default function ResetPasswordPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 sm:p-8">
      <Link
        href="/"
        className="absolute top-4 left-4 rtl:right-4 rtl:left-auto text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm z-20"
      >
        <ArrowLeft className="h-4 w-4 transform rtl:rotate-180" />
        חזרה לדף הבית
      </Link>
      {/* Wrap the client component that uses useSearchParams with Suspense */}
      <Suspense fallback={<div>טוען...</div>}>
        <ResetPasswordPageContent />
      </Suspense>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\setup-account
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\setup-account\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/auth/setup-account/page.tsx
"use client";

import React, { useState, useEffect, Suspense } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { toast } from 'sonner';
import { Loader2, KeyRound, CheckCircle } from "lucide-react";

function SetupAccountForm() {
  const searchParams = useSearchParams();
  const router = useRouter(); 
  
  const [token, setToken] = useState<string | null>(null);
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);

  useEffect(() => {
    const tokenFromUrl = searchParams.get('token');
    if (tokenFromUrl) {
      setToken(tokenFromUrl);
    } else {
      setError("קישור הגדרת החשבון אינו תקין או חסר. אנא השתמש בקישור שנשלח אליך במייל.");
    }
  }, [searchParams]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    if (password.length < 8) {
      setError("הסיסמה חייבת להכיל לפחות 8 תווים.");
      return;
    }
    if (password !== confirmPassword) {
      setError("הסיסמאות אינן תואמות.");
      return;
    }
    
    setIsLoading(true);

    try {
      const response = await fetch('/api/auth/complete-setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token, password }),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.error || 'שגיאה בהגדרת החשבון.');
      }

      setSuccess(true);
      toast.success("החשבון הוגדר בהצלחה! הנך מועבר/ת להשלמת הפרופיל.");

      // --- START: התיקון המרכזי ---
      // נשתמש ב-window.location.assign כדי לכפות רענון מלא והפניה.
      // זה מבטיח שה-Middleware יקבל את הסשן המעודכן ביותר.
      // נוסיף השהיה קטנה כדי שהמשתמש יראה את הודעת ההצלחה.
      setTimeout(() => {
        window.location.assign('/profile'); 
      }, 1500); // 1.5 שניות
      // --- END: התיקון המרכזי ---

    } catch (err) {
      setError(err instanceof Error ? err.message : 'אירעה שגיאה בלתי צפויה.');
      setIsLoading(false); 
    }
  };
  
  if (success) {
    return (
        <Card className="w-full max-w-md mx-auto text-center">
            <CardHeader>
                <div className="mx-auto bg-green-100 rounded-full p-3 w-fit">
                    <CheckCircle className="h-10 w-10 text-green-600" />
                </div>
                <CardTitle className="mt-4">החשבון הוגדר בהצלחה!</CardTitle>
            </CardHeader>
            <CardContent>
                <p className="text-muted-foreground">הסיסמה נקבעה. הנך מועבר/ת אוטומטית לשלב הבא של השלמת הפרופיל.</p>
                <Loader2 className="mt-4 h-6 w-6 animate-spin mx-auto" />
            </CardContent>
        </Card>
    );
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>הגדרת חשבון וקביעת סיסמה</CardTitle>
        <CardDescription>
          שלב אחרון לפני שתוכל/י להתחיל. אנא בחר/י סיסמה לחשבונך.
        </CardDescription>
      </CardHeader>
      <CardContent>
        {!token ? (
            <div className="text-red-500 text-center p-4 bg-red-50 rounded-md">{error}</div>
        ) : (
            <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <Label htmlFor="password">סיסמה חדשה</Label>
                <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                />
                <p className="text-xs text-muted-foreground mt-1">לפחות 8 תווים, כולל אותיות ומספרים.</p>
            </div>
            <div>
                <Label htmlFor="confirmPassword">אישור סיסמה</Label>
                <Input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                />
            </div>
            {error && <p className="text-sm font-medium text-destructive">{error}</p>}
             <CardFooter className="p-0 pt-4">
                 <Button type="submit" className="w-full" disabled={isLoading}>
                    {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <KeyRound className="mr-2 h-4 w-4" />}
                    {isLoading ? 'מגדיר סיסמה...' : 'הגדר סיסמה והמשך'}
                </Button>
            </CardFooter>
            </form>
        )}
      </CardContent>
    </Card>
  );
}

// Suspense Boundary for useSearchParams
export default function SetupAccountPage() {
    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4">
            <Suspense fallback={<Loader2 className="h-8 w-8 animate-spin" />}>
                <SetupAccountForm />
            </Suspense>
        </div>
    );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\signin
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\signin\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { signIn } from "next-auth/react";
import { useSession } from "next-auth/react";
import { SessionProvider } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Mail, Lock, AlertCircle, ArrowLeft } from "lucide-react";
import Link from "next/link";

// Signin form component
const SignInForm = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { data: session, status } = useSession();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);

  // Get error message from URL if exists
  useEffect(() => {
    const errorMessage = searchParams.get("error");
    if (errorMessage) {
      switch (errorMessage) {
        case "CredentialsSignin":
          setError("אימייל או סיסמה אינם נכונים");
          break;
        default:
          setError("אירעה שגיאה, נסה שנית");
      }
    }
  }, [searchParams]);

  // If user is already logged in, redirect to profile
  useEffect(() => {
    if (session?.user) {
      router.push("/profile");
    }
  }, [session, router]);

  // Handle email/password sign in
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!email || !password) {
      setError("אנא הזן אימייל וסיסמה");
      return;
    }

    try {
      setError("");
      setIsLoading(true);

      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("אימייל או סיסמה אינם נכונים");
        console.error("Sign-in error:", result.error);
      } else {
        router.push("/profile");
      }
    } catch (err) {
      console.error("Unexpected sign-in error:", err);
      setError("אירעה שגיאה בהתחברות, נסה שנית");
    } finally {
      setIsLoading(false);
    }
  };

  // Handle Google sign in
 const handleGoogleSignIn = async () => {
    try {
      setIsGoogleLoading(true);
      setError("");

      // Store this information for potential fallback
      localStorage.setItem("signin_started", "true");

      // NextAuth will handle the redirect. The 'redirect' callback in authOptions will determine the final destination.
      // --- START: התיקון ---
      await signIn("google"); // הסרנו את callbackUrl
      // --- END: התיקון ---
    } catch (error) {
      console.error("Google sign-in error:", error);
      setError("אירעה שגיאה בהתחברות עם גוגל");
      setIsGoogleLoading(false);
    }
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
        <div className="mb-4 w-16 h-16 border-4 border-t-4 border-cyan-500 border-t-pink-500 rounded-full animate-spin"></div>
        <h2 className="text-xl font-medium text-gray-700">טוען...</h2>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
      {/* Back to home button */}
      <button
        onClick={() => router.push("/")}
        className="absolute top-4 left-4 text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm"
      >
        <ArrowLeft className="h-4 w-4" />
        חזרה לדף הבית
      </button>

      <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
        {/* Decorative elements */}
        <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>

        <div className="p-6 sm:p-8">
          <div className="text-center mb-6">
            <h1 className="text-2xl font-bold text-gray-800 mb-2">
              התחברות למערכת
            </h1>
            <p className="text-gray-600">
              ברוכים השבים! המשיכו למצוא את השידוך המושלם
            </p>
          </div>

          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg flex items-center gap-2">
              <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0" />
              <p className="text-red-600 text-sm">{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-4 mb-6">
            <div className="space-y-1">
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700"
              >
                אימייל
              </label>
              <div className="relative">
                <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <input
                  type="email"
                  id="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  placeholder="you@example.com"
                />
              </div>
            </div>

            <div className="space-y-1">
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700"
              >
                סיסמה
              </label>
              <div className="relative">
                <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <input
                  type="password"
                  id="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  placeholder="הסיסמה שלך"
                />
              </div>
              <div className="flex justify-end">
                <Link
                  href="/auth/forgot-password"
                  className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline mt-1"
                >
                  שכחת סיסמה?
                </Link>
              </div>
            </div>

            <Button
              type="submit"
              disabled={isLoading}
              className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2 relative overflow-hidden"
            >
              {isLoading ? (
                <>
                  <div className="h-4 w-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                  מתחבר...
                </>
              ) : (
                <>
                  {/* Button shimmer effect */}
                  <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
                  <span>התחברות</span>
                </>
              )}
            </Button>
          </form>

          <div className="relative mb-6">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">או</span>
            </div>
          </div>

          <Button
            onClick={handleGoogleSignIn}
            disabled={isGoogleLoading}
            variant="outline"
            size="lg"
            className="w-full relative border-2 border-gray-300 hover:border-gray-400 py-3 rounded-xl flex items-center justify-center gap-3 group"
          >
            {isGoogleLoading ? (
              <div className="animate-spin h-5 w-5 border-2 border-gray-500 rounded-full border-t-transparent" />
            ) : (
              <>
                <svg className="h-5 w-5" viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                    fill="#4285F4"
                  />
                  <path
                    d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                    fill="#34A853"
                  />
                  <path
                    d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                    fill="#FBBC05"
                  />
                  <path
                    d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                    fill="#EA4335"
                  />
                </svg>
                <span className="text-gray-700 font-medium">
                  התחברות עם Google
                </span>
              </>
            )}
          </Button>

          <div className="mt-6 text-center">
            <p className="text-gray-600 text-sm">
              אין לך חשבון עדיין?{" "}
              <Link
                href="/auth/register"
                className="text-cyan-600 font-medium hover:text-cyan-700 hover:underline"
              >
                הרשמה עכשיו
              </Link>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

// Export the page with provider
export default function SignInPage() {
  return (
    <SessionProvider>
      <SignInForm />
    </SessionProvider>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\update-phone
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\update-phone\page.tsx
--------------------------------------------------------------------------------
Content:
// app/auth/update-phone/page.tsx
'use client';

import { useState, useCallback } from 'react'; // Added useCallback
import { useRouter } from 'next/navigation';
import { useSession } from 'next-auth/react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { AlertCircle, Loader2, Phone } from 'lucide-react';
import Link from 'next/link';

const UpdatePhonePage = () => {
    const router = useRouter();
    const { status: sessionStatus } = useSession();
    const [newPhone, setNewPhone] = useState('');
    const [error, setError] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const handleSubmit = useCallback(async (e: React.FormEvent) => {
        e.preventDefault(); // Prevent default form submission
        setError(null); // Clear previous errors

        // Basic phone number format validation
        if (!/^0\d{9}$/.test(newPhone)) {
            setError("פורמט מספר הטלפון אינו תקין (לדוגמה: 0501234567).");
            return;
        }

        setIsLoading(true);
        try {
            const response = await fetch('/api/auth/update-and-resend-code', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ newPhone }),
            });

            const result = await response.json();

            if (!response.ok) {
                // Use error message from API if available
                throw new Error(result.error || 'עדכון מספר הטלפון נכשל.');
            }

            // Success! Redirect back to the verification page to enter the new code
            console.log("Phone updated, redirecting back to verify page.");
            router.push('/auth/verify-phone');

        } catch (err: unknown) { // Catch error as unknown
             // Type check the error before accessing properties
             if (err instanceof Error) {
                 setError(err.message);
             } else {
                 setError('אירעה שגיאה בלתי צפויה בעת עדכון מספר הטלפון.');
             }
        } finally {
            setIsLoading(false); // Stop loading indicator
        }
    }, [newPhone, router]); // Dependencies for useCallback

    // --- Session Handling & Loading State ---
    if (sessionStatus === 'loading') {
        return (
             <div className="min-h-screen flex items-center justify-center">
                 <Loader2 className="h-8 w-8 animate-spin text-cyan-600" />
                 <span className="ml-2">טוען נתונים...</span>
             </div>
         );
    }
     if (sessionStatus === 'unauthenticated') {
         // If user somehow gets here unauthenticated, redirect to signin
         router.push('/auth/signin?callbackUrl=/auth/update-phone');
         return null; // Return null while redirecting
    }
    // --- End Session Handling ---


    // --- Render Component ---
    return (
        <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
            <div className="w-full max-w-sm bg-white rounded-xl shadow-xl p-6 sm:p-8 space-y-6"> {/* Adjusted padding */}
                <div className="text-center">
                    <h1 className="text-2xl font-bold text-gray-800">עדכון מספר טלפון</h1>
                    <p className="text-gray-600 mt-2 text-sm sm:text-base"> {/* Adjusted text size */}
                        הזן/י את מספר הטלפון הנכון שלך.
                        <br />קוד אימות חדש יישלח אליו באמצעות WhatsApp.
                    </p>
                </div>

                {/* Error Alert */}
                {error && (
                    <Alert variant="destructive">
                        <AlertCircle className="h-4 w-4" />
                        <AlertTitle>שגיאה</AlertTitle>
                        <AlertDescription>{error}</AlertDescription>
                    </Alert>
                )}

                {/* Update Phone Form */}
                <form onSubmit={handleSubmit} className="space-y-4">
                    <div>
                        <label htmlFor="phone" className="block text-sm font-medium text-gray-700 mb-1 text-right">
                            מספר טלפון חדש
                        </label>
                         <div className="relative">
                            {/* Icon on the right for RTL */}
                            <Phone className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5 pointer-events-none" />
                            <Input
                                type="tel" // Use tel type for better mobile experience
                                id="phone"
                                name="phone"
                                value={newPhone}
                                onChange={(e) => setNewPhone(e.target.value)}
                                placeholder="0501234567"
                                className="w-full pr-10 pl-3 py-2 border border-gray-300 rounded-md focus:ring-cyan-500 focus:border-cyan-500 shadow-sm text-right" // Added text-right
                                required
                                disabled={isLoading}
                                dir="ltr" // Keep input direction LTR for phone numbers
                                autoComplete="tel" // Add autocomplete hint
                            />
                         </div>
                    </div>

                    <Button type="submit" disabled={isLoading} className="w-full py-3"> {/* Added py-3 */}
                        {isLoading ? <Loader2 className="animate-spin h-5 w-5" /> : 'עדכן ושלח קוד חדש'}
                    </Button>
                </form>

                 {/* Link back to Verification Page */}
                 <div className="text-center mt-4">
                     <Link href="/auth/verify-phone" className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline">
                         חזרה לאימות קוד
                     </Link>
                 </div>
            </div>
        </div>
    );
};

export default UpdatePhonePage;
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-email\page.tsx
--------------------------------------------------------------------------------
Content:
// /auth/verify-email/page.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useSession } from "next-auth/react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2 } from "lucide-react";

interface VerificationState {
  status: "pending" | "verifying" | "success" | "error";
  message: string;
}

export default function VerifyEmailPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { data: session } = useSession();

  const navigationTimeoutIdRef = useRef<NodeJS.Timeout | null>(null);

  // Ref to ensure the API call logic runs only once after the component has "settled" from StrictMode effects.
  const verificationApiCallMadeRef = useRef(false);

  const [verification, setVerification] = useState<VerificationState>({
    status: "pending",
    message: "",
  });

  const [isResending, setIsResending] = useState(false);

  const handleResendVerification = async () => {
    // ... (same as before)
    const emailFromQuery = searchParams.get("email");
    if (!emailFromQuery) {
      setVerification({
        status: "error",
        message: "לא ניתן לשלוח מחדש ללא כתובת אימייל.",
      });
      return;
    }
    setIsResending(true);
    setVerification({ status: "pending", message: "" });
    try {
      const response = await fetch("/api/auth/resend-verification", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: emailFromQuery, type: "EMAIL" }),
      });
      const data = await response.json();
      if (!response.ok)
        throw new Error(data.error || "שגיאה בשליחת מייל האימות מחדש");
      setVerification({
        status: "pending",
        message: "מייל אימות חדש נשלח בהצלחה. אנא בדוק את תיבת הדואר.",
      });
    } catch (error) {
      setVerification({
        status: "error",
        message:
          error instanceof Error
            ? error.message
            : "שגיאה בשליחת מייל האימות מחדש",
      });
    } finally {
      setIsResending(false);
    }
  };

  useEffect(() => {
    let isEffectMounted = true; // Tracks if the current effect instance is still mounted
    const controller = new AbortController();

    const processVerification = async () => {
      if (verificationApiCallMadeRef.current) {
        console.log(
          "VerifyEmailPage: API call already made or in progress, skipping."
        );
        return;
      }
      verificationApiCallMadeRef.current = true; // Mark that we are making the call

      const rawTokenParam = searchParams.get("token");
      const emailFromQuery = searchParams.get("email");
      let actualToken: string | null = null;

      console.log("VerifyEmailPage: Raw token from URL:", rawTokenParam);
      if (rawTokenParam) {
        // ... (token extraction logic)
        if (
          rawTokenParam.includes("://") &&
          rawTokenParam.includes("?token=")
        ) {
          try {
            const nestedUrl = new URL(rawTokenParam);
            actualToken = nestedUrl.searchParams.get("token");
            console.log(
              "VerifyEmailPage: Extracted token from nested URL:",
              actualToken
            );
          } catch (error) {
            console.warn(
              "VerifyEmailPage: Could not parse rawTokenParam as a URL:",
              rawTokenParam,
              error
            );
            actualToken = rawTokenParam;
          }
        } else {
          actualToken = rawTokenParam;
          console.log(
            "VerifyEmailPage: Using raw token directly:",
            actualToken
          );
        }
      }

      if (!actualToken) {
        if (emailFromQuery) {
          console.log(
            "VerifyEmailPage: No token, but email found. Setting to pending."
          );
          if (isEffectMounted)
            setVerification({
              status: "pending",
              message: "שלחנו מייל אימות לכתובת:",
            });
        } else {
          console.log(
            "VerifyEmailPage: No token and no email. Setting to error."
          );
          if (isEffectMounted)
            setVerification({
              status: "error",
              message: "קישור האימות אינו תקין (חסר מידע נדרש).",
            });
        }
        return; // Stop further processing
      }

      if (isEffectMounted)
        setVerification({ status: "verifying", message: "" });
      console.log(
        "VerifyEmailPage: ==> Attempting API verification for token:",
        actualToken
      );

      // Session check
      if (
        session?.user?.email &&
        emailFromQuery &&
        session.user.email !== emailFromQuery
      ) {
        console.warn(
          "VerifyEmailPage: User logged in with different email. Aborting."
        );
        if (isEffectMounted)
          setVerification({
            status: "error",
            message:
              "אתה מחובר עם חשבון מייל אחר. אנא התנתק ונסה שוב את הלינק.",
          });
        return;
      }

      try {
        const response = await fetch("/api/auth/verify", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: actualToken, type: "EMAIL" }),
          signal: controller.signal,
        });

        let data;
        try {
          data = await response.json();
        } catch (jsonError) {
          console.error(
            "VerifyEmailPage (API): Failed to parse JSON response.",
            jsonError
          );
          if (response.ok && response.status !== 204)
            throw new Error("תגובה לא תקינה מהשרת (JSON parsing failed).");
          else if (!response.ok)
            throw new Error("תגובה לא תקינה מהשרת במהלך האימות.");
        }

        if (controller.signal.aborted) {
          console.log("VerifyEmailPage (API): Fetch aborted by cleanup.");
          return;
        }

        if (!response.ok) {
          const errorMessage =
            data?.error || `שגיאה באימות החשבון (סטטוס ${response.status})`;
          throw new Error(errorMessage);
        }

        console.log("VerifyEmailPage (API): Verification successful.");
        if (isEffectMounted) {
          setVerification({
            status: "success",
            message: "החשבון אומת בהצלחה!",
          });
          navigationTimeoutIdRef.current = setTimeout(() => {
            if (isEffectMounted) {
              // Check mount status again before navigating
              console.log("VerifyEmailPage: Navigating now to /auth/signin.");
              router.push("/auth/signin");
            } else {
              console.log(
                "VerifyEmailPage: Effect unmounted before navigation timeout."
              );
            }
          }, 1500);
        }
      } catch (error: unknown) {
        if (controller.signal.aborted) {
          // Check if the error is due to our own abort
          console.log(
            "VerifyEmailPage (API) [catch]: Fetch aborted by controller during operation."
          );
        } else if (isEffectMounted) {
          console.error(
            "VerifyEmailPage (API) [catch]: Error during API verification:",
            error
          );
          let errorMessage = "שגיאה באימות החשבון";
          if (error instanceof Error) {
            if (error.message.includes("הטוקן כבר נוצל"))
              errorMessage =
                "הטוקן הזה כבר נוצל לאימות. אם נרשמת בהצלחה, נסה להתחבר.";
            else if (error.message.includes("תוקף הטוקן פג"))
              errorMessage =
                "תוקף קישור האימות פג. אנא נסה לשלוח מייל אימות מחדש.";
            else if (error.message.includes("תגובה לא תקינה מהשרת"))
              errorMessage = error.message;
            else errorMessage = error.message;
          } else {
            errorMessage = "אירעה שגיאה לא צפויה במהלך האימות.";
          }
          setVerification({ status: "error", message: errorMessage });
        }
      }
    };

    processVerification();

    return () => {
      console.log(
        "VerifyEmailPage (useEffect cleanup): Cleaning up. Aborting API call."
      );
      isEffectMounted = false; // Mark that this effect instance is being cleaned up
      controller.abort();
      if (navigationTimeoutIdRef.current) {
        clearTimeout(navigationTimeoutIdRef.current);
        console.log(
          "VerifyEmailPage (useEffect cleanup): Cleared navigation timeout."
        );
      }
      // Do NOT reset verificationApiCallMadeRef.current here.
      // It should ensure the logic runs only once per component true lifecycle.
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, router, session]); // Dependencies

  // ... (JSX remains the same)
  return (
    <div className="min-h-screen flex items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardContent className="p-6 space-y-4">
          {verification.status === "pending" && (
            <div className="text-center space-y-4">
              <h2 className="text-xl font-semibold">אימות חשבון</h2>
              {verification.message && (
                <Alert
                  variant="default"
                  className="text-sm text-center bg-blue-50 border-blue-200 text-blue-800"
                >
                  <AlertDescription>
                    {verification.message ||
                      (searchParams.get("email")
                        ? "שלחנו מייל אימות לכתובת:"
                        : "טוען מידע...")}
                  </AlertDescription>
                </Alert>
              )}
              {!verification.message && searchParams.get("email") && (
                <p>שלחנו מייל אימות לכתובת:</p>
              )}
              <p className="font-medium">
                {searchParams.get("email") || "לא צוינה כתובת"}
              </p>
              <p>אנא בדקו את תיבת הדואר שלכם ולחצו על הקישור לאימות החשבון.</p>
              {searchParams.get("email") && (
                <Button
                  onClick={handleResendVerification}
                  disabled={isResending}
                  className="mt-4"
                >
                  {isResending ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" /> שולח
                      מייל חדש...
                    </>
                  ) : (
                    "שלח מייל אימות מחדש"
                  )}
                </Button>
              )}
            </div>
          )}
          {verification.status === "verifying" && (
            <div className="flex flex-col items-center space-y-4">
              <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
              <p className="text-gray-600">מאמת את החשבון...</p>
            </div>
          )}
          {verification.status === "success" && (
            <div className="text-center space-y-4">
              <h2 className="text-xl font-semibold text-green-600">
                {verification.message}
              </h2>
              <p className="text-gray-600">
                החשבון אומת בהצלחה. מעביר אותך להתחברות...
              </p>
              <Loader2 className="h-6 w-6 animate-spin mx-auto mt-4 text-gray-400" />
            </div>
          )}
          {verification.status === "error" && (
            <div className="space-y-4">
              <Alert variant="destructive">
                <AlertDescription>{verification.message}</AlertDescription>
              </Alert>
              {searchParams.get("email") &&
                !verification.message.includes("הטוקן הזה כבר נוצל") &&
                !verification.message.includes("מחובר עם חשבון מייל אחר") &&
                (verification.message.includes("תוקף קישור האימות פג") ||
                  verification.message.includes(
                    "שגיאה בשליחת מייל האימות מחדש"
                  ) ||
                  (verification.message.includes("שגיאה באימות החשבון") &&
                    !verification.message.includes(
                      "פורמט קישור האימות אינו תקין"
                    ) &&
                    !verification.message.includes("תגובה לא תקינה מהשרת")) ||
                  verification.message.includes("תגובה לא תקינה מהשרת")) && (
                  <div className="flex justify-center">
                    <Button
                      onClick={handleResendVerification}
                      disabled={isResending}
                      variant="outline"
                      className="mt-2"
                    >
                      {isResending ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" /> שולח
                          מייל חדש...
                        </>
                      ) : (
                        "נסה לשלוח מייל אימות מחדש"
                      )}
                    </Button>
                  </div>
                )}
              <div className="flex justify-center mt-4">
                <Button onClick={() => router.push("/auth/signin")}>
                  חזור לדף ההתחברות
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-phone
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\auth\verify-phone\page.tsx
--------------------------------------------------------------------------------
Content:
// app/auth/verify-phone/page.tsx
"use client";

import { useState, useEffect, useRef, useCallback, FormEvent } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, Loader2, CheckCircle } from "lucide-react"; // Mail or Info icon could be added if needed
import Link from "next/link";

const OTP_LENGTH = 6;

const VerifyPhonePage = () => {
  const router = useRouter();
  const {
    data: session,
    status: sessionStatus,
    update: updateSession,
  } = useSession();
  const [code, setCode] = useState<string[]>(new Array(OTP_LENGTH).fill(""));
  const [error, setError] = useState<string | null>(null);
  const [verifySuccessMessage, setVerifySuccessMessage] = useState<string | null>(null); // Renamed from successMessage
  const [resendInfoMessage, setResendInfoMessage] = useState<string | null>(null); // New state for resend info
  const [isLoading, setIsLoading] = useState(false); // For verify code submission
  const [isResending, setIsResending] = useState(false); // For resend code submission
  const [resendDisabled, setResendDisabled] = useState(false);
  const [resendTimer, setResendTimer] = useState(0);
  const inputRefs = useRef<(HTMLInputElement | null)[]>([]);

  // --- Resend Timer Logic ---
  useEffect(() => {
    let interval: NodeJS.Timeout | null = null;
    if (resendDisabled && resendTimer > 0) {
      interval = setInterval(() => {
        setResendTimer((prev) => Math.max(0, prev - 1));
      }, 1000);
    } else if (resendTimer === 0 && resendDisabled) {
      setResendDisabled(false);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [resendDisabled, resendTimer]);

  const startResendTimer = useCallback(() => {
    setResendDisabled(true);
    setResendTimer(60);
  }, []);
  // --- End Resend Timer Logic ---

  // --- Input Handling (Focus and Backspace) ---
  const handleInputChange = useCallback(
    (index: number, value: string) => {
      if (!/^\d*$/.test(value)) return;

      const newCode = [...code];
      newCode[index] = value.slice(-1);
      setCode(newCode);

      if (value && index < OTP_LENGTH - 1 && inputRefs.current[index + 1]) {
        inputRefs.current[index + 1]?.focus();
      }
    },
    [code]
  );

  const handleKeyDown = useCallback(
    (index: number, e: React.KeyboardEvent<HTMLInputElement>) => {
      if (
        e.key === "Backspace" &&
        !code[index] &&
        index > 0 &&
        inputRefs.current[index - 1]
      ) {
        inputRefs.current[index - 1]?.focus();
      }
    },
    [code]
  );

  useEffect(() => {
    if (inputRefs.current[0]) {
      inputRefs.current[0]?.focus();
    }
  }, []);
  // --- End Input Handling ---

  // --- API Calls ---
  const handleVerifyCode = useCallback(
    async (e: FormEvent) => {
      e.preventDefault();
      setError(null);
      setVerifySuccessMessage(null);
      setResendInfoMessage(null); // Clear resend info message as well

      const otp = code.join("");
      if (otp.length !== OTP_LENGTH) {
        setError(`אנא הזן את הקוד בן ${OTP_LENGTH} הספרות במלואו.`);
        return;
      }

      setIsLoading(true);
      try {
        console.log("[VerifyPhonePage] Verifying code:", otp);
        const response = await fetch("/api/auth/verify-phone-code", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ code: otp }),
        });

        const result = await response.json();

        if (!response.ok) {
          throw new Error(result.error || "אימות הקוד נכשל. אנא נסה שנית.");
        }

        console.log(
          "[VerifyPhonePage] Code verified successfully. Result:",
          result
        );
        setVerifySuccessMessage("מספר הטלפון אומת בהצלחה! מעדכן את הפרופיל שלך...");

        console.log(
          "[VerifyPhonePage] Current session before update:",
          session
        );
        await updateSession({
          isPhoneVerified: true,
          isProfileComplete: true,
          status: "ACTIVE",
        });
        console.log(
          "[VerifyPhonePage] Session update initiated. Performing full page redirect to /profile."
        );

        window.location.href = "/profile";
      } catch (err: unknown) {
        const errorMessage =
          err instanceof Error
            ? err.message
            : "אירעה שגיאה בלתי צפויה במהלך האימות.";
        console.error(
          "[VerifyPhonePage] Error during verification:",
          errorMessage,
          err
        );
        setError(errorMessage);
        setCode(new Array(OTP_LENGTH).fill(""));
        if (inputRefs.current[0]) inputRefs.current[0]?.focus();
        setIsLoading(false);
      }
    },
    [code, updateSession, session]
  );

  const handleResendCode = useCallback(async () => {
    if (resendDisabled || isResending) return;
    setError(null);
    setVerifySuccessMessage(null); // Clear main success message
    setResendInfoMessage(null); // Clear previous resend info
    setIsResending(true);

    try {
      console.log("[VerifyPhonePage] Resending code...");
      const response = await fetch("/api/auth/resend-phone-code", {
        method: "POST",
      });
      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "שליחת קוד חדש נכשלה.");
      }

      setResendInfoMessage("קוד חדש נשלח אליך באמצעות WhatsApp."); // Use new state for info
      startResendTimer();
    } catch (err: unknown) {
      const errorMessage =
        err instanceof Error
          ? err.message
          : "אירעה שגיאה בלתי צפויה בעת שליחת קוד חדש.";
      setError(errorMessage);
    } finally {
      setIsResending(false);
    }
  }, [isResending, resendDisabled, startResendTimer]);
  // --- End API Calls ---

  // --- Session Handling ---
  useEffect(() => {
    console.log(
      "[VerifyPhonePage] Session useEffect triggered. Status:",
      sessionStatus,
      "Session:",
      session
    );

    if (sessionStatus === "authenticated") {
      if (session?.user?.isPhoneVerified && session?.user?.isProfileComplete) {
        if (window.location.pathname === "/auth/verify-phone") {
          console.log(
            "[VerifyPhonePage] User already verified and on verify-phone page. Redirecting to /profile via router.push."
          );
          router.push("/profile");
        }
      } else if (session?.user && !session.user.isPhoneVerified) {
        console.log(
          "[VerifyPhonePage] Authenticated, but phone not yet verified. User should stay on this page."
        );
      }
    } else if (sessionStatus === "unauthenticated") {
      console.log("[VerifyPhonePage] Unauthenticated. Redirecting to signin.");
      router.push("/auth/signin?callbackUrl=/auth/verify-phone");
    }
  }, [sessionStatus, session, router]);

  // --- Loading State ---
  if (sessionStatus === "loading") {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
        <div className="flex items-center">
          <Loader2 className="h-8 w-8 animate-spin text-cyan-600" />
          <span className="ml-2 text-gray-700">טוען נתונים...</span>
        </div>
      </div>
    );
  }
  // --- End Loading State ---

  // --- Helper Function for Displaying Phone ---
  const getHiddenPhone = () => {
    const phone = session?.user?.phone;
    if (!phone) return "הטלפון שלך";
    if (phone.length >= 10) {
      return `${phone.substring(0, 3)}••••${phone.substring(phone.length - 3)}`;
    }
    return "הטלפון שלך";
  };
  // --- End Helper Function ---

  // --- Render Component ---
  const disableFormInputsAndVerifyButton = isLoading || !!verifySuccessMessage;
  const disableResendButton = isResending || resendDisabled || !!verifySuccessMessage;


  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4">
      <div className="w-full max-w-md bg-white rounded-xl shadow-xl p-6 sm:p-8 space-y-6 text-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-800">אימות מספר טלפון</h1>
          <p className="text-gray-600 mt-2 text-sm sm:text-base">
            כמעט סיימנו! שלחנו קוד בן {OTP_LENGTH} ספרות באמצעות WhatsApp למספר{" "}
            <span className="font-medium text-gray-700">
              {getHiddenPhone()}
            </span>
            .
            <br />
            הזן/י אותו להשלמת ההרשמה.
          </p>
        </div>
        
        {error && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        {!error && verifySuccessMessage && (
          <Alert
            variant="default"
            className="bg-green-50 border-green-200 text-green-700"
          >
            <CheckCircle className="h-4 w-4 text-green-600" />
            <AlertTitle>הצלחה</AlertTitle>
            <AlertDescription>{verifySuccessMessage}</AlertDescription>
          </Alert>
        )}
        {!error && !verifySuccessMessage && resendInfoMessage && (
          <Alert
            variant="default"
            className="bg-green-50 border-green-200 text-green-700" // Reusing success style for info
          >
            <CheckCircle className="h-4 w-4 text-green-600" /> {/* Or a different icon like Info if preferred */}
            <AlertTitle>הודעה</AlertTitle>
            <AlertDescription>{resendInfoMessage}</AlertDescription>
          </Alert>
        )}

        <form onSubmit={handleVerifyCode} className="space-y-6">
          <div className="flex justify-center gap-2 sm:gap-3" dir="ltr">
            {code.map((digit, index) => (
              <Input
                key={index}
                ref={(el: HTMLInputElement | null) => {
                  inputRefs.current[index] = el;
                }}
                type="text"
                inputMode="numeric"
                pattern="\d{1}"
                maxLength={1}
                value={digit}
                onChange={(e) => handleInputChange(index, e.target.value)}
                onKeyDown={(e) => handleKeyDown(index, e)}
                className="w-10 h-12 sm:w-12 sm:h-14 text-center text-xl sm:text-2xl font-semibold border-2 border-gray-300 focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500 rounded-md shadow-sm transition-colors disabled:opacity-50 disabled:bg-gray-100"
                disabled={disableFormInputsAndVerifyButton}
                required
                aria-label={`ספרה ${index + 1}`}
              />
            ))}
          </div>

          <Button
            type="submit"
            disabled={
              disableFormInputsAndVerifyButton ||
              code.join("").length !== OTP_LENGTH
            }
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 text-white"
          >
            {isLoading ? (
              <Loader2 className="animate-spin h-5 w-5 mx-auto" />
            ) : (
              "אימות קוד"
            )}
          </Button>
        </form>
        <div className="text-sm text-gray-600 space-y-2">
          <div>
            לא קיבלת את הקוד?{" "}
            <Button
              type="button"
              variant="link"
              onClick={handleResendCode}
              disabled={disableResendButton}
              className="p-0 h-auto text-cyan-600 hover:text-cyan-700 disabled:text-gray-400 disabled:no-underline"
            >
              {isResending
                ? "שולח שוב..."
                : resendDisabled
                ? `שלח קוד חדש (${resendTimer} שניות)`
                : "שלח קוד חדש"}
            </Button>
          </div>
          <div>
            <Link
              href="/auth/update-phone"
              className={`text-cyan-600 hover:text-cyan-700 hover:underline ${
                disableFormInputsAndVerifyButton // Use the more specific disabling logic
                  ? "pointer-events-none text-gray-400"
                  : ""
              }`}
              aria-disabled={disableFormInputsAndVerifyButton}
              tabIndex={disableFormInputsAndVerifyButton ? -1 : undefined}
            >
              האם מספר הטלפון שגוי?
            </Link>
          </div>
        </div>
        <div className="mt-4 border-t border-gray-200 pt-4">
          <Link
            href="/auth/signin"
            className={`text-xs text-gray-500 hover:text-gray-600 ${
              disableFormInputsAndVerifyButton // Use the more specific disabling logic
                ? "pointer-events-none opacity-50"
                : ""
            }`}
            aria-disabled={disableFormInputsAndVerifyButton}
            tabIndex={disableFormInputsAndVerifyButton ? -1 : undefined}
          >
            חזרה להתחברות
          </Link>
        </div>
      </div>
    </div>
  );
};

export default VerifyPhonePage;
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ConsentCheckbox.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/ConsentCheckbox.tsx
"use client";

import React from "react";
import Link from "next/link";

interface ConsentCheckboxProps {
  checked: boolean;
  onChange: (isChecked: boolean) => void;
  error?: string | null;
}

const ConsentCheckbox: React.FC<ConsentCheckboxProps> = ({
  checked,
  onChange,
  error,
}) => {
  return (
    <div className="space-y-2">
      <div className="flex items-start space-x-2 rtl:space-x-reverse">
        <input
          type="checkbox"
          id="termsConsent"
          checked={checked}
          onChange={(e) => onChange(e.target.checked)}
          className={`mt-1 h-4 w-4 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500 ${
            error ? "border-red-500" : ""
          }`}
        />
        <label htmlFor="termsConsent" className="text-sm text-gray-700">
          קראתי ואני מאשר/ת את{" "}
          <Link
            href="/legal/terms-of-service"
            target="_blank"
            className="font-medium text-cyan-600 hover:text-cyan-700 underline"
          >
            תנאי השימוש
          </Link>{" "}
          ואת{" "}
          <Link
            href="/legal/privacy-policy"
            target="_blank"
            className="font-medium text-cyan-600 hover:text-cyan-700 underline"
          >
            מדיניות הפרטיות
          </Link>{" "}
          של Matchpoint, ומסכים/ה לאיסוף, עיבוד ושמירת המידע האישי שלי, לרבות
          מידע רגיש, בהתאם למפורט בהם, ולהעברת המידע שלי לשרתים שעשויים להיות
          ממוקמים מחוץ לגבולות ישראל.
        </label>
      </div>
      {error && <p className="text-xs text-red-500">{error}</p>}
    </div>
  );
};

export default ConsentCheckbox;
--- End of Content for ConsentCheckbox.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ForgotPasswordForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/ForgotPasswordForm.tsx
"use client";

import { useState, FormEvent } from "react";
import { useRouter } from "next/navigation"; // <--- 1. Import useRouter
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Mail, Loader2, AlertCircle } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import Link from "next/link";

export default function ForgotPasswordForm() {
  const router = useRouter(); // <--- 2. Initialize router
  const [email, setEmail] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // The success message might not be seen if we redirect immediately.
  // Consider removing it or using a toast notification system for a brief message before redirect.
  // const [successMessage, setSuccessMessage] = useState<string | null>(null);

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    // setSuccessMessage(null); // If redirecting, this isn't needed

    if (!email) {
      setError("אנא הזן את כתובת המייל שלך.");
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch("/api/auth/request-password-reset", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email }),
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || "אירעה שגיאה בבקשת איפוס הסיסמה.");
      }

      // 3. Redirect to the reset password page on success
      // The API's success message (data.message) is generic for security and won't be shown here.
      // The ResetPasswordForm will guide the user.
      router.push(`/auth/reset-password?email=${encodeURIComponent(email)}`);
      
      // setEmail(""); // Clearing email is not strictly necessary as we are navigating away

    } catch (err) {
      setError(err instanceof Error ? err.message : "אירעה שגיאה לא צפויה.");
      setIsLoading(false); // Ensure isLoading is set to false in case of an error before navigation
    }
    // setIsLoading(false); // If navigation occurs, this line might not be reached or necessary.
                         // It's important that isLoading is false if an error occurs and we don't navigate.
  };

  return (
    <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
      <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>
      <div className="p-6 sm:p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold text-gray-800 mb-2">
            שכחת סיסמה?
          </h1>
          <p className="text-gray-600 text-sm">
            אין בעיה! הזן את כתובת המייל שלך למטה, ואם היא קיימת במערכת, נשלח לך קוד לאיפוס הסיסמה.
          </p>
        </div>

        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Success message is removed because we are redirecting. 
            If you want to show a message on the next page, 
            you could pass a query param like ?request_sent=true
        */}
        {/*
        {successMessage && (
          <Alert variant="default" className="mb-4 bg-green-50 border-green-200 text-green-700">
            <CheckCircle className="h-4 w-4 text-green-600" />
            <AlertTitle>הבקשה נשלחה</AlertTitle>
            <AlertDescription>{successMessage}</AlertDescription>
          </Alert>
        )}
        */}
        
        {/* Form is always shown unless you conditionally hide it during loading/after success,
            but since we redirect, this logic can be simpler.
        */}
        {/* {!successMessage && ( // This condition can be removed if successMessage state is removed */}
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-1">
              <label htmlFor="email-forgot" className="block text-sm font-medium text-gray-700">
                כתובת מייל
              </label>
              <div className="relative">
                <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type="email"
                  id="email-forgot"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="you@example.com"
                  required
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  disabled={isLoading}
                />
              </div>
            </div>

            <Button
              type="submit"
              disabled={isLoading}
              className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2"
            >
              {isLoading ? (
                <>
                  <Loader2 className="h-5 w-5 animate-spin mr-2" />
                  <span>שולח...</span>
                </>
              ) : (
                "שלח בקשה לאיפוס סיסמה" // Changed text slightly
              )}
            </Button>
          </form>
        {/* )} */}

        <div className="mt-6 text-center">
          <Link
            href="/auth/signin"
            className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline"
          >
            חזרה להתחברות
          </Link>
        </div>
      </div>
    </div>
  );
}
--- End of Content for ForgotPasswordForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ProgressBar.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { motion } from "framer-motion";

interface ProgressBarProps {
  currentStep: number;
  totalSteps: number;
}

const ProgressBar: React.FC<ProgressBarProps> = ({
  currentStep,
  totalSteps,
}) => {
  // Calculate percentage
  const percentage = (currentStep / totalSteps) * 100;

  // Generate step markers
  const steps = Array.from({ length: totalSteps }, (_, i) => i + 1);

  return (
    <div className="w-full relative">
      {/* Step labels */}
      <div className="flex justify-between mb-2">
        {steps.map((step) => (
          <div
            key={step}
            className={`text-xs font-medium transition-colors duration-300 ${
              step <= currentStep ? "text-gray-800" : "text-gray-400"
            }`}
          >
            שלב {step}
          </div>
        ))}
      </div>

      {/* Progress bar track */}
      <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
        {/* Animated progress fill */}
        <motion.div
          className="h-full bg-gradient-to-r from-cyan-500 to-pink-500"
          initial={{ width: `${((currentStep - 1) / totalSteps) * 100}%` }}
          animate={{ width: `${percentage}%` }}
          transition={{ duration: 0.5, ease: "easeInOut" }}
        />
      </div>

      {/* Step markers */}
      <div className="relative flex justify-between mt-1">
        {steps.map((step) => (
          <motion.div
            key={step}
            className={`w-6 h-6 rounded-full flex items-center justify-center -mt-4 z-10 transition-all duration-300
              ${
                step <= currentStep
                  ? "bg-gradient-to-r from-cyan-500 to-pink-500 shadow-md text-white"
                  : "bg-white border-2 border-gray-300 text-gray-500"
              }`}
            initial={{ scale: step === currentStep ? 0.8 : 1 }}
            animate={{ scale: step === currentStep ? 1.1 : 1 }}
            transition={{ duration: 0.3 }}
          >
            <span className="text-xs font-semibold">{step}</span>
          </motion.div>
        ))}
      </div>
    </div>
  );
};

export default ProgressBar;
--- End of Content for ProgressBar.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\RegisterForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/RegisterForm.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Gender } from "@prisma/client";
import { signIn } from "next-auth/react";
import ConsentCheckbox from "./ConsentCheckbox"; // <-- ייבוא הקומפוננטה
import { Button } from "@/components/ui/button"; // אם אתה משתמש בכפתור משותף
import { Loader2 } from "lucide-react"; // לאייקון טעינה

interface RegistrationFormData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  phone: string;
  gender: Gender;
  birthDate: string;
  maritalStatus?: string;
  height?: number;
  occupation?: string;
  education?: string;
}

export default function RegisterForm() {
  const router = useRouter();
  const [error, setError] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);
  const [password, setPassword] = useState("");
  const [passwordError, setPasswordError] = useState("");

  // --- הוספת State עבור תיבת ההסכמה ---
  const [consentChecked, setConsentChecked] = useState(false);
  const [consentError, setConsentError] = useState<string | null>(null);

  const validatePassword = (value: string) => {
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(value)) {
      setPasswordError(
        "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר"
      );
      return false;
    }
    setPasswordError("");
    return true;
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");
    setConsentError(null); // איפוס שגיאת הסכמה

    if (!consentChecked) {
      setConsentError("חובה לאשר את תנאי השימוש ומדיניות הפרטיות.");
      setIsLoading(false);
      return;
    }

    if (!validatePassword(password)) {
      setIsLoading(false);
      return;
    }

    const formData = new FormData(e.currentTarget);
    const data: RegistrationFormData = {
      email: formData.get("email") as string,
      password: password,
      firstName: formData.get("firstName") as string,
      lastName: formData.get("lastName") as string,
      phone: formData.get("phone") as string,
      gender: formData.get("gender") as Gender,
      birthDate: formData.get("birthDate") as string,
      maritalStatus: formData.get("maritalStatus") as string,
      height: formData.get("height")
        ? Number(formData.get("height"))
        : undefined,
      occupation: formData.get("occupation") as string,
      education: formData.get("education") as string,
    };

    try {
      // כאן, ה-API /api/auth/register אמור לשמור את termsAndPrivacyAcceptedAt: new Date()
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "אירעה שגיאה בהרשמה");
      }

      router.push(`/auth/verify-email?email=${encodeURIComponent(data.email)}`);
    } catch (error) {
      setError(error instanceof Error ? error.message : "אירעה שגיאה בהרשמה");
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    // ההנחה היא שאם המשתמש נרשם עם גוגל דרך הטופס הזה,
    // הוא יועבר לתהליך RegisterSteps, שם יתבקש לאשר תנאים אם נדרש.
    try {
      setIsGoogleLoading(true);
      setError("");
      await signIn("google"); // NextAuth יטפל בהפניה
    } catch (error) {
      console.error("Google sign-in error:", error);
      setError("אירעה שגיאה בהתחברות עם גוגל");
      setIsGoogleLoading(false);
    }
  };

  const isSubmitDisabled = isLoading || !!passwordError || !consentChecked;


  return (
    <div className="space-y-6 max-w-sm mx-auto p-6 bg-white shadow-lg rounded-lg">
      <h2 className="text-2xl font-semibold text-center text-gray-800">הרשמה</h2>
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* ... כל שדות הטופס הקיימים ... */}
        {/* שם פרטי */}
        <div>
          <label htmlFor="firstNameRegForm" className="block text-sm font-medium text-gray-700">שם פרטי</label>
          <input type="text" name="firstName" id="firstNameRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* שם משפחה */}
        <div>
          <label htmlFor="lastNameRegForm" className="block text-sm font-medium text-gray-700">שם משפחה</label>
          <input type="text" name="lastName" id="lastNameRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* אימייל */}
        <div>
          <label htmlFor="emailRegForm" className="block text-sm font-medium text-gray-700">אימייל</label>
          <input type="email" name="email" id="emailRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* טלפון */}
        <div>
          <label htmlFor="phoneRegForm" className="block text-sm font-medium text-gray-700">טלפון נייד</label>
          <input type="tel" name="phone" id="phoneRegForm" required pattern="[0-9]{10}" placeholder="" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* סיסמה */}
        <div>
          <label htmlFor="passwordRegForm" className="block text-sm font-medium text-gray-700">סיסמה</label>
          <input
            type="password"
            name="password" // חשוב שה-name יהיה "password" כדי ש-validatePassword יעבוד עם הערך מה-state. או שנה את validatePassword לקבל את הערך ישירות.
            id="passwordRegForm"
            required
            value={password}
            onChange={(e) => {
              setPassword(e.target.value);
              validatePassword(e.target.value);
            }}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2"
          />
          <p className="mt-1 text-sm text-gray-500">
            הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה באנגלית, אות קטנה באנגלית ומספר.
          </p>
          {passwordError && (
            <div className="text-red-500 text-sm mt-1">{passwordError}</div>
          )}
        </div>
        {/* מגדר */}
        <div>
          <label htmlFor="genderRegForm" className="block text-sm font-medium text-gray-700">מגדר</label>
          <select name="gender" id="genderRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
            <option value="">בחר מגדר</option>
            <option value="MALE">זכר</option>
            <option value="FEMALE">נקבה</option>
          </select>
        </div>
        {/* תאריך לידה */}
        <div>
          <label htmlFor="birthDateRegForm" className="block text-sm font-medium text-gray-700">תאריך לידה</label>
          <input type="date" name="birthDate" id="birthDateRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* מצב משפחתי */}
        <div>
          <label htmlFor="maritalStatusRegForm" className="block text-sm font-medium text-gray-700">מצב משפחתי</label>
          <select name="maritalStatus" id="maritalStatusRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
            <option value="">בחר מצב משפחתי</option>
            <option value="רווק/ה">רווק/ה</option>
            <option value="גרוש/ה">גרוש/ה</option>
            <option value="אלמן/ה">אלמן/ה</option>
          </select>
        </div>
        {/* גובה */}
        <div>
          <label htmlFor="heightRegForm" className="block text-sm font-medium text-gray-700">גובה (בסמ)</label>
          <input type="number" name="height" id="heightRegForm" min="120" max="220" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* עיסוק */}
        <div>
          <label htmlFor="occupationRegForm" className="block text-sm font-medium text-gray-700">עיסוק</label>
          <input type="text" name="occupation" id="occupationRegForm" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* השכלה */}
        <div>
          <label htmlFor="educationRegForm" className="block text-sm font-medium text-gray-700">השכלה</label>
          <input type="text" name="education" id="educationRegForm" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>


        {/* --- הוספת תיבת ההסכמה --- */}
        <div className="pt-4">
          <ConsentCheckbox
            checked={consentChecked}
            onChange={(isChecked) => {
              setConsentChecked(isChecked);
              if (isChecked) setConsentError(null);
            }}
            error={consentError}
          />
        </div>

        {error && <div className="text-red-500 text-sm mt-2">{error}</div>}

        <Button
          type="submit"
          disabled={isSubmitDisabled}
          className="w-full flex justify-center py-2.5 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gradient-to-r from-cyan-600 to-pink-600 hover:from-cyan-700 hover:to-pink-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
        >
          {isLoading ? (
            <div className="flex items-center">
              <Loader2 className="animate-spin h-5 w-5 mr-2" />
              נרשם...
            </div>
          ) : (
            "הרשמה"
          )}
        </Button>
      </form>

      <div className="relative my-6">
        <div className="absolute inset-0 flex items-center">
          <div className="w-full border-t border-gray-300" />
        </div>
        <div className="relative flex justify-center text-sm">
          <span className="px-2 bg-white text-gray-500">או</span>
        </div>
      </div>

      <Button
        type="button"
        onClick={handleGoogleSignIn}
        disabled={isGoogleLoading}
        variant="outline"
        className="w-full flex justify-center items-center py-2.5 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
      >
        {isGoogleLoading ? (
          <div className="flex items-center">
            <Loader2 className="animate-spin h-5 w-5 mr-2" />
            <span>מתחבר...</span>
          </div>
        ) : (
          <>
            <svg className="h-5 w-5 mr-2" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
              <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
              <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
              <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
            </svg>
            הרשמה עם גוגל
          </>
        )}
      </Button>
    </div>
  );
}
--- End of Content for RegisterForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\RegisterSteps.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/RegisterSteps.tsx
"use client";

import React, { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useSession } from "next-auth/react";
import { RegistrationProvider, useRegistration } from "./RegistrationContext"; // ודא ש-RegistrationData מיובא
import WelcomeStep from "./steps/WelcomeStep";
import BasicInfoStep from "./steps/BasicInfoStep";
import EmailVerificationCodeStep from "./steps/EmailVerificationCodeStep";
import PersonalDetailsStep from "./steps/PersonalDetailsStep";
import OptionalInfoStep from "./steps/OptionalInfoStep";
import CompleteStep from "./steps/CompleteStep";
import ProgressBar from "./ProgressBar";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { ArrowRight, Info, Loader2 } from "lucide-react";
import type { User as SessionUserType } from "@/types/next-auth";

const RegisterStepsContent: React.FC = () => {
  const {
    data: registrationContextData,
    initializeFromSession,
    resetForm,
    goToStep,
  } = useRegistration();
  const router = useRouter();
  const { data: session, status: sessionStatus } = useSession();
  const searchParams = useSearchParams();

  const [showIncompleteProfileMessage, setShowIncompleteProfileMessage] = useState(false);
  const [initializationAttempted, setInitializationAttempted] = useState(false);

  // הדפסה ראשונית של מצב הקומפוננטה בעת טעינה/עדכון
  console.log(
    "[RegisterStepsContent RENDER] Initial State Check:",
    {
      sessionStatus,
      sessionUserExists: !!session?.user,
      registrationContextData_step: registrationContextData.step,
      registrationContextData_isCompletingProfile: registrationContextData.isCompletingProfile,
      registrationContextData_isVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
      initializationAttempted,
      searchParams: searchParams.toString(),
    }
  );


  useEffect(() => {
    const reasonParam = searchParams.get("reason");
    if (reasonParam === "complete_profile" && !registrationContextData.isCompletingProfile) {
      setShowIncompleteProfileMessage(true);
    } else if (reasonParam === "verify_phone" && !registrationContextData.isCompletingProfile) {
      setShowIncompleteProfileMessage(true);
    } else {
      setShowIncompleteProfileMessage(false);
    }
  }, [searchParams, registrationContextData.isCompletingProfile]);

  useEffect(() => {
    console.log(
      "[RegisterStepsContent useEffect Trigger] Current State:", {
        sessionStatus,
        sessionUserExists: !!session?.user,
        contextStep: registrationContextData.step,
        contextIsCompletingProfile: registrationContextData.isCompletingProfile,
        contextIsVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
        initializationAttempted,
      }
    );

    if (sessionStatus === "loading") {
      console.log("[RegisterStepsContent useEffect] Session loading, returning.");
      return;
    }

    if (sessionStatus === "authenticated" && session?.user) {
      const user = session.user as SessionUserType;
      console.log("[RegisterStepsContent useEffect] AUTHENTICATED. User data from session:", user);

      if (user.isProfileComplete && user.isPhoneVerified && user.termsAndPrivacyAcceptedAt) {
        console.log("[RegisterStepsContent useEffect] User fully set up. Redirecting to /profile.");
        if (typeof window !== 'undefined' && window.location.pathname !== "/profile") {
             router.push("/profile");
        }
        return;
      }

      const needsSetup = !user.termsAndPrivacyAcceptedAt || !user.isProfileComplete || !user.isPhoneVerified;
      console.log("[RegisterStepsContent useEffect] User needsSetup:", needsSetup);

      if (needsSetup) {
        if (!initializationAttempted || (registrationContextData.step === 0 && !registrationContextData.isVerifyingEmailCode)) {
          console.log("[RegisterStepsContent useEffect] AUTHENTICATED & needs setup. Initializing context from session.");
          initializeFromSession(user);
          setInitializationAttempted(true);
          // הפונקציה initializeFromSession תגרום לעדכון הקונטקסט, מה שיפעיל מחדש את ה-useEffect.
          // הלוגיקה תמשיך משם עם הקונטקסט המעודכן.
          return;
        } else {
          console.log("[RegisterStepsContent useEffect] AUTHENTICATED & needs setup, but initialization already attempted or context not in initial state. Context should be guiding the flow now.");
        }
      } else {
        console.warn("[RegisterStepsContent useEffect] AUTHENTICATED & fully setup, but somehow not redirected yet. Forcing redirect to /profile.");
        if (typeof window !== 'undefined' && window.location.pathname !== "/profile") {
            router.push("/profile");
        }
        return;
      }

    } else if (sessionStatus === "unauthenticated") {
      console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED. Context state:", {
        step: registrationContextData.step,
        isCompletingProfile: registrationContextData.isCompletingProfile,
        isVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
      });
      setInitializationAttempted(false); // אפס ניסיון אתחול עבור התחברות עתידית
      let shouldReset = false;
      let resetReason = "";

      // קריטי: בדוק אם אנחנו במצב שבו אנו *מצפים* שהאימות יתרחש בקרוב.
      // זה נכון אם הרגע סיימנו אימות מייל והקונטקסט משקף זאת.
      const justFinishedEmailVerificationAndContextIsReadyForProfileCompletion =
        registrationContextData.isCompletingProfile && // הקונטקסט עבר למצב השלמת פרופיל
        registrationContextData.step === 2 &&         // השלב הבא הוא פרטים אישיים
        !registrationContextData.isVerifyingEmailCode; // לא בתהליך אימות קוד מייל

      if (justFinishedEmailVerificationAndContextIsReadyForProfileCompletion) {
        console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED, but context suggests email verification just completed and set for profile completion. Holding off on reset, expecting session to become 'authenticated' soon.");
        shouldReset = false; // אל תאפס, חכה שהסשן יתעדכן
      } else if (registrationContextData.isCompletingProfile) {
        // אם נמצאים בתהליך השלמת פרופיל (לא מיד אחרי אימות מייל) והסשן אבד.
        shouldReset = true;
        resetReason = "Unauthenticated while in 'isCompletingProfile' mode (not immediately after email verification).";
      } else if (registrationContextData.isVerifyingEmailCode) {
        // זהו מצב תקין למשתמש חדש שאינו מאומת ונמצא בתהליך אימות קוד מייל.
        shouldReset = false;
        console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED, but actively verifying email code. No reset needed.");
      } else if (registrationContextData.step > 1) {
        // בתהליך הרשמה חדש (לא isCompletingProfile), עבר את שלב BasicInfo (שלב 1), לא מאמת קוד מייל, והפך ללא מאומת.
        shouldReset = true;
        resetReason = "Unauthenticated in new registration flow, past BasicInfo (step > 1), and not verifying email code.";
      } else if (registrationContextData.step <= 1 && registrationContextData.step >= 0) {
        // ב-Welcome (שלב 0) או BasicInfo (שלב 1) עבור הרשמה חדשה, ומצב לא מאומת הוא צפוי.
        shouldReset = false;
        console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED, on Welcome/BasicInfo step for new registration. This is normal, no reset needed.");
      }


      if (shouldReset) {
        console.warn(`[RegisterStepsContent useEffect] UNAUTHENTICATED. Resetting form. Reason: ${resetReason}`);
        resetForm();
      }
    }
  }, [
    sessionStatus,
    session, // תלות בסשן עצמו (לא רק בסטטוס)
    router,
    registrationContextData,
    initializeFromSession,
    resetForm,
    goToStep,
    initializationAttempted,
    searchParams, // הוספנו כתלות כי הוא משפיע על הודעת הפרופיל הלא שלם
  ]);

  const renderStep = (): React.ReactNode => {
    console.log("[RegisterStepsContent renderStep] Determining step. Context:", {
        step: registrationContextData.step,
        isCompletingProfile: registrationContextData.isCompletingProfile,
        isVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
        emailForVerification: registrationContextData.emailForVerification,
      },
      "Session Status:", sessionStatus
    );

    if (sessionStatus === "loading") {
      console.log("[RegisterStepsContent renderStep] Session loading, showing loader.");
      return <div className="flex justify-center p-10"><Loader2 className="h-8 w-8 animate-spin text-cyan-600" /></div>;
    }
const user = session?.user as SessionUserType | undefined;
    if (
      sessionStatus === "authenticated" &&
      user &&
      (!user.isProfileComplete || !user.isPhoneVerified) &&
      registrationContextData.step < 2
    ) {
      console.log("[RegisterStepsContent renderStep] Authenticated but context is not ready. Showing 'preparing' loader to prevent flash.");
      return (
        <div className="flex justify-center items-center p-10 space-x-3 rtl:space-x-reverse">
          <Loader2 className="h-8 w-8 animate-spin text-cyan-600" />
          <span className="text-gray-600">מכין את השלב הבא...</span>
        </div>
      );
    }
    // --- סוף התיקון ---
    const userFromSession = session?.user as SessionUserType | undefined;
    if (
      sessionStatus === "authenticated" && userFromSession && !initializationAttempted &&
      (!userFromSession.termsAndPrivacyAcceptedAt || !userFromSession.isProfileComplete || !userFromSession.isPhoneVerified) &&
      registrationContextData.step === 0 &&
      !registrationContextData.isVerifyingEmailCode
    ) {
        console.log("[RegisterStepsContent renderStep] Authenticated but initialization not attempted and context is at step 0. Showing 'preparing' loader.");
        return <div className="flex justify-center p-10"><Loader2 className="h-8 w-8 animate-spin text-cyan-600" /><p className="ml-2">מכין תהליך הרשמה...</p></div>;
    }


    // אימות מייל למשתמשים חדשים עם אימייל/סיסמה
    if (registrationContextData.isVerifyingEmailCode && !registrationContextData.isCompletingProfile) {
      console.log("[RegisterStepsContent renderStep] Rendering EmailVerificationCodeStep.");
      return <EmailVerificationCodeStep />;
    }

    // תהליך השלמת פרופיל (isCompletingProfile הוא true)
    // זה כולל משתמשי גוגל שצריכים השלמה, משתמשי אימייל/סיסמה אחרי אימות מייל,
    // או משתמשים שחזרו להשלים פרופיל/טלפון.
    // ההסכמה מטופלת כעת בתוך PersonalDetailsStep אם נדרש.
    if (registrationContextData.isCompletingProfile) {
      console.log("[RegisterStepsContent renderStep] In 'isCompletingProfile' mode. Current step:", registrationContextData.step);
      switch (registrationContextData.step) {
        case 2:
          console.log("[RegisterStepsContent renderStep] Rendering PersonalDetailsStep for profile completion.");
          return <PersonalDetailsStep />;
        case 3:
          console.log("[RegisterStepsContent renderStep] Rendering OptionalInfoStep for profile completion.");
          return <OptionalInfoStep />;
        case 4:
          console.log("[RegisterStepsContent renderStep] Rendering CompleteStep for profile completion.");
          return <CompleteStep />;
        default:
          console.warn(`[RegisterStepsContent renderStep] (Profile Completion Flow) Unexpected step ${registrationContextData.step}. Session:`, session?.user);
          // ניסיון התאוששות אם המצב לא תקין
          if (session?.user) { // רק אם יש סשן, אחרת זה עלול לגרום ללולאה עם הלוגיקה ב-useEffect
            if (!initializationAttempted) {
                console.log("[RegisterStepsContent renderStep] (Profile Completion Flow) Default case - user exists, re-initializing from session.");
                initializeFromSession(session.user as SessionUserType);
                setInitializationAttempted(true); // סמן שניסית לאתחל
                return <Loader2 className="h-8 w-8 animate-spin text-cyan-600 mx-auto my-10" />;
            } else if (registrationContextData.step < 2 || registrationContextData.step > 4) {
                // אם כבר ניסינו אתחול, והשלב עדיין לא תקין (לא 2,3,4), נסה לנתב לשלב ההתחלה של השלמת פרופיל
                console.log(`[RegisterStepsContent renderStep] (Profile Completion Flow) Default case - user exists, init attempted, step ${registrationContextData.step} invalid. Going to step 2.`);
                if(goToStep) goToStep(2); // ודא ש-goToStep מוגדר לפני הקריאה
                return <Loader2 className="h-8 w-8 animate-spin text-cyan-600 mx-auto my-10" />;
            }
          }
          // אם אין סשן או שההתאוששות לא עבדה, אולי כדאי לאפס
          console.log("[RegisterStepsContent renderStep] (Profile Completion Flow) Default case - cannot recover, resetting form and showing WelcomeStep.");
          resetForm();
          return <WelcomeStep />;
      }
    }

    // תהליך הרשמה חדש רגיל
    console.log("[RegisterStepsContent renderStep] In new registration flow. Current step:", registrationContextData.step);
    switch (registrationContextData.step) {
      case 0:
        console.log("[RegisterStepsContent renderStep] Rendering WelcomeStep.");
        return <WelcomeStep />;
      case 1:
        console.log("[RegisterStepsContent renderStep] Rendering BasicInfoStep.");
        return <BasicInfoStep />;
      // שלבים 2,3,4 עבור הרשמה חדשה קורים אחרי אימות מייל,
      // שם isCompletingProfile הופך ל-true והלוגיקה למעלה תופסת.
      default:
        console.warn(`[RegisterStepsContent renderStep] (New Registration Flow) Unexpected step ${registrationContextData.step}.`);
        // אם יש סשן והוא לא מוגדר במלואו, נסה לאתחל
        if (session?.user && (!session.user.isProfileComplete || !session.user.isPhoneVerified || !session.user.termsAndPrivacyAcceptedAt)) {
          if (!initializationAttempted) {
            console.log("[RegisterStepsContent renderStep] (New Registration Flow) Default case - user exists and needs setup, re-initializing from session.");
            initializeFromSession(session.user as SessionUserType);
            setInitializationAttempted(true);
            return <Loader2 className="h-8 w-8 animate-spin text-cyan-600 mx-auto my-10" />;
          }
        }
        // אם אין סשן או שהאתחול לא נדרש/עזר, אפס והצג את שלב הפתיחה
        console.log("[RegisterStepsContent renderStep] (New Registration Flow) Default case - resetting form and showing WelcomeStep.");
        resetForm();
        return <WelcomeStep />;
    }
  };

  const stepContent = renderStep();

  // --- לוגיקת כותרות וסרגל התקדמות (נשארה כפי שהייתה, אך מומלץ לבדוק אותה היטב בהקשר לשינויים) ---
  let pageTitle = "הרשמה למערכת";
  let stepDescription = "ברוכים הבאים! בואו נתחיל.";
  let currentProgressBarStep = 0;
  let totalProgressBarSteps = 3;
  let showProgressBar = false;

  if (registrationContextData.isVerifyingEmailCode && !registrationContextData.isCompletingProfile) {
    pageTitle = "אימות כתובת מייל";
    stepDescription = `הזן את הקוד שנשלח ל: ${registrationContextData.emailForVerification || registrationContextData.email}.`;
    showProgressBar = true;
    currentProgressBarStep = 1;
  } else if (registrationContextData.isCompletingProfile) {
    pageTitle = "השלמת פרטים";
    totalProgressBarSteps = 2; // פרטים אישיים (1), אופציונלי (2)
    if (registrationContextData.step === 2) { // PersonalDetails
      stepDescription = session?.user?.termsAndPrivacyAcceptedAt
        ? "שלב 1 מתוך 2: פרטים אישיים."
        : "שלב 1: אישור תנאים ופרטים אישיים.";
      currentProgressBarStep = 1;
      showProgressBar = true;
    } else if (registrationContextData.step === 3) { // OptionalInfo
      stepDescription = "שלב 2 מתוך 2: מידע נוסף (מומלץ).";
      currentProgressBarStep = 2;
      showProgressBar = true;
    } else if (registrationContextData.step === 4) { // CompleteStep
      stepDescription = session?.user?.isPhoneVerified
        ? "הפרופיל שלך מוכן!"
        : "הפרטים הושלמו! השלב הבא: אימות טלפון.";
      showProgressBar = false; // בדרך כלל אין סרגל התקדמות במסך הסיום
    } else {
      // למקרה שהשלב הוא לא 2, 3, או 4 במצב השלמת פרופיל (למשל, אם נתקע על 0 או 1)
      stepDescription = "טוען שלב השלמת פרופיל...";
      showProgressBar = registrationContextData.step > 1 && registrationContextData.step < 4; // הצג רק אם בשלבי מילוי פעילים
    }
  } else { // הרשמה חדשה (לא מאמתים מייל על המסך, לא משלימים פרופיל עדיין)
    if (registrationContextData.step === 0) { // Welcome
      pageTitle = "ברוכים הבאים";
      stepDescription = "בואו נתחיל את המסע יחד.";
      showProgressBar = false;
    } else if (registrationContextData.step === 1) { // BasicInfo
      pageTitle = "יצירת חשבון";
      stepDescription = "שלב 1 מתוך 3: אישור תנאים ופרטי התחברות.";
      currentProgressBarStep = 1;
      totalProgressBarSteps = 3; // בסיסי (כולל הסכמה), אישי, אופציונלי (אחרי אימות מייל)
      showProgressBar = true;
    }
  }
  // --- סוף לוגיקת כותרות וסרגל התקדמות ---

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 sm:p-8">
      <button
        onClick={() => router.push("/")}
        className="absolute top-4 left-4 rtl:right-4 rtl:left-auto text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm z-20"
      >
        <ArrowRight className="h-4 w-4" />
        חזרה לדף הבית
      </button>

      <div className="mb-6 text-center">
        <h1 className="text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-pink-500 text-3xl font-bold mb-2">
          {pageTitle}
        </h1>
        <p className="text-gray-600 max-w-md mx-auto">{stepDescription}</p>
      </div>

      {showIncompleteProfileMessage && (
         <Alert className="mb-6 w-full max-w-md bg-yellow-50 border-yellow-200 text-yellow-800 shadow-md">
           <Info className="h-5 w-5 text-yellow-600 flex-shrink-0 mt-1" />
           <div className="ml-3 rtl:mr-3 rtl:ml-0">
             <AlertTitle className="font-semibold mb-1">
               נדרשת פעולה להשלמת החשבון
             </AlertTitle>
             <AlertDescription className="text-sm">
               {searchParams.get("reason") === "verify_phone"
                 ? "הפרופיל שלך כמעט מוכן! נדרש אימות טלפון כדי להמשיך."
                 : "כדי לגשת לאזור האישי ולשאר חלקי האתר, יש להשלים תחילה את פרטי הפרופיל ואימותים נדרשים."}
             </AlertDescription>
           </div>
         </Alert>
       )}

      {showProgressBar && (
        <div className="w-full max-w-md mb-6">
          <ProgressBar
            currentStep={currentProgressBarStep}
            totalSteps={totalProgressBarSteps}
          />
        </div>
      )}

      <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
        {!(
          (registrationContextData.step === 0 && !registrationContextData.isCompletingProfile) || // WelcomeStep
          registrationContextData.step === 4 // CompleteStep
        ) && (
          <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>
        )}
        <div className="p-6 sm:p-8">{stepContent}</div>
      </div>

      <div className="mt-8 text-center text-sm text-gray-500">
        יש לך שאלות?{" "}
        <a href="/contact" className="text-cyan-600 hover:underline">
          צור קשר
        </a>
      </div>
    </div>
  );
};

export default function RegisterSteps() {
  return (
    <RegistrationProvider>
      <RegisterStepsContent />
    </RegistrationProvider>
  );
}
--- End of Content for RegisterSteps.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\RegistrationContext.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/RegistrationContext.tsx
"use client";

import React, {
  createContext,
  useContext,
  useState,
  ReactNode,
  useCallback,
} from "react";
import { Gender, UserStatus, UserSource } from "@prisma/client";
import type { User as SessionUserType } from "@/types/next-auth";

export interface RegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  phone: string;
  gender: Gender | ""; // "" for unselected, or actual Gender enum value
  birthDate: string;
  maritalStatus: string;
  height?: number;
  occupation?: string;
  education?: string;
  step: number;
  isGoogleSignup: boolean;
  isCompletingProfile: boolean;
  isVerifyingEmailCode: boolean;
  emailForVerification: string | null;
}

const initialRegistrationData: RegistrationData = {
  email: "",
  password: "",
  firstName: "",
  lastName: "",
  phone: "",
  gender: "", // Initialized as empty string
  birthDate: "",
  maritalStatus: "",
  height: undefined,
  occupation: "",
  education: "",
  step: 0,
  isGoogleSignup: false,
  isCompletingProfile: false,
  isVerifyingEmailCode: false,
  emailForVerification: null,
};

interface RegistrationContextType {
  data: RegistrationData;
  setData: React.Dispatch<React.SetStateAction<RegistrationData>>;
  updateField: <K extends keyof RegistrationData>(
    field: K,
    value: RegistrationData[K]
  ) => void;
  nextStep: () => void;
  prevStep: () => void;
  goToStep: (step: number) => void;
  resetForm: () => void;
  setGoogleSignup: (googleUserData: {
    email: string;
    firstName?: string;
    lastName?: string;
  }) => void;
  initializeFromSession: (sessionUser: SessionUserType) => void;
  proceedToEmailVerification: (email: string) => void;
  completeEmailVerification: () => void;
  exitEmailVerification: () => void;
}

const RegistrationContext = createContext<RegistrationContextType>({
  data: initialRegistrationData,
  setData: () => console.warn("RegistrationProvider not found"),
  updateField: () => console.warn("RegistrationProvider not found"),
  nextStep: () => console.warn("RegistrationProvider not found"),
  prevStep: () => console.warn("RegistrationProvider not found"),
  goToStep: () => console.warn("RegistrationProvider not found"),
  resetForm: () => console.warn("RegistrationProvider not found"),
  setGoogleSignup: () => console.warn("RegistrationProvider not found"),
  initializeFromSession: () => console.warn("RegistrationProvider not found"),
  proceedToEmailVerification: () => console.warn("RegistrationProvider not found"),
  completeEmailVerification: () => console.warn("RegistrationProvider not found"),
  exitEmailVerification: () => console.warn("RegistrationProvider not found"),
});

export const RegistrationProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [data, setData] = useState<RegistrationData>(initialRegistrationData);

  const updateField = useCallback(
    <K extends keyof RegistrationData>(
      field: K,
      value: RegistrationData[K]
    ) => {
      setData((prev) => ({ ...prev, [field]: value }));
    },
    []
  );

  const nextStep = useCallback(() => {
    setData((prev) => {
      if (prev.isVerifyingEmailCode) return prev;
      const currentMaxStep = 3;
      if (prev.step === 1 && !prev.isCompletingProfile && !prev.isGoogleSignup) return prev;
      if (prev.step < currentMaxStep) return { ...prev, step: prev.step + 1 };
      if (prev.step === currentMaxStep) return { ...prev, step: 4 };
      return prev;
    });
  }, []);

  const prevStep = useCallback(() => {
    setData((prev) => {
      if (prev.isVerifyingEmailCode) {
        return { ...prev, isVerifyingEmailCode: false, emailForVerification: null, step: 1 };
      }
      if (prev.step > 0) {
        if (prev.step === 4) return { ...prev, step: 3 };
        return { ...prev, step: prev.step - 1 };
      }
      return prev;
    });
  }, []);

  const goToStep = useCallback((stepNum: number) => {
    setData((prev) => ({
      ...prev,
      step: stepNum,
      isVerifyingEmailCode: false,
      emailForVerification: null,
    }));
  }, []);

  const resetForm = useCallback(() => {
    setData(initialRegistrationData);
  }, []);

  const setGoogleSignup = useCallback(
    (googleUserData: { email: string; firstName?: string; lastName?: string }) => {
      setData({
        ...initialRegistrationData,
        email: googleUserData.email,
        isGoogleSignup: true,
      });
    },
    []
  );

  const initializeFromSession = useCallback(
    (sessionUser: SessionUserType) => {
      // אנחנו משתמשים בצורת העדכון הפונקציונלית של setData
      // כדי לקבל גישה למצב הקודם של הקונטקסט (prevData).
      setData((prevData) => {
        const isGoogleAcc = !!(
          sessionUser.source === UserSource.REGISTRATION &&
          sessionUser.accounts?.some(acc => acc.provider === 'google')
        );

        // המרת מגדר מהסשן לטיפוס הנכון
        const sessionGender: Gender | "" = sessionUser.profile?.gender || "";

        // אובייקט זה תמיד יכיל את הנתונים המעודכנים ביותר מהסשן,
        // וישמש לעדכון שדות הטופס בקונטקסט.
        const baseStateFromSession = {
          email: sessionUser.email || "",
          firstName: sessionUser.firstName || "",
          lastName: sessionUser.lastName || "",
          phone: sessionUser.phone || "",
          gender: sessionGender,
          birthDate: sessionUser.profile?.birthDate
            ? new Date(sessionUser.profile.birthDate).toISOString().split("T")[0]
            : "",
          maritalStatus: sessionUser.profile?.maritalStatus || "",
          height: sessionUser.profile?.height ?? undefined,
          occupation: sessionUser.profile?.occupation || "",
          education: sessionUser.profile?.education || "",
        };

        // תרחיש 1: משתמש חדש עם אימייל/סיסמה צריך לאמת מייל.
        // זהו תחילתו של תהליך, ולכן זה בסדר לאפס את המצב לנקודת התחלה נקייה.
        if (
          sessionUser.status === UserStatus.PENDING_EMAIL_VERIFICATION &&
          !isGoogleAcc &&
          !sessionUser.isVerified
        ) {
          return {
            ...initialRegistrationData, // איפוס המצב
            ...baseStateFromSession,    // מילוי במידע הבסיסי מהסשן
            isVerifyingEmailCode: true,
            emailForVerification: sessionUser.email,
            step: 1,
            isCompletingProfile: false,
            isGoogleSignup: false,
          };
        }

        // תרחיש 2: המשתמש נכנס לתהליך השלמת פרופיל בפעם הראשונה
        // (למשל, אחרי התחברות עם גוגל, או אחרי אימות מייל).
        // גם זו התחלה של תהליך, ואיפוס המצב הוא תקין.
        if (!sessionUser.isProfileComplete) {
          return {
            ...initialRegistrationData, // איפוס המצב
            ...baseStateFromSession,    // מילוי במידע הבסיסי מהסשן
            isCompletingProfile: true,
            isGoogleSignup: isGoogleAcc,
            step: 2, // התחל משלב פרטים אישיים
            isVerifyingEmailCode: false,
          };
        }

        // תרחיש 3: הפרופיל הושלם, אך הטלפון עדיין לא אומת.
        // >>> זהו התיקון הקריטי <<<
        // מצב זה מתרחש אחרי שהמשתמש לחץ "שלח" ב-OptionalInfoStep.
        // כאן אסור לנו לאפס את נתוני הטופס.
        if (sessionUser.isProfileComplete && !sessionUser.isPhoneVerified) {
          return {
            ...prevData, // *** התיקון: שמור את נתוני הטופס הקיימים (גובה, עיסוק וכו') ***
            ...baseStateFromSession, // עדכן את השדות עם המידע העדכני ביותר מה-DB
            isCompletingProfile: true,
            isGoogleSignup: isGoogleAcc,
            step: 4, // זה יעביר נכון לרכיב CompleteStep
            isVerifyingEmailCode: false,
          };
        }
        
        // תרחיש ברירת מחדל: המשתמש מאומת אך לא מתאים לאף תרחיש "השלמה" ספציפי.
        // לדוגמה, בריענון עמוד. אנחנו רק רוצים לסנכרן את הקונטקסט עם הסשן
        // מבלי לאפס את כל המצב (כמו השלב הנוכחי בתהליך).
        return { 
            ...prevData, // שמור על המצב הקיים של הקונטקסט
            ...baseStateFromSession, // ועדכן אותו עם מידע טרי מהסשן
            isGoogleSignup: isGoogleAcc,
        };
      });
    },
    [] // התלויות ריקות כי setData מובטח להיות יציב ולא נעשה שימוש ב-state חיצוני אחר.
  );

  const proceedToEmailVerification = useCallback((emailToVerify: string) => {
    setData((prev) => ({
      ...prev,
      isVerifyingEmailCode: true,
      emailForVerification: emailToVerify,
    }));
  }, []);

  const completeEmailVerification = useCallback(() => {
    setData((prev) => ({
      ...prev,
      isVerifyingEmailCode: false,
      emailForVerification: null,
      isCompletingProfile: true,
      step: 2,
    }));
  }, []);

  const exitEmailVerification = useCallback(() => {
    setData((prev) => ({
      ...prev,
      isVerifyingEmailCode: false,
      emailForVerification: null,
      step: 1,
    }));
  }, []);

  const value: RegistrationContextType = {
    data,
    setData,
    updateField,
    nextStep,
    prevStep,
    goToStep,
    resetForm,
    setGoogleSignup,
    initializeFromSession,
    proceedToEmailVerification,
    completeEmailVerification,
    exitEmailVerification,
  };

  return (
    <RegistrationContext.Provider value={value}>
      {children}
    </RegistrationContext.Provider>
  );
};

export const useRegistration = (): RegistrationContextType => {
  const context = useContext(RegistrationContext);
  if (context === undefined || Object.keys(context).every(
      (key) =>
        typeof context[key as keyof RegistrationContextType] === "function" &&
        context[key as keyof RegistrationContextType]
          .toString()
          .includes("RegistrationProvider not found")
    )
  ) {
    throw new Error(
      "useRegistration must be used within a RegistrationProvider"
    );
  }
  return context;
};
--- End of Content for RegistrationContext.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ResetPasswordForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/ResetPasswordForm.tsx
"use client";

import { useState, FormEvent, useEffect }
from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Lock, KeySquare, Loader2, AlertCircle, CheckCircle, Eye, EyeOff, Mail } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import Link from "next/link";

// Password validation function (similar to your RegisterForm)
const validatePassword = (value: string): string | null => {
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
  if (!passwordRegex.test(value)) {
    return "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר.";
  }
  return null;
};


export default function ResetPasswordForm() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [email, setEmail] = useState(""); // To prefill if passed, or keep empty
  const [otp, setOtp] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [passwordError, setPasswordError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);

  useEffect(() => {
    const emailFromQuery = searchParams.get("email");
    const tokenFromQuery = searchParams.get("token"); // If you decide to also prefill OTP via token

    if (emailFromQuery) {
      setEmail(emailFromQuery);
    }
    if (tokenFromQuery) { // This 'token' from query is the OTP
      setOtp(tokenFromQuery);
    }
  }, [searchParams]);


  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setPasswordError(null);
    setSuccessMessage(null);

    if (!email) {
        setError("כתובת המייל חסרה. אנא חזור להתחלה ונסה שנית.");
        setIsLoading(false);
        return;
    }
    if (!otp || otp.length !== 6 || !/^\d+$/.test(otp)) {
      setError("קוד האימות (OTP) חייב להיות בן 6 ספרות.");
      setIsLoading(false);
      return;
    }
    const passValidationError = validatePassword(newPassword);
    if (passValidationError) {
      setPasswordError(passValidationError);
      setIsLoading(false);
      return;
    }
    if (newPassword !== confirmPassword) {
      setError("הסיסמאות אינן תואמות.");
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch("/api/auth/reset-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, otp, newPassword }),
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || "אירעה שגיאה באיפוס הסיסמה.");
      }

      setSuccessMessage(data.message || "הסיסמה אופסה בהצלחה! כעת תוכל להתחבר עם הסיסמה החדשה.");
      // Clear fields on success
      setOtp("");
      setNewPassword("");
      setConfirmPassword("");
      // Optionally redirect after a delay or with a button
      setTimeout(() => {
        router.push("/auth/signin?reset=success");
      }, 3000);

    } catch (err) {
      setError(err instanceof Error ? err.message : "אירעה שגיאה לא צפויה.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
      <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>
      <div className="p-6 sm:p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold text-gray-800 mb-2">
            איפוס סיסמה
          </h1>
          <p className="text-gray-600 text-sm">
            הזן את קוד האימות (OTP) שקיבלת במייל ואת הסיסמה החדשה שלך.
          </p>
        </div>

        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
         {passwordError && !error && ( // Show passwordError only if general error is not present
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאת סיסמה</AlertTitle>
            <AlertDescription>{passwordError}</AlertDescription>
          </Alert>
        )}

        {successMessage && (
          <Alert variant="default" className="mb-4 bg-green-50 border-green-200 text-green-700">
            <CheckCircle className="h-4 w-4 text-green-600" />
            <AlertTitle>הצלחה!</AlertTitle>
            <AlertDescription>{successMessage} אתה מועבר לדף ההתחברות...</AlertDescription>
          </Alert>
        )}

        {!successMessage && ( // Only show form if no success message
          <form onSubmit={handleSubmit} className="space-y-5">
             <div className="space-y-1">
              <label htmlFor="email-reset" className="block text-sm font-medium text-gray-700">
                כתובת מייל (לאימות) <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type="email"
                  id="email-reset"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="you@example.com"
                  required
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  disabled={isLoading || !!searchParams.get("email")} // Disable if email came from query
                />
              </div>
            </div>
            <div className="space-y-1">
              <label htmlFor="otp-reset" className="block text-sm font-medium text-gray-700">
                קוד אימות (OTP) <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <KeySquare className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type="text"
                  id="otp-reset"
                  value={otp}
                  onChange={(e) => setOtp(e.target.value.replace(/[^0-9]/g, '').slice(0, 6))}
                  placeholder="xxxxxx"
                  maxLength={6}
                  required
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none tracking-widest text-center"
                  disabled={isLoading}
                  inputMode="numeric"
                />
              </div>
            </div>

            <div className="space-y-1">
              <label htmlFor="new-password-reset" className="block text-sm font-medium text-gray-700">
                סיסמה חדשה <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type={showPassword ? "text" : "password"}
                  id="new-password-reset"
                  value={newPassword}
                  onChange={(e) => {
                    setNewPassword(e.target.value);
                    const validationErr = validatePassword(e.target.value);
                    if (e.target.value && validationErr) setPasswordError(validationErr);
                    else setPasswordError(null);
                  }}
                  placeholder="לפחות 8 תווים, אות גדולה, קטנה ומספר"
                  required
                  className={`w-full pr-10 pl-10 py-3 border rounded-lg focus:ring-2 focus:outline-none ${
                    passwordError ? 'border-red-500 focus:ring-red-200' : 'border-gray-300 focus:ring-cyan-200 focus:border-cyan-500'
                  }`}
                  disabled={isLoading}
                />
                 <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700"
                    aria-label={showPassword ? "הסתר סיסמה" : "הצג סיסמה"}
                >
                    {showPassword ? <EyeOff className="h-5 w-5" /> : <Eye className="h-5 w-5" />}
                </button>
              </div>
              {!passwordError && <p className="mt-1 text-xs text-gray-500">חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר.</p>}
            </div>

            <div className="space-y-1">
              <label htmlFor="confirm-password-reset" className="block text-sm font-medium text-gray-700">
                אימות סיסמה חדשה <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type={showConfirmPassword ? "text" : "password"}
                  id="confirm-password-reset"
                  value={confirmPassword}
                  onChange={(e) => setConfirmPassword(e.target.value)}
                  placeholder="הזן את הסיסמה החדשה שוב"
                  required
                  className="w-full pr-10 pl-10 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  disabled={isLoading}
                />
                <button
                    type="button"
                    onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                    className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700"
                    aria-label={showConfirmPassword ? "הסתר סיסמה" : "הצג סיסמה"}
                >
                    {showConfirmPassword ? <EyeOff className="h-5 w-5" /> : <Eye className="h-5 w-5" />}
                </button>
              </div>
            </div>

            <Button
              type="submit"
              disabled={isLoading || !!passwordError || !otp || !newPassword || !confirmPassword || newPassword !== confirmPassword}
              className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2"
            >
              {isLoading ? (
                <>
                  <Loader2 className="h-5 w-5 animate-spin mr-2" />
                  <span>מאפס סיסמה...</span>
                </>
              ) : (
                "אפס סיסמה"
              )}
            </Button>
          </form>
        )}

        <div className="mt-6 text-center">
          <Link
            href="/auth/signin"
            className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline"
          >
            חזרה להתחברות
          </Link>
        </div>
      </div>
    </div>
  );
}
--- End of Content for ResetPasswordForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\SignInForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/SignInForm.tsx
"use client";

import { useState, useEffect, FormEvent } from "react";
import { useSearchParams, useRouter } from "next/navigation"; // Added useRouter
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Mail, Lock, AlertCircle, Loader2 } from "lucide-react"; // Added Loader2
import Link from "next/link";

export default function SignInForm() {
  const router = useRouter(); // Initialize useRouter
  const searchParams = useSearchParams();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);

  // Check for error from URL (e.g., after failed NextAuth sign-in attempt)
  useEffect(() => {
    const errorMessage = searchParams.get("error");
    const resetSuccess = searchParams.get("reset"); // Check for password reset success

    if (resetSuccess === "success") {
        // Optionally show a success message, e.g., using a toast or a temporary state
        // For now, we just clear any previous errors.
        setError(""); // Clear any auth errors if coming from successful reset
    }

    if (errorMessage) {
      switch (errorMessage) {
        case "CredentialsSignin":
          setError("אימייל או סיסמה אינם נכונים. אנא נסה שנית.");
          break;
        case "OAuthAccountNotLinked":
          setError(
            "חשבון זה כבר מקושר באמצעות ספק אחר. אנא התחבר באמצעות הספק המקורי."
          );
          break;
        // Add more specific error messages as needed from NextAuth errors
        default:
          setError(`אירעה שגיאה בהתחברות (${errorMessage}). נסה שנית.`);
      }
    }
  }, [searchParams]);

  // Pre-fill email if provided in URL (e.g., after registration or password reset notice)
  useEffect(() => {
    const emailParam = searchParams.get("email");
    if (emailParam) {
      setEmail(emailParam);
    }
  }, [searchParams]);

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError(""); // Clear previous errors
    setIsLoading(true);

    if (!email || !password) {
      setError("אנא הזן אימייל וסיסמה.");
      setIsLoading(false);
      return;
    }

    try {
      localStorage.setItem("last_user_email", email); // Store email for potential reuse

      const result = await signIn("credentials", {
        email: email.toLowerCase(), // Send normalized email
        password,
        redirect: false, // Handle redirect manually based on result
      });

      if (result?.error) {
        console.error("Sign-in error from NextAuth:", result.error);
        if (result.error === "CredentialsSignin") {
          setError("אימייל או סיסמה אינם נכונים.");
        } else if (result.error === "OAuthAccountNotLinked") {
          setError("חשבון זה מקושר לספק אחר (למשל Google). אנא התחבר באמצעותו.");
        }
        else {
          setError(result.error || "אירעה שגיאה בהתחברות, נסה שנית.");
        }
      } else if (result?.ok && result?.url) {
        // Successful sign-in, NextAuth would typically redirect if redirect:true
        // Since redirect:false, we can manually push or let NextAuth's redirect callback handle it.
        // The redirect callback in authOptions will determine the final destination.
        // If it reaches here, it means NextAuth didn't auto-redirect.
        router.push(result.url); // Or a default like '/profile'
        console.log("Sign-in successful, NextAuth redirecting to:", result.url);
      } else if (result && !result.ok && !result.error) {
        console.warn("Sign-in attempt did not result in an error or a redirect URL:", result);
        setError("תהליך ההתחברות לא הושלם כראוי. נסה שנית.");
      } else {
        // If signIn was successful but no specific URL (might happen with redirect: false if callback doesn't provide one)
        // This usually means the redirect callback in authOptions should handle it.
        // For safety, you might redirect to a default page or check session.
        router.push('/profile'); // Default redirect
      }
    } catch (err) {
      console.error("Unexpected sign-in error in handleSubmit:", err);
      setError("אירעה שגיאה לא צפויה בהתחברות, נסה שנית.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    setIsGoogleLoading(true);
    setError("");
    localStorage.setItem("google_auth_in_progress", "true");
    localStorage.setItem("auth_method", "google");

    try {
      // NextAuth handles the redirect. The callbackUrl is where Google sends the user back to your app.
      // Then, NextAuth's main redirect callback in auth.ts determines the final destination.
      await signIn("google", { callbackUrl: "/auth/google-callback" });
      // If signIn is successful, browser redirects, code below this await might not run if redirection happens.
    } catch (error) {
      console.error("Google sign-in error:", error);
      setError("אירעה שגיאה בהתחברות עם גוגל. נסה שנית.");
      setIsGoogleLoading(false); // Important if error occurs before redirection
    }
    // setIsGoogleLoading(false); // Typically not reached if redirect occurs
  };

  return (
    <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
      <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>

      <div className="p-6 sm:p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold text-gray-800 mb-2">
            התחברות למערכת
          </h1>
          <p className="text-gray-600">
            ברוכים השבים! המשיכו למצוא את השידוך המושלם.
          </p>
        </div>

        {error && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0" />
            <p className="text-red-600 text-sm">{error}</p>
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4 mb-6">
          <div className="space-y-1">
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              אימייל
            </label>
            <div className="relative">
              <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
              <input
                type="email"
                id="email"
                name="email"
                autoComplete="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                placeholder="you@example.com"
                required
                disabled={isLoading || isGoogleLoading}
              />
            </div>
          </div>

          <div className="space-y-1">
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700"
            >
              סיסמה
            </label>
            <div className="relative">
              <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
              <input
                type="password"
                id="password"
                name="password"
                autoComplete="current-password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                placeholder="הסיסמה שלך"
                required
                disabled={isLoading || isGoogleLoading}
              />
            </div>
            <div className="flex justify-end">
              <Link
                href="/auth/forgot-password" // Link to the new forgot password page
                className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline mt-1"
              >
                שכחת סיסמה?
              </Link>
            </div>
          </div>

          <Button
            type="submit"
            disabled={isLoading || isGoogleLoading}
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2 relative overflow-hidden group"
          >
            {isLoading ? (
              <>
                <Loader2 className="h-5 w-5 animate-spin mr-1" /> {/* Using Loader2 */}
                <span>מתחבר...</span>
              </>
            ) : (
              <>
                <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
                <span>התחברות</span>
              </>
            )}
          </Button>
        </form>

        <div className="relative mb-6">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">או</span>
          </div>
        </div>

        <Button
          type="button"
          onClick={handleGoogleSignIn}
          disabled={isLoading || isGoogleLoading}
          variant="outline"
          size="lg"
          className="w-full relative border-2 border-gray-300 hover:border-gray-400 py-3 rounded-xl flex items-center justify-center gap-3 group"
        >
          {isGoogleLoading ? (
            <>
              <Loader2 className="animate-spin h-5 w-5 mr-1" /> {/* Using Loader2 */}
              <span>מתחבר עם Google...</span>
            </>
          ) : (
            <>
              <svg className="h-5 w-5" viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  fill="#4285F4"
                />
                <path
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  fill="#34A853"
                />
                <path
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  fill="#FBBC05"
                />
                <path
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  fill="#EA4335"
                />
              </svg>
              <span className="text-gray-700 font-medium">
                התחברות עם Google
              </span>
            </>
          )}
        </Button>

        <div className="mt-6 text-center">
          <p className="text-gray-600 text-sm">
            אין לך חשבון עדיין?{" "}
            <Link
              href="/auth/register"
              className="text-cyan-600 font-medium hover:text-cyan-700 hover:underline"
            >
              הרשמה עכשיו
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
--- End of Content for SignInForm.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\BasicInfoStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/BasicInfoStep.tsx
"use client";

import { useState, useEffect } from "react";
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import {
  ArrowLeft,
  ArrowRight,
  User,
  Mail,
  Lock,
  AlertCircle,
  Loader2,
} from "lucide-react";
import { motion } from "framer-motion";
import ConsentCheckbox from "../ConsentCheckbox"; // <-- ייבוא הקומפוננטה החדשה

const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
  return email.trim() !== "" && emailRegex.test(email);
};
const isValidPassword = (password: string): boolean => {
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
  return passwordRegex.test(password);
};

const BasicInfoStep: React.FC = () => {
  const { data, updateField, prevStep, proceedToEmailVerification } =
    useRegistration();
  const [passwordVisible, setPasswordVisible] = useState(false);
  const [passwordError, setPasswordError] = useState("");
  const [emailError, setEmailError] = useState("");
  const [isFormValid, setIsFormValid] = useState(false);

  const [isLoading, setIsLoading] = useState(false);
  const [apiError, setApiError] = useState<string | null>(null);

  // --- הוספת State עבור תיבת ההסכמה ---
  const [consentChecked, setConsentChecked] = useState(false);
  const [consentError, setConsentError] = useState<string | null>(null);

  useEffect(() => {
    const isEmailValid = isValidEmail(data.email);
    const isPasswordValid = isValidPassword(data.password);
    const isNameValid =
      data.firstName.trim().length > 0 && data.lastName.trim().length > 0;

    setEmailError(
      data.email.trim() !== "" && !isEmailValid ? "כתובת אימייל לא תקינה" : ""
    );
    setPasswordError(
      data.password.trim() !== "" && !isPasswordValid
        ? "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר"
        : ""
    );

    // --- עדכון תנאי תקינות הטופס ---
    setIsFormValid(
      isEmailValid &&
        isPasswordValid &&
        isNameValid &&
        consentChecked && // <-- הוספת בדיקת הסכמה
        !isLoading
    );
  }, [
    data.email,
    data.password,
    data.firstName,
    data.lastName,
    consentChecked, // <-- הוספת תלות
    isLoading,
  ]);

  const handleEmailBlur = () => {
    if (data.email.trim() === "") {
      setEmailError("");
    } else if (!isValidEmail(data.email)) {
      setEmailError("כתובת אימייל לא תקינה");
    } else {
      setEmailError("");
    }
  };
  const handlePasswordBlur = () => {
    if (data.password.trim() === "") {
      setPasswordError("");
    } else if (!isValidPassword(data.password)) {
      setPasswordError(
        "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר"
      );
    } else {
      setPasswordError("");
    }
  };

  const handleRegisterSubmit = async () => {
    setConsentError(null); // איפוס שגיאת הסכמה
    if (!consentChecked) {
      setConsentError("חובה לאשר את תנאי השימוש ומדיניות הפרטיות.");
      setIsFormValid(false); // ודא שהטופס לא יישלח
      return;
    }

    const isEmailValid = isValidEmail(data.email);
    const isPasswordValid = isValidPassword(data.password);
    const isFirstNameValid = data.firstName.trim().length > 0;
    const isLastNameValid = data.lastName.trim().length > 0;

    if (
      !isEmailValid ||
      !isPasswordValid ||
      !isFirstNameValid ||
      !isLastNameValid
    ) {
      setApiError("אנא מלא את כל השדות הנדרשים בצורה תקינה.");
      if (!isEmailValid && data.email.trim() !== "") handleEmailBlur();
      else if (data.email.trim() === "") setEmailError("שדה אימייל הוא חובה");
      if (!isPasswordValid && data.password.trim() !== "") handlePasswordBlur();
      else if (data.password.trim() === "")
        setPasswordError("שדה סיסמה הוא חובה");
      return;
    }
    if (emailError || passwordError) {
      setApiError("אנא תקן את השגיאות המסומנות.");
      return;
    }

    setIsLoading(true);
    setApiError(null);

    try {
      // כאן, ה-API /api/auth/register אמור לשמור את termsAndPrivacyAcceptedAt: new Date()
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          email: data.email,
          password: data.password,
          firstName: data.firstName,
          lastName: data.lastName,
          // אין צורך לשלוח את סטטוס ההסכמה, עצם השליחה מפה (לאחר שהכפתור הופעל) מעידה על הסכמה.
          // ה-API בצד השרת יקבע את חתימת הזמן.
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(
          result.error || `שגיאה ${response.status}: ${response.statusText}`
        );
      }

      if (result.success && result.email) {
        proceedToEmailVerification(result.email);
      } else {
        console.error(
          "Registration API success but no email returned or success false:",
          result
        );
        setApiError(
          result.error || "אירעה שגיאה במעבר לשלב אימות המייל. אנא נסה שנית."
        );
      }
    } catch (error) {
      console.error("Registration API error:", error);
      setApiError(
        error instanceof Error ? error.message : "אירעה שגיאה בלתי צפויה בהרשמה"
      );
    } finally {
      setIsLoading(false);
    }
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.1 } },
  };
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.5 } },
  };

  return (
    <motion.div
      className="space-y-5"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      {apiError && (
        <motion.div variants={itemVariants}>
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה בהרשמה</AlertTitle>
            <AlertDescription>{apiError}</AlertDescription>
          </Alert>
        </motion.div>
      )}

      <motion.h2
        className="text-xl font-bold text-gray-800 mb-4"
        variants={itemVariants}
      >
        פרטי חשבון
      </motion.h2>

      <motion.div variants={itemVariants} className="space-y-4">
        {/* Email Field */}
        <div className="space-y-1">
          <label
            htmlFor="emailBasic"
            className="block text-sm font-medium text-gray-700"
          >
            אימייל <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type="email"
              id="emailBasic"
              value={data.email}
              onChange={(e) => updateField("email", e.target.value)}
              onBlur={handleEmailBlur}
              placeholder="you@example.com"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } ${
                emailError
                  ? "border-red-500 focus:ring-red-200"
                  : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
            />
            {emailError && !isLoading && (
              <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                <AlertCircle className="h-5 w-5 text-red-500" />
              </div>
            )}
          </div>
          {emailError && (
            <p className="text-red-500 text-xs mt-1">{emailError}</p>
          )}
        </div>

        {/* Password Field */}
        <motion.div variants={itemVariants} className="space-y-1">
          <label
            htmlFor="passwordBasic"
            className="block text-sm font-medium text-gray-700"
          >
            סיסמה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type={passwordVisible ? "text" : "password"}
              id="passwordBasic"
              value={data.password}
              onChange={(e) => updateField("password", e.target.value)}
              onBlur={handlePasswordBlur}
              placeholder="לפחות 8 תווים"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-10 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } ${
                passwordError
                  ? "border-red-300 focus:ring-red-200"
                  : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
            />
            <button
              type="button"
              onClick={() => setPasswordVisible(!passwordVisible)}
              className="absolute inset-y-0 left-0 flex items-center pl-3 focus:outline-none"
              aria-label={passwordVisible ? "הסתר סיסמה" : "הצג סיסמה"}
            >
              <span className="text-gray-500">
                {passwordVisible ? "🙈" : "👁️"}
              </span>
            </button>
            {passwordError && !isLoading && (
              <div className="absolute inset-y-0 left-10 flex items-center pl-3 pointer-events-none">
                <AlertCircle className="h-5 w-5 text-red-500" />
              </div>
            )}
          </div>
          {passwordError && (
            <p className="text-red-500 text-xs mt-1">{passwordError}</p>
          )}
          {!passwordError && (
            <p className="text-gray-500 text-xs mt-1">
              הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה באנגלית, אות קטנה
              באנגלית ומספר.
            </p>
          )}
        </motion.div>

        {/* First Name Field */}
        <motion.div variants={itemVariants} className="space-y-1">
          <label
            htmlFor="firstNameBasic"
            className="block text-sm font-medium text-gray-700"
          >
            שם פרטי <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <User className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type="text"
              id="firstNameBasic"
              value={data.firstName}
              onChange={(e) => updateField("firstName", e.target.value)}
              placeholder="ישראל"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } border-gray-300 focus:ring-cyan-200 focus:border-cyan-500`}
            />
          </div>
        </motion.div>

        {/* Last Name Field */}
        <motion.div variants={itemVariants} className="space-y-1">
          <label
            htmlFor="lastNameBasic"
            className="block text-sm font-medium text-gray-700"
          >
            שם משפחה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <User className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type="text"
              id="lastNameBasic"
              value={data.lastName}
              onChange={(e) => updateField("lastName", e.target.value)}
              placeholder="ישראלי"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } border-gray-300 focus:ring-cyan-200 focus:border-cyan-500`}
            />
          </div>
        </motion.div>
      </motion.div>

      {/* --- הוספת תיבת ההסכמה --- */}
      <motion.div variants={itemVariants} className="mt-6">
        <ConsentCheckbox
          checked={consentChecked}
          onChange={(isChecked) => {
            setConsentChecked(isChecked);
            if (isChecked) setConsentError(null);
          }}
          error={consentError}
        />
      </motion.div>

      <motion.div
        variants={itemVariants}
        className="flex justify-between pt-4 mt-6 border-t border-gray-200"
      >
        <Button
          type="button"
          onClick={prevStep}
          variant="outline"
          className="flex items-center gap-2 border-gray-300"
          disabled={isLoading}
        >
          <ArrowRight className="h-4 w-4" /> חזרה
        </Button>

        <Button
          type="button"
          onClick={handleRegisterSubmit}
          disabled={!isFormValid || isLoading}
          className={`flex items-center gap-2 min-w-[200px] justify-center text-white font-medium px-4 py-2.5 rounded-lg transition-opacity
            ${
              isFormValid && !isLoading
                ? "bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-md hover:shadow-lg"
                : "bg-gray-300 cursor-not-allowed"
            }`}
        >
          {isLoading ? (
            <>
              <Loader2 className="h-5 w-5 animate-spin mr-2" />
              <span>יוצר חשבון...</span>
            </>
          ) : (
            <>
              <span>צור חשבון והמשך לאימות</span>
              <ArrowLeft className="h-4 w-4" />
            </>
          )}
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default BasicInfoStep;
--- End of Content for BasicInfoStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\CompleteStep.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  ArrowLeft,
  CheckCircle,
  Mail,
  User,
  Phone,
  ShieldQuestion,
} from "lucide-react";
import { motion } from "framer-motion";
import Link from "next/link";
import { useSession } from "next-auth/react";
// ודא שהנתיב לייבוא נכון. יכול להיות שזה ישירות מ-@prisma/client אם ייצאת אותו משם
import { UserStatus } from "@prisma/client"; // אם זה הנתיב שבו UserStatus מוגדר
import type { User as SessionUserType } from "@/types/next-auth"; // ... (variants נשארים אותו דבר) ...
const containerVariants = {
  /* ... */
};
const itemVariants = {
  /* ... */
};
const circleVariants = {
  /* ... */
};

const CompleteStep: React.FC = () => {
  const router = useRouter();
  const { data: session, status: sessionStatus } = useSession();

  const navigateToProfile = () => router.push("/profile/me");
  const navigateToQuestionnaire = () => router.push("/questionnaire");
  const navigateToVerifyPhone = () => router.push("/auth/verify-phone");
  const navigateToCompleteProfile = () => router.push("/auth/complete-profile");

  if (sessionStatus === "loading") {
    return (
      <div className="flex justify-center items-center h-40">
        <p className="text-lg text-gray-600">טוען נתונים...</p>
      </div>
    );
  }

  if (!session?.user) {
    router.push("/auth/signin");
    return null;
  }

  const user = session.user as SessionUserType; // ודא ש-SessionUserType מיובא נכון

  // תרחיש 1: צריך לאמת אימייל (ורק אם ההרשמה היא עם אימייל/סיסמה)
  // נניח ש-user.accounts הוא מערך של PrismaAccount
  const isCredentialsUser = user.accounts?.every(
    (acc) => acc.provider === "credentials"
  );

  // *******************************************************************
  // כאן השינוי: השתמש בערכים מה-enum UserStatus שלך
  // *******************************************************************
  if (
    !user.isVerified &&
    isCredentialsUser &&
    user.status === UserStatus.PENDING_EMAIL_VERIFICATION
  ) {
    return (
      <motion.div
        className="space-y-6 text-center"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* ... תוכן לאימות מייל ... */}
        <motion.div
          className="flex justify-center mb-6"
          variants={circleVariants}
        >
          <div className="relative w-28 h-28 rounded-full bg-gradient-to-r from-cyan-500 to-pink-500 flex items-center justify-center">
            <motion.div
              className="absolute inset-1 bg-white rounded-full flex items-center justify-center"
              animate={{ scale: [0.6, 1] }}
              transition={{ duration: 0.5, delay: 0.5 }}
            >
              <Mail className="h-14 w-14 text-cyan-500" />
            </motion.div>
          </div>
        </motion.div>
        <motion.h2
          className="text-2xl font-bold text-gray-800"
          variants={itemVariants}
        >
          אימות כתובת המייל
        </motion.h2>
        <motion.div variants={itemVariants}>
          <div className="p-4 bg-cyan-50 rounded-lg mb-5">
            <div className="flex items-center gap-2 text-cyan-700 mb-2 justify-center">
              <Mail className="h-5 w-5" />
              <h3 className="font-medium">אנא אמת את כתובת המייל שלך</h3>
            </div>
            <p className="text-sm text-cyan-600">
              שלחנו לך מייל לכתובת{" "}
              <span className="font-bold">{user.email}</span>.
              <br />
              אנא לחץ על הקישור במייל כדי להשלים את תהליך האימות.
            </p>
          </div>
        </motion.div>
      </motion.div>
    );
  }

  // תרחיש 2: צריך להשלים פרופיל
  if (user.isVerified && !user.isProfileComplete) {
    return (
      <motion.div
        className="space-y-6 text-center"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* ... תוכן להשלמת פרופיל ... */}
        <motion.div
          className="flex justify-center mb-6"
          variants={circleVariants}
        >
          <div className="relative w-28 h-28 rounded-full bg-gradient-to-r from-cyan-500 to-pink-500 flex items-center justify-center">
            <motion.div
              className="absolute inset-1 bg-white rounded-full flex items-center justify-center"
              animate={{ scale: [0.6, 1] }}
              transition={{ duration: 0.5, delay: 0.5 }}
            >
              <User className="h-14 w-14 text-cyan-500" />
            </motion.div>
          </div>
        </motion.div>
        <motion.h2
          className="text-2xl font-bold text-gray-800"
          variants={itemVariants}
        >
          השלמת פרטי פרופיל
        </motion.h2>
        <motion.p className="text-gray-600 mb-6" variants={itemVariants}>
          כדי שנוכל להתאים לך את השידוכים הטובים ביותר, אנא השלם את פרטי הפרופיל
          שלך.
        </motion.p>
        <motion.div variants={itemVariants} className="flex flex-col gap-4">
          <Button
            onClick={navigateToCompleteProfile}
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 rounded-lg shadow-lg flex items-center justify-center gap-2"
          >
            <User className="h-5 w-5 text-white" />
            <span className="text-white">להשלמת הפרופיל</span>
          </Button>
        </motion.div>
      </motion.div>
    );
  }

  // תרחיש 3: צריך לאמת טלפון
  // *******************************************************************
  // כאן השינוי: השתמש בערכים מה-enum UserStatus שלך
  // יכול להיות שגם תרצה לבדוק user.status === UserStatus.PENDING_PHONE_VERIFICATION
  // *******************************************************************
  if (
    user.isVerified &&
    user.isProfileComplete &&
    !user.isPhoneVerified &&
    user.status === UserStatus.PENDING_PHONE_VERIFICATION
  ) {
    return (
      <motion.div /* ... */>
        {/* ... הצגת אייקון, כותרת, וטקסט ... */}
        <motion.div variants={itemVariants} className="flex flex-col gap-4">
          <Button
            onClick={navigateToVerifyPhone} // הפונקציה הזו עושה router.push('/auth/verify-phone')
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 rounded-lg shadow-lg flex items-center justify-center gap-2"
          >
            <Phone className="h-5 w-5 text-white" />
            <span className="text-white">לאימות מספר הטלפון</span>
          </Button>
        </motion.div>
      </motion.div>
    );
  }

  // תרחיש 4: הכל הושלם! (או user.status === UserStatus.ACTIVE)
  return (
    <motion.div
      className="space-y-6 text-center"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      {/* ... תוכן להכל הושלם ... */}
      <motion.div
        className="flex justify-center mb-6"
        variants={circleVariants}
      >
        <div className="relative w-28 h-28 rounded-full bg-gradient-to-r from-cyan-500 to-pink-500 flex items-center justify-center">
          <motion.div
            className="absolute inset-1 bg-white rounded-full flex items-center justify-center"
            animate={{ scale: [0.6, 1] }}
            transition={{ duration: 0.5, delay: 0.5 }}
          >
            <CheckCircle className="h-14 w-14 text-green-500" />
          </motion.div>
        </div>
      </motion.div>
      <motion.h2
        className="text-2xl font-bold text-gray-800"
        variants={itemVariants}
      >
        ההרשמה והפרופיל הושלמו בהצלחה!
      </motion.h2>
      <motion.div variants={itemVariants}>
        <p className="text-gray-600 mb-6">
          מעולה! כל הפרטים שלך מאומתים ומוכנים.
          <br />
          עכשיו תוכל להתחיל בתהליך מציאת השידוך.
        </p>
      </motion.div>
      <motion.div variants={itemVariants} className="flex flex-col gap-4">
        <Button
          onClick={navigateToProfile}
          className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 rounded-lg shadow-lg flex items-center justify-center gap-2 group relative overflow-hidden"
        >
          <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
          <User className="h-5 w-5 text-white" />
          <span className="text-white">לפרופיל שלי</span>
          <ArrowLeft className="h-4 w-4 text-white opacity-0 group-hover:opacity-100 transform translate-x-2 group-hover:translate-x-0 transition-all duration-300" />
        </Button>
        <Button
          onClick={navigateToQuestionnaire}
          variant="outline"
          className="w-full py-3 border-2 border-cyan-200 text-cyan-600 hover:bg-cyan-50 hover:border-cyan-300 flex items-center justify-center gap-2"
        >
          <ShieldQuestion className="h-5 w-5" />
          <span>למילוי שאלון התאמה</span>
          <ArrowLeft className="h-4 w-4" />
        </Button>
        <Link
          href="/"
          className="text-sm text-gray-500 hover:text-gray-700 hover:underline mt-2"
        >
          חזרה לדף הבית
        </Link>
      </motion.div>
    </motion.div>
  );
};

export default CompleteStep;
--- End of Content for CompleteStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\EmailVerificationCodeStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/EmailVerificationCodeStep.tsx
"use client";

import { useState, useRef, KeyboardEvent, useEffect, FormEvent } from "react";
import { useRouter } from "next/navigation";
import { signIn } from "next-auth/react"; // נשאר רק signIn, useSession לא בשימוש ישיר כאן
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, AlertCircle, MailCheck, ArrowRight } from "lucide-react";
import { motion } from "framer-motion";
import { Input } from "@/components/ui/input";

const OTP_LENGTH = 6;

const EmailVerificationCodeStep: React.FC = () => {
  const {
    data: registrationData,
    exitEmailVerification: goBackToBasicInfo,
    completeEmailVerification, // הוספת הפונקציה מהקונטקסט
  } = useRegistration();

  const router = useRouter();

  const [otp, setOtp] = useState<string[]>(new Array(OTP_LENGTH).fill(""));
  const [isLoading, setIsLoading] = useState(false);
  const [isResending, setIsResending] = useState(false);
  const [apiError, setApiError] = useState<string | null>(null);
  const [resendMessage, setResendMessage] = useState<string | null>(null);
  const inputRefs = useRef<(HTMLInputElement | null)[]>([]);

  useEffect(() => {
    if (inputRefs.current[0]) {
      inputRefs.current[0]?.focus();
    }
  }, []);

  const handleChange = (element: HTMLInputElement, index: number) => {
    const value = element.value.replace(/[^0-9]/g, "");

    if (value.length > 1 && index < OTP_LENGTH) {
      const chars = value.split("");
      let currentIdx = index;
      const newOtp = [...otp];

      for (
        let i = 0;
        i < chars.length && currentIdx < OTP_LENGTH;
        i++, currentIdx++
      ) {
        newOtp[currentIdx] = chars[i];
      }
      setOtp(newOtp);
      const nextFocusIndex = Math.min(index + chars.length, OTP_LENGTH - 1);
      if (inputRefs.current[nextFocusIndex] && chars.length > 0) {
        setTimeout(() => inputRefs.current[nextFocusIndex]?.focus(), 0);
      }
      return;
    }

    const newOtp = [...otp];
    newOtp[index] = value;
    setOtp(newOtp);

    if (value && index < OTP_LENGTH - 1) {
      if (inputRefs.current[index + 1]) {
        inputRefs.current[index + 1]?.focus();
      }
    }
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>, index: number) => {
    if (e.key === "Backspace") {
      e.preventDefault();
      const newOtp = [...otp];
      if (newOtp[index]) {
        newOtp[index] = "";
        setOtp(newOtp);
      } else if (index > 0) {
        if (inputRefs.current[index - 1]) {
          inputRefs.current[index - 1]?.focus();
        }
      }
    } else if (e.key === "ArrowLeft" && index > 0) {
      e.preventDefault();
      if (inputRefs.current[index - 1]) {
        inputRefs.current[index - 1]?.focus();
      }
    } else if (e.key === "ArrowRight" && index < OTP_LENGTH - 1) {
      e.preventDefault();
      if (inputRefs.current[index + 1]) {
        inputRefs.current[index + 1]?.focus();
      }
    }
  };

  const handleFormSubmit = async (e: FormEvent) => {
    e.preventDefault();
    const enteredCode = otp.join("");
    if (enteredCode.length !== OTP_LENGTH) {
      setApiError(`הקוד חייב להכיל ${OTP_LENGTH} ספרות.`);
      return;
    }

    setIsLoading(true);
    setApiError(null);
    setResendMessage(null);

    try {
      // 1. Verify the code with the backend
      console.log(
        "CLIENT LOG: Submitting OTP to API. Email:",
        registrationData.emailForVerification
      );
      const response = await fetch("/api/auth/verify-email-code", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          email: registrationData.emailForVerification,
          code: enteredCode,
        }),
      });

      const result = await response.json();
      console.log("CLIENT LOG: API response for /verify-email-code:", result);

      if (!response.ok || !result.success || !result.authToken) {
        throw new Error(
          result.error || "שגיאה באימות הקוד מה-API או שלא הוחזר טוקן התחברות."
        );
      }

      const authToken = result.authToken;
      console.log(
        "CLIENT LOG: Email code verified with API. AuthToken received. Attempting auto-signin..."
      );

      // 2. Attempt auto-signin with the received authToken
      const signInResult = await signIn("email-verified-autologin", {
        authToken: authToken,
        redirect: false, // חשוב! אנחנו נטפל בהפניה ידנית
      });

      console.log("CLIENT LOG: Auto-signin attempt result:", signInResult);

      if (signInResult?.ok) {
        // ההתחברות האוטומטית הצליחה, והסשן נוצר/עודכן
        console.log(
          "CLIENT LOG: Auto-signin successful. Calling completeEmailVerification and navigating to /auth/register."
        );
        completeEmailVerification(); // <-- קריאה לפונקציה מהקונטקסט
        router.push("/auth/register");
        // אין צורך לקרוא ל-setIsLoading(false) כאן כי הקומפוננטה תעשה unmount
      } else {
        // ההתחברות האוטומטית נכשלה
        console.error("CLIENT LOG: Auto-signin failed.", signInResult?.error);
        setApiError(
          `אימות המייל הצליח, אך נתקלנו בבעיה בהתחברות האוטומטית: ${
            signInResult?.error || "שגיאה לא ידועה"
          }. אנא נסה להתחבר ידנית.`
        );
        setIsLoading(false); // אפשר למשתמש לנסות שוב או לנקוט פעולה אחרת
      }
    } catch (error) {
      console.error(
        "CLIENT LOG: Error during email verification process or auto-signin:",
        error
      );
      setApiError(
        error instanceof Error
          ? error.message
          : "אירעה שגיאה בלתי צפויה בתהליך האימות"
      );
      setOtp(new Array(OTP_LENGTH).fill(""));
      if (inputRefs.current[0]) {
        inputRefs.current[0]?.focus();
      }
      setIsLoading(false);
    }
  };

  const handleResendCode = async () => {
    setIsResending(true);
    setApiError(null);
    setResendMessage(null);

    try {
      console.log(
        "CLIENT LOG: Requesting to resend verification code for email:",
        registrationData.emailForVerification
      );
      const response = await fetch("/api/auth/resend-verification-code", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: registrationData.emailForVerification }),
      });
      const result = await response.json();
      console.log(
        "CLIENT LOG: API response for /resend-verification-code:",
        result
      );

      if (!response.ok || !result.success) {
        throw new Error(result.error || "שגיאה בשליחה חוזרת של הקוד");
      }
      setResendMessage(result.message || "קוד חדש נשלח בהצלחה.");
      setOtp(new Array(OTP_LENGTH).fill(""));
      if (inputRefs.current[0]) {
        inputRefs.current[0]?.focus();
      }
    } catch (error) {
      console.error("CLIENT LOG: Error during resend code:", error);
      setApiError(
        error instanceof Error ? error.message : "אירעה שגיאה בשליחה חוזרת"
      );
    } finally {
      setIsResending(false);
    }
  };

  const handlePaste = (e: React.ClipboardEvent<HTMLDivElement>) => {
    const pasteData = e.clipboardData
      .getData("text")
      .replace(/[^0-9]/g, "")
      .slice(0, OTP_LENGTH);

    if (pasteData.length > 0) {
      e.preventDefault();
      const newOtp = new Array(OTP_LENGTH).fill("");
      for (let i = 0; i < pasteData.length; i++) {
        newOtp[i] = pasteData[i];
      }
      setOtp(newOtp);
      const focusIndex = Math.min(pasteData.length, OTP_LENGTH - 1);
      if (inputRefs.current[focusIndex]) {
        setTimeout(() => inputRefs.current[focusIndex]?.focus(), 0);
      }
    }
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.1 } },
  };
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.5 } },
  };

  return (
    <motion.div
      className="space-y-6 text-center p-4 sm:p-6"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.div variants={itemVariants}>
        <MailCheck className="h-12 w-12 text-cyan-500 mx-auto mb-3" />
        <h2 className="text-xl sm:text-2xl font-bold text-gray-800">
          אימות כתובת מייל
        </h2>
        <p className="text-gray-600 mt-2 text-sm sm:text-base">
          שלחנו קוד אימות בן {OTP_LENGTH} ספרות לכתובת{" "}
          <strong className="font-semibold text-gray-700">
            {registrationData.emailForVerification || "האימייל שלך"}
          </strong>
          .
          <br />
          אנא הזן את הקוד שקיבלת.
        </p>
      </motion.div>

      {apiError && (
        <motion.div variants={itemVariants}>
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{apiError}</AlertDescription>
          </Alert>
        </motion.div>
      )}
      {resendMessage && !apiError && (
        <motion.div variants={itemVariants}>
          <Alert
            variant="default"
            className="bg-green-50 border-green-300 text-green-700"
          >
            <MailCheck className="h-4 w-4 text-green-600" />
            <AlertTitle>הודעה</AlertTitle>
            <AlertDescription>{resendMessage}</AlertDescription>
          </Alert>
        </motion.div>
      )}

      <form onSubmit={handleFormSubmit}>
        <motion.div
          variants={itemVariants}
          className="flex justify-center space-x-2 sm:space-x-3 rtl:space-x-reverse"
          dir="ltr"
          onPaste={handlePaste}
        >
          {otp.map((digit, index) => (
            <Input
              key={index}
              type="text"
              maxLength={1}
              value={digit}
              onChange={(e) =>
                handleChange(e.target as HTMLInputElement, index)
              }
              onKeyDown={(e) =>
                handleKeyDown(e as KeyboardEvent<HTMLInputElement>, index)
              }
              ref={(el) => {
                inputRefs.current[index] = el;
              }}
              className="w-10 h-12 sm:w-12 sm:h-14 text-center text-lg sm:text-xl font-semibold border-2 border-gray-300 rounded-md focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500 outline-none transition-colors disabled:bg-gray-100 appearance-none"
              disabled={isLoading || isResending}
              aria-label={`OTP digit ${index + 1}`}
              autoComplete="one-time-code"
              inputMode="numeric"
            />
          ))}
        </motion.div>

        <motion.div variants={itemVariants} className="space-y-4 mt-6">
          <Button
            type="submit"
            disabled={
              isLoading || isResending || otp.join("").length !== OTP_LENGTH
            }
            className="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600"
          >
            {isLoading ? (
              <>
                <Loader2 className="h-5 w-5 animate-spin" />
                <span>מאמת ומתחבר...</span>
              </>
            ) : (
              "אמת קוד והמשך להשלמת פרופיל"
            )}
          </Button>
        </motion.div>
      </form>

      <motion.div
        variants={itemVariants}
        className="text-sm text-gray-500 mt-2"
      >
        לא קיבלת קוד?{" "}
        <Button
          type="button"
          variant="link"
          onClick={handleResendCode}
          disabled={isLoading || isResending}
          className="p-0 h-auto text-cyan-600 hover:text-cyan-700 disabled:text-gray-400"
        >
          {isResending ? (
            <>
              <Loader2 className="h-4 w-4 animate-spin ml-1 rtl:mr-1 rtl:ml-0" />
              <span>שולח קוד חדש...</span>
            </>
          ) : (
            "שלח קוד חדש"
          )}
        </Button>
      </motion.div>

      <motion.div variants={itemVariants} className="mt-6">
        <Button
          type="button"
          onClick={goBackToBasicInfo}
          variant="outline"
          className="flex items-center gap-2 border-gray-300 text-sm"
          disabled={isLoading || isResending}
        >
          <ArrowRight className="h-4 w-4" /> חזור למילוי פרטים
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default EmailVerificationCodeStep;
--- End of Content for EmailVerificationCodeStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\OptionalInfoStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/OptionalInfoStep.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Input } from "@/components/ui/input";
import {
  ArrowLeft,
  ArrowRight,
  Ruler,
  Briefcase,
  GraduationCap,
  Loader2,
  AlertCircle,
} from "lucide-react";
import { motion } from "framer-motion";

type SubmissionStatus = "idle" | "savingProfile" | "updatingSession" | "sendingCode" | "error";

const OptionalInfoStep: React.FC = () => {
  const { data, updateField, prevStep } = useRegistration();
  const router = useRouter();
  const { update: updateSessionHook, status: sessionStatus } = useSession();

  const [submissionStatus, setSubmissionStatus] =
    useState<SubmissionStatus>("idle");
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async () => {
    console.log(`[OptionalInfoStep] handleSubmit triggered. Current session status: ${sessionStatus}, RegistrationContext data:`, JSON.stringify(data, null, 2));
    setSubmissionStatus("savingProfile");
    setError(null);

    try {
      const profileData = {
        // חשוב לוודא ששולחים את כל השדות שה-API מצפה להם, במיוחד firstName ו-lastName
        firstName: data.firstName,
        lastName: data.lastName,
        phone: data.phone, // ודא ש-data.phone מכיל ערך תקין מהשלב הקודם
        gender: data.gender, // ודא ש-data.gender מכיל ערך תקין
        birthDate: data.birthDate, // ודא ש-data.birthDate מכיל ערך תקין
        maritalStatus: data.maritalStatus, // ודא ש-data.maritalStatus מכיל ערך תקין
        height: data.height,
        occupation: data.occupation,
        education: data.education,
      };

      // בדיקה נוספת של הנתונים לפני השליחה
      if (!profileData.firstName || !profileData.lastName || !profileData.phone || !profileData.gender || !profileData.birthDate || !profileData.maritalStatus) {
        console.error("[OptionalInfoStep] ERROR: Missing required profile data before sending to API. Data:", JSON.stringify(profileData, null, 2));
        setError("חסרים נתונים חיוניים להשלמת הפרופיל. אנא חזור לשלב הקודם ובדוק את הפרטים.");
        setSubmissionStatus("error");
        return;
      }


      console.log("[OptionalInfoStep] Submitting profile data to /api/auth/complete-profile:", JSON.stringify(profileData, null, 2));

      const profileResponse = await fetch("/api/auth/complete-profile", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(profileData),
        credentials: "include", // חשוב אם ה-API שלך מסתמך על עוגיות סשן
      });

      const profileResultText = await profileResponse.text();
      console.log(`[OptionalInfoStep] Raw response from /api/auth/complete-profile (Status: ${profileResponse.status}):`, profileResultText);

      if (!profileResponse.ok) {
        let errorMessage = `שגיאה ${profileResponse.status}`;
        try {
          const errorData = JSON.parse(profileResultText);
          errorMessage =
            errorData.error || errorData.message || // נסה גם message
            `שגיאה ${profileResponse.status}: נתונים לא תקינים או בעיית שרת.`;
          console.error(
            "[OptionalInfoStep] API Error (complete-profile):",
            errorData
          );
        } catch (parseError) {
          errorMessage = `שגיאה ${profileResponse.status}: ${profileResponse.statusText}. Response: ${profileResultText}`;
          console.error("[OptionalInfoStep] Failed to parse error JSON from /api/auth/complete-profile:", parseError);
        }
        throw new Error(errorMessage);
      }

      let profileResult;
      try {
        profileResult = JSON.parse(profileResultText);
      } catch (e) {
        console.error("[OptionalInfoStep] Failed to parse success JSON from /api/auth/complete-profile. Text was:", profileResultText, "Error:", e);
        throw new Error("תגובה לא תקינה מהשרת לאחר שמירת פרופיל (לא JSON).");
      }

      console.log(
        "[OptionalInfoStep] Profile data saved successfully via API. API Response:",
        JSON.stringify(profileResult, null, 2)
      );

      if (profileResult?.user?.isProfileComplete !== true) {
          console.warn("[OptionalInfoStep] WARNING: API /api/auth/complete-profile did NOT return user.isProfileComplete as true in its response. User object from API:", JSON.stringify(profileResult?.user, null, 2));
          // זה לא בהכרח אומר שה-DB לא התעדכן, אבל זה מצביע על חוסר עקביות בתגובת ה-API או שה-API לא עדכן את הדגל.
      }

      console.log("[OptionalInfoStep] Setting status to 'updatingSession' and calling updateSessionHook()...");
      setSubmissionStatus("updatingSession");
      await updateSessionHook(); // גורם ל-NextAuth לרענן את הטוקן/סשן. ה-JWT callback בשרת יקרא מה-DB.
      console.log("[OptionalInfoStep] updateSessionHook() presumably completed. The session and token should now be refreshed based on DB state.");


      console.log("[OptionalInfoStep] Setting status to 'sendingCode' and attempting to send phone verification code...");
      setSubmissionStatus("sendingCode");

      const sendCodeResponse = await fetch("/api/auth/send-phone-code", {
        method: "POST",
        headers: { "Content-Type": "application/json" }, // גם אם אין body, header זה עדיין טוב
        // body: JSON.stringify({}), // אם ה-API דורש גוף כלשהו, אפשר לשלוח אובייקט ריק
        credentials: "include",
      });
      const sendCodeResultText = await sendCodeResponse.text();
      console.log(`[OptionalInfoStep] Raw response from /api/auth/send-phone-code (Status: ${sendCodeResponse.status}):`, sendCodeResultText);


      if (!sendCodeResponse.ok) {
        let errorMessage = `שגיאה ${sendCodeResponse.status}`;
         try {
          const errorData = JSON.parse(sendCodeResultText);
          errorMessage = errorData.error || errorData.message || `שגיאה ${sendCodeResponse.status} בשליחת קוד אימות.`;
         } catch(e){
            errorMessage = `שגיאה ${sendCodeResponse.status}: ${sendCodeResponse.statusText}. Response: ${sendCodeResultText}`;
            console.error("[OptionalInfoStep] Failed to parse error JSON from /api/auth/send-phone-code:", e);
         }
        throw new Error(errorMessage);
      }

      let sendCodeResult;
      try {
        sendCodeResult = JSON.parse(sendCodeResultText);
      } catch (e) {
         console.error("[OptionalInfoStep] Failed to parse success JSON from /api/auth/send-phone-code. Text was:", sendCodeResultText, "Error:", e);
         throw new Error("תגובה לא תקינה מהשרת לאחר שליחת קוד טלפון (לא JSON).");
      }

      console.log(
        "[OptionalInfoStep] Verification code sent successfully via API. API Response:",
        JSON.stringify(sendCodeResult, null, 2)
      );

      console.log("[OptionalInfoStep] Successfully sent phone code. Navigating to /auth/verify-phone...");
      // בשלב זה, הטוקן בעוגיה אמור להיות מעודכן עם isProfileComplete: true (לאחר ה-updateSessionHook).
      // ה-Middleware שיפעל עם הניווט יראה את הטוקן המעודכן.
      router.push("/auth/verify-phone");
    } catch (err) {
      console.error(
        "[OptionalInfoStep] Error during handleSubmit:",
        err instanceof Error ? err.stack : err // הדפס את ה-stack trace המלא אם זמין
      );
      setError(err instanceof Error ? err.message : "אירעה שגיאה לא צפויה");
      setSubmissionStatus("error");
    }
    // אין צורך ב-finally להחזיר סטטוס ל-idle אם יש ניווט,
    // כי הקומפוננטה תעשה unmount.
    // אם נשארים בדף עקב שגיאה, הכפתור צריך להיות פעיל שוב (הסטטוס 'error' יאפשר זאת).
  };

  const getButtonText = (): string => {
    switch (submissionStatus) {
      case "savingProfile": return "שומר פרטים...";
      case "updatingSession": return "מעדכן סשן...";
      case "sendingCode": return "שולח קוד אימות...";
      case "error": // במקרה של שגיאה, חזור לטקסט המקורי כדי לאפשר ניסיון חוזר
      case "idle":
      default:
        // הטקסט הדינמי המקורי היה: data.isCompletingProfile ? "סיום והמשך לאימות" : "סיום והרשמה";
        // מכיוון שאנחנו ב-OptionalInfoStep, סביר להניח ש-isCompletingProfile יהיה true מהקונטקסט.
        return "סיום והמשך לאימות";
    }
  };

  const isSubmitting =
    submissionStatus === "savingProfile" ||
    submissionStatus === "updatingSession" ||
    submissionStatus === "sendingCode";

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: { staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.5 },
    },
  };

  return (
    <motion.div
      className="space-y-5"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.h2
        className="text-xl font-bold text-gray-800 mb-1"
        variants={itemVariants}
      >
        מידע נוסף (אופציונלי)
      </motion.h2>
      <motion.p className="text-gray-600 text-sm mb-4" variants={itemVariants}>
        מידע זה יעזור לנו להתאים לך שידוכים מדויקים יותר. כל השדות הבאים הם
        אופציונליים אך מומלצים.
      </motion.p>

      {error && submissionStatus === "error" && (
          <motion.div variants={itemVariants}>
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>שגיאה</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          </motion.div>
        )}

      <motion.div variants={itemVariants} className="space-y-4">
        {/* Height Field */}
        <div className="space-y-1">
          <label
            htmlFor="heightOptional"
            className="block text-sm font-medium text-gray-700 flex items-center gap-1"
          >
            <Ruler className="h-4 w-4 text-gray-400" />
            גובה (בסמ)
          </label>
          <Input
            type="number"
            id="heightOptional"
            min="120"
            max="220"
            value={data.height ?? ""} // השתמש ב- ?? "" כדי למנוע uncontrolled input אם הערך הוא undefined
            onChange={(e) =>
              updateField(
                "height",
                e.target.value === "" // אם השדה ריק, שלח undefined
                  ? undefined
                  : parseInt(e.target.value, 10) || undefined // אם לא ניתן להמיר למספר, שלח undefined
              )
            }
            placeholder="לדוגמה: 175"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none disabled:bg-gray-100"
            disabled={isSubmitting}
          />
        </div>

        {/* Occupation Field */}
        <div className="space-y-1">
          <label
            htmlFor="occupationOptional"
            className="block text-sm font-medium text-gray-700 flex items-center gap-1"
          >
            <Briefcase className="h-4 w-4 text-gray-400" />
            עיסוק
          </label>
          <Input
            type="text"
            id="occupationOptional"
            value={data.occupation ?? ""}
            onChange={(e) => updateField("occupation", e.target.value || undefined)} // אם ריק, שלח undefined
            placeholder="לדוגמה: מהנדס תוכנה, מורה, סטודנט/ית"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none disabled:bg-gray-100"
            disabled={isSubmitting}
          />
        </div>

        {/* Education Field */}
        <div className="space-y-1">
          <label
            htmlFor="educationOptional"
            className="block text-sm font-medium text-gray-700 flex items-center gap-1"
          >
            <GraduationCap className="h-4 w-4 text-gray-400" />
            השכלה
          </label>
          <Input
            type="text"
            id="educationOptional"
            value={data.education ?? ""}
            onChange={(e) => updateField("education", e.target.value || undefined)} // אם ריק, שלח undefined
            placeholder="לדוגמה: תואר ראשון במדעי המחשב"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none disabled:bg-gray-100"
            disabled={isSubmitting}
          />
        </div>
      </motion.div>

      <motion.div
        variants={itemVariants}
        className="flex justify-between pt-4 mt-6"
      >
        <Button
          type="button"
          onClick={prevStep}
          variant="outline"
          className="flex items-center gap-2 border-gray-300"
          disabled={isSubmitting}
        >
          <ArrowRight className="h-4 w-4" />
          חזרה
        </Button>

        <Button
          type="button"
          onClick={handleSubmit}
          disabled={isSubmitting}
          className="bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 flex items-center gap-2 min-w-[200px] justify-center px-4 py-2.5 disabled:opacity-70" // שיניתי קצת את העיצוב שיתאים לכפתורים אחרים
        >
          {isSubmitting ? (
            <>
              <Loader2 className="h-5 w-5 animate-spin mr-2" /> {/* התאמתי גודל אייקון */}
              <span>{getButtonText()}</span>
            </>
          ) : (
            <>
              <span>{getButtonText()}</span>
              <ArrowLeft className="h-4 w-4 ml-2" />
            </>
          )}
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default OptionalInfoStep;
--- End of Content for OptionalInfoStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\PersonalDetailsStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/PersonalDetailsStep.tsx
"use client";

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react"; // הוספת update
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  ArrowLeft,
  ArrowRight,
  Phone,
  Calendar,
  Users,
  Edit3,
  Loader2, // הוספת אייקון טעינה
  AlertCircle, // הוספת אייקון לשגיאות
} from "lucide-react";
import { Gender } from "@prisma/client";
import { motion } from "framer-motion";
import ConsentCheckbox from "../ConsentCheckbox"; // ייבוא קומפוננטת ההסכמה
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"; // ייבוא רכיבי Alert

const PersonalDetailsStep: React.FC = () => {
  const { data: registrationState, updateField, nextStep, prevStep } = useRegistration();
  const { data: session, update: updateSessionHook } = useSession(); // שימוש ב-update מה-hook

  const [firstNameError, setFirstNameError] = useState("");
  const [lastNameError, setLastNameError] = useState("");
  const [phoneError, setPhoneError] = useState("");
  const [ageError, setAgeError] = useState("");
  const [isFormValid, setIsFormValid] = useState(false);

  // State עבור הסכמה
  const [consentChecked, setConsentChecked] = useState(
    !!session?.user?.termsAndPrivacyAcceptedAt // אתחול לפי הסשן
  );
  const [consentError, setConsentError] = useState<string | null>(null);
  const [isSubmittingConsent, setIsSubmittingConsent] = useState(false);
  const [generalApiError, setGeneralApiError] = useState<string | null>(null);

  const userHasAlreadyConsented = !!session?.user?.termsAndPrivacyAcceptedAt;

  // פונקציות ולידציה (נשארות זהות)
  const validateFirstName = (name: string): boolean => {
    const isValid = name.trim() !== "";
    setFirstNameError(isValid ? "" : "שם פרטי הוא שדה חובה");
    return isValid;
  };
  const validateLastName = (name: string): boolean => {
    const isValid = name.trim() !== "";
    setLastNameError(isValid ? "" : "שם משפחה הוא שדה חובה");
    return isValid;
  };
  const validatePhone = (phone: string): boolean => {
    const phoneRegex = /^0\d{9}$/;
    const isValid = phoneRegex.test(phone);
    setPhoneError(
      isValid
        ? ""
        : phone.trim() === ""
        ? "מספר טלפון הוא שדה חובה"
        : "מספר טלפון לא תקין (10 ספרות, מתחיל ב-0)"
    );
    return isValid;
  };
  const validateAge = (birthDate: string): boolean => {
    if (!birthDate) {
      setAgeError("תאריך לידה הוא שדה חובה");
      return false;
    }
    const birthDateObj = new Date(birthDate);
    const today = new Date();
    let age = today.getFullYear() - birthDateObj.getFullYear();
    const monthDifference = today.getMonth() - birthDateObj.getMonth();
    if (
      monthDifference < 0 ||
      (monthDifference === 0 && today.getDate() < birthDateObj.getDate())
    ) {
      age--;
    }
    if (age < 18) {
      setAgeError("גיל מינימלי להרשמה הוא 18");
      return false;
    } else if (age > 120) {
      setAgeError("תאריך לידה לא תקין");
      return false;
    }
    setAgeError("");
    return true;
  };

  useEffect(() => {
    // אם המשתמש כבר אישר בעבר, נסמן את התיבה
    if (userHasAlreadyConsented) {
        setConsentChecked(true);
    }
  }, [userHasAlreadyConsented]);


  useEffect(() => {
    const isFirstNameValid = registrationState.firstName.trim() !== "" && !firstNameError;
    const isLastNameValid = registrationState.lastName.trim() !== "" && !lastNameError;
    const isPhoneValid =
      registrationState.phone.trim() !== "" &&
      /^0\d{9}$/.test(registrationState.phone) &&
      !phoneError;
    const isBirthDateValid = registrationState.birthDate !== "" && !ageError;
    const isGenderValid = registrationState.gender !== "";
    const isMaritalStatusValid = registrationState.maritalStatus !== "";

    // תקינות הטופס תלויה גם באישור התנאים (אם טרם אושרו)
    const consentRequirementMet = userHasAlreadyConsented || consentChecked;

    setIsFormValid(
      isFirstNameValid &&
        isLastNameValid &&
        isPhoneValid &&
        isBirthDateValid &&
        isGenderValid &&
        isMaritalStatusValid &&
        consentRequirementMet // הוספת דרישת הסכמה
    );
  }, [
    registrationState.firstName,
    registrationState.lastName,
    registrationState.phone,
    registrationState.birthDate,
    registrationState.gender,
    registrationState.maritalStatus,
    firstNameError,
    lastNameError,
    phoneError,
    ageError,
    consentChecked, // הוספת תלות
    userHasAlreadyConsented,
  ]);

  const handleContinue = async () => {
    setGeneralApiError(null); // איפוס שגיאה כללית
    setConsentError(null); // איפוס שגיאת הסכמה

    // ולידציות שדות
    const fnValid = validateFirstName(registrationState.firstName);
    const lnValid = validateLastName(registrationState.lastName);
    const pValid = validatePhone(registrationState.phone);
    const ageValid = validateAge(registrationState.birthDate);
    const genderValid = registrationState.gender !== "";
    const maritalValid = registrationState.maritalStatus !== "";

    if (!fnValid || !lnValid || !pValid || !ageValid || !genderValid || !maritalValid) {
      return; // עצור אם יש שגיאות בשדות
    }

    // בדיקה וטיפול בהסכמה אם נדרש
    if (!userHasAlreadyConsented) {
      if (!consentChecked) {
        setConsentError("חובה לאשר את תנאי השימוש ומדיניות הפרטיות.");
        return;
      }
      setIsSubmittingConsent(true);
      try {
        const consentResponse = await fetch("/api/user/accept-terms", {
          method: "POST",
        });
        const consentResult = await consentResponse.json();
        if (!consentResponse.ok || !consentResult.success) {
          throw new Error(consentResult.error || "שגיאה באישור התנאים.");
        }
        // לאחר אישור מוצלח, עדכן את הסשן (אם צריך)
        await updateSessionHook(); // קריאה לפונקציית העדכון מה-hook
        console.log("Terms accepted via API, session should be updated.");
      } catch (error) {
        setGeneralApiError(
          error instanceof Error ? error.message : "אירעה שגיאה באישור התנאים."
        );
        setIsSubmittingConsent(false);
        return;
      } finally {
        setIsSubmittingConsent(false);
      }
    }

    // אם הגענו לכאן, כל הולידציות עברו וההסכמה (אם נדרשה) טופלה
    nextStep(); // עבור לשלב הבא (OptionalInfoStep)
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.07 } },
  };
  const itemVariants = {
    hidden: { opacity: 0, y: 15 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.4 } },
  };

  return (
    <motion.div
      className="space-y-5"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.h2
        className="text-xl font-semibold text-gray-800 mb-4"
        variants={itemVariants}
      >
        פרטים אישיים חיוניים
      </motion.h2>
      <motion.p className="text-sm text-gray-500 mb-5" variants={itemVariants}>
        אנו צריכים פרטים אלו כדי להמשיך בתהליך ההרשמה שלך.
      </motion.p>

      {generalApiError && (
        <motion.div variants={itemVariants}>
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{generalApiError}</AlertDescription>
          </Alert>
        </motion.div>
      )}

      <motion.div variants={itemVariants} className="space-y-4">
        {/* First Name Field */}
        <div className="space-y-1">
          <label htmlFor="firstNamePersonal" className="block text-sm font-medium text-gray-700">
            שם פרטי <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Edit3 className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="text"
              id="firstNamePersonal"
              value={registrationState.firstName}
              onChange={(e) => updateField("firstName", e.target.value)}
              onBlur={() => validateFirstName(registrationState.firstName)}
              placeholder="לדוגמה: ישראל"
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                firstNameError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {firstNameError && <p className="text-red-500 text-xs mt-1">{firstNameError}</p>}
        </div>

        {/* Last Name Field */}
        <div className="space-y-1">
          <label htmlFor="lastNamePersonal" className="block text-sm font-medium text-gray-700">
            שם משפחה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Edit3 className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="text"
              id="lastNamePersonal"
              value={registrationState.lastName}
              onChange={(e) => updateField("lastName", e.target.value)}
              onBlur={() => validateLastName(registrationState.lastName)}
              placeholder="לדוגמה: ישראלי"
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                lastNameError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {lastNameError && <p className="text-red-500 text-xs mt-1">{lastNameError}</p>}
        </div>

        {/* Phone Field */}
        <div className="space-y-1">
          <label htmlFor="phonePersonal" className="block text-sm font-medium text-gray-700">
            טלפון נייד <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Phone className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="tel"
              id="phonePersonal"
              value={registrationState.phone}
              onChange={(e) => updateField("phone", e.target.value)}
              onBlur={() => validatePhone(registrationState.phone)}
              placeholder=""
              required
              maxLength={10}
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                phoneError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {phoneError && <p className="text-red-500 text-xs mt-1">{phoneError}</p>}
        </div>

        {/* Gender Field */}
        <div className="space-y-1">
          <label className="block text-sm font-medium text-gray-700">
            מגדר <span className="text-red-500">*</span>
          </label>
          <div className="grid grid-cols-2 gap-3 mt-1">
            {([
              { value: Gender.MALE, label: "זכר", icon: "👨" },
              { value: Gender.FEMALE, label: "נקבה", icon: "👩" },
            ] as const).map((genderOption) => (
              <button
                key={genderOption.value}
                type="button"
                onClick={() => updateField("gender", genderOption.value)}
                disabled={isSubmittingConsent}
                className={`flex items-center justify-center gap-2 py-3 rounded-lg border-2 transition-all duration-200 ease-in-out transform hover:scale-105 disabled:opacity-70 disabled:cursor-not-allowed ${
                  registrationState.gender === genderOption.value
                    ? genderOption.value === Gender.MALE
                      ? "border-cyan-500 bg-cyan-50 text-cyan-700 shadow-md"
                      : "border-pink-500 bg-pink-50 text-pink-700 shadow-md"
                    : "border-gray-200 hover:border-gray-300 text-gray-700 bg-white"
                }`}
              >
                <span className="text-xl">{genderOption.icon}</span>
                <span className="font-medium">{genderOption.label}</span>
              </button>
            ))}
          </div>
          {registrationState.gender === "" && <p className="text-red-500 text-xs mt-1">יש לבחור מגדר</p>}
        </div>

        {/* Birth Date Field */}
        <div className="space-y-1">
          <label htmlFor="birthDatePersonal" className="block text-sm font-medium text-gray-700">
            תאריך לידה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Calendar className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="date"
              id="birthDatePersonal"
              value={registrationState.birthDate}
              onChange={(e) => {
                updateField("birthDate", e.target.value);
                validateAge(e.target.value);
              }}
              onBlur={() => validateAge(registrationState.birthDate)}
              max={new Date(new Date().setFullYear(new Date().getFullYear() - 18)).toISOString().split("T")[0]}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                ageError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {ageError && <p className="text-red-500 text-xs mt-1">{ageError}</p>}
        </div>

        {/* Marital Status Field */}
        <div className="space-y-1">
          <label htmlFor="maritalStatusPersonal" className="block text-sm font-medium text-gray-700">
            מצב משפחתי <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Users className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <select
              id="maritalStatusPersonal"
              value={registrationState.maritalStatus}
              onChange={(e) => updateField("maritalStatus", e.target.value)}
              required
              disabled={isSubmittingConsent}
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none appearance-none bg-white transition-colors disabled:opacity-70 disabled:cursor-not-allowed ${
                registrationState.maritalStatus === "" && false // Not a real error condition for select, just placeholder
                  ? "border-red-400 focus:ring-red-200"
                  : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
            >
              <option value="" disabled>בחר/י מצב משפחתי...</option>
              <option value="רווק/ה">רווק/ה</option>
              <option value="גרוש/ה">גרוש/ה</option>
              <option value="אלמן/ה">אלמן/ה</option>
            </select>
            <div className="absolute left-3 top-1/2 transform -translate-y-1/2 pointer-events-none">
              <svg className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7" />
              </svg>
            </div>
          </div>
          {registrationState.maritalStatus === "" && <p className="text-red-500 text-xs mt-1">יש לבחור מצב משפחתי</p>}
        </div>
      </motion.div>

      {/* Consent Checkbox - מוצג רק אם המשתמש טרם אישר */}
      {!userHasAlreadyConsented && (
        <motion.div variants={itemVariants} className="mt-6 pt-4 border-t border-gray-100">
          <ConsentCheckbox
            checked={consentChecked}
            onChange={(isChecked) => {
              setConsentChecked(isChecked);
              if (isChecked) setConsentError(null);
            }}
            error={consentError}
          />
        </motion.div>
      )}

      <motion.div
        variants={itemVariants}
        className="flex justify-between items-center pt-5 mt-6 border-t border-gray-200"
      >
        <Button
          onClick={prevStep}
          variant="outline"
          className="flex items-center gap-2 border-gray-300 text-gray-700 hover:bg-gray-50"
          disabled={isSubmittingConsent || (registrationState.step === 0 && !registrationState.isCompletingProfile)}
        >
          <ArrowRight className="h-4 w-4" />
          חזרה
        </Button>

        <Button
          onClick={handleContinue}
          disabled={!isFormValid || isSubmittingConsent}
          className={`flex items-center gap-2 px-6 py-3 rounded-lg font-semibold text-white transition-all duration-300
            ${
              isFormValid && !isSubmittingConsent
                ? "bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg hover:shadow-xl transform hover:scale-105"
                : "bg-gray-300 cursor-not-allowed"
            }`}
        >
          {isSubmittingConsent ? (
            <>
              <Loader2 className="h-5 w-5 animate-spin mr-2" />
              <span>מאשר תנאים...</span>
            </>
          ) : (
            <>
              <span>המשך לשלב הבא</span>
              <ArrowLeft className="h-4 w-4" />
            </>
          )}
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default PersonalDetailsStep;
--- End of Content for PersonalDetailsStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\WelcomeStep.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useState } from "react";
import { useRegistration } from "../RegistrationContext";
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Heart, ArrowLeft, Mail } from "lucide-react";
import Link from "next/link";

const WelcomeStep: React.FC = () => {
  const { nextStep,  } = useRegistration();
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);

  const handleGoogleSignIn = async () => {
    try {
      setIsGoogleLoading(true);

      // Store this information for potential fallback
      localStorage.setItem("registration_started", "true");

      // The 'redirect' callback in authOptions will handle where to send the user
      // --- START: התיקון ---
      await signIn("google"); // הסרנו את callbackUrl
      // --- END: התיקון ---
    } catch (error) {
      console.error("Google sign-in error:", error);
      setIsGoogleLoading(false);
    }
  };

  const handleEmailSignUp = () => {
    nextStep();
  };

  return (
    <div className="space-y-6 text-center">
      {/* Welcome animation */}
      <div className="flex justify-center mb-4">
        <div className="relative">
          <div className="w-20 h-20 rounded-full bg-pink-100 flex items-center justify-center animate-pulse">
            <Heart className="h-10 w-10 text-pink-500 fill-pink-500" />
          </div>
          <div className="absolute -top-2 -right-2 w-8 h-8 rounded-full bg-cyan-500 flex items-center justify-center text-white font-bold animate-bounce">
            <span className="text-sm">👋</span>
          </div>
        </div>
      </div>

      <h2 className="text-2xl font-bold text-gray-800">ברוכים הבאים!</h2>

      <p className="text-gray-600 max-w-sm mx-auto">
        אנחנו שמחים שבחרת להצטרף אלינו. בואו נתחיל בתהליך הרשמה קצר ופשוט שיאפשר
        לנו להכיר אותך טוב יותר.
      </p>

      {/* Buttons */}
      <div className="space-y-4 mt-8">
        <Button
          onClick={handleGoogleSignIn}
          disabled={isGoogleLoading}
          variant="outline"
          size="lg"
          className="w-full relative border-2 border-gray-300 hover:border-gray-400 py-6 rounded-xl flex items-center justify-center gap-3 group"
        >
          {isGoogleLoading ? (
            <div className="animate-spin h-5 w-5 border-2 border-gray-500 rounded-full border-t-transparent" />
          ) : (
            <>
              <svg className="h-5 w-5" viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  fill="#4285F4"
                />
                <path
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  fill="#34A853"
                />
                <path
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  fill="#FBBC05"
                />
                <path
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  fill="#EA4335"
                />
              </svg>
              <span className="text-gray-700 font-medium">המשך עם Google</span>
            </>
          )}
        </Button>

        <Button
          onClick={handleEmailSignUp}
          size="lg"
          className="w-full py-6 rounded-xl bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-3 group relative overflow-hidden"
        >
          {/* Button background shimmer effect */}
          <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
          <Mail className="h-5 w-5 text-white" />
          <span className="text-white font-medium">המשך עם אימייל</span>
          <ArrowLeft className="h-5 w-5 text-white opacity-0 group-hover:opacity-100 transition-opacity" />
        </Button>
      </div>

      {/* Already have an account link */}
      <div className="mt-8 pt-4 border-t border-gray-200">
        <p className="text-gray-600 text-sm">
          כבר יש לך חשבון?{" "}
          <Link
            href="/auth/signin"
            className="text-cyan-600 font-medium hover:text-cyan-700 hover:underline"
          >
            התחברות
          </Link>
        </p>
      </div>
    </div>
  );
};

export default WelcomeStep;
--- End of Content for WelcomeStep.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\MatchmakerEditProfile.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/MatchmakerEditProfile.tsx

import React, { useState, useEffect, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { toast } from "sonner";
import { ProfileSection } from "@/app/components/profile";
import { PhotosSection } from "@/app/components/profile";
import { PreferencesSection } from "@/app/components/profile";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Loader2, X, UserCog, Image as ImageIcon, Sliders, Trash2, AlertCircle, Send } from "lucide-react";
import type { UserProfile, UserImage } from "@/types/next-auth";
import type { Candidate } from "./types/candidates";
import { motion } from "framer-motion";
import { useSession } from "next-auth/react";

interface MatchmakerEditProfileProps {
  isOpen: boolean;
  onClose: () => void;
  candidate: Candidate | null;
  onCandidateDeleted?: (candidateId: string) => void; 
}

const DELETE_CANDIDATE_CONFIRMATION_PHRASE = "אני מאשר מחיקה";

const MatchmakerEditProfile: React.FC<MatchmakerEditProfileProps> = ({
  isOpen,
  onClose,
  candidate,
  onCandidateDeleted,
}) => {
  const { data: session } = useSession();
  const isAdmin = session?.user?.role === "ADMIN";

  const [activeTab, setActiveTab] = useState("profile");
  const [isEditing, setIsEditing] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [images, setImages] = useState<UserImage[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // States for delete candidate confirmation
  const [isDeleteCandidateDialogOpen, setIsDeleteCandidateDialogOpen] = useState(false);
  const [deleteCandidateConfirmText, setDeleteCandidateConfirmText] = useState("");
  const [isDeletingCandidate, setIsDeletingCandidate] = useState(false);

  // --- NEW: States for Account Setup Invite ---
  const [isSetupInviteOpen, setIsSetupInviteOpen] = useState(false);
  const [inviteEmail, setInviteEmail] = useState("");
  const [isSendingInvite, setIsSendingInvite] = useState(false);
  // --- END NEW ---

  const fetchProfileData = useCallback(async () => {
    if (!candidate) return;
    setIsLoading(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}`);
      if (!response.ok) throw new Error("Failed to fetch candidate profile");
      const data = await response.json();
      if (data.success) {
        setProfile(data.profile);
        setImages(data.images || []);
        // --- NEW: Populate email for invite dialog ---
        // Check if the email is a real one, not a placeholder
        if (candidate.email && !candidate.email.endsWith('@shidduch.placeholder.com')) {
          setInviteEmail(candidate.email);
        } else {
          setInviteEmail(""); // Clear if it's a placeholder
        }
        // --- END NEW ---
      } else {
        throw new Error(data.error || "Failed to load profile data");
      }
    } catch (error) {
      console.error("Error fetching profile:", error);
      toast.error("שגיאה בטעינת נתוני המועמד");
    } finally {
      setIsLoading(false);
    }
  }, [candidate]);

  useEffect(() => {
    if (isOpen && candidate) {
      fetchProfileData();
    } else if (!isOpen) {
      setProfile(null);
      setImages([]);
      setActiveTab("profile");
      setIsLoading(true);
      setDeleteCandidateConfirmText("");
      setIsDeleteCandidateDialogOpen(false);
      // --- NEW: Reset invite state on close ---
      setIsSetupInviteOpen(false);
      setInviteEmail("");
      setIsSendingInvite(false);
      // --- END NEW ---
    }
  }, [isOpen, candidate, fetchProfileData]);

  const handleProfileUpdate = async (updatedProfile: Partial<UserProfile>) => {
    if (!candidate || !profile) return;
    setIsSaving(true);
    try {
      const cleanedProfile = { ...updatedProfile };
      if (cleanedProfile.gender === undefined) { /* Keep undefined */ }
      if (cleanedProfile.preferredMatchmakerGender === undefined) { /* Keep undefined */ }

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(cleanedProfile),
        }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to update profile");
      }
      setProfile(prevProfile => ({ ...prevProfile, ...cleanedProfile } as UserProfile));
      toast.success("פרופיל המועמד עודכן בהצלחה", { position: "top-center", duration: 3000 });
    } catch (error) {
      console.error("Error updating profile:", error);
      toast.error(
        "שגיאה בעדכון פרופיל המועמד: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"),
        { duration: 5000 }
      );
    } finally {
      setIsSaving(false);
    }
  };

  const handleImageUpload = async (file: File) => {
    if (!candidate) return;
    setIsUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      formData.append("userId", candidate.id);

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images`,
        { method: "POST", body: formData }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to upload image");
      }
      setImages((prev) => [...prev, data.image]);
      toast.success("התמונה הועלתה בהצלחה");
    } catch (error) {
      console.error("Error uploading image:", error);
      toast.error("שגיאה בהעלאת התמונה");
    } finally {
      setIsUploading(false);
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    if (!candidate) return;
    try {
      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}/main`,
        { method: "PATCH" }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to set main image");
      }
      setImages((prev) => prev.map((img) => ({ ...img, isMain: img.id === imageId })));
      toast.success("התמונה הראשית עודכנה בהצלחה");
    } catch (error) {
      console.error("Error setting main image:", error);
      toast.error("שגיאה בעדכון התמונה הראשית");
    }
  };

  const handleDeleteImage = async (imageId: string) => {
    if (!candidate) return;
    setIsUploading(true);
    try {
      const isMainImage = images.find((img) => img.id === imageId)?.isMain;
      let nextMainImageId: string | undefined;
      if (isMainImage) {
        nextMainImageId = images.find((img) => img.id !== imageId)?.id;
      }

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}`,
        { method: "DELETE" }
      );

      if (response.status === 204) {
         setImages((prev) => prev.filter((img) => img.id !== imageId));
         if (isMainImage && nextMainImageId) {
           await handleSetMainImage(nextMainImageId);
         }
         toast.success("התמונה נמחקה בהצלחה", { position: "top-center" });
         return;
      }

      const data = await response.json();
      if (!response.ok || !data.success) {
        const errorText = data.error || await response.text();
        throw new Error(`שגיאה במחיקת התמונה: ${errorText}`);
      }
      
      setImages((prev) => prev.filter((img) => img.id !== imageId));
      if (isMainImage && nextMainImageId) {
        await handleSetMainImage(nextMainImageId);
      }
      toast.success("התמונה נמחקה בהצלחה", { position: "top-center" });

    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה במחיקת התמונה");
    } finally {
      setIsUploading(false);
    }
  };

  const handleDeleteCandidateRequest = async () => {
    if (!candidate) return;
    if (deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE) {
      toast.error("אישור לא תקין", { description: `נא להקליד "${DELETE_CANDIDATE_CONFIRMATION_PHRASE}" בדיוק כדי לאשר מחיקה.` });
      return;
    }
    setIsDeletingCandidate(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}`, { method: "DELETE" });
      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to delete candidate profile");
      }

      toast.success("המועמד נמחק בהצלחה", { position: "top-center", duration: 3000 });
      if (onCandidateDeleted) {
        onCandidateDeleted(candidate.id);
      }
      setIsDeleteCandidateDialogOpen(false);
      onClose();
    } catch (error) {
      console.error("Error deleting candidate:", error);
      toast.error("שגיאה במחיקת המועמד: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"), { duration: 5000 });
    } finally {
      setIsDeletingCandidate(false);
    }
  };
  
  // --- NEW: Handler for sending setup invite ---
  const handleSendSetupInvite = async () => {
    if (!candidate || !inviteEmail) {
      toast.error("נא להזין כתובת אימייל תקינה.");
      return;
    }
    setIsSendingInvite(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}/invite-setup`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: inviteEmail }),
      });
      const result = await response.json();
      if (!response.ok || !result.success) {
        throw new Error(result.error || 'שגיאה בשליחת ההזמנה.');
      }
      toast.success("הזמנה להגדרת חשבון נשלחה בהצלחה!");
      setIsSetupInviteOpen(false);
    } catch (error) {
      console.error("Error sending setup invite:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה בשליחת ההזמנה.");
    } finally {
      setIsSendingInvite(false);
    }
  };
  // --- END NEW ---

  if (!candidate && isOpen) return null;
  if (!candidate) return null;

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-5xl max-h-[90vh] p-0 overflow-hidden">
          {isLoading && !profile ? (
            <div className="flex items-center justify-center h-64"><Loader2 className="w-10 h-10 animate-spin text-primary" /></div>
          ) : (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }} className="flex flex-col h-full max-h-[90vh]">
              <DialogHeader className="p-6 border-b">
                <div className="flex items-center justify-between">
                  <div>
                    <DialogTitle className="text-2xl font-bold text-primary/90">עריכת פרופיל - {candidate.firstName} {candidate.lastName}</DialogTitle>
                    <DialogDescription className="text-gray-500 mt-1">עריכת פרטי המועמד והעדפותיו במערכת</DialogDescription>
                  </div>
                  {isSaving && <div className="flex items-center bg-blue-50 text-blue-700 py-1 px-2 rounded-full text-sm"><Loader2 className="w-3 h-3 animate-spin mr-1" />שומר שינויים...</div>}
                </div>
              </DialogHeader>

              <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col min-h-0">
                <div className="px-6 pt-4">
                  <TabsList className="w-full bg-muted/30 p-1 rounded-xl shadow-sm">
                    <TabsTrigger value="profile" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <UserCog className="w-4 h-4" />פרטים אישיים
                    </TabsTrigger>
                    <TabsTrigger value="photos" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <ImageIcon className="w-4 h-4" />תמונות
                    </TabsTrigger>
                    <TabsTrigger value="preferences" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <Sliders className="w-4 h-4" />העדפות
                    </TabsTrigger>
                  </TabsList>
                </div>

                <div className="flex-1 overflow-hidden flex flex-col min-h-0">
                  <TabsContent value="profile" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    {profile ? <div className="bg-white rounded-xl shadow-sm border"><ProfileSection profile={profile} isEditing={isEditing} setIsEditing={setIsEditing} onSave={handleProfileUpdate} /></div> : <div className="flex items-center justify-center h-full"><Loader2 className="w-8 h-8 animate-spin text-muted-foreground" /></div>}
                  </TabsContent>
                  <TabsContent value="photos" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    <div className="bg-white rounded-xl shadow-sm border"><PhotosSection images={images} isUploading={isUploading} disabled={isSaving || isDeletingCandidate} onUpload={handleImageUpload} onSetMain={handleSetMainImage} onDelete={handleDeleteImage} maxImages={10} /></div>
                  </TabsContent>
                  <TabsContent value="preferences" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    {profile ? <div className="bg-white rounded-xl shadow-sm border"><PreferencesSection profile={profile} isEditing={isEditing} setIsEditing={setIsEditing} onChange={handleProfileUpdate} /></div> : <div className="flex items-center justify-center h-full"><Loader2 className="w-8 h-8 animate-spin text-muted-foreground" /></div>}
                  </TabsContent>
                </div>
              </Tabs>

              <div className="p-4 border-t flex justify-between items-center mt-auto bg-white/80 backdrop-blur-sm sticky bottom-0">
                <div>
                  <span className="text-sm text-muted-foreground">{activeTab === "profile" ? "עריכת פרטים אישיים" : activeTab === "photos" ? "ניהול תמונות" : "עריכת העדפות"}</span>
                </div>
                <div className="flex items-center gap-3">
                  <Button variant="outline" onClick={() => setIsSetupInviteOpen(true)} disabled={isSaving || isDeletingCandidate || isSendingInvite}>
                    <Send className="w-4 h-4 ml-2" />
                    שלח הזמנה לניהול החשבון
                  </Button>
                  {isAdmin && <Button variant="destructive" onClick={() => setIsDeleteCandidateDialogOpen(true)} disabled={isSaving || isUploading || isDeletingCandidate} size="sm"><Trash2 className="w-4 h-4 mr-2" />מחק מועמד</Button>}
                  <Button variant="outline" onClick={onClose} disabled={isSaving || isDeletingCandidate} className="bg-white hover:bg-gray-100 transition-colors shadow-sm" size="sm"><X className="w-4 h-4 mr-2" />סגור</Button>
                </div>
              </div>
            </motion.div>
          )}
        </DialogContent>
      </Dialog>
      
      {/* --- NEW: Invite Setup Dialog --- */}
      {candidate && (
        <Dialog open={isSetupInviteOpen} onOpenChange={setIsSetupInviteOpen}>
            <DialogContent className="sm:max-w-md">
                <DialogHeader>
                    <DialogTitle>הזמנת מועמד לניהול החשבון</DialogTitle>
                    <DialogDescription>
                        שלח הזמנה ל<strong>{candidate.firstName} {candidate.lastName}</strong> להגדיר סיסמה ולקחת שליטה על הפרופיל.
                    </DialogDescription>
                </DialogHeader>
                <div className="grid gap-4 py-4">
                    <Label htmlFor="inviteEmail" className="text-right">
                        כתובת אימייל
                    </Label>
                    <Input
                        id="inviteEmail"
                        type="email"
                        value={inviteEmail}
                        onChange={(e) => setInviteEmail(e.target.value)}
                        placeholder="user@example.com"
                        className="col-span-3"
                        dir="ltr"
                    />
                </div>
                <DialogFooter>
                    <DialogClose asChild>
                        <Button type="button" variant="secondary" disabled={isSendingInvite}>ביטול</Button>
                    </DialogClose>
                    <Button type="button" onClick={handleSendSetupInvite} disabled={isSendingInvite || !inviteEmail}>
                        {isSendingInvite ? <Loader2 className="ml-2 h-4 w-4 animate-spin" /> : <Send className="ml-2 h-4 w-4" />}
                        {isSendingInvite ? "שולח..." : "שלח הזמנה"}
                    </Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
      )}
      {/* --- END NEW --- */}

      {/* Delete Candidate Confirmation Dialog */}
      {candidate && (
        <Dialog open={isDeleteCandidateDialogOpen} onOpenChange={(open) => !isDeletingCandidate && setIsDeleteCandidateDialogOpen(open)}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle className="text-xl flex items-center gap-2 text-red-600"><AlertCircle className="h-5 w-5" />אישור מחיקת מועמד</DialogTitle>
              <DialogDescription>האם אתה בטוח שברצונך למחוק את המועמד <strong>{candidate.firstName} {candidate.lastName}</strong>? פעולה זו הינה בלתי הפיכה ותסיר את כל נתוני המועמד מהמערכת.</DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
              <Label htmlFor="deleteCandidateConfirm" className="text-gray-700">לאישור המחיקה, אנא הקלד: <strong className="text-red-700">{DELETE_CANDIDATE_CONFIRMATION_PHRASE}</strong></Label>
              <Input id="deleteCandidateConfirm" value={deleteCandidateConfirmText} onChange={(e) => setDeleteCandidateConfirmText(e.target.value)} disabled={isDeletingCandidate} className="border-gray-300 focus:border-red-500" placeholder={DELETE_CANDIDATE_CONFIRMATION_PHRASE} dir="rtl" />
              {deleteCandidateConfirmText && deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE && (<p className="text-xs text-red-600">הטקסט שהוקלד אינו תואם.</p>)}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => { setIsDeleteCandidateDialogOpen(false); setDeleteCandidateConfirmText(""); }} disabled={isDeletingCandidate} className="border-gray-300">ביטול</Button>
              <Button variant="destructive" onClick={handleDeleteCandidateRequest} disabled={isDeletingCandidate || deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE}>
                {isDeletingCandidate ? (<span className="flex items-center gap-2"><Loader2 className="w-4 h-4 animate-spin" />מוחק...</span>) : (<><Trash2 className="w-4 h-4 mr-2" />מחק מועמד לצמיתות</>)}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </>
  );
};

export default MatchmakerEditProfile;
--- End of Content for MatchmakerEditProfile.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\Actions.tsx
--------------------------------------------------------------------------------
Content:
// /components/matchmaker/CandidateCard/Actions.tsx

"use client";

import React from "react";

import { Button } from "@/components/ui/button";
import { Heart, Mail, FileText, Eye, Clock } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface ActionsProps {
  candidate: Candidate;
  onInvite: (candidate: Candidate) => void;
  onSuggest: (candidate: Candidate) => void;
  onCheckAvailability: (candidate: Candidate) => void;
  onViewProfile: (candidate: Candidate) => void;
  className?: string;
}

const Actions: React.FC<ActionsProps> = ({
  candidate,
  onInvite,
  onSuggest,
  onCheckAvailability,
  onViewProfile,
  className,
}) => {
  // מונע התפשטות הקליק לכרטיס המינימלי
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  return (
    <div className={`flex flex-wrap gap-2 ${className}`} onClick={handleClick}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onViewProfile(candidate)}
      >
        <Eye className="w-4 h-4 ml-2" />
        צפייה בפרופיל
      </Button>

      <Button variant="outline" size="sm" onClick={() => onInvite(candidate)}>
        <Mail className="w-4 h-4 ml-2" />
        שליחת הזמנה
      </Button>

      <Button variant="outline" size="sm" onClick={() => onSuggest(candidate)}>
        <FileText className="w-4 h-4 ml-2" />
        הצעת שידוך
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => onCheckAvailability(candidate)}
      >
        <Clock className="w-4 h-4 ml-2" />
        בדיקת זמינות
      </Button>

      <Button
        variant="ghost"
        size="sm"
        className="text-red-600 hover:text-red-700 hover:bg-red-50"
      >
        <Heart className="w-4 h-4" />
      </Button>
    </div>
  );
};

export default Actions;
--- End of Content for Actions.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\MinimalCard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/CandidateCard/MinimalCard.tsx

"use client";

import React, { useState } from "react";
import Image from "next/image";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { User, MapPin, Briefcase, Calendar, Edit2, Sparkles, Star } from "lucide-react";
import type { Candidate } from "../types/candidates";
import { UserSource } from "@prisma/client";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import { motion } from "framer-motion";
import { Skeleton } from "@/components/ui/skeleton";
import { cn } from "@/lib/utils";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";


interface MinimalCandidateCardProps {
  candidate: Candidate;
  onClick: (candidate: Candidate) => void;
  onEdit?: (candidate: Candidate, e: React.MouseEvent) => void;
  isHighlighted?: boolean;
  highlightTerm?: string;
  className?: string;
  
  // --- AI-Related Props ---
  aiScore?: number;
  isAiTarget?: boolean;
  onSetAiTarget?: (candidate: Candidate, e: React.MouseEvent) => void;
  isSelectableForComparison?: boolean;
  isSelectedForComparison?: boolean;
  onToggleComparison?: (candidate: Candidate, e: React.MouseEvent) => void;
}

const calculateAge = (birthDate: Date | string): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const MinimalCandidateCard: React.FC<MinimalCandidateCardProps> = ({
  candidate,
  onClick,
  onEdit,
  isHighlighted = false,
  highlightTerm = "",
  className,
  aiScore,
  isAiTarget = false,
  onSetAiTarget,
  isSelectableForComparison = false,
  isSelectedForComparison = false,
  onToggleComparison,
}) => {
  const mainImage = candidate.images.find((img) => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);

  const highlightText = (text: string | undefined | null): React.ReactNode => {
    if (!highlightTerm || !text) return text;
    const parts = text.split(new RegExp(`(${highlightTerm})`, "gi"));
    return (
      <>
        {parts.map((part, i) =>
          part.toLowerCase() === highlightTerm.toLowerCase() ? (
            <mark key={i} className="bg-yellow-200 px-0.5 rounded-sm">
              {part}
            </mark>
          ) : (
            part
          )
        )}
      </>
    );
  };

  const getAvailabilityBadge = () => {
    switch (candidate.profile.availabilityStatus) {
      case "AVAILABLE": return { label: "פנוי/ה", className: "bg-emerald-100 text-emerald-800 border-emerald-200" };
      case "DATING": return { label: "בתהליך הכרות", className: "bg-amber-100 text-amber-800 border-amber-200" };
      case "UNAVAILABLE": return { label: "לא פנוי/ה", className: "bg-red-100 text-red-800 border-red-200" };
      default: return { label: "לא ידוע", className: "bg-gray-100 text-gray-800 border-gray-200" };
    }
  };

  const availabilityBadge = getAvailabilityBadge();
  const isManualEntry = candidate.source === UserSource.MANUAL_ENTRY;

  return (
    <motion.div
      whileHover={{ y: -4 }}
      transition={{ type: "spring", stiffness: 300, damping: 15 }}
    >
      <Card
        className={cn(
          "relative overflow-hidden cursor-pointer transition-all hover:shadow-lg duration-300 group border-2",
          isAiTarget ? "border-green-500 shadow-lg" : 
          isSelectedForComparison ? "border-blue-500 shadow-md" :
          typeof aiScore === 'number' ? "border-teal-400/50" :
          isHighlighted ? "border-yellow-400" :
          "border-gray-200",
          className || ""
        )}
        onClick={() => onClick(candidate)}
      >
        {/* --- Top-left Badges Area --- */}
        <div className="absolute top-2 left-2 z-20 flex flex-col items-start gap-1.5">
          {typeof aiScore === 'number' && (
            <Badge className="bg-gradient-to-r from-teal-400 to-cyan-500 text-white border-0 shadow-lg px-2.5 py-1 text-xs font-bold flex items-center gap-1.5 animate-pulse-slow">
              <Sparkles className="w-3.5 h-3.5" />
              {aiScore}% התאמה
            </Badge>
          )}
        </div>

        {/* --- Top-right Badges Area --- */}
        <div className="absolute top-2 right-2 z-10 flex flex-col gap-1 items-end">
          <Badge variant="outline" className={`px-2 py-0.5 text-xs font-medium shadow-sm ${availabilityBadge.className}`}>
            {availabilityBadge.label}
          </Badge>
          {isManualEntry && (
            <Badge variant="outline" className="px-2 py-0.5 text-xs font-medium shadow-sm bg-purple-100 text-purple-800 border-purple-200 flex items-center gap-1">
              <Edit2 className="w-2.5 h-2.5" /> מועמד ידני
            </Badge>
          )}
        </div>

        <div className="relative h-48 sm:h-56 bg-gradient-to-b from-blue-50 to-blue-100">
          {mainImage && !imageError ? (
            <>
              {!imageLoaded && <Skeleton className="absolute inset-0 h-full w-full" />}
              <Image
                src={mainImage.url}
                alt={`${candidate.firstName} ${candidate.lastName}`}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                priority={false}
                className={`object-cover transition-opacity duration-300 ${imageLoaded ? "opacity-100" : "opacity-0"}`}
                onLoad={() => setImageLoaded(true)}
                onError={() => setImageError(true)}
              />
              <div className="absolute inset-0 bg-gradient-to-t from-gray-900/80 via-gray-900/40 to-transparent" />
            </>
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-blue-50">
              <User className="w-20 h-20 text-gray-400" />
            </div>
          )}

          <div className="absolute bottom-0 w-full p-3 text-right">
            <h3 className="font-bold mb-0.5 text-white drop-shadow-md text-lg">
              {highlightText(`${candidate.firstName} ${candidate.lastName}`)}
            </h3>
            <div className="flex items-center justify-end gap-2 text-white/90 text-sm">
              <span>{age}</span>
              <Calendar className="w-3 h-3" />
            </div>
          </div>
        </div>

        <div className="p-4">
          <div className="space-y-1.5 text-gray-700 text-sm">
            {isManualEntry && candidate.profile.manualEntryText ? (
              <p className="line-clamp-3 text-gray-600 text-sm leading-relaxed">
                {highlightText(candidate.profile.manualEntryText)}
              </p>
            ) : (
              <>
                {candidate.profile.city && (
                  <div className="flex items-center justify-end gap-1">
                    <span className="font-medium">{highlightText(candidate.profile.city)}</span>
                    <MapPin className="w-4 h-4 text-blue-600" />
                  </div>
                )}
                {candidate.profile.occupation && (
                  <div className="flex items-center justify-end gap-1">
                    <span>{highlightText(candidate.profile.occupation)}</span>
                    <Briefcase className="w-4 h-4 text-blue-600" />
                  </div>
                )}
              </>
            )}
            {candidate.profile.lastActive && (
              <div className="flex items-center justify-end gap-1 mt-2 text-xs text-gray-400">
                <span>{`פעיל/ה ${formatDistanceToNow(new Date(candidate.profile.lastActive), { addSuffix: true, locale: he })}`}</span>
                <Edit2 className="w-3 h-3" />
              </div>
            )}
          </div>
        </div>

        {/* --- Bottom Action Buttons --- */}
        <div className="absolute bottom-2 left-2 z-10 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
          {onEdit && (
            <Button variant="outline" size="icon" className="h-8 w-8 bg-white/80 backdrop-blur-sm shadow-md" onClick={(e) => onEdit(candidate, e)} title="ערוך פרופיל">
              <Edit2 className="h-4 w-4 text-blue-600" />
            </Button>
          )}
          {onSetAiTarget && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                   <Button variant="outline" size="icon" className={cn("h-8 w-8 bg-white/80 backdrop-blur-sm shadow-md", isAiTarget && "bg-green-200")} onClick={(e) => onSetAiTarget(candidate, e)}>
                      <Star className={cn("h-4 w-4", isAiTarget ? "text-green-600 fill-current" : "text-gray-500")} />
                   </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{isAiTarget ? "בטל בחירת מטרה" : "בחר כמטרה לחיפוש AI"}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}
        </div>
        
      {/* --- Comparison Checkbox --- */}
      {isSelectableForComparison && onToggleComparison && (
          <div 
              className="absolute bottom-2 right-2 z-10 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity"
              onClick={(e) => {
                  e.stopPropagation(); // מונע את הקליק על הכרטיס
                  onToggleComparison(candidate, e); // מפעיל את הפונקציה הנכונה
              }}
          >
              <div 
                  className="flex items-center space-x-2 bg-white/80 backdrop-blur-sm p-1.5 rounded-md shadow-md cursor-pointer"
              >
                  <Checkbox
                      id={`compare-${candidate.id}`}
                      checked={isSelectedForComparison}
                      // --- START OF FIX ---
                      // הסרת readOnly והוספת pointer-events-none
                      // זה הופך את ה-Checkbox לויזואלי בלבד, והקליק מטופל ב-div החיצוני
                      className="pointer-events-none"
                      // --- END OF FIX ---
                  />
                  <label
                      htmlFor={`compare-${candidate.id}`}
                      className="text-xs font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 text-gray-700 cursor-pointer"
                  >
                      השווה
                  </label>
              </div>
          </div>
      )}
      </Card>
    </motion.div>
  );
};

export default MinimalCandidateCard;
--- End of Content for MinimalCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\QuickView.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidateCard/QuickView.tsx

"use client";
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  Mail,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  User,
  FileText,
  CalendarClock,
  Edit,
  Info,
  Star, // הוספת ייבוא לכוכב
} from "lucide-react";

import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";
import { UserSource } from "@prisma/client";
import { cn } from "@/lib/utils"; // הוספת ייבוא עבור cn

// פונקציה לחישוב גיל
const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

interface QuickViewProps {
  candidate: Candidate;
  onAction: (
    action: "view" | "invite" | "suggest" | "contact" | "favorite" | "edit"
  ) => void;
  // --- Props חדשים עבור AI ---
  onSetAiTarget?: (candidate: Candidate, e: React.MouseEvent) => void;
  isAiTarget?: boolean;
}

const QuickView: React.FC<QuickViewProps> = ({ 
  candidate, 
  onAction,
  onSetAiTarget,
  isAiTarget = false 
}) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = candidate.profile;
  const isManualEntry = candidate.source === UserSource.MANUAL_ENTRY;

  return (
    <div
      className="bg-white shadow-xl flex flex-col border border-gray-200 overflow-hidden max-w-md sm:max-w-lg w-full rounded-lg"
      onClick={handleClick}
    >
      {/* Header with name and avatar */}
      <div className="px-6 py-4 bg-gradient-to-r from-blue-500 to-blue-600 border-b text-white">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Badge className="bg-white text-blue-700 border-0 font-medium shadow-sm px-3 py-1">
              {profile.availabilityStatus === "AVAILABLE"
                ? "פנוי/ה"
                : profile.availabilityStatus === "DATING"
                ? "בתהליך הכרות"
                : profile.availabilityStatus === "UNAVAILABLE"
                ? "לא פנוי/ה"
                : "לא ידוע"}
            </Badge>
            {isManualEntry && (
              <Badge className="bg-purple-200 text-purple-800 border-0 font-medium shadow-sm px-3 py-1">
                מועמד ידני
              </Badge>
            )}
          </div>
          
          <div className="flex items-center gap-2">
            {onSetAiTarget && (
              <Button
                size="icon"
                variant="ghost"
                className="h-8 w-8 text-white hover:bg-white/20"
                onClick={(e) => onSetAiTarget(candidate, e)}
                title={isAiTarget ? "בטל בחירת מטרה" : "בחר כמטרה לחיפוש AI"}
              >
                <Star className={cn("h-5 w-5", isAiTarget ? "fill-current text-yellow-300" : "text-white/80")} />
              </Button>
            )}
            <h3 className="text-lg font-bold">
              {candidate.firstName} {candidate.lastName}
            </h3>
          </div>
        </div>
      </div>

      {/* Main content container */}
      <div className="flex-1 p-6 space-y-6 text-right overflow-y-auto max-h-[calc(80vh-200px)] sm:max-h-96 bg-white">
        {/* Key information section */}
        <div className="grid grid-cols-2 gap-y-4 gap-x-6">
          {profile.birthDate && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">
                {calculateAge(new Date(profile.birthDate))} שנים
              </span>
              <CalendarClock className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.height && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.height} ס״מ</span>
              <User className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.maritalStatus}</span>
              <Heart className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.religiousLevel}</span>
              <Scroll className="w-5 h-5 text-blue-500" />
            </div>
          )}
        </div>

        <Separator className="my-4 bg-gray-200" />

        {/* Manual Entry Text (if applicable) */}
        {isManualEntry && profile.manualEntryText && (
          <div className="space-y-3">
            <div className="flex items-center justify-end gap-2">
              <h4 className="text-sm font-bold text-gray-600">
                תיאור ידני מהשדכן
              </h4>
              <Info className="w-5 h-5 text-purple-500" />
            </div>
            <p className="text-sm leading-relaxed py-3 px-4 bg-purple-50 rounded-md border border-purple-200 shadow-sm whitespace-pre-wrap">
              {profile.manualEntryText}
            </p>
          </div>
        )}

        {/* Education & Occupation (if not manual entry, or if manual entry but these fields are filled) */}
        {(!isManualEntry ||
          (isManualEntry &&
            (profile.education || profile.occupation || profile.city))) && (
          <div className="space-y-4">
            <h4 className="text-sm font-bold text-gray-600 mb-3">מידע נוסף</h4>
            {profile.education && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md">
                <span className="font-medium">{profile.education}</span>
                <GraduationCap className="w-5 h-5 text-blue-500" />
              </div>
            )}

            {profile.occupation && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
                <span className="font-medium">{profile.occupation}</span>
                <Briefcase className="w-5 h-5 text-blue-500" />
              </div>
            )}

            {profile.city && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
                <span className="font-medium">{profile.city}</span>
                <MapPin className="w-5 h-5 text-blue-500" />
              </div>
            )}
          </div>
        )}

        {/* About section (if not manual entry with text, or if manual entry but 'about' is also filled) */}
        {(!isManualEntry || !profile.manualEntryText) && profile.about && (
          <>
            <Separator className="my-4 bg-gray-200" />
            <div className="space-y-3">
              <h4 className="text-sm font-bold text-gray-600">אודות</h4>
              <p className="text-sm leading-relaxed py-3 px-4 bg-gray-50 rounded-md border border-gray-200 shadow-sm whitespace-pre-wrap">
                {profile.about}
              </p>
            </div>
          </>
        )}
      </div>

      {/* Action Buttons with improved layout */}
      <div className="p-4 bg-gray-50 border-t border-gray-200">
        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
          <Button
            variant="default"
            className="w-full bg-blue-500 hover:bg-blue-600 transition-colors shadow-sm"
            onClick={() => onAction("view")}
          >
            <Eye className="w-4 h-4 ml-1.5" />
            <span className="text-sm">צפייה בפרופיל</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("suggest")}
          >
            <FileText className="w-4 h-4 ml-1.5" />
            <span className="text-sm">הצעת שידוך</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("invite")}
          >
            <Mail className="w-4 h-4 ml-1.5" />
            <span className="text-sm">שליחת הזמנה</span>
          </Button>

          <Button
            variant="outline"
            className="w-full sm:col-span-2 border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("contact")}
          >
            <Clock className="w-4 h-4 ml-1.5" />
            <span className="text-sm">בדיקת זמינות</span>
          </Button>

          <Button
            variant="ghost"
            className="w-full hover:bg-blue-50 transition-colors bg-blue-50/50"
            onClick={() => onAction("edit")}
          >
            <Edit className="w-4 h-4 ml-1.5" />
            <span className="text-sm">עריכת פרופיל</span>
          </Button>
        </div>
      </div>
    </div>
  );
};

export default QuickView;
--- End of Content for QuickView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesList.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/CandidatesList.tsx

import React, { useState, useCallback, useEffect, useRef, useMemo } from "react";
import { UserX, Edit } from "lucide-react";
import MinimalCard from "../CandidateCard/MinimalCard";
import QuickView from "../CandidateCard/QuickView";
import { ProfileCard } from "@/app/components/profile";
import type { Candidate, CandidateAction, MobileView } from "../types/candidates";
import type { QuestionnaireResponse } from "@/types/next-auth";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { ActionDialogs } from "../dialogs/ActionDialogs";
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import MatchmakerEditProfile from "../MatchmakerEditProfile";
import { cn } from "@/lib/utils";

interface CreateSuggestionData {
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  firstPartyId: string;
  secondPartyId: string;
  status:
    | "DRAFT"
    | "PENDING_FIRST_PARTY"
    | "FIRST_PARTY_APPROVED"
    | "FIRST_PARTY_DECLINED"
    | string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
}

interface CandidatesListProps {
  candidates: (Candidate & { aiScore?: number })[];
  allCandidates: Candidate[];
  onCandidateClick?: (candidate: Candidate) => void;
  onCandidateAction?: (type: CandidateAction, candidate: Candidate) => void;
  viewMode: "grid" | "list";
  mobileView: MobileView;
  isLoading?: boolean;
  className?: string;
  highlightTerm?: string;
  
  // --- AI-RELATED PROPS ---
  aiTargetCandidate: Candidate | null;
  onSetAiTarget: (candidate: Candidate, e: React.MouseEvent) => void;
  comparisonSelection: Record<string, Candidate>;
  onToggleComparison: (candidate: Candidate, e: React.MouseEvent) => void;
}

const CandidatesList: React.FC<CandidatesListProps> = ({
  candidates,
  allCandidates,
  onCandidateClick,
  onCandidateAction,
  viewMode,
  mobileView,
  isLoading = false,
  className,
  highlightTerm,
  aiTargetCandidate,
  onSetAiTarget,
  comparisonSelection,
  onToggleComparison,
}) => {
  // Base states
  const [selectedCandidate, setSelectedCandidate] = useState<Candidate | null>(
    null
  );
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [isMatchmaker, setIsMatchmaker] = useState(false);
  const [hoveredCandidate, setHoveredCandidate] = useState<Candidate | null>(
    null
  );
  const [hoverPosition, setHoverPosition] = useState({ top: 0, left: 0 });
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const quickViewRef = useRef<HTMLDivElement>(null);

  // Dialog states
  const [showInviteDialog, setShowInviteDialog] = useState(false);
  const [showAvailabilityDialog, setShowAvailabilityDialog] = useState(false);
  const [showSuggestDialog, setShowSuggestDialog] = useState(false);
  const [showEditProfileDialog, setShowEditProfileDialog] = useState(false);
  const [dialogCandidate, setDialogCandidate] = useState<Candidate | null>(
    null
  );

  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    return () => {
      window.removeEventListener("resize", checkScreenSize);
    };
  }, []);

  // Close QuickView when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        hoveredCandidate &&
        quickViewRef.current &&
        !quickViewRef.current.contains(event.target as Node)
      ) {
        setHoveredCandidate(null);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [hoveredCandidate]);

  // Clean up timeout on unmount
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Load questionnaire when candidate is selected
  useEffect(() => {
    const loadQuestionnaire = async () => {
      if (!selectedCandidate) {
        setQuestionnaireResponse(null);
        return;
      }

      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${selectedCandidate.id}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          const formattedQuestionnaire = {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
          setQuestionnaireResponse(formattedQuestionnaire);
        }
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
      }
    };

    loadQuestionnaire();
  }, [selectedCandidate]);

  // Action handlers
  const handleInvite = async (candidate: Candidate, email: string) => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}/invite-setup`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          candidateId: candidate.id,
          email,
        }),
      });

      if (!response.ok) throw new Error("Failed to send invitation");

      toast.success("ההזמנה נשלחה בהצלחה");
      onCandidateAction?.("invite", candidate);
    } catch (error) {
      console.error("Error sending invite:", error);
      throw error;
    }
  };

  const handleAvailabilityCheck = async (candidate: Candidate) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clientId: candidate.id }),
      });

      if (!response.ok) throw new Error("Failed to check availability");

      toast.success("בדיקת הזמינות נשלחה");
      onCandidateAction?.("contact", candidate);
    } catch (error) {
      console.error("Error checking availability:", error);
      throw error;
    }
  };

  const handleCreateSuggestion = async (data: CreateSuggestionData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      toast.success("ההצעה נוצרה בהצלחה");
      onCandidateAction?.("suggest", dialogCandidate!);
    } catch (error) {
      console.error("Error creating suggestion:", error);
      throw error;
    }
  };

  const handleEditProfile = (candidate: Candidate) => {
    setDialogCandidate(candidate);
    setShowEditProfileDialog(true);
  };

  const handleMouseEnter = (candidate: Candidate, e?: React.MouseEvent) => {
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }

    let top = window.scrollY + window.innerHeight / 3;
    let left = window.innerWidth / 2;

    if (e) {
      const element = e.currentTarget as HTMLElement;
      if (element) {
        const rect = element.getBoundingClientRect();
        const screenMiddle = window.innerWidth / 2;
        const isRightPanel = rect.left < screenMiddle;

        top = rect.top + window.scrollY;

        if (isRightPanel) {
          left = Math.min(rect.right + 10, window.innerWidth - 430);
        } else {
          left = Math.max(rect.left - 430, 10);
        }
      }
    }

    hoverTimeoutRef.current = setTimeout(() => {
      setHoverPosition({ top, left });
      setHoveredCandidate(candidate);
    }, 300);
  };

  const handleMouseLeave = () => {
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
      hoverTimeoutRef.current = null;
    }

    setTimeout(() => {
      if (!quickViewRef.current?.matches(":hover")) {
        setHoveredCandidate(null);
      }
    }, 100);
  };

  const handleAction = useCallback(
    (action: CandidateAction, candidate: Candidate) => {
      setDialogCandidate(candidate);
      setHoveredCandidate(null);

      switch (action) {
        case "invite":
          setShowInviteDialog(true);
          break;
        case "contact":
          setShowAvailabilityDialog(true);
          break;
        case "suggest":
          setShowSuggestDialog(true);
          break;
        case "view":
          setSelectedCandidate(candidate);
          onCandidateClick?.(candidate);
          break;
        case "edit":
          handleEditProfile(candidate);
          break;
        default:
          onCandidateAction?.(action, candidate);
      }
    },
    [onCandidateAction, onCandidateClick]
  );
  
  const gridLayoutClass = useMemo(() => {
    if (isMobile) {
      // Mobile view logic
      return mobileView === 'double'
        ? 'grid grid-cols-2 gap-2' // Two columns for mobile
        : 'grid grid-cols-1 gap-3'; // Single column for mobile
    }
    // Desktop view logic
    return viewMode === 'grid'
      ? 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-3 gap-y-4'
      : 'space-y-4';
  }, [isMobile, mobileView, viewMode]);

  // Loading states render
  if (isLoading) {
    return (
      <div
        className={`${
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            : "space-y-4"
        } ${className || ""}`}
      >
        {Array.from({ length: 6 }).map((_, i) => (
          <div key={i} className="relative">
            <Skeleton
              className={
                viewMode === "list" ? "h-32 w-full" : "h-[350px] w-full"
              }
            />
            <div className="absolute top-3 right-3">
              <Skeleton className="h-6 w-16 rounded-full" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  // Empty state render with improved UI
  if (candidates.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-32 bg-gray-50 rounded-lg border border-dashed border-gray-300 p-4 text-center">
        <UserX className="w-8 h-8 mb-2 text-gray-400" />
        <p className="text-sm font-medium text-gray-500 mb-1">
          לא נמצאו מועמדים
        </p>
        <p className="text-xs text-gray-400">
          נסו להרחיב את החיפוש או להסיר חלק מהמסננים.
        </p>
      </div>
    );
  }

  return (
    <>
      <div className={cn(gridLayoutClass, className || "")}>
        {candidates.map((candidate) => (
          <div
            key={candidate.id}
            className="group relative"
            onMouseEnter={(e) => handleMouseEnter(candidate, e)}
            onMouseLeave={handleMouseLeave}
            onClick={() => handleAction("view", candidate)}
          >
            <MinimalCard
              candidate={candidate}
              onClick={() => handleAction("view", candidate)}
              onEdit={(c, e) => {
                e.stopPropagation();
                handleAction("edit", c);
              }}
              className={cn(
                viewMode === "list" && !isMobile ? "flex flex-row-reverse gap-4 h-32" : "",
                isMobile && mobileView === 'double' ? 'transform scale-90' : '',
                isMobile && mobileView === 'single' ? 'transform scale-95' : ''
              )}
              highlightTerm={highlightTerm}
              aiScore={candidate.aiScore}
              onSetAiTarget={onSetAiTarget}
              isAiTarget={aiTargetCandidate?.id === candidate.id}
              isSelectableForComparison={
                !!aiTargetCandidate &&
                aiTargetCandidate.profile.gender !== candidate.profile.gender &&
                aiTargetCandidate.id !== candidate.id
              }
              isSelectedForComparison={!!comparisonSelection[candidate.id]}
              onToggleComparison={onToggleComparison}
            />
            <button
              className="absolute top-2 left-2 bg-primary text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity z-10"
              onClick={(e) => {
                e.stopPropagation();
                handleAction("edit", candidate);
              }}
              aria-label="ערוך פרופיל"
              title="ערוך פרופיל"
            >
              <Edit className="w-4 h-4" />
            </button>
          </div>
        ))}
      </div>

      {hoveredCandidate && !isMobile && (
        <div
          ref={quickViewRef}
          className="fixed z-50 md:absolute transform -translate-x-1/2 sm:translate-x-0"
          style={{
            top: `${hoverPosition.top}px`,
            left: `${hoverPosition.left}px`,
            maxWidth: window.innerWidth < 768 ? "calc(100vw - 32px)" : "420px",
            ...(window.innerWidth < 768
              ? {
                  left: "50%",
                  transform: "translateX(-50%)",
                  maxHeight: "85vh",
                }
              : {}),
          }}
        >
          <div className="drop-shadow-2xl">
            <QuickView
              candidate={hoveredCandidate}
              onAction={(action) => handleAction(action, hoveredCandidate)}
              onSetAiTarget={(c, e) => onSetAiTarget(c, e)}
              isAiTarget={aiTargetCandidate?.id === hoveredCandidate.id}
            />
          </div>
        </div>
      )}

      <Dialog
        open={!!selectedCandidate}
        onOpenChange={(open) => {
          if (!open) {
            setSelectedCandidate(null);
            setQuestionnaireResponse(null);
          }
        }}
      >
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <div className="flex items-center justify-between">
              <DialogTitle>פרופיל מועמד</DialogTitle>
              <Button
                variant="outline"
                onClick={() => handleAction("edit", selectedCandidate!)}
                className="flex items-center gap-2"
              >
                <Edit className="w-4 h-4" />
                עריכת פרופיל
              </Button>
            </div>
            <DialogDescription>צפייה בפרטי המועמד</DialogDescription>
            <Select
              value={isMatchmaker ? "matchmaker" : "candidate"}
              onValueChange={(value) => setIsMatchmaker(value === "matchmaker")}
            >
              <SelectTrigger className="w-full sm:w-48">
                <SelectValue placeholder="בחר תצוגה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="candidate">תצוגת מועמד</SelectItem>
                <SelectItem value="matchmaker">תצוגת שדכן</SelectItem>
              </SelectContent>
            </Select>
          </DialogHeader>

          {selectedCandidate && (
            <div className="space-y-6">
              <ProfileCard
                profile={selectedCandidate.profile}
                images={selectedCandidate.images}
                questionnaire={questionnaireResponse}
                viewMode={isMatchmaker ? "matchmaker" : "candidate"}
              />
            </div>
          )}
        </DialogContent>
      </Dialog>

      <ActionDialogs
        suggestDialog={{
          isOpen: showSuggestDialog,
          onClose: () => setShowSuggestDialog(false),
          onSubmit: handleCreateSuggestion,
          selectedCandidate: dialogCandidate,
        }}
        availabilityDialog={{
          isOpen: showAvailabilityDialog,
          onClose: () => setShowAvailabilityDialog(false),
          onCheck: handleAvailabilityCheck,
          selectedCandidate: dialogCandidate,
        }}
        inviteDialog={{
          isOpen: showInviteDialog,
          onClose: () => setShowInviteDialog(false),
          onInvite: handleInvite,
          selectedCandidate: dialogCandidate,
        }}
      />

      <NewSuggestionForm
        isOpen={showSuggestDialog}
        onClose={() => setShowSuggestDialog(false)}
        candidates={allCandidates}
        selectedCandidate={selectedCandidate}
        onSubmit={handleCreateSuggestion}
      />

      <MatchmakerEditProfile
        isOpen={showEditProfileDialog}
        onClose={() => setShowEditProfileDialog(false)}
        candidate={dialogCandidate}
      />
    </>
  );
};

export default CandidatesList;
--- End of Content for CandidatesList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesStats.tsx
--------------------------------------------------------------------------------
Content:
// /CandidatesManager/CandidatesStats.tsx

"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Users,
  UserSquare2,
  Clock,
  MapPin,
  CheckCircle,
  Image as ImageIcon,
} from "lucide-react";
import { useStatistics } from "../hooks/useStatistics";
import type { Candidate } from "../types/candidates";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from "recharts";

interface StatCardProps {
  title: string;
  value: string | number;
  description?: string;
  icon: React.ReactNode;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

interface CandidatesStatsProps {
  candidates: Candidate[];
  className?: string;
}

const CHART_COLORS = [
  "#3B82F6", // כחול
  "#EF4444", // אדום
  "#10B981", // ירוק
  "#F59E0B", // כתום
  "#6366F1", // סגול
  "#EC4899", // ורוד
];

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  icon,
  trend,
  className,
}) => (
  <Card className={`p-6 ${className}`}>
    <div className="flex items-start justify-between">
      <div className="space-y-2">
        <p className="text-sm text-gray-500">{title}</p>
        <p className="text-2xl font-semibold">{value}</p>
        {description && <p className="text-xs text-gray-400">{description}</p>}
        {trend && (
          <div
            className={`text-xs flex items-center gap-1 ${
              trend.isPositive ? "text-green-600" : "text-red-600"
            }`}
          >
            <span>{trend.isPositive ? "↑" : "↓"}</span>
            <span>{Math.abs(trend.value)}%</span>
            <span>מהחודש שעבר</span>
          </div>
        )}
      </div>
      <div className="bg-blue-50 p-3 rounded-lg">{icon}</div>
    </div>
  </Card>
);

const CandidatesStats: React.FC<CandidatesStatsProps> = ({
  candidates,
  className,
}) => {
  const {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats,
  } = useStatistics(candidates);

  const genderRatio = getGenderRatio();
  const activeUsers = getActiveUsersPercent();
  const completionStats = getProfileCompletionStats();
  const ageDistribution = getAgeGroupDistribution();
  const religiousDistribution = getReligiousDistribution();
  const activityTrend = getActivityTrend();
  const topCities = getTopCities(5);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* סטטיסטיקות עיקריות */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          title="סה״כ מועמדים"
          value={stats.gender.total}
          icon={<Users className="w-6 h-6 text-blue-600" />}
          description="סה״כ מועמדים פעילים במערכת"
        />
        <StatCard
          title="יחס מועמדים/ות"
          value={genderRatio.formattedRatio}
          icon={<UserSquare2 className="w-6 h-6 text-blue-600" />}
          description="גברים/נשים"
        />
        <StatCard
          title="פעילות בשבוע האחרון"
          value={`${activeUsers}%`}
          icon={<Clock className="w-6 h-6 text-blue-600" />}
          trend={{
            value: 5,
            isPositive: true,
          }}
        />
        <StatCard
          title="פרופילים מלאים"
          value={`${completionStats.percentage}%`}
          icon={<CheckCircle className="w-6 h-6 text-blue-600" />}
          description={`${completionStats.completed} מתוך ${stats.gender.total}`}
        />
      </div>

      {/* טאבים לניתוחים מתקדמים */}
      <Tabs defaultValue="demographics" className="w-full">
        <TabsList className="w-full justify-start">
          <TabsTrigger value="demographics">דמוגרפיה</TabsTrigger>
          <TabsTrigger value="activity">פעילות</TabsTrigger>
          <TabsTrigger value="completion">שלמות פרופילים</TabsTrigger>
        </TabsList>

        {/* דמוגרפיה */}
        <TabsContent value="demographics">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* התפלגות גילאים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות גילאים</h3>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={ageDistribution}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="range" />
                  <YAxis />
                  <Tooltip />
                  <Bar dataKey="count" fill="#3B82F6" />
                </BarChart>
              </ResponsiveContainer>
            </Card>

            {/* התפלגות דתית */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות רמת דתיות</h3>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={religiousDistribution}
                    dataKey="count"
                    nameKey="level"
                    cx="50%"
                    cy="50%"
                    outerRadius={100}
                    label
                  >
                    {religiousDistribution.map((_, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={CHART_COLORS[index % CHART_COLORS.length]}
                      />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </Card>

            {/* מיקומים מובילים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">ערים מובילות</h3>
              <div className="space-y-4">
                {topCities.map((city) => (
                  <div
                    key={city.city}
                    className="flex items-center justify-between"
                  >
                    <div className="flex items-center gap-2">
                      <MapPin className="w-4 h-4 text-blue-600" />
                      <span>{city.city}</span>
                    </div>
                    <span className="font-medium">{city.count}</span>
                  </div>
                ))}
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* פעילות */}
        <TabsContent value="activity">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* פעילות לאורך זמן */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">פעילות משתמשים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <span>פעילים בשבוע האחרון</span>
                  <span className="font-medium">{activityTrend.weekly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>פעילים בחודש האחרון</span>
                  <span className="font-medium">{activityTrend.monthly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>ממוצע ימים בין התחברויות</span>
                  <span className="font-medium">
                    {activityTrend.average} ימים
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* שלמות פרופילים */}
        <TabsContent value="completion">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">שלמות פרופילים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <ImageIcon className="w-4 h-4 text-blue-600" />
                    <span>תמונות פרופיל</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasPhotos}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <CheckCircle className="w-4 h-4 text-blue-600" />
                    <span>פרופיל מאומת</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.isVerified}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Users className="w-4 h-4 text-blue-600" />
                    <span>המלצות</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasReferences}%
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default CandidatesStats;
--- End of Content for CandidatesStats.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\SplitView.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/SplitView.tsx

"use client";

import React, { useMemo, useEffect, useState } from "react";
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import CandidatesList from "./CandidatesList";
import { Badge } from "@/components/ui/badge";
import { Sparkles, XCircle, Users, User } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import type { Candidate, CandidateAction, MobileView } from "../types/candidates";
import type { FilterState } from "../types/filters";
import SearchBar from "../Filters/SearchBar";
import { toast } from "sonner";
import { cn } from "@/lib/utils";
import { Gender } from "@prisma/client";

interface AiMatch {
  userId: string;
  score: number;
}

interface SplitViewProps {
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  allCandidates: Candidate[];
  onCandidateAction: (type: CandidateAction, candidate: Candidate) => void;
  onCandidateClick: (candidate: Candidate) => void;
  viewMode: "grid" | "list";
  mobileView: MobileView;
  isLoading?: boolean;
  className?: string;
  
  // --- AI State and Handlers (Received from Parent) ---
  aiTargetCandidate: Candidate | null;
  aiMatches: AiMatch[];
  isAiLoading: boolean;
  onSetAiTarget: (candidate: Candidate, e: React.MouseEvent) => void;
  onClearAiTarget: (e: React.MouseEvent) => void;
  setAiMatches: React.Dispatch<React.SetStateAction<AiMatch[]>>;
  setIsAiLoading: React.Dispatch<React.SetStateAction<boolean>>;
  comparisonSelection: Record<string, Candidate>;
  onToggleComparison: (candidate: Candidate, e: React.MouseEvent) => void;

  // --- Filter Props ---
  separateFiltering: boolean;
  maleFilters?: Partial<FilterState>;
  femaleFilters?: Partial<FilterState>;
  onMaleFiltersChange: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange: (filters: Partial<FilterState>) => void;
  onCopyFilters: (source: "male" | "female", target: "male" | "female") => void;
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  onMaleSearchChange?: (query: string) => void;
  onFemaleSearchChange?: (query: string) => void;
}

const SplitView: React.FC<SplitViewProps> = (props) => {
  const {
    maleCandidates,
    femaleCandidates,
    allCandidates,
    onCandidateAction,
    onCandidateClick,
    viewMode,
    mobileView,
    isLoading = false,
    className,
    maleSearchQuery = "",
    femaleSearchQuery = "",
    onMaleSearchChange,
    onFemaleSearchChange,
    // --- Destructure AI props ---
    aiTargetCandidate,
    aiMatches,
    isAiLoading,
    onSetAiTarget,
    onClearAiTarget,
    setAiMatches,
    setIsAiLoading,
    comparisonSelection,
    onToggleComparison,
  } = props;

  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreenSize = () => setIsMobile(window.innerWidth < 768);
    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);
    return () => window.removeEventListener("resize", checkScreenSize);
  }, []);

  const handleFindAiMatches = async (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!aiTargetCandidate) return;

    setIsAiLoading(true);
    setAiMatches([]);

    const targetGender = aiTargetCandidate.profile.gender;
    const candidatePool = targetGender === Gender.MALE ? femaleCandidates : maleCandidates;
    const candidatePoolIds = candidatePool.map(c => c.id);

    if (candidatePoolIds.length === 0) {
      toast.error("אין מועמדים במאגר לחיפוש התאמות.", { position: "top-center" });
      setIsAiLoading(false);
      return;
    }
    
    try {
      const response = await fetch('/api/ai/find-matches', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ targetUserId: aiTargetCandidate.id, candidatePoolIds }),
      });

      const data = await response.json();
      if (!response.ok || !data.success) throw new Error(data.error || 'Failed to fetch AI matches');
      
      setAiMatches(data.matches);
      toast.success(`נמצאו ${data.matches.length} התאמות AI פוטנציאליות.`, {
         position: "top-center",
         description: "המועמדים המומלצים מסומנים ומוינו לראש הרשימה."
      });
    } catch (error) {
      console.error("Error finding AI matches:", error);
      toast.error("שגיאה במציאת התאמות AI.", {
          description: error instanceof Error ? error.message : "נסה שוב מאוחר יותר.",
      });
    } finally {
      setIsAiLoading(false);
    }
  };
  
  const maleCandidatesWithScores = useMemo(() => {
    if (aiMatches.length === 0) return maleCandidates;
    const scoreMap = new Map(aiMatches.map(m => [m.userId, m.score]));
    return maleCandidates
      .map(c => ({ ...c, aiScore: scoreMap.get(c.id) }))
      .sort((a, b) => (b.aiScore ?? -1) - (a.aiScore ?? -1));
  }, [maleCandidates, aiMatches]);

  const femaleCandidatesWithScores = useMemo(() => {
    if (aiMatches.length === 0) return femaleCandidates;
    const scoreMap = new Map(aiMatches.map(m => [m.userId, m.score]));
    return femaleCandidates
      .map(c => ({ ...c, aiScore: scoreMap.get(c.id) }))
      .sort((a, b) => (b.aiScore ?? -1) - (a.aiScore ?? -1));
  }, [femaleCandidates, aiMatches]);

  const renderPanelHeader = (gender: 'male' | 'female', isMobileView: boolean = false) => {
      const panelGenderEnum = gender === 'male' ? Gender.MALE : Gender.FEMALE;
      const isTargetPanel = aiTargetCandidate?.profile.gender === panelGenderEnum;
      const isSearchPanel = aiTargetCandidate && aiTargetCandidate.profile.gender !== panelGenderEnum;
      const count = gender === 'male' ? maleCandidates.length : femaleCandidates.length;

      return (
        <div className={cn("flex justify-between items-center mb-2 p-2 rounded-t-lg", !isMobileView && "bg-gray-50 border-b")}>
          <h2 className={cn("text-lg font-bold", gender === 'male' ? "text-blue-800" : "text-purple-800")}>
            {gender === 'male' ? `מועמדים (${count})` : `מועמדות (${count})`}
          </h2>
          <div className="flex-grow" />
          <div className="flex items-center gap-2">
              {isTargetPanel && aiTargetCandidate && (
                <div className="flex items-center gap-2 bg-green-100 p-1.5 rounded-full shadow-sm animate-fade-in">
                  <span className="text-xs font-medium text-green-800 px-2">מטרה: {aiTargetCandidate.firstName}</span>
                  <Button size="icon" variant="ghost" className="h-6 w-6 text-green-700 hover:bg-green-200 rounded-full" onClick={onClearAiTarget}>
                    <XCircle className="h-4 w-4"/>
                  </Button>
                </div>
              )}
              {isSearchPanel && (
                <Button size="sm" onClick={handleFindAiMatches} disabled={isAiLoading}>
                  <Sparkles className={`ml-2 h-4 w-4 ${isAiLoading ? 'animate-spin' : ''}`}/>
                  {isAiLoading ? 'מחפש...' : 'מצא התאמות AI'}
                </Button>
              )}
          </div>
        </div>
      );
  };

  // --- Mobile View Logic ---
  if (isMobile) {
    if (mobileView === 'split') {
      // --- START OF CHANGE ---
      // The container now has h-full to take the height from its parent in CandidatesManager
      return (
        <div className="grid grid-cols-2 gap-2 h-full">
          {/* Male Candidates Column */}
          <div className="flex flex-col h-full">
            <div className="p-2 text-center flex-shrink-0">
              <h2 className="text-sm font-bold text-blue-800 flex items-center justify-center gap-1">
                <User className="w-4 h-4" /> מועמדים <Badge variant="secondary">{maleCandidates.length}</Badge>
              </h2>
            </div>
            {/* This div will grow to fill the space and handle its own scrolling */}
            <div className="flex-grow min-h-0 overflow-y-auto">
              <CandidatesList
                candidates={maleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode="grid"
                mobileView="single"
                isLoading={isLoading}
                highlightTerm={maleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>

          {/* Female Candidates Column */}
          <div className="flex flex-col h-full">
            <div className="p-2 text-center flex-shrink-0">
              <h2 className="text-sm font-bold text-purple-800 flex items-center justify-center gap-1">
                <User className="w-4 h-4" /> מועמדות <Badge variant="secondary">{femaleCandidates.length}</Badge>
              </h2>
            </div>
            <div className="flex-grow min-h-0 overflow-y-auto">
              <CandidatesList
                candidates={femaleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode="grid"
                mobileView="single"
                isLoading={isLoading}
                highlightTerm={femaleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </div>
      );
      // --- END OF CHANGE ---
    }

    // Original Tabs view for 'single' or 'double' column modes
    return (
        <div className={cn("w-full h-full", className)}>
            <Tabs defaultValue="male" className="w-full h-full flex flex-col">
                <TabsList className="grid w-full grid-cols-2 flex-shrink-0">
                    <TabsTrigger value="male" className="flex items-center gap-2">
                        <User className="h-4 w-4"/> מועמדים <Badge variant="secondary">{maleCandidates.length}</Badge>
                    </TabsTrigger>
                    <TabsTrigger value="female" className="flex items-center gap-2">
                        <User className="h-4 w-4"/> מועמדות <Badge variant="secondary">{femaleCandidates.length}</Badge>
                    </TabsTrigger>
                </TabsList>
                <TabsContent value="male" className="mt-4 flex-1 min-h-0">
                    <div className="p-1 flex flex-col h-full">
                        {renderPanelHeader('male', true)}
                        {onMaleSearchChange && <SearchBar value={maleSearchQuery} onChange={onMaleSearchChange} placeholder="חיפוש מועמדים..." genderTarget="male" separateMode={true} />}
                        <div className="flex-grow min-h-0 overflow-y-auto">
                            <CandidatesList
                                candidates={maleCandidatesWithScores}
                                allCandidates={allCandidates}
                                onCandidateClick={onCandidateClick}
                                onCandidateAction={onCandidateAction}
                                viewMode={viewMode}
                                mobileView={mobileView}
                                isLoading={isLoading}
                                highlightTerm={maleSearchQuery}
                                aiTargetCandidate={aiTargetCandidate}
                                onSetAiTarget={onSetAiTarget}
                                comparisonSelection={comparisonSelection}
                                onToggleComparison={onToggleComparison}
                            />
                        </div>
                    </div>
                </TabsContent>
                <TabsContent value="female" className="mt-4 flex-1 min-h-0">
                    <div className="p-1 flex flex-col h-full">
                        {renderPanelHeader('female', true)}
                        {onFemaleSearchChange && <SearchBar value={femaleSearchQuery} onChange={onFemaleSearchChange} placeholder="חיפוש מועמדות..." genderTarget="female" separateMode={true} />}
                        <div className="flex-grow min-h-0 overflow-y-auto">
                            <CandidatesList
                                candidates={femaleCandidatesWithScores}
                                allCandidates={allCandidates}
                                onCandidateClick={onCandidateClick}
                                onCandidateAction={onCandidateAction}
                                viewMode={viewMode}
                                mobileView={mobileView}
                                isLoading={isLoading}
                                highlightTerm={femaleSearchQuery}
                                aiTargetCandidate={aiTargetCandidate}
                                onSetAiTarget={onSetAiTarget}
                                comparisonSelection={comparisonSelection}
                                onToggleComparison={onToggleComparison}
                            />
                        </div>
                    </div>
                </TabsContent>
            </Tabs>
        </div>
    );
  }

  // --- Desktop View using Resizable Panels ---
  return (
    <div className={cn("h-full", className)}>
      <ResizablePanelGroup direction="horizontal" className="h-full rounded-lg bg-white shadow-sm border">
        <ResizablePanel defaultSize={50} minSize={30}>
          <div className="p-3 flex flex-col h-full">
            {renderPanelHeader('male')}
            {onMaleSearchChange && <SearchBar value={maleSearchQuery} onChange={onMaleSearchChange} placeholder="חיפוש מועמדים..." genderTarget="male" separateMode={true} />}
            <div className="flex-grow min-h-0 overflow-y-auto">
              <CandidatesList
                candidates={maleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={isLoading}
                highlightTerm={maleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </ResizablePanel>
        <ResizableHandle withHandle />
        <ResizablePanel defaultSize={50} minSize={30}>
          <div className="p-3 flex flex-col h-full">
            {renderPanelHeader('female')}
            {onFemaleSearchChange && <SearchBar value={femaleSearchQuery} onChange={onFemaleSearchChange} placeholder="חיפוש מועמדות..." genderTarget="female" separateMode={true} />}
            <div className="flex-grow min-h-0 overflow-y-auto">
               <CandidatesList
                candidates={femaleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={isLoading}
                highlightTerm={femaleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  );
};

export default SplitView;
--- End of Content for SplitView.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\StatsCard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };
  variant?: "default" | "success" | "warning" | "destructive";
  bgGradient?: string;
  iconColor?: string;
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  variant = "default",
  bgGradient,
  iconColor = "text-primary",
  className,
}) => {
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "border-emerald-200";
      case "warning":
        return "border-amber-200";
      case "destructive":
        return "border-red-200";
      default:
        return "border-gray-200";
    }
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-all duration-300 p-4 overflow-hidden",
        bgGradient ? `bg-gradient-to-br ${bgGradient}` : "bg-card",
        getVariantStyles(),
        className
      )}
    >
      <div className="flex items-start justify-between">
        <div className="mr-4 flex-shrink-0">
          <div className={`p-2.5 rounded-full bg-white/60 backdrop-blur-sm shadow-sm`}>
            <Icon className={`w-4 h-4 ${iconColor}`} />
          </div>
        </div>

        <div className="flex-1 text-right">
          <p className="text-xs text-muted-foreground mb-1">{title}</p>
          <h3 className="text-xl font-bold">{value}</h3>

          {trend && (
            <div className="flex items-center justify-end gap-1 mt-1">
              <span
                className={cn(
                  "text-sm font-medium flex items-center gap-0.5",
                  trend.isPositive ? "text-emerald-600" : "text-red-600"
                )}
              >
                {trend.isPositive ? "+" : "-"}{trend.value}%
                <span className={`${trend.isPositive ? "rotate-0" : "rotate-180"} transition-transform`}>
                  ↑
                </span>
              </span>
              <span className="text-[11px] text-muted-foreground">
                {trend.label}
              </span>
            </div>
          )}
        </div>
      </div>

      {/* Animated background pattern for more visual appeal */}
      <div className="absolute right-0 bottom-0 opacity-10 pointer-events-none">
        <svg width="80" height="80" viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="60" cy="60" r="40" fill="currentColor" />
        </svg>
      </div>
    </Card>
  );
};

export default StatsCard;
--- End of Content for StatsCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\index.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/index.tsx

"use client";

import React, { useState, useCallback, useEffect, useMemo } from "react";
import { Button } from "@/components/ui/button";
import { UserPlus, Filter, LayoutGrid, List, ArrowUpDown, RotateCw, BarChart2, Bot, Loader2, Columns, View, Users, Split } from "lucide-react";
import { toast } from "sonner";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuRadioGroup, DropdownMenuRadioItem } from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useSession } from "next-auth/react";

// Custom Hooks
import { useCandidates } from "../hooks/useCandidates";
import { useFilterLogic } from "../hooks/useFilterLogic";

// Components
import SplitView from "./SplitView";
import FilterPanel from "../Filters/FilterPanel";
import ActiveFilters from "../Filters/ActiveFilters";
import SearchBar from "../Filters/SearchBar";
import { LoadingContainer } from "../shared/LoadingStates";
import { AddManualCandidateDialog } from "../dialogs/AddManualCandidateDialog";
import { AiMatchAnalysisDialog } from "../dialogs/AiMatchAnalysisDialog";

// Types
import type { Candidate, ViewMode, CandidatesFilter, CandidateAction, MobileView } from "../types/candidates"; 

// Constants
import { SORT_OPTIONS, VIEW_OPTIONS } from "../constants/filterOptions";

interface AiMatch {
  userId: string;
  score: number;
}

const CandidatesManager: React.FC = () => {
  // --- UI and General State ---
  const [viewMode, setViewMode] = useState<ViewMode>("grid");
  const [mobileView, setMobileView] = useState<MobileView>('split'); 
  const [showFiltersPanel, setShowFiltersPanel] = useState(false);
  const [showFiltersMobile, setShowFiltersMobile] = useState(false);
  const [showManualAddDialog, setShowManualAddDialog] = useState(false);
  
  // --- AI State Management ---
  const [aiTargetCandidate, setAiTargetCandidate] = useState<Candidate | null>(null);
  const [comparisonSelection, setComparisonSelection] = useState<Record<string, Candidate>>({});
  const [aiMatches, setAiMatches] = useState<AiMatch[]>([]);
  const [isAiLoading, setIsAiLoading] = useState(false);
  const [isAnalysisDialogOpen, setIsAnalysisDialogOpen] = useState(false);
  const [isBulkUpdating, setIsBulkUpdating] = useState(false); 

  // --- Session and Permissions ---
  const { data: session } = useSession();
  const isAdmin = session?.user?.role === 'ADMIN';

  // Custom Hooks
  const {
    loading,
    candidates,
    maleCandidates,
    femaleCandidates,
    setSorting,
    setFilters,
    refresh,
  } = useCandidates();

  const {
    filters,
    savedFilters,
    recentSearches,
    popularFilters,
    activeFilters,
    saveFilter,
    resetFilters,
    clearRecentSearches,
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
  } = useFilterLogic({
    onFilterChange: setFilters,
  });

  // --- Handlers ---
  const handleCandidateAdded = useCallback(() => { refresh(); toast.success("מועמד חדש נוסף בהצלחה!"); }, [refresh]);
  const handleSearch = useCallback((value: string) => { if (!filters.separateFiltering) { setFilters(prev => ({ ...prev, searchQuery: value })); } }, [setFilters, filters.separateFiltering]);
  const handleRemoveFilter = useCallback((key: keyof CandidatesFilter, value?: string) => { setFilters(prev => { const newFilters = { ...prev }; if (key === "cities" && value) newFilters.cities = newFilters.cities?.filter(city => city !== value); else if (key === "occupations" && value) newFilters.occupations = newFilters.occupations?.filter(occ => occ !== value); else delete newFilters[key]; return newFilters; }); }, [setFilters]);
  const handleCandidateAction = useCallback(async (type: CandidateAction, candidate: Candidate) => { console.log(`Action '${type}' triggered for candidate: ${candidate.firstName}`); }, []);
  const handleFilterSave = useCallback(async (name: string) => { try { await saveFilter(name, filters); toast.success("הפילטר נשמר בהצלחה"); } catch { toast.error("שגיאה בשמירת הפילטר"); } }, [filters, saveFilter]);
  const handleSetAiTarget = useCallback((candidate: Candidate, e: React.MouseEvent) => { e.stopPropagation(); if (aiTargetCandidate?.id === candidate.id) { handleClearAiTarget(e); return; } setAiTargetCandidate(candidate); setAiMatches([]); setComparisonSelection({}); toast.info(`מועמד מטרה נבחר: ${candidate.firstName}. כעת ניתן לחפש התאמות בפאנל הנגדי.`, { position: "bottom-center" }); }, [aiTargetCandidate]);
  const handleClearAiTarget = (e: React.MouseEvent) => { e.stopPropagation(); setAiTargetCandidate(null); setAiMatches([]); setComparisonSelection({}); toast.info("בחירת מועמד מטרה בוטלה.", { position: "bottom-center" }); };
  const handleToggleComparison = useCallback((candidate: Candidate, e: React.MouseEvent) => { e.stopPropagation(); setComparisonSelection(prev => { const newSelection = {...prev}; if (newSelection[candidate.id]) { delete newSelection[candidate.id]; } else { newSelection[candidate.id] = candidate; } return newSelection; }); }, []);
  const handleUpdateAllProfiles = async () => { setIsBulkUpdating(true); toast.info("מתחיל תהליך עדכון פרופילי AI...", { description: "התהליך ירוץ ברקע. אין צורך להישאר בעמוד זה.", }); try { const response = await fetch('/api/ai/update-all-profiles', { method: 'POST', }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'שגיאה בהפעלת העדכון הכללי.'); toast.success("העדכון הכללי הופעל בהצלחה!", { description: data.message, duration: 8000, }); } catch (error) { console.error("Failed to initiate bulk AI profile update:", error); toast.error("שגיאה בהפעלת העדכון", { description: error instanceof Error ? error.message : 'אנא נסה שוב מאוחר יותר.', }); } finally { setIsBulkUpdating(false); } };
  
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreen = () => {
      const isDesktop = window.innerWidth >= 1024;
      const isMob = window.innerWidth < 768;
      setShowFiltersPanel(isDesktop);
      setIsMobile(isMob);
    };
    checkScreen();
    window.addEventListener('resize', checkScreen);
    return () => window.removeEventListener('resize', checkScreen);
  }, []);

  const activeFilterCount = useMemo(() => activeFilters.length, [activeFilters]);

  return (
    // --- START OF FIX ---
    // 1. שינוי מבנה העמוד הראשי ל-flex-col עם גובה מסך מלא (h-screen)
    //    זה מאפשר לנו לשלוט בגובה של אזור התוכן הראשי.
    <div className="h-screen flex flex-col bg-gray-50/50">
      {/* 2. הכותרת הופכת ל-flex-shrink-0 כדי לא לתפוס גובה גמיש.
          הסרנו את "sticky" כדי לאפשר layout יציב ופשוט יותר. */}
      <header className="flex-shrink-0 z-30 bg-white/80 backdrop-blur-sm border-b shadow-sm">
        <div className="container mx-auto py-3 px-4">
          <div className="flex justify-between items-center mb-4">
            <h1 className="text-2xl font-bold text-primary/90">ניהול מועמדים</h1>
            <div className="flex items-center gap-2">
              <Button onClick={() => setShowManualAddDialog(true)} size="sm">
                <UserPlus className="w-4 h-4 ml-2" />
                הוסף מועמד ידנית
              </Button>
               {Object.keys(comparisonSelection).length > 0 && aiTargetCandidate && (
                <Button onClick={() => setIsAnalysisDialogOpen(true)} size="sm" variant="secondary">
                    <BarChart2 className="w-4 h-4 ml-2"/>
                    נתח התאמה ({Object.keys(comparisonSelection).length})
                </Button>
              )}
              
              {isAdmin && (
                <AlertDialog>
                    <AlertDialogTrigger asChild>
                        <Button variant="destructive" size="sm" disabled={isBulkUpdating || loading}>
                            {isBulkUpdating ? <Loader2 className="w-4 h-4 ml-2 animate-spin" /> : <Bot className="w-4 h-4 ml-2" />}
                            עדכון כללי AI
                        </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent dir="rtl">
                        <AlertDialogHeader>
                            <AlertDialogTitle>אישור עדכון AI כללי</AlertDialogTitle>
                            <AlertDialogDescription>
                                פעולה זו תפעיל תהליך עדכון וקטורים עבור **כל** המשתמשים הפעילים. 
                                התהליך ירוץ ברקע ועשוי לקחת מספר דקות. 
                                האם אתה בטוח שברצונך להמשיך?
                            </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                            <AlertDialogCancel>ביטול</AlertDialogCancel>
                            <AlertDialogAction onClick={handleUpdateAllProfiles}>כן, הפעל עדכון</AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialog>
              )}

              <Button onClick={refresh} variant="outline" size="icon" title="רענן רשימה" disabled={loading}>
                <RotateCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </Button>
            </div>
          </div>
          <div className="flex flex-col sm:flex-row gap-2">
            {!filters.separateFiltering && (
              <div className="flex-1">
                <SearchBar
                  value={filters.searchQuery || ""}
                  onChange={handleSearch}
                  placeholder="חיפוש כללי בשם, עיר, עיסוק..."
                  recentSearches={recentSearches}
                  onClearRecentSearches={clearRecentSearches}
                />
              </div>
            )}
            <div className="flex gap-2 justify-between">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm"><ArrowUpDown className="w-4 h-4 ml-2" />מיון</Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuLabel>מיון לפי</DropdownMenuLabel>
                  <DropdownMenuSeparator />
                  {SORT_OPTIONS.map((option) => (
                    <DropdownMenuItem key={option.value} onClick={() => setSorting(option.value, option.defaultOrder as "asc" | "desc")}>
                      {option.label}
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>

              <div className="hidden lg:flex">
                <Button variant="outline" size="sm" onClick={() => setShowFiltersPanel(!showFiltersPanel)}>
                  <Filter className="w-4 h-4 ml-2" />
                  {showFiltersPanel ? "הסתר סינון" : "הצג סינון"}
                </Button>
              </div>

              <Sheet open={showFiltersMobile} onOpenChange={setShowFiltersMobile}>
                <SheetTrigger asChild>
                  <Button variant="outline" size="sm" className="lg:hidden relative">
                    <Filter className="w-4 h-4 ml-2" />
                    סינון
                    {activeFilterCount > 0 && <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center">{activeFilterCount}</Badge>}
                  </Button>
                </SheetTrigger>
                <SheetContent>
                    <FilterPanel
                        filters={filters}
                        onFiltersChange={setFilters}
                        onSavePreset={handleFilterSave}
                        onReset={resetFilters}
                        savedFilters={savedFilters.map((f) => ({ id: f.id, name: f.name, isDefault: f.isDefault }))}
                        popularFilters={popularFilters}
                        separateFiltering={filters.separateFiltering}
                        onToggleSeparateFiltering={toggleSeparateFiltering}
                        onMaleFiltersChange={updateMaleFilters}
                        onFemaleFiltersChange={updateFemaleFilters}
                        onCopyFilters={copyFilters}
                    />
                </SheetContent>
              </Sheet>
              
               <div className="flex gap-1 bg-gray-100 p-1 rounded-lg">
                {isMobile ? (
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="outline" size="sm" className="w-32 justify-between px-2">
                        {mobileView === 'split' && (
                          <>
                            <Users className="w-4 h-4" />
                            <span>מפוצל</span>
                          </>
                        )}
                        {mobileView === 'single' && (
                          <>
                            <View className="w-4 h-4" />
                            <span>טור אחד</span>
                          </>
                        )}
                        {mobileView === 'double' && (
                          <>
                            <Columns className="w-4 h-4" />
                            <span>שני טורים</span>
                          </>
                        )}
                        <ArrowUpDown className="w-3 h-3 opacity-50 ml-2" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuLabel>תצוגת מובייל</DropdownMenuLabel>
                      <DropdownMenuSeparator />
                      <DropdownMenuRadioGroup value={mobileView} onValueChange={(value) => setMobileView(value as MobileView)}>
                        <DropdownMenuRadioItem value="split">
                          <Users className="w-4 h-4 mr-2" />
                          תצוגה מפוצלת (גברים/נשים)
                        </DropdownMenuRadioItem>
                        <DropdownMenuRadioItem value="single">
                          <View className="w-4 h-4 mr-2" />
                          תצוגת טור אחד
                        </DropdownMenuRadioItem>
                        <DropdownMenuRadioItem value="double">
                          <Columns className="w-4 h-4 mr-2" />
                          תצוגת שני טורים
                        </DropdownMenuRadioItem>
                      </DropdownMenuRadioGroup>
                    </DropdownMenuContent>
                  </DropdownMenu>
                ) : (
                  VIEW_OPTIONS.map((option) => (
                    <Button key={option.value} variant={viewMode === option.value ? "default" : "ghost"} size="icon" onClick={() => setViewMode(option.value as ViewMode)}>
                      {option.value === 'grid' ? <LayoutGrid className="w-4 h-4"/> : <List className="w-4 h-4"/>}
                    </Button>
                  ))
                )}
              </div>
            </div>
          </div>
          <div className="mt-4">
            <ActiveFilters filters={filters} onRemoveFilter={handleRemoveFilter} onResetAll={resetFilters} />
          </div>
        </div>
      </header>
      
      {/* 3. אזור התוכן הראשי מקבל flex-1 ו-min-h-0 כדי למלא את הגובה הנותר ולא לגלוש החוצה. */}
      <main className="flex-1 min-h-0 container mx-auto py-6 px-4">
        {/* 4. הקונטיינר הפנימי מקבל h-full כדי להעביר את הגובה הלאה לילדיו. */}
        <div className="flex gap-6 h-full">
          {showFiltersPanel && (
            // 5. פאנל הסינון בצד - אם הוא נהיה ארוך מדי, הוא יגלוש פנימית.
            <aside className="hidden lg:block w-80 flex-shrink-0 overflow-y-auto">
              <FilterPanel
                filters={filters}
                onFiltersChange={setFilters}
                onSavePreset={handleFilterSave}
                onReset={resetFilters}
                savedFilters={savedFilters.map((f) => ({ id: f.id, name: f.name, isDefault: f.isDefault }))}
                popularFilters={popularFilters}
                separateFiltering={filters.separateFiltering}
                onToggleSeparateFiltering={toggleSeparateFiltering}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
              />
            </aside>
          )}

          {/* 6. הקונטיינר של SplitView מקבל h-full כדי שהוא ידע מה הגובה שלו. */}
          <div className="flex-1 min-w-0 h-full">
            {loading ? (
              <LoadingContainer>
                {/* התאמת גובה הסקלטון לגובה המלא של הקונטיינר */}
                <div className="h-full bg-gray-200 rounded-lg animate-pulse"></div>
              </LoadingContainer>
            ) : (
              // 7. SplitView מקבלת h-full וכעת יכולה לממש את הגלילה הפנימית הנפרדת לכל עמודה.
              <SplitView
                maleCandidates={maleCandidates}
                femaleCandidates={femaleCandidates}
                allCandidates={candidates}
                onCandidateAction={handleCandidateAction}
                onCandidateClick={() => {}}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={loading || isAiLoading}
                className="h-full" // הוספת h-full כאן היא קריטית
                
                aiTargetCandidate={aiTargetCandidate}
                aiMatches={aiMatches}
                isAiLoading={isAiLoading}
                onSetAiTarget={handleSetAiTarget}
                onClearAiTarget={handleClearAiTarget}
                setAiMatches={setAiMatches}
                setIsAiLoading={setIsAiLoading}
                comparisonSelection={comparisonSelection}
                onToggleComparison={handleToggleComparison}
                
                separateFiltering={filters.separateFiltering ?? false}
                maleFilters={filters.maleFilters}
                femaleFilters={filters.femaleFilters}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
                maleSearchQuery={filters.maleSearchQuery}
                femaleSearchQuery={filters.femaleSearchQuery}
                onMaleSearchChange={updateMaleSearchQuery}
                onFemaleSearchChange={updateFemaleSearchQuery}
              />
            )}
          </div>
        </div>
      </main>
      {/* --- END OF FIX --- */}

      {/* Dialogs */}
      <AddManualCandidateDialog
        isOpen={showManualAddDialog}
        onClose={() => setShowManualAddDialog(false)}
        onCandidateAdded={handleCandidateAdded}
      />

      <AiMatchAnalysisDialog
        isOpen={isAnalysisDialogOpen}
        onClose={() => setIsAnalysisDialogOpen(false)}
        targetCandidate={aiTargetCandidate}
        comparisonCandidates={Object.values(comparisonSelection)}
      />
    </div>
  );
};

export default CandidatesManager;
--- End of Content for index.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\ActiveFilters.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { X, RefreshCw, Sparkles } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import type { CandidatesFilter } from "../types/candidates";
import { motion, AnimatePresence } from "framer-motion";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ActiveFiltersProps {
  filters: CandidatesFilter;
  onRemoveFilter: (key: keyof CandidatesFilter, value?: string) => void;
  onResetAll: () => void;
  onSuggestFilter?: () => void;
  className?: string;
}

interface ActiveFilter {
  key: keyof CandidatesFilter;
  label: string;
  value?: string;
  color?: string;
}

const ActiveFilters: React.FC<ActiveFiltersProps> = ({
  filters,
  onRemoveFilter,
  onResetAll,
  onSuggestFilter,
  className,
}) => {
  const getActiveFilters = (): ActiveFilter[] => {
    const activeFilters: ActiveFilter[] = [];

    // חיפוש כללי (מופיע רק אם אין סינון נפרד)
    if (!filters.separateFiltering && filters.searchQuery) {
      activeFilters.push({
        key: "searchQuery",
        label: `חיפוש: ${filters.searchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לגברים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.maleSearchQuery) {
      activeFilters.push({
        key: "maleSearchQuery",
        label: `חיפוש מועמדים: ${filters.maleSearchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לנשים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.femaleSearchQuery) {
      activeFilters.push({
        key: "femaleSearchQuery",
        label: `חיפוש מועמדות: ${filters.femaleSearchQuery}`,
        color: "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // מצב סינון נפרד
    if (filters.separateFiltering) {
      activeFilters.push({
        key: "separateFiltering",
        label: `סינון וחיפוש נפרד`,
        color: "bg-indigo-100 text-indigo-800 border-indigo-200",
      });
    }

    // Gender
    if (filters.gender) {
      activeFilters.push({
        key: "gender",
        label: `מגדר: ${filters.gender === "MALE" ? "גברים" : "נשים"}`,
        color:
          filters.gender === "MALE"
            ? "bg-blue-100 text-blue-800 border-blue-200"
            : "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // Age Range
    if (filters.ageRange) {
      const isDefaultMin = filters.ageRange.min === 18;
      const isDefaultMax = filters.ageRange.max === 99;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גיל: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.ageRange.min}-${filters.ageRange.max}`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.ageRange.min}`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.ageRange.max}`;
        }

        activeFilters.push({
          key: "ageRange",
          label,
        });
      }
    }

    // Height Range
    if (filters.heightRange) {
      const isDefaultMin = filters.heightRange.min === 140;
      const isDefaultMax = filters.heightRange.max === 210;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גובה: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.heightRange.min}-${filters.heightRange.max} ס"מ`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.heightRange.min} ס"מ`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.heightRange.max} ס"מ`;
        }

        activeFilters.push({
          key: "heightRange",
          label,
        });
      }
    }

    // Religious Level
    if (filters.religiousLevel) {
      activeFilters.push({
        key: "religiousLevel",
        label: `רמת דתיות: ${filters.religiousLevel}`,
        color: "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Education Level
    if (filters.educationLevel) {
      activeFilters.push({
        key: "educationLevel",
        label: `השכלה: ${filters.educationLevel}`,
      });
    }

    // Cities
    filters.cities?.forEach((city) => {
      activeFilters.push({
        key: "cities",
        value: city,
        label: `עיר: ${city}`,
        color: "bg-green-100 text-green-800 border-green-200",
      });
    });

    // Occupations
    filters.occupations?.forEach((occupation) => {
      activeFilters.push({
        key: "occupations",
        value: occupation,
        label: `תחום עיסוק: ${occupation}`,
      });
    });

    // Availability Status
    if (filters.availabilityStatus) {
      const statusLabel =
        filters.availabilityStatus === "AVAILABLE"
          ? "פנוי/ה"
          : filters.availabilityStatus === "DATING"
          ? "בתהליך הכרות"
          : filters.availabilityStatus === "UNAVAILABLE"
          ? "לא פנוי/ה"
          : filters.availabilityStatus;

      activeFilters.push({
        key: "availabilityStatus",
        label: `סטטוס: ${statusLabel}`,
        color:
          filters.availabilityStatus === "AVAILABLE"
            ? "bg-emerald-100 text-emerald-800 border-emerald-200"
            : "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Marital Status
    if (filters.maritalStatus) {
      activeFilters.push({
        key: "maritalStatus",
        label: `מצב משפחתי: ${filters.maritalStatus}`,
      });
    }

    // Verified Filter
    if (filters.isVerified !== undefined) {
      activeFilters.push({
        key: "isVerified",
        label: `מאומתים בלבד`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // References Filter
    if (filters.hasReferences !== undefined) {
      activeFilters.push({
        key: "hasReferences",
        label: `עם המלצות`,
      });
    }

    // Profile Completeness
    if (filters.isProfileComplete !== undefined) {
      activeFilters.push({
        key: "isProfileComplete",
        label: `פרופיל מלא`,
      });
    }

    // Last Activity
    if (filters.lastActiveDays !== undefined) {
      let label: string;

      switch (filters.lastActiveDays) {
        case 1:
          label = "פעילים היום";
          break;
        case 3:
          label = "פעילים ב-3 ימים אחרונים";
          break;
        case 7:
          label = "פעילים בשבוע האחרון";
          break;
        case 30:
          label = "פעילים בחודש האחרון";
          break;
        default:
          label = `פעילים ב-${filters.lastActiveDays} ימים אחרונים`;
      }

      activeFilters.push({
        key: "lastActiveDays",
        label,
        color: "bg-cyan-100 text-cyan-800 border-cyan-200",
      });
    }

    return activeFilters;
  };

  const activeFilters = getActiveFilters();

  if (activeFilters.length === 0) {
    return null;
  }

  return (
    <div className={`${className || ""}`}>
      <div className="bg-white border rounded-lg p-3">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-sm font-medium text-gray-700 flex items-center gap-1.5">
            <span>סינון פעיל</span>
            <Badge variant="outline" className="bg-blue-50 text-xs">
              {activeFilters.length}
            </Badge>
          </h3>

          <div className="flex items-center gap-2">
            {onSuggestFilter && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={onSuggestFilter}
                      className="h-7 text-xs text-blue-600 hover:text-blue-700 hover:bg-blue-50"
                    >
                      <Sparkles className="w-3 h-3 mr-1" />
                      הצע פילטרים נוספים
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>הצעת פילטרים נוספים המתאימים לתוצאות הנוכחיות</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}

            <Button
              variant="ghost"
              size="sm"
              onClick={onResetAll}
              className="h-7 text-xs text-gray-600 hover:text-gray-700"
            >
              <RefreshCw className="w-3 h-3 mr-1" />
              נקה הכל
            </Button>
          </div>
        </div>

        <div className="flex flex-wrap gap-2">
          <AnimatePresence>
            {activeFilters.map((filter, index) => (
              <motion.div
                key={`${filter.key}-${filter.value || index}`}
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                transition={{ duration: 0.15 }}
              >
                <Badge
                  variant="secondary"
                  className={`px-2 py-0.5 whitespace-nowrap border ${
                    filter.color || "bg-gray-100 text-gray-800 border-gray-200"
                  }`}
                >
                  <span className="max-w-[200px] truncate">{filter.label}</span>
                  <button
                    className="ml-1.5 hover:bg-gray-200/40 rounded-full p-0.5 transition-colors"
                    onClick={() => onRemoveFilter(filter.key, filter.value)}
                    aria-label={`הסר פילטר ${filter.label}`}
                  >
                    <X className="w-3 h-3" />
                  </button>
                </Badge>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
};

export default ActiveFilters;
--- End of Content for ActiveFilters.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\FilterPanel.tsx
--------------------------------------------------------------------------------
Content:
// /Filters/FilterPanel.tsx - גרסה משופרת
import React, { useState } from "react";
import { Card } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { UserSource } from "@prisma/client"; // At the top
import { UserStatus } from "@prisma/client";

import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { UserPlus } from "lucide-react"; // Add UserPlus for the button

import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Save,
  User,
  GraduationCap,
  MapPin,
  Scroll,
  Calendar,
  ChevronDown,
  ChevronUp,
  Clock,
  Ruler,
  Heart,
  Briefcase,
  Star,
  RefreshCw,
  Bookmark,
  Check,
  Filter as FilterIcon,
  Copy,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type { FilterState } from "../types/filters";
import type { CandidatesFilter } from "../types/candidates";
import SavedFilters from "./SavedFilters";
import {
  AGE_RANGE,
  HEIGHT_RANGE,
  RELIGIOUS_LEVELS,
  EDUCATION_LEVELS,
  OCCUPATION_CATEGORIES,
  POPULAR_CITIES,
  AVAILABILITY_STATUS_OPTIONS,
  MARITAL_STATUS,
} from "../constants/filterOptions";

interface PopularFilterOption {
  id: string;
  label: string;
  icon: React.ReactNode;
  filter: Partial<CandidatesFilter>;
}

interface FilterPanelProps {
  filters: CandidatesFilter;
  onFiltersChange: (filters: CandidatesFilter) => void;
  onSavePreset?: (name: string) => void;
  onReset: () => void;
  onApplySavedFilter?: (id: string) => void;
  savedFilters?: Array<{
    id: string;
    name: string;
    isDefault?: boolean;
  }>;
  popularFilters?: string[];
  className?: string;
  compactMode?: boolean;

  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering?: boolean;
  onToggleSeparateFiltering?: () => void;
  onMaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}

interface FilterSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
  defaultOpen?: boolean;
  badge?: number;
}

const POPULAR_FILTERS: PopularFilterOption[] = [
  {
    id: "active-recently",
    label: "פעילים לאחרונה",
    icon: <Clock className="w-4 h-4 text-blue-600" />,
    filter: {
      lastActiveDays: 7,
    },
  },
  {
    id: "verified-only",
    label: "מאומתים בלבד",
    icon: <Check className="w-4 h-4 text-blue-600" />,
    filter: {
      isVerified: true,
    },
  },
  {
    id: "has-recommendations",
    label: "עם המלצות",
    icon: <Star className="w-4 h-4 text-blue-600" />,
    filter: {
      hasReferences: true,
    },
  },
  {
    id: "available-only",
    label: "פנויים בלבד",
    icon: <Heart className="w-4 h-4 text-blue-600" />,
    filter: {
      availabilityStatus: "AVAILABLE",
    },
  },
  {
    id: "complete-profiles",
    label: "פרופילים מלאים",
    icon: <User className="w-4 h-4 text-blue-600" />,
    filter: {
      isProfileComplete: true,
    },
  },
];

const FilterSection: React.FC<FilterSectionProps> = ({
  title,
  icon,
  children,
  defaultOpen = false,
  badge,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <Collapsible
      open={isOpen}
      onOpenChange={setIsOpen}
      className="border rounded-lg mb-3 overflow-hidden bg-white"
    >
      <CollapsibleTrigger asChild>
        <div className="flex items-center justify-between p-4 cursor-pointer hover:bg-blue-50/30 transition-colors">
          <div className="flex items-center gap-2">
            <div className="bg-blue-50 p-2 rounded-md text-blue-600">
              {icon}
            </div>
            <span className="font-medium">{title}</span>
            {badge !== undefined && (
              <Badge
                variant="secondary"
                className="bg-blue-100 text-blue-800 text-xs mr-2"
              >
                {badge}
              </Badge>
            )}
          </div>
          {isOpen ? (
            <ChevronUp size={16} className="text-gray-500" />
          ) : (
            <ChevronDown size={16} className="text-gray-500" />
          )}
        </div>
      </CollapsibleTrigger>
      <CollapsibleContent className="px-4 pb-4 pt-1 border-t">
        {children}
      </CollapsibleContent>
    </Collapsible>
  );
};

// קומפוננט חדש לסינון מגדרי
const GenderFilterPanel = ({
  gender,
  filters,
  onFiltersChange,
  className,
  copyTarget,
  onCopyFilters,
}: {
  gender: "male" | "female";
  filters: Partial<FilterState>;
  onFiltersChange: (filters: Partial<FilterState>) => void;
  className?: string;
  copyTarget: "male" | "female";
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}) => {
  const genderColors = {
    male: {
      bg: "bg-blue-50/50",
      border: "border-blue-200",
      text: "text-blue-800",
      icon: <User className="w-4 h-4 text-blue-600" />,
      title: "סינון מועמדים",
    },
    female: {
      bg: "bg-purple-50/50",
      border: "border-purple-200",
      text: "text-purple-800",
      icon: <User className="w-4 h-4 text-purple-600" />,
      title: "סינון מועמדות",
    },
  };

  const colorConfig = genderColors[gender];

  return (
    <div className={`${className} mb-4 border rounded-lg overflow-hidden`}>
      {/* כותרת עם צבע תואם מגדר */}
      <div
        className={`flex justify-between items-center px-4 py-2 ${colorConfig.bg} ${colorConfig.border} border-b`}
      >
        <div className="flex items-center gap-2">
          {colorConfig.icon}
          <h3 className={`text-sm font-medium ${colorConfig.text}`}>
            {colorConfig.title}
          </h3>
        </div>
        {onCopyFilters && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onCopyFilters(gender, copyTarget)}
            className="text-xs h-7 py-0 px-2 flex items-center gap-1"
            title={`העתק הגדרות ל${
              copyTarget === "male" ? "מועמדים" : "מועמדות"
            }`}
          >
            <Copy className="w-3 h-3" />
            <span>העתק ל{copyTarget === "male" ? "מועמדים" : "מועמדות"}</span>
          </Button>
        )}
      </div>

      {/* תוכן הפאנל */}
      <div className="p-3 space-y-4">
        {/* סינון גיל - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">גיל</Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.min || AGE_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= AGE_RANGE.min &&
                      newMin <= AGE_RANGE.max
                    ) {
                      const currentMax =
                        filters?.ageRange?.max || AGE_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.max || AGE_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= AGE_RANGE.min &&
                      newMax <= AGE_RANGE.max
                    ) {
                      const currentMin =
                        filters?.ageRange?.min || AGE_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                value={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                min={AGE_RANGE.min}
                max={AGE_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    ageRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{AGE_RANGE.min}</span>
              <span className="text-xs text-gray-400">{AGE_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* סינון גובה - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">
            גובה (סמ)
          </Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.min || HEIGHT_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= HEIGHT_RANGE.min &&
                      newMin <= HEIGHT_RANGE.max
                    ) {
                      const currentMax =
                        filters?.heightRange?.max || HEIGHT_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.max || HEIGHT_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= HEIGHT_RANGE.min &&
                      newMax <= HEIGHT_RANGE.max
                    ) {
                      const currentMin =
                        filters?.heightRange?.min || HEIGHT_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                value={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                min={HEIGHT_RANGE.min}
                max={HEIGHT_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    heightRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.min}</span>
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* רמת דתיות */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">רמת דתיות</Label>
          <div className="px-2">
            <Select
              value={filters?.religiousLevel || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  religiousLevel: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר רמת דתיות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {RELIGIOUS_LEVELS.map((level) => (
                  <SelectItem key={level.value} value={level.value}>
                    {level.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* מצב משפחתי */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">מצב משפחתי</Label>
          <div className="px-2">
            <Select
              value={filters?.maritalStatus || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  maritalStatus: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר מצב משפחתי" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {MARITAL_STATUS.map((status) => (
                  <SelectItem key={status.value} value={status.value}>
                    {status.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* ערים */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">ערים מבוקשות</Label>
          <div className="px-2">
            <Select
              value={filters.cities?.[0] || ""}
              onValueChange={(value) => {
                if (value === "all") {
                  onFiltersChange({ cities: [] });
                } else {
                  onFiltersChange({ cities: [value] });
                }
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר עיר" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">כל הערים</SelectItem>
                {POPULAR_CITIES.map((city) => (
                  <SelectItem key={city} value={city}>
                    {city}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* סטטוס אימות ותוספות */}
        <div className="space-y-2 pt-2 border-t border-gray-100">
          <div className="flex items-center justify-between px-2">
            <span className="text-xs font-medium">מאומתים בלבד</span>
            <Switch
              checked={filters?.isVerified || false}
              onCheckedChange={(checked) => {
                onFiltersChange({
                  isVerified: checked || undefined,
                });
              }}
            />
          </div>
        </div>

        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">עם המלצות</span>
          <Switch
            checked={filters?.hasReferences || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                hasReferences: checked || undefined,
              });
            }}
          />
        </div>
        <FilterSection
          title="מקור המועמד"
          icon={<UserPlus className="w-4 h-4" />}
        >
          <div className="pt-2">
            <Select
              value={filters.source || ""}
              onValueChange={(value) =>
                onFiltersChange({
                  ...filters,
                  source: value ? (value as UserSource) : undefined,
                })
              }
            >
              <SelectTrigger className="w-full bg-white">
                <SelectValue placeholder="בחר מקור המועמד" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">הכל</SelectItem>
                <SelectItem value={UserSource.REGISTRATION}>
                  רישום עצמי
                </SelectItem>
                <SelectItem value={UserSource.MANUAL_ENTRY}>
                  הוספה ידנית
                </SelectItem>
              </SelectContent>
            </Select>
          </div>
        </FilterSection>
        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">פרופיל מלא</span>
          <Switch
            checked={filters?.isProfileComplete || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                isProfileComplete: checked || undefined,
              });
            }}
          />
        </div>
      </div>
    </div>
  );
};

const FilterPanel: React.FC<FilterPanelProps> = ({
  filters,
  onFiltersChange,
  onSavePreset,
  onReset,
  onApplySavedFilter,
  savedFilters = [],
  popularFilters = [],
  className,
  compactMode = false,
  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering = false,
  onToggleSeparateFiltering,
  onMaleFiltersChange,
  onFemaleFiltersChange,
  onCopyFilters,
}) => {
  const [showSavePreset, setShowSavePreset] = useState(false);
  const [presetName, setPresetName] = useState("");
  const [activeTab, setActiveTab] = useState<string>("basic");
  const [activeGenderFilter, setActiveGenderFilter] = useState<
    "male" | "female"
  >("male");

  const handleSavePreset = () => {
    if (presetName && onSavePreset) {
      onSavePreset(presetName);
      setPresetName("");
      setShowSavePreset(false);
    }
  };
  const layoutClasses = compactMode
    ? "p-1 space-y-1 text-xs" // הרבה יותר קומפקטי
    : "p-4 space-y-4"; // תצוגה רגילה

  const handleAgeRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      ageRange: { min: value[0], max: value[1] },
    });
  };

  const handleHeightRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      heightRange: { min: value[0], max: value[1] },
    });
  };
  const handleApplyPopularFilter = (filter: Partial<CandidatesFilter>) => {
    onFiltersChange({
      ...filters,
      ...filter,
    });
  };

  const countActiveFilters = (category: string): number => {
    let count = 0;

    switch (category) {
      case "basic":
        // Count basic filters
        if (filters.gender) count++;
        if (
          filters.ageRange &&
          (filters.ageRange.min !== AGE_RANGE.default.min ||
            filters.ageRange.max !== AGE_RANGE.default.max)
        )
          count++;
        if (filters.cities?.length) count++;
        if (filters.religiousLevel) count++;
        break;
      case "advanced":
        // Count advanced filters
        if (
          filters.heightRange &&
          (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
            filters.heightRange.max !== HEIGHT_RANGE.default.max)
        )
          count++;
        if (filters.occupations?.length) count++;
        if (filters.educationLevel) count++;
        if (filters.maritalStatus) count++;
        break;
      case "status":
        // Count status filters
        if (filters.availabilityStatus) count++;
        if (filters.isVerified !== undefined) count++;
        if (filters.hasReferences !== undefined) count++;
        if (filters.lastActiveDays !== undefined) count++;
        if (filters.isProfileComplete !== undefined) count++;
        break;
      case "saved":
        // Count of saved filters is just the length
        return savedFilters.length;
    }

    return count;
  };

  return (
    <Card
      className={`${layoutClasses} border border-slate-200 bg-white/90 shadow-sm ${className}`}
    >
      {/* Header */}
      {!compactMode && (
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <FilterIcon className="w-5 h-5 text-blue-600" />
            <h3 className="font-semibold text-lg">סינון מועמדים</h3>
          </div>
          <div className="flex gap-2">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={onReset}
                    className="h-8 w-8 p-0"
                  >
                    <RefreshCw className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>איפוס כל הפילטרים</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>

            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowSavePreset(!showSavePreset)}
                    className="h-8 w-8 p-0"
                  >
                    <Bookmark className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>שמירת הפילטר הנוכחי</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </div>
      )}

      {/* Popular Filters */}
      {!compactMode && (
        <div className="mb-4">
          <div className="flex flex-wrap gap-2">
            {POPULAR_FILTERS.map((option) => (
              <Button
                key={option.id}
                variant="outline"
                size="sm"
                onClick={() => handleApplyPopularFilter(option.filter)}
                className="bg-white flex items-center gap-1.5 transition-all hover:bg-blue-50 hover:text-blue-700 hover:border-blue-200"
              >
                {option.icon}
                <span>{option.label}</span>
              </Button>
            ))}
          </div>
        </div>
      )}

      {/* Save Preset Form */}
      {showSavePreset && !compactMode && (
        <div className="p-4 border rounded-lg bg-blue-50/50 mb-4">
          <Label>שם לשמירת הפילטר</Label>
          <div className="flex gap-2 mt-2">
            <Input
              value={presetName}
              onChange={(e) => setPresetName(e.target.value)}
              placeholder="פילטר מותאם אישית"
              className="h-9"
            />
            <Button size="sm" onClick={handleSavePreset}>
              <Save className="w-4 h-4 ml-1.5" />
              שמור
            </Button>
          </div>
        </div>
      )}

      {/* Separate Filtering Toggle */}
      <div className="mb-4 border rounded-lg p-4 bg-blue-50/10">
        <div className="flex items-center justify-between">
          <div className="space-y-1">
            <div className="font-medium">סינון וחיפוש נפרד לפי מגדר</div>
            <p className="text-sm text-gray-500">
              סנן מועמדים ומועמדות עם קריטריונים שונים
            </p>
          </div>
          <div className="flex items-center gap-2">
            <Switch
              checked={separateFiltering}
              onCheckedChange={onToggleSeparateFiltering}
            />
            {separateFiltering && (
              <Button
                variant="outline"
                size="sm"
                onClick={onToggleSeparateFiltering}
                className="text-sm"
              >
                <RefreshCw className="w-3.5 h-3.5 mr-1.5" />
                בטל סינון נפרד
              </Button>
            )}
          </div>
        </div>
      </div>

      {/* Separate Filtering UI */}
      {separateFiltering ? (
        <div className="space-y-4">
          {/* Gender Filter Switcher */}
          <div className="flex border rounded-lg overflow-hidden mb-2">
            <Button
              type="button"
              variant={activeGenderFilter === "male" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("male")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "male" ? "bg-blue-600" : ""
              }`}
            >
              סינון מועמדים
              <User className="w-4 h-4 mr-2" />
            </Button>
            <Button
              type="button"
              variant={activeGenderFilter === "female" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("female")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "female" ? "bg-purple-600" : ""
              }`}
            >
              סינון מועמדות
              <User className="w-4 h-4 mr-2" />
            </Button>
          </div>

          {/* Conditionally render based on active gender filter */}
          {activeGenderFilter === "male" ? (
            <GenderFilterPanel
              gender="male"
              filters={filters.maleFilters || {}}
              onFiltersChange={onMaleFiltersChange || (() => {})}
              copyTarget="female"
              onCopyFilters={onCopyFilters}
            />
          ) : (
            <GenderFilterPanel
              gender="female"
              filters={filters.femaleFilters || {}}
              onFiltersChange={onFemaleFiltersChange || (() => {})}
              copyTarget="male"
              onCopyFilters={onCopyFilters}
            />
          )}
        </div>
      ) : (
        // Standard Filtering Tabs
        <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
          <TabsList
            className={`grid grid-cols-4 w-full bg-muted/30 p-1 rounded-xl shadow-sm ${
              compactMode ? "text-xs" : ""
            }`}
          >
            <TabsTrigger
              value="basic"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                בסיסי
                {countActiveFilters("basic") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("basic")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="advanced"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                מתקדם
                {countActiveFilters("advanced") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("advanced")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="status"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                סטטוס
                {countActiveFilters("status") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("status")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="saved"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                שמורים
                {countActiveFilters("saved") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("saved")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
          </TabsList>

          <div className={compactMode ? "mt-2" : "mt-4"}>
            {/* Basic Filters Tab */}
            <TabsContent value="basic" className="space-y-4">
              {/* Gender Filter */}
              <FilterSection
                title="מגדר"
                icon={<User className="w-4 h-4" />}
                defaultOpen={true}
              >
                <div className="grid grid-cols-2 gap-2 pt-2">
                  <Button
                    type="button"
                    variant={filters.gender === "MALE" ? "default" : "outline"}
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "MALE" })
                    }
                    className={
                      filters.gender === "MALE" ? "bg-blue-600" : "bg-white"
                    }
                  >
                    גברים
                  </Button>
                  <Button
                    type="button"
                    variant={
                      filters.gender === "FEMALE" ? "default" : "outline"
                    }
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "FEMALE" })
                    }
                    className={
                      filters.gender === "FEMALE" ? "bg-purple-600" : "bg-white"
                    }
                  >
                    נשים
                  </Button>
                </div>
                {filters.gender && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: undefined })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                )}
              </FilterSection>
                           <FilterSection
                title="סטטוס משתמש"
                icon={<User className="w-4 h-4" />}
                defaultOpen={true}
                badge={filters.userStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  {/* --- START OF FIX --- */}
                  <Select
                    // 1. אם הסטטוס לא מוגדר, הערך של ה-Select יהיה "all"
                    value={filters.userStatus || "all"}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        // 2. אם המשתמש בחר "all", ננקה את הפילטר (undefined). אחרת, נגדיר את הערך שנבחר.
                        userStatus: value === "all" ? undefined : (value as UserStatus),
                      })
                    }
                  >
                  {/* --- END OF FIX --- */}
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="בחר סטטוס משתמש" />
                    </SelectTrigger>
                    <SelectContent>
                      {/* --- START OF FIX --- */}
                      {/* 3. שינוי הערך של "הכל" למחרוזת שאינה ריקה */}
                      <SelectItem value="all">הכל</SelectItem>
                      {/* --- END OF FIX --- */}
                      <SelectItem value={UserStatus.ACTIVE}>פעילים</SelectItem>
                      <SelectItem value={UserStatus.PENDING_PHONE_VERIFICATION}>ממתינים לאימות טלפון</SelectItem>
                      <SelectItem value={UserStatus.PENDING_EMAIL_VERIFICATION}>ממתינים לאימות מייל</SelectItem>
                    </SelectContent>
                  </Select>
                  {filters.userStatus && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          userStatus: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>
              {/* Age Range - משופר ומתוקן */}
              <FilterSection
                title="גיל"
                icon={<Calendar className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  filters.ageRange &&
                  (filters.ageRange.min !== AGE_RANGE.default.min ||
                    filters.ageRange.max !== AGE_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.max || AGE_RANGE.default.max}
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= AGE_RANGE.min &&
                            newMax <= AGE_RANGE.max
                          ) {
                            const currentMin =
                              filters.ageRange?.min || AGE_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.min || AGE_RANGE.default.min}
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= AGE_RANGE.min &&
                            newMin <= AGE_RANGE.max
                          ) {
                            const currentMax =
                              filters.ageRange?.max || AGE_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          AGE_RANGE.default.min,
                          AGE_RANGE.default.max,
                        ]}
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        step={1}
                        value={[
                          filters.ageRange?.min || AGE_RANGE.default.min,
                          filters.ageRange?.max || AGE_RANGE.default.max,
                        ]}
                        onValueChange={handleAgeRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.max}
                      </span>
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.min}
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Cities Filter */}
              <FilterSection
                title="ערים"
                icon={<MapPin className="w-4 h-4" />}
                badge={filters.cities?.length}
              >
                <ScrollArea className="h-48 mt-2 rounded-md border overflow-hidden bg-white pr-4">
                  <div className="p-2">
                    {POPULAR_CITIES.map((city) => (
                      <div
                        key={city}
                        className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                      >
                        <span className="text-sm">{city}</span>
                        <Switch
                          checked={filters.cities?.includes(city) || false}
                          onCheckedChange={(checked) => {
                            const newCities = checked
                              ? [...(filters.cities || []), city]
                              : filters.cities?.filter((c) => c !== city);
                            onFiltersChange({ ...filters, cities: newCities });
                          }}
                        />
                      </div>
                    ))}
                  </div>
                </ScrollArea>
                {filters.cities?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => onFiltersChange({ ...filters, cities: [] })}
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Religious Level */}
              <FilterSection
                title="רמת דתיות"
                icon={<Scroll className="w-4 h-4" />}
                badge={filters.religiousLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.religiousLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        religiousLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="בחר רמת דתיות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {RELIGIOUS_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Advanced Filters Tab */}
            <TabsContent value="advanced" className="space-y-4">
              {/* Height Range - משופר ומתוקן */}
              <FilterSection
                title="גובה (ס״מ)"
                icon={<Ruler className="w-4 h-4" />}
                badge={
                  filters.heightRange &&
                  (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
                    filters.heightRange.max !== HEIGHT_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.max || HEIGHT_RANGE.default.max
                        }
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= HEIGHT_RANGE.min &&
                            newMax <= HEIGHT_RANGE.max
                          ) {
                            const currentMin =
                              filters.heightRange?.min ||
                              HEIGHT_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.min || HEIGHT_RANGE.default.min
                        }
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= HEIGHT_RANGE.min &&
                            newMin <= HEIGHT_RANGE.max
                          ) {
                            const currentMax =
                              filters.heightRange?.max ||
                              HEIGHT_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          HEIGHT_RANGE.default.min,
                          HEIGHT_RANGE.default.max,
                        ]}
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        step={1}
                        value={[
                          filters.heightRange?.min || HEIGHT_RANGE.default.min,
                          filters.heightRange?.max || HEIGHT_RANGE.default.max,
                        ]}
                        onValueChange={handleHeightRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.min} ס״מ
                      </span>
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.max} ס״מ
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Occupation */}
              <FilterSection
                title="תחום עיסוק"
                icon={<Briefcase className="w-4 h-4" />}
                badge={filters.occupations?.length}
              >
                <ScrollArea className="h-48 rounded-md mt-2 border p-2 bg-white pr-4">
                  {OCCUPATION_CATEGORIES.map((occupation) => (
                    <div
                      key={occupation.value}
                      className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                    >
                      <span className="text-sm">{occupation.label}</span>
                      <Switch
                        checked={
                          filters.occupations?.includes(occupation.value) ||
                          false
                        }
                        onCheckedChange={(checked) => {
                          const newOccupations = checked
                            ? [...(filters.occupations || []), occupation.value]
                            : filters.occupations?.filter(
                                (o) => o !== occupation.value
                              );
                          onFiltersChange({
                            ...filters,
                            occupations: newOccupations,
                          });
                        }}
                      />
                    </div>
                  ))}
                </ScrollArea>
                {filters.occupations?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, occupations: [] })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Education Level */}
              <FilterSection
                title="השכלה"
                icon={<GraduationCap className="w-4 h-4" />}
                badge={filters.educationLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.educationLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        educationLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="רמת השכלה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {EDUCATION_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>

              {/* Marital Status */}
              <FilterSection
                title="מצב משפחתי"
                icon={<Heart className="w-4 h-4" />}
                badge={filters.maritalStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.maritalStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        maritalStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="מצב משפחתי" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {MARITAL_STATUS.map((status) => (
                        <SelectItem key={status.value} value={status.value}>
                          {status.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Status & Availability Filters Tab */}
            <TabsContent value="status" className="space-y-4">
              {/* Availability Status */}
              <FilterSection
                title="סטטוס זמינות"
                icon={<Clock className="w-4 h-4" />}
                defaultOpen={true}
                badge={filters.availabilityStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.availabilityStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        availabilityStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="סטטוס זמינות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {AVAILABILITY_STATUS_OPTIONS.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          <div className="flex items-center gap-2">
                            <div
                              className={`w-2 h-2 rounded-full ${
                                option.value === "AVAILABLE"
                                  ? "bg-emerald-500"
                                  : option.value === "DATING"
                                  ? "bg-amber-500"
                                  : "bg-red-500"
                              }`}
                            />
                            {option.label}
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {filters.availabilityStatus && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          availabilityStatus: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>

              {/* Verification Switches */}
              <FilterSection
                title="אימות ואיכות פרופיל"
                icon={<Check className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  (filters.isVerified !== undefined ? 1 : 0) +
                  (filters.hasReferences !== undefined ? 1 : 0) +
                  (filters.isProfileComplete !== undefined ? 1 : 0)
                }
              >
                <div className="space-y-3 pt-2">
                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">מועמדים מאומתים בלבד</span>
                    <Switch
                      checked={filters.isVerified || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isVerified: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">עם המלצות בלבד</span>
                    <Switch
                      checked={filters.hasReferences || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          hasReferences: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">פרופילים מלאים בלבד</span>
                    <Switch
                      checked={filters.isProfileComplete || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isProfileComplete: checked || undefined,
                        })
                      }
                    />
                  </div>
                </div>
              </FilterSection>

              {/* Activity Filter */}
              <FilterSection
                title="פעילות אחרונה"
                icon={<Clock className="w-4 h-4" />}
                badge={filters.lastActiveDays ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.lastActiveDays?.toString() || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        lastActiveDays: value ? parseInt(value) : undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="פעילות אחרונה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="1">היום</SelectItem>
                      <SelectItem value="3">3 ימים אחרונים</SelectItem>
                      <SelectItem value="7">שבוע אחרון</SelectItem>
                      <SelectItem value="30">חודש אחרון</SelectItem>
                    </SelectContent>
                  </Select>
                  {filters.lastActiveDays && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          lastActiveDays: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>
            </TabsContent>

            {/* Saved Filters Tab */}
            <TabsContent value="saved" className="space-y-4">
              {savedFilters.length === 0 ? (
                <div className="text-center py-8 text-gray-500 bg-white rounded-lg border p-4">
                  <Bookmark className="w-8 h-8 mx-auto mb-2 text-gray-400" />
                  <h3 className="mb-1 font-medium">אין פילטרים שמורים</h3>
                  <p className="text-sm">
                    שמור את הפילטר הנוכחי ע״י לחיצה על כפתור השמירה
                  </p>
                </div>
              ) : (
                <SavedFilters
                  filters={savedFilters.map((filter) => ({
                    id: filter.id,
                    name: filter.name,
                    filter: {},
                    isDefault: filter.isDefault,
                    createdAt: new Date(),
                  }))}
                  activeFilterId={filters.savedFilterId}
                  onSelect={(filter) => onApplySavedFilter?.(filter.id)}
                  onDelete={() => {}}
                  onEdit={() => {}}
                  onSetDefault={() => {}}
                />
              )}

              {popularFilters.length > 0 && (
                <div className="mt-4">
                  <h4 className="font-medium text-sm mb-2">
                    חיפושים פופולריים
                  </h4>
                  <div className="flex flex-wrap gap-2">
                    {popularFilters.map((term, index) => (
                      <Badge
                        key={index}
                        variant="outline"
                        className="cursor-pointer bg-blue-50 border-blue-200 hover:bg-blue-100 transition-colors"
                        onClick={() =>
                          onFiltersChange({
                            ...filters,
                            searchQuery: term,
                          })
                        }
                      >
                        {term}
                      </Badge>
                    ))}
                  </div>
                </div>
              )}
            </TabsContent>
          </div>
        </Tabs>
      )}

      {/* Action buttons */}
      <div
        className={`${
          compactMode ? "pt-2 mt-2" : "pt-4 mt-4"
        } border-t flex justify-end gap-2`}
      >
        <Button
          variant="outline"
          size={compactMode ? "sm" : "default"}
          onClick={onReset}
          className="bg-white"
        >
          איפוס
        </Button>
        {!compactMode && (
          <Button onClick={() => setShowSavePreset(true)} size="sm">
            <Save className="w-4 h-4 ml-1.5" />
            שמירת פילטר
          </Button>
        )}
      </div>
    </Card>
  );
};

export default FilterPanel;
--- End of Content for FilterPanel.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\SavedFilters.tsx
--------------------------------------------------------------------------------
Content:
// /components/matchmaker/Filters/SavedFilters.tsx
"use client";
import React from "react";
import { Star, MoreVertical, Edit, Trash } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import type { CandidatesFilter } from "../types/candidates";

interface SavedFilter {
  id: string;
  name: string;
  filter: CandidatesFilter;
  isDefault?: boolean;
  createdAt: Date;
}

interface SavedFiltersProps {
  filters: SavedFilter[];
  activeFilterId?: string;
  onSelect: (filter: SavedFilter) => void;
  onDelete: (filterId: string) => void;
  onEdit: (filter: SavedFilter) => void;
  onSetDefault: (filterId: string) => void;
  className?: string;
}

const SavedFilters: React.FC<SavedFiltersProps> = ({
  filters,
  activeFilterId,
  onSelect,
  onDelete,
  onEdit,
  onSetDefault,
  className,
}) => {
  return (
    <div className={`space-y-2 ${className}`}>
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-gray-700">פילטרים שמורים</h3>
        <Badge variant="secondary" className="text-xs">
          {filters.length}
        </Badge>
      </div>

      <ScrollArea className="h-[300px]">
        <div className="space-y-2">
          {filters.map((filter) => (
            <div
              key={filter.id}
              className={`
                flex items-center justify-between p-2 rounded-lg
                ${
                  activeFilterId === filter.id
                    ? "bg-blue-50 border border-blue-200"
                    : "bg-white hover:bg-gray-50"
                }
                transition-colors cursor-pointer
              `}
              onClick={() => onSelect(filter)}
            >
              <div className="flex items-center gap-2">
                {filter.isDefault && (
                  <Star className="w-4 h-4 text-yellow-400" />
                )}
                <div>
                  <p className="font-medium text-sm">{filter.name}</p>
                  <p className="text-xs text-gray-500">
                    {formatFilterSummary(filter.filter)}
                  </p>
                </div>
              </div>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8 w-8 p-0"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <MoreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onEdit(filter)}>
                    <Edit className="ml-2 h-4 w-4" />
                    עריכה
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => onSetDefault(filter.id)}
                    disabled={filter.isDefault}
                  >
                    <Star className="ml-2 h-4 w-4" />
                    הגדר כברירת מחדל
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onDelete(filter.id)}>
                    <Trash className="ml-2 h-4 w-4" />
                    מחיקה
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
};

// פונקציית עזר להצגת סיכום הפילטר
const formatFilterSummary = (filter: CandidatesFilter): string => {
  const parts: string[] = [];

  if (filter.ageRange) {
    parts.push(`גיל: ${filter.ageRange.min}-${filter.ageRange.max}`);
  }

  if (filter.cities?.length) {
    parts.push(`ערים: ${filter.cities.length}`);
  }

  if (filter.religiousLevel) {
    parts.push(`רמה דתית: ${filter.religiousLevel}`);
  }

  if (filter.occupations?.length) {
    parts.push(`תחומי עיסוק: ${filter.occupations.length}`);
  }

  return parts.join(" | ") || "פילטר ריק";
};

export default SavedFilters;
--- End of Content for SavedFilters.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\SearchBar.tsx
--------------------------------------------------------------------------------
Content:
// /Filters/SearchBar.tsx - גרסה עם לוגים לדיבאג
"use client";

import React, { useState, useEffect, useRef } from "react";
import { Search, X, History } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSelect?: (candidate: Candidate) => void;
  recentSearches?: string[];
  onSaveSearch?: (value: string) => void;
  onClearRecentSearches?: () => void;
  suggestions?: Candidate[];
  loading?: boolean;
  className?: string;
  placeholder?: string;
  autoFocus?: boolean;
  // הוספת שדה לציון לאיזה מגדר החיפוש מכוון
  genderTarget?: "male" | "female" | "all";
  // הוספת שדה לציון האם החיפוש מופעל במצב נפרד
  separateMode?: boolean;
}

const SEARCH_CATEGORIES = [
  { id: "name", label: "שם", placeholder: "חיפוש לפי שם..." },
  { id: "city", label: "עיר", placeholder: "חיפוש לפי עיר..." },
  {
    id: "occupation",
    label: "תחום עיסוק",
    placeholder: "חיפוש לפי תחום עיסוק...",
  },
  { id: "all", label: "הכל", placeholder: "חיפוש בכל השדות..." },
];

const SearchBar: React.FC<SearchBarProps> = ({
  value,
  onChange,
  onSelect,
  recentSearches = [],
  onSaveSearch,
  onClearRecentSearches,
  suggestions = [],
  loading = false,
  className = "",
  placeholder = "חיפוש מועמדים...",
  autoFocus = false,
  genderTarget = "all",
  separateMode = false,
}) => {
  const [open, setOpen] = useState(false);
  const [searchCategory, setSearchCategory] = useState<string>("all");
  const [inputValue, setInputValue] = useState(value);
  const [showClearButton, setShowClearButton] = useState(Boolean(value));
  const inputRef = useRef<HTMLInputElement>(null);
  const searchContainerRef = useRef<HTMLDivElement>(null);

  // לוג מצב התחלתי
  console.log("SearchBar mounted/updated. Props:", {
    initialValue: value,
    suggestionsCount: suggestions.length,
    recentSearchesCount: recentSearches.length,
  });

  // Sync input value with prop value
  useEffect(() => {
    console.log("Value prop changed:", value);
    setInputValue(value);
    setShowClearButton(Boolean(value));
  }, [value]);

  // Handle search when user presses Enter or selects a suggestion
  const handleSearch = (searchValue: string) => {
    console.log(
      `handleSearch called with: ${searchValue}, gender: ${genderTarget}, separate: ${separateMode}`
    );

    if (searchValue.trim()) {
      onChange(searchValue.trim());

      if (onSaveSearch) {
        // שמירת החיפוש בהיסטוריה
        // אפשר גם לשמור את המגדר אם יש צורך
        onSaveSearch(searchValue.trim());
      }
    }
  };
  // כשמשתמשים בחיפוש נפרד, נעדכן את הפלייסהולדר בהתאם
  const getSearchPlaceholder = () => {
    if (separateMode) {
      // מצא את ה-placeholder של הקטגוריה "all" או השתמש בברירת מחדל
      const allCategoryPlaceholder =
        SEARCH_CATEGORIES.find((cat) => cat.id === "all")?.placeholder ||
        "חיפוש בכל השדות...";

      if (genderTarget === "male") {
        return `חיפוש מועמדים - ${allCategoryPlaceholder}`;
      }
      if (genderTarget === "female") {
        return `חיפוש מועמדות - ${allCategoryPlaceholder}`;
      }
    }

    // אם לא במצב סינון נפרד, השתמש בקטגוריה הנוכחית שנבחרה
    const category = SEARCH_CATEGORIES.find((cat) => cat.id === searchCategory);
    return category?.placeholder || placeholder;
  };
  // Handle input change
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    console.log("handleInputChange:", { oldValue: inputValue, newValue });

    setInputValue(newValue);
    setShowClearButton(Boolean(newValue));

    // CRITICAL: הפעלת onChange בכל הקלדה כדי שהחיפוש יקרה בזמן אמת
    console.log(
      "Calling onChange directly from handleInputChange with:",
      newValue
    );
    onChange(newValue);
  };

  // Handle keyboard events
  const handleKeyDown = (e: React.KeyboardEvent) => {
    console.log("handleKeyDown:", e.key);

    if (e.key === "Enter" && inputValue.trim()) {
      console.log("Enter pressed with value:", inputValue);
      handleSearch(inputValue);
      setOpen(false);
    } else if (e.key === "Escape") {
      console.log("Escape pressed, closing dropdown");
      setOpen(false);
    }
  };

  // Clear search input
  const handleClear = () => {
    console.log("handleClear called");
    setInputValue("");
    console.log("Calling onChange with empty string from handleClear");
    onChange("");
    setShowClearButton(false);
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        searchContainerRef.current &&
        !searchContainerRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  // Handle suggestion selection
  const handleSuggestionSelect = (candidate: Candidate) => {
    console.log(
      "handleSuggestionSelect called with candidate:",
      `${candidate.firstName} ${candidate.lastName}`
    );

    if (onSelect) {
      console.log("Calling onSelect for the candidate");
      onSelect(candidate);
    } else {
      // אם אין פונקציית בחירה, התייחס לכך כחיפוש טקסט
      const searchText = `${candidate.firstName} ${candidate.lastName}`;
      console.log("No onSelect provided, using as text search:", searchText);
      setInputValue(searchText);
      console.log("Calling onChange with:", searchText);
      onChange(searchText);
    }
    setOpen(false);
  };

   return (
    <div className={`relative ${className}`} ref={searchContainerRef}>
      {/* Search Input Field */}
      <div className="relative flex items-center rounded-lg border border-input bg-background shadow-sm transition-colors focus-within:ring-1 focus-within:ring-blue-200">
        <Search className="absolute right-3 h-4 w-4 text-muted-foreground" />

        {/* הכנסת שדה הקלט */}
        <Input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onClick={() => {
            console.log("Search input clicked, opening dropdown");
            setOpen(true);
          }}
          placeholder={getSearchPlaceholder()}
          className={`border-0 pr-10 focus-visible:ring-0 focus-visible:ring-offset-0 ${
            separateMode ? "pl-16" : ""
          }`}
          autoFocus={autoFocus}
        />

        {/* תווית המגדר כתווית קבועה שלא חופפת את יתר האלמנטים */}
        {separateMode && (
          <div className="absolute left-4 top-1/2 -translate-y-1/2 z-10">
            <Badge
              variant="outline"
              className={
                genderTarget === "male"
                  ? "bg-blue-100 text-blue-800 border-blue-200"
                  : genderTarget === "female"
                  ? "bg-purple-100 text-purple-800 border-purple-200"
                  : ""
              }
            >
              {genderTarget === "male"
                ? "מועמדים"
                : genderTarget === "female"
                ? "מועמדות"
                : "הכל"}
            </Badge>
          </div>
        )}

        {/* כפתור ניקוי עם מיקום משופר */}
        {showClearButton && (
          <Button
            type="button"
            variant="ghost"
            size="icon"
            onClick={handleClear}
            className={`absolute ${
              separateMode ? "left-16" : "left-3 md:left-40"
            } top-1/2 -translate-y-1/2 h-7 w-7 z-10`}
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>

      {/* Suggestions Dropdown - Custom Styled */}
      {open && (
        <div
          className="absolute z-50 mt-1 w-full rounded-md border bg-white shadow-lg"
          style={{ maxHeight: "400px", overflowY: "auto" }}
        >
          {/* Search Input for Filtering */}
          <div className="p-2 border-b">
            <div className="relative">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-muted-foreground opacity-70" />
              <input
                type="text"
                value={inputValue}
                onChange={(e) => {
                  const newValue = e.target.value;
                  console.log("Dropdown filter input changed:", {
                    oldValue: inputValue,
                    newValue,
                  });
                  setInputValue(newValue);

                  // CRITICAL: וודא שהערך מועבר להורה בזמן הקלדה
                  console.log(
                    "Calling onChange from dropdown filter with:",
                    newValue
                  );
                  onChange(newValue);
                }}
                className="w-full border rounded-md px-3 pr-9 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-blue-300"
                placeholder="סנן תוצאות..."
                autoFocus
              />
            </div>
          </div>

          {/* No Results */}
          {suggestions.length === 0 && recentSearches.length === 0 && (
            <div className="p-4 text-center text-sm text-gray-500">
              {loading ? "טוען..." : "לא נמצאו תוצאות"}
            </div>
          )}

          {/* Recent Searches Section */}
          {recentSearches.length > 0 && (
            <div className="border-b">
              <div className="px-2 py-1.5 text-xs text-gray-500 flex justify-between">
                <span className="font-medium">חיפושים אחרונים</span>
                {onClearRecentSearches && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-5 text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      console.log("Clear recent searches clicked");
                      onClearRecentSearches();
                    }}
                  >
                    נקה היסטוריה
                  </Button>
                )}
              </div>
              <div className="p-1">
                {recentSearches.slice(0, 5).map((search, index) => (
                  <div
                    key={`recent-${index}`}
                    className="flex items-center gap-2 text-right px-3 py-1.5 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log("Recent search clicked:", search);
                      handleSearch(search);
                      setOpen(false);
                    }}
                  >
                    <History className="h-4 w-4 text-blue-400" />
                    <span className="text-sm">{search}</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Suggestions Section */}
          {suggestions.length > 0 && (
            <div>
              <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
                תוצאות
              </div>
              <div className="p-1">
                {suggestions.map((candidate) => (
                  <div
                    key={candidate.id}
                    className="flex items-center gap-2 text-right px-3 py-2 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log(
                        "Suggestion clicked:",
                        `${candidate.firstName} ${candidate.lastName}`
                      );
                      handleSuggestionSelect(candidate);
                    }}
                  >
                    <div className="flex-1">
                      <div className="font-medium text-sm">
                        {`${candidate.firstName} ${candidate.lastName}`}
                      </div>
                      <div className="text-xs text-gray-500 truncate">
                        {[
                          candidate.profile.city,
                          candidate.profile.occupation,
                          candidate.profile.religiousLevel,
                        ]
                          .filter(Boolean)
                          .join(" | ")}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}



          {/* Search Categories on Mobile */}
          <div className="md:hidden border-t">
            <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
              חפש לפי
            </div>
            <div className="flex flex-wrap gap-1 p-2">
              {SEARCH_CATEGORIES.map((category) => (
                <Badge
                  key={category.id}
                  variant={
                    searchCategory === category.id ? "default" : "outline"
                  }
                  className={`cursor-pointer ${
                    searchCategory === category.id
                      ? "bg-blue-500 text-white"
                      : "bg-transparent hover:bg-blue-50"
                  }`}
                  onClick={() => {
                    console.log("Mobile category changed to:", category.id);
                    setSearchCategory(category.id);
                  }}
                >
                  {category.label}
                </Badge>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SearchBar;
--- End of Content for SearchBar.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants\filterOptions.ts
--------------------------------------------------------------------------------
Content:
// /constants/filterOptions.ts
import { AvailabilityStatus } from '@prisma/client';

export const AGE_RANGE = {
  min: 18,
  max: 99,
  default: {
    min: 20,
    max: 35
  }
};

export const HEIGHT_RANGE = {
  min: 140,
  max: 210,
  default: {
    min: 150,
    max: 190
  }
};

export const RELIGIOUS_LEVELS = [
  { value: 'חרדי', label: 'חרדי' },
  { value: 'דתי לאומי', label: 'דתי לאומי' },
  { value: 'דתי', label: 'דתי' },
  { value: 'מסורתי', label: 'מסורתי' }
];

export const EDUCATION_LEVELS = [
  { value: 'תיכונית', label: 'השכלה תיכונית' },
  { value: 'ישיבה', label: 'ישיבה' },
  { value: 'סמינר', label: 'סמינר' },
  { value: 'תואר ראשון', label: 'תואר ראשון' },
  { value: 'תואר שני', label: 'תואר שני' },
  { value: 'דוקטורט', label: 'דוקטורט' }
];

export const MARITAL_STATUS = [
  { value: 'רווק/ה', label: 'רווק/ה' },
  { value: 'גרוש/ה', label: 'גרוש/ה' },
  { value: 'אלמן/ה', label: 'אלמן/ה' }
];

export const OCCUPATION_CATEGORIES = [
  { value: 'חינוך', label: 'חינוך והוראה' },
  { value: 'הייטק', label: 'הייטק ותוכנה' },
  { value: 'רפואה', label: 'רפואה ובריאות' },
  { value: 'משפטים', label: 'משפטים' },
  { value: 'עסקים', label: 'עסקים וכלכלה' },
  { value: 'שירותים', label: 'שירותים' },
  { value: 'אחר', label: 'אחר' }
];

export const REGIONS = [
  { value: 'ירושלים', label: 'ירושלים והסביבה' },
  { value: 'תל אביב', label: 'תל אביב והמרכז' },
  { value: 'חיפה', label: 'חיפה והצפון' },
  { value: 'באר שבע', label: 'באר שבע והדרום' },
  { value: 'יהודה ושומרון', label: 'יהודה ושומרון' }
];

export const POPULAR_CITIES = [
  'ירושלים',
  'תל אביב',
  'חיפה',
  'בני ברק',
  'פתח תקווה',
  'אשדוד',
  'נתניה',
  'באר שבע',
  'חולון',
  'רמת גן',
  'בית שמש',
  'מודיעין עילית',
  'אלעד',
  'ביתר עילית'
];

export const AVAILABILITY_STATUS_OPTIONS = [
  { 
    value: AvailabilityStatus.AVAILABLE, 
    label: 'פנוי/ה',
    description: 'מועמד/ת פנוי/ה להצעות'
  },
  { 
    value: AvailabilityStatus.DATING, 
    label: 'בתהליך הכרות',
    description: 'נמצא/ת בתהליך הכרות'
  },
  { 
    value: AvailabilityStatus.UNAVAILABLE, 
    label: 'לא פנוי/ה',
    description: 'לא פנוי/ה להצעות כרגע'
  }
];

export const SORT_OPTIONS = [
  { 
    value: 'lastActive',
    label: 'פעילות אחרונה',
    defaultOrder: 'desc'
  },
  { 
    value: 'age',
    label: 'גיל',
    defaultOrder: 'asc'
  },
  { 
    value: 'name',
    label: 'שם',
    defaultOrder: 'asc'
  },
  { 
    value: 'city',
    label: 'עיר',
    defaultOrder: 'asc'
  },
  { 
    value: 'religiousLevel',
    label: 'רמת דתיות',
    defaultOrder: 'asc'
  },
  { 
    value: 'height',
    label: 'גובה',
    defaultOrder: 'desc'
  },
  { 
    value: 'registrationDate',
    label: 'תאריך הרשמה',
    defaultOrder: 'desc'
  }
];

export const VIEW_OPTIONS = [
  {
    value: 'grid',
    label: 'תצוגת גריד',
    icon: 'LayoutGrid'
  },
  {
    value: 'list',
    label: 'תצוגת רשימה',
    icon: 'List'
  }
];

export const CARD_SIZES = [
  {
    value: 'sm',
    label: 'קטן',
    dimensions: {
      grid: 'h-64',
      list: 'h-24'
    }
  },
  {
    value: 'md',
    label: 'בינוני',
    dimensions: {
      grid: 'h-80',
      list: 'h-32'
    }
  },
  {
    value: 'lg',
    label: 'גדול',
    dimensions: {
      grid: 'h-96',
      list: 'h-40'
    }
  }
];

export const GROUP_BY_OPTIONS = [
  {
    value: 'none',
    label: 'ללא קיבוץ'
  },
  {
    value: 'city',
    label: 'עיר'
  },
  {
    value: 'religiousLevel',
    label: 'רמת דתיות'
  },
  {
    value: 'ageGroup',
    label: 'קבוצת גיל'
  },
  {
    value: 'availability',
    label: 'סטטוס זמינות'
  }
];

export const DEFAULT_FILTERS = {
  gender: undefined,
  ageRange: AGE_RANGE.default,
  heightRange: HEIGHT_RANGE.default,
  cities: [],
  religiousLevel: undefined,
  occupations: [],
  availability: undefined,
  searchQuery: '',
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined
};

export const FILTER_CATEGORIES = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'education', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availability', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];
--- End of Content for filterOptions.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants\matchingCriteria.ts
--------------------------------------------------------------------------------
Content:
// /constants/matchingCriteria.ts

export const CRITERIA_WEIGHTS = {
    // קריטריונים בסיסיים
    age: {
      weight: 15,
      description: 'התאמת גיל',
      thresholds: {
        perfect: 2,  // הפרש של עד שנתיים
        good: 5,     // הפרש של עד 5 שנים
        fair: 8      // הפרש של עד 8 שנים
      }
    },
    
    religiousLevel: {
      weight: 20,
      description: 'התאמה דתית',
      bonusPoints: {
        exactMatch: 1.0,        // התאמה מדויקת
        adjacentLevel: 0.8,     // רמה דתית סמוכה
        twoLevelsApart: 0.4     // הפרש של שתי רמות
      }
    },
  
    location: {
      weight: 10,
      description: 'מיקום גיאוגרפי',
      bonusPoints: {
        sameCity: 1.0,          // אותה עיר
        sameRegion: 0.8,        // אותו אזור
        preferredCity: 0.7,     // עיר מועדפת
        differentRegion: 0.4    // אזור אחר
      }
    },
  
    // קריטריונים מקצועיים והשכלתיים
    education: {
      weight: 8,
      description: 'רמת השכלה',
      bonusPoints: {
        sameLevel: 1.0,         // רמת השכלה זהה
        adjacentLevel: 0.8,     // רמת השכלה סמוכה
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    occupation: {
      weight: 7,
      description: 'תחום עיסוק',
      bonusPoints: {
        sameField: 1.0,         // אותו תחום
        relatedField: 0.8,      // תחום קרוב
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    // קריטריונים אישיים
    familyBackground: {
      weight: 12,
      description: 'רקע משפחתי',
      factors: {
        origin: 0.4,            // מוצא
        parentStatus: 0.3,      // מצב הורים
        familyType: 0.3         // סוג משפחה
      }
    },
  
    personalityMatch: {
      weight: 15,
      description: 'התאמה אישיותית',
      factors: {
        hobbies: 0.3,           // תחביבים משותפים
        lifestyle: 0.4,         // סגנון חיים
        values: 0.3             // ערכים משותפים
      }
    },
  
    // גורמים נוספים
    preferences: {
      weight: 8,
      description: 'העדפות אישיות',
      factors: {
        agePreference: 0.3,     // העדפות גיל
        locationPreference: 0.3, // העדפות מיקום
        otherPreferences: 0.4   // העדפות נוספות
      }
    },
  
    compatibility: {
      weight: 5,
      description: 'תאימות כללית',
      factors: {
        language: 0.3,          // שפה משותפת
        culture: 0.4,           // תרבות
        lifestyle: 0.3          // סגנון חיים
      }
    }
  };
  
  // סף ציון להתאמה טובה
  export const MATCH_THRESHOLDS = {
    EXCELLENT: 85,  // התאמה מצוינת
    GOOD: 75,       // התאמה טובה
    FAIR: 65,       // התאמה סבירה
    POOR: 50        // התאמה חלשה
  };
  
  // משקלים יחסיים לפי סוג התאמה
  export const MATCH_TYPE_WEIGHTS = {
    PRECISE: {     // התאמה מדויקת
      exact: 1.0,
      similar: 0.8,
      partial: 0.5
    },
    FLEXIBLE: {    // התאמה גמישה
      exact: 0.8,
      similar: 1.0,
      partial: 0.7
    },
    OPEN: {        // התאמה פתוחה
      exact: 0.7,
      similar: 0.9,
      partial: 1.0
    }
  };
  
  // הגדרת קטגוריות להתאמה
  export const MATCH_CATEGORIES = {
    IMMEDIATE: {
      minScore: 90,
      label: 'התאמה מיידית',
      description: 'התאמה גבוהה מאוד, מומלץ ליצור קשר בהקדם'
    },
    HIGH: {
      minScore: 80,
      label: 'התאמה גבוהה',
      description: 'התאמה טובה מאוד, שווה לבדוק'
    },
    GOOD: {
      minScore: 70,
      label: 'התאמה טובה',
      description: 'יש פוטנציאל טוב להתאמה'
    },
    MODERATE: {
      minScore: 60,
      label: 'התאמה בינונית',
      description: 'יש נקודות משותפות, אבל גם הבדלים'
    },
    LOW: {
      minScore: 50,
      label: 'התאמה נמוכה',
      description: 'יש פערים משמעותיים בין המועמדים'
    }
  };
--- End of Content for matchingCriteria.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\ActionDialogs.tsx
--------------------------------------------------------------------------------
Content:
"use client";

// --- שינוי: הוספת useEffect ליבוא ---
import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Clock, Mail, Loader2 } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface NewSuggestionFormData {
  firstPartyId: string;
  secondPartyId: string;
  priority: Priority;
  status: MatchSuggestionStatus;
}
interface ActionDialogsProps {
  suggestDialog: {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: NewSuggestionFormData) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  availabilityDialog: {
    isOpen: boolean;
    onClose: () => void;
    onCheck: (candidate: Candidate) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  inviteDialog: {
    isOpen: boolean;
    onClose: () => void;
    onInvite: (candidate: Candidate, email: string) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
}

export const ActionDialogs: React.FC<ActionDialogsProps> = ({
  suggestDialog,
  availabilityDialog,
  inviteDialog,
}) => {
  // State for invite dialog
  const [inviteEmail, setInviteEmail] = useState("");
  const [isInviting, setIsInviting] = useState(false);
  const [inviteError, setInviteError] = useState<string | null>(null);

  // State for availability dialog
  const [isChecking, setIsChecking] = useState(false);
  const [availabilityError, setAvailabilityError] = useState<string | null>(
    null
  );

  // --- הוספה: useEffect למילוי אוטומטי של האימייל ---
  useEffect(() => {
    // בודקים אם דיאלוג ההזמנה פתוח ויש מועמד שנבחר
    if (inviteDialog.isOpen && inviteDialog.selectedCandidate) {
      // מעדכנים את שדה האימייל עם האימייל של המועמד מהדאטהבייס.
      // אם אין לו אימייל, השדה יישאר ריק.
      setInviteEmail(inviteDialog.selectedCandidate.email || "");
    } else {
      // כאשר הדיאלוג נסגר, מנקים את שדה האימייל
      setInviteEmail("");
    }
  }, [inviteDialog.isOpen, inviteDialog.selectedCandidate]); // ה-hook יופעל בכל פעם שהדיאלוג נפתח/נסגר או שהמועמד משתנה

  // Handler for invite submission
  const handleInviteSubmit = async () => {
    if (!inviteDialog.selectedCandidate || !inviteEmail) return;

    try {
      setIsInviting(true);
      setInviteError(null);
      await inviteDialog.onInvite(inviteDialog.selectedCandidate, inviteEmail);
      // setInviteEmail(""); // השורה הזו כבר לא הכרחית כי ה-useEffect ינקה את השדה בסגירה
      inviteDialog.onClose();
    } catch (error) {
      setInviteError(
        error instanceof Error ? error.message : "Failed to send invitation"
      );
    } finally {
      setIsInviting(false);
    }
  };

  // Handler for availability check
  const handleAvailabilityCheck = async () => {
    if (!availabilityDialog.selectedCandidate) return;

    try {
      setIsChecking(true);
      setAvailabilityError(null);
      await availabilityDialog.onCheck(availabilityDialog.selectedCandidate);
      availabilityDialog.onClose();
    } catch (error) {
      setAvailabilityError(
        error instanceof Error ? error.message : "Failed to check availability"
      );
    } finally {
      setIsChecking(false);
    }
  };

  return (
    <>
      {/* Invite Dialog */}
      <Dialog open={inviteDialog.isOpen} onOpenChange={inviteDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>שליחת הזמנה למועמד</DialogTitle>
            <DialogDescription>
              {inviteDialog.selectedCandidate && (
                <span>
                  שליחת הזמנה ל: {inviteDialog.selectedCandidate.firstName}{" "}
                  {inviteDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            <div>
              <Label>כתובת אימייל</Label>
              <Input
                type="email"
                value={inviteEmail}
                onChange={(e) => setInviteEmail(e.target.value)}
                placeholder="הזן כתובת אימייל"
                className="mt-2"
              />
            </div>

            {inviteError && (
              <Alert variant="destructive">
                <AlertDescription>{inviteError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={inviteDialog.onClose}
              disabled={isInviting}
            >
              ביטול
            </Button>
            <Button
              onClick={handleInviteSubmit}
              disabled={isInviting || !inviteEmail}
            >
              {isInviting ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Mail className="ml-2 h-4 w-4" />
              )}
              {isInviting ? "שולח..." : "שלח הזמנה"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Availability Check Dialog */}
      <Dialog
        open={availabilityDialog.isOpen}
        onOpenChange={availabilityDialog.onClose}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>בדיקת זמינות</DialogTitle>
            <DialogDescription>
              {availabilityDialog.selectedCandidate && (
                <span>
                  בדיקת זמינות עבור:{" "}
                  {availabilityDialog.selectedCandidate.firstName}{" "}
                  {availabilityDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            {availabilityError && (
              <Alert variant="destructive">
                <AlertDescription>{availabilityError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={availabilityDialog.onClose}
              disabled={isChecking}
            >
              ביטול
            </Button>
            <Button onClick={handleAvailabilityCheck} disabled={isChecking}>
              {isChecking ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Clock className="ml-2 h-4 w-4" />
              )}
              {isChecking ? "בודק..." : "בדוק זמינות"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Suggest Match Dialog */}
      <Dialog open={suggestDialog.isOpen} onOpenChange={suggestDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>הצעת שידוך חדשה</DialogTitle>
            <DialogDescription>
              {suggestDialog.selectedCandidate && (
                <span>
                  יצירת הצעת שידוך עבור:{" "}
                  {suggestDialog.selectedCandidate.firstName}{" "}
                  {suggestDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>
          {/* תוכן הדיאלוג יועבר מהקומפוננטה NewSuggestionForm */}
        </DialogContent>
      </Dialog>
    </>
  );
};

export default ActionDialogs;
--- End of Content for ActionDialogs.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\AddManualCandidateDialog.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2, UserPlus, X, UploadCloud, Trash2 } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import Image from "next/image";
import { Gender } from "@prisma/client";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { DatePicker } from "@/components/ui/date-picker";
import {
  RadioGroup,
  RadioGroupItem,
} from "@/components/ui/radio-group";

interface AddManualCandidateDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onCandidateAdded: () => void;
}

const MAX_IMAGES = 5;
const MAX_IMAGE_SIZE_MB = 5;

export const AddManualCandidateDialog: React.FC<
  AddManualCandidateDialogProps
> = ({ isOpen, onClose, onCandidateAdded }) => {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [gender, setGender] = useState<Gender | undefined>(undefined);
  const [birthDate, setBirthDate] = useState<Date | undefined>(undefined);
  const [manualEntryText, setManualEntryText] = useState("");
  const [images, setImages] = useState<File[]>([]);
  const [imagePreviews, setImagePreviews] = useState<string[]>([]);
  const [sendInvite, setSendInvite] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [birthDateInputMode, setBirthDateInputMode] = useState<"date" | "age">(
    "date"
  );
  const [ageInput, setAgeInput] = useState<string>("");

  const resetForm = useCallback(() => {
    setFirstName("");
    setLastName("");
    setEmail("");
    setGender(undefined);
    setBirthDate(undefined);
    setManualEntryText("");
    setImages([]);
    setImagePreviews([]);
    setSendInvite(false);
    setIsSaving(false);
    setBirthDateInputMode("date");
    setAgeInput("");
  }, []);

  const handleClose = () => {
    resetForm();
    onClose();
  };

  const handleImageChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      const newFiles = Array.from(event.target.files);
      const validFiles: File[] = [];
      const validPreviews: string[] = [];

      newFiles.forEach((file) => {
        if (images.length + validFiles.length < MAX_IMAGES) {
          if (file.size <= MAX_IMAGE_SIZE_MB * 1024 * 1024) {
            validFiles.push(file);
            validPreviews.push(URL.createObjectURL(file));
          } else {
            toast.error(
              `הקובץ ${file.name} גדול מדי (מקסימום ${MAX_IMAGE_SIZE_MB}MB).`
            );
          }
        } else {
          toast.warning(`ניתן להעלות עד ${MAX_IMAGES} תמונות.`);
        }
      });

      setImages((prev) => [...prev, ...validFiles]);
      setImagePreviews((prev) => [...prev, ...validPreviews]);
    }
  };

  const removeImage = (index: number) => {
    const newImages = images.filter((_, i) => i !== index);
    const newImagePreviews = imagePreviews.filter((_, i) => i !== index);
    setImages(newImages);
    setImagePreviews(newImagePreviews);
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setIsSaving(true);

    if (!firstName || !lastName || !gender || !manualEntryText) {
      toast.error(
        "נא למלא את כל שדות החובה: שם פרטי, שם משפחה, מין וטקסט חופשי."
      );
      setIsSaving(false);
      return;
    }

    let finalBirthDate: Date | undefined;
    let isBirthDateApproximate: boolean = false;

    if (birthDateInputMode === "date") {
      if (!birthDate) {
        toast.error("נא לבחור תאריך לידה.");
        setIsSaving(false);
        return;
      }
      finalBirthDate = birthDate;
      isBirthDateApproximate = false;
    } else {
      const ageNum = parseInt(ageInput, 10);
      if (isNaN(ageNum) || ageNum <= 0 || ageNum > 120) {
        toast.error("נא להזין גיל תקין (בין 1 ל-120).");
        setIsSaving(false);
        return;
      }
      const currentYear = new Date().getFullYear();
      const birthYear = currentYear - ageNum;
      finalBirthDate = new Date(birthYear, 0, 1);
      isBirthDateApproximate = true;
    }

    if (!finalBirthDate) {
        toast.error("שגיאה בקביעת תאריך לידה. נא לבדוק את הקלט.");
        setIsSaving(false);
        return;
    }

    const formData = new FormData();
    formData.append("firstName", firstName);
    formData.append("lastName", lastName);
    if (email) formData.append("email", email);
    formData.append("gender", gender);
    formData.append("birthDate", finalBirthDate.toISOString());
    formData.append("birthDateIsApproximate", String(isBirthDateApproximate));
    formData.append("manualEntryText", manualEntryText);
    images.forEach((image) => {
      formData.append("images", image);
    });

    try {
      const response = await fetch("/api/matchmaker/candidates/manual", {
        method: "POST",
        body: formData,
      });

      const result = await response.json();

      if (response.ok && result.success) {
        if (sendInvite && email && result.candidate?.id) {
           const promise = fetch(`/api/matchmaker/candidates/${result.candidate.id}/invite-setup`, {
               method: 'POST',
               headers: { 'Content-Type': 'application/json' },
               body: JSON.stringify({ email }),
           }).then(async (inviteResponse) => {
               if (!inviteResponse.ok) {
                   const errorData = await inviteResponse.json().catch(() => ({}));
                   throw new Error(errorData.error || 'שליחת ההזמנה נכשלה.');
               }
               return inviteResponse.json();
           });

           toast.promise(promise, {
               loading: 'מוסיף מועמד ושולח הזמנה...',
               success: 'המועמד נוסף וההזמנה נשלחה בהצלחה!',
               error: (err: Error) => `המועמד נוסף, אך שליחת ההזמנה נכשלה: ${err.message}`,
           });
        } else {
            toast.success("המועמד הידני נוסף בהצלחה!");
        }

        onCandidateAdded();
        handleClose();
      } else {
        throw new Error(result.error || "שגיאה בהוספת המועמד.");
      }
    } catch (error) {
      console.error("Error adding manual candidate:", error);
      toast.error(
        "שגיאה בהוספת המועמד: " +
          (error instanceof Error ? error.message : "שגיאה לא ידועה")
      );
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => { if (!open) handleClose(); }}>
      <DialogContent className="max-w-2xl">
        <DialogClose asChild>
          <button className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground p-1">
            <X className="h-4 w-4" />
            <span className="sr-only">סגור</span>
          </button>
        </DialogClose>

        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-right">
            <UserPlus className="w-6 h-6 text-primary" />
            הוספת מועמד ידנית
          </DialogTitle>
          <DialogDescription className="text-right">
            הזן את פרטי המועמד שברצונך להוסיף למערכת באופן ידני.
          </DialogDescription>
        </DialogHeader>

        <form
          onSubmit={handleSubmit}
          className="space-y-6 py-4 max-h-[70vh] overflow-y-auto pr-2 pl-1"
        >
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="firstName" className="text-right block">
                שם פרטי <span className="text-red-500">*</span>
              </Label>
              <Input
                id="firstName"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                placeholder="לדוגמה: ישראל"
                required
                dir="rtl"
              />
            </div>
            <div>
              <Label htmlFor="lastName" className="text-right block">
                שם משפחה <span className="text-red-500">*</span>
              </Label>
              <Input
                id="lastName"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                placeholder="לדוגמה: ישראלי"
                required
                dir="rtl"
              />
            </div>
          </div>

          <div>
            <Label htmlFor="email" className="text-right block">
              כתובת אימייל (אופציונלי)
            </Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="לדוגמה: user@example.com"
              dir="ltr"
            />
            <p className="text-xs text-gray-500 mt-1 text-right">
              אם לא תסופק כתובת אימייל, תיווצר כתובת פנימית עבור המערכת.
            </p>
          </div>

          <div className="flex items-center space-x-2 rtl:space-x-reverse pt-2">
            <Checkbox
              id="sendInvite"
              checked={sendInvite}
              onCheckedChange={(checked) => setSendInvite(Boolean(checked))}
              disabled={!email || isSaving}
            />
            <Label
              htmlFor="sendInvite"
              className={`cursor-pointer transition-colors ${!email ? 'text-gray-400 cursor-not-allowed' : 'text-gray-700'}`}
            >
              שלח הזמנה למועמד/ת להגדרת חשבון לאחר ההוספה
            </Label>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="gender" className="text-right block">
                מין <span className="text-red-500">*</span>
              </Label>
              <Select
                value={gender}
                onValueChange={(value) => setGender(value as Gender)}
              >
                <SelectTrigger id="gender" dir="rtl">
                  <SelectValue placeholder="בחר/י מין" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Gender.MALE}>זכר</SelectItem>
                  <SelectItem value={Gender.FEMALE}>נקבה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div>
              <div>
                <Label className="text-right block mb-2">
                  אופן הזנת גיל/תאריך לידה <span className="text-red-500">*</span>
                </Label>
                <RadioGroup
                  dir="rtl"
                  value={birthDateInputMode}
                  onValueChange={(value: "date" | "age") => {
                    setBirthDateInputMode(value);
                    if (value === "date") {
                      setAgeInput("");
                    } else {
                      setBirthDate(undefined);
                    }
                  }}
                  className="flex space-x-4 rtl:space-x-reverse mb-3"
                >
                  <div className="flex items-center space-x-2 rtl:space-x-reverse">
                    <RadioGroupItem value="date" id="r-date" />
                    <Label htmlFor="r-date" className="cursor-pointer">לפי תאריך לידה</Label>
                  </div>
                  <div className="flex items-center space-x-2 rtl:space-x-reverse">
                    <RadioGroupItem value="age" id="r-age" />
                    <Label htmlFor="r-age" className="cursor-pointer">לפי גיל</Label>
                  </div>
                </RadioGroup>
              </div>

              {birthDateInputMode === "date" ? (
                <div>
                  <Label htmlFor="birthDate" className="text-right block">
                    תאריך לידה <span className="text-red-500">*</span>
                  </Label>
                  <DatePicker
                    value={
                      birthDate ? { from: birthDate, to: undefined } : undefined
                    }
                    onChange={({ from }) => setBirthDate(from)}
                    isRange={false}
                    placeholder="בחר תאריך לידה"
                    className="w-full"
                  />
                </div>
              ) : (
                <div>
                  <Label htmlFor="ageInput" className="text-right block">
                    גיל (משוער) <span className="text-red-500">*</span>
                  </Label>
                  <Input
                    id="ageInput"
                    type="number"
                    value={ageInput}
                    onChange={(e) => setAgeInput(e.target.value)}
                    placeholder="לדוגמה: 25"
                    required={birthDateInputMode === "age"}
                    dir="rtl"
                    min="1"
                    max="120"
                  />
                   <p className="text-xs text-gray-500 mt-1 text-right">
                    יוזן תאריך לידה משוער (1 בינואר של שנת הלידה) בהתאם לגיל שהוזן.
                  </p>
                </div>
              )}
            </div>
          </div>

          <div>
            <Label htmlFor="manualEntryText" className="text-right block">
              טקסט חופשי על המועמד <span className="text-red-500">*</span>
            </Label>
            <Textarea
              id="manualEntryText"
              value={manualEntryText}
              onChange={(e) => setManualEntryText(e.target.value)}
              placeholder="ספר על המועמד, רקע, תכונות, מה מחפש/ת וכו'..."
              rows={6}
              required
              className="min-h-[100px]"
              dir="rtl"
            />
          </div>

          <div>
            <Label htmlFor="image-upload" className="text-right block">
              תמונות (עד {MAX_IMAGES})
            </Label>
            <div className="mt-2 flex items-center justify-center w-full">
              <label
                htmlFor="image-upload"
                className="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100"
              >
                <div className="flex flex-col items-center justify-center pt-5 pb-6">
                  <UploadCloud className="w-8 h-8 mb-2 text-gray-500" />
                  <p className="mb-2 text-sm text-gray-500 text-center">
                    גרור ושחרר תמונות לכאן, או לחץ לבחירה
                  </p>
                  <p className="text-xs text-gray-500">
                    PNG, JPG, WEBP (עד {MAX_IMAGE_SIZE_MB}MB לתמונה)
                  </p>
                </div>
                <Input
                  id="image-upload"
                  type="file"
                  multiple
                  accept="image/png, image/jpeg, image/webp"
                  className="hidden"
                  onChange={handleImageChange}
                  disabled={images.length >= MAX_IMAGES}
                />
              </label>
            </div>
            {imagePreviews.length > 0 && (
              <div className="mt-4 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                {imagePreviews.map((preview, index) => (
                  <div key={index} className="relative group">
                    <Image
                      src={preview}
                      alt={`תצוגה מקדימה ${index + 1}`}
                      width={100}
                      height={100}
                      className="rounded-md object-cover w-full aspect-square"
                      onLoad={() => URL.revokeObjectURL(preview)} // Clean up object URLs
                    />
                    <Button
                      type="button"
                      variant="destructive"
                      size="icon"
                      className="absolute top-1 right-1 h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity p-0"
                      onClick={() => removeImage(index)}
                    >
                      <Trash2 className="h-3 w-3" />
                      <span className="sr-only">הסר תמונה</span>
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </div>

          <DialogFooter className="pt-4 sm:justify-start">
            <Button type="submit" disabled={isSaving} className="w-full sm:w-auto">
              {isSaving ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <UserPlus className="w-4 h-4 mr-2" />
              )}
              {isSaving ? "שומר..." : "הוסף מועמד"}
            </Button>
            <DialogClose asChild>
              <Button variant="outline" type="button" className="w-full sm:w-auto mt-2 sm:mt-0">
                <X className="w-4 h-4 mr-2" />
                ביטול
              </Button>
            </DialogClose>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};
--- End of Content for AddManualCandidateDialog.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\AiMatchAnalysisDialog.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/dialogs/AiMatchAnalysisDialog.tsx

"use client";

import React, { useState, useEffect, useMemo } from 'react';
import Image from 'next/image';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogClose } from "@/components/ui/dialog";
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Skeleton } from '@/components/ui/skeleton';
import { X, Sparkles, CheckCircle, AlertTriangle, MessageSquare, Info, XCircle, Star, Cake, MapPin, BookMarked, Users, ChevronsUpDown } from 'lucide-react';
import type { Candidate } from '../types/candidates';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from "framer-motion";

// --- Interfaces ---
interface AiAnalysis {
  overallScore: number;
  matchSummary: string;
  compatibilityPoints: { area: string; explanation: string; strength: 'HIGH' | 'MEDIUM' | 'LOW' }[];
  potentialChallenges: { area: string; explanation: string; severity: 'HIGH' | 'MEDIUM' | 'LOW' }[];
  suggestedConversationStarters: string[];
}

interface AiMatchAnalysisDialogProps {
  isOpen: boolean;
  onClose: () => void;
  targetCandidate: Candidate | null;
  comparisonCandidates: Candidate[];
}

// --- Helper Functions ---
const getInitials = (firstName?: string, lastName?: string): string => {
  let initials = "";
  if (firstName && firstName.length > 0) initials += firstName[0];
  if (lastName && lastName.length > 0) initials += lastName[0];
  return initials.toUpperCase() || "?";
};

const calculateAge = (birthDate: Date | string): number => {
    if (!birthDate) return 0;
    const today = new Date();
    const birth = new Date(birthDate);
    if (isNaN(birth.getTime())) return 0;
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
        age--;
    }
    return age > 0 ? age : 0;
};

// --- Sub-components ---

const MiniProfileHeader: React.FC<{ candidate: Candidate; score?: number; isTarget?: boolean }> = ({ candidate, score, isTarget = false }) => {
  const mainImage = candidate.images?.find(img => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);
  const initials = getInitials(candidate.firstName, candidate.lastName);

  return (
    <div className="p-4 rounded-t-lg bg-gradient-to-b from-slate-50 to-slate-100 border-b border-slate-200 text-center relative">
      <div className="relative w-24 h-24 mx-auto rounded-full overflow-hidden border-4 border-white shadow-lg ring-2 ring-offset-2 ring-cyan-400">
        {mainImage?.url ? (
          <Image src={mainImage.url} alt={`תמונת פרופיל של ${candidate.firstName}`} layout="fill" className="object-cover" />
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-slate-200 to-slate-300">
            <span className="text-4xl font-medium text-slate-500">{initials}</span>
          </div>
        )}
      </div>
      
      {!isTarget && typeof score === 'number' && (
        <Badge className="absolute top-4 left-4 bg-gradient-to-r from-teal-400 to-cyan-500 text-white border-0 shadow-lg px-3 py-1.5 text-sm font-bold flex items-center gap-1.5">
          <Sparkles className="w-4 h-4" />
          {score}% התאמה
        </Badge>
      )}

      {isTarget && (
        <Badge className="absolute top-4 right-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white border-0 shadow-lg px-3 py-1.5 text-sm font-bold flex items-center gap-1.5">
          <Star className="w-4 h-4" />
          מועמד מטרה
        </Badge>
      )}

      <h3 className="mt-3 text-lg font-bold text-slate-800">{candidate.firstName} {candidate.lastName}</h3>
      <div className="mt-2 flex justify-center items-center flex-wrap gap-x-3 gap-y-1 text-xs text-slate-600">
        <div className="flex items-center gap-1"><Cake className="w-3.5 h-3.5 text-slate-400"/> {age} שנים</div>
        <div className="flex items-center gap-1"><MapPin className="w-3.5 h-3.5 text-slate-400"/> {candidate.profile.city || 'לא צוין'}</div>
        <div className="flex items-center gap-1"><BookMarked className="w-3.5 h-3.5 text-slate-400"/> {candidate.profile.religiousLevel || 'לא צוין'}</div>
      </div>
    </div>
  );
};

const AnalysisItem: React.FC<{ icon: React.ElementType; iconColor: string; area: string; explanation: string; }> = ({ icon: Icon, iconColor, area, explanation }) => (
    <div className="flex items-start gap-4 p-3 rounded-lg hover:bg-slate-50/70 transition-colors">
        <div className={cn("mt-1 flex-shrink-0 rounded-full p-2 bg-opacity-10", iconColor.replace('text-', 'bg-'))}>
            <Icon className={cn("h-5 w-5", iconColor)} />
        </div>
        <div>
            <h4 className="font-semibold text-gray-800">{area}</h4>
            <p className="text-sm text-gray-600 leading-relaxed">{explanation}</p>
        </div>
    </div>
);

const ComparisonTable: React.FC<{ target: Candidate; comparison: Candidate; }> = ({ target, comparison }) => {
    const fieldsToCompare = [
        { key: 'age', label: 'גיל', formatter: (c: Candidate) => `${calculateAge(c.profile.birthDate)}${c.profile.birthDateIsApproximate ? ' (משוער)' : ''}` },
        { key: 'city', label: 'עיר', formatter: (c: Candidate) => c.profile.city || 'לא צוין' },
        { key: 'maritalStatus', label: 'מצב משפחתי', formatter: (c: Candidate) => c.profile.maritalStatus || 'לא צוין' },
        { key: 'religiousLevel', label: 'רמה דתית', formatter: (c: Candidate) => c.profile.religiousLevel || 'לא צוין' },
        { key: 'occupation', label: 'עיסוק', formatter: (c: Candidate) => c.profile.occupation || 'לא צוין' },
        { key: 'education', label: 'השכלה', formatter: (c: Candidate) => c.profile.education || 'לא צוין' },
    ];
  
    return (
      <div className="overflow-x-auto border rounded-lg">
        <table className="w-full text-sm text-right border-collapse">
          <thead>
            <tr className="bg-slate-50">
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200">קריטריון</th>
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200 text-center">{target.firstName}</th>
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200 text-center">{comparison.firstName}</th>
            </tr>
          </thead>
          <tbody>
            {fieldsToCompare.map((field, index) => (
              <tr key={field.key} className={index % 2 === 0 ? "bg-white" : "bg-slate-50/50"}>
                <td className="p-3 font-medium text-slate-500 border-b border-slate-200">{field.label}</td>
                <td className="p-3 text-slate-700 border-b border-slate-200 text-center">{field.formatter(target)}</td>
                <td className="p-3 text-slate-700 border-b border-slate-200 text-center">{field.formatter(comparison)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    );
};

const AnalysisSkeleton: React.FC = () => (
    <div className="space-y-6 p-4 animate-pulse">
        <div className="p-4 bg-gray-100 rounded-lg"><div className="h-20 bg-gray-200 rounded-md"></div></div>
        <div className="space-y-4">
            <div className="h-5 bg-gray-200 rounded-md w-1/3"></div>
            <div className="flex gap-4"><div className="rounded-full bg-gray-200 h-10 w-10"></div><div className="flex-1 space-y-2 py-1"><div className="h-4 bg-gray-200 rounded w-full"></div><div className="h-3 bg-gray-300 rounded w-5/6"></div></div></div>
            <div className="flex gap-4"><div className="rounded-full bg-gray-200 h-10 w-10"></div><div className="flex-1 space-y-2 py-1"><div className="h-4 bg-gray-200 rounded w-full"></div><div className="h-3 bg-gray-300 rounded w-4/6"></div></div></div>
        </div>
    </div>
);

// --- Main Dialog Component ---

export const AiMatchAnalysisDialog: React.FC<AiMatchAnalysisDialogProps> = ({ isOpen, onClose, targetCandidate, comparisonCandidates }) => {
  const [activeComparisonId, setActiveComparisonId] = useState<string | null>(null);
  const [analyses, setAnalyses] = useState<Record<string, AiAnalysis | 'error' | 'loading'>>({});
  const [language, setLanguage] = useState<'he' | 'en'>('he');
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const activeComparisonCandidate = useMemo(() => {
    return comparisonCandidates.find(c => c.id === activeComparisonId);
  }, [activeComparisonId, comparisonCandidates]);
  
  const activeAnalysis = useMemo(() => {
      if (!activeComparisonId) return null;
      return analyses[activeComparisonId] || null;
  }, [activeComparisonId, analyses]);

  useEffect(() => {
    if (isOpen && comparisonCandidates.length > 0 && !comparisonCandidates.some(c => c.id === activeComparisonId)) {
      setActiveComparisonId(comparisonCandidates[0].id);
    }
  }, [isOpen, comparisonCandidates, activeComparisonId]);

  useEffect(() => {
    if (isOpen && targetCandidate && activeComparisonId && analyses[activeComparisonId] === undefined) {
      const fetchAnalysis = async () => {
        setAnalyses(prev => ({ ...prev, [activeComparisonId]: 'loading' }));

        try {
          const response = await fetch('/api/ai/generate-rationale', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              userId1: targetCandidate.id,
              userId2: activeComparisonId,
              language: language,
            }),
          });

          const data = await response.json();
          if (response.ok && data.success) {
            setAnalyses(prev => ({ ...prev, [activeComparisonId]: data.analysis }));
          } else {
            throw new Error(data.error || "Failed to fetch analysis");
          }
        } catch (e) {
          console.error(`Failed to get analysis for ${activeComparisonId}:`, e);
          setAnalyses(prev => ({ ...prev, [activeComparisonId]: 'error' }));
        }
      };
      fetchAnalysis();
    }
  }, [isOpen, targetCandidate, activeComparisonId, language, analyses]);

  const handleLanguageChange = (newLang: 'he' | 'en') => {
    if (newLang !== language) {
      setLanguage(newLang);
      setAnalyses({});
    }
  };
  
  if (!isOpen || !targetCandidate) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl w-full h-[95vh] flex flex-col p-0 overflow-hidden" dir="rtl">
        <DialogHeader className="p-4 border-b flex-row justify-between items-center flex-shrink-0">
          <div className="flex items-center gap-3">
            <Sparkles className="w-7 h-7 text-teal-500" />
            <div>
              <DialogTitle className="text-xl">ניתוח התאמה מבוסס AI</DialogTitle>
              <DialogDescription>השוואה מפורטת בין מועמדים</DialogDescription>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Select value={language} onValueChange={handleLanguageChange}>
              <SelectTrigger className="w-[120px] text-xs h-9">
                <SelectValue placeholder="שפת ניתוח" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="he">עברית</SelectItem>
                <SelectItem value="en">English</SelectItem>
              </SelectContent>
            </Select>
            <DialogClose asChild>
              <Button variant="ghost" size="icon"><X className="h-5 w-5"/></Button>
            </DialogClose>
          </div>
        </DialogHeader>

        <div className="flex-1 flex flex-col md:flex-row min-h-0">
          {/* Sidebar (Desktop) or Select (Mobile) */}
          {isMobile ? (
            <div className="p-4 border-b md:hidden">
                <Select value={activeComparisonId || ''} onValueChange={setActiveComparisonId}>
                    <SelectTrigger className="w-full">
                        <SelectValue placeholder="בחר מועמד להשוואה" />
                    </SelectTrigger>
                    <SelectContent>
                        {comparisonCandidates.map(c => (
                            <SelectItem key={c.id} value={c.id}>{c.firstName} {c.lastName}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>
          ) : (
            <aside className="w-1/4 border-l bg-slate-50/50 flex flex-col flex-shrink-0">
              <h3 className="p-3 text-sm font-semibold text-slate-600 border-b">מועמדים להשוואה ({comparisonCandidates.length})</h3>
              <ScrollArea className="flex-1">
                {comparisonCandidates.map(candidate => (
                  <button
                    key={candidate.id}
                    onClick={() => setActiveComparisonId(candidate.id)}
                    className={cn(
                      "w-full text-right p-3 flex items-center gap-3 border-b border-slate-200/60 hover:bg-slate-100 transition-colors",
                      activeComparisonId === candidate.id && "bg-cyan-50 border-r-4 border-cyan-500 font-semibold"
                    )}
                  >
                    <div className="relative w-10 h-10 rounded-full overflow-hidden flex-shrink-0">
                       <Image src={candidate.images?.find(img => img.isMain)?.url || '/placeholder.jpg'} alt={candidate.firstName} layout="fill" className="object-cover" />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="truncate text-sm text-slate-800">{candidate.firstName} {candidate.lastName}</p>
                      <p className="text-xs text-slate-500">{calculateAge(candidate.profile.birthDate)} | {candidate.profile.city}</p>
                    </div>
                    {activeAnalysis && activeAnalysis !== 'error' && activeAnalysis !== 'loading' && (
                      <Badge variant="secondary" className="bg-teal-100 text-teal-800">{(activeAnalysis as AiAnalysis).overallScore}%</Badge>
                    )}
                  </button>
                ))}
              </ScrollArea>
            </aside>
          )}

          {/* Main content area */}
          <main className="flex-1 flex flex-col min-h-0 bg-white">
            {!activeComparisonCandidate ? (
                 <div className="flex-1 flex flex-col items-center justify-center text-center p-6 text-gray-500">
                    <Users className="w-16 h-16 text-gray-300 mb-4"/>
                    <h3 className="text-lg font-semibold">בחר מועמד/ת להשוואה</h3>
                    <p className="max-w-xs">בחר מועמד מהרשימה בצד (או מהתפריט הנפתח במובייל) כדי להתחיל בניתוח ההתאמה.</p>
                 </div>
            ) : (
                <>
                    <div className="grid grid-cols-1 md:grid-cols-2 flex-shrink-0">
                      <MiniProfileHeader candidate={targetCandidate} isTarget />
                      <MiniProfileHeader candidate={activeComparisonCandidate} score={(activeAnalysis as AiAnalysis)?.overallScore} />
                    </div>

                    <Tabs defaultValue="summary" className="flex-1 flex flex-col min-h-0">
                      <TabsList className="mx-4 mt-4 bg-slate-100 p-1 rounded-lg">
                        <TabsTrigger value="summary">סיכום וחוזקות</TabsTrigger>
                        <TabsTrigger value="challenges">אתגרים ופערים</TabsTrigger>
                        <TabsTrigger value="comparison">השוואת נתונים</TabsTrigger>
                        <TabsTrigger value="conversation">נושאים לשיחה</TabsTrigger>
                      </TabsList>
                      <ScrollArea className="flex-1">
                        <AnimatePresence mode="wait">
                          <motion.div
                            key={activeComparisonId}
                            initial={{ opacity: 0, y: 10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -10 }}
                            transition={{ duration: 0.2 }}
                            className="p-4 md:p-6"
                          >
                            {activeAnalysis === 'loading' && <AnalysisSkeleton />}
                            {activeAnalysis === 'error' && (
                                <div className="text-center py-10">
                                    <XCircle className="w-12 h-12 text-red-400 mx-auto mb-4"/>
                                    <h3 className="font-semibold text-xl text-red-600">שגיאה בניתוח ההתאמה</h3>
                                    <p className="text-gray-500 mt-2">לא הצלחנו להפיק ניתוח עבור זוג זה. אנא נסה שוב מאוחר יותר.</p>
                                </div>
                            )}
                            {activeAnalysis && activeAnalysis !== 'error' && activeAnalysis !== 'loading' && (
                              <>
                                <TabsContent value="summary" className="space-y-6 mt-0">
                                  <div className="p-4 bg-slate-50/70 rounded-lg border border-slate-200"><h3 className="font-semibold text-gray-800 mb-2 flex items-center gap-2"><Info className="w-5 h-5 text-blue-500"/> סיכום ההתאמה</h3><p className="text-sm text-gray-600 leading-relaxed">{(activeAnalysis as AiAnalysis).matchSummary}</p></div>
                                  <div><h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><CheckCircle className="w-5 h-5 text-green-500"/> נקודות חוזק וחיבור</h3><div className="space-y-4">{(activeAnalysis as AiAnalysis).compatibilityPoints.map(point => <AnalysisItem key={point.area} icon={CheckCircle} iconColor="text-green-500" {...point} />)}</div></div>
                                </TabsContent>
                                <TabsContent value="challenges" className="space-y-6 mt-0">
                                  <div><h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><AlertTriangle className="w-5 h-5 text-amber-500"/> אתגרים ופערים פוטנציאליים</h3><div className="space-y-4">{(activeAnalysis as AiAnalysis).potentialChallenges.map(challenge => <AnalysisItem key={challenge.area} icon={AlertTriangle} iconColor="text-amber-500" {...challenge} />)}</div></div>
                                </TabsContent>
                                <TabsContent value="comparison" className="mt-0"><ComparisonTable target={targetCandidate} comparison={activeComparisonCandidate} /></TabsContent>
                                <TabsContent value="conversation" className="space-y-4 mt-0">
                                  <h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><MessageSquare className="w-5 h-5 text-indigo-500"/> נושאים מומלצים לשיחה</h3>
                                  <ul className="space-y-3 list-inside">{(activeAnalysis as AiAnalysis).suggestedConversationStarters.map((starter, index) => (<li key={index} className="flex items-start gap-2 p-2 rounded-md hover:bg-indigo-50/50"><MessageSquare className="w-4 h-4 text-indigo-400 mt-1 flex-shrink-0"/><span className="text-sm text-gray-700">{starter}</span></li>))}</ul>
                                </TabsContent>
                              </>
                            )}
                          </motion.div>
                        </AnimatePresence>
                      </ScrollArea>
                    </Tabs>
                </>
            )}
          </main>
        </div>
      </DialogContent>
    </Dialog>
  );
};
--- End of Content for AiMatchAnalysisDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\filterUtils
--------------------------------------------------------------------------------
Content:
--- End of Content for filterUtils ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useCandidates.ts
--------------------------------------------------------------------------------
Content:
import { useState, useEffect, useMemo, useCallback } from 'react';
import Papa from 'papaparse';
import type { Candidate, CandidatesFilter } from '../types/candidates';
import type { CandidateProfile } from '../types/candidates';
import { Dispatch, SetStateAction } from 'react';

export interface UseCandidatesReturn {
  loading: boolean;
  error: string | null;
  candidates: Candidate[];
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  filteredCandidates: Candidate[];
  filters: CandidatesFilter;
  setFilters: Dispatch<SetStateAction<CandidatesFilter>>;
  refresh: () => Promise<void>;
  totalCount: number;
  filteredCount: number;
  maleCount: number;
  femaleCount: number;
  searchResults: {
    term: string;
    count: number;
    male: number;
    female: number;
  } | null;
  exportCandidates: (candidates: Candidate[], filters: CandidatesFilter) => Promise<void>;
  updateCandidate: (id: string, updates: Partial<CandidateProfile>) => Promise<void>;
  sorting: {
    field: string;
    direction: 'asc' | 'desc';
  };
  setSorting: (field: string, direction: 'asc' | 'desc') => void;
  searchSuggestions: (term: string) => Promise<Candidate[]>;
}

export const useCandidates = (initialFilters: CandidatesFilter = {}): UseCandidatesReturn => {
  // Base states
  const [candidates, setCandidates] = useState<Candidate[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<CandidatesFilter>(initialFilters);
  const [searchResults, setSearchResults] = useState<{
    term: string;
    count: number;
    male: number;
    female: number;
  } | null>(null);
  const [sorting, setSortingState] = useState<{
    field: string;
    direction: 'asc' | 'desc';
  }>({
    field: 'lastActive',
    direction: 'desc',
  });

  // Helper function to calculate age
  const calculateAge = useCallback((birthDate: Date): number => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    return age;
  }, []);

  // Fetch candidates data
  const fetchCandidates = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/matchmaker/candidates');
      if (!response.ok) {
        throw new Error(await response.text());
      }
      
      const data = await response.json();
     
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load candidates');
      }
  
      setCandidates(data.clients);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
      console.error('Error fetching candidates:', err);
    } finally {
      setLoading(false);
    }
  };

  // Set sorting field and direction
  const setSorting = useCallback((field: string, direction: 'asc' | 'desc') => {
    setSortingState({ field, direction });
  }, []);

  // Search suggestions based on a term
  const searchSuggestions = useCallback(async (term: string): Promise<Candidate[]> => {
    if (!term || term.length < 2) return [];
    
    // Local search implementation for quick response
    const searchTerm = term.toLowerCase();
    return candidates.filter(candidate => {
      const searchableText = `
        ${candidate.firstName} 
        ${candidate.lastName} 
        ${candidate.profile.occupation || ''} 
        ${candidate.profile.city || ''}
        ${candidate.profile.religiousLevel || ''}
      `.toLowerCase();
      
      return searchableText.includes(searchTerm);
    }).slice(0, 10);
    
    // Alternatively, you can implement an API call for server-side search
    // if the dataset is very large
  }, [candidates]);

  const sortCandidates = useCallback((candidatesList: Candidate[], field: string, direction: 'asc' | 'desc') => {
    return [...candidatesList].sort((a, b) => {
      let valueA, valueB;
      
      switch (field) {
        case 'name':
          valueA = `${a.firstName} ${a.lastName}`.toLowerCase();
          valueB = `${b.firstName} ${b.lastName}`.toLowerCase();
          break;
        case 'age':
          valueA = calculateAge(a.profile.birthDate);
          valueB = calculateAge(b.profile.birthDate);
          break;
        case 'city':
          valueA = (a.profile.city || '').toLowerCase();
          valueB = (b.profile.city || '').toLowerCase();
          break;
        case 'religiousLevel':
          valueA = (a.profile.religiousLevel || '').toLowerCase();
          valueB = (b.profile.religiousLevel || '').toLowerCase();
          break;
        case 'lastActive':
          valueA = a.profile.lastActive ? new Date(a.profile.lastActive).getTime() : 0;
          valueB = b.profile.lastActive ? new Date(b.profile.lastActive).getTime() : 0;
          break;
        case 'registrationDate':
          valueA = new Date(a.createdAt).getTime();
          valueB = new Date(b.createdAt).getTime();
          break;
        case 'height':
          valueA = a.profile.height || 0;
          valueB = b.profile.height || 0;
          break;
        default:
          valueA = 0;
          valueB = 0;
      }
      
      if (valueA < valueB) return direction === 'asc' ? -1 : 1;
      if (valueA > valueB) return direction === 'asc' ? 1 : -1;
      return 0;
    });
  }, [calculateAge]);
  
  // פונקציה לבדיקה אם מועמד עומד בקריטריוני חיפוש
  const checkSearchMatch = useCallback((candidate: Candidate, searchTerm: string): boolean => {
    if (!searchTerm) return true;
    
    // נרמול החיפוש
    const normalizedTerm = searchTerm.toLowerCase().trim();
    if (!normalizedTerm) return true;
    
    // בדיקת התאמה בשדות השונים
    const fullName = `${candidate.firstName} ${candidate.lastName}`.toLowerCase();
    const city = (candidate.profile.city || '').toLowerCase();
    const occupation = (candidate.profile.occupation || '').toLowerCase();
    const religiousLevel = (candidate.profile.religiousLevel || '').toLowerCase();
    
    return (
      fullName.includes(normalizedTerm) || 
      city.includes(normalizedTerm) || 
      occupation.includes(normalizedTerm) || 
      religiousLevel.includes(normalizedTerm)
    );
  }, []);

  // בקובץ useCandidates.ts - לעדכן את החלק של filteredCandidates
  const filteredCandidates = useMemo(() => {
    console.log("Filtering candidates with filters:", filters);
    
    // אם הסינון הנפרד מופעל, נשתמש בפילטרים הכלליים בלבד ללא מגדר
    const currentFilters = filters.separateFiltering 
      ? { ...filters, gender: undefined }
      : filters;

    let results = candidates.filter(candidate => {
      // סינון לפי מגדר רק אם הסינון הנפרד כבוי
      if (!filters.separateFiltering && currentFilters.gender && candidate.profile.gender !== currentFilters.gender) {
        return false;
      }
      if (currentFilters.source && candidate.source !== currentFilters.source) {
    return false;
}
      // בדיקת גיל מותאמת
      if (currentFilters.ageRange) {
        try {
          const age = calculateAge(candidate.profile.birthDate);
          if (age < currentFilters.ageRange.min || age > currentFilters.ageRange.max) {
            return false;
          }
        } catch (err) {
          console.error("Error calculating age for candidate:", candidate.id, err);
        }
      }
      
      // סינון סטטוס משתמש
      if (filters.userStatus && candidate.status !== filters.userStatus) {
        return false;
      }
   // סינון סטטוס משתמש
      if (filters.userStatus && candidate.status !== filters.userStatus) {
        return false;
      }
      // סינון סטטוס זמינות - ודא המרה נכונה של הטיפוס
      if (filters.availabilityStatus && 
          candidate.profile.availabilityStatus !== filters.availabilityStatus) {
        return false;
      }
      
      // בדיקת גובה
      if (filters.heightRange && candidate.profile.height) {
        if (
          candidate.profile.height < filters.heightRange.min || 
          candidate.profile.height > filters.heightRange.max
        ) {
          return false;
        }
      }

      // בדיקת רמת דתיות
      if (filters.religiousLevel && candidate.profile.religiousLevel !== filters.religiousLevel) {
        return false;
      }

      // בדיקת ערים
      if (filters.cities?.length && candidate.profile.city) {
        if (!filters.cities.includes(candidate.profile.city)) {
          return false;
        }
      }

      // בדיקת תחומי עיסוק
      if (filters.occupations?.length && candidate.profile.occupation) {
        if (!filters.occupations.includes(candidate.profile.occupation)) {
          return false;
        }
      }

      // בדיקת השכלה
      if (filters.educationLevel && candidate.profile.education !== filters.educationLevel) {
        return false;
      }

      // בדיקת מצב משפחתי
      if (filters.maritalStatus && candidate.profile.maritalStatus !== filters.maritalStatus) {
        return false;
      }

      // בדיקת אימות
      if (filters.isVerified !== undefined && candidate.isVerified !== filters.isVerified) {
        return false;
      }

      // בדיקת המלצות
   
      // בדיקת פעילות אחרונה
      if (filters.lastActiveDays && candidate.profile.lastActive) {
        const lastActive = new Date(candidate.profile.lastActive);
        const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
        if (daysDiff > filters.lastActiveDays) {
          return false;
        }
      }

      // בדיקת שלמות פרופיל
      if (filters.isProfileComplete !== undefined && 
          candidate.isProfileComplete !== filters.isProfileComplete) {
        return false;
      }

      // בדיקת חיפוש כללי - רק אם אין סינון נפרד
      if (!filters.separateFiltering && currentFilters.searchQuery) {
        return checkSearchMatch(candidate, currentFilters.searchQuery);
      }

      return true;
    });

    // מיון התוצאות
    if (sorting.field && sorting.direction) {
      results = sortCandidates(results, sorting.field, sorting.direction);
    }

    return results;
  }, [candidates, filters, calculateAge, sorting.field, sorting.direction, sortCandidates, checkSearchMatch]);

  // חלוקה למועמדים ומועמדות עם תמיכה בחיפוש נפרד
  const maleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לגברים
      return filteredCandidates
        .filter(c => c.profile.gender === 'MALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לגברים
          if (filters.maleFilters) {
            // בדיקת גיל
            if (filters.maleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.maleFilters.ageRange.min || age > filters.maleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.maleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.maleFilters.heightRange.min || 
                candidate.profile.height > filters.maleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.maleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.maleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.maleFilters.cities?.length && candidate.profile.city) {
              if (!filters.maleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.maleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.maleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.maleFilters.educationLevel && candidate.profile.education !== filters.maleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.maleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.maleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.maleFilters.isVerified !== undefined && candidate.isVerified !== filters.maleFilters.isVerified) {
              return false;
            }

    

            // בדיקת פעילות אחרונה
            if (filters.maleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.maleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.maleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.maleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הגברים
            if (filters.maleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.maleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לגברים
          if (filters.maleSearchQuery) {
            return checkSearchMatch(candidate, filters.maleSearchQuery);
          }
          
          return true;
        });
    
      }, [filteredCandidates, filters.maleFilters, filters.maleSearchQuery, calculateAge, checkSearchMatch]);
  const femaleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לנשים

      return filteredCandidates
        .filter(c => c.profile.gender === 'FEMALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לנשים
          if (filters.femaleFilters) {
            // בדיקת גיל
            if (filters.femaleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.femaleFilters.ageRange.min || age > filters.femaleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.femaleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.femaleFilters.heightRange.min || 
                candidate.profile.height > filters.femaleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.femaleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.femaleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.femaleFilters.cities?.length && candidate.profile.city) {
              if (!filters.femaleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.femaleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.femaleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.femaleFilters.educationLevel && candidate.profile.education !== filters.femaleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.femaleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.femaleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.femaleFilters.isVerified !== undefined && candidate.isVerified !== filters.femaleFilters.isVerified) {
              return false;
            }

       

            // בדיקת פעילות אחרונה
            if (filters.femaleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.femaleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.femaleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.femaleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הנשים
            if (filters.femaleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.femaleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לנשים
          if (filters.femaleSearchQuery) {
            return checkSearchMatch(candidate, filters.femaleSearchQuery);
          }
          
          return true;
        });
      }, [filteredCandidates, filters.femaleFilters, filters.femaleSearchQuery, calculateAge, checkSearchMatch]);
  // עדכון תוצאות החיפוש
  useEffect(() => {
    if (!filters.separateFiltering && filters.searchQuery) {
      // מצב חיפוש רגיל
      setSearchResults({
        term: filters.searchQuery,
        count: filteredCandidates.length,
        male: maleCandidates.length,
        female: femaleCandidates.length
      });
    } else if (filters.separateFiltering) {
      // במצב חיפוש נפרד, לא מציגים תוצאות חיפוש מאוחדות
      setSearchResults(null);
    } else {
      setSearchResults(null);
    }
  }, [filteredCandidates, maleCandidates, femaleCandidates, filters.searchQuery, filters.separateFiltering]);

  // Export candidates to CSV
  const exportCandidates = async (
    candidates: Candidate[], 
    filters: CandidatesFilter
  ): Promise<void> => {
    try {
      // Prepare data for export
      const exportData = candidates.map(candidate => ({
        'שם פרטי': candidate.firstName,
        'שם משפחה': candidate.lastName,
        'גיל': calculateAge(candidate.profile.birthDate),
        'מגדר': candidate.profile.gender === 'MALE' ? 'זכר' : 'נקבה',
        'עיר': candidate.profile.city || '',
        'גובה': candidate.profile.height || '',
        'רמת דתיות': candidate.profile.religiousLevel || '',
        'תעסוקה': candidate.profile.occupation || '',
        'השכלה': candidate.profile.education || '',
        'מצב משפחתי': candidate.profile.maritalStatus || '',
        'סטטוס זמינות': candidate.profile.availabilityStatus || '',
        'מאומת': candidate.isVerified ? 'כן' : 'לא',
        'פעילות אחרונה': candidate.profile.lastActive 
          ? new Date(candidate.profile.lastActive).toLocaleDateString('he-IL')
          : ''
      }));

      // Add filter info to filename
      const filenameSegments = ['candidates'];
      
      if (filters.gender) {
        filenameSegments.push(filters.gender === 'MALE' ? 'male' : 'female');
      }
      
      if (filters.religiousLevel) {
        filenameSegments.push(filters.religiousLevel.replace(/ /g, '-'));
      }
      
      if (filters.cities?.length === 1) {
        filenameSegments.push(filters.cities[0].replace(/ /g, '-'));
      }
      
      // Convert to CSV
      const csv = Papa.unparse(exportData);
      
      // Create and download file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      const timestamp = new Date().toISOString().split('T')[0];
      
      link.setAttribute('href', url);
      link.setAttribute('download', `${filenameSegments.join('_')}_${timestamp}.csv`);
      document.body.appendChild(link);
      
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Error exporting candidates:', error);
      throw new Error('Failed to export candidates');
    }
  };

  // Update candidate
  const updateCandidate = async (
    id: string, 
    updates: Partial<CandidateProfile>
  ): Promise<void> => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error('Failed to update candidate');
      }
      
      // Refresh candidates list after update
      await fetchCandidates();
    } catch (error) {
      console.error('Error updating candidate:', error);
      throw error;
    }
  };

  // Load candidates on mount
  useEffect(() => {
    fetchCandidates();
  }, []);

  // Return interface
  return {
    loading,
    error,
    candidates,
    filteredCandidates,
    maleCandidates,
    femaleCandidates,
    filters,
    setFilters,
    refresh: fetchCandidates,
    totalCount: candidates.length,
    filteredCount: filteredCandidates.length,
    maleCount: maleCandidates.length,
    femaleCount: femaleCandidates.length,
    searchResults,
    exportCandidates,
    updateCandidate,
    sorting,
    setSorting,
    searchSuggestions
  };
};
--- End of Content for useCandidates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useFilterLogic.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/hooks/useFilterLogic.ts - גרסה משופרת

import { useState, useEffect, useMemo, useCallback } from 'react';
import type {
  FilterState,
  SavedFilter,
  FilterOption,
  FilterChangeHandler,  
} from '../types/filters';
import { DEFAULT_FILTER_STATE } from '../types/filters'; 

type SavedFilterFromStorage = Omit<SavedFilter, 'createdAt'> & {
  createdAt: string;
};

interface SearchHistoryItemFromStorage {
  query: string;
  timestamp: string;
}
interface UseFilterLogicProps {
  onFilterChange?: FilterChangeHandler;
  defaultFilters?: Partial<FilterState>;
  localStorageKey?: string;
}

export const useFilterLogic = ({
  onFilterChange,
  defaultFilters = {},
  localStorageKey = 'candidateFilters'
}: UseFilterLogicProps = {}) => {
  // States
  const [filters, setFilters] = useState<FilterState>({
    ...DEFAULT_FILTER_STATE,
    ...defaultFilters
  });
  
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [searchHistory, setSearchHistory] = useState<{query: string, timestamp: Date}[]>([]);
  const [lastAppliedFilter, setLastAppliedFilter] = useState<string | null>(null);

  // Load saved filters and history from localStorage
  useEffect(() => {
    try {
      // Load saved filters
      const savedPrefs = localStorage.getItem(localStorageKey);
      if (savedPrefs) {
        const parsed = JSON.parse(savedPrefs);
        setSavedFilters(parsed.map((filter: SavedFilterFromStorage) => ({
          ...filter,
          createdAt: new Date(filter.createdAt)
        })));
      }

      // Load recent searches
      const searches = localStorage.getItem(`${localStorageKey}_recent_searches`);
      if (searches) {
        setRecentSearches(JSON.parse(searches));
      }

      // Load search history
      const history = localStorage.getItem(`${localStorageKey}_search_history`);
      if (history) {
        setSearchHistory(JSON.parse(history).map((item: SearchHistoryItemFromStorage) => ({
          ...item,
          timestamp: new Date(item.timestamp)
        })));
      }
    } catch (error) {
      console.error('Error loading saved filters:', error);
    }
  }, [localStorageKey]);

  // עדכון פילטרים כללי
  const updateFilters = useCallback((newFilters: Partial<FilterState>) => {
    console.log("updateFilters called with:", newFilters);
    
    setFilters(prev => {
      const updated = { ...prev, ...newFilters };
      console.log("Updated filters:", updated);
      
      // אם יש מחרוזת חיפוש חדשה, עדכן את היסטורית החיפוש
      if (newFilters.searchQuery && newFilters.searchQuery !== prev.searchQuery) {
        const newQuery = newFilters.searchQuery;
        console.log("New search query detected:", newQuery);
        
        // עדכון היסטוריית החיפוש
        const updatedHistory = [
          { query: newQuery, timestamp: new Date() },
          ...searchHistory.filter(item => item.query !== newQuery).slice(0, 9)
        ];
        
        setSearchHistory(updatedHistory);
        setRecentSearches(updatedHistory.map(item => item.query));
        
        // שמירה ב-localStorage
        try {
          localStorage.setItem(
            `${localStorageKey}_recent_searches`, 
            JSON.stringify(updatedHistory.map(item => item.query))
          );
          localStorage.setItem(
            `${localStorageKey}_search_history`,
            JSON.stringify(updatedHistory.map(item => ({
              query: item.query,
              timestamp: item.timestamp.toISOString()
            })))
          );
        } catch (e) {
          console.error("Error saving search history:", e);
        }
      }
      
      // טיפול בחיפוש נפרד לגברים
      if (newFilters.maleSearchQuery && newFilters.maleSearchQuery !== prev.maleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי גברים או לשמור בהיסטוריה הכללית
        console.log("New male search query:", newFilters.maleSearchQuery);
      }
      
      // טיפול בחיפוש נפרד לנשים
      if (newFilters.femaleSearchQuery && newFilters.femaleSearchQuery !== prev.femaleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי נשים או לשמור בהיסטוריה הכללית
        console.log("New female search query:", newFilters.femaleSearchQuery);
      }

      // קריאה לפונקציית callback
      if (onFilterChange) {
        console.log("Calling onFilterChange with updated filters");
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange, searchHistory, localStorageKey, setRecentSearches, setSearchHistory]);

  // Reset filters
  const resetFilters = useCallback(() => {
    const defaultState: FilterState = {
      ...DEFAULT_FILTER_STATE,
      ...defaultFilters
    };

    setFilters(defaultState);
    setLastAppliedFilter(null);
    onFilterChange?.(defaultState);
  }, [defaultFilters, onFilterChange]);

  // Clear recent searches
  const clearRecentSearches = useCallback(() => {
    setRecentSearches([]);
    localStorage.removeItem(`${localStorageKey}_recent_searches`);
  }, [localStorageKey]);

  // Save new filter
  const saveFilter = useCallback(async (name: string, filters: FilterState) => {
    const newFilter: SavedFilter = {
      id: Date.now().toString(),
      name,
      filters,
      isDefault: false,
      createdAt: new Date()
    };

    setSavedFilters(prev => {
      const updated = [...prev, newFilter];
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });

    return newFilter;
  }, [localStorageKey]);

  // פונקציה משופרת להחלפת מצב הסינון הנפרד
  const toggleSeparateFiltering = useCallback(() => {
    console.log("toggleSeparateFiltering called");
    
    setFilters(prev => {
      const newState = {
        ...prev,
        separateFiltering: !prev.separateFiltering
      };
      
      console.log(`Changing separateFiltering from ${prev.separateFiltering} to ${newState.separateFiltering}`);
      
      return newState;
    });
  }, []);

  // פונקציה משופרת לעדכון סינון גברים
  const updateMaleFilters = useCallback((maleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedMaleFilters = {
        ...prev.maleFilters,
        ...maleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לגברים
      if (maleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          maleFilters: updatedMaleFilters,
          maleSearchQuery: maleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        maleFilters: updatedMaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת לעדכון סינון נשים
  const updateFemaleFilters = useCallback((femaleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedFemaleFilters = {
        ...prev.femaleFilters,
        ...femaleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לנשים
      if (femaleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          femaleFilters: updatedFemaleFilters,
          femaleSearchQuery: femaleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        femaleFilters: updatedFemaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  const updateMaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        maleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לגברים אם פעיל סינון נפרד
      if (prev.separateFiltering) {
        updated.maleFilters = {
          ...prev.maleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);
  
  // פונקציה חדשה לעדכון חיפוש נפרד לנשים
  const updateFemaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        femaleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לנשים אם פעיל סינון נפרד
      if (prev.separateFiltering) {
        updated.femaleFilters = {
          ...prev.femaleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת להעתקת סינון מצד אחד לשני
  const copyFilters = useCallback((source: 'male' | 'female', target: 'male' | 'female') => {
    setFilters(prev => {
      const sourceFilters = source === 'male' ? prev.maleFilters : prev.femaleFilters;
      
      if (!sourceFilters) {
        return prev;
      }
      
      const updated = { ...prev };
      
      if (target === 'male') {
        updated.maleFilters = { ...sourceFilters };
      } else {
        updated.femaleFilters = { ...sourceFilters };
      }
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // Update existing filter
  const updateSavedFilter = useCallback((id: string, updates: Partial<SavedFilter>) => {
    setSavedFilters(prev => {
      const updated = prev.map(filter => 
        filter.id === id ? { ...filter, ...updates } : filter
      );
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Delete filter
  const deleteFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.filter(f => f.id !== id);
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      
      if (lastAppliedFilter === id) {
        setLastAppliedFilter(null);
      }
      
      return updated;
    });
  }, [localStorageKey, lastAppliedFilter]);

  // Set default filter
  const setDefaultFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.map(f => ({
        ...f,
        isDefault: f.id === id
      }));
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Load saved filter - תמיכה בסינון נפרד
  const loadSavedFilter = useCallback((id: string) => {
    const filter = savedFilters.find(f => f.id === id);
    if (filter) {
      // בדוק אם יש בפילטר השמור מידע לגבי סינון נפרד
      setFilters({ 
        ...filter.filters, 
        savedFilterId: id,
        // וודא שיש תמיד את המאפיינים האלה, גם אם אינם מוגדרים בפילטר המקורי
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {}
      });
      
      setLastAppliedFilter(id);
      onFilterChange?.({ 
        ...filter.filters, 
        savedFilterId: id,
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {} 
      });
    }
  }, [savedFilters, onFilterChange]);

  // Apply popular filter
  const applyPopularFilter = useCallback((filterConfig: Partial<FilterState>) => {
    const updatedFilters = {
      ...DEFAULT_FILTER_STATE,
      ...filterConfig
    };
    setFilters(updatedFilters);
    onFilterChange?.(updatedFilters);
  }, [onFilterChange]);

  // Check for active filters
  const hasActiveFilters = useMemo(() => {
    return (
      filters.searchQuery ||
      filters.gender !== undefined ||
      (filters.cities?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      (filters.occupations?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      filters.religiousLevel ||
      filters.educationLevel ||
      filters.maritalStatus ||
      filters.availabilityStatus ||
      filters.userStatus ||
      filters.isVerified ||
      filters.hasReferences ||
      filters.lastActiveDays ||
      filters.isProfileComplete ||
      (filters.ageRange && (
        filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min ||
        filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
      )) ||
      (filters.heightRange && (
        filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min ||
        filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
      )) ||
      // בדיקת פילטרים נפרדים פעילים
      filters.separateFiltering
    );
  }, [filters]);

  // Get active filters in formatted array
  const activeFilters = useMemo((): FilterOption[] => {
    const active: FilterOption[] = [];

    if (filters.searchQuery) {
      active.push({
        key: 'searchQuery',
        value: filters.searchQuery,
        label: `חיפוש: ${filters.searchQuery}`,
        category: 'חיפוש'
      });
    }

    if (filters.gender) {
      active.push({
        key: 'gender',
        value: filters.gender,
        label: `מגדר: ${filters.gender === 'MALE' ? 'זכר' : 'נקבה'}`,
        category: 'מידע בסיסי'
      });
    }

    if (filters.separateFiltering) {
      active.push({
        key: 'separateFiltering',
        value: true,
        label: 'סינון נפרד לפי מגדר',
        category: 'מידע בסיסי'
      });
    }

    // גיל
    if (filters.ageRange && (
      filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min || 
      filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
    )) {
      active.push({
        key: 'ageRange',
        value: filters.ageRange,
        label: `גיל: ${filters.ageRange.min}-${filters.ageRange.max}`,
        category: 'מידע בסיסי'
      });
    }

    // גובה
    if (filters.heightRange && (
      filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min || 
      filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
    )) {
      active.push({
        key: 'heightRange',
        value: filters.heightRange,
        label: `גובה: ${filters.heightRange.min}-${filters.heightRange.max} ס"מ`,
        category: 'מידע בסיסי'
      });
    }

    // ערים
    if (filters.cities?.length) {
      if (filters.cities.length === 1) {
        active.push({
          key: 'cities',
          value: filters.cities[0],
          label: `עיר: ${filters.cities[0]}`,
          category: 'מיקום'
        });
      } else {
        active.push({
          key: 'cities',
          value: filters.cities,
          label: `ערים: ${filters.cities.length} נבחרו`,
          category: 'מיקום'
        });
      }
    }

    // תחומי עיסוק
    if (filters.occupations?.length) {
      if (filters.occupations.length === 1) {
        active.push({
          key: 'occupations',
          value: filters.occupations[0],
          label: `תחום עיסוק: ${filters.occupations[0]}`,
          category: 'תעסוקה'
        });
      } else {
        active.push({
          key: 'occupations',
          value: filters.occupations,
          label: `תחומי עיסוק: ${filters.occupations.length} נבחרו`,
          category: 'תעסוקה'
        });
      }
    }

    // רמת דתיות
    if (filters.religiousLevel) {
      active.push({
        key: 'religiousLevel',
        value: filters.religiousLevel,
        label: `רמת דתיות: ${filters.religiousLevel}`,
        category: 'דת'
      });
    }

    // השכלה
    if (filters.educationLevel) {
      active.push({
        key: 'educationLevel',
        value: filters.educationLevel,
        label: `השכלה: ${filters.educationLevel}`,
        category: 'השכלה'
      });
    }

    // מצב משפחתי
    if (filters.maritalStatus) {
      active.push({
        key: 'maritalStatus',
        value: filters.maritalStatus,
        label: `מצב משפחתי: ${filters.maritalStatus}`,
        category: 'מידע אישי'
      });
    }

    // סטטוס זמינות
    if (filters.availabilityStatus) {
      const statusLabel = 
        filters.availabilityStatus === "AVAILABLE" ? "פנוי/ה" :
        filters.availabilityStatus === "DATING" ? "בתהליך הכרות" :
        filters.availabilityStatus === "UNAVAILABLE" ? "לא פנוי/ה" :
        filters.availabilityStatus;
      
      active.push({
        key: 'availabilityStatus',
        value: filters.availabilityStatus,
        label: `סטטוס זמינות: ${statusLabel}`,
        category: 'זמינות'
      });
    }

    // סטטוס משתמש
    if (filters.userStatus) {
      active.push({
        key: 'userStatus',
        value: filters.userStatus,
        label: `סטטוס משתמש: ${filters.userStatus}`,
        category: 'סטטוס'
      });
    }

    // משתמש מאומת
    if (filters.isVerified !== undefined) {
      active.push({
        key: 'isVerified',
        value: filters.isVerified,
        label: `משתמש מאומת: ${filters.isVerified ? 'כן' : 'לא'}`,
        category: 'אימות'
      });
    }

    // יש המלצות
    if (filters.hasReferences !== undefined) {
      active.push({
        key: 'hasReferences',
        value: filters.hasReferences,
        label: `יש המלצות: ${filters.hasReferences ? 'כן' : 'לא'}`,
        category: 'המלצות'
      });
    }

    // פעילות אחרונה
    if (filters.lastActiveDays !== undefined) {
      active.push({
        key: 'lastActiveDays',
        value: filters.lastActiveDays,
        label: `פעיל ב-${filters.lastActiveDays} הימים האחרונים`,
        category: 'פעילות'
      });
    }

    // פרופיל מלא
    if (filters.isProfileComplete !== undefined) {
      active.push({
        key: 'isProfileComplete',
        value: filters.isProfileComplete,
        label: `פרופיל מלא: ${filters.isProfileComplete ? 'כן' : 'לא'}`,
        category: 'שלמות פרופיל'
      });
    }

    return active;
  }, [filters]);

  // Remove single filter
  const removeFilter = useCallback((key: keyof FilterState, value?: string) => {
    setFilters(prev => {
      const updated = { ...prev };

      if (key === 'separateFiltering') {
        updated.separateFiltering = false;
      } else if (Array.isArray(updated[key]) && value !== undefined) {
        if (key === 'cities' || key === 'occupations') {
          updated[key] = (updated[key] as string[]).filter(v => v !== value);
        }
      } else {
        delete updated[key];
      }

      onFilterChange?.(updated);
      return updated;
    });
  }, [onFilterChange]);
  
  // Calculate popular filters based on search history
  const popularFilters = useMemo(() => {
    // Group searches by frequency
    const searchFrequency: Record<string, number> = {};
    searchHistory.forEach(item => {
      searchFrequency[item.query] = (searchFrequency[item.query] || 0) + 1;
    });
    
    // Sort by frequency
    return Object.entries(searchFrequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([query]) => query);
  }, [searchHistory]);

  return {
    // Current state
    filters,
    savedFilters,
    recentSearches,
    searchHistory,
    activeFilters,
    hasActiveFilters,
    popularFilters,
    lastAppliedFilter,
    
    // Separate filtering functions
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    
    // חיפוש נפרד פונקציות חדשות
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
    
    // Actions
    setFilters: updateFilters,
    removeFilter,
    resetFilters,
    clearRecentSearches,
    applyPopularFilter,

    // Saved filters management
    saveFilter,
    updateSavedFilter,
    deleteFilter,
    setDefaultFilter,
    loadSavedFilter,
};
};
export default useFilterLogic;
--- End of Content for useFilterLogic.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useStatistics.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useStatistics.ts

import { useMemo } from 'react';
import type { Candidate } from '../types/candidates';
import {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
} from '../../suggestions/utils/statisticsCalculator';

export interface Statistics {
  gender: {
    maleCount: number;
    femaleCount: number;
    ratio: number;
    total: number;
    percentages: {
      male: number;
      female: number;
    };
  };
  age: {
    ageGroups: Record<string, number>;
    averageAge: number;
    medianAge: number;
  };
  location: {
    cities: Record<string, number>;
    topCities: Array<{ city: string; count: number }>;
  };
  religious: {
    levels: Record<string, number>;
    percentages: Record<string, number>;
  };
  activity: {
    activeLastWeek: number;
    activeLastMonth: number;
    averageLoginFrequency: number;
    completedProfiles: number;
  };
  availability: {
    counts: Record<string, number>;
    percentages: Record<string, number>;
  };
  completion: {
    counts: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
    percentages: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
  };
}

export const useStatistics = (candidates: Candidate[]) => {
  const stats = useMemo<Statistics>(() => {
    return {
      gender: calculateGenderStats(candidates),
      age: calculateAgeDistribution(candidates),
      location: calculateLocationDistribution(candidates),
      religious: calculateReligiousDistribution(candidates),
      activity: calculateActivityStats(candidates),
      availability: calculateAvailabilityStats(candidates),
      completion: calculateCompletionStats(candidates)
    };
  }, [candidates]);

  // פונקציות עזר לשליפת נתונים ספציפיים
  const getGenderRatio = () => {
    return {
      ratio: stats.gender.ratio,
      formattedRatio: `${stats.gender.maleCount}:${stats.gender.femaleCount}`
    };
  };

  const getTopCities = (limit: number = 5) => {
    return stats.location.topCities.slice(0, limit);
  };

  const getActiveUsersPercent = () => {
    return Math.round((stats.activity.activeLastWeek / stats.gender.total) * 100);
  };

  const getCompletionRate = () => {
    return stats.completion.percentages.fullyCompleted;
  };

  const getAgeGroupDistribution = () => {
    return Object.entries(stats.age.ageGroups)
      .map(([range, count]) => ({
        range,
        count,
        percentage: Math.round((count / stats.gender.total) * 100)
      }))
      .sort((a, b) => {
        const [aMin] = a.range.split('-').map(Number);
        const [bMin] = b.range.split('-').map(Number);
        return aMin - bMin;
      });
  };

  const getReligiousDistribution = () => {
    return Object.entries(stats.religious.levels)
      .map(([level, count]) => ({
        level,
        count,
        percentage: stats.religious.percentages[level]
      }))
      .sort((a, b) => b.count - a.count);
  };

  const getActivityTrend = () => {
    return {
      weekly: stats.activity.activeLastWeek,
      monthly: stats.activity.activeLastMonth,
      average: stats.activity.averageLoginFrequency
    };
  };

  const getProfileCompletionStats = () => {
    return {
      completed: stats.completion.counts.fullyCompleted,
      partial: stats.gender.total - stats.completion.counts.fullyCompleted,
      percentage: stats.completion.percentages.fullyCompleted
    };
  };

  return {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getCompletionRate,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats
  };
};

export default useStatistics;
--- End of Content for useStatistics.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\LoadingStates.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { Loader2, AlertCircle } from "lucide-react";
import { cn } from "@/lib/utils";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";

interface LoadingContainerProps {
  children: React.ReactNode;
  className?: string;
}

interface LoadingSpinnerProps {
  size?: "sm" | "md" | "lg";
  className?: string;
}

interface LoadingCardProps {
  count?: number;
  layout?: "grid" | "list";
  className?: string;
}

interface LoadingTextProps {
  lines?: number;
  className?: string;
}

interface LoadingErrorProps {
  message: string;
  onRetry?: () => void;
  className?: string;
}

export const LoadingContainer: React.FC<LoadingContainerProps> = ({
  children,
  className,
}) => {
  return (
    <div className={cn("relative min-h-[200px]", className)}>
      <div className="absolute inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
      </div>
      <div className="opacity-50 pointer-events-none">{children}</div>
    </div>
  );
};

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = "md",
  className,
}) => {
  const sizeClasses = {
    sm: "w-4 h-4",
    md: "w-8 h-8",
    lg: "w-12 h-12",
  };

  return (
    <div className={cn("flex items-center justify-center", className)}>
      <Loader2
        className={cn("animate-spin text-blue-600", sizeClasses[size])}
      />
    </div>
  );
};

export const LoadingCard: React.FC<LoadingCardProps> = ({
  count = 1,
  layout = "grid",
  className,
}) => {
  return (
    <div
      className={cn(
        layout === "grid"
          ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
          : "space-y-4",
        className
      )}
    >
      {Array.from({ length: count }).map((_, index) => (
        <div
          key={index}
          className={cn(
            "bg-white rounded-lg overflow-hidden shadow-sm",
            layout === "list" ? "flex gap-4" : ""
          )}
        >
          <Skeleton
            className={cn(
              "bg-gray-200",
              layout === "list" ? "w-32 h-32" : "w-full h-48"
            )}
          />

          <div className="p-4 flex-1">
            <div className="flex items-center justify-between mb-4">
              <Skeleton className="h-6 w-1/3" />
              <Skeleton className="h-6 w-16" />
            </div>

            <div className="space-y-2">
              <Skeleton className="h-4 w-2/3" />
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-4 w-3/4" />
            </div>

            <div className="flex gap-2 mt-4">
              <Skeleton className="h-9 w-24" />
              <Skeleton className="h-9 w-24" />
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export const LoadingText: React.FC<LoadingTextProps> = ({
  lines = 3,
  className,
}) => {
  return (
    <div className={cn("space-y-2", className)}>
      {Array.from({ length: lines }).map((_, index) => (
        <Skeleton
          key={index}
          className={cn("h-4", index === lines - 1 ? "w-3/4" : "w-full")}
        />
      ))}
    </div>
  );
};

export const LoadingError: React.FC<LoadingErrorProps> = ({
  message,
  onRetry,
  className,
}) => {
  return (
    <Alert variant="destructive" className={cn("border-red-500", className)}>
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>שגיאה</AlertTitle>
      <AlertDescription className="flex items-center justify-between">
        <span>{message}</span>
        {onRetry && (
          <Button
            variant="outline"
            size="sm"
            onClick={onRetry}
            className="ml-4"
          >
            נסה שוב
          </Button>
        )}
      </AlertDescription>
    </Alert>
  );
};

export const LoadingStats: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("grid grid-cols-2 md:grid-cols-4 gap-4", className)}>
      {Array.from({ length: 4 }).map((_, index) => (
        <div key={index} className="bg-white p-4 rounded-lg shadow-sm">
          <Skeleton className="h-4 w-16 mb-2" />
          <Skeleton className="h-8 w-24" />
        </div>
      ))}
    </div>
  );
};

export const LoadingFilters: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("space-y-4", className)}>
      <Skeleton className="h-10 w-full" />
      <div className="flex flex-wrap gap-2">
        {Array.from({ length: 4 }).map((_, index) => (
          <Skeleton key={index} className="h-8 w-24" />
        ))}
      </div>
    </div>
  );
};

// Create a named object containing all loading components
const LoadingComponents = {
  LoadingContainer,
  LoadingSpinner,
  LoadingCard,
  LoadingText,
  LoadingError,
  LoadingStats,
  LoadingFilters,
};

// Export the named object as default
export default LoadingComponents;
--- End of Content for LoadingStates.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\Pagination.tsx
--------------------------------------------------------------------------------
Content:
// /shared/Pagination.tsx
"use client";


import React from 'react';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { 
  ChevronRight, 
  ChevronLeft,
  ChevronsLeft,
  ChevronsRight
} from 'lucide-react';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  pageSize: number;
  totalItems: number;
  onPageChange: (page: number) => void;
  onPageSizeChange: (size: number) => void;
  className?: string;
}

const pageSizeOptions = [10, 20, 50, 100];

const Pagination: React.FC<PaginationProps> = ({
  currentPage,
  totalPages,
  pageSize,
  totalItems,
  onPageChange,
  onPageSizeChange,
  className
}) => {
  // Helper to generate page numbers array
  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisiblePages = 5;
    
    if (totalPages <= maxVisiblePages) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    // Always show first page
    pages.push(1);

    // Calculate start and end of visible pages
    let start = Math.max(currentPage - 1, 2);
    let end = Math.min(currentPage + 1, totalPages - 1);

    // Adjust for edge cases
    if (currentPage <= 3) {
      end = Math.min(maxVisiblePages - 1, totalPages - 1);
    } else if (currentPage >= totalPages - 2) {
      start = Math.max(totalPages - maxVisiblePages + 2, 2);
    }

    // Add ellipsis and numbers
    if (start > 2) pages.push('...');
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    if (end < totalPages - 1) pages.push('...');

    // Always show last page
    if (totalPages > 1) pages.push(totalPages);

    return pages;
  };

  const startItem = (currentPage - 1) * pageSize + 1;
  const endItem = Math.min(currentPage * pageSize, totalItems);

  return (
    <div className={`flex flex-col sm:flex-row items-center justify-between gap-4 ${className}`}>
      {/* Page Size Selector */}
      <div className="flex items-center gap-2 text-sm text-gray-600">
        <span>הצג</span>
        <Select
          value={pageSize.toString()}
          onValueChange={(value) => onPageSizeChange(Number(value))}
        >
          <SelectTrigger className="w-[70px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {pageSizeOptions.map(size => (
              <SelectItem key={size} value={size.toString()}>
                {size}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <span>שורות</span>
      </div>

      {/* Results Count */}
      <div className="text-sm text-gray-600">
        מציג {startItem}-{endItem} מתוך {totalItems} תוצאות
      </div>

      {/* Page Navigation */}
      <div className="flex items-center gap-1">
        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(1)}
          disabled={currentPage === 1}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((page, index) => (
          typeof page === 'number' ? (
            <Button
              key={index}
              variant={currentPage === page ? "default" : "outline"}
              size="sm"
              onClick={() => onPageChange(page)}
              className="hidden sm:inline-flex min-w-[32px]"
            >
              {page}
            </Button>
          ) : (
            <span key={index} className="px-2">
              {page}
            </span>
          )
        ))}

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(totalPages)}
          disabled={currentPage === totalPages}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};

export default Pagination;
--- End of Content for Pagination.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\StatusBadge.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Badge } from "@/components/ui/badge";
import {
  Circle,
  CheckCircle,
  XCircle,
  Clock,
  AlertTriangle,
} from "lucide-react";
import { MatchSuggestionStatus, VerificationStatus } from "@prisma/client";

type StatusType = "suggestion" | "verification" | "profile";
type StatusSize = "sm" | "md" | "lg";

interface StatusConfig {
  label: string;
  color: "destructive" | "outline" | "secondary" | "success" | "warning";
  icon:
    | typeof Circle
    | typeof CheckCircle
    | typeof XCircle
    | typeof Clock
    | typeof AlertTriangle;
}

interface StatusBadgeProps {
  type: StatusType;
  status: string;
  size?: StatusSize;
}

const suggestionStatuses: Record<MatchSuggestionStatus, StatusConfig> = {
  DRAFT: {
    label: "טיוטה",
    color: "secondary",
    icon: Circle,
  },
  PENDING_FIRST_PARTY: {
    label: "ממתין לצד ראשון",
    color: "warning",
    icon: Clock,
  },
  FIRST_PARTY_APPROVED: {
    label: 'אושר ע"י צד ראשון',
    color: "success",
    icon: CheckCircle,
  },
  FIRST_PARTY_DECLINED: {
    label: 'נדחה ע"י צד ראשון',
    color: "destructive",
    icon: XCircle,
  },
  PENDING_SECOND_PARTY: {
    label: "ממתין לצד שני",
    color: "warning",
    icon: Clock,
  },
  SECOND_PARTY_APPROVED: {
    label: 'אושר ע"י צד שני',
    color: "success",
    icon: CheckCircle,
  },
  SECOND_PARTY_DECLINED: {
    label: 'נדחה ע"י צד שני',
    color: "destructive",
    icon: XCircle,
  },
  AWAITING_MATCHMAKER_APPROVAL: {
    label: "ממתין לאישור שדכן",
    color: "warning",
    icon: Clock,
  },
  CONTACT_DETAILS_SHARED: {
    label: "פרטי קשר שותפו",
    color: "success",
    icon: CheckCircle,
  },
  AWAITING_FIRST_DATE_FEEDBACK: {
    label: "ממתין למשוב פגישה ראשונה",
    color: "warning",
    icon: Clock,
  },
  THINKING_AFTER_DATE: {
    label: "בשיקול לאחר פגישה",
    color: "warning",
    icon: Clock,
  },
  PROCEEDING_TO_SECOND_DATE: {
    label: "ממשיכים לפגישה שנייה",
    color: "success",
    icon: CheckCircle,
  },
  ENDED_AFTER_FIRST_DATE: {
    label: "הסתיים לאחר פגישה ראשונה",
    color: "destructive",
    icon: XCircle,
  },
  MEETING_PENDING: {
    label: "פגישה בתכנון",
    color: "warning",
    icon: Clock,
  },
  MEETING_SCHEDULED: {
    label: "פגישה נקבעה",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_APPROVED: {
    label: "השידוך אושר",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_DECLINED: {
    label: "השידוך נדחה",
    color: "destructive",
    icon: XCircle,
  },
  DATING: {
    label: "בתהליך היכרות",
    color: "secondary",
    icon: Circle,
  },
  ENGAGED: {
    label: "מאורסים",
    color: "success",
    icon: CheckCircle,
  },
  MARRIED: {
    label: "נישאו",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  CLOSED: {
    label: "סגור",
    color: "destructive",
    icon: XCircle,
  },
  CANCELLED: {
    label: "בוטל",
    color: "destructive",
    icon: XCircle,
  },
};

const verificationStatuses: Record<VerificationStatus, StatusConfig> = {
  PENDING: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  COMPLETED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  FAILED: {
    label: "נכשל",
    color: "destructive",
    icon: XCircle,
  },
};

const profileStatuses: Record<string, StatusConfig> = {
  INCOMPLETE: {
    label: "לא הושלם",
    color: "warning",
    icon: AlertTriangle,
  },
  PENDING_VERIFICATION: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  VERIFIED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  BLOCKED: {
    label: "חסום",
    color: "destructive",
    icon: XCircle,
  },
};

const defaultStatus: StatusConfig = {
  label: "לא ידוע",
  color: "secondary",
  icon: Circle,
};

const getStatusConfig = (type: StatusType, status: string): StatusConfig => {
  switch (type) {
    case "suggestion":
      return (
        suggestionStatuses[status as MatchSuggestionStatus] || defaultStatus
      );
    case "verification":
      return (
        verificationStatuses[status as VerificationStatus] || defaultStatus
      );
    case "profile":
      return profileStatuses[status] || defaultStatus;
    default:
      return defaultStatus;
  }
};

const StatusBadge: React.FC<StatusBadgeProps> = ({
  type,
  status,
  size = "md",
}) => {
  const config = getStatusConfig(type, status);
  const Icon = config.icon;

  const sizeClasses = {
    sm: "text-xs px-2 py-0.5",
    md: "text-sm px-2.5 py-1",
    lg: "text-base px-3 py-1.5",
  };

  return (
    <Badge
      variant={config.color}
      className={`flex items-center gap-1.5 ${sizeClasses[size]}`}
    >
      <Icon className={size === "sm" ? "w-3 h-3" : "w-4 h-4"} />
      <span>{config.label}</span>
    </Badge>
  );
};

export default StatusBadge;
--- End of Content for StatusBadge.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types\candidates.ts
--------------------------------------------------------------------------------
Content:
// candidates.ts
import { Gender, AvailabilityStatus, UserStatus, UserSource  } from '@prisma/client';
import type { UserProfile, UserImage, QuestionnaireResponse} from '@/types/next-auth';

// Base API Response Type
export interface APIResponse<T> {
  success: boolean;
  clients: T[];
  count: number;
  error?: string;
}

// Base Types
export type CandidateImage = UserImage;

export type CandidateProfile = UserProfile;

export type MobileView = 'split' | 'single' | 'double';

export interface Candidate {
  id: string;
  email: string;
  firstName: string;
  createdAt: Date;
  lastName: string;
  status: UserStatus;
  isVerified: boolean;
  images: CandidateImage[];
  isProfileComplete: boolean;
  source: UserSource; // Add new field
  addedByMatchmakerId?: string | null; // Add new field
  profile: CandidateProfile; // Ensure this uses the updated CandidateProfile
    suggestionStatus?: {
    status: 'BLOCKED' | 'PENDING';
    suggestionId: string;
    withCandidateName: string;
  } | null;

}
export interface CandidatesFilter {
   source?: UserSource;
  gender?: Gender;
  ageRange?: {
    min: number;
    max: number;
  };
  heightRange?: {
    min: number;
    max: number;
  };
  cities?: string[];
  religiousLevel?: string;
  occupations?: string[];
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
  searchQuery?: string;
  savedFilterId?: string;
  separateFiltering?: boolean;
  
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  
  maleFilters?: Partial<CandidatesFilter>;
  femaleFilters?: Partial<CandidatesFilter>;
  userStatus?: UserStatus;
}

// ViewMode and Action Types - אלה נשארים כמו שהם
export type ViewMode = 'grid' | 'list';
export type CardSize = 'sm' | 'md' | 'lg';
export type CandidateAction = 'suggest' | 'invite' | 'contact' | 'favorite' | 'view' | 'edit';

// Profile Card Types
export interface ProfileCardData {
  profile: CandidateProfile;
  images: CandidateImage[];
  questionnaire?: QuestionnaireResponse;
}

/**
 * ממפה את אובייקט המועמד מהשרת למבנה הנדרש עבור ProfileCard
 */
export const mapCandidateToProfileCard = (candidate: Candidate): ProfileCardData => {
  return {
    profile: candidate.profile,
    images: candidate.images,
    questionnaire: undefined // יש להוסיף לוגיקה לטעינת השאלון בנפרד
  };
};

/**
 * מפריד מועמדים לפי מגדר
 */
export const separateCandidatesByGender = (candidates: Candidate[]) => {
  return {
    maleCandidates: candidates.filter(c => c.profile.gender === 'MALE'),
    femaleCandidates: candidates.filter(c => c.profile.gender === 'FEMALE')
  };
};

/**
 * בודק האם הפרופיל מלא
 */
export const isProfileComplete = (profile: CandidateProfile): boolean => {
  const requiredFields: Array<keyof CandidateProfile> = [
    'birthDate',
    'city',
    'religiousLevel',
    'about',
    'occupation',
    'education'
  ];

  return requiredFields.every(field => Boolean(profile[field]));
};

const candidateUtils = {
  mapCandidateToProfileCard,
  separateCandidatesByGender,
  isProfileComplete
};

export default candidateUtils;
--- End of Content for candidates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types\filters.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/types/filters.ts

import { Gender, AvailabilityStatus, UserStatus, UserSource  } from '@prisma/client';

// הגדרת טווח ערכים מספריים
export interface RangeFilter {
  min: number;
  max: number;
}

// הגדרת פילטר שמור
export interface SavedFilter {
  id: string;
  name: string;
  filters: FilterState;
  isDefault?: boolean;
  createdAt: Date;
}

export interface FilterState {
  // הוספת מצב תצוגה נפרדת
  separateFiltering: boolean;
    source?: UserSource | undefined;
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;

  // פילטרים נפרדים לגברים
  maleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;
  
  // פילטרים נפרדים לנשים
  femaleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;

  searchQuery?: string;
  savedFilterId?: string;
  gender?: Gender | undefined;
  ageRange?: RangeFilter;
  heightRange?: RangeFilter;
  cities?: string[];
  occupations?: string[];
  religiousLevel?: string;
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  userStatus?: UserStatus;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
}

// הגדרת אפשרות פילטר
export interface FilterOption {
  key: keyof (FilterState & { education: string });
  value: Gender | AvailabilityStatus | UserStatus | RangeFilter | string[] | string | number | boolean | undefined;
  label: string;
  category?: string;
}

// הגדרת קטגוריית פילטר
export interface FilterCategory {
  id: string;
  label: string;
  filters: Array<keyof (FilterState & { education: string })>;
}

// הגדרת פרופ לקומפוננטת הפילטרים
export interface FilterProps {
  filters: FilterState;
  onFiltersChange: (filters: FilterState) => void;
  onReset?: () => void;
  className?: string;
}

// הגדרת אפשרויות הפילטר
export interface FilterOptions {
  ages: RangeFilter;
  heights: RangeFilter;
  cities: string[];
  religiousLevels: string[];
  educationLevels: string[];
  occupations: string[];
  maritalStatuses: string[];
  availabilityStatuses: AvailabilityStatus[];
}

// הגדרת מצב הממשק של הפילטרים
export interface FilterUIState {
  isOpen: boolean;
  activeCategory?: string;
  showSaveDialog: boolean;
  presetName: string;
}

// הגדרה של אירועי שינוי בפילטרים
export type FilterChangeHandler = (filters: FilterState) => void;

// הגדרת אירועי שמירת פילטר
export interface SaveFilterHandler {
  (name: string, filters: FilterState): Promise<SavedFilter>;
}

// הגדרת אירועי טעינת פילטר
export interface LoadFilterHandler {
  (id: string): void;
}

// הגדרת הגדרות הפילטרים
export interface FilterSettings {
  localStorageKey?: string;
  defaultFilters?: Partial<FilterState>;
  onFilterChange?: FilterChangeHandler;
}

// הגדרת תוצאות הפילטר
export interface FilterResults {
  totalResults: number;
  filteredResults: number;
  categories: Record<string, number>;
}

// קונסטנטות של הפילטרים
export const DEFAULT_FILTER_STATE: FilterState = {
  separateFiltering: false,
  maleFilters: {},
  femaleFilters: {},
  maleSearchQuery: '',
  femaleSearchQuery: '',
  gender: undefined,
  ageRange: { min: 18, max: 99 },
  heightRange: { min: 140, max: 210 },
  cities: [],
  occupations: [],
  religiousLevel: undefined,
  educationLevel: undefined,
  maritalStatus: undefined,
  availabilityStatus: undefined,
    source: undefined,
  userStatus: undefined,
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined,
  isProfileComplete: undefined,
  searchQuery: '',
  savedFilterId: undefined
};

// קטגוריות פילטרים מוגדרות מראש
export const FILTER_CATEGORIES: FilterCategory[] = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'educationLevel', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availabilityStatus', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];

// טיפוסי מיון
export type SortDirection = 'asc' | 'desc';

export interface SortOption {
  field: keyof FilterState;
  direction: SortDirection;
  label: string;
}

// הגדרות קיבוץ
export interface GroupOption {
  field: keyof FilterState;
  label: string;
}

export const filterConstants = {
  DEFAULT_FILTER_STATE,
  FILTER_CATEGORIES
};

export default filterConstants;
--- End of Content for filters.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\EditSuggestionForm.tsx
--------------------------------------------------------------------------------
Content:
// קוד מתוקן ב-EditSuggestionForm.tsx עם פתרון לבעיית הטיפוסים

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { DatePicker } from "@/components/ui/date-picker";
import type { Suggestion } from "@/types/suggestions";

interface EditSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSave: (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      status?: MatchSuggestionStatus;
      statusNotes?: string;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => Promise<void>;
}

const EditSuggestionForm: React.FC<EditSuggestionFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSave,
}) => {
  const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
  // נשתמש בסוג נפרד לתיעוד אם נבחר סטטוס חדש או לא
  const [selectedStatus, setSelectedStatus] = useState<string | null>(null);
  // נשתמש במשתנה נפרד שיחזיק את הסטטוס האמיתי שיישלח לשרת
  const [statusToUpdate, setStatusToUpdate] =
    useState<MatchSuggestionStatus | null>(null);
  const [statusNotes, setStatusNotes] = useState("");
  const [matchingReason, setMatchingReason] = useState("");
  const [firstPartyNotes, setFirstPartyNotes] = useState("");
  const [secondPartyNotes, setSecondPartyNotes] = useState("");
  const [internalNotes, setInternalNotes] = useState("");
  const [decisionDeadline, setDecisionDeadline] = useState<Date | undefined>(
    undefined
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showStatusChange, setShowStatusChange] = useState(false);

  // עדכון הטופס כאשר נתוני ההצעה משתנים
  useEffect(() => {
    if (suggestion) {
      // עדכון כל השדות עם הנתונים הקיימים בהצעה
      setPriority(suggestion.priority as Priority);
      setSelectedStatus(null);
      setStatusToUpdate(null);
      setStatusNotes("");
      setMatchingReason(suggestion.matchingReason || "");
      setFirstPartyNotes(suggestion.firstPartyNotes || "");
      setSecondPartyNotes(suggestion.secondPartyNotes || "");
      setInternalNotes(suggestion.internalNotes || "");

      // טיפול נכון בתאריך
      if (suggestion.decisionDeadline) {
        // וידוא שמדובר בתאריך תקין
        const deadlineDate = new Date(suggestion.decisionDeadline);
        if (!isNaN(deadlineDate.getTime())) {
          setDecisionDeadline(deadlineDate);
        }
      } else {
        setDecisionDeadline(undefined);
      }
    }
  }, [suggestion]);

  const handleSubmit = async () => {
    if (!suggestion) return;

    try {
      setIsSubmitting(true);

      // מבנה העדכון עם אפשרות לסטטוס
      const updateData: {
        priority: Priority;
        status?: MatchSuggestionStatus;
        statusNotes?: string;
        matchingReason: string;
        firstPartyNotes: string;
        secondPartyNotes: string;
        internalNotes: string;
        decisionDeadline: string | null;
      } = {
        priority,
        matchingReason,
        firstPartyNotes,
        secondPartyNotes,
        internalNotes,
        decisionDeadline: decisionDeadline
          ? decisionDeadline.toISOString()
          : null,
      };

      // הוספת סטטוס רק אם נבחר סטטוס חדש לעדכון
      if (statusToUpdate) {
        updateData.status = statusToUpdate;
        updateData.statusNotes =
          statusNotes || `סטטוס שונה ל-${getStatusLabel(statusToUpdate)}`;
      }

      // עדכון הקומפוננטה ההורה
      await onSave({
        suggestionId: suggestion.id,
        updates: {
          priority,
          status: statusToUpdate || undefined,
          statusNotes: statusToUpdate ? statusNotes : undefined,
          matchingReason,
          firstPartyNotes,
          secondPartyNotes,
          internalNotes,
          decisionDeadline,
        },
      });

      toast.success("פרטי ההצעה עודכנו בהצלחה");
      onClose();
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    } finally {
      setIsSubmitting(false);
    }
  };

  // פונקציה להחזרת התווית המתאימה לסטטוס
  const getStatusLabel = (statusValue: string): string => {
    const statusLabels: Record<string, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
      FIRST_PARTY_APPROVED: "צד א׳ אישר",
      FIRST_PARTY_DECLINED: "צד א׳ דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
      SECOND_PARTY_APPROVED: "צד ב׳ אישר",
      SECOND_PARTY_DECLINED: "צד ב׳ דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
      PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
      ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
      MEETING_PENDING: "ממתין לקביעת פגישה",
      MEETING_SCHEDULED: "פגישה נקבעה",
      MATCH_APPROVED: "ההצעה אושרה",
      MATCH_DECLINED: "ההצעה נדחתה",
      DATING: "בתהליך היכרות",
      ENGAGED: "מאורסים",
      MARRIED: "נישאו",
      EXPIRED: "פג תוקף",
      CLOSED: "ההצעה נסגרה",
      CANCELLED: "ההצעה בוטלה",
    };

    return statusLabels[statusValue] || statusValue;
  };

  // הסטטוסים שניתן לשנות אליהם - יכול להשתנות לפי הסטטוס הנוכחי
  const getAvailableStatuses = (): MatchSuggestionStatus[] => {
    if (!suggestion) return [];

    // סטטוסים מרכזיים שתמיד זמינים
    const commonStatuses: MatchSuggestionStatus[] = [
      "PENDING_FIRST_PARTY",
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "PENDING_SECOND_PARTY",
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "CONTACT_DETAILS_SHARED",
      "DATING",
      "EXPIRED",
      "CLOSED",
      "CANCELLED",
    ];

    return commonStatuses;
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>עריכת הצעת שידוך</DialogTitle>
          <DialogDescription>
            עריכת הפרטים עבור ההצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Status and Priority Section */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Priority */}
            <div className="space-y-2">
              <Label>עדיפות ההצעה</Label>
              <Select
                value={priority}
                onValueChange={(value) => setPriority(value as Priority)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י עדיפות" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
                  <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                  <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                  <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Status */}
            <div className="space-y-2">
              <Label>שינוי סטטוס (אופציונלי)</Label>
              <Select
                value={selectedStatus || undefined}
                onValueChange={(value) => {
                  setSelectedStatus(value);

                  // אם נבחר "ללא שינוי" או ערך ריק
                  if (value === "NO_CHANGE" || !value) {
                    setStatusToUpdate(null);
                    setShowStatusChange(false);
                  } else {
                    // אחרת, מעדכנים את הסטטוס שיישלח לשרת
                    setStatusToUpdate(value as MatchSuggestionStatus);
                    setShowStatusChange(true);
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י סטטוס חדש (אופציונלי)" />
                </SelectTrigger>
                <SelectContent>
                  {/* משתמשים בערך חוקי מהמערכת */}
                  <SelectItem value="NO_CHANGE">ללא שינוי</SelectItem>
                  {getAvailableStatuses().map((availableStatus) => (
                    <SelectItem key={availableStatus} value={availableStatus}>
                      {getStatusLabel(availableStatus)}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Status Notes - מוצג רק אם נבחר סטטוס לעדכון */}
          {showStatusChange && statusToUpdate && (
            <div className="space-y-2 bg-slate-50 p-4 rounded-md border">
              <Label>הערות לשינוי הסטטוס</Label>
              <Textarea
                value={statusNotes}
                onChange={(e) => setStatusNotes(e.target.value)}
                placeholder="הערות אופציונליות לשינוי הסטטוס..."
                className="h-20"
              />
              <div className="text-xs text-gray-500 mt-1">
                הערות אלו יוצגו בהיסטוריית השינויים של ההצעה
              </div>
            </div>
          )}

          {/* Decision Deadline */}
          <div className="space-y-2">
            <Label>מועד החלטה אחרון</Label>
            <DatePicker
              value={{ from: decisionDeadline, to: undefined }}
              onChange={({ from }) => setDecisionDeadline(from)}
            />
          </div>

          {/* Matching Reason */}
          <div className="space-y-2">
            <Label>סיבת ההתאמה</Label>
            <Textarea
              value={matchingReason}
              onChange={(e) => setMatchingReason(e.target.value)}
              placeholder="פרט/י מדוע יש התאמה בין המועמדים..."
              className="h-24"
            />
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label>הערות לצד א׳ ({suggestion.firstParty.firstName})</Label>
              <Textarea
                value={firstPartyNotes}
                onChange={(e) => setFirstPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד א׳..."
                className="h-24"
              />
            </div>

            <div className="space-y-2">
              <Label>הערות לצד ב׳ ({suggestion.secondParty.firstName})</Label>
              <Textarea
                value={secondPartyNotes}
                onChange={(e) => setSecondPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד ב׳..."
                className="h-24"
              />
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-2">
            <Label>הערות פנימיות</Label>
            <Textarea
              value={internalNotes}
              onChange={(e) => setInternalNotes(e.target.value)}
              placeholder="הערות פנימיות לשימוש השדכנים בלבד..."
              className="h-24"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? "שומר..." : "שמור שינויים"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default EditSuggestionForm;
--- End of Content for EditSuggestionForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\MessageForm.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { MessageCircle, Send, AlertCircle } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";

interface MessageFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSend: (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => Promise<void>;
}

const MessageForm: React.FC<MessageFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSend,
}) => {
  const [partyType, setPartyType] = useState<"first" | "second" | "both">(
    "both"
  );
  const [messageType, setMessageType] = useState<
    "message" | "reminder" | "update"
  >("message");
  const [messageContent, setMessageContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async () => {
    if (!suggestion || !messageContent.trim()) return;

    try {
      setIsSubmitting(true);

      // Notify the parent component
      await onSend({
        suggestionId: suggestion.id,
        partyType,
        messageType,
        messageContent,
      });

      toast.success(
        `ההודעה נשלחה ${
          partyType === "first"
            ? `ל${suggestion.firstParty.firstName}`
            : partyType === "second"
            ? `ל${suggestion.secondParty.firstName}`
            : "לשני הצדדים"
        }`
      );
      onClose();
    } catch (error) {
      toast.error("שגיאה בשליחת ההודעה");
      console.error("Error sending message:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getMessagePlaceholder = () => {
    switch (messageType) {
      case "reminder":
        return "הודעת תזכורת למועמד/ת לגבי ההצעה...";
      case "update":
        return "עדכון לגבי סטטוס ההצעה או מידע חדש...";
      default:
        return "הודעה אישית למועמד/ת...";
    }
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>שליחת הודעה</DialogTitle>
          <DialogDescription>
            שליחת הודעה הקשורה להצעת השידוך בין{" "}
            {suggestion.firstParty.firstName} {suggestion.firstParty.lastName} ל
            {suggestion.secondParty.firstName} {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Recipient Selection */}
          <div className="space-y-2">
            <Label>שלח אל</Label>
            <Select
              value={partyType}
              onValueChange={(value) =>
                setPartyType(value as "first" | "second" | "both")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר נמען" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="first">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} (צד א׳)
                </SelectItem>
                <SelectItem value="second">
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName} (צד ב׳)
                </SelectItem>
                <SelectItem value="both">שני הצדדים</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Type */}
          <div className="space-y-2">
            <Label>סוג ההודעה</Label>
            <Select
              value={messageType}
              onValueChange={(value) =>
                setMessageType(value as "message" | "reminder" | "update")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר סוג הודעה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="message">
                  <div className="flex items-center">
                    <MessageCircle className="w-4 h-4 ml-2" />
                    הודעה רגילה
                  </div>
                </SelectItem>
                <SelectItem value="reminder">
                  <div className="flex items-center">
                    <AlertCircle className="w-4 h-4 ml-2" />
                    תזכורת
                  </div>
                </SelectItem>
                <SelectItem value="update">
                  <div className="flex items-center">
                    <Send className="w-4 h-4 ml-2" />
                    עדכון סטטוס
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Content */}
          <div className="space-y-2">
            <Label>תוכן ההודעה</Label>
            <Textarea
              value={messageContent}
              onChange={(e) => setMessageContent(e.target.value)}
              placeholder={getMessagePlaceholder()}
              className="h-36"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={isSubmitting || !messageContent.trim()}
            className="gap-2"
          >
            <Send className="w-4 h-4" />
            {isSubmitting ? "שולח..." : "שלח הודעה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default MessageForm;
--- End of Content for MessageForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions
# Generated on: 2025-07-10 05:49:08
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\EditSuggestionForm.tsx
--------------------------------------------------------------------------------
Content:
// קוד מתוקן ב-EditSuggestionForm.tsx עם פתרון לבעיית הטיפוסים

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { DatePicker } from "@/components/ui/date-picker";
import type { Suggestion } from "@/types/suggestions";

interface EditSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSave: (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      status?: MatchSuggestionStatus;
      statusNotes?: string;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => Promise<void>;
}

const EditSuggestionForm: React.FC<EditSuggestionFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSave,
}) => {
  const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
  // נשתמש בסוג נפרד לתיעוד אם נבחר סטטוס חדש או לא
  const [selectedStatus, setSelectedStatus] = useState<string | null>(null);
  // נשתמש במשתנה נפרד שיחזיק את הסטטוס האמיתי שיישלח לשרת
  const [statusToUpdate, setStatusToUpdate] =
    useState<MatchSuggestionStatus | null>(null);
  const [statusNotes, setStatusNotes] = useState("");
  const [matchingReason, setMatchingReason] = useState("");
  const [firstPartyNotes, setFirstPartyNotes] = useState("");
  const [secondPartyNotes, setSecondPartyNotes] = useState("");
  const [internalNotes, setInternalNotes] = useState("");
  const [decisionDeadline, setDecisionDeadline] = useState<Date | undefined>(
    undefined
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showStatusChange, setShowStatusChange] = useState(false);

  // עדכון הטופס כאשר נתוני ההצעה משתנים
  useEffect(() => {
    if (suggestion) {
      // עדכון כל השדות עם הנתונים הקיימים בהצעה
      setPriority(suggestion.priority as Priority);
      setSelectedStatus(null);
      setStatusToUpdate(null);
      setStatusNotes("");
      setMatchingReason(suggestion.matchingReason || "");
      setFirstPartyNotes(suggestion.firstPartyNotes || "");
      setSecondPartyNotes(suggestion.secondPartyNotes || "");
      setInternalNotes(suggestion.internalNotes || "");

      // טיפול נכון בתאריך
      if (suggestion.decisionDeadline) {
        // וידוא שמדובר בתאריך תקין
        const deadlineDate = new Date(suggestion.decisionDeadline);
        if (!isNaN(deadlineDate.getTime())) {
          setDecisionDeadline(deadlineDate);
        }
      } else {
        setDecisionDeadline(undefined);
      }
    }
  }, [suggestion]);

  const handleSubmit = async () => {
    if (!suggestion) return;

    try {
      setIsSubmitting(true);

      // מבנה העדכון עם אפשרות לסטטוס
      const updateData: {
        priority: Priority;
        status?: MatchSuggestionStatus;
        statusNotes?: string;
        matchingReason: string;
        firstPartyNotes: string;
        secondPartyNotes: string;
        internalNotes: string;
        decisionDeadline: string | null;
      } = {
        priority,
        matchingReason,
        firstPartyNotes,
        secondPartyNotes,
        internalNotes,
        decisionDeadline: decisionDeadline
          ? decisionDeadline.toISOString()
          : null,
      };

      // הוספת סטטוס רק אם נבחר סטטוס חדש לעדכון
      if (statusToUpdate) {
        updateData.status = statusToUpdate;
        updateData.statusNotes =
          statusNotes || `סטטוס שונה ל-${getStatusLabel(statusToUpdate)}`;
      }

      // עדכון הקומפוננטה ההורה
      await onSave({
        suggestionId: suggestion.id,
        updates: {
          priority,
          status: statusToUpdate || undefined,
          statusNotes: statusToUpdate ? statusNotes : undefined,
          matchingReason,
          firstPartyNotes,
          secondPartyNotes,
          internalNotes,
          decisionDeadline,
        },
      });

      toast.success("פרטי ההצעה עודכנו בהצלחה");
      onClose();
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    } finally {
      setIsSubmitting(false);
    }
  };

  // פונקציה להחזרת התווית המתאימה לסטטוס
  const getStatusLabel = (statusValue: string): string => {
    const statusLabels: Record<string, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
      FIRST_PARTY_APPROVED: "צד א׳ אישר",
      FIRST_PARTY_DECLINED: "צד א׳ דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
      SECOND_PARTY_APPROVED: "צד ב׳ אישר",
      SECOND_PARTY_DECLINED: "צד ב׳ דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
      PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
      ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
      MEETING_PENDING: "ממתין לקביעת פגישה",
      MEETING_SCHEDULED: "פגישה נקבעה",
      MATCH_APPROVED: "ההצעה אושרה",
      MATCH_DECLINED: "ההצעה נדחתה",
      DATING: "בתהליך היכרות",
      ENGAGED: "מאורסים",
      MARRIED: "נישאו",
      EXPIRED: "פג תוקף",
      CLOSED: "ההצעה נסגרה",
      CANCELLED: "ההצעה בוטלה",
    };

    return statusLabels[statusValue] || statusValue;
  };

  // הסטטוסים שניתן לשנות אליהם - יכול להשתנות לפי הסטטוס הנוכחי
  const getAvailableStatuses = (): MatchSuggestionStatus[] => {
    if (!suggestion) return [];

    // סטטוסים מרכזיים שתמיד זמינים
    const commonStatuses: MatchSuggestionStatus[] = [
      "PENDING_FIRST_PARTY",
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "PENDING_SECOND_PARTY",
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "CONTACT_DETAILS_SHARED",
      "DATING",
      "EXPIRED",
      "CLOSED",
      "CANCELLED",
    ];

    return commonStatuses;
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>עריכת הצעת שידוך</DialogTitle>
          <DialogDescription>
            עריכת הפרטים עבור ההצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Status and Priority Section */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Priority */}
            <div className="space-y-2">
              <Label>עדיפות ההצעה</Label>
              <Select
                value={priority}
                onValueChange={(value) => setPriority(value as Priority)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י עדיפות" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
                  <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                  <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                  <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Status */}
            <div className="space-y-2">
              <Label>שינוי סטטוס (אופציונלי)</Label>
              <Select
                value={selectedStatus || undefined}
                onValueChange={(value) => {
                  setSelectedStatus(value);

                  // אם נבחר "ללא שינוי" או ערך ריק
                  if (value === "NO_CHANGE" || !value) {
                    setStatusToUpdate(null);
                    setShowStatusChange(false);
                  } else {
                    // אחרת, מעדכנים את הסטטוס שיישלח לשרת
                    setStatusToUpdate(value as MatchSuggestionStatus);
                    setShowStatusChange(true);
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י סטטוס חדש (אופציונלי)" />
                </SelectTrigger>
                <SelectContent>
                  {/* משתמשים בערך חוקי מהמערכת */}
                  <SelectItem value="NO_CHANGE">ללא שינוי</SelectItem>
                  {getAvailableStatuses().map((availableStatus) => (
                    <SelectItem key={availableStatus} value={availableStatus}>
                      {getStatusLabel(availableStatus)}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Status Notes - מוצג רק אם נבחר סטטוס לעדכון */}
          {showStatusChange && statusToUpdate && (
            <div className="space-y-2 bg-slate-50 p-4 rounded-md border">
              <Label>הערות לשינוי הסטטוס</Label>
              <Textarea
                value={statusNotes}
                onChange={(e) => setStatusNotes(e.target.value)}
                placeholder="הערות אופציונליות לשינוי הסטטוס..."
                className="h-20"
              />
              <div className="text-xs text-gray-500 mt-1">
                הערות אלו יוצגו בהיסטוריית השינויים של ההצעה
              </div>
            </div>
          )}

          {/* Decision Deadline */}
          <div className="space-y-2">
            <Label>מועד החלטה אחרון</Label>
            <DatePicker
              value={{ from: decisionDeadline, to: undefined }}
              onChange={({ from }) => setDecisionDeadline(from)}
            />
          </div>

          {/* Matching Reason */}
          <div className="space-y-2">
            <Label>סיבת ההתאמה</Label>
            <Textarea
              value={matchingReason}
              onChange={(e) => setMatchingReason(e.target.value)}
              placeholder="פרט/י מדוע יש התאמה בין המועמדים..."
              className="h-24"
            />
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label>הערות לצד א׳ ({suggestion.firstParty.firstName})</Label>
              <Textarea
                value={firstPartyNotes}
                onChange={(e) => setFirstPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד א׳..."
                className="h-24"
              />
            </div>

            <div className="space-y-2">
              <Label>הערות לצד ב׳ ({suggestion.secondParty.firstName})</Label>
              <Textarea
                value={secondPartyNotes}
                onChange={(e) => setSecondPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד ב׳..."
                className="h-24"
              />
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-2">
            <Label>הערות פנימיות</Label>
            <Textarea
              value={internalNotes}
              onChange={(e) => setInternalNotes(e.target.value)}
              placeholder="הערות פנימיות לשימוש השדכנים בלבד..."
              className="h-24"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? "שומר..." : "שמור שינויים"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default EditSuggestionForm;
--- End of Content for EditSuggestionForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\MessageForm.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { MessageCircle, Send, AlertCircle } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";

interface MessageFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSend: (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => Promise<void>;
}

const MessageForm: React.FC<MessageFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSend,
}) => {
  const [partyType, setPartyType] = useState<"first" | "second" | "both">(
    "both"
  );
  const [messageType, setMessageType] = useState<
    "message" | "reminder" | "update"
  >("message");
  const [messageContent, setMessageContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async () => {
    if (!suggestion || !messageContent.trim()) return;

    try {
      setIsSubmitting(true);

      // Notify the parent component
      await onSend({
        suggestionId: suggestion.id,
        partyType,
        messageType,
        messageContent,
      });

      toast.success(
        `ההודעה נשלחה ${
          partyType === "first"
            ? `ל${suggestion.firstParty.firstName}`
            : partyType === "second"
            ? `ל${suggestion.secondParty.firstName}`
            : "לשני הצדדים"
        }`
      );
      onClose();
    } catch (error) {
      toast.error("שגיאה בשליחת ההודעה");
      console.error("Error sending message:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getMessagePlaceholder = () => {
    switch (messageType) {
      case "reminder":
        return "הודעת תזכורת למועמד/ת לגבי ההצעה...";
      case "update":
        return "עדכון לגבי סטטוס ההצעה או מידע חדש...";
      default:
        return "הודעה אישית למועמד/ת...";
    }
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>שליחת הודעה</DialogTitle>
          <DialogDescription>
            שליחת הודעה הקשורה להצעת השידוך בין{" "}
            {suggestion.firstParty.firstName} {suggestion.firstParty.lastName} ל
            {suggestion.secondParty.firstName} {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Recipient Selection */}
          <div className="space-y-2">
            <Label>שלח אל</Label>
            <Select
              value={partyType}
              onValueChange={(value) =>
                setPartyType(value as "first" | "second" | "both")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר נמען" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="first">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} (צד א׳)
                </SelectItem>
                <SelectItem value="second">
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName} (צד ב׳)
                </SelectItem>
                <SelectItem value="both">שני הצדדים</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Type */}
          <div className="space-y-2">
            <Label>סוג ההודעה</Label>
            <Select
              value={messageType}
              onValueChange={(value) =>
                setMessageType(value as "message" | "reminder" | "update")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר סוג הודעה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="message">
                  <div className="flex items-center">
                    <MessageCircle className="w-4 h-4 ml-2" />
                    הודעה רגילה
                  </div>
                </SelectItem>
                <SelectItem value="reminder">
                  <div className="flex items-center">
                    <AlertCircle className="w-4 h-4 ml-2" />
                    תזכורת
                  </div>
                </SelectItem>
                <SelectItem value="update">
                  <div className="flex items-center">
                    <Send className="w-4 h-4 ml-2" />
                    עדכון סטטוס
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Content */}
          <div className="space-y-2">
            <Label>תוכן ההודעה</Label>
            <Textarea
              value={messageContent}
              onChange={(e) => setMessageContent(e.target.value)}
              placeholder={getMessagePlaceholder()}
              className="h-36"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={isSubmitting || !messageContent.trim()}
            className="gap-2"
          >
            <Send className="w-4 h-4" />
            {isSubmitting ? "שולח..." : "שלח הודעה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default MessageForm;
--- End of Content for MessageForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\CandidateSelector.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/CandidateSelector.tsx

import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search, AlertTriangle, Clock } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../../new/types/candidates";
import { toast } from "sonner"; // Make sure to import toast

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      // Check if the candidate is blocked by an active suggestion
      if (candidate.suggestionStatus?.status === 'BLOCKED') {
        toast.error("לא ניתן לבחור מועמד זה", {
          description: `${candidate.firstName} ${candidate.lastName} כבר נמצא/ת בהצעה פעילה עם ${candidate.suggestionStatus.withCandidateName}.`,
        });
        return; // Prevent selection
      }
      
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={setInputValue}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => {
                    const isBlocked = candidate.suggestionStatus?.status === 'BLOCKED';
                    return (
                      <div
                        key={candidate.id}
                        onClick={() => handleSelect(candidate)}
                        className={`flex items-start gap-3 p-2 text-right ${
                          isBlocked 
                            ? 'cursor-not-allowed opacity-60' 
                            : 'cursor-pointer hover:bg-accent/50'
                        } ${index === activeIndex ? "bg-accent" : ""}`}
                        role="option"
                        id={`candidate-${candidate.id}`}
                        aria-selected={index === activeIndex}
                        onMouseEnter={() => setActiveIndex(index)}
                      >
                        <div className="flex-1">
                          <div className="font-medium">
                            {formatCandidateDisplay(candidate)}
                          </div>
                          <div className="text-sm text-gray-500">
                            {candidate.profile.religiousLevel} | {candidate.profile.occupation}
                          </div>
                          {candidate.suggestionStatus?.status === 'BLOCKED' && (
                            <Badge variant="destructive" className="mt-2 font-normal">
                              <AlertTriangle className="w-3.5 h-3.5 ml-1.5" />
                              בהצעה פעילה עם: {candidate.suggestionStatus.withCandidateName}
                            </Badge>
                          )}
                          {candidate.suggestionStatus?.status === 'PENDING' && (
                            <Badge variant="outline" className="mt-2 font-normal text-amber-800 bg-amber-50 border-amber-200">
                              <Clock className="w-3.5 h-3.5 ml-1.5" />
                              הצעה ממתינה עם: {candidate.suggestionStatus.withCandidateName}
                            </Badge>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => { /* Implement view profile handler */ }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;
--- End of Content for CandidateSelector.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\MatchPreview.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../../new/types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;
--- End of Content for MatchPreview.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\SuggestionDetails.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/SuggestionDetails.tsx

"use client";
import React, { useState } from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2, Sparkles, AlertTriangle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../../new/types/candidates";

interface SuggestionDetailsProps {
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({ firstParty, secondParty }) => {
  const { register, formState: { errors }, setValue, watch } = useFormContext<NewSuggestionFormData>();
  const [isGeneratingRationale, setIsGeneratingRationale] = useState(false);

  const priority = watch("priority", Priority.MEDIUM);

  const handleGenerateRationale = async () => {
    setIsGeneratingRationale(true);
    toast.info("ה-AI מנסח את חבילת הנימוקים...");
    try {
      const response = await fetch('/api/ai/generate-suggestion-rationale', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId1: firstParty.id, userId2: secondParty.id }),
      });

      const data = await response.json();

      if (!response.ok || !data.success || !data.rationales) {
        throw new Error(data.error || "שגיאה בייצור הנימוקים");
      }

      // --- START OF CHANGE: Populate all three fields ---
      const { generalRationale, rationaleForParty1, rationaleForParty2 } = data.rationales;

      setValue('matchingReason', generalRationale, { shouldValidate: true, shouldDirty: true });
      setValue('firstPartyNotes', rationaleForParty1, { shouldValidate: true, shouldDirty: true });
      setValue('secondPartyNotes', rationaleForParty2, { shouldValidate: true, shouldDirty: true });
      // --- END OF CHANGE ---

      toast.success("הנימוקים נוצרו בהצלחה והוזנו בשדות המתאימים.");

    } catch (error) {
      console.error("Failed to generate rationales:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה לא צפויה");
    } finally {
      setIsGeneratingRationale(false);
    }
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardContent className="pt-6 space-y-6">
          <div className="space-y-2">
            <Label htmlFor="priority">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => setValue("priority", value, { shouldValidate: true })}
              defaultValue={priority}
              name="priority"
            >
              <SelectTrigger id="priority"><SelectValue placeholder="בחר/י עדיפות" /></SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>דחופה</SelectItem>
                <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && <p className="text-sm text-red-500 mt-1">{errors.priority.message}</p>}
          </div>

          <div className="space-y-2">
            <div className="flex justify-between items-center">
              <Label htmlFor="matchingReason">סיבת התאמה (כללי, יוצג לצדדים)</Label>
              <Button type="button" variant="ghost" size="sm" onClick={handleGenerateRationale} disabled={isGeneratingRationale}>
                {isGeneratingRationale ? (
                  <Loader2 className="w-4 h-4 ml-2 animate-spin" />
                ) : (
                  <Sparkles className="w-4 h-4 ml-2 text-purple-500" />
                )}
                {isGeneratingRationale ? 'מנסח...' : 'צור נימוקים (AI)'}
              </Button>
            </div>
            <Textarea
              id="matchingReason"
              {...register("matchingReason")}
              placeholder="נימוק כללי המסביר מדוע יש התאמה בין הצדדים..."
              className="min-h-[120px]"
            />
            {errors.matchingReason && <p className="text-sm text-red-500 mt-1">{errors.matchingReason.message}</p>}
             <Alert variant="default" className="mt-2 text-xs p-3 bg-blue-50 border-blue-200">
                <AlertTriangle className="h-4 w-4 text-blue-500" />
                <AlertDescription>
                  לחיצה על כפתור ה-AI תמלא אוטומטית את שדה זה וגם את שדות ההערות האישיות לכל צד.
                </AlertDescription>
            </Alert>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label htmlFor="firstPartyNotes">הערות אישיות לצד א׳ ({firstParty.firstName})</Label>
              <Textarea
                id="firstPartyNotes"
                {...register("firstPartyNotes")}
                placeholder="טקסט אישי המדגיש את היתרונות של צד ב' עבור צד א'..."
                className="min-h-[140px]"
              />
              {errors.firstPartyNotes && <p className="text-sm text-red-500 mt-1">{errors.firstPartyNotes.message}</p>}
            </div>
            <div className="space-y-2">
              <Label htmlFor="secondPartyNotes">הערות אישיות לצד ב׳ ({secondParty.firstName})</Label>
              <Textarea
                id="secondPartyNotes"
                {...register("secondPartyNotes")}
                placeholder="טקסט אישי המדגיש את היתרונות של צד א' עבור צד ב'..."
                className="min-h-[140px]"
              />
              {errors.secondPartyNotes && <p className="text-sm text-red-500 mt-1">{errors.secondPartyNotes.message}</p>}
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="internalNotes">הערות פנימיות (לצוות השדכנים)</Label>
            <Textarea
              id="internalNotes"
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשימוש פנימי בלבד..."
              className="min-h-[100px]"
            />
            {errors.internalNotes && <p className="text-sm text-red-500 mt-1">{errors.internalNotes.message}</p>}
          </div>
          
          <div className="space-y-2">
            <Label>תאריך יעד להחלטה</Label>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value, 10);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, { shouldValidate: true });
              }}
              defaultValue="14"
            >
              <SelectTrigger><SelectValue /></SelectTrigger>
              <SelectContent>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
                <SelectItem value="14">14 ימים</SelectItem>
                <SelectItem value="30">30 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && <p className="text-sm text-red-500 mt-1">{errors.decisionDeadline.message}</p>}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;
--- End of Content for SuggestionDetails.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\index.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/index.tsx

"use client";
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { UserPlus, Sparkles, Loader2, BarChart2, CheckCircle, Users } from "lucide-react";

// Types
import type { Candidate } from "../../new/types/candidates";
import { newSuggestionSchema, type NewSuggestionFormData } from "./schema";

// Components
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";
import { AiMatchAnalysisDialog } from "../../new/dialogs/AiMatchAnalysisDialog";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({ isOpen, onClose, candidates, selectedCandidate, onSubmit }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(null);
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);
  const [showAnalysisDialog, setShowAnalysisDialog] = useState(false);

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      decisionDeadline: new Date(new Date().setDate(new Date().getDate() + 14)), // Default to 2 weeks
    },
  });

  // Reset form and state when dialog opens or selectedCandidate changes
  useEffect(() => {
    if (isOpen) {
      form.reset({
        priority: Priority.MEDIUM,
        status: MatchSuggestionStatus.DRAFT,
        decisionDeadline: new Date(new Date().setDate(new Date().getDate() + 14)),
        firstPartyId: selectedCandidate?.id || "",
        secondPartyId: "",
      });
      setFirstParty(selectedCandidate || null);
      setSecondParty(null);
    }
  }, [isOpen, selectedCandidate, form]);

  const handleCandidateSelect = (type: "first" | "second") => (candidate: Candidate | null) => {
    const setter = type === 'first' ? setFirstParty : setSecondParty;
    const fieldName = type === 'first' ? 'firstPartyId' : 'secondPartyId';
    setter(candidate);
    form.setValue(fieldName, candidate?.id || "", { shouldValidate: true, shouldDirty: true });
  };

  const handleSubmit = form.handleSubmit(async (data) => {
    if (!firstParty || !secondParty) {
      toast.error("יש לבחור את שני הצדדים להצעה.");
      return;
    }

    setIsSubmitting(true);
    try {
      await onSubmit(data);
      toast.success("ההצעה נוצרה בהצלחה!");
      onClose();
    } catch (error) {
      toast.error("שגיאה ביצירת ההצעה: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"));
    } finally {
      setIsSubmitting(false);
    }
  });

  const maleCandidates = candidates.filter(c => c.profile.gender === 'MALE');
  const femaleCandidates = candidates.filter(c => c.profile.gender === 'FEMALE');

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-7xl w-full h-[95vh] flex flex-col p-0" dir="rtl">
          <DialogHeader className="px-6 py-4 border-b flex-shrink-0">
            <DialogTitle className="text-2xl flex items-center gap-3">
              <UserPlus className="text-primary"/>
              יצירת הצעת שידוך חדשה
            </DialogTitle>
            <DialogDescription>
              בחר שני מועמדים, נתח את ההתאמה ביניהם והגדר את פרטי ההצעה.
            </DialogDescription>
          </DialogHeader>

          <FormProvider {...form}>
            <form onSubmit={handleSubmit} className="flex-1 grid grid-cols-1 md:grid-cols-12 gap-6 p-6 overflow-hidden">
              
              {/* Left Panel: Male Selector */}
              <div className="md:col-span-3 flex flex-col gap-4">
                <CandidateSelector
                  label="צד א' (גבר)"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={maleCandidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />
              </div>
              
              {/* Center Panel: Details and Actions */}
              <div className="md:col-span-6 flex flex-col gap-4 overflow-y-auto pr-2 pb-4">
                {firstParty && secondParty ? (
                  <>
                    <MatchPreview firstParty={firstParty} secondParty={secondParty} />
                     <div className="flex gap-2 justify-center">
                      <Button type="button" variant="outline" onClick={() => setShowAnalysisDialog(true)}>
                        <BarChart2 className="w-4 h-4 ml-2"/>
                        נתח התאמה מלא (AI)
                      </Button>
                     </div>
                    <SuggestionDetails firstParty={firstParty} secondParty={secondParty} />
                  </>
                ) : (
                  <div className="flex items-center justify-center h-full bg-gray-50 rounded-lg border-2 border-dashed">
                    <div className="text-center text-gray-500">
                        <Users className="mx-auto h-12 w-12 text-gray-300" />
                        <h3 className="mt-2 text-sm font-medium">בחר מועמדים</h3>
                        <p className="mt-1 text-sm text-gray-500">
                            יש לבחור מועמד ומועמדת מהעמודות בצדדים.
                        </p>
                    </div>
                  </div>
                )}
              </div>

              {/* Right Panel: Female Selector */}
              <div className="md:col-span-3 flex flex-col gap-4">
                <CandidateSelector
                  label="צד ב' (אישה)"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={femaleCandidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

            </form>
          </FormProvider>

          <DialogFooter className="p-4 border-t flex-shrink-0">
            <div className="flex justify-between w-full items-center">
                <span className="text-xs text-gray-500">לאחר יצירת ההצעה, היא תופיע בסטטוס טיוטה.</span>
                <div className="flex gap-2">
                    <DialogClose asChild><Button variant="outline">ביטול</Button></DialogClose>
                    <Button
                        type="submit"
                        onClick={handleSubmit}
                        disabled={isSubmitting || !firstParty || !secondParty}
                    >
                        {isSubmitting ? <Loader2 className="w-4 h-4 animate-spin ml-2"/> : <CheckCircle className="w-4 h-4 ml-2"/>}
                        {isSubmitting ? "יוצר הצעה..." : "צור הצעה"}
                    </Button>
                </div>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {firstParty && secondParty && (
        <AiMatchAnalysisDialog
          isOpen={showAnalysisDialog}
          onClose={() => setShowAnalysisDialog(false)}
          targetCandidate={firstParty}
          comparisonCandidates={[secondParty]}
        />
      )}
    </>
  );
};

export default NewSuggestionForm;
--- End of Content for index.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\schema.ts
--------------------------------------------------------------------------------
Content:
import { z } from "zod";
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;
--- End of Content for schema.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards\SuggestionCard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/cards/SuggestionCard.tsx

import React, { useState, useEffect } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import Image from "next/image";
import {
  Clock,
  User,
  MessageCircle,
  Eye,
  AlertCircle,
  MoreHorizontal,
  Send,
  RefreshCw,
  Trash2,
  Edit,
  CheckCircle,
  XCircle,
  CalendarClock,
  Heart,
  MapPin,
  Calendar,
  Star,
  ChevronDown,
  ChevronUp,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestionStatus, Priority } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";

// A simple media query hook
const useMediaQuery = (query: string) => {
  const [matches, setMatches] = useState(false);
  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    window.addEventListener("resize", listener);
    return () => window.removeEventListener("resize", listener);
  }, [matches, query]);
  return matches;
};

interface SuggestionCardProps {
  suggestion: Suggestion;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
  variant?: "full" | "compact";
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const getStatusInfo = (status: MatchSuggestionStatus) => {
  // ... (no changes to this function)
  switch (status) {
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לצד א׳",
        className: "bg-yellow-100 text-yellow-800 border-yellow-200",
        color: "text-yellow-600",
        bgColor: "bg-yellow-50",
        icon: Clock,
        progress: 25,
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לצד ב׳",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        color: "text-blue-600",
        bgColor: "bg-blue-50",
        icon: Clock,
        progress: 50,
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "צד א׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 40,
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "צד ב׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 60,
      };
    case "FIRST_PARTY_DECLINED":
      return {
        label: "צד א׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "SECOND_PARTY_DECLINED":
      return {
        label: "צד ב׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        className: "bg-purple-100 text-purple-800 border-purple-200",
        color: "text-purple-600",
        bgColor: "bg-purple-50",
        icon: Send,
        progress: 70,
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        className: "bg-pink-100 text-pink-800 border-pink-200",
        color: "text-pink-600",
        bgColor: "bg-pink-50",
        icon: Heart,
        progress: 80,
      };
    case "AWAITING_FIRST_DATE_FEEDBACK":
      return {
        label: "ממתין למשוב פגישה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        color: "text-orange-600",
        bgColor: "bg-orange-50",
        icon: AlertCircle,
        progress: 75,
      };
    case "EXPIRED":
      return {
        label: "פג תוקף",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: Clock,
        progress: 100,
      };
    default:
      return {
        label: "בטיפול",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: RefreshCw,
        progress: 30,
      };
  }
};

const getPriorityInfo = (priority: Priority) => {
  // ... (no changes to this function)
   switch (priority) {
    case "URGENT":
      return {
        label: "דחוף",
        className: "bg-red-100 text-red-800 border-red-200",
        icon: AlertCircle,
        color: "text-red-600",
        borderColor: "border-red-500",
      };
    case "HIGH":
      return {
        label: "גבוה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        icon: Star,
        color: "text-orange-600",
        borderColor: "border-orange-500",
      };
    case "MEDIUM":
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
        borderColor: "border-blue-500",
      };
    case "LOW":
      return {
        label: "נמוך",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: Star,
        color: "text-gray-600",
        borderColor: "border-gray-400",
      };
    default:
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
        borderColor: "border-blue-500",
      };
  }
};

const getDaysLeft = (decisionDeadline?: Date | string | null) => {
  // ... (no changes to this function)
  if (!decisionDeadline) return null;

  const deadline = new Date(decisionDeadline);
  const today = new Date();
  const diffTime = deadline.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? diffDays : 0;
};

const SuggestionCard: React.FC<SuggestionCardProps> = ({
  suggestion,
  onAction,
  className,
  variant = "full",
}) => {
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [isExpanded, setIsExpanded] = useState(false);

  // Common data
  const { firstParty, secondParty } = suggestion;
  const statusInfo = getStatusInfo(suggestion.status);
  const priorityInfo = getPriorityInfo(suggestion.priority);
  const daysLeft = getDaysLeft(suggestion.decisionDeadline);
  const firstPartyAge = calculateAge(firstParty.profile.birthDate);
  const secondPartyAge = calculateAge(secondParty.profile.birthDate);
  const firstPartyMainImage = firstParty.images.find((img) => img.isMain);
  const secondPartyMainImage = secondParty.images.find((img) => img.isMain);

  // ######################################################################
  // #                        MOBILE - KANBAN VIEW                        #
  // ######################################################################
  if (isMobile && variant === "compact") {
    const StatusIcon = statusInfo.icon;
    return (
      <Card
        className={cn(
          "p-3 w-full cursor-pointer hover:bg-gray-50",
          "border-l-4",
          priorityInfo.borderColor,
          className
        )}
        onClick={() => onAction("view", suggestion)}
      >
        <div className="flex justify-between items-start">
          <div className="flex-1 space-y-1">
            <h4 className="font-semibold text-sm leading-tight">
              {firstParty.firstName} ו{secondParty.firstName}
            </h4>
            <div className="flex items-center gap-2">
              <div className="flex -space-x-2">
                <Image
                  src={firstPartyMainImage?.url || "/placeholders/user.png"}
                  alt={firstParty.firstName}
                  width={24}
                  height={24}
                  className="rounded-full border-2 border-white"
                />
                <Image
                  src={secondPartyMainImage?.url || "/placeholders/user.png"}
                  alt={secondParty.firstName}
                  width={24}
                  height={24}
                  className="rounded-full border-2 border-white"
                />
              </div>
              <p className="text-xs text-gray-500">
                {firstPartyAge}, {secondPartyAge}
              </p>
            </div>
          </div>
          <div className={cn("p-1 rounded-full", statusInfo.bgColor)}>
            <StatusIcon className={cn("w-4 h-4", statusInfo.color)} />
          </div>
        </div>
      </Card>
    );
  }

  // ######################################################################
  // #                      MOBILE - SMART LIST VIEW                      #
  // ######################################################################
  if (isMobile && variant === "full") {
    const StatusIcon = statusInfo.icon;
    const isWaitingForResponse = suggestion.status.includes("PENDING");

    return (
      <Card className={cn("overflow-hidden shadow-sm", className)}>
        {/* Progress Bar and Status */}
        <div className={cn("p-3", statusInfo.bgColor)}>
          <div className="flex justify-between items-center mb-1.5">
            <div className="flex items-center gap-2">
              <StatusIcon className={cn("w-5 h-5", statusInfo.color)} />
              <span className="font-medium text-sm">{statusInfo.label}</span>
            </div>
            {daysLeft !== null && daysLeft <= 3 && (
              <Badge variant="destructive" className="text-xs">
                <Clock className="w-3 h-3 ml-1" />
                {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים`}
              </Badge>
            )}
          </div>
          <Progress value={statusInfo.progress} className="h-1" />
        </div>

        <CardContent className="p-4 space-y-4">
          {/* Parties Info */}
          <div className="flex items-center gap-4">
            <div className="flex-1 text-center space-y-1">
              <Image
                src={firstPartyMainImage?.url || "/placeholders/user.png"}
                alt={firstParty.firstName}
                width={64}
                height={64}
                className="rounded-full mx-auto border-2 border-blue-200"
              />
              <h4 className="font-bold">{firstParty.firstName}</h4>
              <p className="text-xs text-gray-600">
                {firstPartyAge}, {firstParty.profile.city}
              </p>
            </div>
            <Heart className="w-6 h-6 text-pink-400 flex-shrink-0" />
            <div className="flex-1 text-center space-y-1">
              <Image
                src={secondPartyMainImage?.url || "/placeholders/user.png"}
                alt={secondParty.firstName}
                width={64}
                height={64}
                className="rounded-full mx-auto border-2 border-purple-200"
              />
              <h4 className="font-bold">{secondParty.firstName}</h4>
              <p className="text-xs text-gray-600">
                {secondPartyAge}, {secondParty.profile.city}
              </p>
            </div>
          </div>

          {/* Collapsible Matching Reason */}
          {suggestion.matchingReason && (
            <div className="bg-gray-50 p-3 rounded-lg border">
              <p className={cn("text-sm text-gray-700", !isExpanded && "line-clamp-2")}>
                {suggestion.matchingReason}
              </p>
              <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="text-xs text-blue-600 font-semibold mt-1 flex items-center"
              >
                {isExpanded ? "הצג פחות" : "הצג יותר"}
                {isExpanded ? <ChevronUp className="w-4 h-4 mr-1" /> : <ChevronDown className="w-4 h-4 mr-1" />}
              </button>
            </div>
          )}

          {/* Thumb-friendly Action Bar */}
          <div className="flex items-center justify-between pt-3 border-t">
            <span className="text-xs text-gray-500">
              {formatDistanceToNow(new Date(suggestion.createdAt), { addSuffix: true, locale: he })}
            </span>
            <div className="flex items-center gap-2">
              {isWaitingForResponse && (
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => onAction("reminder", suggestion, { partyType: suggestion.status === 'PENDING_FIRST_PARTY' ? 'first' : 'second' })}
                >
                  <Send className="w-4 h-4" />
                </Button>
              )}
              <Button size="sm" onClick={() => onAction("view", suggestion)}>
                <Eye className="w-4 h-4 ml-1" />
                פרטים
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button size="sm" variant="ghost" className="px-1">
                    <MoreHorizontal className="w-5 h-5" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onAction("edit", suggestion)}>
                    <Edit className="w-4 h-4 ml-2" />
                    <span>ערוך הצעה</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onAction("message", suggestion)}>
                    <MessageCircle className="w-4 h-4 ml-2" />
                    <span>שלח הודעה</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onAction("delete", suggestion)} className="text-red-600">
                    <Trash2 className="w-4 h-4 ml-2" />
                    <span>מחק הצעה</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  // ######################################################################
  // #                              DESKTOP VIEW                          #
  // ######################################################################
  const StatusIcon = statusInfo.icon;
  const PriorityIcon = priorityInfo.icon;
  const canBeResent = ["EXPIRED", "FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"].includes(suggestion.status);
  const isWaitingForResponse = suggestion.status === "PENDING_FIRST_PARTY" || suggestion.status === "PENDING_SECOND_PARTY";
  const needsFeedback = suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK";

  return (
    <Card className={cn("overflow-hidden hover:shadow-md transition-shadow", className)}>
      {/* Header with status and progress */}
      <div className={cn("p-4 border-b relative", statusInfo.bgColor)}>
        <div className="flex justify-between items-center mb-2">
          <div className="flex items-center gap-2">
            <StatusIcon className={cn("w-5 h-5", statusInfo.color)} />
            <span className="font-medium text-gray-900">{statusInfo.label}</span>
          </div>
          <Badge className={priorityInfo.className}>
            <PriorityIcon className="w-3 h-3 ml-1" />
            {priorityInfo.label}
          </Badge>
        </div>
        <Progress value={statusInfo.progress} className="h-1.5" />
        {daysLeft !== null && daysLeft <= 3 && suggestion.status !== "EXPIRED" && (
          <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 bg-red-500 text-white text-xs font-bold py-0.5 px-2 rounded-full whitespace-nowrap z-10">
            <Clock className="w-3 h-3 inline-block ml-1" />
            {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים נותרו`}
          </div>
        )}
      </div>

      {/* Main content - a copy of the original desktop view */}
      <div className="p-4">
        {/* Parties info */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div className="space-y-2 border-l pl-4 order-1">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-blue-50">צד א׳</Badge>
              {suggestion.status === "FIRST_PARTY_APPROVED" && <Badge className="bg-green-100 text-green-800"><CheckCircle className="w-3 h-3 ml-1" />אישר</Badge>}
              {suggestion.status === "FIRST_PARTY_DECLINED" && <Badge className="bg-red-100 text-red-800"><XCircle className="w-3 h-3 ml-1" />דחה</Badge>}
            </div>
            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {firstPartyMainImage ? <Image src={firstPartyMainImage.url} alt={firstParty.firstName} className="object-cover" fill sizes="4rem" /> : <div className="w-full h-full flex items-center justify-center"><User className="w-8 h-8 text-gray-400" /></div>}
              </div>
              <div>
                <h4 className="font-semibold">{firstParty.firstName} {firstParty.lastName}</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center"><Calendar className="w-3 h-3 ml-1 text-gray-400" /><span>{firstPartyAge} שנים</span></div>
                  {firstParty.profile.city && <div className="flex items-center"><MapPin className="w-3 h-3 ml-1 text-gray-400" /><span>{firstParty.profile.city}</span></div>}
                </div>
              </div>
            </div>
          </div>
          <div className="space-y-2 order-0">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-purple-50">צד ב׳</Badge>
              {suggestion.status === "SECOND_PARTY_APPROVED" && <Badge className="bg-green-100 text-green-800"><CheckCircle className="w-3 h-3 ml-1" />אישר</Badge>}
              {suggestion.status === "SECOND_PARTY_DECLINED" && <Badge className="bg-red-100 text-red-800"><XCircle className="w-3 h-3 ml-1" />דחה</Badge>}
            </div>
            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {secondPartyMainImage ? <Image src={secondPartyMainImage.url} alt={secondParty.firstName} className="object-cover" fill sizes="4rem" /> : <div className="w-full h-full flex items-center justify-center"><User className="w-8 h-8 text-gray-400" /></div>}
              </div>
              <div>
                <h4 className="font-semibold">{secondParty.firstName} {secondParty.lastName}</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center"><Calendar className="w-3 h-3 ml-1 text-gray-400" /><span>{secondPartyAge} שנים</span></div>
                  {secondParty.profile.city && <div className="flex items-center"><MapPin className="w-3 h-3 ml-1 text-gray-400" /><span>{secondParty.profile.city}</span></div>}
                </div>
              </div>
            </div>
          </div>
        </div>

        {suggestion.matchingReason && (
          <div className="mb-4 p-3 bg-gray-50 rounded-lg border text-sm">
            <h5 className="text-xs font-semibold text-gray-600 mb-1">סיבת ההתאמה:</h5>
            <p className="text-gray-800 line-clamp-2">{suggestion.matchingReason}</p>
          </div>
        )}

        <div className="flex justify-between text-xs text-gray-500 mb-4">
          <div className="flex items-center"><Clock className="w-3.5 h-3.5 ml-1" />{formatDistanceToNow(new Date(suggestion.createdAt), { addSuffix: true, locale: he })}</div>
          {suggestion.decisionDeadline && <div className="flex items-center"><CalendarClock className="w-3.5 h-3.5 ml-1" />{daysLeft !== null ? (daysLeft === 0 ? "היום!" : `${daysLeft} ימים להחלטה`) : "אין מועד אחרון"}</div>}
        </div>

        <div className="flex items-center justify-between pt-2 border-t">
          <Button variant="ghost" size="sm" onClick={() => onAction("message", suggestion)} className="text-gray-600 hover:text-primary"><MessageCircle className="w-4 h-4 ml-1" />הודעה</Button>
          <div className="flex items-center gap-1">
            <Button variant="default" size="sm" onClick={() => onAction("view", suggestion)}><Eye className="w-4 h-4 ml-1" />פרטים</Button>
            <DropdownMenu>
              <DropdownMenuTrigger asChild><Button size="sm" variant="ghost" className="px-1"><MoreHorizontal className="w-4 h-4" /></Button></DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => onAction("edit", suggestion)}><Edit className="w-4 h-4 ml-2" /><span>ערוך הצעה</span></DropdownMenuItem>
                {canBeResent && <DropdownMenuItem onClick={() => onAction("resend", suggestion)}><RefreshCw className="w-4 h-4 ml-2" /><span>שלח מחדש</span></DropdownMenuItem>}
                <DropdownMenuItem onClick={() => onAction("delete", suggestion)} className="text-red-600"><Trash2 className="w-4 h-4 ml-2" /><span>מחק הצעה</span></DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </Card>
  );
};

export default SuggestionCard;
--- End of Content for SuggestionCard.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback, useEffect, useMemo } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Plus, RefreshCw, BarChart, Loader2, List, LayoutGrid, Filter, Search } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger } from "@/components/ui/sheet";
import { ToggleGroup, ToggleGroupItem } from "@/components/ui/toggle-group";
import { toast } from "sonner";
import { MatchSuggestionStatus, Priority } from "@prisma/client";
import { cn } from "@/lib/utils";

// --- START: Type Imports and Definitions ---
import type {
  Suggestion,
  SuggestionFilters,
  ActionAdditionalData,
} from "@/types/suggestions";
import type { NewSuggestionFormData } from "../../suggestions/NewSuggestionForm/schema";
import type { Candidate } from "../../new/types/candidates";

// Hooks
import { useCandidates } from "../../new/hooks/useCandidates";

// Components
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import SuggestionCard from "../cards/SuggestionCard";
import EditSuggestionForm from "../EditSuggestionForm";
import MessageForm from "../MessageForm";
import MonthlyTrendModal from "./MonthlyTrendModal";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Input } from "@/components/ui/input";

// --- A simple media query hook ---
const useMediaQuery = (query: string) => {
  const [matches, setMatches] = useState(false);
  useEffect(() => {
    // Ensure this runs only on the client
    if (typeof window === 'undefined') return;
    
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    window.addEventListener("resize", listener);
    return () => window.removeEventListener("resize", listener);
  }, [matches, query]);
  return matches;
};

// --- Defining specific payload types to replace 'any' ---
interface SuggestionUpdatePayload {
  priority?: Priority;
  status?: MatchSuggestionStatus;
  statusNotes?: string;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: Date;
}

interface SendMessagePayload {
  suggestionId: string;
  partyType: "first" | "second" | "both";
  messageType: "message" | "reminder" | "update";
  messageContent: string;
}

type DialogActionData = {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyType?: "first" | "second" | "both";
  type?: string;
};

type ConfirmActionData = {
  suggestionId: string;
  partyType?: "first" | "second" | "both";
  type?: string;
};
// --- END: Type Imports and Definitions ---

export default function MatchmakerDashboard() {
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [mobileView, setMobileView] = useState<'list' | 'kanban'>('list');
  const [showMobileFilters, setShowMobileFilters] = useState(false);

  // State management
  const [activeTab, setActiveTab] = useState("pending");
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<SuggestionFilters>({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  // Dialogs and selected items state
  const [selectedSuggestion, setSelectedSuggestion] = useState<Suggestion | null>(null);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmAction, setConfirmAction] = useState<{ type: string; data: ConfirmActionData; } | null>(null);
  const [showEditForm, setShowEditForm] = useState(false);
  const [showMessageForm, setShowMessageForm] = useState(false);
  const [showMonthlyTrendDialog, setShowMonthlyTrendDialog] = useState(false);

  // Fetch candidates list to pass to the form
  const { candidates: allCandidates } = useCandidates();

  const fetchSuggestions = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/matchmaker/suggestions");
      if (!response.ok) throw new Error("Failed to fetch suggestions");
      const data = await response.json();
      setSuggestions(data);
    } catch (error: unknown) {
      console.error("Error fetching suggestions:", error);
      toast.error("שגיאה בטעינת ההצעות");
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchSuggestions();
  }, [fetchSuggestions]);
  
  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((s) => {
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const match =
          (s.firstParty.firstName + " " + s.firstParty.lastName).toLowerCase().includes(query) ||
          (s.secondParty.firstName + " " + s.secondParty.lastName).toLowerCase().includes(query) ||
          (s.firstParty.profile?.city && s.firstParty.profile.city.toLowerCase().includes(query)) ||
          (s.secondParty.profile?.city && s.secondParty.profile.city.toLowerCase().includes(query));
        if (!match) return false;
      }
      if (filters.priority?.length && !filters.priority.includes(s.priority)) return false;
      if (filters.status?.length && !filters.status.includes(s.status)) return false;
      if (filters.dateRange) {
        const createdAt = new Date(s.createdAt);
        if (createdAt < filters.dateRange.start || (filters.dateRange.end && createdAt > filters.dateRange.end)) return false;
      }
      return true;
    });
  }, [suggestions, searchQuery, filters]);
  
  const pendingSuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'PENDING'), [filteredSuggestions]);
  const activeSuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'ACTIVE'), [filteredSuggestions]);
  const historySuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'HISTORY'), [filteredSuggestions]);

  const pendingCount = pendingSuggestions.length;
  const activeCount = activeSuggestions.length;
  const historyCount = historySuggestions.length;

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await fetchSuggestions();
    setIsRefreshing(false);
    toast.success("נתוני ההצעות עודכנו");
  };

  const handleNewSuggestion = async (data: NewSuggestionFormData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error((await response.json()).error || "Failed to create suggestion");
      setShowNewSuggestion(false);
      toast.success("ההצעה נוצרה בהצלחה");
      await fetchSuggestions();
    } catch (error: unknown) {
      console.error("Error creating suggestion:", error);
      toast.error("שגיאה ביצירת ההצעה: " + (error instanceof Error ? error.message : ""));
    }
  };

  const handleSuggestionDeleted = useCallback((deletedId: string) => {
    setSuggestions((prev) => prev.filter((s) => s.id !== deletedId));
    if (selectedSuggestion?.id === deletedId) setSelectedSuggestion(null);
  }, [selectedSuggestion]);

  const handleConfirmAction = async () => {
    if (!confirmAction) return;
    try {
      if (confirmAction.type === "delete") {
        const response = await fetch(`/api/matchmaker/suggestions/${confirmAction.data.suggestionId}/delete`, { method: "DELETE" });
        if (!response.ok) throw new Error("Failed to delete suggestion");
        handleSuggestionDeleted(confirmAction.data.suggestionId);
        toast.success("ההצעה נמחקה בהצלחה");
      }
    } catch (error: unknown) {
      toast.error("אירעה שגיאה בביצוע הפעולה");
    } finally {
      setShowConfirmDialog(false);
      setConfirmAction(null);
    }
  };
  
  const handleStatusChange = async (suggestionId: string, newStatus: MatchSuggestionStatus, notes?: string) => {
    try {
      const response = await fetch(`/api/matchmaker/suggestions/${suggestionId}/status`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: newStatus, notes: notes || `סטטוס שונה מממשק ניהול` }),
      });
      if (!response.ok) throw new Error((await response.json()).error || "Failed to update status");
      toast.success("סטטוס ההצעה עודכן בהצלחה");
      fetchSuggestions();
    } catch (error: unknown) {
      console.error("Error updating suggestion status:", error);
      toast.error("שגיאה בעדכון סטטוס ההצעה: " + (error instanceof Error ? error.message : ""));
    }
  };

  const handleUpdateSuggestion = async (data: { suggestionId: string; updates: SuggestionUpdatePayload; }) => {
    try {
        const response = await fetch(`/api/matchmaker/suggestions/${data.suggestionId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data.updates),
        });
        if (!response.ok) throw new Error('Failed to update suggestion');
        toast.success("פרטי ההצעה עודכנו בהצלחה");
        setShowEditForm(false);
        fetchSuggestions();
    } catch (error: unknown) {
        console.error("Error updating suggestion:", error);
        toast.error("שגיאה בעדכון פרטי ההצעה");
    }
  };

  const handleSendMessage = async (data: SendMessagePayload) => {
    try {
      const response = await fetch(`/api/matchmaker/suggestions/${data.suggestionId}/message`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            partyType: data.partyType,
            messageType: data.messageType,
            content: data.messageContent
        }),
      });
      if (!response.ok) throw new Error((await response.json()).error || 'Failed to send message');
      toast.success("ההודעה נשלחה בהצלחה");
      setShowMessageForm(false);
    } catch (error: unknown) {
      toast.error("שגיאה בשליחת ההודעה: " + (error instanceof Error ? error.message : ""));
    }
  };
  
  const handleDialogAction = (action: string, data?: DialogActionData) => {
    setSelectedSuggestion(data?.suggestion || null);
    if (action === 'view' && data?.suggestion) {
        setSelectedSuggestion(data.suggestion);
    } else if (action === 'delete' && data?.suggestionId) {
      setConfirmAction({ type: 'delete', data: { suggestionId: data.suggestionId } });
      setShowConfirmDialog(true);
    } else if (action === 'edit' && data?.suggestion) {
      setShowEditForm(true);
    } else if (action === 'message' && data?.suggestion) {
      setShowMessageForm(true);
    } else if (action === 'changeStatus' && data?.suggestionId && data.newStatus) {
        handleStatusChange(data.suggestionId, data.newStatus, data.notes);
    }
  };
  
  const handleSuggestionAction = (type: any, suggestion: Suggestion, additionalData?: ActionAdditionalData) => {
    handleDialogAction(type, { ...additionalData, suggestionId: suggestion.id, suggestion });
  };
  
  const kanbanColumns = useMemo(() => {
    const columns: { title: string; suggestions: Suggestion[] }[] = [
      { title: "דורש טיפול", suggestions: [] },
      { title: "ממתין לתגובה", suggestions: [] },
      { title: "פעילות", suggestions: [] },
      { title: "היסטוריה", suggestions: [] },
    ];

    filteredSuggestions.forEach(s => {
      if (['AWAITING_MATCHMAKER_APPROVAL', 'AWAITING_FIRST_DATE_FEEDBACK'].includes(s.status)) {
        columns[0].suggestions.push(s);
      } else if (['PENDING_FIRST_PARTY', 'PENDING_SECOND_PARTY'].includes(s.status)) {
        columns[1].suggestions.push(s);
      } else if (['CLOSED', 'CANCELLED', 'EXPIRED', 'MARRIED', 'ENGAGED'].includes(s.status)) {
        columns[3].suggestions.push(s);
      } else {
        columns[2].suggestions.push(s);
      }
    });

    return columns;
  }, [filteredSuggestions]);

  // =========================================================================
  // ============================ RENDER LOGIC ===============================
  // =========================================================================

  const renderMobileFilters = () => (
    <Sheet open={showMobileFilters} onOpenChange={setShowMobileFilters}>
      <SheetTrigger asChild>
        <Button variant="outline" size="sm">
          <Filter className="w-4 h-4 mr-2" />
          סינון
        </Button>
      </SheetTrigger>
      <SheetContent>
        <SheetHeader>
          <SheetTitle>סינון הצעות</SheetTitle>
        </SheetHeader>
        <div className="py-4">
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
            totalCount={suggestions.length}
            activeCount={activeCount}
            pendingCount={pendingCount}
            historyCount={historyCount}
          />
        </div>
      </SheetContent>
    </Sheet>
  );

  const renderMobileView = () => (
    <div className="h-screen flex flex-col">
      <div className="flex items-center justify-between p-4 border-b bg-white sticky top-0 z-10">
        <div className="relative flex-1">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-400" />
          <Input
            placeholder="חיפוש..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10 text-right pr-10 bg-gray-100"
          />
        </div>
        <div className="mr-2">{renderMobileFilters()}</div>
        <ToggleGroup
          type="single"
          value={mobileView}
          onValueChange={(value: 'list' | 'kanban') => value && setMobileView(value)}
          className="mr-2"
        >
          <ToggleGroupItem value="list" aria-label="List view"><List className="h-4 w-4" /></ToggleGroupItem>
          <ToggleGroupItem value="kanban" aria-label="Kanban view"><LayoutGrid className="h-4 w-4" /></ToggleGroupItem>
        </ToggleGroup>
      </div>
      {isLoading ? (
        <div className="flex-1 flex items-center justify-center"><Loader2 className="w-8 h-8 animate-spin text-primary" /></div>
      ) : mobileView === 'kanban' ? (
        <ScrollArea className="w-full whitespace-nowrap flex-1">
          <div className="flex gap-4 p-4 h-full">
            {kanbanColumns.map((col, idx) => (
              <div key={idx} className="w-64 flex-shrink-0 bg-gray-100 rounded-lg flex flex-col">
                <div className="p-3 font-semibold text-sm border-b sticky top-0 bg-gray-100/80 backdrop-blur-sm z-10">
                  {col.title} <Badge variant="secondary" className="mr-1">{col.suggestions.length}</Badge>
                </div>
                <ScrollArea className="flex-1">
                  <div className="p-2 space-y-2">
                    {col.suggestions.length > 0 ? col.suggestions.map(s => <SuggestionCard key={s.id} suggestion={s} onAction={handleSuggestionAction} variant="compact" />)
                    : <div className="p-4 text-center text-xs text-gray-500">אין הצעות</div>}
                  </div>
                </ScrollArea>
              </div>
            ))}
          </div>
        </ScrollArea>
      ) : (
        <ScrollArea className="flex-1">
          <div className="p-4 space-y-4">
            {filteredSuggestions.map(s => <SuggestionCard key={s.id} suggestion={s} onAction={handleSuggestionAction} variant="full" />)}
            {filteredSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">לא נמצאו הצעות תואמות.</div>}
          </div>
        </ScrollArea>
      )}
       <div className="p-4 bg-white border-t sticky bottom-0">
         <Button onClick={() => setShowNewSuggestion(true)} className="w-full">
            <Plus className="w-4 h-4 mr-2" />
            הצעה חדשה
         </Button>
       </div>
    </div>
  );

  const renderDesktopView = () => (
    <div className="container mx-auto space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
        <div className="flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={handleRefresh} disabled={isRefreshing}><RefreshCw className={cn("w-4 h-4 mr-2", isRefreshing && "animate-spin")} />{isRefreshing ? "מעדכן..." : "רענן"}</Button>
          <Button variant="outline" size="sm" onClick={() => setShowMonthlyTrendDialog(true)}><BarChart className="w-4 h-4 mr-2" />מגמה חודשית</Button>
          <Button onClick={() => setShowNewSuggestion(true)}><Plus className="w-4 h-4 mr-2" />הצעה חדשה</Button>
        </div>
      </div>
      <SuggestionsStats suggestions={suggestions} onFilterChange={(filter) => setFilters(prev => ({...prev, ...filter}))} />
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <div className="flex items-center justify-between mb-6">
          <TabsList dir="rtl">
            <TabsTrigger value="pending">ממתין לאישור <Badge className="mr-2">{pendingCount}</Badge></TabsTrigger>
            <TabsTrigger value="active">פעילות <Badge className="mr-2">{activeCount}</Badge></TabsTrigger>
            <TabsTrigger value="history">היסטוריה <Badge className="mr-2">{historyCount}</Badge></TabsTrigger>
          </TabsList>
        </div>
        <SuggestionActionBar
          searchQuery={searchQuery} onSearchChange={setSearchQuery} filters={filters} onFiltersChange={setFilters}
          totalCount={suggestions.length}
          activeCount={activeCount}
          pendingCount={pendingCount}
          historyCount={historyCount}
        />
        {isLoading ? (
          <div className="flex items-center justify-center h-64"><Loader2 className="w-8 h-8 animate-spin text-primary" /></div>
        ) : (
          <>
            <TabsContent value="pending">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {pendingSuggestions.map((suggestion) => ( <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} /> ))}
              </div>
              {pendingSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות ממתינות לאישור.</div>}
            </TabsContent>
            <TabsContent value="active">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {activeSuggestions.map((suggestion) => ( <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} /> ))}
              </div>
              {activeSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות פעילות.</div>}
            </TabsContent>
            <TabsContent value="history">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {historySuggestions.map((suggestion) => ( <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} /> ))}
              </div>
              {historySuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות בהיסטוריה.</div>}
            </TabsContent>
          </>
        )}
      </Tabs>
    </div>
  );

  return (
    <div className={cn("min-h-screen bg-gray-50 rtl", !isMobile && "p-6", isMobile && "p-0")}>
      {isMobile ? renderMobileView() : renderDesktopView()}

      {/* Dialogs and Forms (common for both views) */}
      <NewSuggestionForm isOpen={showNewSuggestion} onClose={() => setShowNewSuggestion(false)} candidates={allCandidates} onSubmit={handleNewSuggestion} />
      <SuggestionDetailsDialog suggestion={selectedSuggestion} isOpen={!!selectedSuggestion} onClose={() => setSelectedSuggestion(null)} onAction={handleDialogAction as any} />
      <Dialog open={showMonthlyTrendDialog} onOpenChange={setShowMonthlyTrendDialog}><DialogContent className="max-w-4xl"><DialogHeader><DialogTitle>מגמה חודשית</DialogTitle></DialogHeader><MonthlyTrendModal suggestions={suggestions} /></DialogContent></Dialog>
      <EditSuggestionForm isOpen={showEditForm} onClose={() => setShowEditForm(false)} suggestion={selectedSuggestion} onSave={handleUpdateSuggestion} />
      <MessageForm isOpen={showMessageForm} onClose={() => setShowMessageForm(false)} suggestion={selectedSuggestion} onSend={handleSendMessage} />
      {confirmAction && <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}><AlertDialogContent><AlertDialogHeader><AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle><AlertDialogDescription>{confirmAction.type === "delete" && "פעולה זו תמחק את ההצעה לצמיתות."}</AlertDialogDescription></AlertDialogHeader><AlertDialogFooter><AlertDialogCancel>ביטול</AlertDialogCancel><AlertDialogAction onClick={handleConfirmAction}>אישור</AlertDialogAction></AlertDialogFooter></AlertDialogContent></AlertDialog>}
    </div>
  );
}
--- End of Content for MatchmakerDashboard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MonthlyTrendModal.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface MonthlyTrendModalProps {
  suggestions: Suggestion[];
}

interface MonthlyData {
  month: string;
  year: number;
  count: number;
  active: number;
  pending: number;
  success: number;
  declined: number;
}

const MonthlyTrendModal: React.FC<MonthlyTrendModalProps> = ({
  suggestions,
}) => {
  // Group suggestions by month to prepare data for chart
  const monthlyData = useMemo(() => {
    const data = suggestions.reduce((acc, s) => {
      const createdDate = new Date(s.createdAt);
      const month = createdDate.getMonth();
      const year = createdDate.getFullYear();
      const key = `${year}-${month + 1}`;

      if (!acc[key]) {
        acc[key] = {
          month: new Date(year, month).toLocaleString("he", {
            month: "short",
          }),
          year: year,
          count: 0,
          active: 0,
          pending: 0,
          success: 0,
          declined: 0,
        };
      }

      acc[key].count += 1;

      if (s.category === "ACTIVE") acc[key].active += 1;
      if (s.category === "PENDING") acc[key].pending += 1;
      if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
      if (
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
      ) {
        acc[key].declined += 1;
      }

      return acc;
    }, {} as Record<string, MonthlyData>);

    // Convert to array and sort by date
    return Object.values(data).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      const monthA = new Date(
        a.year,
        a.month === "ינו" ? 0 : new Date(`1 ${a.month} 2000`).getMonth()
      ).getMonth();
      const monthB = new Date(
        b.year,
        b.month === "ינו" ? 0 : new Date(`1 ${b.month} 2000`).getMonth()
      ).getMonth();
      return monthA - monthB;
    });
  }, [suggestions]);

  // Calculate trends
  const trends = useMemo(() => {
    if (monthlyData.length < 2)
      return { active: 0, pending: 0, success: 0, total: 0 };

    const current = monthlyData[monthlyData.length - 1];
    const previous = monthlyData[monthlyData.length - 2];

    const calculateTrend = (current: number, previous: number) => {
      if (previous === 0) return current > 0 ? 100 : 0;
      return Math.round(((current - previous) / previous) * 100);
    };

    return {
      active: calculateTrend(current.active, previous.active),
      pending: calculateTrend(current.pending, previous.pending),
      success: calculateTrend(current.success, previous.success),
      total: calculateTrend(current.count, previous.count),
    };
  }, [monthlyData]);

  if (monthlyData.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        <p>אין מספיק נתונים להצגת מגמה חודשית</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Summary stats */}
      <div className="grid grid-cols-4 gap-3">
        <Card className="p-3">
          <div className="text-sm text-gray-500"> סך כל ההצעות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].count}
            <span
              className={`text-xs ml-2 ${
                trends.total >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.total > 0 ? "+" : ""}
              {trends.total}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות פעילות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].active}
            <span
              className={`text-xs ml-2 ${
                trends.active >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.active > 0 ? "+" : ""}
              {trends.active}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">ממתינות לאישור</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].pending}
            <span
              className={`text-xs ml-2 ${
                trends.pending >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.pending > 0 ? "+" : ""}
              {trends.pending}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות מוצלחות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].success}
            <span
              className={`text-xs ml-2 ${
                trends.success >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.success > 0 ? "+" : ""}
              {trends.success}%
            </span>
          </div>
        </Card>
      </div>

      {/* Main chart */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={monthlyData}
              margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip
                formatter={(value) => [`${value} הצעות`, ""]}
                labelFormatter={(label) => `חודש ${label}`}
              />
              <Legend />
              <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
              <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
              <Bar dataKey="success" name="הצלחות" fill="#10B981" />
              <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* Monthly breakdown table */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">פירוט חודשי</h3>
        <div className="overflow-x-auto">
          <table className="w-full border-collapse">
            <thead>
              <tr className="bg-gray-50">
                <th className="p-2 border text-right">חודש</th>
                <th className="p-2 border text-center">סך הכל</th>
                <th className="p-2 border text-center">פעילות</th>
                <th className="p-2 border text-center">ממתינות</th>
                <th className="p-2 border text-center">הצלחות</th>
                <th className="p-2 border text-center">נדחו</th>
              </tr>
            </thead>
            <tbody>
              {monthlyData
                .slice()
                .reverse()
                .map((month, idx) => (
                  <tr
                    key={idx}
                    className={idx % 2 === 0 ? "bg-white" : "bg-gray-50"}
                  >
                    <td className="p-2 border font-medium">
                      {month.month} {month.year}
                    </td>
                    <td className="p-2 border text-center">{month.count}</td>
                    <td className="p-2 border text-center">{month.active}</td>
                    <td className="p-2 border text-center">{month.pending}</td>
                    <td className="p-2 border text-center">{month.success}</td>
                    <td className="p-2 border text-center">{month.declined}</td>
                  </tr>
                ))}
            </tbody>
          </table>
        </div>
      </Card>
    </div>
  );
};

export default MonthlyTrendModal;
--- End of Content for MonthlyTrendModal.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { DatePicker } from "@/components/ui/date-picker";
import {
  Search,
  Filter,
  X,
  Calendar,
  User,
  Clock,
  ChevronDown,
  AlertCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import type { SuggestionFilters, SortByOption } from "@/types/suggestions";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: SuggestionFilters;
  onFiltersChange: (filters: SuggestionFilters) => void;
  totalCount: number;
  activeCount: number;
  pendingCount: number;
  historyCount: number;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
  totalCount,
  activeCount,
  pendingCount,
  historyCount,
}) => {
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const activeFilters = Object.keys(filters).length;
  const [dateRange, setDateRange] = useState<{
    from: Date | undefined;
    to: Date | undefined;
  }>({
    from: filters.dateRange?.start,
    to: filters.dateRange?.end,
  });

  const handleRemoveFilter = (key: keyof SuggestionFilters) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  const handleDateRangeChange = (range: {
    from: Date | undefined;
    to: Date | undefined;
  }) => {
    setDateRange(range);
    if (range.from) {
      onFiltersChange({
        ...filters,
        dateRange: {
          start: range.from,
          end: range.to || new Date(),
        },
      });
    } else {
      const newFilters = { ...filters };
      delete newFilters.dateRange;
      onFiltersChange(newFilters);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return <Clock className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_APPROVED":
      case "SECOND_PARTY_APPROVED":
        return <CheckCircle className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
        return <XCircle className="h-4 w-4 ml-1" />;
      default:
        return <AlertCircle className="h-4 w-4 ml-1" />;
    }
  };

  return (
    <div className="space-y-4 mb-6">
      {/* Main filters and search */}
      <div className="flex items-center gap-4">
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות לפי שם, עיר או כל מידע אחר..."
            className="pl-10 text-right pr-10"
          />
        </div>

        <Select
          value={filters.priority?.[0] || "all"}
          onValueChange={(value) =>
            onFiltersChange({
              ...filters,
              priority: value === "all" ? undefined : [value as Priority],
            })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">כל העדיפויות</SelectItem>
            <SelectItem value={Priority.URGENT}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-red-500"></span>
                דחוף
              </div>
            </SelectItem>
            <SelectItem value={Priority.HIGH}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-orange-500"></span>
                גבוהה
              </div>
            </SelectItem>
            <SelectItem value={Priority.MEDIUM}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-blue-500"></span>
                רגילה
              </div>
            </SelectItem>
            <SelectItem value={Priority.LOW}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-gray-500"></span>
                נמוכה
              </div>
            </SelectItem>
          </SelectContent>
        </Select>

        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" className="flex items-center">
              <Calendar className="h-4 w-4 ml-2" />
              <span>טווח זמן</span>
              <ChevronDown className="h-4 w-4 mr-2" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-4" align="end">
            <div className="space-y-2">
              <h4 className="font-medium">בחר טווח תאריכים</h4>
              <DatePicker
                onChange={handleDateRangeChange}
                value={dateRange}
                isRange={true}
              />
              <div className="flex justify-end mt-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() =>
                    handleDateRangeChange({ from: undefined, to: undefined })
                  }
                >
                  נקה
                </Button>
              </div>
            </div>
          </PopoverContent>
        </Popover>

        <Button
          variant={showAdvancedFilters ? "default" : "outline"}
          onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
        >
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Stats Row */}
      <div className="flex justify-between bg-slate-50 rounded-md p-3">
        <div className="flex items-center gap-6">
          <div className="flex items-center">
            <Badge variant="outline" className="rounded-full px-2 py-0 mr-2">
              {totalCount}
            </Badge>
            <span className="text-sm font-medium">סה״כ הצעות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="default" className="rounded-full px-2 py-0 mr-2">
              {activeCount}
            </Badge>
            <span className="text-sm font-medium">פעילות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="warning" className="rounded-full px-2 py-0 mr-2">
              {pendingCount}
            </Badge>
            <span className="text-sm font-medium">ממתינות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="secondary" className="rounded-full px-2 py-0 mr-2">
              {historyCount}
            </Badge>
            <span className="text-sm font-medium">היסטוריה</span>
          </div>
        </div>

        {activeFilters > 0 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה את כל המסננים ({activeFilters})
          </Button>
        )}
      </div>

      {/* Advanced Filters */}
      {showAdvancedFilters && (
        <div className="bg-slate-50 p-4 rounded-md space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="font-medium">מסננים מתקדמים</h3>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 px-2"
              onClick={() => setShowAdvancedFilters(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Status Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">סטטוס</h4>
              <div className="space-y-2">
                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-first"
                    checked={filters.status?.includes("PENDING_FIRST_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_FIRST_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_FIRST_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-first"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-yellow-600" />
                    ממתין לתשובת צד א׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-second"
                    checked={filters.status?.includes("PENDING_SECOND_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_SECOND_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_SECOND_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-second"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-blue-600" />
                    ממתין לתשובת צד ב׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-approved"
                    checked={
                      filters.status?.includes("FIRST_PARTY_APPROVED") ||
                      filters.status?.includes("SECOND_PARTY_APPROVED")
                    }
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "FIRST_PARTY_APPROVED",
                          "SECOND_PARTY_APPROVED",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) =>
                              s !== "FIRST_PARTY_APPROVED" &&
                              s !== "SECOND_PARTY_APPROVED"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-approved"
                    className="text-sm mr-2 flex items-center"
                  >
                    <CheckCircle className="h-3 w-3 ml-1 text-green-600" />
                    אושר ע״י אחד הצדדים
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-dating"
                    checked={filters.status?.includes("DATING")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [...(filters.status || []), "DATING"];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "DATING"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-dating"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Calendar className="h-3 w-3 ml-1 text-pink-600" />
                    בתהליך היכרות
                  </label>
                </div>
              </div>
            </div>

            {/* User Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">משתתפים</h4>
              <Select
                value={filters.userId || "all"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    userId: value === "all" ? undefined : value,
                  })
                }
              >
                <SelectTrigger>
                  <User className="h-4 w-4 ml-1" />
                  <SelectValue placeholder="בחר משתתף" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">כל המשתתפים</SelectItem>
                  {/* Replace with dynamic user data */}
                  <SelectItem value="user1">ישראל ישראלי</SelectItem>
                  <SelectItem value="user2">שרה כהן</SelectItem>
                  <SelectItem value="user3">דוד לוי</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Sort By */}
            <div>
              <h4 className="text-sm font-medium mb-2">מיון לפי</h4>
              <Select
                value={filters.sortBy || "lastActivity"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    sortBy: value as SortByOption, // Cast to SortByOption
                  })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="מיון לפי" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="lastActivity">פעילות אחרונה</SelectItem>
                  <SelectItem value="createdAt">תאריך יצירה</SelectItem>
                  <SelectItem value="priority">עדיפות</SelectItem>
                  <SelectItem value="decisionDeadline">תאריך יעד</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      )}

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2 flex-wrap">
          {filters.priority && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                עדיפות:{" "}
                {filters.priority[0] === "URGENT"
                  ? "דחוף"
                  : filters.priority[0] === "HIGH"
                  ? "גבוהה"
                  : filters.priority[0] === "MEDIUM"
                  ? "רגילה"
                  : "נמוכה"}
              </span>
              <button
                onClick={() => handleRemoveFilter("priority")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.dateRange && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                תאריך:{" "}
                {new Date(filters.dateRange.start).toLocaleDateString("he-IL")}
                {filters.dateRange.end &&
                  ` - ${new Date(filters.dateRange.end).toLocaleDateString(
                    "he-IL"
                  )}`}
              </span>
              <button
                onClick={() => handleRemoveFilter("dateRange")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.status && filters.status.length > 0 && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                סטטוס:{" "}
                {filters.status.length === 1
                  ? ""
                  : `(${filters.status.length})`}
                {filters.status.length === 1 && (
                  <span className="flex items-center">
                    {getStatusIcon(filters.status[0])}
                    {filters.status[0] === "PENDING_FIRST_PARTY"
                      ? "ממתין לצד א׳"
                      : filters.status[0] === "PENDING_SECOND_PARTY"
                      ? "ממתין לצד ב׳"
                      : filters.status[0]}
                  </span>
                )}
              </span>
              <button
                onClick={() => handleRemoveFilter("status")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.userId && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>משתתף מסוים</span>
              <button
                onClick={() => handleRemoveFilter("userId")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;
--- End of Content for SuggestionActionBar.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  Users,
  CheckCircle,
  Clock,
  Calendar,
  AlertCircle,
  Ban,
  X,
} from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion, SuggestionFilters } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  onClick?: () => void;
  isClickable?: boolean;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
  onFilterChange?: (filter: Partial<SuggestionFilters>) => void;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
  onClick,
  isClickable = false,
}) => (
  <Card
    className={`p-4 ${className} ${
      isClickable ? "cursor-pointer hover:shadow-md transition-shadow" : ""
    }`}
    onClick={onClick}
  >
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value > 0 ? "+" : ""}
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
  onFilterChange,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter((s) => s.category === "ACTIVE").length;
    const pending = suggestions.filter((s) => s.category === "PENDING").length;
    const history = suggestions.filter((s) => s.category === "HISTORY").length;

    const approvedByFirst = suggestions.filter(
      (s) => s.status === "FIRST_PARTY_APPROVED"
    ).length;
    const approvedBySecond = suggestions.filter(
      (s) => s.status === "SECOND_PARTY_APPROVED"
    ).length;
    const declined = suggestions.filter(
      (s) =>
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
    ).length;
    const expired = suggestions.filter((s) => s.status === "EXPIRED").length;
    const dating = suggestions.filter((s) => s.status === "DATING").length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Group suggestions by month
    const monthlyData = suggestions.reduce(
      (acc, s) => {
        const month = new Date(s.createdAt).getMonth();
        const year = new Date(s.createdAt).getFullYear();
        const key = `${year}-${month + 1}`;

        if (!acc[key]) {
          acc[key] = {
            month: new Date(year, month).toLocaleString("he", {
              month: "short",
            }),
            year: year,
            count: 0,
            active: 0,
            pending: 0,
            success: 0,
            declined: 0,
          };
        }

        acc[key].count += 1;

        if (s.category === "ACTIVE") acc[key].active += 1;
        if (s.category === "PENDING") acc[key].pending += 1;
        if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
        if (
          s.status === "FIRST_PARTY_DECLINED" ||
          s.status === "SECOND_PARTY_DECLINED"
        ) {
          acc[key].declined += 1;
        }

        return acc;
      },
      {} as Record<
        string,
        {
          month: string;
          year: number;
          count: number;
          active: number;
          pending: number;
          success: number;
          declined: number;
        }
      >
    );

    // Convert to array and sort by date
    const monthlyArray = Object.values(monthlyData).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      return a.month.localeCompare(b.month);
    });

    // Calculate trends
    const calculateTrend = (currentValue: number, previousValue: number) => {
      if (previousValue === 0) return currentValue > 0 ? 100 : 0;
      return Math.round(((currentValue - previousValue) / previousValue) * 100);
    };

    // Calculate success rate
    const successRate = total > 0 ? Math.round((success / total) * 100) : 0;

    // Get current month stats vs previous month for trend
    let activeTrend = 0;
    let pendingTrend = 0;
    let successTrend = 0;

    if (monthlyArray.length >= 2) {
      const currentMonth = monthlyArray[monthlyArray.length - 1];
      const previousMonth = monthlyArray[monthlyArray.length - 2];

      activeTrend = calculateTrend(currentMonth.active, previousMonth.active);
      pendingTrend = calculateTrend(
        currentMonth.pending,
        previousMonth.pending
      );
      successTrend = calculateTrend(
        currentMonth.success,
        previousMonth.success
      );
    }

    return {
      total,
      active,
      pending,
      history,
      approvedByFirst,
      approvedBySecond,
      declined,
      expired,
      dating,
      success,
      successRate,
      byStatus,
      monthlyData: monthlyArray,
      trends: {
        active: activeTrend,
        pending: pendingTrend,
        success: successTrend,
      },
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() => onFilterChange && onFilterChange({})}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: [
                "DATING",
                "FIRST_PARTY_APPROVED",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            })
          }
        />
        <StatsCard
          icon={Clock}
          title="ממתינות לתגובה"
          value={stats.pending}
          trend={{
            value: stats.trends.pending,
            isPositive: stats.trends.pending >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY"],
            })
          }
        />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${stats.successRate}%`}
          trend={{
            value: stats.trends.success,
            isPositive: stats.trends.success >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING", "ENGAGED", "MARRIED"],
            })
          }
        />
      </div>

      {/* Action Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-3 mt-4">
        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-yellow-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-yellow-600" />
            <div className="text-xs">ממתין לצד א׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_FIRST_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-blue-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_SECOND_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-blue-600" />
            <div className="text-xs">ממתין לצד ב׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_SECOND_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-red-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <X className="w-4 h-4 text-red-600" />
            <div className="text-xs">הצעות שנדחו</div>
            <div className="font-bold ml-auto">{stats.declined}</div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-pink-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Calendar className="w-4 h-4 text-pink-600" />
            <div className="text-xs">בתהליך היכרות</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["DATING"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-gray-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["EXPIRED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Ban className="w-4 h-4 text-gray-600" />
            <div className="text-xs">פג תוקף</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["EXPIRED"] || 0}
            </div>
          </div>
        </Card>
      </div>

      {/* מגמה חודשית נשארת כאן אבל עכשיו היא מוצגת בדיאלוג מודלי */}
      <div className="hidden">
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={stats.monthlyData}
                margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip
                  formatter={(value) => [`${value} הצעות`, ""]}
                  labelFormatter={(label) => `חודש ${label}`}
                />
                <Legend />
                <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
                <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
                <Bar dataKey="success" name="הצלחות" fill="#10B981" />
                <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;
--- End of Content for SuggestionsStats.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx
--------------------------------------------------------------------------------
Content:
// SuggestionDetailsDialog.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ProfileCard } from "@/app/components/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  AlertCircle,
  CheckCircle,
  XCircle,
  MessageCircle,
  Send,
  RefreshCw,
  Edit,
  Calendar,
  Clock,
  Download,
  AlarmClock,
  Trash2,
  MapPin,
  Mail,
  Phone,
  User,
  ExternalLink,
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { MatchSuggestionStatus } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";
import Image from "next/image";

// --- START OF FIX ---
// Define a specific type for all possible suggestion actions to ensure type safety
type SuggestionActionType =
  | "view" | "contact" | "message" | "edit" | "delete" | "resend"
  | "changeStatus" | "reminder" | "sendReminder" | "shareContacts"
  | "scheduleMeeting" | "viewMeetings" | "exportHistory" | "export"
  | "resendToAll";
// --- END OF FIX ---

interface DialogActionData extends ActionAdditionalData {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyId?: string;
  type?: string;
  partyType?: "first" | "second" | "both";
}

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  // --- START OF FIX ---
  // Update the onAction prop to use the specific type instead of a generic string
  onAction: (action: SuggestionActionType, data?: DialogActionData) => void;
  // --- END OF FIX ---
}

// Map status to its display info
const getStatusInfo = (status: MatchSuggestionStatus) => {
  const statusMap: Record<
    string,
    { label: string; icon: React.ElementType; color: string }
  > = {
    DRAFT: { label: "טיוטה", icon: Edit, color: "text-gray-600" },
    PENDING_FIRST_PARTY: {
      label: "ממתין לתשובת צד א׳",
      icon: Clock,
      color: "text-yellow-600",
    },
    FIRST_PARTY_APPROVED: {
      label: "צד א׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    FIRST_PARTY_DECLINED: {
      label: "צד א׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    PENDING_SECOND_PARTY: {
      label: "ממתין לתשובת צד ב׳",
      icon: Clock,
      color: "text-blue-600",
    },
    SECOND_PARTY_APPROVED: {
      label: "צד ב׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    SECOND_PARTY_DECLINED: {
      label: "צד ב׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    AWAITING_MATCHMAKER_APPROVAL: {
      label: "ממתין לאישור שדכן",
      icon: AlertCircle,
      color: "text-purple-600",
    },
    CONTACT_DETAILS_SHARED: {
      label: "פרטי קשר שותפו",
      icon: Send,
      color: "text-purple-600",
    },
    AWAITING_FIRST_DATE_FEEDBACK: {
      label: "ממתין למשוב פגישה",
      icon: MessageCircle,
      color: "text-orange-600",
    },
    DATING: {
      label: "בתהליך היכרות",
      icon: Calendar,
      color: "text-pink-600",
    },
    EXPIRED: { label: "פג תוקף", icon: AlarmClock, color: "text-gray-600" },
    CLOSED: { label: "סגור", icon: XCircle, color: "text-gray-600" },
  };
  return (
    statusMap[status] || {
      label: status as string,
      icon: AlertCircle as React.ElementType,
      color: "text-gray-600",
    }
  );
};

// Status groups for the progress indicator
const statusGroups = [
  ["DRAFT", "PENDING_FIRST_PARTY"],
  ["FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY"],
  ["SECOND_PARTY_APPROVED", "AWAITING_MATCHMAKER_APPROVAL"],
  ["CONTACT_DETAILS_SHARED", "AWAITING_FIRST_DATE_FEEDBACK"],
  ["DATING", "ENGAGED", "MARRIED"],
];
// הוספת מיפוי מלא של כל הסטטוסים האפשריים
const getAllStatusLabels = () => {
  // יצירת מיפוי של כל הסטטוסים האפשריים לפי הסכמה
  const statusLabels: Record<MatchSuggestionStatus, string> = {
    DRAFT: "טיוטה",
    PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
    FIRST_PARTY_APPROVED: "צד א׳ אישר",
    FIRST_PARTY_DECLINED: "צד א׳ דחה",
    PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
    SECOND_PARTY_APPROVED: "צד ב׳ אישר",
    SECOND_PARTY_DECLINED: "צד ב׳ דחה",
    AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
    CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
    AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
    THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
    PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
    ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
    MEETING_PENDING: "ממתין לקביעת פגישה",
    MEETING_SCHEDULED: "פגישה נקבעה",
    MATCH_APPROVED: "ההצעה אושרה",
    MATCH_DECLINED: "ההצעה נדחתה",
    DATING: "בתהליך היכרות",
    ENGAGED: "מאורסים",
    MARRIED: "נישאו",
    EXPIRED: "פג תוקף",
    CLOSED: "סגור",
    CANCELLED: "בוטל",
  };

  return statusLabels;
};
// Helper to determine if a status change is possible
const canChangeStatus = (
  currentStatus: MatchSuggestionStatus
): MatchSuggestionStatus[] => {
  // Status changes that are allowed directly by the matchmaker
  const allowedChanges: Partial<
    Record<MatchSuggestionStatus, MatchSuggestionStatus[]>
  > = {
    // סטטוסים קיימים
    DRAFT: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_FIRST_PARTY: [
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    FIRST_PARTY_APPROVED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    FIRST_PARTY_DECLINED: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_SECOND_PARTY: [
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    SECOND_PARTY_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    SECOND_PARTY_DECLINED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    CONTACT_DETAILS_SHARED: [
      "AWAITING_FIRST_DATE_FEEDBACK",
      "DATING",
      "CANCELLED",
      "CLOSED",
    ],
    AWAITING_FIRST_DATE_FEEDBACK: ["DATING", "CANCELLED", "CLOSED"],
    DATING: ["ENGAGED", "CLOSED"],
    ENGAGED: ["MARRIED", "CLOSED"],
    MARRIED: ["CLOSED"],
    EXPIRED: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY", "CLOSED"],
    CANCELLED: ["DRAFT"],
    CLOSED: [],

    // הוספת הסטטוסים החסרים
    AWAITING_MATCHMAKER_APPROVAL: [
      "CONTACT_DETAILS_SHARED",
      "CANCELLED",
      "CLOSED",
    ],
    THINKING_AFTER_DATE: [
      "PROCEEDING_TO_SECOND_DATE",
      "ENDED_AFTER_FIRST_DATE",
      "CLOSED",
    ],
    PROCEEDING_TO_SECOND_DATE: ["DATING", "CLOSED"],
    ENDED_AFTER_FIRST_DATE: ["CLOSED"],
    MEETING_PENDING: ["MEETING_SCHEDULED", "CANCELLED", "CLOSED"],
    MEETING_SCHEDULED: ["AWAITING_FIRST_DATE_FEEDBACK", "CANCELLED", "CLOSED"],
    MATCH_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    MATCH_DECLINED: ["CLOSED"],
  };

  return allowedChanges[currentStatus] || [];
};

const formatDateSafely = (
  dateInput: Date | string | null | undefined
): string => {
  if (!dateInput) return "לא נקבע";

  // Ensure we're working with a Date object
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;

  // Validate that the date is valid before formatting
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    return "תאריך לא תקין";
  }

  return new Intl.DateTimeFormat("he-IL", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(date);
};

const getDaysRemaining = (
  deadline: Date | string | null | undefined
): number | null => {
  if (!deadline) return null;

  // Convert string to Date if needed
  const deadlineDate =
    typeof deadline === "string" ? new Date(deadline) : deadline;

  // Validate date
  if (!(deadlineDate instanceof Date) || isNaN(deadlineDate.getTime())) {
    return null;
  }

  const today = new Date();
  const diffTime = deadlineDate.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
};

// Get the status group index for progress indicator
const getStatusGroupIndex = (status: MatchSuggestionStatus): number => {
  for (let i = 0; i < statusGroups.length; i++) {
    if (statusGroups[i].includes(status)) {
      return i;
    }
  }
  return -1;
};

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [statusChangeNote, setStatusChangeNote] = useState("");
  const [newStatus, setNewStatus] = useState<MatchSuggestionStatus | null>(
    null
  );
  const [showStatusChange, setShowStatusChange] = useState(false);

  // Calculate allowed status changes based on current status
  const allowedStatusChanges = suggestion
    ? canChangeStatus(suggestion.status as MatchSuggestionStatus)
    : [];

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  // Handle status change
  const handleStatusChange = async () => {
    if (!newStatus || !suggestion) return;

    setIsLoading(true);
    try {
      console.log(
        `שולח בקשה לשינוי סטטוס: ${newStatus} עם הערות: ${
          statusChangeNote || "ללא הערות"
        }`
      );
      // עדכון הקומפוננטה ההורה
      onAction("changeStatus", {
        suggestionId: suggestion.id,
        newStatus,
        notes: statusChangeNote,
      });

      // איפוס מצב הטופס
      setShowStatusChange(false);
      setStatusChangeNote("");
      setNewStatus(null);
    } catch (error) {
      console.error("Error changing status:", error);
      toast.error(
        `שגיאה בעדכון הסטטוס: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  };

  if (!suggestion) return null;

  // Get status display info
  const statusInfo = getStatusInfo(suggestion.status as MatchSuggestionStatus);
  const StatusIcon = statusInfo.icon;

  // Format suggestion dates
  const createdDate = suggestion.createdAt;
  const lastActivityDate = suggestion.lastActivity;
  const decisionDeadlineDate = suggestion.decisionDeadline
    ? suggestion.decisionDeadline
    : null;

  // Days remaining for decision if applicable
  const daysRemaining = decisionDeadlineDate
    ? getDaysRemaining(decisionDeadlineDate)
    : null;

  // Get status progress index for the progress indicator
  const statusGroupIndex = getStatusGroupIndex(
    suggestion.status as MatchSuggestionStatus
  );

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="max-w-6xl max-h-[90vh] flex flex-col p-0"
        style={{ direction: "rtl" }}
      >
        {/* Header with Progress Bar */}
        <div className="bg-gradient-to-r from-slate-50 to-white border-b flex-shrink-0">
          <DialogHeader className="p-6 pb-3">
            <div className="flex items-center justify-between">
              <div>
                <DialogTitle className="text-2xl font-bold">
                  הצעת שידוך #{suggestion.id.toString().split("-")[0]}
                </DialogTitle>
                <DialogDescription className="text-lg mt-1">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} ו
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName}
                </DialogDescription>
              </div>
              <div className="flex items-center gap-3">
                <Badge
                  className={`px-3 py-1.5 ${statusInfo.color} flex items-center gap-1 text-sm shadow-sm`}
                >
                  <StatusIcon className="w-4 h-4" />
                  {statusInfo.label}
                </Badge>
                <Badge
                  variant="outline"
                  className={`px-3 shadow-sm ${
                    suggestion.priority === "URGENT"
                      ? "bg-red-50 text-red-600 border-red-200"
                      : suggestion.priority === "HIGH"
                      ? "bg-orange-50 text-orange-600 border-orange-200"
                      : suggestion.priority === "MEDIUM"
                      ? "bg-blue-50 text-blue-600 border-blue-200"
                      : "bg-gray-50 text-gray-600 border-gray-200"
                  }`}
                >
                  {suggestion.priority === "URGENT"
                    ? "דחוף"
                    : suggestion.priority === "HIGH"
                    ? "עדיפות גבוהה"
                    : suggestion.priority === "MEDIUM"
                    ? "עדיפות רגילה"
                    : "עדיפות נמוכה"}
                </Badge>
              </div>
            </div>
          </DialogHeader>

          {/* Status Progress Indicator */}
          <div className="px-6 pb-4">
            <div className="relative flex items-center justify-between w-full h-3 bg-gray-100 rounded-full mt-4">
              {statusGroupIndex >= 0 && (
                <div
                  className="absolute h-3 bg-gradient-to-r from-blue-400 to-blue-600 rounded-full"
                  style={{
                    width: `${Math.min(
                      ((statusGroupIndex + 1) / statusGroups.length) * 100,
                      100
                    )}%`,
                  }}
                ></div>
              )}
              {statusGroups.map((_, index) => (
                <div
                  key={index}
                  className={`relative z-10 w-6 h-6 rounded-full flex items-center justify-center border-2 ${
                    index <= statusGroupIndex
                      ? "bg-blue-600 border-blue-700 text-white"
                      : "bg-white border-gray-300"
                  }`}
                >
                  {index + 1}
                </div>
              ))}
            </div>
            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
              <span>יצירת הצעה</span>
              <span>אישור ראשוני</span>
              <span>אישור סופי</span>
              <span>שיתוף פרטים</span>
              <span>בתהליך היכרות</span>
            </div>
          </div>
        </div>
        {/* Main Content Area */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex-1 flex flex-col overflow-hidden"
        >
          <TabsList className="px-6 pt-2 border-b justify-end gap-1 flex-shrink-0">
            <TabsTrigger
              value="overview"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              סקירה כללית
            </TabsTrigger>
            <TabsTrigger
              value="firstParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד ראשון
            </TabsTrigger>
            <TabsTrigger
              value="secondParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד שני
            </TabsTrigger>
            <TabsTrigger
              value="timeline"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              ציר זמן
            </TabsTrigger>
            <TabsTrigger
              value="communication"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              תקשורת
            </TabsTrigger>
            <TabsTrigger
              value="actions"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              פעולות
            </TabsTrigger>
          </TabsList>

          <div className="flex-1 overflow-y-auto">
            {/* Overview Tab */}

            <TabsContent
              value="overview"
              className="p-0 m-0 h-full overflow-auto"
            >
              <div className="p-6">
                {/* שינוי 1: שינוי המבנה כך שפרטי ההצעה יהיו בחלק העליון ושני הצדדים יהיו זה לצד זה */}
                <div className="space-y-3">
                  {/* פרטי הצעה - עיצוב מסודר וקומפקטי */}
                  <div className="bg-white rounded-xl shadow-sm border p-4 mb-3 hover:shadow-md transition-shadow">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="text-md font-semibold flex items-center">
                        <Calendar className="w-4 h-4 ml-1 text-blue-600" />
                        פרטי הצעה
                      </h3>
                      <Badge
                        className={`${statusInfo.color} px-2 py-0.5 text-xs`}
                      >
                        <StatusIcon className="w-3 h-3 ml-1" />
                        {statusInfo.label}
                      </Badge>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">תאריך יצירה:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(createdDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">עדכון אחרון:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(lastActivityDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">שדכן:</span>
                        <span className="font-medium mr-1">
                          {`${suggestion.matchmaker?.firstName} ${suggestion.matchmaker?.lastName}`}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">דחיפות:</span>
                        <span
                          className={`font-medium mr-1 ${
                            suggestion.priority === "URGENT"
                              ? "text-red-600"
                              : suggestion.priority === "HIGH"
                              ? "text-orange-600"
                              : suggestion.priority === "MEDIUM"
                              ? "text-blue-600"
                              : "text-gray-600"
                          }`}
                        >
                          {suggestion.priority === "URGENT"
                            ? "דחוף"
                            : suggestion.priority === "HIGH"
                            ? "עדיפות גבוהה"
                            : suggestion.priority === "MEDIUM"
                            ? "עדיפות רגילה"
                            : "עדיפות נמוכה"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד תגובה:</span>
                        <span className="font-medium mr-1">
                          {suggestion.responseDeadline
                            ? formatDateSafely(suggestion.responseDeadline)
                            : "לא נקבע"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד להחלטה:</span>
                        <span
                          className={
                            daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED"
                              ? "text-red-600 font-medium"
                              : "font-medium"
                          }
                        >
                          {decisionDeadlineDate
                            ? formatDateSafely(decisionDeadlineDate)
                            : "לא נקבע"}
                          {daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED" && (
                              <span className="mr-1 text-red-600 text-xs">
                                (
                                {daysRemaining === 0
                                  ? "היום!"
                                  : `נותרו ${daysRemaining} ימים`}
                                )
                              </span>
                            )}
                        </span>
                      </div>
                    </div>

                    <div className="flex justify-end mt-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowStatusChange(true)}
                        disabled={allowedStatusChanges.length === 0}
                        className="text-blue-600 border-blue-200 hover:bg-blue-50 text-xs py-1 h-7"
                      >
                        <RefreshCw className="w-3 h-3 ml-1" />
                        שנה סטטוס
                      </Button>
                    </div>
                  </div>

                  {/* שינוי 2: כרטיסי הצדדים מסודרים זה לצד זה בגריד עם 2 עמודות */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* First Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-blue-800">
                        <User className="w-5 h-5 ml-2 text-blue-600" />
                        צד א׳: {suggestion.firstParty.firstName}{" "}
                        {suggestion.firstParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.firstParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-blue-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.firstParty.firstName}{" "}
                            {suggestion.firstParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.firstPartySent
                              ? formatDateSafely(suggestion.firstPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "FIRST_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "FIRST_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_FIRST_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "FIRST_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "FIRST_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_FIRST_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.firstPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-blue-50 rounded-lg p-3 text-sm border border-blue-100">
                            {suggestion.firstPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-blue-200 hover:bg-blue-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_FIRST_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-yellow-500 hover:bg-yellow-600"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.firstParty.id,
                                partyType: "first",
                              })
                            }
                          >
                            <AlertCircle className="w-4 h-4 ml-2" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>

                    {/* Second Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-purple-800">
                        <User className="w-5 h-5 ml-2 text-purple-600" />
                        צד ב׳: {suggestion.secondParty.firstName}{" "}
                        {suggestion.secondParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.secondParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-purple-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.secondParty.firstName}{" "}
                            {suggestion.secondParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.secondPartySent
                              ? formatDateSafely(suggestion.secondPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "SECOND_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "SECOND_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_SECOND_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "SECOND_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "SECOND_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_SECOND_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.secondPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-purple-50 rounded-lg p-3 text-sm border border-purple-100">
                            {suggestion.secondPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-purple-200 hover:bg-purple-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_SECOND_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-purple-600 hover:bg-purple-700"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.secondParty.id,
                                partyType: "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* מידע נוסף */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
                    {/* Matching Reason Card */}
                    {suggestion.matchingReason && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <User className="w-5 h-5 ml-2 text-green-600" />
                          סיבת ההתאמה
                        </h3>
                        <div className="bg-green-50 rounded-lg border border-green-100 p-4 text-gray-700">
                          {suggestion.matchingReason}
                        </div>
                      </div>
                    )}

                    {/* Internal Notes */}
                    {suggestion.internalNotes && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <AlertCircle className="w-5 h-5 ml-2 text-amber-600" />
                          הערות פנימיות
                        </h3>
                        <div className="bg-amber-50 rounded-lg border border-amber-100 p-4 text-gray-700">
                          {suggestion.internalNotes}
                        </div>
                      </div>
                    )}

                    {/* Quick Actions */}
                    <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center">
                        <RefreshCw className="w-5 h-5 ml-2 text-gray-600" />
                        פעולות מהירות
                      </h3>

                      <div className="grid grid-cols-2 gap-2">
                        <Button
                          variant="outline"
                          className="justify-start"
                          onClick={() =>
                            onAction("edit", { suggestionId: suggestion.id, suggestion: suggestion })
                          }
                        >
                          <Edit className="w-4 h-4 ml-1" />
                          ערוך הצעה
                        </Button>

                        {(suggestion.status === "PENDING_FIRST_PARTY" ||
                          suggestion.status === "PENDING_SECOND_PARTY") && (
                          <Button
                            variant="outline"
                            className="justify-start"
                            onClick={() =>
                              onAction("sendReminder", {
                                suggestionId: suggestion.id,
                                type:
                                  suggestion.status === "PENDING_FIRST_PARTY"
                                    ? "first"
                                    : "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}

                        {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                          suggestion.status === "SECOND_PARTY_APPROVED") && (
                          <Button
                            variant="default"
                            className="justify-start bg-green-600 hover:bg-green-700"
                            onClick={() =>
                              onAction("shareContacts", {
                                suggestionId: suggestion.id,
                              })
                            }
                          >
                            <ExternalLink className="w-4 h-4 ml-1" />
                            שתף פרטי קשר
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* First Party Tab */}
            <TabsContent value="firstParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-blue-800">
                      {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-blue-100 text-blue-700 border-blue-200">
                      צד א׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.firstParty.images.find((img) => img.isMain)
                            ?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-blue-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty?.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.birthDate
                              ? new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-blue-200 hover:bg-blue-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.firstParty.id,
                          partyType: "first",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_FIRST_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד ראשון
                      </Button>
                    )}

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד שני
                      </Button>
                    )}

                    {suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyType: "both",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח בקשת עדכון מפגש
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.firstParty.profile}
                  images={suggestion.firstParty.images}
                  questionnaire={firstPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-blue-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.firstParty.firstName}
                  </h3>
                  {suggestion.firstPartyNotes ? (
                    <p>{suggestion.firstPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Second Party Tab */}
            <TabsContent value="secondParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-purple-800">
                      {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-purple-100 text-purple-700 border-purple-200">
                      צד ב׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.secondParty.images.find(
                            (img) => img.isMain
                          )?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-purple-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.birthDate
                              ? new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-purple-200 hover:bg-purple-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.secondParty.id,
                          partyType: "second",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="flex-1 bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-1" />
                        שלח תזכורת
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.secondParty.profile}
                  images={suggestion.secondParty.images}
                  questionnaire={secondPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-purple-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.secondParty.firstName}
                  </h3>
                  {suggestion.secondPartyNotes ? (
                    <p>{suggestion.secondPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Timeline Tab */}
            <TabsContent value="timeline" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 mb-4">
                  <h3 className="text-lg font-semibold flex items-center">
                    <Calendar className="w-5 h-5 ml-2 text-blue-600" />
                    התקדמות ההצעה
                  </h3>
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="p-2 rounded-full bg-blue-100 mr-2">
                        <Clock className="w-5 h-5 text-blue-600" />
                      </div>
                      <div>
                        <div className="font-medium">
                          נוצר: {formatDateSafely(suggestion.createdAt)}
                        </div>
                        <div className="text-sm text-gray-500">
                          פעילות אחרונה:{" "}
                          {formatDateSafely(suggestion.lastActivity)}
                        </div>
                      </div>
                    </div>
                    <Badge
                      className={`px-3 py-1.5 flex items-center gap-1 ${statusInfo.color}`}
                    >
                      <StatusIcon className="w-4 h-4" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border p-5">
                  <h3 className="text-lg font-semibold mb-4">
                    היסטוריית סטטוסים
                  </h3>

                  <ScrollArea className="h-[400px] pr-4">
                    {isLoading ? (
                      <div className="flex items-center justify-center h-32">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-700"></div>
                      </div>
                    ) : (
                      <Timeline
                        items={(suggestion?.statusHistory || []).map(
                          (history) => ({
                            title: getStatusInfo(
                              history.status as MatchSuggestionStatus
                            ).label,
                            description: history.notes || "אין הערות",
                            date:
                              typeof history.createdAt === "string"
                                ? new Date(history.createdAt)
                                : history.createdAt,
                            icon: history.status.includes("APPROVED")
                              ? CheckCircle
                              : history.status.includes("DECLINED")
                              ? XCircle
                              : history.status.includes("PENDING")
                              ? Clock
                              : AlertCircle,
                            iconColor: history.status.includes("APPROVED")
                              ? "text-green-600"
                              : history.status.includes("DECLINED")
                              ? "text-red-600"
                              : history.status.includes("PENDING")
                              ? "text-yellow-600"
                              : "text-blue-600",
                          })
                        )}
                      />
                    )}
                  </ScrollArea>

                  <div className="mt-4 flex justify-end">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() =>
                        onAction("exportHistory", {
                          suggestionId: suggestion.id,
                        })
                      }
                    >
                      <Download className="w-4 h-4 ml-1" />
                      ייצא היסטוריה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* Communication Tab */}
            <TabsContent value="communication" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-blue-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">תקשורת</h3>
                  <p className="text-gray-600">
                    ניהול התקשורת עם הצדדים השונים בהצעה. שליחת הודעות ותזכורות.
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* First Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-blue-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-blue-600" />
                      תקשורת עם {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full justify-start border-blue-200 hover:bg-blue-50"
                        onClick={() =>
                          onAction("message", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <MessageCircle className="w-4 h-4 ml-2" />
                        שלח הודעה
                      </Button>

                      {suggestion.status === "PENDING_FIRST_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>

                  {/* Second Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-purple-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-purple-600" />
                      תקשורת עם {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full"
                        onClick={() =>
                          onAction("edit", {
                            suggestionId: suggestion.id,
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <Edit className="w-4 h-4 ml-2" />
                        ערוך פרטי הצעה
                      </Button>

                      {suggestion.status === "PENDING_SECOND_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {/* Meeting Arrangement Section */}
                {(suggestion.status === "CONTACT_DETAILS_SHARED" ||
                  suggestion.status === "DATING") && (
                  <div className="mt-6 bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Calendar className="w-5 h-5 ml-2 text-pink-600" />
                      תיאום פגישה
                    </h4>
                    <div className="space-y-3">
                      <p className="text-gray-600">
                        סיוע בתיאום פגישה בין הצדדים ותיעוד מועדי הפגישות
                      </p>
                      <div className="flex gap-2">
                        <Button
                          className="flex-1 bg-pink-600 hover:bg-pink-700"
                          onClick={() =>
                            onAction("scheduleMeeting", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Calendar className="w-4 h-4 ml-2" />
                          תאם פגישה חדשה
                        </Button>
                        <Button
                          variant="outline"
                          className="flex-1"
                          onClick={() =>
                            onAction("viewMeetings", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Clock className="w-4 h-4 ml-2" />
                          צפה בפגישות קודמות
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </TabsContent>

            {/* Actions Tab */}
            <TabsContent value="actions" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-gray-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">פעולות נוספות</h3>
                  <p className="text-gray-600">
                    פעולות נוספות שניתן לבצע על הצעת השידוך
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {/* Status Change */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-blue-100 w-fit mb-3">
                      <RefreshCw className="w-6 h-6 text-blue-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">שינוי סטטוס</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עדכון סטטוס ההצעה בהתאם להתקדמות התהליך
                    </p>
                    <Button
                      className="w-full"
                      onClick={() => setShowStatusChange(true)}
                      disabled={allowedStatusChanges.length === 0}
                    >
                      <RefreshCw className="w-4 h-4 ml-2" />
                      שנה סטטוס
                    </Button>
                  </div>

                  {/* Edit Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-amber-100 w-fit mb-3">
                      <Edit className="w-6 h-6 text-amber-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">עריכת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עריכת פרטי ההצעה, סיבת ההתאמה והערות
                    </p>
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() =>
                        onAction("edit", { suggestionId: suggestion.id, suggestion: suggestion })
                      }
                    >
                      <Edit className="w-4 h-4 ml-2" />
                      ערוך פרטי הצעה
                    </Button>
                  </div>

                  {/* Delete Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-red-100 w-fit mb-3">
                      <Trash2 className="w-6 h-6 text-red-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">מחיקת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      מחיקת ההצעה לצמיתות מהמערכת
                    </p>
                    <Button
                      variant="outline"
                      className="border-red-200 hover:bg-red-50 text-red-600"
                      onClick={() =>
                        onAction("delete", { suggestionId: suggestion.id })
                      }
                    >
                      <Trash2 className="w-4 h-4 ml-1" />
                      מחק הצעה
                    </Button>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Resend to Both Parties */}
                  {canChangeStatus(
                    suggestion.status as MatchSuggestionStatus
                  ).includes("PENDING_FIRST_PARTY") && (
                    <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                      <h4 className="text-lg font-semibold mb-3 flex items-center">
                        <Send className="w-5 h-5 ml-2 text-purple-600" />
                        שליחה מחדש
                      </h4>
                      <p className="text-sm text-gray-600 mb-3">
                        שליחת ההצעה מחדש לשני הצדדים
                      </p>
                      <Button
                        className="w-full bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("resendToAll", {
                            suggestionId: suggestion.id,
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-2" />
                        שלח מחדש לשני הצדדים
                      </Button>
                    </div>
                  )}

                  {/* Export Suggestion Details */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Download className="w-5 h-5 ml-2 text-green-600" />
                      ייצוא פרטי הצעה
                    </h4>
                    <p className="text-sm text-gray-600 mb-3">
                      ייצוא כל פרטי ההצעה בפורמט PDF או CSV
                    </p>
                    <Button
                      variant="outline"
                      className="w-full border-green-200 hover:bg-green-50 text-green-700"
                      onClick={() =>
                        onAction("export", { suggestionId: suggestion.id })
                      }
                    >
                      <Download className="w-4 h-4 ml-2" />
                      ייצא פרטי הצעה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>
          </div>
        </Tabs>
        {/* Status Change Dialog */}
        {showStatusChange && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-xl max-w-md w-full shadow-lg">
              <h3 className="text-xl font-bold mb-4 flex items-center">
                <RefreshCw className="w-5 h-5 ml-2 text-blue-600" />
                שינוי סטטוס הצעה
              </h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס נוכחי
                  </label>
                  <div className="flex items-center p-2 bg-gray-50 rounded border">
                    <StatusIcon
                      className={`w-5 h-5 ml-2 ${statusInfo.color}`}
                    />
                    <span className="font-medium">{statusInfo.label}</span>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס חדש
                  </label>
                  <Select
                    value={newStatus || undefined}
                    onValueChange={(value) => {
                      console.log("Selected new status:", value);
                      setNewStatus(value as MatchSuggestionStatus);
                    }}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="בחר/י סטטוס חדש" />
                    </SelectTrigger>
                    <SelectContent className="max-h-80 overflow-y-auto">
                      {/* מציג את כל הסטטוסים האפשריים במערכת */}
                      {Object.entries(getAllStatusLabels()).map(
                        ([status, label]) => (
                          <SelectItem key={status} value={status}>
                            {label}
                          </SelectItem>
                        )
                      )}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    הערות לשינוי סטטוס
                  </label>
                  <Textarea
                    value={statusChangeNote}
                    onChange={(e) => setStatusChangeNote(e.target.value)}
                    placeholder="הערות אופציונליות לשינוי הסטטוס..."
                    className="min-h-[100px] resize-none"
                  />
                </div>

                <div className="flex justify-end gap-2 pt-2">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowStatusChange(false);
                      setNewStatus(null);
                      setStatusChangeNote("");
                    }}
                  >
                    ביטול
                  </Button>
                  <Button
                    onClick={handleStatusChange}
                    disabled={!newStatus || isLoading}
                    className="bg-blue-600 hover:bg-blue-700"
                  >
                    {isLoading ? (
                      <>
                        <div className="h-4 w-4 ml-2 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                        מעדכן...
                      </>
                    ) : (
                      "שמור שינוי"
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}
        <DialogFooter className="px-6 py-4 border-t bg-gray-50">
          <div className="flex justify-between w-full">
            <Button
              variant="outline"
              className="border-red-200 hover:bg-red-50 text-red-600"
              onClick={() =>
                onAction("delete", { suggestionId: suggestion.id })
              }
            >
              <Trash2 className="w-4 h-4 ml-1" />
              מחק הצעה
            </Button>

            <div className="flex gap-2">
              <Button variant="outline" onClick={onClose}>
                סגור
              </Button>
              <Button
                // תיקון: המקום השלישי בו צריך לוודא שהפונקציה מופעלת נכון
                onClick={() => setShowStatusChange(true)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <RefreshCw className="w-4 h-4 ml-1" />
                עדכן סטטוס
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;
--- End of Content for SuggestionDetailsDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks\useMatchmaking.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS } from '../../new/constants/matchingCriteria';
import type { User } from '@/types/next-auth';
// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: User[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: User;
  candidateB: User;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: User;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile?.gender === candidateB.profile?.gender ||
          candidateA.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA.profile, candidateB.profile);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;
--- End of Content for useMatchmaking.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Users } from "lucide-react";

import type { Suggestion, SuggestionFilters } from "@/types/suggestions";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: SuggestionFilters;
  searchQuery: string;
  type: "active" | "pending" | "history";
  onSuggestionDeleted?: (id: string) => void;
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
  onSuggestionDeleted,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [, setShowDeleteDialog] = useState(false);
  const [suggestionToDelete, setSuggestionToDelete] = useState<string | null>(
    null
  );

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Priority filter
      if (
        filters.priority?.length &&
        !filters.priority.includes(suggestion.priority)
      ) {
        return false;
      }

      // Date range filter
      if (filters.dateRange) {
        const createdAt = new Date(suggestion.createdAt);
        if (
          createdAt < filters.dateRange.start ||
          createdAt > filters.dateRange.end
        ) {
          return false;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const confirmDelete = async () => {
    if (!suggestionToDelete) return;

    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionToDelete}/delete`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to delete suggestion");
      }

      toast.success("ההצעה נמחקה בהצלחה");
      if (onSuggestionDeleted) {
        onSuggestionDeleted(suggestionToDelete);
      }
    } catch (error) {
      console.error("Error deleting suggestion:", error);
      toast.error("שגיאה במחיקת ההצעה");
    } finally {
      setShowDeleteDialog(false);
      setSuggestionToDelete(null);
    }
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                {/* Rest of the JSX remains the same */}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />

      <AlertDialog>
        {" "}
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
            <AlertDialogDescription>
              פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              מחיקה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default ManagerSuggestionsList;
--- End of Content for ManagerSuggestionsList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useMemo } from "react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Search, Filter, SortDesc } from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";
import SuggestionCard from "../cards/SuggestionCard";
import { LoadingContainer } from "../../new/shared/LoadingStates";
import type {
  Suggestion,
  ActionAdditionalData,
  SuggestionStatusHistory,
} from "@/types/suggestions";

interface PartyInfo {
  id: string;
  firstName: string;
  lastName: string;
  profile: UserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: SuggestionStatusHistory[]; // הוספת השדה החסר
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  isLoading?: boolean;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const SORT_OPTIONS = [
  { value: "latest", label: "החדשים ביותר" },
  { value: "oldest", label: "הישנים ביותר" },
  { value: "deadline", label: "לפי תאריך יעד" },
  { value: "priority", label: "לפי דחיפות" },
];

const STATUS_OPTIONS = [
  { value: "PENDING_FIRST_PARTY", label: "ממתין לצד א׳" },
  { value: "PENDING_SECOND_PARTY", label: "ממתין לצד ב׳" },
  { value: "FIRST_PARTY_APPROVED", label: "צד א׳ אישר" },
  { value: "SECOND_PARTY_APPROVED", label: "צד ב׳ אישר" },
  { value: "CONTACT_DETAILS_SHARED", label: "פרטי קשר שותפו" },
  { value: "DATING", label: "בתהליך היכרות" },
];

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions,
  isLoading = false,
  onAction,
  className,
}) => {
  // Filters state
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState("latest");
  const [statusFilter, setStatusFilter] = useState<string[]>([]);
  const [showFilters, setShowFilters] = useState(false);

  // Filter and sort suggestions
  const filteredSuggestions = useMemo(() => {
    let result = [...suggestions];

    // Apply status filter
    if (statusFilter.length > 0) {
      result = result.filter((s) => statusFilter.includes(s.status));
    }

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (s) =>
          s.firstParty.firstName.toLowerCase().includes(query) ||
          s.firstParty.lastName.toLowerCase().includes(query) ||
          s.secondParty.firstName.toLowerCase().includes(query) ||
          s.secondParty.lastName.toLowerCase().includes(query) ||
          s.firstParty.profile.city?.toLowerCase().includes(query) ||
          s.secondParty.profile.city?.toLowerCase().includes(query)
      );
    }

    // Apply sorting
    switch (sortBy) {
      case "latest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
        );
        break;
    }

    return result;
  }, [suggestions, searchQuery, sortBy, statusFilter]);

  return (
    <div className={className}>
      {/* Filters Bar */}
      <div className="mb-6 space-y-4">
        <div className="flex gap-4">
          <div className="relative flex-1">
            <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
            <Input
              placeholder="חיפוש לפי שם או עיר..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 text-right"
            />
          </div>

          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-48">
              <SortDesc className="w-4 h-4 ml-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {SORT_OPTIONS.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Button
            variant="outline"
            onClick={() => setShowFilters(!showFilters)}
          >
            <Filter className="w-4 h-4 ml-2" />
            סינון
          </Button>
        </div>

        {showFilters && (
          <div className="flex gap-4">
            {STATUS_OPTIONS.map((status) => (
              <Button
                key={status.value}
                variant={
                  statusFilter.includes(status.value) ? "default" : "outline"
                }
                onClick={() => {
                  setStatusFilter((prev) =>
                    prev.includes(status.value)
                      ? prev.filter((s) => s !== status.value)
                      : [...prev, status.value]
                  );
                }}
                className="text-sm"
              >
                {status.label}
              </Button>
            ))}
          </div>
        )}
      </div>

      {/* Suggestions Grid */}
      {isLoading ? (
        <LoadingContainer>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <div
                key={i}
                className="h-64 bg-gray-100 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </LoadingContainer>
      ) : (
        // בערך בשורה 196 - שנה את הגריד להצגה מימין לשמאל
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
          {filteredSuggestions.map((suggestion) => (
            <SuggestionCard
              key={suggestion.id}
              suggestion={suggestion as unknown as Suggestion}
              onAction={onAction}
              className="rtl" // הוסף מחלקה זו
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default SuggestionsList;
--- End of Content for SuggestionsList.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\NotificationService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/NotificationService.ts

import { MatchSuggestionStatus } from '@prisma/client';
import { SuggestionWithParties } from '../suggestions/StatusTransitionService';

export type RecipientInfo = {
  email: string;
  phone?: string; // Phone number with international prefix, e.g.: +972501234567
  name: string;
};

export type NotificationContent = {
  subject: string;
  body: string;
  htmlBody?: string; // HTML version for email
};

export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
  channels: NotificationChannel[];
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
  priority?: 'high' | 'normal' | 'low';
  attachments?: Array<{
    filename: string;
    content: Buffer | string;
    contentType: string;
  }>;
  customMessage?: string;
  metadata?: Record<string, unknown>;
};

export interface NotificationAdapter {
  canSendTo(recipient: RecipientInfo): boolean;
  send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean>;
  getChannelType(): NotificationChannel;
}

export class NotificationService {
  private static instance: NotificationService;
  private adapters: Map<NotificationChannel, NotificationAdapter> = new Map();

  private constructor() {}

  public static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  public registerAdapter(adapter: NotificationAdapter): void {
    this.adapters.set(adapter.getChannelType(), adapter);
    console.log(`Registered ${adapter.getChannelType()} adapter`);
  }

  public async sendNotification(
    recipient: RecipientInfo,
    content: NotificationContent,
    options: NotificationOptions
  ): Promise<Record<NotificationChannel, boolean>> {
    const results: Record<NotificationChannel, boolean> = {} as Record<NotificationChannel, boolean>;
    console.log(`Attempting to send notification to ${recipient.name} via channels:`, options.channels);

    for (const channel of options.channels) {
      const adapter = this.adapters.get(channel);
      if (!adapter) {
        console.warn(`No adapter registered for channel: ${channel}`);
        results[channel] = false;
        continue;
      }

      if (!adapter.canSendTo(recipient)) {
        console.warn(`Cannot send to recipient via ${channel}: missing required info`);
        results[channel] = false;
        continue;
      }

      try {
        console.log(`Sending ${channel} notification to ${recipient.name}`);
        results[channel] = await adapter.send(recipient, content);
        console.log(`${channel} notification sent successfully: ${results[channel]}`);
      } catch (error) {
        console.error(`Error sending notification via ${channel}:`, error);
        results[channel] = false;
      }
    }

    return results;
  }

  // Dedicated method for handling suggestion-related notifications
  public async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
    options: Partial<NotificationOptions> = {}
  ): Promise<void> {
    console.log(`Processing notifications for suggestion ${suggestion.id} with status ${suggestion.status}`);
    
    const templateContent = this.getSuggestionTemplate(suggestion, options.customMessage);
    if (!templateContent) {
      console.log(`No template found for status ${suggestion.status} - skipping notification`);
      return;
    }
  
    const recipientsWithChannels = this.getRecipientsForSuggestion(suggestion);
    console.log(`Found ${recipientsWithChannels.length} potential recipients`);
  
    for (const { recipient, preferredChannels } of recipientsWithChannels) {
      // Filter recipients based on notifyParties if provided
      if (options.notifyParties) {
        const recipientType = this.getRecipientType(recipient, suggestion);
        if (!recipientType || !options.notifyParties.includes(recipientType)) {
          console.log(`Skipping recipient ${recipient.name} (${recipientType}) - not in notifyParties`, options.notifyParties);
          continue;
        }
      }
      
      const channelsToUse = options.channels || preferredChannels || ['email'];
      console.log(`Sending notification to ${recipient.name} via channels:`, channelsToUse);
      
      await this.sendNotification(
        recipient,
        templateContent,
        { ...options, channels: channelsToUse }
      );
    }
    
    console.log(`Finished processing notifications for suggestion ${suggestion.id}`);
  }

  // Helper method to determine recipient type
  private getRecipientType(
    recipient: RecipientInfo, 
    suggestion: SuggestionWithParties
  ): 'first' | 'second' | 'matchmaker' | null {
    if (recipient.email === suggestion.firstParty.email) {
      return 'first';
    } else if (recipient.email === suggestion.secondParty.email) {
      return 'second';
    } else if (recipient.email === suggestion.matchmaker.email) {
      return 'matchmaker';
    }
    return null;
  }

  private getSuggestionTemplate(
    suggestion: SuggestionWithParties,
    customMessage?: string
  ): NotificationContent | null {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    // If there's a custom message, use it instead of the template
    if (customMessage) {
      const reviewUrl = `${baseUrl}/suggestions/${suggestion.id}/review`;
      return {
        subject: "עדכון בהצעת שידוך",
        body: `שלום,\n\n${customMessage}\n\nלצפייה בפרטי ההצעה: ${reviewUrl}\n\nבברכה,\nמערכת השידוכים`,
        htmlBody: `
          <div dir="rtl">
            <h2>שלום,</h2>
            <p>${customMessage}</p>
            <p>לצפייה בפרטי ההצעה: <a href="${reviewUrl}">לחץ כאן</a></p>
            <p>בברכה,<br>מערכת השידוכים</p>
          </div>
        `
      };
    }
    
    // Otherwise use the template based on status
    switch (suggestion.status) {
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.firstParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.firstParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בהצעה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.\n\nההצעה תועבר כעת באופן אוטומטי לצד השני.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.</p><p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.secondParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nהצד הראשון כבר אישר את ההצעה.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.secondParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>הצד הראשון כבר אישר את ההצעה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בפרטי ההצעה ומענה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.\n\nשני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.</p><p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
    
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Prepare contact details with multi-line support
        const firstPartyDetails = this.formatUserDetails(suggestion.firstParty);
        const secondPartyDetails = this.formatUserDetails(suggestion.secondParty);
        
        return {
          subject: 'פרטי קשר להצעת השידוך',
          body: `ברכות! שני הצדדים אישרו את הצעת השידוך.\n\nפרטי הקשר של הצד הראשון:\n${firstPartyDetails}\n\nפרטי הקשר של הצד השני:\n${secondPartyDetails}\n\nאנא צרו קשר בהקדם לתיאום פגישה ראשונה.\n\nבהצלחה!`,
          htmlBody: `<div dir="rtl"><h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2><p>פרטי הקשר של הצד הראשון:</p><pre>${firstPartyDetails}</pre><p>פרטי הקשר של הצד השני:</p><pre>${secondPartyDetails}</pre><p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p><p>בהצלחה!</p></div>`
        };
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return {
          subject: 'בקשה למשוב על הפגישה הראשונה',
          body: `שלום,\n\nנשמח לקבל את המשוב שלך על הפגישה הראשונה.\n\nלשליחת המשוב: ${baseUrl}/suggestions/${suggestion.id}/feedback\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום,</h2><p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/feedback">לשליחת המשוב</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
        return {
          subject: 'בקשת זמן למחשבה לאחר הפגישה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nאחד הצדדים ביקש זמן למחשבה לאחר הפגישה.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.DATING:
        return {
          subject: 'עדכון סטטוס - בתהליך היכרות',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהזוג נמצא בתהליך היכרות.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הזוג נמצא בתהליך היכרות.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.ENGAGED:
        return {
          subject: 'מזל טוב! - אירוסין',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.MARRIED:
        return {
          subject: 'מזל טוב! - חתונה',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.EXPIRED:
        return {
          subject: 'הצעת השידוך פגה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהצעת השידוך פגה עקב חוסר מענה במועד.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הצעת השידוך פגה עקב חוסר מענה במועד.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      default:
        // For other statuses, return null to skip notification
        console.log(`No template defined for status: ${suggestion.status}`);
        return null;
    }
  }

  private getRecipientsForSuggestion(suggestion: SuggestionWithParties): Array<{
    recipient: RecipientInfo;
    preferredChannels: NotificationChannel[];
  }> {
    const recipients: Array<{
      recipient: RecipientInfo;
      preferredChannels: NotificationChannel[];
    }> = [];
    
    // Logic to determine recipients based on suggestion status
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email'] // Email only for drafts
        });
        break;
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.firstParty.email,
            phone: suggestion.firstParty.phone || undefined,
            name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.secondParty.email,
            phone: suggestion.secondParty.phone || undefined,
            name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email']
          }
        );
        break;
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        // Send to both parties
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;
      
      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;

      default:
        // Default: send to matchmaker only
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email']
        });
        break;
    }

    return recipients;
  }

  // Helper function to format contact details
  private formatUserDetails(user: { 
    firstName: string; 
    lastName: string; 
    email: string; 
    phone?: string | null 
  }): string {
    const details = [
      `שם: ${user.firstName} ${user.lastName}`,
      `אימייל: ${user.email}`,
    ];

    if (user.phone) {
      details.push(`טלפון: ${user.phone}`);
    }

    return details.join('\n');
  }
}

export const notificationService = NotificationService.getInstance();
--- End of Content for NotificationService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\initNotifications.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/initNotifications.ts

import { notificationService } from './NotificationService';
import { emailAdapter } from './adapters/EmailAdapter';
import { whatsAppAdapter } from './adapters/WhatsAppAdapter';

// Define notification channel type
export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
    channels: NotificationChannel[];
    notifyParties?: ('first' | 'second' | 'matchmaker')[];
    customMessage?: string;
  };

/**
 * Initializes the notification service by registering all available adapters
 * @returns The initialized notification service
 */
export function initNotificationService() {
  // Register adapters
  notificationService.registerAdapter(emailAdapter);
  notificationService.registerAdapter(whatsAppAdapter);
  
  console.log('Notification service initialized with email and WhatsApp adapters');
  
  return notificationService;
}
--- End of Content for initNotifications.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\EmailAdapter.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/adapters/EmailAdapter.ts

import { NotificationAdapter, NotificationChannel, RecipientInfo, NotificationContent } from '../NotificationService';
import nodemailer from 'nodemailer';

export class EmailAdapter implements NotificationAdapter {
  private static instance: EmailAdapter;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure the transporter exactly like in EmailService
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER || '',
        pass: process.env.GMAIL_APP_PASSWORD || '',
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on initialization
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig(): Promise<void> {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw, to allow the system to continue even if verification fails
    }
  }

  public static getInstance(): EmailAdapter {
    if (!EmailAdapter.instance) {
      EmailAdapter.instance = new EmailAdapter();
    }
    return EmailAdapter.instance;
  }

  public getChannelType(): NotificationChannel {
    return 'email';
  }

  public canSendTo(recipient: RecipientInfo): boolean {
    return !!recipient.email;
  }

  public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
    try {
      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME || 'מערכת השידוכים'} <${process.env.GMAIL_USER || ''}>`,
        to: recipient.email,
        subject: content.subject,
        text: content.body,
        html: content.htmlBody || content.body.replace(/\n/g, '<br>'),
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
        to: recipient.email,
        subject: content.subject
      });

      return true;
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        recipient: recipient.email,
        subject: content.subject
      });
      return false;
    }
  }
}

export const emailAdapter = EmailAdapter.getInstance();
--- End of Content for EmailAdapter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\WhatsAppAdapter.ts
--------------------------------------------------------------------------------
Content:
// lib/WhatsAppAdapter.ts
import {
  NotificationAdapter,
  NotificationChannel,
  RecipientInfo,
  NotificationContent as BaseNotificationContent
} from '../NotificationService'; // Assuming NotificationService.ts exists in the same directory
import twilio from 'twilio';
// Import the specific type for message creation options if available
import { MessageListInstanceCreateOptions } from 'twilio/lib/rest/api/v2010/account/message';

// --- Define an extended NotificationContent interface ---
// This adds the optional adapter-specific data structure
interface NotificationContent extends BaseNotificationContent {
  _adapterSpecificData?: {
      contentSid?: string;
      contentVariables?: string; // Should be a JSON string
      // Add other potential adapter-specific fields here
  };
}
// --- End Interface Extension ---

// --- Type Guard for Twilio-like Errors ---
interface PotentialTwilioError {
  code?: number | string;
  message?: string;
  // Add other potential properties like 'status', 'moreInfo', etc. if needed
}

/**
* Type guard to check if an unknown error object might be a Twilio API error
* by checking for the presence of 'code' or 'message' properties.
* @param error The unknown value caught in a catch block.
* @returns True if the error object has properties common to Twilio errors, false otherwise.
*/
function isPotentialTwilioError(error: unknown): error is PotentialTwilioError {
  // Check if it's a non-null object and has either 'code' or 'message' property
  return typeof error === 'object' && error !== null && ('code' in error || 'message' in error);
}
// --- End Type Guard ---

// --- Helper: Logger (optional but recommended) ---
// Using Record<string, unknown> or object instead of any
const logger = {
info: (message: string, meta?: Record<string, unknown> | object) => {
  console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
warn: (message: string, meta?: Record<string, unknown> | object) => {
  console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
error: (message: string, meta?: Record<string, unknown> | object) => {
  let logMeta = meta || {};
  // If the meta object itself is an Error, extract relevant info
  if (meta instanceof Error) {
      logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
  } else if (isPotentialTwilioError(meta)) {
      // If it's potentially a Twilio error passed directly
      logMeta = { code: meta.code, message: meta.message, ...meta };
  }
  console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', service: 'WhatsAppAdapter', message, ...logMeta }));
},
};
// --- End Logger ---


export class WhatsAppAdapter implements NotificationAdapter {
// Singleton instance
private static instance: WhatsAppAdapter;
// Twilio client instance (typed)
private client: twilio.Twilio | null = null;
// Configured Twilio WhatsApp sender number
private fromNumber: string = '';

/**
 * Private constructor to enforce singleton pattern.
 * Initializes the Twilio client using environment variables.
 */
private constructor() {
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  this.fromNumber = process.env.TWILIO_WHATSAPP_NUMBER || ''; // Get number from env

  // Validate configuration
  if (!accountSid || !authToken || !this.fromNumber) {
    logger.error('Missing Twilio configuration details', {
        hasSid: !!accountSid,
        hasToken: !!authToken,
        hasWhatsAppNumber: !!this.fromNumber,
        detail: "WhatsApp notifications will be unavailable."
    });
    // Do not throw, allow graceful degradation if possible
  } else {
    try {
      // Initialize Twilio client
      this.client = twilio(accountSid, authToken);
      logger.info('Twilio client initialized successfully', { fromWhatsAppNumber: this.fromNumber });
    } catch (error: unknown) { // Catch as unknown
      logger.error('Failed to initialize Twilio client during constructor', { error });
      this.client = null; // Ensure client is null on initialization failure
    }
  }
}

/**
 * Gets the singleton instance of the WhatsAppAdapter.
 * @returns The WhatsAppAdapter instance.
 */
public static getInstance(): WhatsAppAdapter {
  if (!WhatsAppAdapter.instance) {
    WhatsAppAdapter.instance = new WhatsAppAdapter();
  }
  return WhatsAppAdapter.instance;
}

/**
 * Returns the channel type handled by this adapter.
 * @returns The notification channel type ('whatsapp').
 */
public getChannelType(): NotificationChannel {
  return 'whatsapp';
}

/**
 * Checks if this adapter is capable of sending a notification to the given recipient.
 * Requires a valid phone number, an initialized Twilio client, and a configured 'from' number.
 * @param recipient Information about the recipient.
 * @returns True if the adapter can send, false otherwise.
 */
public canSendTo(recipient: RecipientInfo): boolean {
  const hasValidPhone = !!recipient.phone && recipient.phone.length > 8; // Basic validation
  const isClientReady = this.client !== null;
  const hasFromNumber = this.fromNumber !== '';
  const canSend = hasValidPhone && isClientReady && hasFromNumber;

  if (!canSend) {
      let reason = 'Unknown';
      if (!hasValidPhone) reason = 'Invalid or missing phone number';
      else if (!isClientReady) reason = 'Twilio client not initialized';
      else if (!hasFromNumber) reason = 'Twilio "from" number not configured';
      logger.warn('Cannot send WhatsApp message due to configuration or recipient data', {
          reason: reason,
          recipientPhone: recipient.phone // Log phone for debugging
      });
  }
  return canSend;
}

/**
 * Formats a phone number into E.164 standard without the leading '+'.
 * Required for Twilio's `to` parameter when prefixed with `whatsapp:`.
 * Handles Israeli numbers starting with '0'.
 * Example: 0501234567 -> 972501234567
 * @param phone The phone number string to format.
 * @returns The formatted phone number string.
 */
private formatPhoneNumber(phone: string): string {
  // Remove all non-digit characters
  let cleaned = phone.replace(/\D/g, '');
  // Prepend country code for Israeli numbers if '0' prefix exists
  if (cleaned.startsWith('0')) {
    cleaned = '972' + cleaned.substring(1);
  }
  // Remove leading '+' if present (it's added later in the `whatsapp:` prefix)
  if (cleaned.startsWith('+')) {
    cleaned = cleaned.substring(1);
  }
  return cleaned;
}

/**
 * Sends a notification via WhatsApp using the Twilio API.
 * Prefers using template messages if configured via `_adapterSpecificData`.
 * Falls back to raw text messages otherwise (less reliable for business-initiated messages).
 * @param recipient Information about the recipient.
 * @param content The notification content, potentially including adapter-specific data.
 * @returns A promise that resolves to true if the message was successfully queued by Twilio, false otherwise.
 */
public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
  logger.info('Attempting to send WhatsApp message', {
    recipientPhone: recipient.phone,
    fromNumber: this.fromNumber,
    hasClient: !!this.client,
    contentSid: content._adapterSpecificData?.contentSid,
    hasContentVariables: !!content._adapterSpecificData?.contentVariables,
  });

  // --- Pre-send Checks ---
  if (!this.client) {
    logger.error('Twilio client not initialized. Cannot send WhatsApp message.');
    return false;
  }
  if (!recipient.phone) {
    logger.error('Recipient phone number is missing. Cannot send WhatsApp message.');
    return false;
  }
  if (!this.fromNumber) {
      logger.error('Twilio "from" WhatsApp number is not configured. Cannot send message.');
      return false;
  }
  // --- End Pre-send Checks ---


  try {
    // --- Format Numbers ---
    const toNumberE164 = this.formatPhoneNumber(recipient.phone);
    // Ensure 'from' number has '+' prefix for the whatsapp: schema
    const fromWhatsAppFormatted = `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`;
    // Ensure 'to' number has '+' prefix for the whatsapp: schema
    const toWhatsAppFormatted = `whatsapp:+${toNumberE164}`;

    logger.info(`Formatted numbers for sending via Twilio`, { from: fromWhatsAppFormatted, to: toWhatsAppFormatted });
    // --- End Format Numbers ---


    // --- Prepare Message Payload ---
    let messagePayload: MessageListInstanceCreateOptions;
    const adapterData = content._adapterSpecificData;

    if (adapterData?.contentSid && adapterData?.contentVariables) {
       // **Use Template Messaging**
       logger.info(`Preparing WhatsApp template message`, { contentSid: adapterData.contentSid });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          contentSid: adapterData.contentSid, // The approved template SID
          contentVariables: adapterData.contentVariables, // JSON string of variables {"1": "value1", "2": "value2"}
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    } else {
       // **Use Raw Text Messaging (Fallback)**
       // Note: This might fail if outside the 24-hour customer service window
       // or if WhatsApp/Twilio policies require templates for this type of message.
       const bodyText = content.body || content.subject || 'הודעה ממערכת השידוכים'; // Determine fallback content
       logger.warn(`Preparing raw text WhatsApp message (using fallback, might fail)`, { bodyLength: bodyText.length });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          body: bodyText, // The actual text message content
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    }
    // --- End Prepare Message Payload ---


    // --- Send Message via Twilio API ---
    logger.info("Sending message payload to Twilio API", { payload: messagePayload }); // Be cautious logging full payload in production if sensitive
    const message = await this.client.messages.create(messagePayload);
    // --- End Send Message ---


    // --- Log Success ---
    // The message status here is typically 'queued' or 'sending'. Delivery confirmation is asynchronous.
    logger.info('WhatsApp message request processed successfully by Twilio', {
      messageSid: message.sid,
      status: message.status,
      to: toWhatsAppFormatted,
      from: fromWhatsAppFormatted,
      price: message.price, // Log cost if available
      priceUnit: message.priceUnit,
      errorCode: message.errorCode, // Log if Twilio detected an error immediately
      errorMessage: message.errorMessage,
    });
    // We return true because Twilio accepted the request. Delivery is not guaranteed at this point.
    return true;
    // --- End Log Success ---

  } catch (error: unknown) { // Catch error as unknown
    // --- Handle Errors ---
    let errorMessage = 'Unknown error occurred while sending WhatsApp message.';
    let errorCode: number | string | undefined;

    // Use the type guard to safely access potential error properties
    if (isPotentialTwilioError(error)) {
        errorCode = error.code;
        errorMessage = error.message || errorMessage;
    } else if (error instanceof Error) {
        // Standard JavaScript Error
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        // Simple string error
        errorMessage = error;
    }

    // Log detailed error information
    logger.error('Failed to send WhatsApp message via Twilio', {
      errorCode,
      errorMessage,
      recipient: `whatsapp:+${this.formatPhoneNumber(recipient.phone)}`, // Log formatted number for debugging
      from: `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`,
      // Pass the original error object for full details in structured logs
      errorDetails: error
    });

    // Specific handling/logging for common, informative errors
    if (errorCode === 63018 || errorCode === 21614) { // Common codes for non-WhatsApp/incapable numbers
         logger.error(`Recipient number appears invalid or not registered on WhatsApp.`, { phone: recipient.phone, errorCode });
         // Consider adding logic here: maybe mark the user's number as invalid? Notify admin?
    } else if (errorCode === 63016) { // Common code for failing outside the 24-hour window without a template
          logger.warn(`Failed to send non-template message outside 24-hour window.`, { phone: recipient.phone, errorCode });
    }

    return false; // Indicate that sending failed
    // --- End Handle Errors ---
  }
}
}

// Export the singleton instance for use in other parts of the application
export const whatsAppAdapter = WhatsAppAdapter.getInstance();
--- End of Content for WhatsAppAdapter.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\StatusTransitionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService.ts

import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { notificationService } from "../notification/NotificationService";


type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type TransitionOptions = {
  sendNotifications?: boolean;
  customMessage?: string;
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string,
    options: TransitionOptions = {}
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;
    const mergedOptions = {
      sendNotifications: true,
      notifyParties: ['first', 'second', 'matchmaker'],
      ...options
    };

    // Validate the transition
    this.validateStatusTransition(previousStatus, newStatus);

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Only send notifications if option is enabled
    if (mergedOptions.sendNotifications) {
      try {
        // Utilize the notification service for all channels (email, WhatsApp, etc.)
        await notificationService.handleSuggestionStatusChange(
          
          updatedSuggestion, 
          {
            channels: ['email', 'whatsapp'],
            notifyParties: mergedOptions.notifyParties as ('first' | 'second' | 'matchmaker')[],
            customMessage: mergedOptions.customMessage
          }
        );
        
        console.log(`Notifications sent for suggestion ${updatedSuggestion.id} status change to ${newStatus}`);
      } catch (error) {
        // Log error but don't fail the transition
        console.error('Error sending status transition notifications:', error);
      }
    }

    return updatedSuggestion;
  }

  private validateStatusTransition(
    currentStatus: MatchSuggestionStatus, 
    newStatus: MatchSuggestionStatus
  ): void {
    const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
      DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
      PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
      ],
      AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      ENDED_AFTER_FIRST_DATE: [
        MatchSuggestionStatus.CLOSED
      ],
      MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
      ],
      MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
      ],
      ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
      ],
      MARRIED: [],
      EXPIRED: [],
      CLOSED: [],
      CANCELLED: []
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new Error(
        `Invalid status transition from ${currentStatus} to ${newStatus}. ` +
        `Valid transitions are: ${validTransitions[currentStatus]?.join(', ') || 'none'}`
      );
    }
  }
  
  getStatusLabel(status: MatchSuggestionStatus): string {
    const statusLabels: Record<MatchSuggestionStatus, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת הצד הראשון",
      FIRST_PARTY_APPROVED: "הצד הראשון אישר",
      FIRST_PARTY_DECLINED: "הצד הראשון דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת הצד השני",
      SECOND_PARTY_APPROVED: "הצד השני אישר",
      SECOND_PARTY_DECLINED: "הצד השני דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור השדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בחשיבה לאחר הפגישה",
      PROCEEDING_TO_SECOND_DATE: "התקדמות לפגישה שנייה",
      ENDED_AFTER_FIRST_DATE: "הסתיים לאחר פגישה ראשונה",
      MEETING_PENDING: "פגישה בהמתנה",
      MEETING_SCHEDULED: "פגישה קבועה",
      MATCH_APPROVED: "השידוך אושר",
      MATCH_DECLINED: "השידוך נדחה",
      DATING: "בתהליך היכרות",
      ENGAGED: "אירוסין",
      MARRIED: "נישואין",
      CANCELLED: "בוטל",
      CLOSED: "נסגר",
      EXPIRED: "פג תוקף"
    };
    
    return statusLabels[status] || status;
  }
  
  // Get available actions for current status based on user role
  getAvailableActions(
    suggestion: SuggestionWithParties, 
    userId: string
  ): { id: string; label: string; nextStatus: MatchSuggestionStatus }[] {
    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;
    const isMatchmaker = suggestion.matchmakerId === userId;
    
    const actions: Record<MatchSuggestionStatus, { 
      firstParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      secondParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      matchmaker?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
    }> = {
      DRAFT: {
        matchmaker: [
          { id: "send-to-first", label: "שליחה לצד הראשון", nextStatus: MatchSuggestionStatus.PENDING_FIRST_PARTY }
        ]
      },
      PENDING_FIRST_PARTY: {
        firstParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_APPROVED: {
        matchmaker: [
          { id: "send-to-second", label: "שליחה לצד השני", nextStatus: MatchSuggestionStatus.PENDING_SECOND_PARTY },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      PENDING_SECOND_PARTY: {
        secondParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_APPROVED: {
        matchmaker: [
          { id: "share-contacts", label: "שיתוף פרטי קשר", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      AWAITING_MATCHMAKER_APPROVAL: {
        matchmaker: [
          { id: "approve-share", label: "אישור שיתוף פרטים", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      CONTACT_DETAILS_SHARED: {
        firstParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        secondParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        matchmaker: [
          { id: "request-feedback", label: "בקש משוב", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      AWAITING_FIRST_DATE_FEEDBACK: {
         matchmaker: [
            { id: "mark-thinking", label: "סמן כ'בחשיבה'", nextStatus: MatchSuggestionStatus.THINKING_AFTER_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      THINKING_AFTER_DATE: {
         matchmaker: [
            { id: "proceed-second", label: "המשך לפגישה שניה", nextStatus: MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      PROCEEDING_TO_SECOND_DATE: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      ENDED_AFTER_FIRST_DATE: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      MEETING_PENDING: {
         matchmaker: [
            { id: "schedule-meeting", label: "קביעת פגישה", nextStatus: MatchSuggestionStatus.MEETING_SCHEDULED },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MEETING_SCHEDULED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_APPROVED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      DATING: {
        matchmaker: [
          { id: "mark-engaged", label: "עדכון אירוסין", nextStatus: MatchSuggestionStatus.ENGAGED },
          { id: "close", label: "סגירת תהליך", nextStatus: MatchSuggestionStatus.CLOSED },
          { id: "cancel", label: "ביטול השידוך", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      ENGAGED: {
        matchmaker: [
          { id: "mark-married", label: "עדכון נישואין", nextStatus: MatchSuggestionStatus.MARRIED },
          { id: "cancel", label: "ביטול אירוסין", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      MARRIED: {},
      EXPIRED: {},
      CLOSED: {},
      CANCELLED: {}
    };
    
    if (isFirstParty && actions[suggestion.status]?.firstParty) {
      return actions[suggestion.status].firstParty || [];
    }
    
    if (isSecondParty && actions[suggestion.status]?.secondParty) {
      return actions[suggestion.status].secondParty || [];
    }
    
    if (isMatchmaker && actions[suggestion.status]?.matchmaker) {
      return actions[suggestion.status].matchmaker || [];
    }
    
    return [];
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();
--- End of Content for StatusTransitionService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\SuggestionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/SuggestionService.ts

import { MatchSuggestionStatus, Priority, UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { initNotificationService } from "../notification/initNotifications";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
} from "@/types/suggestions";

// Initialize notification service
const notificationService = initNotificationService();
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];
export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    // קוד חדש ומתוקן
const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
if (!matchmaker || !allowedRoles.includes(matchmaker.role)) {
  throw new Error("Unauthorized - User must be a Matchmaker or Admin");
}
  // --- START: NEW VALIDATION LOGIC ---
    // Fetch both parties to get their names for error messages
    const [firstParty, secondParty] = await Promise.all([
        prisma.user.findUnique({ where: { id: data.firstPartyId } }),
        prisma.user.findUnique({ where: { id: data.secondPartyId } })
    ]);

    if (!firstParty || !secondParty) {
        throw new Error("One or both candidates not found.");
    }
    
    // Check for BLOCKING suggestions for either party
    const blockingSuggestion = await prisma.matchSuggestion.findFirst({
        where: {
            OR: [
                { firstPartyId: data.firstPartyId },
                { secondPartyId: data.firstPartyId },
                { firstPartyId: data.secondPartyId },
                { secondPartyId: data.secondPartyId },
            ],
            status: {
                in: BLOCKING_SUGGESTION_STATUSES,
            },
        },
    });

    if (blockingSuggestion) {
        const hasBlockingSuggestion = (id: string) => 
            blockingSuggestion.firstPartyId === id || blockingSuggestion.secondPartyId === id;
            
        if (hasBlockingSuggestion(data.firstPartyId)) {
            throw new Error(`לא ניתן ליצור הצעה חדשה. ל${firstParty.firstName} ${firstParty.lastName} יש כבר הצעה פעילה.`);
        }
        if (hasBlockingSuggestion(data.secondPartyId)) {
            throw new Error(`לא ניתן ליצור הצעה חדשה. ל${secondParty.firstName} ${secondParty.lastName} יש כבר הצעה פעילה.`);
        }
    }

    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
      console.log('Decision deadline type:', typeof data.decisionDeadline);
      
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות באמצעות מערכת ההתראות המאוחדת
    try {
      console.log('Sending notifications for new suggestion...');
      await notificationService.handleSuggestionStatusChange(
        suggestion,
        {
          channels: ['email', 'whatsapp'],
          notifyParties: ['first'] // רק לצד הראשון בשלב זה
        }
      );
    } catch (error) {
      console.error('Error sending initial suggestion notifications:', error);
      // לא לעצור את התהליך - רק לדווח על השגיאה
    }

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: SuggestionWithParties,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<SuggestionWithParties | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }
}
export const suggestionService = SuggestionService.getInstance();
--- End of Content for SuggestionService.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\matchingAlgorithm.ts
--------------------------------------------------------------------------------
Content:
import { AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

const matchingAlgorithm = {
  calculateMatchScore,
  findBestMatches
};

export default matchingAlgorithm;
--- End of Content for matchingAlgorithm.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\statisticsCalculator.ts
--------------------------------------------------------------------------------
Content:
// /utils/statisticsCalculator.ts
import type { Candidate } from '../../new/types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const  stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

const statisticsCalculator = {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

export default statisticsCalculator;
--- End of Content for statisticsCalculator.ts ---

--- End of Content for suggestions_contents.txt ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\CandidateSelector.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/CandidateSelector.tsx

import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search, AlertTriangle, Clock } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../../new/types/candidates";
import { toast } from "sonner"; // Make sure to import toast

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      // Check if the candidate is blocked by an active suggestion
      if (candidate.suggestionStatus?.status === 'BLOCKED') {
        toast.error("לא ניתן לבחור מועמד זה", {
          description: `${candidate.firstName} ${candidate.lastName} כבר נמצא/ת בהצעה פעילה עם ${candidate.suggestionStatus.withCandidateName}.`,
        });
        return; // Prevent selection
      }
      
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={setInputValue}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => {
                    const isBlocked = candidate.suggestionStatus?.status === 'BLOCKED';
                    return (
                      <div
                        key={candidate.id}
                        onClick={() => handleSelect(candidate)}
                        className={`flex items-start gap-3 p-2 text-right ${
                          isBlocked 
                            ? 'cursor-not-allowed opacity-60' 
                            : 'cursor-pointer hover:bg-accent/50'
                        } ${index === activeIndex ? "bg-accent" : ""}`}
                        role="option"
                        id={`candidate-${candidate.id}`}
                        aria-selected={index === activeIndex}
                        onMouseEnter={() => setActiveIndex(index)}
                      >
                        <div className="flex-1">
                          <div className="font-medium">
                            {formatCandidateDisplay(candidate)}
                          </div>
                          <div className="text-sm text-gray-500">
                            {candidate.profile.religiousLevel} | {candidate.profile.occupation}
                          </div>
                          {candidate.suggestionStatus?.status === 'BLOCKED' && (
                            <Badge variant="destructive" className="mt-2 font-normal">
                              <AlertTriangle className="w-3.5 h-3.5 ml-1.5" />
                              בהצעה פעילה עם: {candidate.suggestionStatus.withCandidateName}
                            </Badge>
                          )}
                          {candidate.suggestionStatus?.status === 'PENDING' && (
                            <Badge variant="outline" className="mt-2 font-normal text-amber-800 bg-amber-50 border-amber-200">
                              <Clock className="w-3.5 h-3.5 ml-1.5" />
                              הצעה ממתינה עם: {candidate.suggestionStatus.withCandidateName}
                            </Badge>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => { /* Implement view profile handler */ }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;
--- End of Content for CandidateSelector.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\MatchPreview.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../../new/types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;
--- End of Content for MatchPreview.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\SuggestionDetails.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/SuggestionDetails.tsx

"use client";
import React, { useState } from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2, Sparkles, AlertTriangle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../../new/types/candidates";

interface SuggestionDetailsProps {
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({ firstParty, secondParty }) => {
  const { register, formState: { errors }, setValue, watch } = useFormContext<NewSuggestionFormData>();
  const [isGeneratingRationale, setIsGeneratingRationale] = useState(false);

  const priority = watch("priority", Priority.MEDIUM);

  const handleGenerateRationale = async () => {
    setIsGeneratingRationale(true);
    toast.info("ה-AI מנסח את חבילת הנימוקים...");
    try {
      const response = await fetch('/api/ai/generate-suggestion-rationale', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId1: firstParty.id, userId2: secondParty.id }),
      });

      const data = await response.json();

      if (!response.ok || !data.success || !data.rationales) {
        throw new Error(data.error || "שגיאה בייצור הנימוקים");
      }

      // --- START OF CHANGE: Populate all three fields ---
      const { generalRationale, rationaleForParty1, rationaleForParty2 } = data.rationales;

      setValue('matchingReason', generalRationale, { shouldValidate: true, shouldDirty: true });
      setValue('firstPartyNotes', rationaleForParty1, { shouldValidate: true, shouldDirty: true });
      setValue('secondPartyNotes', rationaleForParty2, { shouldValidate: true, shouldDirty: true });
      // --- END OF CHANGE ---

      toast.success("הנימוקים נוצרו בהצלחה והוזנו בשדות המתאימים.");

    } catch (error) {
      console.error("Failed to generate rationales:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה לא צפויה");
    } finally {
      setIsGeneratingRationale(false);
    }
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardContent className="pt-6 space-y-6">
          <div className="space-y-2">
            <Label htmlFor="priority">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => setValue("priority", value, { shouldValidate: true })}
              defaultValue={priority}
              name="priority"
            >
              <SelectTrigger id="priority"><SelectValue placeholder="בחר/י עדיפות" /></SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>דחופה</SelectItem>
                <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && <p className="text-sm text-red-500 mt-1">{errors.priority.message}</p>}
          </div>

          <div className="space-y-2">
            <div className="flex justify-between items-center">
              <Label htmlFor="matchingReason">סיבת התאמה (כללי, יוצג לצדדים)</Label>
              <Button type="button" variant="ghost" size="sm" onClick={handleGenerateRationale} disabled={isGeneratingRationale}>
                {isGeneratingRationale ? (
                  <Loader2 className="w-4 h-4 ml-2 animate-spin" />
                ) : (
                  <Sparkles className="w-4 h-4 ml-2 text-purple-500" />
                )}
                {isGeneratingRationale ? 'מנסח...' : 'צור נימוקים (AI)'}
              </Button>
            </div>
            <Textarea
              id="matchingReason"
              {...register("matchingReason")}
              placeholder="נימוק כללי המסביר מדוע יש התאמה בין הצדדים..."
              className="min-h-[120px]"
            />
            {errors.matchingReason && <p className="text-sm text-red-500 mt-1">{errors.matchingReason.message}</p>}
             <Alert variant="default" className="mt-2 text-xs p-3 bg-blue-50 border-blue-200">
                <AlertTriangle className="h-4 w-4 text-blue-500" />
                <AlertDescription>
                  לחיצה על כפתור ה-AI תמלא אוטומטית את שדה זה וגם את שדות ההערות האישיות לכל צד.
                </AlertDescription>
            </Alert>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label htmlFor="firstPartyNotes">הערות אישיות לצד א׳ ({firstParty.firstName})</Label>
              <Textarea
                id="firstPartyNotes"
                {...register("firstPartyNotes")}
                placeholder="טקסט אישי המדגיש את היתרונות של צד ב' עבור צד א'..."
                className="min-h-[140px]"
              />
              {errors.firstPartyNotes && <p className="text-sm text-red-500 mt-1">{errors.firstPartyNotes.message}</p>}
            </div>
            <div className="space-y-2">
              <Label htmlFor="secondPartyNotes">הערות אישיות לצד ב׳ ({secondParty.firstName})</Label>
              <Textarea
                id="secondPartyNotes"
                {...register("secondPartyNotes")}
                placeholder="טקסט אישי המדגיש את היתרונות של צד א' עבור צד ב'..."
                className="min-h-[140px]"
              />
              {errors.secondPartyNotes && <p className="text-sm text-red-500 mt-1">{errors.secondPartyNotes.message}</p>}
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="internalNotes">הערות פנימיות (לצוות השדכנים)</Label>
            <Textarea
              id="internalNotes"
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשימוש פנימי בלבד..."
              className="min-h-[100px]"
            />
            {errors.internalNotes && <p className="text-sm text-red-500 mt-1">{errors.internalNotes.message}</p>}
          </div>
          
          <div className="space-y-2">
            <Label>תאריך יעד להחלטה</Label>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value, 10);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, { shouldValidate: true });
              }}
              defaultValue="14"
            >
              <SelectTrigger><SelectValue /></SelectTrigger>
              <SelectContent>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
                <SelectItem value="14">14 ימים</SelectItem>
                <SelectItem value="30">30 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && <p className="text-sm text-red-500 mt-1">{errors.decisionDeadline.message}</p>}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;
--- End of Content for SuggestionDetails.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\index.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/index.tsx

"use client";
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { UserPlus, Sparkles, Loader2, BarChart2, CheckCircle, Users } from "lucide-react";

// Types
import type { Candidate } from "../../new/types/candidates";
import { newSuggestionSchema, type NewSuggestionFormData } from "./schema";

// Components
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";
import { AiMatchAnalysisDialog } from "../../new/dialogs/AiMatchAnalysisDialog";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({ isOpen, onClose, candidates, selectedCandidate, onSubmit }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(null);
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);
  const [showAnalysisDialog, setShowAnalysisDialog] = useState(false);

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      decisionDeadline: new Date(new Date().setDate(new Date().getDate() + 14)), // Default to 2 weeks
    },
  });

  // Reset form and state when dialog opens or selectedCandidate changes
  useEffect(() => {
    if (isOpen) {
      form.reset({
        priority: Priority.MEDIUM,
        status: MatchSuggestionStatus.DRAFT,
        decisionDeadline: new Date(new Date().setDate(new Date().getDate() + 14)),
        firstPartyId: selectedCandidate?.id || "",
        secondPartyId: "",
      });
      setFirstParty(selectedCandidate || null);
      setSecondParty(null);
    }
  }, [isOpen, selectedCandidate, form]);

  const handleCandidateSelect = (type: "first" | "second") => (candidate: Candidate | null) => {
    const setter = type === 'first' ? setFirstParty : setSecondParty;
    const fieldName = type === 'first' ? 'firstPartyId' : 'secondPartyId';
    setter(candidate);
    form.setValue(fieldName, candidate?.id || "", { shouldValidate: true, shouldDirty: true });
  };

  const handleSubmit = form.handleSubmit(async (data) => {
    if (!firstParty || !secondParty) {
      toast.error("יש לבחור את שני הצדדים להצעה.");
      return;
    }

    setIsSubmitting(true);
    try {
      await onSubmit(data);
      toast.success("ההצעה נוצרה בהצלחה!");
      onClose();
    } catch (error) {
      toast.error("שגיאה ביצירת ההצעה: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"));
    } finally {
      setIsSubmitting(false);
    }
  });

  const maleCandidates = candidates.filter(c => c.profile.gender === 'MALE');
  const femaleCandidates = candidates.filter(c => c.profile.gender === 'FEMALE');

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-7xl w-full h-[95vh] flex flex-col p-0" dir="rtl">
          <DialogHeader className="px-6 py-4 border-b flex-shrink-0">
            <DialogTitle className="text-2xl flex items-center gap-3">
              <UserPlus className="text-primary"/>
              יצירת הצעת שידוך חדשה
            </DialogTitle>
            <DialogDescription>
              בחר שני מועמדים, נתח את ההתאמה ביניהם והגדר את פרטי ההצעה.
            </DialogDescription>
          </DialogHeader>

          <FormProvider {...form}>
            <form onSubmit={handleSubmit} className="flex-1 grid grid-cols-1 md:grid-cols-12 gap-6 p-6 overflow-hidden">
              
              {/* Left Panel: Male Selector */}
              <div className="md:col-span-3 flex flex-col gap-4">
                <CandidateSelector
                  label="צד א' (גבר)"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={maleCandidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />
              </div>
              
              {/* Center Panel: Details and Actions */}
              <div className="md:col-span-6 flex flex-col gap-4 overflow-y-auto pr-2 pb-4">
                {firstParty && secondParty ? (
                  <>
                    <MatchPreview firstParty={firstParty} secondParty={secondParty} />
                     <div className="flex gap-2 justify-center">
                      <Button type="button" variant="outline" onClick={() => setShowAnalysisDialog(true)}>
                        <BarChart2 className="w-4 h-4 ml-2"/>
                        נתח התאמה מלא (AI)
                      </Button>
                     </div>
                    <SuggestionDetails firstParty={firstParty} secondParty={secondParty} />
                  </>
                ) : (
                  <div className="flex items-center justify-center h-full bg-gray-50 rounded-lg border-2 border-dashed">
                    <div className="text-center text-gray-500">
                        <Users className="mx-auto h-12 w-12 text-gray-300" />
                        <h3 className="mt-2 text-sm font-medium">בחר מועמדים</h3>
                        <p className="mt-1 text-sm text-gray-500">
                            יש לבחור מועמד ומועמדת מהעמודות בצדדים.
                        </p>
                    </div>
                  </div>
                )}
              </div>

              {/* Right Panel: Female Selector */}
              <div className="md:col-span-3 flex flex-col gap-4">
                <CandidateSelector
                  label="צד ב' (אישה)"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={femaleCandidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

            </form>
          </FormProvider>

          <DialogFooter className="p-4 border-t flex-shrink-0">
            <div className="flex justify-between w-full items-center">
                <span className="text-xs text-gray-500">לאחר יצירת ההצעה, היא תופיע בסטטוס טיוטה.</span>
                <div className="flex gap-2">
                    <DialogClose asChild><Button variant="outline">ביטול</Button></DialogClose>
                    <Button
                        type="submit"
                        onClick={handleSubmit}
                        disabled={isSubmitting || !firstParty || !secondParty}
                    >
                        {isSubmitting ? <Loader2 className="w-4 h-4 animate-spin ml-2"/> : <CheckCircle className="w-4 h-4 ml-2"/>}
                        {isSubmitting ? "יוצר הצעה..." : "צור הצעה"}
                    </Button>
                </div>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {firstParty && secondParty && (
        <AiMatchAnalysisDialog
          isOpen={showAnalysisDialog}
          onClose={() => setShowAnalysisDialog(false)}
          targetCandidate={firstParty}
          comparisonCandidates={[secondParty]}
        />
      )}
    </>
  );
};

export default NewSuggestionForm;
--- End of Content for index.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\schema.ts
--------------------------------------------------------------------------------
Content:
import { z } from "zod";
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;
--- End of Content for schema.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards\SuggestionCard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/cards/SuggestionCard.tsx

import React, { useState, useEffect } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import Image from "next/image";
import {
  Clock,
  User,
  MessageCircle,
  Eye,
  AlertCircle,
  MoreHorizontal,
  Send,
  RefreshCw,
  Trash2,
  Edit,
  CheckCircle,
  XCircle,
  CalendarClock,
  Heart,
  MapPin,
  Calendar,
  Star,
  ChevronDown,
  ChevronUp,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestionStatus, Priority } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";

// A simple media query hook
const useMediaQuery = (query: string) => {
  const [matches, setMatches] = useState(false);
  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    window.addEventListener("resize", listener);
    return () => window.removeEventListener("resize", listener);
  }, [matches, query]);
  return matches;
};

interface SuggestionCardProps {
  suggestion: Suggestion;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
  variant?: "full" | "compact";
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const getStatusInfo = (status: MatchSuggestionStatus) => {
  // ... (no changes to this function)
  switch (status) {
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לצד א׳",
        className: "bg-yellow-100 text-yellow-800 border-yellow-200",
        color: "text-yellow-600",
        bgColor: "bg-yellow-50",
        icon: Clock,
        progress: 25,
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לצד ב׳",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        color: "text-blue-600",
        bgColor: "bg-blue-50",
        icon: Clock,
        progress: 50,
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "צד א׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 40,
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "צד ב׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 60,
      };
    case "FIRST_PARTY_DECLINED":
      return {
        label: "צד א׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "SECOND_PARTY_DECLINED":
      return {
        label: "צד ב׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        className: "bg-purple-100 text-purple-800 border-purple-200",
        color: "text-purple-600",
        bgColor: "bg-purple-50",
        icon: Send,
        progress: 70,
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        className: "bg-pink-100 text-pink-800 border-pink-200",
        color: "text-pink-600",
        bgColor: "bg-pink-50",
        icon: Heart,
        progress: 80,
      };
    case "AWAITING_FIRST_DATE_FEEDBACK":
      return {
        label: "ממתין למשוב פגישה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        color: "text-orange-600",
        bgColor: "bg-orange-50",
        icon: AlertCircle,
        progress: 75,
      };
    case "EXPIRED":
      return {
        label: "פג תוקף",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: Clock,
        progress: 100,
      };
    default:
      return {
        label: "בטיפול",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: RefreshCw,
        progress: 30,
      };
  }
};

const getPriorityInfo = (priority: Priority) => {
  // ... (no changes to this function)
   switch (priority) {
    case "URGENT":
      return {
        label: "דחוף",
        className: "bg-red-100 text-red-800 border-red-200",
        icon: AlertCircle,
        color: "text-red-600",
        borderColor: "border-red-500",
      };
    case "HIGH":
      return {
        label: "גבוה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        icon: Star,
        color: "text-orange-600",
        borderColor: "border-orange-500",
      };
    case "MEDIUM":
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
        borderColor: "border-blue-500",
      };
    case "LOW":
      return {
        label: "נמוך",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: Star,
        color: "text-gray-600",
        borderColor: "border-gray-400",
      };
    default:
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
        borderColor: "border-blue-500",
      };
  }
};

const getDaysLeft = (decisionDeadline?: Date | string | null) => {
  // ... (no changes to this function)
  if (!decisionDeadline) return null;

  const deadline = new Date(decisionDeadline);
  const today = new Date();
  const diffTime = deadline.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? diffDays : 0;
};

const SuggestionCard: React.FC<SuggestionCardProps> = ({
  suggestion,
  onAction,
  className,
  variant = "full",
}) => {
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [isExpanded, setIsExpanded] = useState(false);

  // Common data
  const { firstParty, secondParty } = suggestion;
  const statusInfo = getStatusInfo(suggestion.status);
  const priorityInfo = getPriorityInfo(suggestion.priority);
  const daysLeft = getDaysLeft(suggestion.decisionDeadline);
  const firstPartyAge = calculateAge(firstParty.profile.birthDate);
  const secondPartyAge = calculateAge(secondParty.profile.birthDate);
  const firstPartyMainImage = firstParty.images.find((img) => img.isMain);
  const secondPartyMainImage = secondParty.images.find((img) => img.isMain);

  // ######################################################################
  // #                        MOBILE - KANBAN VIEW                        #
  // ######################################################################
  if (isMobile && variant === "compact") {
    const StatusIcon = statusInfo.icon;
    return (
      <Card
        className={cn(
          "p-3 w-full cursor-pointer hover:bg-gray-50",
          "border-l-4",
          priorityInfo.borderColor,
          className
        )}
        onClick={() => onAction("view", suggestion)}
      >
        <div className="flex justify-between items-start">
          <div className="flex-1 space-y-1">
            <h4 className="font-semibold text-sm leading-tight">
              {firstParty.firstName} ו{secondParty.firstName}
            </h4>
            <div className="flex items-center gap-2">
              <div className="flex -space-x-2">
                <Image
                  src={firstPartyMainImage?.url || "/placeholders/user.png"}
                  alt={firstParty.firstName}
                  width={24}
                  height={24}
                  className="rounded-full border-2 border-white"
                />
                <Image
                  src={secondPartyMainImage?.url || "/placeholders/user.png"}
                  alt={secondParty.firstName}
                  width={24}
                  height={24}
                  className="rounded-full border-2 border-white"
                />
              </div>
              <p className="text-xs text-gray-500">
                {firstPartyAge}, {secondPartyAge}
              </p>
            </div>
          </div>
          <div className={cn("p-1 rounded-full", statusInfo.bgColor)}>
            <StatusIcon className={cn("w-4 h-4", statusInfo.color)} />
          </div>
        </div>
      </Card>
    );
  }

  // ######################################################################
  // #                      MOBILE - SMART LIST VIEW                      #
  // ######################################################################
  if (isMobile && variant === "full") {
    const StatusIcon = statusInfo.icon;
    const isWaitingForResponse = suggestion.status.includes("PENDING");

    return (
      <Card className={cn("overflow-hidden shadow-sm", className)}>
        {/* Progress Bar and Status */}
        <div className={cn("p-3", statusInfo.bgColor)}>
          <div className="flex justify-between items-center mb-1.5">
            <div className="flex items-center gap-2">
              <StatusIcon className={cn("w-5 h-5", statusInfo.color)} />
              <span className="font-medium text-sm">{statusInfo.label}</span>
            </div>
            {daysLeft !== null && daysLeft <= 3 && (
              <Badge variant="destructive" className="text-xs">
                <Clock className="w-3 h-3 ml-1" />
                {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים`}
              </Badge>
            )}
          </div>
          <Progress value={statusInfo.progress} className="h-1" />
        </div>

        <CardContent className="p-4 space-y-4">
          {/* Parties Info */}
          <div className="flex items-center gap-4">
            <div className="flex-1 text-center space-y-1">
              <Image
                src={firstPartyMainImage?.url || "/placeholders/user.png"}
                alt={firstParty.firstName}
                width={64}
                height={64}
                className="rounded-full mx-auto border-2 border-blue-200"
              />
              <h4 className="font-bold">{firstParty.firstName}</h4>
              <p className="text-xs text-gray-600">
                {firstPartyAge}, {firstParty.profile.city}
              </p>
            </div>
            <Heart className="w-6 h-6 text-pink-400 flex-shrink-0" />
            <div className="flex-1 text-center space-y-1">
              <Image
                src={secondPartyMainImage?.url || "/placeholders/user.png"}
                alt={secondParty.firstName}
                width={64}
                height={64}
                className="rounded-full mx-auto border-2 border-purple-200"
              />
              <h4 className="font-bold">{secondParty.firstName}</h4>
              <p className="text-xs text-gray-600">
                {secondPartyAge}, {secondParty.profile.city}
              </p>
            </div>
          </div>

          {/* Collapsible Matching Reason */}
          {suggestion.matchingReason && (
            <div className="bg-gray-50 p-3 rounded-lg border">
              <p className={cn("text-sm text-gray-700", !isExpanded && "line-clamp-2")}>
                {suggestion.matchingReason}
              </p>
              <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="text-xs text-blue-600 font-semibold mt-1 flex items-center"
              >
                {isExpanded ? "הצג פחות" : "הצג יותר"}
                {isExpanded ? <ChevronUp className="w-4 h-4 mr-1" /> : <ChevronDown className="w-4 h-4 mr-1" />}
              </button>
            </div>
          )}

          {/* Thumb-friendly Action Bar */}
          <div className="flex items-center justify-between pt-3 border-t">
            <span className="text-xs text-gray-500">
              {formatDistanceToNow(new Date(suggestion.createdAt), { addSuffix: true, locale: he })}
            </span>
            <div className="flex items-center gap-2">
              {isWaitingForResponse && (
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => onAction("reminder", suggestion, { partyType: suggestion.status === 'PENDING_FIRST_PARTY' ? 'first' : 'second' })}
                >
                  <Send className="w-4 h-4" />
                </Button>
              )}
              <Button size="sm" onClick={() => onAction("view", suggestion)}>
                <Eye className="w-4 h-4 ml-1" />
                פרטים
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button size="sm" variant="ghost" className="px-1">
                    <MoreHorizontal className="w-5 h-5" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onAction("edit", suggestion)}>
                    <Edit className="w-4 h-4 ml-2" />
                    <span>ערוך הצעה</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onAction("message", suggestion)}>
                    <MessageCircle className="w-4 h-4 ml-2" />
                    <span>שלח הודעה</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onAction("delete", suggestion)} className="text-red-600">
                    <Trash2 className="w-4 h-4 ml-2" />
                    <span>מחק הצעה</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  // ######################################################################
  // #                              DESKTOP VIEW                          #
  // ######################################################################
  const StatusIcon = statusInfo.icon;
  const PriorityIcon = priorityInfo.icon;
  const canBeResent = ["EXPIRED", "FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"].includes(suggestion.status);
  const isWaitingForResponse = suggestion.status === "PENDING_FIRST_PARTY" || suggestion.status === "PENDING_SECOND_PARTY";
  const needsFeedback = suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK";

  return (
    <Card className={cn("overflow-hidden hover:shadow-md transition-shadow", className)}>
      {/* Header with status and progress */}
      <div className={cn("p-4 border-b relative", statusInfo.bgColor)}>
        <div className="flex justify-between items-center mb-2">
          <div className="flex items-center gap-2">
            <StatusIcon className={cn("w-5 h-5", statusInfo.color)} />
            <span className="font-medium text-gray-900">{statusInfo.label}</span>
          </div>
          <Badge className={priorityInfo.className}>
            <PriorityIcon className="w-3 h-3 ml-1" />
            {priorityInfo.label}
          </Badge>
        </div>
        <Progress value={statusInfo.progress} className="h-1.5" />
        {daysLeft !== null && daysLeft <= 3 && suggestion.status !== "EXPIRED" && (
          <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 bg-red-500 text-white text-xs font-bold py-0.5 px-2 rounded-full whitespace-nowrap z-10">
            <Clock className="w-3 h-3 inline-block ml-1" />
            {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים נותרו`}
          </div>
        )}
      </div>

      {/* Main content - a copy of the original desktop view */}
      <div className="p-4">
        {/* Parties info */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div className="space-y-2 border-l pl-4 order-1">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-blue-50">צד א׳</Badge>
              {suggestion.status === "FIRST_PARTY_APPROVED" && <Badge className="bg-green-100 text-green-800"><CheckCircle className="w-3 h-3 ml-1" />אישר</Badge>}
              {suggestion.status === "FIRST_PARTY_DECLINED" && <Badge className="bg-red-100 text-red-800"><XCircle className="w-3 h-3 ml-1" />דחה</Badge>}
            </div>
            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {firstPartyMainImage ? <Image src={firstPartyMainImage.url} alt={firstParty.firstName} className="object-cover" fill sizes="4rem" /> : <div className="w-full h-full flex items-center justify-center"><User className="w-8 h-8 text-gray-400" /></div>}
              </div>
              <div>
                <h4 className="font-semibold">{firstParty.firstName} {firstParty.lastName}</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center"><Calendar className="w-3 h-3 ml-1 text-gray-400" /><span>{firstPartyAge} שנים</span></div>
                  {firstParty.profile.city && <div className="flex items-center"><MapPin className="w-3 h-3 ml-1 text-gray-400" /><span>{firstParty.profile.city}</span></div>}
                </div>
              </div>
            </div>
          </div>
          <div className="space-y-2 order-0">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-purple-50">צד ב׳</Badge>
              {suggestion.status === "SECOND_PARTY_APPROVED" && <Badge className="bg-green-100 text-green-800"><CheckCircle className="w-3 h-3 ml-1" />אישר</Badge>}
              {suggestion.status === "SECOND_PARTY_DECLINED" && <Badge className="bg-red-100 text-red-800"><XCircle className="w-3 h-3 ml-1" />דחה</Badge>}
            </div>
            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {secondPartyMainImage ? <Image src={secondPartyMainImage.url} alt={secondParty.firstName} className="object-cover" fill sizes="4rem" /> : <div className="w-full h-full flex items-center justify-center"><User className="w-8 h-8 text-gray-400" /></div>}
              </div>
              <div>
                <h4 className="font-semibold">{secondParty.firstName} {secondParty.lastName}</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center"><Calendar className="w-3 h-3 ml-1 text-gray-400" /><span>{secondPartyAge} שנים</span></div>
                  {secondParty.profile.city && <div className="flex items-center"><MapPin className="w-3 h-3 ml-1 text-gray-400" /><span>{secondParty.profile.city}</span></div>}
                </div>
              </div>
            </div>
          </div>
        </div>

        {suggestion.matchingReason && (
          <div className="mb-4 p-3 bg-gray-50 rounded-lg border text-sm">
            <h5 className="text-xs font-semibold text-gray-600 mb-1">סיבת ההתאמה:</h5>
            <p className="text-gray-800 line-clamp-2">{suggestion.matchingReason}</p>
          </div>
        )}

        <div className="flex justify-between text-xs text-gray-500 mb-4">
          <div className="flex items-center"><Clock className="w-3.5 h-3.5 ml-1" />{formatDistanceToNow(new Date(suggestion.createdAt), { addSuffix: true, locale: he })}</div>
          {suggestion.decisionDeadline && <div className="flex items-center"><CalendarClock className="w-3.5 h-3.5 ml-1" />{daysLeft !== null ? (daysLeft === 0 ? "היום!" : `${daysLeft} ימים להחלטה`) : "אין מועד אחרון"}</div>}
        </div>

        <div className="flex items-center justify-between pt-2 border-t">
          <Button variant="ghost" size="sm" onClick={() => onAction("message", suggestion)} className="text-gray-600 hover:text-primary"><MessageCircle className="w-4 h-4 ml-1" />הודעה</Button>
          <div className="flex items-center gap-1">
            <Button variant="default" size="sm" onClick={() => onAction("view", suggestion)}><Eye className="w-4 h-4 ml-1" />פרטים</Button>
            <DropdownMenu>
              <DropdownMenuTrigger asChild><Button size="sm" variant="ghost" className="px-1"><MoreHorizontal className="w-4 h-4" /></Button></DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => onAction("edit", suggestion)}><Edit className="w-4 h-4 ml-2" /><span>ערוך הצעה</span></DropdownMenuItem>
                {canBeResent && <DropdownMenuItem onClick={() => onAction("resend", suggestion)}><RefreshCw className="w-4 h-4 ml-2" /><span>שלח מחדש</span></DropdownMenuItem>}
                <DropdownMenuItem onClick={() => onAction("delete", suggestion)} className="text-red-600"><Trash2 className="w-4 h-4 ml-2" /><span>מחק הצעה</span></DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </Card>
  );
};

export default SuggestionCard;
--- End of Content for SuggestionCard.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback, useEffect, useMemo } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Plus, RefreshCw, BarChart, Loader2, List, LayoutGrid, Filter, Search } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger } from "@/components/ui/sheet";
import { ToggleGroup, ToggleGroupItem } from "@/components/ui/toggle-group";
import { toast } from "sonner";
import { MatchSuggestionStatus, Priority } from "@prisma/client";
import { cn } from "@/lib/utils";

// --- START: Type Imports and Definitions ---
import type {
  Suggestion,
  SuggestionFilters,
  ActionAdditionalData,
} from "@/types/suggestions";
import type { NewSuggestionFormData } from "../../suggestions/NewSuggestionForm/schema";
import type { Candidate } from "../../new/types/candidates";

// Hooks
import { useCandidates } from "../../new/hooks/useCandidates";

// Components
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import SuggestionCard from "../cards/SuggestionCard";
import EditSuggestionForm from "../EditSuggestionForm";
import MessageForm from "../MessageForm";
import MonthlyTrendModal from "./MonthlyTrendModal";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Input } from "@/components/ui/input";

// --- A simple media query hook ---
const useMediaQuery = (query: string) => {
  const [matches, setMatches] = useState(false);
  useEffect(() => {
    // Ensure this runs only on the client
    if (typeof window === 'undefined') return;
    
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    window.addEventListener("resize", listener);
    return () => window.removeEventListener("resize", listener);
  }, [matches, query]);
  return matches;
};

// --- Defining specific payload types to replace 'any' ---
interface SuggestionUpdatePayload {
  priority?: Priority;
  status?: MatchSuggestionStatus;
  statusNotes?: string;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: Date;
}

interface SendMessagePayload {
  suggestionId: string;
  partyType: "first" | "second" | "both";
  messageType: "message" | "reminder" | "update";
  messageContent: string;
}

type DialogActionData = {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyType?: "first" | "second" | "both";
  type?: string;
};

type ConfirmActionData = {
  suggestionId: string;
  partyType?: "first" | "second" | "both";
  type?: string;
};
// --- END: Type Imports and Definitions ---

export default function MatchmakerDashboard() {
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [mobileView, setMobileView] = useState<'list' | 'kanban'>('list');
  const [showMobileFilters, setShowMobileFilters] = useState(false);

  // State management
  const [activeTab, setActiveTab] = useState("pending");
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<SuggestionFilters>({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  // Dialogs and selected items state
  const [selectedSuggestion, setSelectedSuggestion] = useState<Suggestion | null>(null);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmAction, setConfirmAction] = useState<{ type: string; data: ConfirmActionData; } | null>(null);
  const [showEditForm, setShowEditForm] = useState(false);
  const [showMessageForm, setShowMessageForm] = useState(false);
  const [showMonthlyTrendDialog, setShowMonthlyTrendDialog] = useState(false);

  // Fetch candidates list to pass to the form
  const { candidates: allCandidates } = useCandidates();

  const fetchSuggestions = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/matchmaker/suggestions");
      if (!response.ok) throw new Error("Failed to fetch suggestions");
      const data = await response.json();
      setSuggestions(data);
    } catch (error: unknown) {
      console.error("Error fetching suggestions:", error);
      toast.error("שגיאה בטעינת ההצעות");
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchSuggestions();
  }, [fetchSuggestions]);
  
  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((s) => {
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const match =
          (s.firstParty.firstName + " " + s.firstParty.lastName).toLowerCase().includes(query) ||
          (s.secondParty.firstName + " " + s.secondParty.lastName).toLowerCase().includes(query) ||
          (s.firstParty.profile?.city && s.firstParty.profile.city.toLowerCase().includes(query)) ||
          (s.secondParty.profile?.city && s.secondParty.profile.city.toLowerCase().includes(query));
        if (!match) return false;
      }
      if (filters.priority?.length && !filters.priority.includes(s.priority)) return false;
      if (filters.status?.length && !filters.status.includes(s.status)) return false;
      if (filters.dateRange) {
        const createdAt = new Date(s.createdAt);
        if (createdAt < filters.dateRange.start || (filters.dateRange.end && createdAt > filters.dateRange.end)) return false;
      }
      return true;
    });
  }, [suggestions, searchQuery, filters]);
  
  const pendingSuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'PENDING'), [filteredSuggestions]);
  const activeSuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'ACTIVE'), [filteredSuggestions]);
  const historySuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'HISTORY'), [filteredSuggestions]);

  const pendingCount = pendingSuggestions.length;
  const activeCount = activeSuggestions.length;
  const historyCount = historySuggestions.length;

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await fetchSuggestions();
    setIsRefreshing(false);
    toast.success("נתוני ההצעות עודכנו");
  };

  const handleNewSuggestion = async (data: NewSuggestionFormData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error((await response.json()).error || "Failed to create suggestion");
      setShowNewSuggestion(false);
      toast.success("ההצעה נוצרה בהצלחה");
      await fetchSuggestions();
    } catch (error: unknown) {
      console.error("Error creating suggestion:", error);
      toast.error("שגיאה ביצירת ההצעה: " + (error instanceof Error ? error.message : ""));
    }
  };

  const handleSuggestionDeleted = useCallback((deletedId: string) => {
    setSuggestions((prev) => prev.filter((s) => s.id !== deletedId));
    if (selectedSuggestion?.id === deletedId) setSelectedSuggestion(null);
  }, [selectedSuggestion]);

  const handleConfirmAction = async () => {
    if (!confirmAction) return;
    try {
      if (confirmAction.type === "delete") {
        const response = await fetch(`/api/matchmaker/suggestions/${confirmAction.data.suggestionId}/delete`, { method: "DELETE" });
        if (!response.ok) throw new Error("Failed to delete suggestion");
        handleSuggestionDeleted(confirmAction.data.suggestionId);
        toast.success("ההצעה נמחקה בהצלחה");
      }
    } catch (error: unknown) {
      toast.error("אירעה שגיאה בביצוע הפעולה");
    } finally {
      setShowConfirmDialog(false);
      setConfirmAction(null);
    }
  };
  
  const handleStatusChange = async (suggestionId: string, newStatus: MatchSuggestionStatus, notes?: string) => {
    try {
      const response = await fetch(`/api/matchmaker/suggestions/${suggestionId}/status`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: newStatus, notes: notes || `סטטוס שונה מממשק ניהול` }),
      });
      if (!response.ok) throw new Error((await response.json()).error || "Failed to update status");
      toast.success("סטטוס ההצעה עודכן בהצלחה");
      fetchSuggestions();
    } catch (error: unknown) {
      console.error("Error updating suggestion status:", error);
      toast.error("שגיאה בעדכון סטטוס ההצעה: " + (error instanceof Error ? error.message : ""));
    }
  };

  const handleUpdateSuggestion = async (data: { suggestionId: string; updates: SuggestionUpdatePayload; }) => {
    try {
        const response = await fetch(`/api/matchmaker/suggestions/${data.suggestionId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data.updates),
        });
        if (!response.ok) throw new Error('Failed to update suggestion');
        toast.success("פרטי ההצעה עודכנו בהצלחה");
        setShowEditForm(false);
        fetchSuggestions();
    } catch (error: unknown) {
        console.error("Error updating suggestion:", error);
        toast.error("שגיאה בעדכון פרטי ההצעה");
    }
  };

  const handleSendMessage = async (data: SendMessagePayload) => {
    try {
      const response = await fetch(`/api/matchmaker/suggestions/${data.suggestionId}/message`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            partyType: data.partyType,
            messageType: data.messageType,
            content: data.messageContent
        }),
      });
      if (!response.ok) throw new Error((await response.json()).error || 'Failed to send message');
      toast.success("ההודעה נשלחה בהצלחה");
      setShowMessageForm(false);
    } catch (error: unknown) {
      toast.error("שגיאה בשליחת ההודעה: " + (error instanceof Error ? error.message : ""));
    }
  };
  
  const handleDialogAction = (action: string, data?: DialogActionData) => {
    setSelectedSuggestion(data?.suggestion || null);
    if (action === 'view' && data?.suggestion) {
        setSelectedSuggestion(data.suggestion);
    } else if (action === 'delete' && data?.suggestionId) {
      setConfirmAction({ type: 'delete', data: { suggestionId: data.suggestionId } });
      setShowConfirmDialog(true);
    } else if (action === 'edit' && data?.suggestion) {
      setShowEditForm(true);
    } else if (action === 'message' && data?.suggestion) {
      setShowMessageForm(true);
    } else if (action === 'changeStatus' && data?.suggestionId && data.newStatus) {
        handleStatusChange(data.suggestionId, data.newStatus, data.notes);
    }
  };
  
  const handleSuggestionAction = (type: any, suggestion: Suggestion, additionalData?: ActionAdditionalData) => {
    handleDialogAction(type, { ...additionalData, suggestionId: suggestion.id, suggestion });
  };
  
  const kanbanColumns = useMemo(() => {
    const columns: { title: string; suggestions: Suggestion[] }[] = [
      { title: "דורש טיפול", suggestions: [] },
      { title: "ממתין לתגובה", suggestions: [] },
      { title: "פעילות", suggestions: [] },
      { title: "היסטוריה", suggestions: [] },
    ];

    filteredSuggestions.forEach(s => {
      if (['AWAITING_MATCHMAKER_APPROVAL', 'AWAITING_FIRST_DATE_FEEDBACK'].includes(s.status)) {
        columns[0].suggestions.push(s);
      } else if (['PENDING_FIRST_PARTY', 'PENDING_SECOND_PARTY'].includes(s.status)) {
        columns[1].suggestions.push(s);
      } else if (['CLOSED', 'CANCELLED', 'EXPIRED', 'MARRIED', 'ENGAGED'].includes(s.status)) {
        columns[3].suggestions.push(s);
      } else {
        columns[2].suggestions.push(s);
      }
    });

    return columns;
  }, [filteredSuggestions]);

  // =========================================================================
  // ============================ RENDER LOGIC ===============================
  // =========================================================================

  const renderMobileFilters = () => (
    <Sheet open={showMobileFilters} onOpenChange={setShowMobileFilters}>
      <SheetTrigger asChild>
        <Button variant="outline" size="sm">
          <Filter className="w-4 h-4 mr-2" />
          סינון
        </Button>
      </SheetTrigger>
      <SheetContent>
        <SheetHeader>
          <SheetTitle>סינון הצעות</SheetTitle>
        </SheetHeader>
        <div className="py-4">
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
            totalCount={suggestions.length}
            activeCount={activeCount}
            pendingCount={pendingCount}
            historyCount={historyCount}
          />
        </div>
      </SheetContent>
    </Sheet>
  );

  const renderMobileView = () => (
    <div className="h-screen flex flex-col">
      <div className="flex items-center justify-between p-4 border-b bg-white sticky top-0 z-10">
        <div className="relative flex-1">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-400" />
          <Input
            placeholder="חיפוש..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10 text-right pr-10 bg-gray-100"
          />
        </div>
        <div className="mr-2">{renderMobileFilters()}</div>
        <ToggleGroup
          type="single"
          value={mobileView}
          onValueChange={(value: 'list' | 'kanban') => value && setMobileView(value)}
          className="mr-2"
        >
          <ToggleGroupItem value="list" aria-label="List view"><List className="h-4 w-4" /></ToggleGroupItem>
          <ToggleGroupItem value="kanban" aria-label="Kanban view"><LayoutGrid className="h-4 w-4" /></ToggleGroupItem>
        </ToggleGroup>
      </div>
      {isLoading ? (
        <div className="flex-1 flex items-center justify-center"><Loader2 className="w-8 h-8 animate-spin text-primary" /></div>
      ) : mobileView === 'kanban' ? (
        <ScrollArea className="w-full whitespace-nowrap flex-1">
          <div className="flex gap-4 p-4 h-full">
            {kanbanColumns.map((col, idx) => (
              <div key={idx} className="w-64 flex-shrink-0 bg-gray-100 rounded-lg flex flex-col">
                <div className="p-3 font-semibold text-sm border-b sticky top-0 bg-gray-100/80 backdrop-blur-sm z-10">
                  {col.title} <Badge variant="secondary" className="mr-1">{col.suggestions.length}</Badge>
                </div>
                <ScrollArea className="flex-1">
                  <div className="p-2 space-y-2">
                    {col.suggestions.length > 0 ? col.suggestions.map(s => <SuggestionCard key={s.id} suggestion={s} onAction={handleSuggestionAction} variant="compact" />)
                    : <div className="p-4 text-center text-xs text-gray-500">אין הצעות</div>}
                  </div>
                </ScrollArea>
              </div>
            ))}
          </div>
        </ScrollArea>
      ) : (
        <ScrollArea className="flex-1">
          <div className="p-4 space-y-4">
            {filteredSuggestions.map(s => <SuggestionCard key={s.id} suggestion={s} onAction={handleSuggestionAction} variant="full" />)}
            {filteredSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">לא נמצאו הצעות תואמות.</div>}
          </div>
        </ScrollArea>
      )}
       <div className="p-4 bg-white border-t sticky bottom-0">
         <Button onClick={() => setShowNewSuggestion(true)} className="w-full">
            <Plus className="w-4 h-4 mr-2" />
            הצעה חדשה
         </Button>
       </div>
    </div>
  );

  const renderDesktopView = () => (
    <div className="container mx-auto space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
        <div className="flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={handleRefresh} disabled={isRefreshing}><RefreshCw className={cn("w-4 h-4 mr-2", isRefreshing && "animate-spin")} />{isRefreshing ? "מעדכן..." : "רענן"}</Button>
          <Button variant="outline" size="sm" onClick={() => setShowMonthlyTrendDialog(true)}><BarChart className="w-4 h-4 mr-2" />מגמה חודשית</Button>
          <Button onClick={() => setShowNewSuggestion(true)}><Plus className="w-4 h-4 mr-2" />הצעה חדשה</Button>
        </div>
      </div>
      <SuggestionsStats suggestions={suggestions} onFilterChange={(filter) => setFilters(prev => ({...prev, ...filter}))} />
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <div className="flex items-center justify-between mb-6">
          <TabsList dir="rtl">
            <TabsTrigger value="pending">ממתין לאישור <Badge className="mr-2">{pendingCount}</Badge></TabsTrigger>
            <TabsTrigger value="active">פעילות <Badge className="mr-2">{activeCount}</Badge></TabsTrigger>
            <TabsTrigger value="history">היסטוריה <Badge className="mr-2">{historyCount}</Badge></TabsTrigger>
          </TabsList>
        </div>
        <SuggestionActionBar
          searchQuery={searchQuery} onSearchChange={setSearchQuery} filters={filters} onFiltersChange={setFilters}
          totalCount={suggestions.length}
          activeCount={activeCount}
          pendingCount={pendingCount}
          historyCount={historyCount}
        />
        {isLoading ? (
          <div className="flex items-center justify-center h-64"><Loader2 className="w-8 h-8 animate-spin text-primary" /></div>
        ) : (
          <>
            <TabsContent value="pending">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {pendingSuggestions.map((suggestion) => ( <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} /> ))}
              </div>
              {pendingSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות ממתינות לאישור.</div>}
            </TabsContent>
            <TabsContent value="active">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {activeSuggestions.map((suggestion) => ( <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} /> ))}
              </div>
              {activeSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות פעילות.</div>}
            </TabsContent>
            <TabsContent value="history">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {historySuggestions.map((suggestion) => ( <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} /> ))}
              </div>
              {historySuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות בהיסטוריה.</div>}
            </TabsContent>
          </>
        )}
      </Tabs>
    </div>
  );

  return (
    <div className={cn("min-h-screen bg-gray-50 rtl", !isMobile && "p-6", isMobile && "p-0")}>
      {isMobile ? renderMobileView() : renderDesktopView()}

      {/* Dialogs and Forms (common for both views) */}
      <NewSuggestionForm isOpen={showNewSuggestion} onClose={() => setShowNewSuggestion(false)} candidates={allCandidates} onSubmit={handleNewSuggestion} />
      <SuggestionDetailsDialog suggestion={selectedSuggestion} isOpen={!!selectedSuggestion} onClose={() => setSelectedSuggestion(null)} onAction={handleDialogAction as any} />
      <Dialog open={showMonthlyTrendDialog} onOpenChange={setShowMonthlyTrendDialog}><DialogContent className="max-w-4xl"><DialogHeader><DialogTitle>מגמה חודשית</DialogTitle></DialogHeader><MonthlyTrendModal suggestions={suggestions} /></DialogContent></Dialog>
      <EditSuggestionForm isOpen={showEditForm} onClose={() => setShowEditForm(false)} suggestion={selectedSuggestion} onSave={handleUpdateSuggestion} />
      <MessageForm isOpen={showMessageForm} onClose={() => setShowMessageForm(false)} suggestion={selectedSuggestion} onSend={handleSendMessage} />
      {confirmAction && <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}><AlertDialogContent><AlertDialogHeader><AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle><AlertDialogDescription>{confirmAction.type === "delete" && "פעולה זו תמחק את ההצעה לצמיתות."}</AlertDialogDescription></AlertDialogHeader><AlertDialogFooter><AlertDialogCancel>ביטול</AlertDialogCancel><AlertDialogAction onClick={handleConfirmAction}>אישור</AlertDialogAction></AlertDialogFooter></AlertDialogContent></AlertDialog>}
    </div>
  );
}
--- End of Content for MatchmakerDashboard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MonthlyTrendModal.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface MonthlyTrendModalProps {
  suggestions: Suggestion[];
}

interface MonthlyData {
  month: string;
  year: number;
  count: number;
  active: number;
  pending: number;
  success: number;
  declined: number;
}

const MonthlyTrendModal: React.FC<MonthlyTrendModalProps> = ({
  suggestions,
}) => {
  // Group suggestions by month to prepare data for chart
  const monthlyData = useMemo(() => {
    const data = suggestions.reduce((acc, s) => {
      const createdDate = new Date(s.createdAt);
      const month = createdDate.getMonth();
      const year = createdDate.getFullYear();
      const key = `${year}-${month + 1}`;

      if (!acc[key]) {
        acc[key] = {
          month: new Date(year, month).toLocaleString("he", {
            month: "short",
          }),
          year: year,
          count: 0,
          active: 0,
          pending: 0,
          success: 0,
          declined: 0,
        };
      }

      acc[key].count += 1;

      if (s.category === "ACTIVE") acc[key].active += 1;
      if (s.category === "PENDING") acc[key].pending += 1;
      if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
      if (
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
      ) {
        acc[key].declined += 1;
      }

      return acc;
    }, {} as Record<string, MonthlyData>);

    // Convert to array and sort by date
    return Object.values(data).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      const monthA = new Date(
        a.year,
        a.month === "ינו" ? 0 : new Date(`1 ${a.month} 2000`).getMonth()
      ).getMonth();
      const monthB = new Date(
        b.year,
        b.month === "ינו" ? 0 : new Date(`1 ${b.month} 2000`).getMonth()
      ).getMonth();
      return monthA - monthB;
    });
  }, [suggestions]);

  // Calculate trends
  const trends = useMemo(() => {
    if (monthlyData.length < 2)
      return { active: 0, pending: 0, success: 0, total: 0 };

    const current = monthlyData[monthlyData.length - 1];
    const previous = monthlyData[monthlyData.length - 2];

    const calculateTrend = (current: number, previous: number) => {
      if (previous === 0) return current > 0 ? 100 : 0;
      return Math.round(((current - previous) / previous) * 100);
    };

    return {
      active: calculateTrend(current.active, previous.active),
      pending: calculateTrend(current.pending, previous.pending),
      success: calculateTrend(current.success, previous.success),
      total: calculateTrend(current.count, previous.count),
    };
  }, [monthlyData]);

  if (monthlyData.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        <p>אין מספיק נתונים להצגת מגמה חודשית</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Summary stats */}
      <div className="grid grid-cols-4 gap-3">
        <Card className="p-3">
          <div className="text-sm text-gray-500"> סך כל ההצעות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].count}
            <span
              className={`text-xs ml-2 ${
                trends.total >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.total > 0 ? "+" : ""}
              {trends.total}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות פעילות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].active}
            <span
              className={`text-xs ml-2 ${
                trends.active >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.active > 0 ? "+" : ""}
              {trends.active}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">ממתינות לאישור</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].pending}
            <span
              className={`text-xs ml-2 ${
                trends.pending >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.pending > 0 ? "+" : ""}
              {trends.pending}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות מוצלחות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].success}
            <span
              className={`text-xs ml-2 ${
                trends.success >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.success > 0 ? "+" : ""}
              {trends.success}%
            </span>
          </div>
        </Card>
      </div>

      {/* Main chart */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={monthlyData}
              margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip
                formatter={(value) => [`${value} הצעות`, ""]}
                labelFormatter={(label) => `חודש ${label}`}
              />
              <Legend />
              <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
              <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
              <Bar dataKey="success" name="הצלחות" fill="#10B981" />
              <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* Monthly breakdown table */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">פירוט חודשי</h3>
        <div className="overflow-x-auto">
          <table className="w-full border-collapse">
            <thead>
              <tr className="bg-gray-50">
                <th className="p-2 border text-right">חודש</th>
                <th className="p-2 border text-center">סך הכל</th>
                <th className="p-2 border text-center">פעילות</th>
                <th className="p-2 border text-center">ממתינות</th>
                <th className="p-2 border text-center">הצלחות</th>
                <th className="p-2 border text-center">נדחו</th>
              </tr>
            </thead>
            <tbody>
              {monthlyData
                .slice()
                .reverse()
                .map((month, idx) => (
                  <tr
                    key={idx}
                    className={idx % 2 === 0 ? "bg-white" : "bg-gray-50"}
                  >
                    <td className="p-2 border font-medium">
                      {month.month} {month.year}
                    </td>
                    <td className="p-2 border text-center">{month.count}</td>
                    <td className="p-2 border text-center">{month.active}</td>
                    <td className="p-2 border text-center">{month.pending}</td>
                    <td className="p-2 border text-center">{month.success}</td>
                    <td className="p-2 border text-center">{month.declined}</td>
                  </tr>
                ))}
            </tbody>
          </table>
        </div>
      </Card>
    </div>
  );
};

export default MonthlyTrendModal;
--- End of Content for MonthlyTrendModal.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { DatePicker } from "@/components/ui/date-picker";
import {
  Search,
  Filter,
  X,
  Calendar,
  User,
  Clock,
  ChevronDown,
  AlertCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import type { SuggestionFilters, SortByOption } from "@/types/suggestions";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: SuggestionFilters;
  onFiltersChange: (filters: SuggestionFilters) => void;
  totalCount: number;
  activeCount: number;
  pendingCount: number;
  historyCount: number;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
  totalCount,
  activeCount,
  pendingCount,
  historyCount,
}) => {
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const activeFilters = Object.keys(filters).length;
  const [dateRange, setDateRange] = useState<{
    from: Date | undefined;
    to: Date | undefined;
  }>({
    from: filters.dateRange?.start,
    to: filters.dateRange?.end,
  });

  const handleRemoveFilter = (key: keyof SuggestionFilters) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  const handleDateRangeChange = (range: {
    from: Date | undefined;
    to: Date | undefined;
  }) => {
    setDateRange(range);
    if (range.from) {
      onFiltersChange({
        ...filters,
        dateRange: {
          start: range.from,
          end: range.to || new Date(),
        },
      });
    } else {
      const newFilters = { ...filters };
      delete newFilters.dateRange;
      onFiltersChange(newFilters);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return <Clock className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_APPROVED":
      case "SECOND_PARTY_APPROVED":
        return <CheckCircle className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
        return <XCircle className="h-4 w-4 ml-1" />;
      default:
        return <AlertCircle className="h-4 w-4 ml-1" />;
    }
  };

  return (
    <div className="space-y-4 mb-6">
      {/* Main filters and search */}
      <div className="flex items-center gap-4">
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות לפי שם, עיר או כל מידע אחר..."
            className="pl-10 text-right pr-10"
          />
        </div>

        <Select
          value={filters.priority?.[0] || "all"}
          onValueChange={(value) =>
            onFiltersChange({
              ...filters,
              priority: value === "all" ? undefined : [value as Priority],
            })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">כל העדיפויות</SelectItem>
            <SelectItem value={Priority.URGENT}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-red-500"></span>
                דחוף
              </div>
            </SelectItem>
            <SelectItem value={Priority.HIGH}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-orange-500"></span>
                גבוהה
              </div>
            </SelectItem>
            <SelectItem value={Priority.MEDIUM}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-blue-500"></span>
                רגילה
              </div>
            </SelectItem>
            <SelectItem value={Priority.LOW}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-gray-500"></span>
                נמוכה
              </div>
            </SelectItem>
          </SelectContent>
        </Select>

        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" className="flex items-center">
              <Calendar className="h-4 w-4 ml-2" />
              <span>טווח זמן</span>
              <ChevronDown className="h-4 w-4 mr-2" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-4" align="end">
            <div className="space-y-2">
              <h4 className="font-medium">בחר טווח תאריכים</h4>
              <DatePicker
                onChange={handleDateRangeChange}
                value={dateRange}
                isRange={true}
              />
              <div className="flex justify-end mt-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() =>
                    handleDateRangeChange({ from: undefined, to: undefined })
                  }
                >
                  נקה
                </Button>
              </div>
            </div>
          </PopoverContent>
        </Popover>

        <Button
          variant={showAdvancedFilters ? "default" : "outline"}
          onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
        >
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Stats Row */}
      <div className="flex justify-between bg-slate-50 rounded-md p-3">
        <div className="flex items-center gap-6">
          <div className="flex items-center">
            <Badge variant="outline" className="rounded-full px-2 py-0 mr-2">
              {totalCount}
            </Badge>
            <span className="text-sm font-medium">סה״כ הצעות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="default" className="rounded-full px-2 py-0 mr-2">
              {activeCount}
            </Badge>
            <span className="text-sm font-medium">פעילות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="warning" className="rounded-full px-2 py-0 mr-2">
              {pendingCount}
            </Badge>
            <span className="text-sm font-medium">ממתינות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="secondary" className="rounded-full px-2 py-0 mr-2">
              {historyCount}
            </Badge>
            <span className="text-sm font-medium">היסטוריה</span>
          </div>
        </div>

        {activeFilters > 0 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה את כל המסננים ({activeFilters})
          </Button>
        )}
      </div>

      {/* Advanced Filters */}
      {showAdvancedFilters && (
        <div className="bg-slate-50 p-4 rounded-md space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="font-medium">מסננים מתקדמים</h3>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 px-2"
              onClick={() => setShowAdvancedFilters(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Status Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">סטטוס</h4>
              <div className="space-y-2">
                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-first"
                    checked={filters.status?.includes("PENDING_FIRST_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_FIRST_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_FIRST_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-first"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-yellow-600" />
                    ממתין לתשובת צד א׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-second"
                    checked={filters.status?.includes("PENDING_SECOND_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_SECOND_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_SECOND_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-second"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-blue-600" />
                    ממתין לתשובת צד ב׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-approved"
                    checked={
                      filters.status?.includes("FIRST_PARTY_APPROVED") ||
                      filters.status?.includes("SECOND_PARTY_APPROVED")
                    }
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "FIRST_PARTY_APPROVED",
                          "SECOND_PARTY_APPROVED",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) =>
                              s !== "FIRST_PARTY_APPROVED" &&
                              s !== "SECOND_PARTY_APPROVED"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-approved"
                    className="text-sm mr-2 flex items-center"
                  >
                    <CheckCircle className="h-3 w-3 ml-1 text-green-600" />
                    אושר ע״י אחד הצדדים
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-dating"
                    checked={filters.status?.includes("DATING")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [...(filters.status || []), "DATING"];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "DATING"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-dating"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Calendar className="h-3 w-3 ml-1 text-pink-600" />
                    בתהליך היכרות
                  </label>
                </div>
              </div>
            </div>

            {/* User Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">משתתפים</h4>
              <Select
                value={filters.userId || "all"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    userId: value === "all" ? undefined : value,
                  })
                }
              >
                <SelectTrigger>
                  <User className="h-4 w-4 ml-1" />
                  <SelectValue placeholder="בחר משתתף" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">כל המשתתפים</SelectItem>
                  {/* Replace with dynamic user data */}
                  <SelectItem value="user1">ישראל ישראלי</SelectItem>
                  <SelectItem value="user2">שרה כהן</SelectItem>
                  <SelectItem value="user3">דוד לוי</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Sort By */}
            <div>
              <h4 className="text-sm font-medium mb-2">מיון לפי</h4>
              <Select
                value={filters.sortBy || "lastActivity"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    sortBy: value as SortByOption, // Cast to SortByOption
                  })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="מיון לפי" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="lastActivity">פעילות אחרונה</SelectItem>
                  <SelectItem value="createdAt">תאריך יצירה</SelectItem>
                  <SelectItem value="priority">עדיפות</SelectItem>
                  <SelectItem value="decisionDeadline">תאריך יעד</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      )}

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2 flex-wrap">
          {filters.priority && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                עדיפות:{" "}
                {filters.priority[0] === "URGENT"
                  ? "דחוף"
                  : filters.priority[0] === "HIGH"
                  ? "גבוהה"
                  : filters.priority[0] === "MEDIUM"
                  ? "רגילה"
                  : "נמוכה"}
              </span>
              <button
                onClick={() => handleRemoveFilter("priority")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.dateRange && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                תאריך:{" "}
                {new Date(filters.dateRange.start).toLocaleDateString("he-IL")}
                {filters.dateRange.end &&
                  ` - ${new Date(filters.dateRange.end).toLocaleDateString(
                    "he-IL"
                  )}`}
              </span>
              <button
                onClick={() => handleRemoveFilter("dateRange")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.status && filters.status.length > 0 && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                סטטוס:{" "}
                {filters.status.length === 1
                  ? ""
                  : `(${filters.status.length})`}
                {filters.status.length === 1 && (
                  <span className="flex items-center">
                    {getStatusIcon(filters.status[0])}
                    {filters.status[0] === "PENDING_FIRST_PARTY"
                      ? "ממתין לצד א׳"
                      : filters.status[0] === "PENDING_SECOND_PARTY"
                      ? "ממתין לצד ב׳"
                      : filters.status[0]}
                  </span>
                )}
              </span>
              <button
                onClick={() => handleRemoveFilter("status")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.userId && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>משתתף מסוים</span>
              <button
                onClick={() => handleRemoveFilter("userId")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;
--- End of Content for SuggestionActionBar.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  Users,
  CheckCircle,
  Clock,
  Calendar,
  AlertCircle,
  Ban,
  X,
} from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion, SuggestionFilters } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  onClick?: () => void;
  isClickable?: boolean;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
  onFilterChange?: (filter: Partial<SuggestionFilters>) => void;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
  onClick,
  isClickable = false,
}) => (
  <Card
    className={`p-4 ${className} ${
      isClickable ? "cursor-pointer hover:shadow-md transition-shadow" : ""
    }`}
    onClick={onClick}
  >
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value > 0 ? "+" : ""}
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
  onFilterChange,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter((s) => s.category === "ACTIVE").length;
    const pending = suggestions.filter((s) => s.category === "PENDING").length;
    const history = suggestions.filter((s) => s.category === "HISTORY").length;

    const approvedByFirst = suggestions.filter(
      (s) => s.status === "FIRST_PARTY_APPROVED"
    ).length;
    const approvedBySecond = suggestions.filter(
      (s) => s.status === "SECOND_PARTY_APPROVED"
    ).length;
    const declined = suggestions.filter(
      (s) =>
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
    ).length;
    const expired = suggestions.filter((s) => s.status === "EXPIRED").length;
    const dating = suggestions.filter((s) => s.status === "DATING").length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Group suggestions by month
    const monthlyData = suggestions.reduce(
      (acc, s) => {
        const month = new Date(s.createdAt).getMonth();
        const year = new Date(s.createdAt).getFullYear();
        const key = `${year}-${month + 1}`;

        if (!acc[key]) {
          acc[key] = {
            month: new Date(year, month).toLocaleString("he", {
              month: "short",
            }),
            year: year,
            count: 0,
            active: 0,
            pending: 0,
            success: 0,
            declined: 0,
          };
        }

        acc[key].count += 1;

        if (s.category === "ACTIVE") acc[key].active += 1;
        if (s.category === "PENDING") acc[key].pending += 1;
        if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
        if (
          s.status === "FIRST_PARTY_DECLINED" ||
          s.status === "SECOND_PARTY_DECLINED"
        ) {
          acc[key].declined += 1;
        }

        return acc;
      },
      {} as Record<
        string,
        {
          month: string;
          year: number;
          count: number;
          active: number;
          pending: number;
          success: number;
          declined: number;
        }
      >
    );

    // Convert to array and sort by date
    const monthlyArray = Object.values(monthlyData).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      return a.month.localeCompare(b.month);
    });

    // Calculate trends
    const calculateTrend = (currentValue: number, previousValue: number) => {
      if (previousValue === 0) return currentValue > 0 ? 100 : 0;
      return Math.round(((currentValue - previousValue) / previousValue) * 100);
    };

    // Calculate success rate
    const successRate = total > 0 ? Math.round((success / total) * 100) : 0;

    // Get current month stats vs previous month for trend
    let activeTrend = 0;
    let pendingTrend = 0;
    let successTrend = 0;

    if (monthlyArray.length >= 2) {
      const currentMonth = monthlyArray[monthlyArray.length - 1];
      const previousMonth = monthlyArray[monthlyArray.length - 2];

      activeTrend = calculateTrend(currentMonth.active, previousMonth.active);
      pendingTrend = calculateTrend(
        currentMonth.pending,
        previousMonth.pending
      );
      successTrend = calculateTrend(
        currentMonth.success,
        previousMonth.success
      );
    }

    return {
      total,
      active,
      pending,
      history,
      approvedByFirst,
      approvedBySecond,
      declined,
      expired,
      dating,
      success,
      successRate,
      byStatus,
      monthlyData: monthlyArray,
      trends: {
        active: activeTrend,
        pending: pendingTrend,
        success: successTrend,
      },
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() => onFilterChange && onFilterChange({})}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: [
                "DATING",
                "FIRST_PARTY_APPROVED",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            })
          }
        />
        <StatsCard
          icon={Clock}
          title="ממתינות לתגובה"
          value={stats.pending}
          trend={{
            value: stats.trends.pending,
            isPositive: stats.trends.pending >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY"],
            })
          }
        />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${stats.successRate}%`}
          trend={{
            value: stats.trends.success,
            isPositive: stats.trends.success >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING", "ENGAGED", "MARRIED"],
            })
          }
        />
      </div>

      {/* Action Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-3 mt-4">
        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-yellow-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-yellow-600" />
            <div className="text-xs">ממתין לצד א׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_FIRST_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-blue-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_SECOND_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-blue-600" />
            <div className="text-xs">ממתין לצד ב׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_SECOND_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-red-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <X className="w-4 h-4 text-red-600" />
            <div className="text-xs">הצעות שנדחו</div>
            <div className="font-bold ml-auto">{stats.declined}</div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-pink-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Calendar className="w-4 h-4 text-pink-600" />
            <div className="text-xs">בתהליך היכרות</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["DATING"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-gray-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["EXPIRED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Ban className="w-4 h-4 text-gray-600" />
            <div className="text-xs">פג תוקף</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["EXPIRED"] || 0}
            </div>
          </div>
        </Card>
      </div>

      {/* מגמה חודשית נשארת כאן אבל עכשיו היא מוצגת בדיאלוג מודלי */}
      <div className="hidden">
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={stats.monthlyData}
                margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip
                  formatter={(value) => [`${value} הצעות`, ""]}
                  labelFormatter={(label) => `חודש ${label}`}
                />
                <Legend />
                <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
                <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
                <Bar dataKey="success" name="הצלחות" fill="#10B981" />
                <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;
--- End of Content for SuggestionsStats.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx
--------------------------------------------------------------------------------
Content:
// SuggestionDetailsDialog.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ProfileCard } from "@/app/components/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  AlertCircle,
  CheckCircle,
  XCircle,
  MessageCircle,
  Send,
  RefreshCw,
  Edit,
  Calendar,
  Clock,
  Download,
  AlarmClock,
  Trash2,
  MapPin,
  Mail,
  Phone,
  User,
  ExternalLink,
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { MatchSuggestionStatus } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";
import Image from "next/image";

// --- START OF FIX ---
// Define a specific type for all possible suggestion actions to ensure type safety
type SuggestionActionType =
  | "view" | "contact" | "message" | "edit" | "delete" | "resend"
  | "changeStatus" | "reminder" | "sendReminder" | "shareContacts"
  | "scheduleMeeting" | "viewMeetings" | "exportHistory" | "export"
  | "resendToAll";
// --- END OF FIX ---

interface DialogActionData extends ActionAdditionalData {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyId?: string;
  type?: string;
  partyType?: "first" | "second" | "both";
}

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  // --- START OF FIX ---
  // Update the onAction prop to use the specific type instead of a generic string
  onAction: (action: SuggestionActionType, data?: DialogActionData) => void;
  // --- END OF FIX ---
}

// Map status to its display info
const getStatusInfo = (status: MatchSuggestionStatus) => {
  const statusMap: Record<
    string,
    { label: string; icon: React.ElementType; color: string }
  > = {
    DRAFT: { label: "טיוטה", icon: Edit, color: "text-gray-600" },
    PENDING_FIRST_PARTY: {
      label: "ממתין לתשובת צד א׳",
      icon: Clock,
      color: "text-yellow-600",
    },
    FIRST_PARTY_APPROVED: {
      label: "צד א׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    FIRST_PARTY_DECLINED: {
      label: "צד א׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    PENDING_SECOND_PARTY: {
      label: "ממתין לתשובת צד ב׳",
      icon: Clock,
      color: "text-blue-600",
    },
    SECOND_PARTY_APPROVED: {
      label: "צד ב׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    SECOND_PARTY_DECLINED: {
      label: "צד ב׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    AWAITING_MATCHMAKER_APPROVAL: {
      label: "ממתין לאישור שדכן",
      icon: AlertCircle,
      color: "text-purple-600",
    },
    CONTACT_DETAILS_SHARED: {
      label: "פרטי קשר שותפו",
      icon: Send,
      color: "text-purple-600",
    },
    AWAITING_FIRST_DATE_FEEDBACK: {
      label: "ממתין למשוב פגישה",
      icon: MessageCircle,
      color: "text-orange-600",
    },
    DATING: {
      label: "בתהליך היכרות",
      icon: Calendar,
      color: "text-pink-600",
    },
    EXPIRED: { label: "פג תוקף", icon: AlarmClock, color: "text-gray-600" },
    CLOSED: { label: "סגור", icon: XCircle, color: "text-gray-600" },
  };
  return (
    statusMap[status] || {
      label: status as string,
      icon: AlertCircle as React.ElementType,
      color: "text-gray-600",
    }
  );
};

// Status groups for the progress indicator
const statusGroups = [
  ["DRAFT", "PENDING_FIRST_PARTY"],
  ["FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY"],
  ["SECOND_PARTY_APPROVED", "AWAITING_MATCHMAKER_APPROVAL"],
  ["CONTACT_DETAILS_SHARED", "AWAITING_FIRST_DATE_FEEDBACK"],
  ["DATING", "ENGAGED", "MARRIED"],
];
// הוספת מיפוי מלא של כל הסטטוסים האפשריים
const getAllStatusLabels = () => {
  // יצירת מיפוי של כל הסטטוסים האפשריים לפי הסכמה
  const statusLabels: Record<MatchSuggestionStatus, string> = {
    DRAFT: "טיוטה",
    PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
    FIRST_PARTY_APPROVED: "צד א׳ אישר",
    FIRST_PARTY_DECLINED: "צד א׳ דחה",
    PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
    SECOND_PARTY_APPROVED: "צד ב׳ אישר",
    SECOND_PARTY_DECLINED: "צד ב׳ דחה",
    AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
    CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
    AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
    THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
    PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
    ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
    MEETING_PENDING: "ממתין לקביעת פגישה",
    MEETING_SCHEDULED: "פגישה נקבעה",
    MATCH_APPROVED: "ההצעה אושרה",
    MATCH_DECLINED: "ההצעה נדחתה",
    DATING: "בתהליך היכרות",
    ENGAGED: "מאורסים",
    MARRIED: "נישאו",
    EXPIRED: "פג תוקף",
    CLOSED: "סגור",
    CANCELLED: "בוטל",
  };

  return statusLabels;
};
// Helper to determine if a status change is possible
const canChangeStatus = (
  currentStatus: MatchSuggestionStatus
): MatchSuggestionStatus[] => {
  // Status changes that are allowed directly by the matchmaker
  const allowedChanges: Partial<
    Record<MatchSuggestionStatus, MatchSuggestionStatus[]>
  > = {
    // סטטוסים קיימים
    DRAFT: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_FIRST_PARTY: [
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    FIRST_PARTY_APPROVED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    FIRST_PARTY_DECLINED: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_SECOND_PARTY: [
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    SECOND_PARTY_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    SECOND_PARTY_DECLINED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    CONTACT_DETAILS_SHARED: [
      "AWAITING_FIRST_DATE_FEEDBACK",
      "DATING",
      "CANCELLED",
      "CLOSED",
    ],
    AWAITING_FIRST_DATE_FEEDBACK: ["DATING", "CANCELLED", "CLOSED"],
    DATING: ["ENGAGED", "CLOSED"],
    ENGAGED: ["MARRIED", "CLOSED"],
    MARRIED: ["CLOSED"],
    EXPIRED: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY", "CLOSED"],
    CANCELLED: ["DRAFT"],
    CLOSED: [],

    // הוספת הסטטוסים החסרים
    AWAITING_MATCHMAKER_APPROVAL: [
      "CONTACT_DETAILS_SHARED",
      "CANCELLED",
      "CLOSED",
    ],
    THINKING_AFTER_DATE: [
      "PROCEEDING_TO_SECOND_DATE",
      "ENDED_AFTER_FIRST_DATE",
      "CLOSED",
    ],
    PROCEEDING_TO_SECOND_DATE: ["DATING", "CLOSED"],
    ENDED_AFTER_FIRST_DATE: ["CLOSED"],
    MEETING_PENDING: ["MEETING_SCHEDULED", "CANCELLED", "CLOSED"],
    MEETING_SCHEDULED: ["AWAITING_FIRST_DATE_FEEDBACK", "CANCELLED", "CLOSED"],
    MATCH_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    MATCH_DECLINED: ["CLOSED"],
  };

  return allowedChanges[currentStatus] || [];
};

const formatDateSafely = (
  dateInput: Date | string | null | undefined
): string => {
  if (!dateInput) return "לא נקבע";

  // Ensure we're working with a Date object
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;

  // Validate that the date is valid before formatting
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    return "תאריך לא תקין";
  }

  return new Intl.DateTimeFormat("he-IL", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(date);
};

const getDaysRemaining = (
  deadline: Date | string | null | undefined
): number | null => {
  if (!deadline) return null;

  // Convert string to Date if needed
  const deadlineDate =
    typeof deadline === "string" ? new Date(deadline) : deadline;

  // Validate date
  if (!(deadlineDate instanceof Date) || isNaN(deadlineDate.getTime())) {
    return null;
  }

  const today = new Date();
  const diffTime = deadlineDate.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
};

// Get the status group index for progress indicator
const getStatusGroupIndex = (status: MatchSuggestionStatus): number => {
  for (let i = 0; i < statusGroups.length; i++) {
    if (statusGroups[i].includes(status)) {
      return i;
    }
  }
  return -1;
};

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [statusChangeNote, setStatusChangeNote] = useState("");
  const [newStatus, setNewStatus] = useState<MatchSuggestionStatus | null>(
    null
  );
  const [showStatusChange, setShowStatusChange] = useState(false);

  // Calculate allowed status changes based on current status
  const allowedStatusChanges = suggestion
    ? canChangeStatus(suggestion.status as MatchSuggestionStatus)
    : [];

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  // Handle status change
  const handleStatusChange = async () => {
    if (!newStatus || !suggestion) return;

    setIsLoading(true);
    try {
      console.log(
        `שולח בקשה לשינוי סטטוס: ${newStatus} עם הערות: ${
          statusChangeNote || "ללא הערות"
        }`
      );
      // עדכון הקומפוננטה ההורה
      onAction("changeStatus", {
        suggestionId: suggestion.id,
        newStatus,
        notes: statusChangeNote,
      });

      // איפוס מצב הטופס
      setShowStatusChange(false);
      setStatusChangeNote("");
      setNewStatus(null);
    } catch (error) {
      console.error("Error changing status:", error);
      toast.error(
        `שגיאה בעדכון הסטטוס: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  };

  if (!suggestion) return null;

  // Get status display info
  const statusInfo = getStatusInfo(suggestion.status as MatchSuggestionStatus);
  const StatusIcon = statusInfo.icon;

  // Format suggestion dates
  const createdDate = suggestion.createdAt;
  const lastActivityDate = suggestion.lastActivity;
  const decisionDeadlineDate = suggestion.decisionDeadline
    ? suggestion.decisionDeadline
    : null;

  // Days remaining for decision if applicable
  const daysRemaining = decisionDeadlineDate
    ? getDaysRemaining(decisionDeadlineDate)
    : null;

  // Get status progress index for the progress indicator
  const statusGroupIndex = getStatusGroupIndex(
    suggestion.status as MatchSuggestionStatus
  );

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="max-w-6xl max-h-[90vh] flex flex-col p-0"
        style={{ direction: "rtl" }}
      >
        {/* Header with Progress Bar */}
        <div className="bg-gradient-to-r from-slate-50 to-white border-b flex-shrink-0">
          <DialogHeader className="p-6 pb-3">
            <div className="flex items-center justify-between">
              <div>
                <DialogTitle className="text-2xl font-bold">
                  הצעת שידוך #{suggestion.id.toString().split("-")[0]}
                </DialogTitle>
                <DialogDescription className="text-lg mt-1">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} ו
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName}
                </DialogDescription>
              </div>
              <div className="flex items-center gap-3">
                <Badge
                  className={`px-3 py-1.5 ${statusInfo.color} flex items-center gap-1 text-sm shadow-sm`}
                >
                  <StatusIcon className="w-4 h-4" />
                  {statusInfo.label}
                </Badge>
                <Badge
                  variant="outline"
                  className={`px-3 shadow-sm ${
                    suggestion.priority === "URGENT"
                      ? "bg-red-50 text-red-600 border-red-200"
                      : suggestion.priority === "HIGH"
                      ? "bg-orange-50 text-orange-600 border-orange-200"
                      : suggestion.priority === "MEDIUM"
                      ? "bg-blue-50 text-blue-600 border-blue-200"
                      : "bg-gray-50 text-gray-600 border-gray-200"
                  }`}
                >
                  {suggestion.priority === "URGENT"
                    ? "דחוף"
                    : suggestion.priority === "HIGH"
                    ? "עדיפות גבוהה"
                    : suggestion.priority === "MEDIUM"
                    ? "עדיפות רגילה"
                    : "עדיפות נמוכה"}
                </Badge>
              </div>
            </div>
          </DialogHeader>

          {/* Status Progress Indicator */}
          <div className="px-6 pb-4">
            <div className="relative flex items-center justify-between w-full h-3 bg-gray-100 rounded-full mt-4">
              {statusGroupIndex >= 0 && (
                <div
                  className="absolute h-3 bg-gradient-to-r from-blue-400 to-blue-600 rounded-full"
                  style={{
                    width: `${Math.min(
                      ((statusGroupIndex + 1) / statusGroups.length) * 100,
                      100
                    )}%`,
                  }}
                ></div>
              )}
              {statusGroups.map((_, index) => (
                <div
                  key={index}
                  className={`relative z-10 w-6 h-6 rounded-full flex items-center justify-center border-2 ${
                    index <= statusGroupIndex
                      ? "bg-blue-600 border-blue-700 text-white"
                      : "bg-white border-gray-300"
                  }`}
                >
                  {index + 1}
                </div>
              ))}
            </div>
            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
              <span>יצירת הצעה</span>
              <span>אישור ראשוני</span>
              <span>אישור סופי</span>
              <span>שיתוף פרטים</span>
              <span>בתהליך היכרות</span>
            </div>
          </div>
        </div>
        {/* Main Content Area */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex-1 flex flex-col overflow-hidden"
        >
          <TabsList className="px-6 pt-2 border-b justify-end gap-1 flex-shrink-0">
            <TabsTrigger
              value="overview"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              סקירה כללית
            </TabsTrigger>
            <TabsTrigger
              value="firstParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד ראשון
            </TabsTrigger>
            <TabsTrigger
              value="secondParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד שני
            </TabsTrigger>
            <TabsTrigger
              value="timeline"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              ציר זמן
            </TabsTrigger>
            <TabsTrigger
              value="communication"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              תקשורת
            </TabsTrigger>
            <TabsTrigger
              value="actions"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              פעולות
            </TabsTrigger>
          </TabsList>

          <div className="flex-1 overflow-y-auto">
            {/* Overview Tab */}

            <TabsContent
              value="overview"
              className="p-0 m-0 h-full overflow-auto"
            >
              <div className="p-6">
                {/* שינוי 1: שינוי המבנה כך שפרטי ההצעה יהיו בחלק העליון ושני הצדדים יהיו זה לצד זה */}
                <div className="space-y-3">
                  {/* פרטי הצעה - עיצוב מסודר וקומפקטי */}
                  <div className="bg-white rounded-xl shadow-sm border p-4 mb-3 hover:shadow-md transition-shadow">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="text-md font-semibold flex items-center">
                        <Calendar className="w-4 h-4 ml-1 text-blue-600" />
                        פרטי הצעה
                      </h3>
                      <Badge
                        className={`${statusInfo.color} px-2 py-0.5 text-xs`}
                      >
                        <StatusIcon className="w-3 h-3 ml-1" />
                        {statusInfo.label}
                      </Badge>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">תאריך יצירה:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(createdDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">עדכון אחרון:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(lastActivityDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">שדכן:</span>
                        <span className="font-medium mr-1">
                          {`${suggestion.matchmaker?.firstName} ${suggestion.matchmaker?.lastName}`}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">דחיפות:</span>
                        <span
                          className={`font-medium mr-1 ${
                            suggestion.priority === "URGENT"
                              ? "text-red-600"
                              : suggestion.priority === "HIGH"
                              ? "text-orange-600"
                              : suggestion.priority === "MEDIUM"
                              ? "text-blue-600"
                              : "text-gray-600"
                          }`}
                        >
                          {suggestion.priority === "URGENT"
                            ? "דחוף"
                            : suggestion.priority === "HIGH"
                            ? "עדיפות גבוהה"
                            : suggestion.priority === "MEDIUM"
                            ? "עדיפות רגילה"
                            : "עדיפות נמוכה"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד תגובה:</span>
                        <span className="font-medium mr-1">
                          {suggestion.responseDeadline
                            ? formatDateSafely(suggestion.responseDeadline)
                            : "לא נקבע"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד להחלטה:</span>
                        <span
                          className={
                            daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED"
                              ? "text-red-600 font-medium"
                              : "font-medium"
                          }
                        >
                          {decisionDeadlineDate
                            ? formatDateSafely(decisionDeadlineDate)
                            : "לא נקבע"}
                          {daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED" && (
                              <span className="mr-1 text-red-600 text-xs">
                                (
                                {daysRemaining === 0
                                  ? "היום!"
                                  : `נותרו ${daysRemaining} ימים`}
                                )
                              </span>
                            )}
                        </span>
                      </div>
                    </div>

                    <div className="flex justify-end mt-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowStatusChange(true)}
                        disabled={allowedStatusChanges.length === 0}
                        className="text-blue-600 border-blue-200 hover:bg-blue-50 text-xs py-1 h-7"
                      >
                        <RefreshCw className="w-3 h-3 ml-1" />
                        שנה סטטוס
                      </Button>
                    </div>
                  </div>

                  {/* שינוי 2: כרטיסי הצדדים מסודרים זה לצד זה בגריד עם 2 עמודות */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* First Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-blue-800">
                        <User className="w-5 h-5 ml-2 text-blue-600" />
                        צד א׳: {suggestion.firstParty.firstName}{" "}
                        {suggestion.firstParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.firstParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-blue-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.firstParty.firstName}{" "}
                            {suggestion.firstParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.firstPartySent
                              ? formatDateSafely(suggestion.firstPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "FIRST_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "FIRST_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_FIRST_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "FIRST_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "FIRST_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_FIRST_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.firstPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-blue-50 rounded-lg p-3 text-sm border border-blue-100">
                            {suggestion.firstPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-blue-200 hover:bg-blue-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_FIRST_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-yellow-500 hover:bg-yellow-600"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.firstParty.id,
                                partyType: "first",
                              })
                            }
                          >
                            <AlertCircle className="w-4 h-4 ml-2" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>

                    {/* Second Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-purple-800">
                        <User className="w-5 h-5 ml-2 text-purple-600" />
                        צד ב׳: {suggestion.secondParty.firstName}{" "}
                        {suggestion.secondParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.secondParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-purple-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.secondParty.firstName}{" "}
                            {suggestion.secondParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.secondPartySent
                              ? formatDateSafely(suggestion.secondPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "SECOND_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "SECOND_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_SECOND_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "SECOND_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "SECOND_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_SECOND_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.secondPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-purple-50 rounded-lg p-3 text-sm border border-purple-100">
                            {suggestion.secondPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-purple-200 hover:bg-purple-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_SECOND_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-purple-600 hover:bg-purple-700"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.secondParty.id,
                                partyType: "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* מידע נוסף */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
                    {/* Matching Reason Card */}
                    {suggestion.matchingReason && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <User className="w-5 h-5 ml-2 text-green-600" />
                          סיבת ההתאמה
                        </h3>
                        <div className="bg-green-50 rounded-lg border border-green-100 p-4 text-gray-700">
                          {suggestion.matchingReason}
                        </div>
                      </div>
                    )}

                    {/* Internal Notes */}
                    {suggestion.internalNotes && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <AlertCircle className="w-5 h-5 ml-2 text-amber-600" />
                          הערות פנימיות
                        </h3>
                        <div className="bg-amber-50 rounded-lg border border-amber-100 p-4 text-gray-700">
                          {suggestion.internalNotes}
                        </div>
                      </div>
                    )}

                    {/* Quick Actions */}
                    <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center">
                        <RefreshCw className="w-5 h-5 ml-2 text-gray-600" />
                        פעולות מהירות
                      </h3>

                      <div className="grid grid-cols-2 gap-2">
                        <Button
                          variant="outline"
                          className="justify-start"
                          onClick={() =>
                            onAction("edit", { suggestionId: suggestion.id, suggestion: suggestion })
                          }
                        >
                          <Edit className="w-4 h-4 ml-1" />
                          ערוך הצעה
                        </Button>

                        {(suggestion.status === "PENDING_FIRST_PARTY" ||
                          suggestion.status === "PENDING_SECOND_PARTY") && (
                          <Button
                            variant="outline"
                            className="justify-start"
                            onClick={() =>
                              onAction("sendReminder", {
                                suggestionId: suggestion.id,
                                type:
                                  suggestion.status === "PENDING_FIRST_PARTY"
                                    ? "first"
                                    : "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}

                        {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                          suggestion.status === "SECOND_PARTY_APPROVED") && (
                          <Button
                            variant="default"
                            className="justify-start bg-green-600 hover:bg-green-700"
                            onClick={() =>
                              onAction("shareContacts", {
                                suggestionId: suggestion.id,
                              })
                            }
                          >
                            <ExternalLink className="w-4 h-4 ml-1" />
                            שתף פרטי קשר
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* First Party Tab */}
            <TabsContent value="firstParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-blue-800">
                      {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-blue-100 text-blue-700 border-blue-200">
                      צד א׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.firstParty.images.find((img) => img.isMain)
                            ?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-blue-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty?.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.birthDate
                              ? new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-blue-200 hover:bg-blue-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.firstParty.id,
                          partyType: "first",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_FIRST_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד ראשון
                      </Button>
                    )}

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד שני
                      </Button>
                    )}

                    {suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyType: "both",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח בקשת עדכון מפגש
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.firstParty.profile}
                  images={suggestion.firstParty.images}
                  questionnaire={firstPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-blue-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.firstParty.firstName}
                  </h3>
                  {suggestion.firstPartyNotes ? (
                    <p>{suggestion.firstPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Second Party Tab */}
            <TabsContent value="secondParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-purple-800">
                      {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-purple-100 text-purple-700 border-purple-200">
                      צד ב׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.secondParty.images.find(
                            (img) => img.isMain
                          )?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-purple-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.birthDate
                              ? new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-purple-200 hover:bg-purple-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.secondParty.id,
                          partyType: "second",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="flex-1 bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-1" />
                        שלח תזכורת
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.secondParty.profile}
                  images={suggestion.secondParty.images}
                  questionnaire={secondPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-purple-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.secondParty.firstName}
                  </h3>
                  {suggestion.secondPartyNotes ? (
                    <p>{suggestion.secondPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Timeline Tab */}
            <TabsContent value="timeline" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 mb-4">
                  <h3 className="text-lg font-semibold flex items-center">
                    <Calendar className="w-5 h-5 ml-2 text-blue-600" />
                    התקדמות ההצעה
                  </h3>
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="p-2 rounded-full bg-blue-100 mr-2">
                        <Clock className="w-5 h-5 text-blue-600" />
                      </div>
                      <div>
                        <div className="font-medium">
                          נוצר: {formatDateSafely(suggestion.createdAt)}
                        </div>
                        <div className="text-sm text-gray-500">
                          פעילות אחרונה:{" "}
                          {formatDateSafely(suggestion.lastActivity)}
                        </div>
                      </div>
                    </div>
                    <Badge
                      className={`px-3 py-1.5 flex items-center gap-1 ${statusInfo.color}`}
                    >
                      <StatusIcon className="w-4 h-4" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border p-5">
                  <h3 className="text-lg font-semibold mb-4">
                    היסטוריית סטטוסים
                  </h3>

                  <ScrollArea className="h-[400px] pr-4">
                    {isLoading ? (
                      <div className="flex items-center justify-center h-32">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-700"></div>
                      </div>
                    ) : (
                      <Timeline
                        items={(suggestion?.statusHistory || []).map(
                          (history) => ({
                            title: getStatusInfo(
                              history.status as MatchSuggestionStatus
                            ).label,
                            description: history.notes || "אין הערות",
                            date:
                              typeof history.createdAt === "string"
                                ? new Date(history.createdAt)
                                : history.createdAt,
                            icon: history.status.includes("APPROVED")
                              ? CheckCircle
                              : history.status.includes("DECLINED")
                              ? XCircle
                              : history.status.includes("PENDING")
                              ? Clock
                              : AlertCircle,
                            iconColor: history.status.includes("APPROVED")
                              ? "text-green-600"
                              : history.status.includes("DECLINED")
                              ? "text-red-600"
                              : history.status.includes("PENDING")
                              ? "text-yellow-600"
                              : "text-blue-600",
                          })
                        )}
                      />
                    )}
                  </ScrollArea>

                  <div className="mt-4 flex justify-end">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() =>
                        onAction("exportHistory", {
                          suggestionId: suggestion.id,
                        })
                      }
                    >
                      <Download className="w-4 h-4 ml-1" />
                      ייצא היסטוריה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* Communication Tab */}
            <TabsContent value="communication" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-blue-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">תקשורת</h3>
                  <p className="text-gray-600">
                    ניהול התקשורת עם הצדדים השונים בהצעה. שליחת הודעות ותזכורות.
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* First Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-blue-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-blue-600" />
                      תקשורת עם {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full justify-start border-blue-200 hover:bg-blue-50"
                        onClick={() =>
                          onAction("message", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <MessageCircle className="w-4 h-4 ml-2" />
                        שלח הודעה
                      </Button>

                      {suggestion.status === "PENDING_FIRST_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>

                  {/* Second Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-purple-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-purple-600" />
                      תקשורת עם {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full"
                        onClick={() =>
                          onAction("edit", {
                            suggestionId: suggestion.id,
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <Edit className="w-4 h-4 ml-2" />
                        ערוך פרטי הצעה
                      </Button>

                      {suggestion.status === "PENDING_SECOND_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {/* Meeting Arrangement Section */}
                {(suggestion.status === "CONTACT_DETAILS_SHARED" ||
                  suggestion.status === "DATING") && (
                  <div className="mt-6 bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Calendar className="w-5 h-5 ml-2 text-pink-600" />
                      תיאום פגישה
                    </h4>
                    <div className="space-y-3">
                      <p className="text-gray-600">
                        סיוע בתיאום פגישה בין הצדדים ותיעוד מועדי הפגישות
                      </p>
                      <div className="flex gap-2">
                        <Button
                          className="flex-1 bg-pink-600 hover:bg-pink-700"
                          onClick={() =>
                            onAction("scheduleMeeting", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Calendar className="w-4 h-4 ml-2" />
                          תאם פגישה חדשה
                        </Button>
                        <Button
                          variant="outline"
                          className="flex-1"
                          onClick={() =>
                            onAction("viewMeetings", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Clock className="w-4 h-4 ml-2" />
                          צפה בפגישות קודמות
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </TabsContent>

            {/* Actions Tab */}
            <TabsContent value="actions" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-gray-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">פעולות נוספות</h3>
                  <p className="text-gray-600">
                    פעולות נוספות שניתן לבצע על הצעת השידוך
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {/* Status Change */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-blue-100 w-fit mb-3">
                      <RefreshCw className="w-6 h-6 text-blue-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">שינוי סטטוס</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עדכון סטטוס ההצעה בהתאם להתקדמות התהליך
                    </p>
                    <Button
                      className="w-full"
                      onClick={() => setShowStatusChange(true)}
                      disabled={allowedStatusChanges.length === 0}
                    >
                      <RefreshCw className="w-4 h-4 ml-2" />
                      שנה סטטוס
                    </Button>
                  </div>

                  {/* Edit Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-amber-100 w-fit mb-3">
                      <Edit className="w-6 h-6 text-amber-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">עריכת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עריכת פרטי ההצעה, סיבת ההתאמה והערות
                    </p>
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() =>
                        onAction("edit", { suggestionId: suggestion.id, suggestion: suggestion })
                      }
                    >
                      <Edit className="w-4 h-4 ml-2" />
                      ערוך פרטי הצעה
                    </Button>
                  </div>

                  {/* Delete Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-red-100 w-fit mb-3">
                      <Trash2 className="w-6 h-6 text-red-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">מחיקת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      מחיקת ההצעה לצמיתות מהמערכת
                    </p>
                    <Button
                      variant="outline"
                      className="border-red-200 hover:bg-red-50 text-red-600"
                      onClick={() =>
                        onAction("delete", { suggestionId: suggestion.id })
                      }
                    >
                      <Trash2 className="w-4 h-4 ml-1" />
                      מחק הצעה
                    </Button>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Resend to Both Parties */}
                  {canChangeStatus(
                    suggestion.status as MatchSuggestionStatus
                  ).includes("PENDING_FIRST_PARTY") && (
                    <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                      <h4 className="text-lg font-semibold mb-3 flex items-center">
                        <Send className="w-5 h-5 ml-2 text-purple-600" />
                        שליחה מחדש
                      </h4>
                      <p className="text-sm text-gray-600 mb-3">
                        שליחת ההצעה מחדש לשני הצדדים
                      </p>
                      <Button
                        className="w-full bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("resendToAll", {
                            suggestionId: suggestion.id,
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-2" />
                        שלח מחדש לשני הצדדים
                      </Button>
                    </div>
                  )}

                  {/* Export Suggestion Details */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Download className="w-5 h-5 ml-2 text-green-600" />
                      ייצוא פרטי הצעה
                    </h4>
                    <p className="text-sm text-gray-600 mb-3">
                      ייצוא כל פרטי ההצעה בפורמט PDF או CSV
                    </p>
                    <Button
                      variant="outline"
                      className="w-full border-green-200 hover:bg-green-50 text-green-700"
                      onClick={() =>
                        onAction("export", { suggestionId: suggestion.id })
                      }
                    >
                      <Download className="w-4 h-4 ml-2" />
                      ייצא פרטי הצעה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>
          </div>
        </Tabs>
        {/* Status Change Dialog */}
        {showStatusChange && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-xl max-w-md w-full shadow-lg">
              <h3 className="text-xl font-bold mb-4 flex items-center">
                <RefreshCw className="w-5 h-5 ml-2 text-blue-600" />
                שינוי סטטוס הצעה
              </h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס נוכחי
                  </label>
                  <div className="flex items-center p-2 bg-gray-50 rounded border">
                    <StatusIcon
                      className={`w-5 h-5 ml-2 ${statusInfo.color}`}
                    />
                    <span className="font-medium">{statusInfo.label}</span>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס חדש
                  </label>
                  <Select
                    value={newStatus || undefined}
                    onValueChange={(value) => {
                      console.log("Selected new status:", value);
                      setNewStatus(value as MatchSuggestionStatus);
                    }}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="בחר/י סטטוס חדש" />
                    </SelectTrigger>
                    <SelectContent className="max-h-80 overflow-y-auto">
                      {/* מציג את כל הסטטוסים האפשריים במערכת */}
                      {Object.entries(getAllStatusLabels()).map(
                        ([status, label]) => (
                          <SelectItem key={status} value={status}>
                            {label}
                          </SelectItem>
                        )
                      )}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    הערות לשינוי סטטוס
                  </label>
                  <Textarea
                    value={statusChangeNote}
                    onChange={(e) => setStatusChangeNote(e.target.value)}
                    placeholder="הערות אופציונליות לשינוי הסטטוס..."
                    className="min-h-[100px] resize-none"
                  />
                </div>

                <div className="flex justify-end gap-2 pt-2">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowStatusChange(false);
                      setNewStatus(null);
                      setStatusChangeNote("");
                    }}
                  >
                    ביטול
                  </Button>
                  <Button
                    onClick={handleStatusChange}
                    disabled={!newStatus || isLoading}
                    className="bg-blue-600 hover:bg-blue-700"
                  >
                    {isLoading ? (
                      <>
                        <div className="h-4 w-4 ml-2 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                        מעדכן...
                      </>
                    ) : (
                      "שמור שינוי"
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}
        <DialogFooter className="px-6 py-4 border-t bg-gray-50">
          <div className="flex justify-between w-full">
            <Button
              variant="outline"
              className="border-red-200 hover:bg-red-50 text-red-600"
              onClick={() =>
                onAction("delete", { suggestionId: suggestion.id })
              }
            >
              <Trash2 className="w-4 h-4 ml-1" />
              מחק הצעה
            </Button>

            <div className="flex gap-2">
              <Button variant="outline" onClick={onClose}>
                סגור
              </Button>
              <Button
                // תיקון: המקום השלישי בו צריך לוודא שהפונקציה מופעלת נכון
                onClick={() => setShowStatusChange(true)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <RefreshCw className="w-4 h-4 ml-1" />
                עדכן סטטוס
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;
--- End of Content for SuggestionDetailsDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks\useMatchmaking.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS } from '../../new/constants/matchingCriteria';
import type { User } from '@/types/next-auth';
// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: User[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: User;
  candidateB: User;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: User;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile?.gender === candidateB.profile?.gender ||
          candidateA.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA.profile, candidateB.profile);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;
--- End of Content for useMatchmaking.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Users } from "lucide-react";

import type { Suggestion, SuggestionFilters } from "@/types/suggestions";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: SuggestionFilters;
  searchQuery: string;
  type: "active" | "pending" | "history";
  onSuggestionDeleted?: (id: string) => void;
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
  onSuggestionDeleted,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [, setShowDeleteDialog] = useState(false);
  const [suggestionToDelete, setSuggestionToDelete] = useState<string | null>(
    null
  );

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Priority filter
      if (
        filters.priority?.length &&
        !filters.priority.includes(suggestion.priority)
      ) {
        return false;
      }

      // Date range filter
      if (filters.dateRange) {
        const createdAt = new Date(suggestion.createdAt);
        if (
          createdAt < filters.dateRange.start ||
          createdAt > filters.dateRange.end
        ) {
          return false;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const confirmDelete = async () => {
    if (!suggestionToDelete) return;

    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionToDelete}/delete`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to delete suggestion");
      }

      toast.success("ההצעה נמחקה בהצלחה");
      if (onSuggestionDeleted) {
        onSuggestionDeleted(suggestionToDelete);
      }
    } catch (error) {
      console.error("Error deleting suggestion:", error);
      toast.error("שגיאה במחיקת ההצעה");
    } finally {
      setShowDeleteDialog(false);
      setSuggestionToDelete(null);
    }
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                {/* Rest of the JSX remains the same */}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />

      <AlertDialog>
        {" "}
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
            <AlertDialogDescription>
              פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              מחיקה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default ManagerSuggestionsList;
--- End of Content for ManagerSuggestionsList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useMemo } from "react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Search, Filter, SortDesc } from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";
import SuggestionCard from "../cards/SuggestionCard";
import { LoadingContainer } from "../../new/shared/LoadingStates";
import type {
  Suggestion,
  ActionAdditionalData,
  SuggestionStatusHistory,
} from "@/types/suggestions";

interface PartyInfo {
  id: string;
  firstName: string;
  lastName: string;
  profile: UserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: SuggestionStatusHistory[]; // הוספת השדה החסר
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  isLoading?: boolean;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const SORT_OPTIONS = [
  { value: "latest", label: "החדשים ביותר" },
  { value: "oldest", label: "הישנים ביותר" },
  { value: "deadline", label: "לפי תאריך יעד" },
  { value: "priority", label: "לפי דחיפות" },
];

const STATUS_OPTIONS = [
  { value: "PENDING_FIRST_PARTY", label: "ממתין לצד א׳" },
  { value: "PENDING_SECOND_PARTY", label: "ממתין לצד ב׳" },
  { value: "FIRST_PARTY_APPROVED", label: "צד א׳ אישר" },
  { value: "SECOND_PARTY_APPROVED", label: "צד ב׳ אישר" },
  { value: "CONTACT_DETAILS_SHARED", label: "פרטי קשר שותפו" },
  { value: "DATING", label: "בתהליך היכרות" },
];

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions,
  isLoading = false,
  onAction,
  className,
}) => {
  // Filters state
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState("latest");
  const [statusFilter, setStatusFilter] = useState<string[]>([]);
  const [showFilters, setShowFilters] = useState(false);

  // Filter and sort suggestions
  const filteredSuggestions = useMemo(() => {
    let result = [...suggestions];

    // Apply status filter
    if (statusFilter.length > 0) {
      result = result.filter((s) => statusFilter.includes(s.status));
    }

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (s) =>
          s.firstParty.firstName.toLowerCase().includes(query) ||
          s.firstParty.lastName.toLowerCase().includes(query) ||
          s.secondParty.firstName.toLowerCase().includes(query) ||
          s.secondParty.lastName.toLowerCase().includes(query) ||
          s.firstParty.profile.city?.toLowerCase().includes(query) ||
          s.secondParty.profile.city?.toLowerCase().includes(query)
      );
    }

    // Apply sorting
    switch (sortBy) {
      case "latest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
        );
        break;
    }

    return result;
  }, [suggestions, searchQuery, sortBy, statusFilter]);

  return (
    <div className={className}>
      {/* Filters Bar */}
      <div className="mb-6 space-y-4">
        <div className="flex gap-4">
          <div className="relative flex-1">
            <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
            <Input
              placeholder="חיפוש לפי שם או עיר..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 text-right"
            />
          </div>

          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-48">
              <SortDesc className="w-4 h-4 ml-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {SORT_OPTIONS.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Button
            variant="outline"
            onClick={() => setShowFilters(!showFilters)}
          >
            <Filter className="w-4 h-4 ml-2" />
            סינון
          </Button>
        </div>

        {showFilters && (
          <div className="flex gap-4">
            {STATUS_OPTIONS.map((status) => (
              <Button
                key={status.value}
                variant={
                  statusFilter.includes(status.value) ? "default" : "outline"
                }
                onClick={() => {
                  setStatusFilter((prev) =>
                    prev.includes(status.value)
                      ? prev.filter((s) => s !== status.value)
                      : [...prev, status.value]
                  );
                }}
                className="text-sm"
              >
                {status.label}
              </Button>
            ))}
          </div>
        )}
      </div>

      {/* Suggestions Grid */}
      {isLoading ? (
        <LoadingContainer>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <div
                key={i}
                className="h-64 bg-gray-100 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </LoadingContainer>
      ) : (
        // בערך בשורה 196 - שנה את הגריד להצגה מימין לשמאל
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
          {filteredSuggestions.map((suggestion) => (
            <SuggestionCard
              key={suggestion.id}
              suggestion={suggestion as unknown as Suggestion}
              onAction={onAction}
              className="rtl" // הוסף מחלקה זו
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default SuggestionsList;
--- End of Content for SuggestionsList.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\NotificationService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/NotificationService.ts

import { MatchSuggestionStatus } from '@prisma/client';
import { SuggestionWithParties } from '../suggestions/StatusTransitionService';

export type RecipientInfo = {
  email: string;
  phone?: string; // Phone number with international prefix, e.g.: +972501234567
  name: string;
};

export type NotificationContent = {
  subject: string;
  body: string;
  htmlBody?: string; // HTML version for email
};

export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
  channels: NotificationChannel[];
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
  priority?: 'high' | 'normal' | 'low';
  attachments?: Array<{
    filename: string;
    content: Buffer | string;
    contentType: string;
  }>;
  customMessage?: string;
  metadata?: Record<string, unknown>;
};

export interface NotificationAdapter {
  canSendTo(recipient: RecipientInfo): boolean;
  send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean>;
  getChannelType(): NotificationChannel;
}

export class NotificationService {
  private static instance: NotificationService;
  private adapters: Map<NotificationChannel, NotificationAdapter> = new Map();

  private constructor() {}

  public static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  public registerAdapter(adapter: NotificationAdapter): void {
    this.adapters.set(adapter.getChannelType(), adapter);
    console.log(`Registered ${adapter.getChannelType()} adapter`);
  }

  public async sendNotification(
    recipient: RecipientInfo,
    content: NotificationContent,
    options: NotificationOptions
  ): Promise<Record<NotificationChannel, boolean>> {
    const results: Record<NotificationChannel, boolean> = {} as Record<NotificationChannel, boolean>;
    console.log(`Attempting to send notification to ${recipient.name} via channels:`, options.channels);

    for (const channel of options.channels) {
      const adapter = this.adapters.get(channel);
      if (!adapter) {
        console.warn(`No adapter registered for channel: ${channel}`);
        results[channel] = false;
        continue;
      }

      if (!adapter.canSendTo(recipient)) {
        console.warn(`Cannot send to recipient via ${channel}: missing required info`);
        results[channel] = false;
        continue;
      }

      try {
        console.log(`Sending ${channel} notification to ${recipient.name}`);
        results[channel] = await adapter.send(recipient, content);
        console.log(`${channel} notification sent successfully: ${results[channel]}`);
      } catch (error) {
        console.error(`Error sending notification via ${channel}:`, error);
        results[channel] = false;
      }
    }

    return results;
  }

  // Dedicated method for handling suggestion-related notifications
  public async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
    options: Partial<NotificationOptions> = {}
  ): Promise<void> {
    console.log(`Processing notifications for suggestion ${suggestion.id} with status ${suggestion.status}`);
    
    const templateContent = this.getSuggestionTemplate(suggestion, options.customMessage);
    if (!templateContent) {
      console.log(`No template found for status ${suggestion.status} - skipping notification`);
      return;
    }
  
    const recipientsWithChannels = this.getRecipientsForSuggestion(suggestion);
    console.log(`Found ${recipientsWithChannels.length} potential recipients`);
  
    for (const { recipient, preferredChannels } of recipientsWithChannels) {
      // Filter recipients based on notifyParties if provided
      if (options.notifyParties) {
        const recipientType = this.getRecipientType(recipient, suggestion);
        if (!recipientType || !options.notifyParties.includes(recipientType)) {
          console.log(`Skipping recipient ${recipient.name} (${recipientType}) - not in notifyParties`, options.notifyParties);
          continue;
        }
      }
      
      const channelsToUse = options.channels || preferredChannels || ['email'];
      console.log(`Sending notification to ${recipient.name} via channels:`, channelsToUse);
      
      await this.sendNotification(
        recipient,
        templateContent,
        { ...options, channels: channelsToUse }
      );
    }
    
    console.log(`Finished processing notifications for suggestion ${suggestion.id}`);
  }

  // Helper method to determine recipient type
  private getRecipientType(
    recipient: RecipientInfo, 
    suggestion: SuggestionWithParties
  ): 'first' | 'second' | 'matchmaker' | null {
    if (recipient.email === suggestion.firstParty.email) {
      return 'first';
    } else if (recipient.email === suggestion.secondParty.email) {
      return 'second';
    } else if (recipient.email === suggestion.matchmaker.email) {
      return 'matchmaker';
    }
    return null;
  }

  private getSuggestionTemplate(
    suggestion: SuggestionWithParties,
    customMessage?: string
  ): NotificationContent | null {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    // If there's a custom message, use it instead of the template
    if (customMessage) {
      const reviewUrl = `${baseUrl}/suggestions/${suggestion.id}/review`;
      return {
        subject: "עדכון בהצעת שידוך",
        body: `שלום,\n\n${customMessage}\n\nלצפייה בפרטי ההצעה: ${reviewUrl}\n\nבברכה,\nמערכת השידוכים`,
        htmlBody: `
          <div dir="rtl">
            <h2>שלום,</h2>
            <p>${customMessage}</p>
            <p>לצפייה בפרטי ההצעה: <a href="${reviewUrl}">לחץ כאן</a></p>
            <p>בברכה,<br>מערכת השידוכים</p>
          </div>
        `
      };
    }
    
    // Otherwise use the template based on status
    switch (suggestion.status) {
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.firstParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.firstParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בהצעה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.\n\nההצעה תועבר כעת באופן אוטומטי לצד השני.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.</p><p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.secondParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nהצד הראשון כבר אישר את ההצעה.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.secondParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>הצד הראשון כבר אישר את ההצעה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בפרטי ההצעה ומענה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.\n\nשני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.</p><p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
    
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Prepare contact details with multi-line support
        const firstPartyDetails = this.formatUserDetails(suggestion.firstParty);
        const secondPartyDetails = this.formatUserDetails(suggestion.secondParty);
        
        return {
          subject: 'פרטי קשר להצעת השידוך',
          body: `ברכות! שני הצדדים אישרו את הצעת השידוך.\n\nפרטי הקשר של הצד הראשון:\n${firstPartyDetails}\n\nפרטי הקשר של הצד השני:\n${secondPartyDetails}\n\nאנא צרו קשר בהקדם לתיאום פגישה ראשונה.\n\nבהצלחה!`,
          htmlBody: `<div dir="rtl"><h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2><p>פרטי הקשר של הצד הראשון:</p><pre>${firstPartyDetails}</pre><p>פרטי הקשר של הצד השני:</p><pre>${secondPartyDetails}</pre><p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p><p>בהצלחה!</p></div>`
        };
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return {
          subject: 'בקשה למשוב על הפגישה הראשונה',
          body: `שלום,\n\nנשמח לקבל את המשוב שלך על הפגישה הראשונה.\n\nלשליחת המשוב: ${baseUrl}/suggestions/${suggestion.id}/feedback\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום,</h2><p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/feedback">לשליחת המשוב</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
        return {
          subject: 'בקשת זמן למחשבה לאחר הפגישה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nאחד הצדדים ביקש זמן למחשבה לאחר הפגישה.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.DATING:
        return {
          subject: 'עדכון סטטוס - בתהליך היכרות',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהזוג נמצא בתהליך היכרות.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הזוג נמצא בתהליך היכרות.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.ENGAGED:
        return {
          subject: 'מזל טוב! - אירוסין',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.MARRIED:
        return {
          subject: 'מזל טוב! - חתונה',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.EXPIRED:
        return {
          subject: 'הצעת השידוך פגה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהצעת השידוך פגה עקב חוסר מענה במועד.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הצעת השידוך פגה עקב חוסר מענה במועד.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      default:
        // For other statuses, return null to skip notification
        console.log(`No template defined for status: ${suggestion.status}`);
        return null;
    }
  }

  private getRecipientsForSuggestion(suggestion: SuggestionWithParties): Array<{
    recipient: RecipientInfo;
    preferredChannels: NotificationChannel[];
  }> {
    const recipients: Array<{
      recipient: RecipientInfo;
      preferredChannels: NotificationChannel[];
    }> = [];
    
    // Logic to determine recipients based on suggestion status
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email'] // Email only for drafts
        });
        break;
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.firstParty.email,
            phone: suggestion.firstParty.phone || undefined,
            name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.secondParty.email,
            phone: suggestion.secondParty.phone || undefined,
            name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email']
          }
        );
        break;
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        // Send to both parties
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;
      
      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;

      default:
        // Default: send to matchmaker only
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email']
        });
        break;
    }

    return recipients;
  }

  // Helper function to format contact details
  private formatUserDetails(user: { 
    firstName: string; 
    lastName: string; 
    email: string; 
    phone?: string | null 
  }): string {
    const details = [
      `שם: ${user.firstName} ${user.lastName}`,
      `אימייל: ${user.email}`,
    ];

    if (user.phone) {
      details.push(`טלפון: ${user.phone}`);
    }

    return details.join('\n');
  }
}

export const notificationService = NotificationService.getInstance();
--- End of Content for NotificationService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\initNotifications.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/initNotifications.ts

import { notificationService } from './NotificationService';
import { emailAdapter } from './adapters/EmailAdapter';
import { whatsAppAdapter } from './adapters/WhatsAppAdapter';

// Define notification channel type
export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
    channels: NotificationChannel[];
    notifyParties?: ('first' | 'second' | 'matchmaker')[];
    customMessage?: string;
  };

/**
 * Initializes the notification service by registering all available adapters
 * @returns The initialized notification service
 */
export function initNotificationService() {
  // Register adapters
  notificationService.registerAdapter(emailAdapter);
  notificationService.registerAdapter(whatsAppAdapter);
  
  console.log('Notification service initialized with email and WhatsApp adapters');
  
  return notificationService;
}
--- End of Content for initNotifications.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\EmailAdapter.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/adapters/EmailAdapter.ts

import { NotificationAdapter, NotificationChannel, RecipientInfo, NotificationContent } from '../NotificationService';
import nodemailer from 'nodemailer';

export class EmailAdapter implements NotificationAdapter {
  private static instance: EmailAdapter;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure the transporter exactly like in EmailService
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER || '',
        pass: process.env.GMAIL_APP_PASSWORD || '',
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on initialization
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig(): Promise<void> {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw, to allow the system to continue even if verification fails
    }
  }

  public static getInstance(): EmailAdapter {
    if (!EmailAdapter.instance) {
      EmailAdapter.instance = new EmailAdapter();
    }
    return EmailAdapter.instance;
  }

  public getChannelType(): NotificationChannel {
    return 'email';
  }

  public canSendTo(recipient: RecipientInfo): boolean {
    return !!recipient.email;
  }

  public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
    try {
      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME || 'מערכת השידוכים'} <${process.env.GMAIL_USER || ''}>`,
        to: recipient.email,
        subject: content.subject,
        text: content.body,
        html: content.htmlBody || content.body.replace(/\n/g, '<br>'),
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
        to: recipient.email,
        subject: content.subject
      });

      return true;
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        recipient: recipient.email,
        subject: content.subject
      });
      return false;
    }
  }
}

export const emailAdapter = EmailAdapter.getInstance();
--- End of Content for EmailAdapter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\WhatsAppAdapter.ts
--------------------------------------------------------------------------------
Content:
// lib/WhatsAppAdapter.ts
import {
  NotificationAdapter,
  NotificationChannel,
  RecipientInfo,
  NotificationContent as BaseNotificationContent
} from '../NotificationService'; // Assuming NotificationService.ts exists in the same directory
import twilio from 'twilio';
// Import the specific type for message creation options if available
import { MessageListInstanceCreateOptions } from 'twilio/lib/rest/api/v2010/account/message';

// --- Define an extended NotificationContent interface ---
// This adds the optional adapter-specific data structure
interface NotificationContent extends BaseNotificationContent {
  _adapterSpecificData?: {
      contentSid?: string;
      contentVariables?: string; // Should be a JSON string
      // Add other potential adapter-specific fields here
  };
}
// --- End Interface Extension ---

// --- Type Guard for Twilio-like Errors ---
interface PotentialTwilioError {
  code?: number | string;
  message?: string;
  // Add other potential properties like 'status', 'moreInfo', etc. if needed
}

/**
* Type guard to check if an unknown error object might be a Twilio API error
* by checking for the presence of 'code' or 'message' properties.
* @param error The unknown value caught in a catch block.
* @returns True if the error object has properties common to Twilio errors, false otherwise.
*/
function isPotentialTwilioError(error: unknown): error is PotentialTwilioError {
  // Check if it's a non-null object and has either 'code' or 'message' property
  return typeof error === 'object' && error !== null && ('code' in error || 'message' in error);
}
// --- End Type Guard ---

// --- Helper: Logger (optional but recommended) ---
// Using Record<string, unknown> or object instead of any
const logger = {
info: (message: string, meta?: Record<string, unknown> | object) => {
  console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
warn: (message: string, meta?: Record<string, unknown> | object) => {
  console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
error: (message: string, meta?: Record<string, unknown> | object) => {
  let logMeta = meta || {};
  // If the meta object itself is an Error, extract relevant info
  if (meta instanceof Error) {
      logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
  } else if (isPotentialTwilioError(meta)) {
      // If it's potentially a Twilio error passed directly
      logMeta = { code: meta.code, message: meta.message, ...meta };
  }
  console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', service: 'WhatsAppAdapter', message, ...logMeta }));
},
};
// --- End Logger ---


export class WhatsAppAdapter implements NotificationAdapter {
// Singleton instance
private static instance: WhatsAppAdapter;
// Twilio client instance (typed)
private client: twilio.Twilio | null = null;
// Configured Twilio WhatsApp sender number
private fromNumber: string = '';

/**
 * Private constructor to enforce singleton pattern.
 * Initializes the Twilio client using environment variables.
 */
private constructor() {
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  this.fromNumber = process.env.TWILIO_WHATSAPP_NUMBER || ''; // Get number from env

  // Validate configuration
  if (!accountSid || !authToken || !this.fromNumber) {
    logger.error('Missing Twilio configuration details', {
        hasSid: !!accountSid,
        hasToken: !!authToken,
        hasWhatsAppNumber: !!this.fromNumber,
        detail: "WhatsApp notifications will be unavailable."
    });
    // Do not throw, allow graceful degradation if possible
  } else {
    try {
      // Initialize Twilio client
      this.client = twilio(accountSid, authToken);
      logger.info('Twilio client initialized successfully', { fromWhatsAppNumber: this.fromNumber });
    } catch (error: unknown) { // Catch as unknown
      logger.error('Failed to initialize Twilio client during constructor', { error });
      this.client = null; // Ensure client is null on initialization failure
    }
  }
}

/**
 * Gets the singleton instance of the WhatsAppAdapter.
 * @returns The WhatsAppAdapter instance.
 */
public static getInstance(): WhatsAppAdapter {
  if (!WhatsAppAdapter.instance) {
    WhatsAppAdapter.instance = new WhatsAppAdapter();
  }
  return WhatsAppAdapter.instance;
}

/**
 * Returns the channel type handled by this adapter.
 * @returns The notification channel type ('whatsapp').
 */
public getChannelType(): NotificationChannel {
  return 'whatsapp';
}

/**
 * Checks if this adapter is capable of sending a notification to the given recipient.
 * Requires a valid phone number, an initialized Twilio client, and a configured 'from' number.
 * @param recipient Information about the recipient.
 * @returns True if the adapter can send, false otherwise.
 */
public canSendTo(recipient: RecipientInfo): boolean {
  const hasValidPhone = !!recipient.phone && recipient.phone.length > 8; // Basic validation
  const isClientReady = this.client !== null;
  const hasFromNumber = this.fromNumber !== '';
  const canSend = hasValidPhone && isClientReady && hasFromNumber;

  if (!canSend) {
      let reason = 'Unknown';
      if (!hasValidPhone) reason = 'Invalid or missing phone number';
      else if (!isClientReady) reason = 'Twilio client not initialized';
      else if (!hasFromNumber) reason = 'Twilio "from" number not configured';
      logger.warn('Cannot send WhatsApp message due to configuration or recipient data', {
          reason: reason,
          recipientPhone: recipient.phone // Log phone for debugging
      });
  }
  return canSend;
}

/**
 * Formats a phone number into E.164 standard without the leading '+'.
 * Required for Twilio's `to` parameter when prefixed with `whatsapp:`.
 * Handles Israeli numbers starting with '0'.
 * Example: 0501234567 -> 972501234567
 * @param phone The phone number string to format.
 * @returns The formatted phone number string.
 */
private formatPhoneNumber(phone: string): string {
  // Remove all non-digit characters
  let cleaned = phone.replace(/\D/g, '');
  // Prepend country code for Israeli numbers if '0' prefix exists
  if (cleaned.startsWith('0')) {
    cleaned = '972' + cleaned.substring(1);
  }
  // Remove leading '+' if present (it's added later in the `whatsapp:` prefix)
  if (cleaned.startsWith('+')) {
    cleaned = cleaned.substring(1);
  }
  return cleaned;
}

/**
 * Sends a notification via WhatsApp using the Twilio API.
 * Prefers using template messages if configured via `_adapterSpecificData`.
 * Falls back to raw text messages otherwise (less reliable for business-initiated messages).
 * @param recipient Information about the recipient.
 * @param content The notification content, potentially including adapter-specific data.
 * @returns A promise that resolves to true if the message was successfully queued by Twilio, false otherwise.
 */
public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
  logger.info('Attempting to send WhatsApp message', {
    recipientPhone: recipient.phone,
    fromNumber: this.fromNumber,
    hasClient: !!this.client,
    contentSid: content._adapterSpecificData?.contentSid,
    hasContentVariables: !!content._adapterSpecificData?.contentVariables,
  });

  // --- Pre-send Checks ---
  if (!this.client) {
    logger.error('Twilio client not initialized. Cannot send WhatsApp message.');
    return false;
  }
  if (!recipient.phone) {
    logger.error('Recipient phone number is missing. Cannot send WhatsApp message.');
    return false;
  }
  if (!this.fromNumber) {
      logger.error('Twilio "from" WhatsApp number is not configured. Cannot send message.');
      return false;
  }
  // --- End Pre-send Checks ---


  try {
    // --- Format Numbers ---
    const toNumberE164 = this.formatPhoneNumber(recipient.phone);
    // Ensure 'from' number has '+' prefix for the whatsapp: schema
    const fromWhatsAppFormatted = `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`;
    // Ensure 'to' number has '+' prefix for the whatsapp: schema
    const toWhatsAppFormatted = `whatsapp:+${toNumberE164}`;

    logger.info(`Formatted numbers for sending via Twilio`, { from: fromWhatsAppFormatted, to: toWhatsAppFormatted });
    // --- End Format Numbers ---


    // --- Prepare Message Payload ---
    let messagePayload: MessageListInstanceCreateOptions;
    const adapterData = content._adapterSpecificData;

    if (adapterData?.contentSid && adapterData?.contentVariables) {
       // **Use Template Messaging**
       logger.info(`Preparing WhatsApp template message`, { contentSid: adapterData.contentSid });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          contentSid: adapterData.contentSid, // The approved template SID
          contentVariables: adapterData.contentVariables, // JSON string of variables {"1": "value1", "2": "value2"}
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    } else {
       // **Use Raw Text Messaging (Fallback)**
       // Note: This might fail if outside the 24-hour customer service window
       // or if WhatsApp/Twilio policies require templates for this type of message.
       const bodyText = content.body || content.subject || 'הודעה ממערכת השידוכים'; // Determine fallback content
       logger.warn(`Preparing raw text WhatsApp message (using fallback, might fail)`, { bodyLength: bodyText.length });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          body: bodyText, // The actual text message content
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    }
    // --- End Prepare Message Payload ---


    // --- Send Message via Twilio API ---
    logger.info("Sending message payload to Twilio API", { payload: messagePayload }); // Be cautious logging full payload in production if sensitive
    const message = await this.client.messages.create(messagePayload);
    // --- End Send Message ---


    // --- Log Success ---
    // The message status here is typically 'queued' or 'sending'. Delivery confirmation is asynchronous.
    logger.info('WhatsApp message request processed successfully by Twilio', {
      messageSid: message.sid,
      status: message.status,
      to: toWhatsAppFormatted,
      from: fromWhatsAppFormatted,
      price: message.price, // Log cost if available
      priceUnit: message.priceUnit,
      errorCode: message.errorCode, // Log if Twilio detected an error immediately
      errorMessage: message.errorMessage,
    });
    // We return true because Twilio accepted the request. Delivery is not guaranteed at this point.
    return true;
    // --- End Log Success ---

  } catch (error: unknown) { // Catch error as unknown
    // --- Handle Errors ---
    let errorMessage = 'Unknown error occurred while sending WhatsApp message.';
    let errorCode: number | string | undefined;

    // Use the type guard to safely access potential error properties
    if (isPotentialTwilioError(error)) {
        errorCode = error.code;
        errorMessage = error.message || errorMessage;
    } else if (error instanceof Error) {
        // Standard JavaScript Error
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        // Simple string error
        errorMessage = error;
    }

    // Log detailed error information
    logger.error('Failed to send WhatsApp message via Twilio', {
      errorCode,
      errorMessage,
      recipient: `whatsapp:+${this.formatPhoneNumber(recipient.phone)}`, // Log formatted number for debugging
      from: `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`,
      // Pass the original error object for full details in structured logs
      errorDetails: error
    });

    // Specific handling/logging for common, informative errors
    if (errorCode === 63018 || errorCode === 21614) { // Common codes for non-WhatsApp/incapable numbers
         logger.error(`Recipient number appears invalid or not registered on WhatsApp.`, { phone: recipient.phone, errorCode });
         // Consider adding logic here: maybe mark the user's number as invalid? Notify admin?
    } else if (errorCode === 63016) { // Common code for failing outside the 24-hour window without a template
          logger.warn(`Failed to send non-template message outside 24-hour window.`, { phone: recipient.phone, errorCode });
    }

    return false; // Indicate that sending failed
    // --- End Handle Errors ---
  }
}
}

// Export the singleton instance for use in other parts of the application
export const whatsAppAdapter = WhatsAppAdapter.getInstance();
--- End of Content for WhatsAppAdapter.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\StatusTransitionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService.ts

import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { notificationService } from "../notification/NotificationService";


type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type TransitionOptions = {
  sendNotifications?: boolean;
  customMessage?: string;
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string,
    options: TransitionOptions = {}
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;
    const mergedOptions = {
      sendNotifications: true,
      notifyParties: ['first', 'second', 'matchmaker'],
      ...options
    };

    // Validate the transition
    this.validateStatusTransition(previousStatus, newStatus);

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Only send notifications if option is enabled
    if (mergedOptions.sendNotifications) {
      try {
        // Utilize the notification service for all channels (email, WhatsApp, etc.)
        await notificationService.handleSuggestionStatusChange(
          
          updatedSuggestion, 
          {
            channels: ['email', 'whatsapp'],
            notifyParties: mergedOptions.notifyParties as ('first' | 'second' | 'matchmaker')[],
            customMessage: mergedOptions.customMessage
          }
        );
        
        console.log(`Notifications sent for suggestion ${updatedSuggestion.id} status change to ${newStatus}`);
      } catch (error) {
        // Log error but don't fail the transition
        console.error('Error sending status transition notifications:', error);
      }
    }

    return updatedSuggestion;
  }

  private validateStatusTransition(
    currentStatus: MatchSuggestionStatus, 
    newStatus: MatchSuggestionStatus
  ): void {
    const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
      DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
      PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
      ],
      AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      ENDED_AFTER_FIRST_DATE: [
        MatchSuggestionStatus.CLOSED
      ],
      MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
      ],
      MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
      ],
      ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
      ],
      MARRIED: [],
      EXPIRED: [],
      CLOSED: [],
      CANCELLED: []
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new Error(
        `Invalid status transition from ${currentStatus} to ${newStatus}. ` +
        `Valid transitions are: ${validTransitions[currentStatus]?.join(', ') || 'none'}`
      );
    }
  }
  
  getStatusLabel(status: MatchSuggestionStatus): string {
    const statusLabels: Record<MatchSuggestionStatus, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת הצד הראשון",
      FIRST_PARTY_APPROVED: "הצד הראשון אישר",
      FIRST_PARTY_DECLINED: "הצד הראשון דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת הצד השני",
      SECOND_PARTY_APPROVED: "הצד השני אישר",
      SECOND_PARTY_DECLINED: "הצד השני דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור השדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בחשיבה לאחר הפגישה",
      PROCEEDING_TO_SECOND_DATE: "התקדמות לפגישה שנייה",
      ENDED_AFTER_FIRST_DATE: "הסתיים לאחר פגישה ראשונה",
      MEETING_PENDING: "פגישה בהמתנה",
      MEETING_SCHEDULED: "פגישה קבועה",
      MATCH_APPROVED: "השידוך אושר",
      MATCH_DECLINED: "השידוך נדחה",
      DATING: "בתהליך היכרות",
      ENGAGED: "אירוסין",
      MARRIED: "נישואין",
      CANCELLED: "בוטל",
      CLOSED: "נסגר",
      EXPIRED: "פג תוקף"
    };
    
    return statusLabels[status] || status;
  }
  
  // Get available actions for current status based on user role
  getAvailableActions(
    suggestion: SuggestionWithParties, 
    userId: string
  ): { id: string; label: string; nextStatus: MatchSuggestionStatus }[] {
    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;
    const isMatchmaker = suggestion.matchmakerId === userId;
    
    const actions: Record<MatchSuggestionStatus, { 
      firstParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      secondParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      matchmaker?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
    }> = {
      DRAFT: {
        matchmaker: [
          { id: "send-to-first", label: "שליחה לצד הראשון", nextStatus: MatchSuggestionStatus.PENDING_FIRST_PARTY }
        ]
      },
      PENDING_FIRST_PARTY: {
        firstParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_APPROVED: {
        matchmaker: [
          { id: "send-to-second", label: "שליחה לצד השני", nextStatus: MatchSuggestionStatus.PENDING_SECOND_PARTY },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      PENDING_SECOND_PARTY: {
        secondParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_APPROVED: {
        matchmaker: [
          { id: "share-contacts", label: "שיתוף פרטי קשר", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      AWAITING_MATCHMAKER_APPROVAL: {
        matchmaker: [
          { id: "approve-share", label: "אישור שיתוף פרטים", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      CONTACT_DETAILS_SHARED: {
        firstParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        secondParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        matchmaker: [
          { id: "request-feedback", label: "בקש משוב", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      AWAITING_FIRST_DATE_FEEDBACK: {
         matchmaker: [
            { id: "mark-thinking", label: "סמן כ'בחשיבה'", nextStatus: MatchSuggestionStatus.THINKING_AFTER_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      THINKING_AFTER_DATE: {
         matchmaker: [
            { id: "proceed-second", label: "המשך לפגישה שניה", nextStatus: MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      PROCEEDING_TO_SECOND_DATE: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      ENDED_AFTER_FIRST_DATE: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      MEETING_PENDING: {
         matchmaker: [
            { id: "schedule-meeting", label: "קביעת פגישה", nextStatus: MatchSuggestionStatus.MEETING_SCHEDULED },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MEETING_SCHEDULED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_APPROVED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      DATING: {
        matchmaker: [
          { id: "mark-engaged", label: "עדכון אירוסין", nextStatus: MatchSuggestionStatus.ENGAGED },
          { id: "close", label: "סגירת תהליך", nextStatus: MatchSuggestionStatus.CLOSED },
          { id: "cancel", label: "ביטול השידוך", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      ENGAGED: {
        matchmaker: [
          { id: "mark-married", label: "עדכון נישואין", nextStatus: MatchSuggestionStatus.MARRIED },
          { id: "cancel", label: "ביטול אירוסין", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      MARRIED: {},
      EXPIRED: {},
      CLOSED: {},
      CANCELLED: {}
    };
    
    if (isFirstParty && actions[suggestion.status]?.firstParty) {
      return actions[suggestion.status].firstParty || [];
    }
    
    if (isSecondParty && actions[suggestion.status]?.secondParty) {
      return actions[suggestion.status].secondParty || [];
    }
    
    if (isMatchmaker && actions[suggestion.status]?.matchmaker) {
      return actions[suggestion.status].matchmaker || [];
    }
    
    return [];
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();
--- End of Content for StatusTransitionService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\SuggestionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/SuggestionService.ts

import { MatchSuggestionStatus, Priority, UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { initNotificationService } from "../notification/initNotifications";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
} from "@/types/suggestions";

// Initialize notification service
const notificationService = initNotificationService();
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];
export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    // קוד חדש ומתוקן
const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
if (!matchmaker || !allowedRoles.includes(matchmaker.role)) {
  throw new Error("Unauthorized - User must be a Matchmaker or Admin");
}
  // --- START: NEW VALIDATION LOGIC ---
    // Fetch both parties to get their names for error messages
    const [firstParty, secondParty] = await Promise.all([
        prisma.user.findUnique({ where: { id: data.firstPartyId } }),
        prisma.user.findUnique({ where: { id: data.secondPartyId } })
    ]);

    if (!firstParty || !secondParty) {
        throw new Error("One or both candidates not found.");
    }
    
    // Check for BLOCKING suggestions for either party
    const blockingSuggestion = await prisma.matchSuggestion.findFirst({
        where: {
            OR: [
                { firstPartyId: data.firstPartyId },
                { secondPartyId: data.firstPartyId },
                { firstPartyId: data.secondPartyId },
                { secondPartyId: data.secondPartyId },
            ],
            status: {
                in: BLOCKING_SUGGESTION_STATUSES,
            },
        },
    });

    if (blockingSuggestion) {
        const hasBlockingSuggestion = (id: string) => 
            blockingSuggestion.firstPartyId === id || blockingSuggestion.secondPartyId === id;
            
        if (hasBlockingSuggestion(data.firstPartyId)) {
            throw new Error(`לא ניתן ליצור הצעה חדשה. ל${firstParty.firstName} ${firstParty.lastName} יש כבר הצעה פעילה.`);
        }
        if (hasBlockingSuggestion(data.secondPartyId)) {
            throw new Error(`לא ניתן ליצור הצעה חדשה. ל${secondParty.firstName} ${secondParty.lastName} יש כבר הצעה פעילה.`);
        }
    }

    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
      console.log('Decision deadline type:', typeof data.decisionDeadline);
      
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות באמצעות מערכת ההתראות המאוחדת
    try {
      console.log('Sending notifications for new suggestion...');
      await notificationService.handleSuggestionStatusChange(
        suggestion,
        {
          channels: ['email', 'whatsapp'],
          notifyParties: ['first'] // רק לצד הראשון בשלב זה
        }
      );
    } catch (error) {
      console.error('Error sending initial suggestion notifications:', error);
      // לא לעצור את התהליך - רק לדווח על השגיאה
    }

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: SuggestionWithParties,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<SuggestionWithParties | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }
}
export const suggestionService = SuggestionService.getInstance();
--- End of Content for SuggestionService.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\matchingAlgorithm.ts
--------------------------------------------------------------------------------
Content:
import { AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

const matchingAlgorithm = {
  calculateMatchScore,
  findBestMatches
};

export default matchingAlgorithm;
--- End of Content for matchingAlgorithm.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\statisticsCalculator.ts
--------------------------------------------------------------------------------
Content:
// /utils/statisticsCalculator.ts
import type { Candidate } from '../../new/types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const  stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

const statisticsCalculator = {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

export default statisticsCalculator;
--- End of Content for statisticsCalculator.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\messages
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\messages\AvailabilityRequestCard.tsx
--------------------------------------------------------------------------------
Content:
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Clock, CheckCircle, XCircle } from "lucide-react";
import type { ExtendedInquiry } from "@/types/messages";

interface AvailabilityRequestCardProps {
  inquiry: ExtendedInquiry;
  currentUserId: string;
  onRespond: (inquiryId: string, isAvailable: boolean) => Promise<void>;
}

export default function AvailabilityRequestCard({
  inquiry,
  currentUserId,
  onRespond,
}: AvailabilityRequestCardProps) {
  const isFirstParty = inquiry.firstPartyId === currentUserId;
  const isSecondParty = inquiry.secondPartyId === currentUserId;
  const totalResponses = [
    inquiry.firstPartyResponse,
    inquiry.secondPartyResponse,
  ].filter((r) => r !== null).length;
  const progress = (totalResponses / 2) * 100;

  return (
    <Card>
      <CardContent className="p-6">
        <div className="flex justify-between items-start mb-4">
          <div>
            <h3 className="font-medium">בקשת בדיקת זמינות</h3>
            <p className="text-sm text-gray-600">
              מאת {inquiry.matchmaker.firstName} {inquiry.matchmaker.lastName}
            </p>
          </div>
          <Clock className="w-5 h-5 text-gray-400" />
        </div>

        <div className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <div className="text-sm text-gray-500">צד ראשון</div>
              <div className="flex items-center mt-1">
                {inquiry.firstPartyResponse === null ? (
                  <Clock className="w-4 h-4 text-yellow-500 mr-1" />
                ) : inquiry.firstPartyResponse ? (
                  <CheckCircle className="w-4 h-4 text-green-500 mr-1" />
                ) : (
                  <XCircle className="w-4 h-4 text-red-500 mr-1" />
                )}
                <span>
                  {inquiry.firstParty.firstName} {inquiry.firstParty.lastName}
                </span>
              </div>
            </div>
          </div>

          <div className="space-y-2">
            <div className="flex justify-between text-sm text-gray-500">
              <span>התקדמות</span>
              <span>{progress}%</span>
            </div>
            <Progress value={progress} className="w-full" />
          </div>

          {inquiry.note && (
            <div className="text-sm text-gray-600">
              <strong>הערה:</strong> {inquiry.note}
            </div>
          )}

          {isFirstParty && inquiry.firstPartyResponse === null && (
            <div className="flex gap-2 mt-4">
              <Button
                onClick={() => onRespond(inquiry.id, true)}
                className="flex-1 bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="mr-2 h-4 w-4" />
                אני זמין/ה
              </Button>
              <Button
                onClick={() => onRespond(inquiry.id, false)}
                variant="outline"
                className="flex-1"
              >
                <XCircle className="mr-2 h-4 w-4" />
                לא זמין/ה כרגע
              </Button>
            </div>
          )}

          {isSecondParty && inquiry.secondPartyResponse === null && (
            <div className="flex gap-2 mt-4">
              <Button
                onClick={() => onRespond(inquiry.id, true)}
                className="flex-1 bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="mr-2 h-4 w-4" />
                אני זמין/ה
              </Button>
              <Button
                onClick={() => onRespond(inquiry.id, false)}
                variant="outline"
                className="flex-1"
              >
                <XCircle className="mr-2 h-4 w-4" />
                לא זמין/ה כרגע
              </Button>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
--- End of Content for AvailabilityRequestCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\messages\MessagesPage.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import { useNotifications } from "@/app/contexts/NotificationContext";
import { useState, useEffect, useCallback } from "react";
import { useSession } from "next-auth/react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Clock, CheckCircle, XCircle, Loader2, Users } from "lucide-react";
import type { ExtendedInquiry } from "@/types/messages";
import { Session } from "next-auth";

export default function MessagesPage() {
  const { data: session } = useSession() as { data: Session | null };
  const { refreshNotifications } = useNotifications();
  const [inquiries, setInquiries] = useState<ExtendedInquiry[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [filters, setFilters] = useState({
    status: "pending",
    timeframe: "all",
  });
  const [note, setNote] = useState("");

  const loadInquiries = useCallback(async () => {
    try {
      const queryParams = new URLSearchParams({
        status: filters.status,
        timeframe: filters.timeframe,
      });

      const response = await fetch(`/api/matchmaker/inquiries?${queryParams}`);
      if (!response.ok) throw new Error("Failed to load inquiries");
      const data = await response.json();
      setInquiries(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load inquiries");
    } finally {
      setLoading(false);
    }
  }, [filters]);

  useEffect(() => {
    if (session?.user) {
      loadInquiries();
    }
  }, [session, loadInquiries]);

  const handleResponse = async (inquiryId: string, isAvailable: boolean) => {
    try {
      const response = await fetch(
        `/api/matchmaker/inquiries/${inquiryId}/respond`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ isAvailable, note }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to submit response");
      }

      await loadInquiries();
      await refreshNotifications();
      setNote("");
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to submit response"
      );
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loader2 className="w-8 h-8 animate-spin" />
      </div>
    );
  }

  if (inquiries.length === 0) {
    return (
      <Card className="max-w-4xl mx-auto mt-8">
        <CardContent className="p-6 text-center">
          <Users className="w-12 h-12 mx-auto text-gray-400 mb-4" />
          <h3 className="text-lg font-medium">אין הודעות</h3>
          <p className="text-gray-500">אין הודעות או התראות חדשות</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <Card className="mb-6">
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle>הודעות והתראות</CardTitle>
          <div className="flex gap-4">
            <Select
              value={filters.status}
              onValueChange={(value) =>
                setFilters((prev) => ({ ...prev, status: value }))
              }
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="סינון לפי סטטוס" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                <SelectItem value="pending">ממתין לתגובה</SelectItem>
                <SelectItem value="completed">טופל</SelectItem>
              </SelectContent>
            </Select>

            <Select
              value={filters.timeframe}
              onValueChange={(value) =>
                setFilters((prev) => ({ ...prev, timeframe: value }))
              }
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="סינון לפי זמן" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                <SelectItem value="today">היום</SelectItem>
                <SelectItem value="week">שבוע אחרון</SelectItem>
                <SelectItem value="month">חודש אחרון</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardHeader>
      </Card>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 gap-6">
        {inquiries.map((inquiry) => (
          <Card key={inquiry.id}>
            <CardContent className="p-6">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h3 className="font-medium">בקשת בדיקת זמינות</h3>
                  <p className="text-sm text-gray-600">
                    מאת {inquiry.matchmaker.firstName}{" "}
                    {inquiry.matchmaker.lastName}
                  </p>
                </div>
                <Clock className="w-5 h-5 text-gray-400" />
              </div>

              <div className="space-y-4">
                {inquiry.note && (
                  <div className="text-sm text-gray-600 mt-2">
                    <strong>הערה:</strong> {inquiry.note}
                  </div>
                )}

                {!inquiry.firstPartyResponse && (
                  <>
                    <div className="space-y-2">
                      <label className="block text-sm font-medium">
                        הערות (אופציונלי):
                      </label>
                      <Textarea
                        value={note}
                        onChange={(e) => setNote(e.target.value)}
                        placeholder="הוסף/י הערות..."
                        className="w-full"
                      />
                    </div>

                    <div className="flex gap-2 mt-4">
                      <Button
                        onClick={() => handleResponse(inquiry.id, true)}
                        className="flex-1 bg-green-600 hover:bg-green-700"
                      >
                        <CheckCircle className="mr-2 h-4 w-4" />
                        אני זמין/ה
                      </Button>
                      <Button
                        onClick={() => handleResponse(inquiry.id, false)}
                        variant="outline"
                        className="flex-1"
                      >
                        <XCircle className="mr-2 h-4 w-4" />
                        לא זמין/ה כרגע
                      </Button>
                    </div>
                  </>
                )}

                {inquiry.firstPartyResponse !== null && (
                  <div className="space-y-4">
                    <div
                      className={`flex items-center gap-2 p-2 rounded-md ${
                        inquiry.firstPartyResponse
                          ? "bg-green-50 text-green-700"
                          : "bg-red-50 text-red-700"
                      }`}
                    >
                      {inquiry.firstPartyResponse ? (
                        <CheckCircle className="h-5 w-5" />
                      ) : (
                        <XCircle className="h-5 w-5" />
                      )}
                      <span>
                        {inquiry.firstPartyResponse
                          ? "אישרת זמינות"
                          : "ציינת שאינך זמין/ה"}
                      </span>
                    </div>

                    <div>
                      <Button
                        onClick={() =>
                          handleResponse(
                            inquiry.id,
                            !inquiry.firstPartyResponse
                          )
                        }
                        className={`w-full ${
                          inquiry.firstPartyResponse
                            ? "bg-red-600 hover:bg-red-700"
                            : "bg-green-600 hover:bg-green-700"
                        }`}
                      >
                        {inquiry.firstPartyResponse ? (
                          <>
                            <XCircle className="mr-2 h-4 w-4" />
                            שינוי תשובה - אינני זמין/ה
                          </>
                        ) : (
                          <>
                            <CheckCircle className="mr-2 h-4 w-4" />
                            שינוי תשובה - אני זמין/ה
                          </>
                        )}
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
--- End of Content for MessagesPage.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\ProfileCard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useMemo, useCallback, useEffect } from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";

// UI Components
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogHeader,
  DialogFooter,
} from "@/components/ui/dialog";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { ToggleGroup, ToggleGroupItem } from "@/components/ui/toggle-group";
import { Skeleton } from "@/components/ui/skeleton";
import { Separator } from "@/components/ui/separator";

// Icons
import {
  User, Heart, FileText, Image as ImageIcon, Info as InfoIcon, Eye, Phone, 
  ChevronLeft, ChevronRight, Briefcase, GraduationCap, Users, BookOpen, 
  School, Lock, Languages, Calendar, Star, MapPin, CheckCircle, Clock, 
  Cake, Gem, Sparkles, Users2, Award, Palette, Smile, X, BookMarked, 
  Search, Target, UserCheck, Link as LinkIcon, Handshake, Edit3, 
  ExternalLink, Bot, Coffee, Camera, Music, Globe, Compass, Telescope, 
  Crown, Zap, Gift, ArrowRight, Quote, ChevronDown, Moon, Sun, Baby, 
  Home, Flame, MessageCircle, Play, Plus, Lightbulb, Mountain, Share2,
  Download, Printer, Bookmark, Search as SearchIcon, Filter, SortDesc,
  MessageSquare, Phone as PhoneIcon, Mail, Send, Stars,
  Sparkle, Sunrise, Sunset, TreePine, Flower, Rainbow, Waves, Wind, Shield,
  Maximize, Minimize
} from "lucide-react";

// Types and Interfaces
import type {
  UserProfile, UserImage as UserImageType, QuestionnaireResponse, FormattedAnswer,
  ServiceType, HeadCoveringType, KippahType
} from "@/types/next-auth";
import { languageOptions } from "@/lib/languageOptions";
import type { Candidate } from "@/app/components/matchmaker/new/types/candidates";

import NewSuggestionForm from "@/app/components/matchmaker/suggestions/NewSuggestionForm";

// Define interfaces
interface CreateSuggestionData {
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  firstPartyId: string;
  secondPartyId: string;
  status:
    | "DRAFT"
    | "PENDING_FIRST_PARTY"
    | "FIRST_PARTY_APPROVED"
    | "FIRST_PARTY_DECLINED"
    | string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
}

interface ExcitementFactor {
  icon: React.ElementType;
  text: string;
  gradient: string;
}

// --- Color Palette & Theme ---
const COLOR_PALETTES = {
  professional: {
    name: "מקצועי",
    colors: {
      primary: {
        main: "from-gray-700 via-gray-800 to-gray-900",
        accent: "from-blue-600 via-blue-700 to-blue-800",
        light: "from-gray-100 via-gray-200 to-gray-300",
        romantic: "from-blue-600 via-blue-700 to-blue-800",
        rose: "from-blue-500 via-blue-600 to-blue-700",
        gold: "from-gray-400 via-gray-500 to-gray-600",
        elegant: "from-gray-700 via-gray-800 to-gray-900",
      },
      secondary: {
        sage: "from-gray-300 via-gray-400 to-gray-500",
        sky: "from-blue-100 via-blue-200 to-blue-300",
        lavender: "from-gray-200 via-gray-300 to-gray-400",
        peach: "from-orange-100 via-amber-100 to-yellow-200"
      },
      neutral: {
        warm: "from-gray-50 via-white to-gray-100",
        cool: "from-slate-50 via-gray-50 to-zinc-50",
        elegant: "from-white via-gray-50 to-neutral-100"
      }
    },
    shadows: {
      elegant: "shadow-xl shadow-gray-200/25",
      warm: "shadow-lg shadow-gray-200/30",
      soft: "shadow-md shadow-gray-100/40"
    }
  },
  feminine: {
    name: "נשי",
    colors: {
      primary: {
        main: "from-rose-400 via-pink-400 to-rose-500",
        accent: "from-pink-500 via-rose-500 to-red-400",
        light: "from-pink-100 via-rose-100 to-red-100",
        romantic: "from-rose-400 via-pink-400 to-rose-500",
        rose: "from-rose-400 via-pink-400 to-rose-500",
        gold: "from-amber-200 via-yellow-200 to-orange-300",
        elegant: "from-pink-500 via-rose-500 to-red-400",
      },
      secondary: {
        sage: "from-pink-200 via-rose-200 to-red-200",
        sky: "from-purple-200 via-pink-200 to-rose-300",
        lavender: "from-purple-200 via-violet-200 to-purple-300",
        peach: "from-pink-200 via-rose-200 to-orange-300"
      },
      neutral: {
        warm: "from-rose-50 via-pink-50 to-orange-50",
        cool: "from-purple-50 via-pink-50 to-rose-50",
        elegant: "from-pink-50 via-rose-50 to-neutral-100"
      }
    },
    shadows: {
      elegant: "shadow-xl shadow-pink-200/25",
      warm: "shadow-lg shadow-rose-200/30",
      soft: "shadow-md shadow-pink-100/40"
    }
  },
  masculine: {
    name: "גברי",
    colors: {
      primary: {
        main: "from-blue-600 via-indigo-600 to-blue-700",
        accent: "from-cyan-500 via-blue-500 to-indigo-600",
        light: "from-blue-100 via-indigo-100 to-cyan-100",
        romantic: "from-cyan-500 via-blue-500 to-indigo-600",
        rose: "from-cyan-500 via-blue-500 to-indigo-600",
        gold: "from-blue-200 via-cyan-200 to-teal-300",
        elegant: "from-blue-600 via-indigo-600 to-blue-700",
      },
      secondary: {
        sage: "from-emerald-300 via-teal-300 to-cyan-400",
        sky: "from-blue-200 via-sky-200 to-indigo-300",
        lavender: "from-indigo-200 via-blue-200 to-cyan-300",
        peach: "from-blue-200 via-cyan-200 to-teal-300"
      },
      neutral: {
        warm: "from-blue-50 via-indigo-50 to-cyan-50",
        cool: "from-slate-50 via-blue-50 to-indigo-50",
        elegant: "from-gray-50 via-blue-50 to-neutral-100"
      }
    },
    shadows: {
      elegant: "shadow-xl shadow-blue-200/25",
      warm: "shadow-lg shadow-indigo-200/30",
      soft: "shadow-md shadow-blue-100/40"
    }
  },
  luxury: {
    name: "יוקרתי",
    colors: {
      primary: {
        main: "from-amber-500 via-yellow-500 to-amber-600",
        accent: "from-purple-600 via-indigo-600 to-purple-700",
        light: "from-amber-100 via-yellow-100 to-gold-100",
        romantic: "from-purple-600 via-indigo-600 to-purple-700",
        rose: "from-purple-600 via-indigo-600 to-purple-700",
        gold: "from-amber-500 via-yellow-500 to-amber-600",
        elegant: "from-amber-500 via-yellow-500 to-amber-600",
      },
      secondary: {
        sage: "from-emerald-400 via-teal-400 to-cyan-500",
        sky: "from-indigo-300 via-purple-300 to-violet-400",
        lavender: "from-purple-300 via-violet-300 to-indigo-400",
        peach: "from-amber-300 via-yellow-300 to-orange-400"
      },
      neutral: {
        warm: "from-amber-50 via-yellow-50 to-orange-50",
        cool: "from-purple-50 via-indigo-50 to-violet-50",
        elegant: "from-gray-50 via-amber-50 to-neutral-100"
      }
    },
    shadows: {
      elegant: "shadow-xl shadow-amber-200/25",
      warm: "shadow-lg shadow-yellow-200/30",
      soft: "shadow-md shadow-amber-100/40"
    }
  }
} as const;

type ColorPaletteName = keyof typeof COLOR_PALETTES;

// --- Enhanced Data & Translation Maps ---
const maritalStatusMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  single: { label: "רווק/ה", icon: Heart, color: "text-rose-600" },
  divorced: { label: "גרוש/ה", icon: Sunrise, color: "text-amber-600" },
  widowed: { label: "אלמן/ה", icon: Stars, color: "text-purple-600" },
  annulled: { label: "מוכן/ה לאהבה חדשה", icon: Rainbow, color: "text-pink-600" },
  any: { label: "פתוח/ה לכל האפשרויות", icon: Sparkles, color: "text-indigo-600" }
};

const religiousLevelMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  charedi: { label: "חרדי/ת", icon: BookMarked, color: "text-indigo-700" },
  charedi_modern: { label: "חרדי/ת מודרני/ת", icon: BookOpen, color: "text-indigo-600" },
  dati_leumi_torani: { label: "דתי/ה לאומי/ת תורני/ת", icon: Star, color: "text-blue-700" },
  dati_leumi_liberal: { label: "דתי/ה לאומי/ת ליברלי/ת", icon: Flower, color: "text-blue-600" },
  dati_leumi_standard: { label: "דתי/ה לאומי/ת", icon: Crown, color: "text-blue-600" },
  masorti_strong: { label: "מסורתי/ת (חזק)", icon: TreePine, color: "text-emerald-700" },
  masorti_light: { label: "מסורתי/ת (קל)", icon: Wind, color: "text-emerald-600" },
  secular_traditional_connection: { label: "חילוני/ת עם זיקה", icon: Waves, color: "text-cyan-600" },
  secular: { label: "חילוני/ת", icon: Sunrise, color: "text-orange-600" },
  spiritual_not_religious: { label: "רוחני/ת", icon: Sparkle, color: "text-purple-600" },
  other: { label: "ייחודי/ת", icon: Rainbow, color: "text-pink-600" },
  "לא משנה": { label: "פתוח/ה לכל השקפה", icon: Globe, color: "text-gray-600" }
};

const educationLevelMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  high_school: { label: "תיכונית", icon: School, color: "text-blue-600" },
  vocational: { label: "מקצועית", icon: Award, color: "text-green-600" },
  academic_student: { label: "במהלך לימודים", icon: BookOpen, color: "text-orange-600" },
  academic_ba: { label: "בוגר/ת תואר ראשון", icon: GraduationCap, color: "text-purple-600" },
  academic_ma: { label: "בוגר/ת תואר שני", icon: Star, color: "text-indigo-600" },
  academic_phd: { label: "דוקטור/ת", icon: Crown, color: "text-rose-600" },
  yeshiva_seminary: { label: "לימודים תורניים", icon: BookMarked, color: "text-amber-600" },
  other: { label: "ייחודי/ת", icon: Sparkles, color: "text-pink-600" },
  "ללא העדפה": { label: "הכל פתוח", icon: Globe, color: "text-gray-600" }
};

const serviceTypeMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  MILITARY_COMBATANT: { label: "לוחם/ת", icon: Award, color: "text-red-600" },
  MILITARY_SUPPORT: { label: "תומך/ת לחימה", icon: Users, color: "text-orange-600" },
  MILITARY_OFFICER: { label: "קצין/ה", icon: Crown, color: "text-purple-600" },
  MILITARY_INTELLIGENCE_CYBER_TECH: { label: "טכנולוגיה ומודיעין", icon: Zap, color: "text-blue-600" },
  NATIONAL_SERVICE_ONE_YEAR: { label: "שירות לאומי", icon: Heart, color: "text-pink-600" },
  NATIONAL_SERVICE_TWO_YEARS: { label: "שירות לאומי מורחב", icon: Stars, color: "text-rose-600" },
  HESDER_YESHIVA: { label: "ישיבת הסדר", icon: BookMarked, color: "text-indigo-600" },
  YESHIVA_ONLY_POST_HS: { label: "לימודים תורניים", icon: BookOpen, color: "text-amber-600" },
  PRE_MILITARY_ACADEMY_AND_SERVICE: { label: "מכינה ושירות", icon: GraduationCap, color: "text-green-600" },
  EXEMPTED: { label: "פטור", icon: Shield, color: "text-gray-600" },
  CIVILIAN_SERVICE: { label: "שירות אזרחי", icon: Users2, color: "text-teal-600" },
  OTHER: { label: "ייחודי", icon: Sparkles, color: "text-purple-600" }
};

const headCoveringMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  FULL_COVERAGE: { label: "כיסוי מלא", icon: Crown, color: "text-purple-600" },
  PARTIAL_COVERAGE: { label: "כיסוי חלקי", icon: Flower, color: "text-pink-600" },
  HAT_BERET: { label: "כובע/ברט", icon: Sun, color: "text-orange-600" },
  SCARF_ONLY_SOMETIMES: { label: "מטפחת לאירועים", icon: Sparkle, color: "text-rose-600" },
  NONE: { label: "ללא כיסוי", icon: Wind, color: "text-blue-600" },
  any: { label: "גמיש/ה", icon: Rainbow, color: "text-indigo-600" }
};

const kippahTypeMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  BLACK_VELVET: { label: "קטיפה שחורה", icon: Crown, color: "text-indigo-700" },
  KNITTED_SMALL: { label: "סרוגה קטנה", icon: Star, color: "text-blue-600" },
  KNITTED_LARGE: { label: "סרוגה גדולה", icon: Stars, color: "text-blue-700" },
  CLOTH: { label: "בד", icon: Flower, color: "text-green-600" },
  BRESLEV: { label: "ברסלב", icon: Sparkle, color: "text-purple-600" },
  NONE_AT_WORK_OR_CASUAL: { label: "לא בעבודה", icon: Briefcase, color: "text-gray-600" },
  NONE_USUALLY: { label: "לרוב לא", icon: Wind, color: "text-gray-500" },
  OTHER: { label: "ייחודי", icon: Rainbow, color: "text-pink-600" },
  any: { label: "גמיש", icon: Globe, color: "text-teal-600" }
};

const languageMap = languageOptions.reduce((acc, lang) => {
  acc[lang.value] = { label: lang.label, icon: Globe, color: "text-blue-600" };
  return acc;
}, {} as { [key: string]: { label: string; icon: React.ElementType; color: string } });

const contactPreferenceMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  direct: { label: "ישירות", icon: PhoneIcon, color: "text-green-600" },
  matchmaker: { label: "דרך השדכן/ית", icon: Users, color: "text-purple-600" },
  both: { label: "גמיש/ה", icon: MessageSquare, color: "text-blue-600" }
};

const characterTraitMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  empathetic: { label: "אמפתי/ת", icon: Heart, color: "text-rose-600" },
  driven: { label: "שאפתן/ית", icon: Zap, color: "text-orange-600" },
  optimistic: { label: "אופטימי/ת", icon: Sunrise, color: "text-yellow-600" },
  family_oriented: { label: "משפחתי/ת", icon: Users2, color: "text-pink-600" },
  intellectual: { label: "אינטלקטואל/ית", icon: BookOpen, color: "text-indigo-600" },
  organized: { label: "מאורגנ/ת", icon: CheckCircle, color: "text-green-600" },
  calm: { label: "רגוע/ה", icon: Waves, color: "text-blue-600" },
  humorous: { label: "מצחיק/ה", icon: Smile, color: "text-purple-600" },
  sociable: { label: "חברותי/ת", icon: Users, color: "text-cyan-600" },
  sensitive: { label: "רגיש/ה", icon: Flower, color: "text-pink-600" },
  independent: { label: "עצמאי/ת", icon: Crown, color: "text-amber-600" },
  creative: { label: "יצירתי/ת", icon: Palette, color: "text-rose-600" },
  honest: { label: "כן/ה וישר/ה", icon: Star, color: "text-blue-600" },
  responsible: { label: "אחראי/ת", icon: Award, color: "text-green-600" },
  easy_going: { label: "זורם/ת וקליל/ה", icon: Wind, color: "text-teal-600" },
  no_strong_preference: { label: "פתוח/ה לגילוי", icon: Compass, color: "text-gray-600" }
};

const hobbiesMap: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
  travel: { label: "טיולים", icon: Compass, color: "text-green-600" },
  sports: { label: "ספורט", icon: Zap, color: "text-orange-600" },
  reading: { label: "קריאה", icon: BookOpen, color: "text-indigo-600" },
  cooking_baking: { label: "בישול ואפיה", icon: Coffee, color: "text-amber-600" },
  music_playing_instrument: { label: "מוזיקה", icon: Music, color: "text-purple-600" },
  art_crafts: { label: "אומנות ויצירה", icon: Palette, color: "text-pink-600" },
  volunteering: { label: "התנדבות", icon: Heart, color: "text-rose-600" },
  learning_courses: { label: "למידה", icon: GraduationCap, color: "text-blue-600" },
  board_games_puzzles: { label: "משחקים", icon: Play, color: "text-cyan-600" },
  movies_theater: { label: "סרטים ותיאטרון", icon: Camera, color: "text-red-600" },
  dancing: { label: "ריקוד", icon: Sparkle, color: "text-pink-600" },
  writing: { label: "כתיבה", icon: Edit3, color: "text-gray-600" },
  nature_hiking: { label: "טבע וטיולים", icon: TreePine, color: "text-green-600" },
  photography: { label: "צילום", icon: Camera, color: "text-blue-600" },
  no_strong_preference: { label: "פתוח/ה לגילוי יחד", icon: Rainbow, color: "text-gray-600" }
};

// --- Main Profile Card Component ---
interface ProfileCardProps {
  profile: UserProfile;
  images?: UserImageType[];
  questionnaire?: QuestionnaireResponse | null;
  viewMode?: "matchmaker" | "candidate";
  className?: string;
  candidate?: Candidate;
  allCandidates?: Candidate[];
  onCreateSuggestion?: (data: CreateSuggestionData) => Promise<void>;
}

const ProfileCard: React.FC<ProfileCardProps> = ({
  profile,
  candidate,
  images = [],
  questionnaire,
  viewMode = "candidate",
  className,
  allCandidates = [],
  onCreateSuggestion
}) => {
  const [isClient, setIsClient] = useState(false);
  const [isDesktop, setIsDesktop] = useState(true);
  const [selectedImageForDialog, setSelectedImageForDialog] = useState<UserImageType | null>(null);
  const [activeTab, setActiveTab] = useState("essence");
  const [isSuggestDialogOpen, setIsSuggestDialogOpen] = useState(false);
  const [mobileViewLayout, setMobileViewLayout] = useState<'focus' | 'detailed'>('focus');
  const [selectedPalette, setSelectedPalette] = useState<ColorPaletteName>('feminine');
  const [isFullscreen, setIsFullscreen] = useState(false);

  // Get current theme based on selected palette
  const THEME = useMemo(() => COLOR_PALETTES[selectedPalette], [selectedPalette]);
    
    const WORLDS: { [key: string]: { 
      label: string; 
      icon: React.ElementType; 
      gradient: string; 
      description: string;
      accentColor: string;
    } } = useMemo(() => ({
      values: { 
        label: "הערכים והעקרונות שמנחים אותי", 
        icon: BookMarked, 
        gradient: THEME.colors.primary.accent,
        description: "מה חשוב לי בחיים ומה מוביל אותי",
        accentColor: "blue"
      },
      personality: { 
        label: "האישיות והתכונות הייחודיות שלי", 
        icon: Sparkles, 
        gradient: THEME.colors.primary.light,
        description: "איך אני באמת ומה מאפיין אותי",
        accentColor: "purple"
      },
      relationship: { 
        label: "החזון שלי לזוגיות ומשפחה", 
        icon: Heart, 
        gradient: THEME.colors.primary.main,
        description: "איך אני רואה את עתיד הזוגיות שלי",
        accentColor: "rose"
      },
      partner: { 
        label: "מה אני מחפש/ת בבן/בת הזוג", 
        icon: Users, 
        gradient: THEME.colors.secondary.sky,
        description: "התכונות והערכים שחשובים לי בפרטנר",
        accentColor: "blue"
      },
      religion: { 
        label: "הדת והרוחניות בחיי", 
        icon: Star, 
        gradient: THEME.colors.secondary.peach,
        description: "המקום של האמונה והמסורת בעולמי",
        accentColor: "amber"
      },
      general: { 
        label: "עוד דברים חשובים שכדאי לדעת עליי", 
        icon: FileText, 
        gradient: THEME.colors.secondary.lavender,
        description: "פרטים נוספים שמשלימים את התמונה",
        accentColor: "purple"
      }
    }), [THEME]);

  // --- Enhanced Helper Functions ---
  const formatEnumValue = (
    value: string | null | undefined, 
    map: { [key: string]: { label: string; icon: React.ElementType; color: string } }, 
    placeholder: string = "עוד נגלה יחד..."
  ): { label: string; icon: React.ElementType; color: string } => {
    if (!value || !map[value]) return { 
      label: placeholder, 
      icon: Telescope, 
      color: "text-gray-500" 
    };
    return map[value];
  };

  const getInitials = (firstName?: string, lastName?: string): string => {
    let initials = "";
    if (firstName && firstName.length > 0) initials += firstName[0];
    if (lastName && lastName.length > 0) initials += lastName[0];
    if (initials.length === 0 && firstName && firstName.length > 0) {
      initials = firstName.length > 1 ? firstName.substring(0, 2) : firstName[0];
    }
    return initials.toUpperCase() || "♥";
  };

  const calculateAge = (birthDate: Date | string | null | undefined): number => {
    if (!birthDate) return 0;
    try {
      const today = new Date();
      const birth = new Date(birthDate);
      if (isNaN(birth.getTime())) return 0;
      let age = today.getFullYear() - birth.getFullYear();
      const monthDiff = today.getMonth() - birth.getMonth();
      if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
        age--;
      }
      return age > 0 ? age : 0;
    } catch (e) {
      return 0;
    }
  };

  const formatAvailabilityStatus = useCallback((status: UserProfile["availabilityStatus"] | undefined) => {
    const statusMap = {
      AVAILABLE: { 
        text: "זמין/ה להכרות מרגשות", 
        gradient: THEME.colors.primary.main, 
        icon: Heart, 
        pulse: true,
        bgColor: "bg-gradient-to-r from-emerald-500 to-green-500"
      },
      UNAVAILABLE: { 
        text: "לא זמין/ה כרגע", 
        gradient: "from-gray-400 to-gray-500", 
        icon: Clock, 
        pulse: false,
        bgColor: "bg-gradient-to-r from-gray-400 to-gray-500"
      },
      DATING: { 
        text: "בתהליך היכרות", 
        gradient: THEME.colors.primary.accent, 
        icon: Coffee, 
        pulse: false,
        bgColor: "bg-gradient-to-r from-amber-500 to-orange-500"
      },
      PAUSED: { 
        text: "בהפסקה זמנית", 
        gradient: THEME.colors.secondary.sky, 
        icon: Moon, 
        pulse: false,
        bgColor: "bg-gradient-to-r from-blue-500 to-cyan-500"
      },
      ENGAGED: { 
        text: "מאורס/ת", 
        gradient: THEME.colors.primary.light, 
        icon: Star, 
        pulse: false,
        bgColor: "bg-gradient-to-r from-pink-500 to-rose-500"
      },
      MARRIED: { 
        text: "נשוי/אה", 
        gradient: THEME.colors.primary.main, 
        icon: Heart, 
        pulse: false,
        bgColor: "bg-gradient-to-r from-rose-500 to-pink-500"
      }
    };
    
    return statusMap[status as keyof typeof statusMap] || {
      text: "מסתורי/ת...", 
      gradient: THEME.colors.secondary.lavender, 
      icon: Sparkles, 
      pulse: true,
      bgColor: "bg-gradient-to-r from-purple-500 to-indigo-500"
    };
  }, [THEME]);

  const formatBooleanPreference = (
    value: boolean | null | undefined, 
    yesLabel: string = "כן", 
    noLabel: string = "לא", 
    notSpecifiedLabel: string = "נגלה יחד"
  ): { label: string; icon: React.ElementType; color: string } => {
    if (value === true) return { label: yesLabel, icon: CheckCircle, color: "text-green-600" };
    if (value === false) return { label: noLabel, icon: X, color: "text-red-500" };
    return { label: notSpecifiedLabel, icon: Telescope, color: "text-gray-500" };
  };

  const formatStringBooleanPreference = (
    value: string | null | undefined, 
    options: { [key: string]: { label: string; icon: React.ElementType; color: string } } = {
      yes: { label: "כן", icon: CheckCircle, color: "text-green-600" },
      no: { label: "לא", icon: X, color: "text-red-500" },
      flexible: { label: "גמיש/ה", icon: Rainbow, color: "text-indigo-600" }
    }, 
    notSpecifiedLabel: { label: string; icon: React.ElementType; color: string } = {
      label: "נגלה יחד", icon: Telescope, color: "text-gray-500"
    }
  ): { label: string; icon: React.ElementType; color: string } => {
    if (value && options[value.toLowerCase()]) {
      return options[value.toLowerCase()];
    }
    return notSpecifiedLabel;
  };

  // --- Enhanced Helper Components ---

  const DetailItem: React.FC<{
    icon: React.ElementType;
    label: string;
    value: React.ReactNode;
    className?: string;
    iconColorClass?: string;
    valueClassName?: string;
    tooltip?: string;
    variant?: "default" | "highlight" | "elegant" | "romantic";
    size?: "sm" | "md" | "lg";
  }> = ({ 
    icon: Icon, 
    label, 
    value, 
    className, 
    iconColorClass = "text-rose-500", 
    valueClassName, 
    tooltip, 
    variant = "default",
    size = "md"
  }) => {
    const variants = {
      default: "bg-white border border-gray-200 hover:border-rose-300 hover:shadow-md",
      highlight: `bg-gradient-to-r ${THEME.colors.neutral.warm} border border-rose-200 shadow-sm`,
      elegant: `bg-gradient-to-br ${THEME.colors.neutral.elegant} border border-amber-200 ${THEME.shadows.elegant}`,
      romantic: `bg-gradient-to-r ${THEME.colors.neutral.warm} border border-pink-200 ${THEME.shadows.soft}`
    };

    const sizes = {
      sm: "p-3 gap-2",
      md: "p-4 gap-3", 
      lg: "p-5 gap-4"
    };

    const content = (
      <div className={cn(
        "flex items-start rounded-xl transition-all duration-300",
        variants[variant],
        sizes[size],
        className
      )}>
        <div className={cn(
          "p-2 rounded-lg flex-shrink-0 shadow-sm",
          variant === "highlight" || variant === "elegant" 
            ? `bg-gradient-to-r ${THEME.colors.primary.rose} text-white` 
            : "bg-rose-50 border border-rose-200",
          !variant && iconColorClass
        )}>
          <Icon className={cn(
            "w-4 h-4",
            variant === "highlight" || variant === "elegant" ? "text-white" : iconColorClass
          )} />
        </div>
        <div className="min-w-0 flex-1">
          <p className={cn(
            "text-xs font-semibold mb-1 tracking-wide",
            variant === "highlight" || variant === "elegant" 
              ? "text-rose-700" 
              : "text-gray-600"
          )}>{label}</p>
          <div className={cn(
            "text-sm font-medium break-words leading-relaxed",
            variant === "highlight" || variant === "elegant" 
              ? "text-gray-800" 
              : "text-gray-700",
            valueClassName
          )}>
            {value || "עוד נגלה יחד..."}
          </div>
        </div>
      </div>
    );

    if (tooltip) {
      return (
        <Tooltip>
          <TooltipTrigger asChild>{content}</TooltipTrigger>
          <TooltipContent side="top" className="max-w-xs text-center bg-white border border-rose-200 shadow-lg">
            <p className="text-gray-700">{tooltip}</p>
          </TooltipContent>
        </Tooltip>
      );
    }
    return content;
  };

  const EmptyState: React.FC<{
    icon: React.ElementType;
    title: string;
    description?: string;
    className?: string;
    action?: React.ReactNode;
    variant?: "mystery" | "adventure" | "discovery" | "romantic";
  }> = ({ icon: Icon, title, description, className, action, variant = "discovery" }) => {
    const variants = {
      mystery: {
        bg: `bg-gradient-to-br ${THEME.colors.secondary.lavender}`,
        border: "border-purple-200",
        iconBg: `bg-gradient-to-r ${THEME.colors.primary.romantic}`,
        textColor: "text-purple-700",
        titleColor: "text-purple-800"
      },
      adventure: {
        bg: `bg-gradient-to-br ${THEME.colors.secondary.sage}`,
        border: "border-emerald-200",
        iconBg: `bg-gradient-to-r ${THEME.colors.primary.rose}`,
        textColor: "text-emerald-700",
        titleColor: "text-emerald-800"
      },
      discovery: {
        bg: `bg-gradient-to-br ${THEME.colors.secondary.peach}`,
        border: "border-amber-200",
        iconBg: `bg-gradient-to-r ${THEME.colors.primary.gold}`,
        textColor: "text-amber-700",
        titleColor: "text-amber-800"
      },
      romantic: {
        bg: `bg-gradient-to-br ${THEME.colors.neutral.warm}`,
        border: "border-rose-200",
        iconBg: `bg-gradient-to-r ${THEME.colors.primary.rose}`,
        textColor: "text-rose-700",
        titleColor: "text-rose-800"
      }
    };

    const config = variants[variant];

    return (
      <div className={cn(
        "flex flex-col items-center justify-center py-8 text-center rounded-xl border border-dashed",
        config.bg,
        config.border,
        THEME.shadows.soft,
        className
      )}>
        <div className={cn("p-4 rounded-full mb-4", config.iconBg, THEME.shadows.warm)}>
          <Icon className="w-8 h-8 text-white" />
        </div>
        <h3 className={cn("text-lg font-bold mb-2", config.titleColor)}>{title}</h3>
        {description && (
          <p className={cn("text-sm mt-1 max-w-xs leading-relaxed", config.textColor)}>
            {description}
          </p>
        )}
        {action && <div className="mt-6">{action}</div>}
      </div>
    );
  };

  const SectionCard: React.FC<{
    title: string;
    subtitle?: string;
    icon?: React.ElementType;
    children: React.ReactNode;
    className?: string;
    contentClassName?: string;
    headerClassName?: string;
    action?: React.ReactNode;
    variant?: "default" | "elegant" | "romantic" | "highlight";
    gradient?: string;
  }> = ({ 
    title, 
    subtitle,
    icon: Icon, 
    children, 
    className, 
    contentClassName, 
    headerClassName, 
    action, 
    variant = "default",
    gradient
  }) => {
    const variants = {
      default: {
        card: "bg-white border-gray-200 shadow-lg hover:shadow-xl",
        header: "bg-gradient-to-r from-gray-50 to-white border-gray-200",
        iconBg: "bg-gray-100 border border-gray-200",
        iconColor: "text-gray-600"
      },
      elegant: {
        card: `bg-white border-amber-200 ${THEME.shadows.elegant}`,
        header: `bg-gradient-to-r ${gradient || THEME.colors.neutral.warm} border-amber-200`,
        iconBg: `bg-gradient-to-r ${THEME.colors.primary.gold} text-white`,
        iconColor: "text-white"
      },
      romantic: {
        card: `bg-white border-rose-200 ${THEME.shadows.soft}`,
        header: `bg-gradient-to-r ${gradient || THEME.colors.neutral.warm} border-rose-200`,
        iconBg: `bg-gradient-to-r ${THEME.colors.primary.rose} text-white`,
        iconColor: "text-white"
      },
      highlight: {
        card: `bg-white border-pink-200 ${THEME.shadows.soft} ring-1 ring-pink-100`,
        header: `bg-gradient-to-r ${gradient || THEME.colors.primary.romantic} border-pink-200`,
        iconBg: `bg-gradient-to-r ${THEME.colors.primary.elegant} text-white`,
        iconColor: "text-white"
      }
    };

    const config = variants[variant];

    return (
      <div className={cn(
        "rounded-2xl border overflow-hidden flex flex-col transition-all duration-300",
        config.card,
        className
      )}>
        <div className={cn(
          "flex items-center justify-between gap-3 p-4 border-b",
          config.header,
          headerClassName
        )}>
          <div className="flex items-center gap-3 min-w-0">
            {Icon && (
              <div className={cn("p-2 rounded-lg shadow-sm", config.iconBg)}>
                <Icon className={cn("w-5 h-5", config.iconColor)} />
              </div>
            )}
            <div className="min-w-0">
              <h3 className={cn(
                "text-base font-bold truncate",
                variant === "default" ? "text-gray-800" : "text-gray-800"
              )}>
                {title}
              </h3>
              {subtitle && (
                <p className="text-xs text-gray-600 mt-0.5 truncate">{subtitle}</p>
              )}
            </div>
          </div>
          {action && <div className="ml-auto flex-shrink-0">{action}</div>}
        </div>
        <div className={cn("p-4", contentClassName)}>{children}</div>
      </div>
    );
  };
  
  // Color Palette Selector Component
  const ColorPaletteSelector = () => (
    <div className="flex items-center gap-2 p-2 bg-white/90 backdrop-blur-sm rounded-xl border border-gray-200 shadow-sm">
      <Palette className="w-4 h-4 text-gray-500" />
      <select 
        value={selectedPalette}
        onChange={(e) => setSelectedPalette(e.target.value as ColorPaletteName)}
        className="text-xs bg-transparent border-none outline-none font-medium text-gray-600"
      >
        {Object.entries(COLOR_PALETTES).map(([key, palette]) => (
          <option key={key} value={key}>{palette.name}</option>
        ))}
      </select>
    </div>
  );

  // --- Enhanced Profile Header ---
  const ProfileHeader: React.FC<{
    profile: UserProfile;
    age: number;
    mainImageToDisplay: UserImageType | null;
    availability: ReturnType<typeof formatAvailabilityStatus>;
    viewMode: "matchmaker" | "candidate";
    onSuggestClick: () => void;
    isMobile?: boolean;
    selectedPalette: ColorPaletteName;
  }> = ({ profile, age, mainImageToDisplay, availability, viewMode, onSuggestClick, isMobile = false, selectedPalette }) => {
    
    // **בעיה 3: תיקון באג לוגי**
    // הוספנו את `selectedPalette` למערך התלויות של `useMemo`.
    // בלעדיו, הדגשים לא היו מתעדכנים עם שינוי ערכת הצבעים.
    const personalityHighlights = useMemo(() => {
      const currentTheme = COLOR_PALETTES[selectedPalette];
      const highlights: ExcitementFactor[] = [];
      
      if (profile.profileCharacterTraits?.length > 0) {
        const trait = profile.profileCharacterTraits[0];
        const traitData = formatEnumValue(trait, characterTraitMap, trait);
        highlights.push({
          icon: traitData.icon,
          text: traitData.label,
          gradient: currentTheme.colors.primary.light
        });
      }

      if (profile.profileHobbies?.length > 0) {
        const hobby = profile.profileHobbies[0];
        const hobbyData = formatEnumValue(hobby, hobbiesMap, hobby);
        highlights.push({
          icon: hobbyData.icon,
          text: hobbyData.label,
          gradient: currentTheme.colors.secondary.sage
        });
      }

      if (profile.city) {
        highlights.push({
          icon: MapPin,
          text: `גר/ה ב${profile.city}`,
          gradient: currentTheme.colors.secondary.sky
        });
      }

      return highlights.slice(0, 3);
    }, [profile, selectedPalette]);

    return (
      <div className="relative overflow-hidden">
        {/* Elegant Background */}
        <div className={cn("absolute inset-0 bg-gradient-to-br", THEME.colors.neutral.warm)}>
          <div className="absolute top-10 right-10 w-32 h-32 bg-gradient-to-br from-rose-200/40 to-pink-200/40 rounded-full blur-2xl animate-pulse"></div>
          <div className="absolute bottom-10 left-10 w-24 h-24 bg-gradient-to-br from-amber-200/40 to-orange-200/40 rounded-full blur-xl animate-pulse" style={{ animationDelay: "1s" }}></div>
          <div className="absolute top-1/2 left-1/2 w-20 h-20 bg-gradient-to-br from-purple-200/30 to-pink-200/30 rounded-full blur-lg animate-pulse" style={{ animationDelay: "2s" }}></div>
        </div>

        <div className="relative z-10 p-6">
          <div className={cn("flex gap-6", isMobile ? "flex-col items-center text-center" : "flex-row items-start")}>
            
            {/* Enhanced Profile Image */}
            <div className="relative flex-shrink-0">
              <div className={cn(
                "relative h-36 w-36 rounded-full overflow-hidden border-4 border-white shadow-2xl",
                "ring-4 ring-rose-200/50",
                THEME.shadows.elegant
              )}>
                {mainImageToDisplay?.url ? (
                  <Image
                    src={mainImageToDisplay.url}
                    alt={`תמונת פרופיל של ${profile.user?.firstName || 'מועמד יקר'}`}
                    fill
                    className="object-cover"
                    sizes="144px"
                    priority
                  />
                ) : (
                  <div className={cn(
                    "w-full h-full flex items-center justify-center",
                    `bg-gradient-to-br ${THEME.colors.primary.romantic}`
                  )}>
                    <span className="text-5xl font-bold text-white">
                      {getInitials(profile.user?.firstName, profile.user?.lastName)}
                    </span>
                  </div>
                )}
              </div>

              {/* Elegant Status Badge */}
              <div className="absolute -bottom-2 -right-2">
                <Badge className={cn(
                  "text-xs px-3 py-2 text-white border-0 font-bold",
                  availability.bgColor,
                  availability.pulse && "animate-pulse",
                  THEME.shadows.warm
                )}>
                  <availability.icon className="w-3 h-3 ml-1" />
                  {availability.text}
                </Badge>
              </div>
            </div>

            {/* **בעיה 1: פתרון** */}
            {/* המבנה של ה-div הזה שונה כדי להבטיח זרימה אנכית נכונה ולמנוע חפיפה של תוכן. */}
            <div className="flex-1 min-w-0 flex flex-col justify-start items-start">
              <div className="w-full">
                 {!isMobile && (
                  <div className="flex justify-end mb-2">
                    <ColorPaletteSelector />
                  </div>
                )}
                
                {/* Name and Age */}
                <div className={cn("mb-4 w-full", isMobile && "text-center")}>
                    <h1 className={cn(
                      "text-4xl md:text-5xl font-extrabold leading-tight mb-2",
                      "bg-gradient-to-r from-gray-800 via-gray-900 to-black bg-clip-text text-transparent",
                       isMobile && "mx-auto" // Center title on mobile
                    )}>
                      {profile.user?.firstName ? (
                        <>
                          הכירו את {profile.user.firstName}
                          {profile.user.lastName && ` ${profile.user.lastName}`}
                        </>
                      ) : (
                        "מישהו מיוחד מחכה להכרות"
                      )}
                    </h1>

                    {age > 0 && (
                      <div className="mt-3">
                        <p className="text-xl text-gray-700 font-semibold flex items-center justify-center lg:justify-start gap-2">
                          <Cake className="w-5 h-5 text-blue-500" />
                          {/* שיפור UX: טקסט גיל ניטרלי */}
                          גיל: {age}
                        </p>
                      </div>
                    )}
                </div>

                {/* Personality Highlights */}
                {personalityHighlights.length > 0 && (
                  <div className={cn("flex gap-3 flex-wrap mt-4 w-full", isMobile ? "justify-center" : "justify-start")}>
                    {personalityHighlights.map((highlight, index) => (
                      <div
                        key={index}
                        className={cn(
"flex items-center gap-2 px-4 py-2 rounded-full text-gray-700 font-semibold text-sm",                          THEME.shadows.soft
                        )}
                      >
                        <highlight.icon className="w-4 h-4" />
                        <span>{highlight.text}</span>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              {/* Key Facts Grid */}
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6 w-full">
                {profile.city && (
                  <div className={cn(
                    "flex items-center gap-3 p-3 bg-white/80 backdrop-blur-sm rounded-xl",
                    "border border-rose-200/50 shadow-sm hover:shadow-md transition-all"
                  )}>
                    <MapPin className="w-5 h-5 text-rose-500" />
                    <div>
                      <p className="text-xs text-gray-500 font-medium">מיקום</p>
                      <p className="text-sm font-semibold text-gray-800">{profile.city}</p>
                    </div>
                  </div>
                )}

                {profile.occupation && (
                  <div className={cn(
                    "flex items-center gap-3 p-3 bg-white/80 backdrop-blur-sm rounded-xl",
                    "border border-amber-200/50 shadow-sm hover:shadow-md transition-all"
                  )}>
                    <Briefcase className="w-5 h-5 text-amber-600" />
                    <div>
                      <p className="text-xs text-gray-500 font-medium">עיסוק</p>
                      <p className="text-sm font-semibold text-gray-800">{profile.occupation}</p>
                    </div>
                  </div>
                )}

                {profile.religiousLevel && (
                  <div className={cn(
                    "flex items-center gap-3 p-3 bg-white/80 backdrop-blur-sm rounded-xl",
                    "border border-purple-200/50 shadow-sm hover:shadow-md transition-all"
                  )}>
                    <BookMarked className="w-5 h-5 text-purple-600" />
                    <div>
                      <p className="text-xs text-gray-500 font-medium">השקפה</p>
                      <p className="text-sm font-semibold text-gray-800">
                        {formatEnumValue(profile.religiousLevel, religiousLevelMap).label}
                      </p>
                    </div>
                  </div>
                )}
              </div>

              {/* Action Button for Matchmakers */}
              {viewMode === 'matchmaker' && (
                <div className={cn("pt-6 w-full flex", isMobile ? "justify-center" : "justify-end")}>
                  <Button
                    size="lg"
                    className={cn(
                      "bg-gradient-to-r from-rose-500 via-pink-500 to-rose-600",
                      "hover:from-rose-600 hover:via-pink-600 hover:to-rose-700",
                      "text-white font-bold rounded-full px-8 py-3",
                      "shadow-xl hover:shadow-2xl transition-all duration-300 transform hover:scale-105"
                    )}
                    onClick={onSuggestClick}
                  >
                    <Heart className="w-5 h-5 ml-2" />
                    הצע התאמה מושלמת
                    <ArrowRight className="w-5 h-5 mr-2" />
                  </Button>
                </div>
              )}
            </div>
          </div>

          {/* Inspirational Quote */}
          <div className="mt-8 text-center">
            <div className={cn(
              "inline-flex items-center gap-3 px-6 py-3 rounded-full",
              `bg-gradient-to-r ${THEME.colors.primary.romantic}`,
              "text-white shadow-lg"
            )}>
              <Quote className="w-5 h-5" />
              <p className="text-lg font-medium italic">
                כל סיפור אהבה מתחיל בהכרות אחת מיוחדת...
              </p>
              <Quote className="w-5 h-5 transform rotate-180" />
            </div>
          </div>
        </div>
      </div>
    );
  };


  // --- Enhanced Questionnaire Item ---
  const QuestionnaireItem: React.FC<{
    answer: FormattedAnswer;
    worldColor?: string;
    worldGradient?: string;
  }> = ({ answer, worldColor = "rose", worldGradient }) => {
    return (
      <div className={cn(
        "p-5 rounded-xl border transition-all duration-300 hover:shadow-lg",
        "bg-gradient-to-br from-white to-gray-50/30",
        `border-${worldColor}-200 hover:border-${worldColor}-300`
      )}>
        <div className="flex items-start gap-4">
          <div className={cn(
            "p-3 rounded-lg flex-shrink-0 text-white shadow-md",
            worldGradient ? `bg-gradient-to-r ${worldGradient}` : `bg-gradient-to-r from-${worldColor}-400 to-${worldColor}-500`
          )}>
            <Quote className="w-5 h-5" />
          </div>
          <div className="flex-1 min-w-0">
            <h4 className="text-sm font-bold mb-3 text-gray-800 leading-relaxed">
              {answer.question}
            </h4>
            <div className={cn(
              "p-4 rounded-lg border-r-4 bg-white/60",
              `border-${worldColor}-400`
            )}>
              <p className="text-sm text-gray-700 leading-relaxed italic">
                <Quote className="w-4 h-4 inline ml-1 text-gray-400" />
                {answer.displayText || answer.answer}
                <Quote className="w-4 h-4 inline mr-1 text-gray-400 transform rotate-180" />
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  };

  useEffect(() => {
    setIsClient(true);
    const checkScreenSize = () => setIsDesktop(window.innerWidth >= 1024);
    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    const onFullscreenChange = () => {
        setIsFullscreen(!!document.fullscreenElement);
    };
    document.addEventListener('fullscreenchange', onFullscreenChange);

    return () => {
        window.removeEventListener("resize", checkScreenSize);
        document.removeEventListener('fullscreenchange', onFullscreenChange);
    };
  }, []);
  
  const hasAnyPreferences = useMemo(() => {
    return (
      (profile.preferredMaritalStatuses && profile.preferredMaritalStatuses.length > 0) ||
      (profile.preferredReligiousLevels && profile.preferredReligiousLevels.length > 0) ||
      (profile.preferredEducation && profile.preferredEducation.length > 0) ||
      (profile.preferredOccupations && profile.preferredOccupations.length > 0) ||
      (profile.preferredLocations && profile.preferredLocations.length > 0) ||
      (profile.preferredCharacterTraits && profile.preferredCharacterTraits.length > 0) ||
      (profile.preferredHobbies && profile.preferredHobbies.length > 0)
    );
  }, [profile]);

  const orderedImages = useMemo(() => {
    const validImages = (images || []).filter(img => img.url);
    const mainImg = validImages.find(img => img.isMain);
    const otherImages = validImages.filter(img => !img.isMain);
    return mainImg ? [mainImg, ...otherImages] : validImages;
  }, [images]);

  const mainImageToDisplay = useMemo(() => orderedImages.length > 0 ? orderedImages[0] : null, [orderedImages]);
  const age = useMemo(() => calculateAge(profile.birthDate), [profile.birthDate]);
  const availability = useMemo(() => formatAvailabilityStatus(profile.availabilityStatus), [profile.availabilityStatus, formatAvailabilityStatus]);

  const hasDisplayableQuestionnaireAnswers = useMemo(() =>
    questionnaire &&
    questionnaire.formattedAnswers &&
    Object.values(questionnaire.formattedAnswers)
      .flat()
      .some((a) => a.isVisible !== false && (a.answer || a.displayText)),
    [questionnaire]
  );

  const currentDialogImageIndex = useMemo(() =>
    selectedImageForDialog ? orderedImages.findIndex(img => img.id === selectedImageForDialog.id) : -1,
    [selectedImageForDialog, orderedImages]
  );

  const handleOpenImageDialog = (image: UserImageType) => image.url && setSelectedImageForDialog(image);
  const handleCloseImageDialog = () => setSelectedImageForDialog(null);

  const handleDialogNav = (direction: "next" | "prev") => {
    if (currentDialogImageIndex === -1 || orderedImages.length <= 1) return;
    const newIndex = (currentDialogImageIndex + (direction === 'next' ? 1 : -1) + orderedImages.length) % orderedImages.length;
    setSelectedImageForDialog(orderedImages[newIndex]);
  };

  const handleCreateSuggestion = async (data: CreateSuggestionData) => {
    if (onCreateSuggestion) {
      await onCreateSuggestion(data);
    }
    setIsSuggestDialogOpen(false);
  };
  
  const handleToggleFullscreen = () => {
    const elem = document.getElementById('profile-card-container');
    if (!elem) return;
    
    if (!document.fullscreenElement) {
      elem.requestFullscreen().catch(err => {
        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
      });
    } else {
      document.exitFullscreen();
    }
  };

  // Enhanced tab configuration with THEME dependency
  const tabItems = useMemo(() => [
    { 
      value: "essence", 
      label: "המהות", 
      icon: Sparkles, 
      gradient: THEME.colors.primary.light, 
      description: "מי זה האדם הזה באמת" 
    },
    { 
      value: "story", 
      label: "הסיפור", 
      icon: BookOpen, 
      gradient: THEME.colors.primary.accent, 
      description: "הרקע והדרך שהובילה לכאן" 
    },
    { 
      value: "vision", 
      label: "החזון", 
      icon: Heart, 
      gradient: THEME.colors.primary.main, 
      description: "החלום לזוגיות ומשפחה" 
    },
    { 
      value: "search", 
      label: "החיפוש", 
      icon: Target, 
      gradient: THEME.colors.secondary.sky, 
      description: "מה מחפש בבן/בת הזוג" 
    },
    ...(hasDisplayableQuestionnaireAnswers ? [{
      value: "deeper",
      label: "עומק",
      icon: Telescope,
      gradient: THEME.colors.secondary.peach,
      description: "תשובות מעמיקות מהלב"
    }] : []),
    ...(viewMode === "matchmaker" ? [{
      value: "professional",
      label: "מקצועי",
      icon: Lock,
      gradient: THEME.colors.secondary.lavender,
      description: "מידע לשדכן בלבד"
    }] : []),
  ], [hasDisplayableQuestionnaireAnswers, viewMode, THEME]);

  const renderPreferenceBadges = (
    title: string,
    icon: React.ElementType,
    values: string[] | undefined,
    translationMap: { [key: string]: { label: string; icon: React.ElementType; color: string } },
    gradientClass: string = THEME.colors.secondary.sky
  ) => {
    if (!values || values.length === 0) {
      // לא נציג כלום כאן אם אין ערכים, כדי למנוע כפילויות.
      // הבדיקה הראשית נעשית בלשונית החיפוש.
      return null;
    }

    const IconComponent = icon;
    return (
      <div className="space-y-4">
        <div className="flex items-center gap-3">
          <div className={cn("p-2 rounded-lg bg-gradient-to-r", gradientClass)}>
            <IconComponent className="w-5 h-5 text-white" />
          </div>
          <h4 className="text-base font-bold text-gray-800">{title}</h4>
        </div>
        <div className="flex flex-wrap gap-3">
          {values.map((val) => {
            const itemData = translationMap[val] || { label: val, icon: Sparkles, color: "text-gray-600" };
            return (
              <Badge
                key={val}
                variant="outline"
                className={cn(
                  "flex items-center gap-2 text-sm px-4 py-2 font-semibold border-2",
                  "bg-white hover:bg-gray-50 transition-all hover:scale-105",
                  "border-gray-200 hover:border-rose-300",
                  THEME.shadows.soft
                )}
              >
                <itemData.icon className={cn("w-4 h-4", itemData.color)} />
                {itemData.label}
              </Badge>
            );
          })}
        </div>
      </div>
    );
  };

  // Enhanced Main Content Tabs
  const MainContentTabs = () => (
    <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full flex flex-col flex-grow min-h-0">
      <div className={cn(
        "bg-white/95 backdrop-blur-md p-3 rounded-2xl mb-6 border border-gray-200/50",
        THEME.shadows.elegant,
        "sticky top-0 z-20"
      )}>
        <ScrollArea dir="rtl" className="w-full">
          <TabsList className="h-auto inline-flex bg-transparent p-2 gap-2">
            {tabItems.map((tab) => (
              <TabsTrigger
                key={tab.value}
                value={tab.value}
                className={cn(
                  "flex flex-col items-center gap-2 px-4 py-4 text-xs rounded-xl",
                  "whitespace-nowrap transition-all duration-300",
                  "text-gray-600 hover:text-gray-800 hover:bg-rose-50",
                  "min-w-[90px] border border-transparent",
                  activeTab === tab.value && cn(
                    "font-bold text-white shadow-lg border-white/20",
                    `bg-gradient-to-r ${tab.gradient}`
                  )
                )}
              >
                <tab.icon className="w-5 h-5" />
                <span className="font-semibold">{tab.label}</span>
                {tab.description && activeTab === tab.value && (
                  <span className="text-[10px] text-white/90 leading-tight text-center max-w-[80px] font-normal">
                    {tab.description}
                  </span>
                )}
              </TabsTrigger>
            ))}
          </TabsList>
          <ScrollBar orientation="horizontal" />
        </ScrollArea>
      </div>

      <div className="space-y-8 focus:outline-none flex-grow min-h-0">
        
        {/* Essence Tab - The Heart of the Person */}
        <TabsContent value="essence" className="mt-0">
          <div className="space-y-8">
            
            <SectionCard
              title="הנשמה והמהות"
              subtitle="מי זה האדם הזה באמת"
              icon={Heart}
              variant="romantic"
              gradient={THEME.colors.primary.main}
            >
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                
                <div className="relative">
                  <div className={cn(
                    "relative aspect-[3/4] rounded-2xl overflow-hidden",
                    "border-4 border-white shadow-2xl ring-4 ring-rose-200/50"
                  )}>
                    {mainImageToDisplay?.url ? (
                      <Image
                        src={mainImageToDisplay.url}
                        alt={`${profile.user?.firstName || 'מועמד'} נראה/ת מדהים/ה`}
                        fill
                        className="object-cover transition-transform duration-700 hover:scale-105"
                        sizes="(max-width: 1024px) 100vw, 50vw"
                        priority
                      />
                    ) : (
                      <div className={cn(
                        "w-full h-full flex items-center justify-center",
                        `bg-gradient-to-br ${THEME.colors.primary.romantic}`
                      )}>
                        <div className="text-center text-white">
                          <User className="w-24 h-24 mx-auto mb-4 opacity-80" />
                          <p className="text-xl font-bold">התמונה המושלמת</p>
                          <p className="text-sm opacity-80">מחכה להיחשף</p>
                        </div>
                      </div>
                    )}

                    <div className="absolute top-4 right-4">
                      {profile.gender === "FEMALE" && (
                        <Badge className={cn(
                          "bg-gradient-to-r from-pink-500 to-rose-500 text-white border-0",
                          THEME.shadows.warm
                        )}>
                          <Crown className="w-3 h-3 ml-1" />
                          נסיכה
                        </Badge>
                      )}
                      {profile.gender === "MALE" && (
                        <Badge className={cn(
                          "bg-gradient-to-r from-blue-500 to-cyan-500 text-white border-0",
                          THEME.shadows.warm
                        )}>
                          <Zap className="w-3 h-3 ml-1" />
                          נסיך
                        </Badge>
                      )}
                    </div>
                  </div>
                </div>

                <div className="space-y-6">
                  <div className="text-center lg:text-right">
                    <h2 className={cn(
                      "text-3xl md:text-4xl font-extrabold mb-4 leading-tight",
                      "bg-gradient-to-r from-rose-600 via-pink-600 to-amber-600 bg-clip-text text-transparent"
                    )}>
                      {profile.user?.firstName || "מישהו מדהים"}
                    </h2>

                    {age > 0 && (
                      <p className="text-xl text-gray-700 font-bold mb-6 flex items-center justify-center lg:justify-start gap-2">
                        <Cake className="w-5 h-5 text-rose-500" />
                        גיל: {age}
                      </p>
                    )}

                    {profile.about ? (
                      <div className={cn(
                        "relative p-6 rounded-2xl border border-rose-200/50",
                        `bg-gradient-to-r ${THEME.colors.neutral.warm}`,
                        THEME.shadows.soft
                      )}>
                        <Quote className="absolute top-3 right-3 w-8 h-8 text-rose-300" />
                        <p className="text-lg text-gray-800 leading-relaxed italic font-medium text-center lg:text-right">
                          {profile.about}
                        </p>
                        <Quote className="absolute bottom-3 left-3 w-8 h-8 text-rose-300 transform rotate-180" />
                      </div>
                    ) : (
                      <EmptyState
                        icon={Telescope}
                        title="הסיפור האישי מחכה להיכתב"
                        description="יש כאן אדם מעניין שמחכה לגילוי יחד איתך"
                        variant="romantic"
                      />
                    )}
                  </div>

                  <div className="grid grid-cols-1 gap-4">
                    {profile.city && (
                      <DetailItem
                        icon={MapPin}
                        label="הבית שבלב"
                        value={`${profile.city} - המקום שקורא לי בית`}
                        variant="highlight"
                        size="md"
                      />
                    )}

                    {profile.occupation && (
                      <DetailItem
                        icon={Briefcase}
                        label="התחום שמלהיב אותי"
                        value={`${profile.occupation} - כאן אני נותן/ת את הלב`}
                        variant="highlight"
                        size="md"
                      />
                    )}

                    {profile.religiousLevel && (
                      <DetailItem
                        icon={BookMarked}
                        label="השקפת העולם שמנחה אותי"
                        value={formatEnumValue(profile.religiousLevel, religiousLevelMap).label}
                        variant="highlight"
                        size="md"
                      />
                    )}
                  </div>
                </div>
              </div>
            </SectionCard>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              
              <SectionCard
                title="תכונות הזהב שלי"
                subtitle="מה שעושה אותי מיוחד/ת"
                icon={Sparkles}
                variant="elegant"
                gradient={THEME.colors.primary.light}
              >
                <div className="space-y-4">
                  {profile.profileCharacterTraits?.length > 0 ? (
                    <div className="flex flex-wrap gap-3">
                      {profile.profileCharacterTraits.map(trait => {
                        const traitData = formatEnumValue(trait, characterTraitMap, trait);
                        return (
                          <Badge
                            key={trait}
                            className={cn(
                              "flex items-center gap-2 px-4 py-2 font-semibold text-sm",
                              "bg-gradient-to-r from-purple-100 to-pink-100 text-purple-800",
                              "border border-purple-200 rounded-full",
                              "hover:scale-105 transition-transform",
                              THEME.shadows.soft
                            )}
                          >
                            <traitData.icon className={cn("w-4 h-4", traitData.color)} />
                            {traitData.label}
                          </Badge>
                        );
                      })}
                    </div>
                  ) : (
                    <EmptyState
                      icon={Sparkles}
                      title="תכונות מיוחדות מחכות לגילוי"
                      description="האישיות הייחודית תתגלה בהכרות"
                      variant="mystery"
                    />
                  )}
                </div>
              </SectionCard>

              <SectionCard
                title="מה שאני אוהב/ת לעשות"
                subtitle="התחביבים והתשוקות שלי"
                icon={Heart}
                variant="elegant"
                gradient={THEME.colors.secondary.sage}
              >
                <div className="space-y-4">
                  {profile.profileHobbies?.length > 0 ? (
                    <div className="flex flex-wrap gap-3">
                      {profile.profileHobbies.map(hobby => {
                        const hobbyData = formatEnumValue(hobby, hobbiesMap, hobby);
                        return (
                          <Badge
                            key={hobby}
                            className={cn(
                              "flex items-center gap-2 px-4 py-2 font-semibold text-sm",
                              "bg-gradient-to-r from-emerald-100 to-cyan-100 text-emerald-800",
                              "border border-emerald-200 rounded-full",
                              "hover:scale-105 transition-transform",
                              THEME.shadows.soft
                            )}
                          >
                            <hobbyData.icon className={cn("w-4 h-4", hobbyData.color)} />
                            {hobbyData.label}
                          </Badge>
                        );
                      })}
                    </div>
                  ) : (
                    <EmptyState
                      icon={Mountain}
                      title="הרפתקאות מחכות לנו יחד"
                      description="נגלה ביחד מה אנחנו אוהבים לעשות"
                      variant="adventure"
                    />
                  )}
                </div>
              </SectionCard>
            </div>

            <div className={cn(
              "text-center p-8 rounded-2xl text-white",
              `bg-gradient-to-r ${THEME.colors.primary.main}`,
              THEME.shadows.elegant
            )}>
              <h3 className="text-2xl font-bold mb-4">
                מוכנים להכיר את {profile.user?.firstName || "המועמד המושלם"}?
              </h3>
              <p className="text-lg mb-6 opacity-90">
                עוד המון דברים מעניינים מחכים לגילוי...
              </p>
              <div className="flex flex-wrap justify-center gap-4">
                <Button
                  onClick={() => setActiveTab('story')}
                  className={cn(
                    "bg-white text-gray-600 hover:bg-gray-50 font-bold px-6 py-3 rounded-full",
                    THEME.shadows.warm
                  )}
                >
                  <BookOpen className="w-5 h-5 ml-2" />
                  בואו נכיר את הסיפור
                </Button>
                <Button
                  onClick={() => setActiveTab('vision')}
                  variant="outline"
className="bg-white/20 hover:bg-white border border-white/30 text-white hover:text-rose-600 font-bold px-6 py-3 rounded-full backdrop-blur-sm transition-all"                >
                  <Heart className="w-5 h-5 ml-2" />
                  מה החלום לזוגיות
                </Button>
              </div>
            </div>
          </div>
        </TabsContent>

        {/* Story Tab - Background & Journey */}
        <TabsContent value="story" className="mt-0 space-y-6">
          <div className="text-center mb-8">
            <h2 className={cn(
              "text-3xl font-bold mb-4",
              "bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent"
            )}>
              הסיפור והמסע של {profile.user?.firstName || "המועמד"}
            </h2>
            <p className="text-gray-600 text-lg">השורשים, הדרך והערכים שעיצבו את האדם הזה</p>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            
            <SectionCard
              title="הזהות הדתית והרוחנית"
              subtitle="המקום של האמונה והמסורת בחיי"
              icon={BookMarked}
              variant="elegant"
              gradient={THEME.colors.primary.gold}
            >
              <div className="space-y-5">
                <DetailItem
                  icon={BookMarked}
                  label="השקפת העולם שמנחה אותי"
                  value={formatEnumValue(profile.religiousLevel, religiousLevelMap).label}
                  variant="highlight"
                />
                
                <DetailItem
                  icon={Heart}
                  label="שמירת נגיעה"
                  value={formatBooleanPreference(profile.shomerNegiah, "כן, זה חשוב לי", "לא").label}
                  variant="elegant"
                />

                {profile.gender === "FEMALE" && profile.headCovering && (
                  <DetailItem
                    icon={Crown}
                    label="כיסוי ראש"
                    value={formatEnumValue(profile.headCovering, headCoveringMap).label}
                    variant="elegant"
                  />
                )}

                {profile.gender === "MALE" && profile.kippahType && (
                  <DetailItem
                    icon={Crown}
                    label="סוג כיפה"
                    value={formatEnumValue(profile.kippahType, kippahTypeMap).label}
                    variant="elegant"
                  />
                )}
              </div>
            </SectionCard>

            <SectionCard
              title="השכלה ועולם המקצוע"
              subtitle="הדרך האקדמית והמקצועית שלי"
              icon={GraduationCap}
              variant="elegant"
              gradient={THEME.colors.secondary.sky}
            >
              <div className="space-y-5">
                <DetailItem
                  icon={GraduationCap}
                  label="רמת ההשכלה"
                  value={formatEnumValue(profile.educationLevel, educationLevelMap).label}
                  variant="highlight"
                />

                {profile.education && (
                  <DetailItem
                    icon={BookOpen}
                    label="פירוט הלימודים"
                    value={profile.education}
                    variant="elegant"
                    valueClassName="whitespace-pre-wrap"
                  />
                )}

                <DetailItem
                  icon={Briefcase}
                  label="התחום המקצועי"
                  value={profile.occupation || "מקצוע מעניין מחכה לגילוי"}
                  variant="elegant"
                />

                <DetailItem
                  icon={Award}
                  label="השירות הצבאי/לאומי"
                  value={formatEnumValue(profile.serviceType, serviceTypeMap).label}
                  variant="elegant"
                />

                {profile.serviceDetails && (
                  <DetailItem
                    icon={InfoIcon}
                    label="פרטי השירות"
                    value={profile.serviceDetails}
                    variant="elegant"
                    valueClassName="whitespace-pre-wrap"
                  />
                )}
              </div>
            </SectionCard>
          </div>

          <SectionCard
            title="הרקע המשפחתי והתרבותי"
            subtitle="המשפחה והמקורות שעיצבו אותי"
            icon={Users2}
            variant="romantic"
            gradient={THEME.colors.primary.accent}
          >
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-5">
              <DetailItem
                icon={Users2}
                label="סטטוס ההורים"
                value={profile.parentStatus || "נגלה יחד"}
                variant="elegant"
              />
              
              <DetailItem
                icon={Users}
                label="אחים ואחיות"
                value={profile.siblings ? `${profile.siblings} אחים/אחיות` : "נגלה יחד"}
                variant="elegant"
              />
              
              <DetailItem
                icon={Crown}
                label="המקום במשפחה"
                value={profile.position ? `מקום ${profile.position}` : "נגלה יחד"}
                variant="elegant"
              />

              {profile.aliyaCountry && (
                <DetailItem
                  icon={Globe}
                  label="ארץ המוצא"
                  value={`${profile.aliyaCountry} - השורשים שלי`}
                  variant="elegant"
                />
              )}

              {profile.aliyaYear && (
                <DetailItem
                  icon={Calendar}
                  label="שנת העלייה"
                  value={`${profile.aliyaYear} - הגעתי הביתה`}
                  variant="elegant"
                />
              )}

              {profile.nativeLanguage && (
                <DetailItem
                  icon={Languages}
                  label="השפה הראשונה"
                  value={formatEnumValue(profile.nativeLanguage, languageMap).label}
                  variant="elegant"
                />
              )}
            </div>

            {profile.additionalLanguages && profile.additionalLanguages.length > 0 && (
              <div className="mt-6 pt-6 border-t border-gray-200">
                <h4 className="text-base font-bold text-gray-800 mb-4 flex items-center gap-2">
                  <Languages className="w-5 h-5 text-blue-500" />
                  שפות נוספות שאני מדבר/ת
                </h4>
                <div className="flex flex-wrap gap-3">
                  {profile.additionalLanguages.map(lang => {
                    const langData = formatEnumValue(lang, languageMap);
                    return (
                      <Badge
                        key={lang}
                        className={cn(
                          "flex items-center gap-2 px-4 py-2 font-semibold text-sm",
                          "bg-gradient-to-r from-blue-100 to-cyan-100 text-blue-800",
                          "border border-blue-200 rounded-full",
                          THEME.shadows.soft
                        )}
                      >
                        <langData.icon className={cn("w-4 h-4", langData.color)} />
                        {langData.label}
                      </Badge>
                    );
                  })}
                </div>
              </div>
            )}
          </SectionCard>
        </TabsContent>

        {/* Vision Tab - Dreams & Aspirations */}
        <TabsContent value="vision" className="mt-0 space-y-6">
          <div className="text-center mb-8">
            <h2 className={cn(
              "text-3xl font-bold mb-4",
              "bg-gradient-to-r from-rose-600 to-pink-600 bg-clip-text text-transparent"
            )}>
              החזון והחלום לזוגיות של {profile.user?.firstName || "המועמד"}
            </h2>
            <p className="text-gray-600 text-lg">איך אני רואה את העתיד שלנו יחד</p>
          </div>

          <SectionCard
            title="הזוגיות שאני חולם/ת עליה"
            subtitle="המחשבות והרגשות שלי על אהבה ומשפחה"
            icon={Heart}
            variant="romantic"
            gradient={THEME.colors.primary.main}
          >
            {profile.matchingNotes ? (
              <div className={cn(
                "p-6 rounded-2xl border border-rose-200",
                `bg-gradient-to-r ${THEME.colors.neutral.warm}`,
                THEME.shadows.soft
              )}>
                <div className="flex items-start gap-4">
                  <div className={cn(
                    "p-3 rounded-full bg-gradient-to-r",
                    THEME.colors.primary.rose
                  )}>
                    <Heart className="w-6 h-6 text-white" />
                  </div>
                  <div>
                    <h4 className="font-bold text-rose-800 mb-3 text-lg">
                      המחשבות שלי על הזוגיות המושלמת:
                    </h4>
                    <p className="text-rose-700 leading-relaxed whitespace-pre-wrap italic text-lg">
                      <Quote className="w-5 h-5 inline ml-1 text-rose-400" />
                      {profile.matchingNotes}
                      <Quote className="w-5 h-5 inline mr-1 text-rose-400 transform rotate-180" />
                    </p>
                  </div>
                </div>
              </div>
            ) : (
              // שיפור UX: טקסט משופר למצב ריק
              <EmptyState
                icon={Heart}
                title="החזון לזוגיות טרם פורט"
                description="זו הזדמנות מצוינת להתחיל שיחה ולגלות יחד!"
                variant="romantic"
              />
            )}

            <div className="mt-8 space-y-6">
              <h4 className="text-xl font-bold text-gray-800 flex items-center gap-3">
                <Baby className="w-6 h-6 text-pink-500" />
                החזון למשפחה
              </h4>
              
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
                {profile.maritalStatus && ["divorced", "widowed", "annulled"].includes(profile.maritalStatus) && (
                  <DetailItem
                    icon={Baby}
                    label="ילדים מקשר קודם"
                    value={formatBooleanPreference(
                      profile.hasChildrenFromPrevious, 
                      "יש ילדים יקרים", 
                      "אין ילדים", 
                      "נגלה יחד"
                    ).label}
                    variant="elegant"
                  />
                )}

                {(profile.preferredAgeMin || profile.preferredAgeMax) && (
                  <DetailItem
                    icon={Calendar}
                    label="הגיל המועדף עליי"
                    value={`${profile.preferredAgeMin || '?'} - ${profile.preferredAgeMax || '?'} שנים`}
                    variant="highlight"
                  />
                )}

                {(profile.preferredHeightMin || profile.preferredHeightMax) && (
                  <DetailItem
                    icon={User}
                    label="הגובה המועדף"
                    value={`${profile.preferredHeightMin || '?'} - ${profile.preferredHeightMax || '?'} ס״מ`}
                    variant="highlight"
                  />
                )}

                <DetailItem
                  icon={Heart}
                  label="שמירת נגיעה בזוגיות"
                  value={formatStringBooleanPreference(profile.preferredShomerNegiah).label}
                  variant="elegant"
                />
              </div>
            </div>
          </SectionCard>
        </TabsContent>

        {/* **בעיה 2: פתרון** */}
        {/* החלפנו את הלוגיקה כדי להציג הודעה אחת כללית אם אין העדפות כלל */}
        <TabsContent value="search" className="mt-0 space-y-6">
          <div className="text-center mb-8">
            <h2 className={cn(
              "text-3xl font-bold mb-4",
              "bg-gradient-to-r from-blue-600 to-cyan-600 bg-clip-text text-transparent"
            )}>
              מה {profile.user?.firstName || "המועמד"} מחפש/ת בבן/בת הזוג
            </h2>
            <p className="text-gray-600 text-lg">התכונות והערכים שחשובים בהתאמה</p>
          </div>

          {hasAnyPreferences ? (
            <div className="space-y-8">
              {renderPreferenceBadges(
                "סטטוסים משפחתיים מועדפים",
                Heart,
                profile.preferredMaritalStatuses,
                maritalStatusMap,
                THEME.colors.primary.main
              )}

              {renderPreferenceBadges(
                "רמות דתיות מועדפות",
                BookMarked,
                profile.preferredReligiousLevels,
                religiousLevelMap,
                THEME.colors.secondary.peach
              )}

              {renderPreferenceBadges(
                "רמות השכלה מועדפות",
                GraduationCap,
                profile.preferredEducation,
                educationLevelMap,
                THEME.colors.secondary.sky
              )}
              
              {/* החלקים הבאים יוצגו רק אם יש להם ערכים */}
              {profile.preferredOccupations && profile.preferredOccupations.length > 0 && renderPreferenceBadges(
                "תחומי עיסוק מועדפים",
                Briefcase,
                profile.preferredOccupations,
                {},
                THEME.colors.secondary.sage
              )}

              {profile.preferredLocations && profile.preferredLocations.length > 0 && renderPreferenceBadges(
                "מקומות מגורים מועדפים",
                MapPin,
                profile.preferredLocations,
                {},
                THEME.colors.secondary.peach
              )}
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {profile.preferredCharacterTraits && profile.preferredCharacterTraits.length > 0 && (
                  <SectionCard
                    title="תכונות אופי מועדפות"
                    subtitle="איך אני רואה את בן/בת הזוג שלי"
                    icon={Sparkles}
                    variant="elegant"
                    gradient={THEME.colors.primary.light}
                  >
                    <div className="flex flex-wrap gap-3">
                      {profile.preferredCharacterTraits.map(trait => {
                        const traitData = formatEnumValue(trait, characterTraitMap, trait);
                        return (
                          <Badge
                            key={trait}
                            className={cn(
                              "flex items-center gap-2 px-3 py-2 font-semibold text-sm",
                              "bg-gradient-to-r from-purple-100 to-violet-100 text-purple-800",
                              "border border-purple-200 rounded-full",
                              THEME.shadows.soft
                            )}
                          >
                            <traitData.icon className={cn("w-4 h-4", traitData.color)} />
                            {traitData.label}
                          </Badge>
                        );
                      })}
                    </div>
                  </SectionCard>
                )}

                {profile.preferredHobbies && profile.preferredHobbies.length > 0 && (
                  <SectionCard
                    title="תחביבים מועדפים"
                    subtitle="מה נעשה יחד בזמן הפנוי"
                    icon={Heart}
                    variant="elegant"
                    gradient={THEME.colors.secondary.sage}
                  >
                    <div className="flex flex-wrap gap-3">
                      {profile.preferredHobbies.map(hobby => {
                        const hobbyData = formatEnumValue(hobby, hobbiesMap, hobby);
                        return (
                          <Badge
                            key={hobby}
                            className={cn(
                              "flex items-center gap-2 px-3 py-2 font-semibold text-sm",
                              "bg-gradient-to-r from-emerald-100 to-green-100 text-emerald-800",
                              "border border-emerald-200 rounded-full",
                              THEME.shadows.soft
                            )}
                          >
                            <hobbyData.icon className={cn("w-4 h-4", hobbyData.color)} />
                            {hobbyData.label}
                          </Badge>
                        );
                      })}
                    </div>
                  </SectionCard>
                )}
              </div>
            </div>
          ) : (
            <EmptyState
              icon={Compass}
              title="פתוח/ה לכל האפשרויות"
              description="הלב פתוח להכיר אדם מיוחד, ללא דרישות מוקדמות. יש כאן מקום לגילויים מרגשים יחד."
              variant="discovery"
            />
          )}
        </TabsContent>

        {/* Deeper Tab - Questionnaire Answers */}
        {hasDisplayableQuestionnaireAnswers && (
          <TabsContent value="deeper" className="mt-0 space-y-6">
            <div className="text-center mb-8">
              <h2 className={cn(
                "text-3xl font-bold mb-4",
                "bg-gradient-to-r from-amber-600 to-orange-600 bg-clip-text text-transparent"
              )}>
                התשובות העמוקות מהלב של {profile.user?.firstName || "המועמד"}
              </h2>
              <p className="text-gray-600 text-lg">מחשבות אישיות ותובנות על החיים והאהבה</p>
            </div>

            {Object.entries(WORLDS).map(([worldKey, worldConfig]) => {
              const answersForWorld = (questionnaire?.formattedAnswers?.[worldKey as keyof typeof questionnaire.formattedAnswers] ?? [])
                .filter(answer => answer.isVisible !== false && (answer.answer || answer.displayText));

              if (answersForWorld.length === 0) return null;

              return (
                <SectionCard
                  key={worldKey}
                  title={worldConfig.label}
                  subtitle={worldConfig.description}
                  icon={worldConfig.icon}
                  variant="elegant"
                  gradient={worldConfig.gradient}
                >
                  <div className="grid grid-cols-1 gap-6">
                    {answersForWorld.map(answer => (
                      <QuestionnaireItem
                        key={answer.questionId}
                        answer={answer}
                        worldColor={worldConfig.accentColor}
                        worldGradient={worldConfig.gradient}
                      />
                    ))}
                  </div>
                </SectionCard>
              );
            })}
          </TabsContent>
        )}

        {/* Professional Tab - Matchmaker Info */}
        {viewMode === "matchmaker" && (
          <TabsContent value="professional" className="mt-0">
            <div className="text-center mb-8">
              <h2 className={cn(
                "text-3xl font-bold mb-4",
                "bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent"
              )}>
                מידע מקצועי לשדכן
              </h2>
              <p className="text-gray-600 text-lg">פרטים רגישים וחשובים לתהליך השידוך</p>
            </div>

            <SectionCard
              title="מידע סודי לשדכנים בלבד"
              subtitle="פרטים מקצועיים לתהליך השידוך"
              icon={Lock}
              variant="elegant"
              gradient={THEME.colors.primary.gold}
            >
              <div className={cn(
                "p-6 rounded-2xl border-2 border-amber-300/70",
                `bg-gradient-to-br ${THEME.colors.secondary.peach}`,
                THEME.shadows.elegant
              )}>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                  <DetailItem
                    icon={Phone}
                    label="העדפת יצירת קשר"
                    value={formatEnumValue(profile.contactPreference, contactPreferenceMap, "נגלה יחד").label}
                    variant="elegant"
                  />

                  <DetailItem
                    icon={Users}
                    label="העדפת מגדר שדכן/ית"
                    value={profile.preferredMatchmakerGender ?
                      (profile.preferredMatchmakerGender === "MALE" ? "שדכן גבר" : "שדכנית אישה") :
                      "אין העדפה מיוחדת"
                    }
                    variant="elegant"
                  />
                </div>

                {profile.matchingNotes && (
                  <div className="mt-6">
                    <h4 className="text-lg font-bold text-amber-700 mb-3 flex items-center gap-2">
                      <Edit3 className="w-5 h-5" />
                      הערות מיוחדות לשדכנים:
                    </h4>
                    <div className={cn(
                      "p-4 rounded-xl border border-amber-200/80",
                      "bg-amber-100/70 shadow-inner"
                    )}>
                      <p className="text-amber-800 whitespace-pre-wrap leading-relaxed font-medium">
                        {profile.matchingNotes}
                      </p>
                    </div>
                  </div>
                )}

                <div className={cn(
                  "mt-6 p-4 rounded-xl border border-indigo-200",
                  "bg-gradient-to-r from-indigo-100 to-purple-100"
                )}>
                  <h4 className="font-bold text-indigo-800 mb-3 flex items-center gap-2">
                    <Lightbulb className="w-5 h-5" />
                    תובנות מקצועיות:
                  </h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-indigo-700 text-sm">
                    <div className="flex items-center gap-2">
                      <Calendar className="w-4 h-4" />
                      <span>פרופיל נוצר: {profile.createdAt ? new Date(profile.createdAt).toLocaleDateString('he-IL') : 'לא ידוע'}</span>
                    </div>
                    {profile.lastActive && (
                      <div className="flex items-center gap-2">
                        <Clock className="w-4 h-4" />
                        <span>פעילות אחרונה: {new Date(profile.lastActive).toLocaleDateString('he-IL')}</span>
                      </div>
                    )}
                    <div className="flex items-center gap-2">
                      <CheckCircle className="w-4 h-4" />
                      <span>השלמת פרופיל: {profile.isProfileComplete ? 'מושלם ✅' : 'דורש השלמה ⚠️'}</span>
                    </div>
                    <div className="flex items-center gap-2">
                      <Heart className="w-4 h-4" />
                      <span>סטטוס זמינות: {availability.text}</span>
                    </div>
                  </div>
                </div>
              </div>
            </SectionCard>
          </TabsContent>
        )}
      </div>
    </Tabs>
  );

  // Enhanced Image Gallery for Mobile
  const MobileImageGallery = () => (
    orderedImages.length > 0 && (
      <div className={cn(
        "px-4 pt-4 pb-3",
        `bg-gradient-to-r ${THEME.colors.neutral.warm}`
      )}>
        <div className="text-center mb-4">
          <h3 className="text-lg font-bold text-gray-800 mb-1 flex items-center justify-center gap-2">
            <Camera className="w-5 h-5 text-rose-500" />
            הגלריה של {profile.user?.firstName || "המועמד"}
          </h3>
          <p className="text-sm text-gray-600">לחץ על תמונה להגדלה</p>
        </div>
        <ScrollArea dir="rtl" className="w-full whitespace-nowrap">
          <div className="flex gap-4 pb-3">
            {orderedImages.map((image, idx) => (
              <div
                key={image.id}
                className={cn(
                  "relative w-36 h-48 flex-shrink-0 rounded-2xl overflow-hidden cursor-pointer group",
                  "border-3 border-white shadow-lg hover:shadow-xl transition-all duration-300 hover:scale-105"
                )}
                onClick={() => handleOpenImageDialog(image)}
              >
                <Image
                  src={image.url}
                  alt={`תמונה מדהימה ${idx + 1}`}
                  fill
                  className="object-cover transition-transform duration-500 group-hover:scale-110"
                  sizes="144px"
                />
                <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent"></div>

                {image.isMain && (
                  <Badge className={cn(
                    "absolute top-2 right-2 text-[10px] font-bold gap-1 px-2 py-1",
                    "bg-gradient-to-r from-yellow-400 to-amber-500 text-black",
                    THEME.shadows.warm
                  )}>
                    <Star className="w-2.5 h-2.5 fill-current" />
                    ראשי
                  </Badge>
                )}

                <div className="absolute bottom-2 left-2 right-2 text-center">
                  <p className="text-white text-xs font-medium drop-shadow-lg">
                    תמונה {idx + 1}
                  </p>
                </div>
              </div>
            ))}
          </div>
          <ScrollBar orientation="horizontal" />
        </ScrollArea>
      </div>
    )
  );

  // Mobile Header with Enhanced Toggle
  const MobileHeader = () => (
    <div className={cn(
      "p-3 flex-shrink-0 flex justify-center items-center border-b border-rose-200/50",
      `bg-gradient-to-r ${THEME.colors.neutral.warm}`,
      "sticky top-0 z-30 backdrop-blur-md"
    )}>
      <ToggleGroup
        type="single"
        value={mobileViewLayout}
        onValueChange={(value: 'focus' | 'detailed') => { if (value) setMobileViewLayout(value); }}
        className={cn(
          "bg-white/95 backdrop-blur-sm rounded-2xl border border-rose-200/50 p-1",
          THEME.shadows.soft
        )}
      >
        <ToggleGroupItem
          value="focus"
          aria-label="Focus view"
          className={cn(
            "rounded-xl px-4 py-2 transition-all duration-300",
            "data-[state=on]:bg-gradient-to-r data-[state=on]:from-rose-500 data-[state=on]:to-pink-500",
            "data-[state=on]:text-white data-[state=on]:shadow-md"
          )}
        >
          <Heart className="h-4 w-4" />
          <span className="mr-2 text-sm font-medium">היכרות</span>
        </ToggleGroupItem>
        <ToggleGroupItem
          value="detailed"
          aria-label="Detailed view"
          className={cn(
            "rounded-xl px-4 py-2 transition-all duration-300",
            "data-[state=on]:bg-gradient-to-r data-[state=on]:from-purple-500 data-[state=on]:to-indigo-500",
            "data-[state=on]:text-white data-[state=on]:shadow-md"
          )}
        >
          <FileText className="h-4 w-4" />
          <span className="mr-2 text-sm font-medium">מפורט</span>
        </ToggleGroupItem>
      </ToggleGroup>
    </div>
  );

  // Enhanced Mobile Layouts
  const DetailedMobileLayout = () => (
    <div className="flex-1 min-h-0 overflow-y-auto">
      <ProfileHeader
        profile={profile}
        age={age}
        mainImageToDisplay={mainImageToDisplay}
        availability={availability}
        viewMode={viewMode}
        onSuggestClick={() => setIsSuggestDialogOpen(true)}
        isMobile={true}
          selectedPalette={selectedPalette}
      />
      <MobileImageGallery />
      <div className={cn("p-4", `bg-gradient-to-br ${THEME.colors.neutral.cool}`)}>
        <MainContentTabs />
      </div>
    </div>
  );

  const FocusMobileLayout = () => (
    <div className="flex-1 min-h-0 overflow-y-auto">
      <ProfileHeader
        profile={profile}
        age={age}
        mainImageToDisplay={mainImageToDisplay}
        availability={availability}
        viewMode={viewMode}
        onSuggestClick={() => setIsSuggestDialogOpen(true)}
        isMobile={true}
          selectedPalette={selectedPalette}
      />
      <MobileImageGallery />

      <div className={cn("p-4 space-y-6", `bg-gradient-to-br ${THEME.colors.neutral.warm}`)}>
        
        {profile.about ? (
          <SectionCard 
            title="קצת עליי" 
            icon={Heart} 
            variant="romantic"
            gradient={THEME.colors.primary.main}
          >
            <div className={cn(
              "p-4 rounded-xl border border-rose-200/50",
              `bg-gradient-to-r ${THEME.colors.neutral.warm}`
            )}>
              <p className="text-gray-800 leading-relaxed italic font-medium">
                <Quote className="w-4 h-4 inline ml-1 text-rose-400" />
                {profile.about}
                <Quote className="w-4 h-4 inline mr-1 text-rose-400 transform rotate-180" />
              </p>
            </div>
          </SectionCard>
        ) : (
          <SectionCard 
            title="הסיפור שלי" 
            icon={Telescope} 
            variant="romantic"
          >
            <EmptyState
              icon={Telescope}
              title="יש כאן הרבה לגלות!"
              description="הסיפור האישי מחכה להיכתב יחד איתך..."
              variant="romantic"
            />
          </SectionCard>
        )}

        <SectionCard 
          title="תמצית מהירה" 
          icon={Zap} 
          variant="elegant"
          gradient={THEME.colors.primary.gold}
        >
          <div className="grid grid-cols-2 gap-4">
            <DetailItem
              icon={BookMarked}
              label="השקפה"
              value={formatEnumValue(profile.religiousLevel, religiousLevelMap).label}
              variant="elegant"
              size="sm"
            />
            <DetailItem
              icon={Heart}
              label="שמירת נגיעה"
              value={formatBooleanPreference(profile.shomerNegiah).label}
              variant="elegant"
              size="sm"
            />
            <DetailItem
              icon={Briefcase}
              label="עיסוק"
              value={profile.occupation || "נגלה יחד"}
              variant="elegant"
              size="sm"
            />
            <DetailItem
              icon={GraduationCap}
              label="השכלה"
              value={formatEnumValue(profile.educationLevel, educationLevelMap).label}
              variant="elegant"
              size="sm"
            />
          </div>
        </SectionCard>

        {(profile.profileCharacterTraits?.length > 0 || profile.profileHobbies?.length > 0) && (
          <SectionCard 
            title="מה מיוחד בי" 
            icon={Sparkles} 
            variant="romantic"
            gradient={THEME.colors.primary.romantic}
          >
            <div className="space-y-5">
              {profile.profileCharacterTraits?.length > 0 && (
                <div>
                  <h4 className="text-sm font-bold text-purple-700 mb-3 flex items-center gap-2">
                    <Sparkles className="w-4 h-4" />
                    התכונות שלי:
                  </h4>
                  <div className="flex flex-wrap gap-2">
                    {profile.profileCharacterTraits.slice(0, 4).map(trait => {
                      const traitData = formatEnumValue(trait, characterTraitMap, trait);
                      return (
                        <Badge
                          key={trait}
                          className={cn(
                            "flex items-center gap-1 px-3 py-1 text-xs font-semibold",
                            "bg-gradient-to-r from-purple-100 to-violet-100 text-purple-800",
                            "border border-purple-200 rounded-full"
                          )}
                        >
                          <traitData.icon className="w-3 h-3" />
                          {traitData.label}
                        </Badge>
                      );
                    })}
                  </div>
                </div>
              )}

              {profile.profileHobbies?.length > 0 && (
                <div>
                  <h4 className="text-sm font-bold text-emerald-700 mb-3 flex items-center gap-2">
                    <Heart className="w-4 h-4" />
                    מה אני אוהב/ת:
                  </h4>
                  <div className="flex flex-wrap gap-2">
                    {profile.profileHobbies.slice(0, 4).map(hobby => {
                      const hobbyData = formatEnumValue(hobby, hobbiesMap, hobby);
                      return (
                        <Badge
                          key={hobby}
                          className={cn(
                            "flex items-center gap-1 px-3 py-1 text-xs font-semibold",
                            "bg-gradient-to-r from-emerald-100 to-green-100 text-emerald-800",
                            "border border-emerald-200 rounded-full"
                          )}
                        >
                          <hobbyData.icon className="w-3 h-3" />
                          {hobbyData.label}
                        </Badge>
                      );
                    })}
                  </div>
                </div>
              )}
            </div>
          </SectionCard>
        )}

        <SectionCard 
          title="מה אני מחפש/ת" 
          icon={Target} 
          variant="highlight"
          gradient={THEME.colors.secondary.sky}
        >
          {profile.matchingNotes ? (
            <div className={cn(
              "p-4 rounded-xl border border-blue-200/50",
              "bg-gradient-to-r from-blue-50 to-cyan-50"
            )}>
              <p className="text-blue-700 leading-relaxed italic font-medium">
                <Quote className="w-4 h-4 inline ml-1 text-blue-400" />
                {profile.matchingNotes}
                <Quote className="w-4 h-4 inline mr-1 text-blue-400 transform rotate-180" />
              </p>
            </div>
          ) : (
            <EmptyState
              icon={Heart}
              title="החלום שלי לזוגיות עדיין נכתב..."
              description="אבל בטוח שנגלה יחד מה מתאים לנו!"
              variant="adventure"
            />
          )}

          {(profile.preferredAgeMin || profile.preferredAgeMax) && (
            <div className="mt-5">
              <DetailItem
                icon={Calendar}
                label="טווח גילאים מועדף"
                value={`${profile.preferredAgeMin || '?'} - ${profile.preferredAgeMax || '?'} שנים`}
                variant="elegant"
                size="sm"
              />
            </div>
          )}
        </SectionCard>

        <div className={cn(
          "text-center p-6 rounded-2xl text-white",
          `bg-gradient-to-r ${THEME.colors.primary.main}`,
          THEME.shadows.elegant
        )}>
          <h3 className="text-xl font-bold mb-3">רוצים לדעת עוד?</h3>
          <p className="mb-4 opacity-90">עוד המון דברים מעניינים מחכים לגילוי...</p>
          <Button
            onClick={() => setMobileViewLayout('detailed')}
            className={cn(
              "bg-white text-gray-600 hover:bg-gray-50 font-bold px-6 py-3 rounded-full",
              THEME.shadows.warm
            )}
          >
            <Eye className="w-5 h-5 ml-2" />
            בואו נכיר לעומק
          </Button>
        </div>
      </div>
    </div>
  );

  if (!isClient) {
    return (
      <Card dir="rtl" className={cn(
        "w-full bg-white shadow-2xl rounded-2xl overflow-hidden border-0 flex flex-col h-full",
        className
      )}>
        <div className={cn(
          "p-6 border-b border-gray-200/80",
          `bg-gradient-to-r ${THEME.colors.neutral.warm}`
        )}>
          <div className="flex flex-col sm:flex-row items-center sm:items-start gap-6">
            <Skeleton className="h-36 w-36 rounded-full flex-shrink-0" />
            <div className="flex-grow w-full space-y-4">
              <Skeleton className="h-12 w-3/4" />
              <Skeleton className="h-6 w-1/2" />
              <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 mt-4">
                <Skeleton className="h-12 w-full rounded-xl" />
                <Skeleton className="h-12 w-full rounded-xl" />
                <Skeleton className="h-12 w-full rounded-xl" />
              </div>
            </div>
          </div>
        </div>
        <div className="p-6 flex-grow">
          <div className="space-y-4">
            <Skeleton className="h-8 w-full rounded-xl" />
            <Skeleton className="h-32 w-full rounded-xl" />
            <Skeleton className="h-24 w-full rounded-xl" />
          </div>
        </div>
      </Card>
    );
  }

  return (
    <TooltipProvider>
      <Card
        dir="rtl"
        id="profile-card-container"
        className={cn(
          "w-full shadow-2xl rounded-2xl overflow-hidden border-0 flex flex-col max-h-[calc(100vh-2rem)] h-full relative",
          `bg-gradient-to-br ${THEME.colors.neutral.elegant}`,
          THEME.shadows.elegant,
          className
        )}
      >
        <Tooltip>
            <TooltipTrigger asChild>
                <Button 
                    variant="ghost" 
                    size="icon" 
                    className="absolute top-2 right-2 z-50 text-gray-500 hover:text-gray-800 hover:bg-white/50 rounded-full"
                    onClick={handleToggleFullscreen}
                >
                    {isFullscreen ? <Minimize className="w-5 h-5" /> : <Maximize className="w-5 h-5" />}
                </Button>
            </TooltipTrigger>
            <TooltipContent>
                <p>{isFullscreen ? 'צא ממסך מלא' : 'הצג במסך מלא'}</p>
            </TooltipContent>
        </Tooltip>

        {isDesktop ? (
          <ResizablePanelGroup direction="horizontal" dir="rtl" className="flex-grow min-h-0">
            <ResizablePanel defaultSize={60} minSize={40} className="min-w-0 flex flex-col">
              <ProfileHeader
                profile={profile}
                age={age}
                mainImageToDisplay={mainImageToDisplay}
                availability={availability}
                viewMode={viewMode}
                onSuggestClick={() => setIsSuggestDialogOpen(true)}
                selectedPalette={selectedPalette}
              />
              <ScrollArea className="flex-grow min-h-0">
                <div className="p-6">
                  <MainContentTabs />
                </div>
              </ScrollArea>
            </ResizablePanel>

            <ResizableHandle withHandle className={cn(
              "bg-gradient-to-b from-rose-200 to-pink-200 hover:from-rose-300 hover:to-pink-300",
              "transition-all duration-300"
            )} />

            <ResizablePanel defaultSize={40} minSize={25} className="min-w-0 flex flex-col">
              <ScrollArea className="flex-grow min-h-0">
                <div className="p-6 space-y-6">
                  
                  <SectionCard
                    title="הגלריה האישית"
                    subtitle="התמונות שמספרות את הסיפור"
                    icon={Camera}
                    variant="romantic"
                    gradient={THEME.colors.primary.rose}
                  >
                    {orderedImages.length > 0 ? (
                      <div className="space-y-4">
                        <div
                          className={cn(
                            "relative aspect-video rounded-2xl overflow-hidden cursor-pointer group",
                            "border-3 border-white shadow-lg hover:shadow-xl transition-all duration-300"
                          )}
                          onClick={() => handleOpenImageDialog(orderedImages[0])}
                        >
                          <Image
                            src={orderedImages[0].url}
                            alt="תמונה ראשית מדהימה"
                            fill
                            className="object-cover transition-transform duration-500 group-hover:scale-105"
                            sizes="35vw"
                            priority
                          />
                          <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                            <div className="text-center text-white">
                              <Eye className="w-8 h-8 mx-auto mb-2" />
                              <p className="font-bold">לחץ להגדלה</p>
                            </div>
                          </div>
                        </div>

                        {orderedImages.length > 1 && (
                          <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                            {orderedImages.slice(1, 7).map(img => (
                              <div
                                key={img.id}
                                className={cn(
                                  "relative aspect-square rounded-xl overflow-hidden cursor-pointer",
                                  "border-2 border-transparent hover:border-rose-400 transition-all duration-300",
                                  "shadow-md hover:shadow-lg"
                                )}
                                onClick={() => handleOpenImageDialog(img)}
                              >
                                <Image
                                  src={img.url}
                                  alt="תמונת פרופיל נוספת"
                                  fill
                                  className="object-cover hover:scale-110 transition-transform duration-300"
                                  sizes="15vw"
                                />
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    ) : (
                      <EmptyState
                        icon={Camera}
                        title="התמונות בדרך אלינו..."
                        description="הגלריה האישית מחכה להיחשף"
                        variant="romantic"
                      />
                    )}
                  </SectionCard>

                  <SectionCard
                    title="הנקודות החמות"
                    subtitle="מה שחשוב לדעת ברגע הראשון"
                    icon={Flame}
                    variant="highlight"
                    gradient={THEME.colors.primary.gold}
                  >
                    <div className="space-y-4">
                      <DetailItem
                        icon={BookMarked}
                        label="השקפת עולם"
                        value={formatEnumValue(profile.religiousLevel, religiousLevelMap).label}
                        variant="highlight"
                      />
                      <DetailItem
                        icon={Heart}
                        label="שמירת נגיעה"
                        value={formatBooleanPreference(profile.shomerNegiah).label}
                        variant="elegant"
                      />
                      <DetailItem
                        icon={Briefcase}
                        label="התחום המקצועי"
                        value={profile.occupation || "מקצוע מעניין מחכה לגילוי"}
                        variant="elegant"
                      />
                      <DetailItem
                        icon={GraduationCap}
                        label="רמת השכלה"
                        value={formatEnumValue(profile.educationLevel, educationLevelMap).label}
                        variant="elegant"
                      />
                      <DetailItem
                        icon={MapPin}
                        label="מיקום"
                        value={profile.city || "איפה שהלב נמצא"}
                        variant="elegant"
                      />

                      {profile.maritalStatus && ["divorced", "widowed", "annulled"].includes(profile.maritalStatus) && (
                        <DetailItem
                          icon={Baby}
                          label="ילדים מקשר קודם"
                          value={formatBooleanPreference(
                            profile.hasChildrenFromPrevious, 
                            "יש ילדים יקרים", 
                            "אין ילדים", 
                            "נגלה יחד"
                          ).label}
                          variant="elegant"
                        />
                      )}
                    </div>
                  </SectionCard>

                  <SectionCard
                    title="הסיפור שמאחורי הפרופיל"
                    subtitle="מילים מהלב"
                    icon={Quote}
                    variant="romantic"
                    gradient={THEME.colors.primary.romantic}
                  >
                    {profile.about ? (
                      <div className={cn(
                        "p-4 rounded-xl border border-rose-200/50 shadow-inner",
                        `bg-gradient-to-r ${THEME.colors.neutral.warm}`
                      )}>
                        <Quote className="w-6 h-6 text-rose-400 mb-2" />
                        <p className="text-gray-800 leading-relaxed italic font-medium">
                          {profile.about}
                        </p>
                      </div>
                    ) : (
                      <EmptyState
                        icon={Telescope}
                        title="הסיפור מחכה להיכתב..."
                        description="יש כאן אדם מעניין שמחכה לגילוי!"
                        variant="discovery"
                      />
                    )}
                  </SectionCard>

                  <SectionCard
                    title="החלום לזוגיות"
                    subtitle="מה מחכה למי שיבוא"
                    icon={Target}
                    variant="highlight"
                    gradient={THEME.colors.secondary.sky}
                  >
                    {profile.matchingNotes ? (
                      <div className={cn(
                        "p-4 rounded-xl border border-blue-200/50 shadow-inner",
                        "bg-gradient-to-r from-blue-50 to-cyan-50"
                      )}>
                        <Heart className="w-6 h-6 text-blue-400 mb-2" />
                        <p className="text-blue-700 leading-relaxed italic font-medium">
                          {profile.matchingNotes}
                        </p>
                      </div>
                    ) : (
                      <EmptyState
                        icon={Heart}
                        title="החלום עדיין לא נכתב..."
                        description="אבל בטוח שזה יהיה משהו יפה!"
                        variant="adventure"
                      />
                    )}

                    <div className="mt-4 space-y-3">
                      {(profile.preferredAgeMin || profile.preferredAgeMax) && (
                        <DetailItem
                          icon={Calendar}
                          label="טווח גילאים מועדף"
                          value={`${profile.preferredAgeMin || '?'} - ${profile.preferredAgeMax || '?'} שנים`}
                          variant="elegant"
                        />
                      )}

                      {profile.preferredReligiousLevels && profile.preferredReligiousLevels.length > 0 && (
                        <div>
                          <p className="text-sm font-bold text-indigo-700 mb-2 flex items-center gap-2">
                            <BookMarked className="w-4 h-4" />
                            רמות דתיות מועדפות:
                          </p>
                          <div className="flex flex-wrap gap-2">
                            {profile.preferredReligiousLevels.slice(0, 3).map(level => {
                              const levelData = formatEnumValue(level, religiousLevelMap, level);
                              return (
                                <Badge
                                  key={level}
                                  className={cn(
                                    "flex items-center gap-1 text-xs px-2 py-1 font-semibold rounded-full",
                                    "bg-gradient-to-r from-indigo-100 to-purple-100 text-indigo-800",
                                    "border border-indigo-200"
                                  )}
                                >
                                  <levelData.icon className="w-3 h-3" />
                                  {levelData.label}
                                </Badge>
                              );
                            })}
                          </div>
                        </div>
                      )}
                    </div>
                  </SectionCard>
                </div>
              </ScrollArea>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          <div className="flex flex-col h-full w-full">
            <MobileHeader />
            {mobileViewLayout === 'detailed' ? <DetailedMobileLayout /> : <FocusMobileLayout />}
          </div>
        )}

        {selectedImageForDialog && (
          <Dialog open={!!selectedImageForDialog} onOpenChange={isOpen => !isOpen && handleCloseImageDialog()}>
            <DialogContent className={cn(
              "max-w-5xl w-[95vw] h-[90vh] p-0 border-none rounded-2xl flex flex-col",
              "bg-black/95 backdrop-blur-md"
            )} dir="rtl">
              <DialogHeader className={cn(
                "p-4 text-white flex-row justify-between items-center border-b border-gray-700/50",
                "bg-black/80 backdrop-blur-sm"
              )}>
                <DialogTitle className="text-lg font-bold flex items-center gap-2">
                  <Camera className="w-5 h-5" />
                  תמונה {currentDialogImageIndex + 1} מתוך {orderedImages.length}
                </DialogTitle>
                <Button
                  variant="ghost"
                  size="icon"
                  className="text-gray-300 hover:text-white hover:bg-white/10 rounded-full transition-all"
                  onClick={handleCloseImageDialog}
                >
                  <X className="w-5 h-5" />
                </Button>
              </DialogHeader>

              <div className="relative flex-1 w-full min-h-0">
                <Image
                  key={selectedImageForDialog.id}
                  src={selectedImageForDialog.url}
                  alt={`תמונה מוגדלת ${currentDialogImageIndex + 1}`}
                  fill
                  className="object-contain"
                  sizes="90vw"
                  priority
                />

                {orderedImages.length > 1 && (
                  <>
                    <Button
                      variant="ghost"
                      size="icon"
                      className={cn(
                        "absolute right-4 top-1/2 -translate-y-1/2 h-14 w-14 rounded-full",
                        "bg-black/50 hover:bg-black/70 text-white border border-white/20",
                        "backdrop-blur-sm transition-all hover:scale-110"
                      )}
                      onClick={() => handleDialogNav("prev")}
                    >
                      <ChevronRight className="h-6 w-6" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      className={cn(
                        "absolute left-4 top-1/2 -translate-y-1/2 h-14 w-14 rounded-full",
                        "bg-black/50 hover:bg-black/70 text-white border border-white/20",
                        "backdrop-blur-sm transition-all hover:scale-110"
                      )}
                      onClick={() => handleDialogNav("next")}
                    >
                      <ChevronLeft className="h-6 w-6" />
                    </Button>
                  </>
                )}
              </div>

              {orderedImages.length > 1 && (
                <DialogFooter className="border-t border-gray-700/50 bg-black/80 backdrop-blur-sm p-0">
                  <ScrollArea dir="rtl" className="w-full">
                    <div className="flex gap-2 p-3 justify-center">
                      {orderedImages.map(img => (
                        <div
                          key={img.id}
                          className={cn(
                            "relative flex-shrink-0 w-16 h-16 rounded-lg overflow-hidden cursor-pointer",
                            "border-2 transition-all hover:scale-105",
                            img.id === selectedImageForDialog.id
                              ? "border-rose-400 ring-2 ring-rose-400/50"
                              : "border-white/20 opacity-60 hover:opacity-100 hover:border-white/40"
                          )}
                          onClick={() => setSelectedImageForDialog(img)}
                        >
                          <Image
                            src={img.url}
                            alt="תמונה קטנה"
                            fill
                            className="object-cover"
                            sizes="64px"
                          />
                        </div>
                      ))}
                    </div>
                    <ScrollBar orientation="horizontal" />
                  </ScrollArea>
                </DialogFooter>
              )}
            </DialogContent>
          </Dialog>
        )}

        {viewMode === 'matchmaker' && candidate && (
          <NewSuggestionForm
            isOpen={isSuggestDialogOpen}
            onClose={() => setIsSuggestDialogOpen(false)}
            candidates={allCandidates}
            selectedCandidate={candidate}
            onSubmit={handleCreateSuggestion}
          />
        )}
      </Card>
    </TooltipProvider>
  );
};

export default ProfileCard;
--- End of Content for ProfileCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\constants.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/constants.ts
import { Heart, User, Users, Scroll, GraduationCap, MapPin } from "lucide-react";

export const WORLDS = {
  values: {
    key: "values",
    title: "ערכים ואמונות",
    icon: Heart,
    color: "text-pink-500",
    bgColor: "bg-pink-50",
    borderColor: "border-pink-200",
  },
  personality: {
    key: "personality",
    title: "אישיות",
    icon: User,
    color: "text-blue-500",
    bgColor: "bg-blue-50",
    borderColor: "border-blue-200",
  },
  relationship: {
    key: "relationship",
    title: "זוגיות ומשפחה",
    icon: Users,
    color: "text-purple-500",
    bgColor: "bg-purple-50",
    borderColor: "border-purple-200",
  },
  religion: {
    key: "religion",
    title: "דת ומסורת",
    icon: Scroll,
    color: "text-indigo-500",
    bgColor: "bg-indigo-50",
    borderColor: "border-indigo-200",
  },
  partner: {
    key: "partner",
    title: "העדפות בן/בת זוג",
    icon: Heart,
    color: "text-red-500",
    bgColor: "bg-red-50",
    borderColor: "border-red-200",
  },
} as const;

export const RELIGIOUS_LEVELS = [
  "חרדי",
  "חרדי מודרני",
  "דתי",
  "דתי-לייט",
  "מסורתי"
] as const;

export const MARITAL_STATUS = [
  "single",
  "divorced",
  "widowed"
] as const;

export const EDUCATION_LEVELS = [
  "תיכונית",
  "על תיכונית",
  "אקדמית",
  "תורנית"
] as const;

export const OCCUPATION_TYPES = [
  "עובד/ת",
  "סטודנט/ית",
  "אברך/אברכית",
  "עצמאי/ת"
] as const;

export const LOCATIONS = [
  "צפון",
  "מרכז",
  "דרום",
  "ירושלים",
  "יהודה ושומרון"
] as const;

export const PROFILE_SECTIONS = {
  BASIC_INFO: {
    title: "פרטים אישיים",
    icon: User,
  },
  EDUCATION: {
    title: "השכלה ותעסוקה",
    icon: GraduationCap,
  },
  LOCATION: {
    title: "מיקום",
    icon: MapPin,
  },
  FAMILY: {
    title: "מידע משפחתי",
    icon: Users,
  },
  PREFERENCES: {
    title: "העדפות",
    icon: Heart,
  },
} as const;

export const COMMUNICATION_STYLES = [
  "ישיר",
  "עקיף",
  "דיפלומטי"
] as const;

export const STRESS_MANAGEMENT = [
  "רגוע",
  "לחוץ",
  "משתנה"
] as const;

export const CONTACT_PREFERENCES = [
  { value: "direct", label: "ישירות" },
  { value: "matchmaker", label: "דרך השדכן/ית" },
  { value: "both", label: "שתי האפשרויות" }
] as const;

// הגדרות עבור הוולידציה
export const VALIDATION_RULES = {
  AGE: {
    MIN: 18,
    MAX: 99
  },
  HEIGHT: {
    MIN: 100,
    MAX: 250
  },
  NAME: {
    MIN_LENGTH: 2,
    MAX_LENGTH: 50
  }
} as const;
--- End of Content for constants.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\index.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/index.ts

// Main Components
export { default as ProfileCard } from './ProfileCard';

// Sections
export { default as PhotosSection } from './sections/PhotosSection';
export { default as PreferencesSection } from './sections/PreferencesSection';
export { default as ProfileSection } from './sections/ProfileSection';
export { default as QuestionnaireResponsesSection } from './sections/QuestionnaireResponsesSection';

// Elements
export { default as StatsCard } from './elements/StatsCard';
export { default as VisibilityControl } from './elements/VisibilityControl';
export { default as MinimalCard } from './elements/MinimalCard';

// Types
export * from './types/profile';
export * from './types/questionnaire';
--- End of Content for index.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\utils.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/utils.ts
import type { UserProfile } from "@/types/next-auth";

export const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const formatProfileData = (profile: UserProfile) => {
  return {
    ...profile,
    age: calculateAge(new Date(profile.birthDate)),
    // Add any other formatting needed
  };
};

export const validateProfileData = (data: Partial<UserProfile>) => {
  const errors: Record<string, string> = {};
  
  // Add validation rules as needed
  if (data.height && (data.height < 100 || data.height > 250)) {
    errors.height = "גובה חייב להיות בין 100 ל-250 ס\"מ";
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};
--- End of Content for utils.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements\MinimalCard.tsx
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/elements/MinimalCard.tsx
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { User, MapPin, Scroll, Heart } from "lucide-react";
import Image from "next/image";
import { calculateAge } from "../utils";
import type { UserProfile, UserImage } from "@/types/next-auth";

interface MinimalCardProps {
  profile: UserProfile;
  mainImage?: UserImage;
  onClick?: () => void;
  className?: string;
}

const MinimalCard: React.FC<MinimalCardProps> = ({
  profile,
  mainImage,
  onClick,
  className = "",
}) => {
  const age = calculateAge(new Date(profile.birthDate));

  // Handle cases where profile.user might be undefined
  const userName = profile.user
    ? `${profile.user.firstName} ${profile.user.lastName}`
    : "שם לא זמין"; // "Name not available" in Hebrew

  return (
    <Card
      onClick={onClick}
      className={`relative overflow-hidden cursor-pointer hover:shadow-md transition-shadow ${className}`}
    >
      <div className="flex gap-4 p-4">
        {/* תמונת פרופיל */}
        <div className="relative w-24 h-24 rounded-lg overflow-hidden bg-gray-100">
          {mainImage ? (
            <Image
              src={mainImage.url}
              alt="תמונת פרופיל"
              fill
              className="object-cover"
              sizes="96px"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <User className="w-8 h-8 text-gray-400" />
            </div>
          )}
        </div>

        {/* מידע בסיסי */}
        <div className="flex-1 space-y-2">
          <div>
            <h3 className="text-lg font-medium">{userName}</h3>
            <p className="text-sm text-gray-500">{age} שנים</p>
          </div>

          <div className="flex flex-wrap gap-2">
            {profile.city && (
              <Badge variant="secondary" className="flex items-center gap-1">
                <MapPin className="w-3 h-3" />
                {profile.city}
              </Badge>
            )}
            {profile.religiousLevel && (
              <Badge variant="secondary" className="flex items-center gap-1">
                <Scroll className="w-3 h-3" />
                {profile.religiousLevel}
              </Badge>
            )}
          </div>

          {/* סטטוס זמינות */}
          <div className="flex items-center gap-2 text-sm">
            {profile.availabilityStatus === "AVAILABLE" ? (
              <Badge variant="success" className="flex items-center gap-1">
                <Heart className="w-3 h-3" />
                פנוי/ה להצעות
              </Badge>
            ) : (
              <Badge variant="secondary" className="flex items-center gap-1">
                <Heart className="w-3 h-3" />
                בתהליך הכרות
              </Badge>
            )}
          </div>
        </div>
      </div>
    </Card>
  );
};

export default MinimalCard;
--- End of Content for MinimalCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements\StatsCard.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  /**
   * The icon to display in the card
   */
  icon: React.ElementType;

  /**
   * The title text to display
   */
  title: string;

  /**
   * The main value to display
   */
  value: string | number;

  /**
   * Optional progress value (0-100)
   */
  progress?: number;

  /**
   * Optional trend information
   */
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };

  /**
   * Visual variant of the card
   */
  variant?: "default" | "success" | "warning" | "destructive";

  /**
   * Additional CSS classes
   */
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  progress,
  trend,
  variant = "default",
  className,
}) => {
  // Determine variant-specific background color
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "bg-emerald-50 dark:bg-emerald-900/20";
      case "warning":
        return "bg-amber-50 dark:bg-amber-900/20";
      case "destructive":
        return "bg-red-50 dark:bg-red-900/20";
      default:
        return "bg-card";
    }
  };

  // Special handling for availability status
  const isAvailabilityStatus = title === "סטטוס פניות";
  const isAvailable = typeof value === 'string' && value.toLowerCase() === 'available';

  // Render the value with special handling for availability status
  const renderValue = () => {
    if (isAvailabilityStatus) {
      return (
        <div className="mt-1">
          <span className={cn(
            "inline-flex px-3 py-1 rounded-full text-sm font-semibold tracking-wide",
            isAvailable 
              ? "bg-emerald-100 text-emerald-800 dark:bg-emerald-900/30 dark:text-emerald-300"
              : "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
          )}>
            {value}
          </span>
        </div>
      );
    }
    return <h3 className="text-2xl font-semibold">{value}</h3>;
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-shadow",
        getVariantStyles(),
        className
      )}
    >
      <CardContent className="p-6">
        {/* Header Section */}
        <div className="flex items-center space-x-4 rtl:space-x-reverse">
          <div className="p-2 bg-primary/10 rounded-full">
            <Icon className="w-6 h-6 text-primary" />
          </div>
          <div className="flex-1 space-y-1">
            <p className="text-sm text-muted-foreground">{title}</p>
            {renderValue()}
          </div>
        </div>

        {/* Progress Bar Section */}
        {progress !== undefined && (
          <div className="mt-4 space-y-2">
            <Progress 
              value={progress} 
              className="h-2"
              aria-label={`${title} progress: ${progress}%`}
            />
            <p className="text-sm text-muted-foreground text-right">
              {progress}%
            </p>
          </div>
        )}

        {/* Trend Section */}
        {trend && (
          <div className="mt-4 flex items-center">
            <span
              className={cn(
                "text-sm font-medium",
                trend.isPositive ? "text-emerald-600" : "text-red-600"
              )}
            >
              {trend.isPositive ? "+" : "-"}
              {trend.value}%
            </span>
            <span className="text-sm text-muted-foreground mr-2">
              {trend.label}
            </span>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

// Default export
export default StatsCard;

// Named exports for specific use cases
export type { StatsCardProps };
--- End of Content for StatsCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements\VisibilityControl.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Eye, EyeOff } from "lucide-react";
import { Switch } from "@/components/ui/switch";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

interface VisibilityControlProps {
  /**
   * Current visibility state
   */
  isVisible: boolean;

  /**
   * Callback when visibility changes
   */
  onChange: (isVisible: boolean) => void;

  /**
   * Optional class name for additional styling
   */
  className?: string;

  /**
   * Optional disabled state
   */
  disabled?: boolean;

  /**
   * Optional custom tooltip text
   */
  tooltipText?: {
    visible?: string;
    hidden?: string;
    action?: string;
  };
}

const VisibilityControl: React.FC<VisibilityControlProps> = ({
  isVisible,
  onChange,
  className,
  disabled = false,
  tooltipText = {
    visible: "תשובה זו גלויה למועמדים",
    hidden: "תשובה זו מוסתרת מהמועמדים",
    action: "לחץ כדי",
  },
}) => {
  return (
    <div
      className={cn(
        "flex items-center gap-2 bg-secondary/20 p-2 rounded-md",
        disabled && "opacity-50 cursor-not-allowed",
        className
      )}
    >
      {/* Icon */}
      {isVisible ? (
        <Eye 
          className="h-4 w-4 text-primary" 
          aria-hidden="true"
        />
      ) : (
        <EyeOff 
          className="h-4 w-4 text-muted-foreground" 
          aria-hidden="true"
        />
      )}

      {/* Switch with Tooltip */}
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="relative">
              <Switch
                checked={isVisible}
                onCheckedChange={onChange}
                disabled={disabled}
                className={cn(
                  "data-[state=checked]:bg-primary",
                  disabled && "cursor-not-allowed"
                )}
                aria-label={`Toggle visibility: currently ${isVisible ? 'visible' : 'hidden'}`}
              />
              {/* Visually hidden text for screen readers */}
              <span className="sr-only">
                {isVisible ? "הסתר תוכן" : "הצג תוכן"}
              </span>
            </div>
          </TooltipTrigger>
          <TooltipContent 
            side="left" 
            className="max-w-[200px]"
            dir="rtl"
          >
            <p>
              {isVisible ? tooltipText.visible : tooltipText.hidden}
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              {tooltipText.action} {isVisible ? "להסתיר" : "להציג"} תשובה זו
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  );
};

// Default export
export default VisibilityControl;

// Named exports for types
export type { VisibilityControlProps };
--- End of Content for VisibilityControl.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\PhotosSection.tsx
--------------------------------------------------------------------------------
Content:

"use client";

import React, { useRef, useState, useEffect, useCallback } from "react"; // Added useCallback
import Image from "next/image";
import { cn } from "@/lib/utils";

// UI Components
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogDescription,
  DialogHeader,
  DialogFooter, // Added DialogFooter
} from "@/components/ui/dialog"; // Removed Card components as we use divs/structure directly now for more control

import { toast } from "sonner";

// Icons
import {
  Camera,
  Star,
  Loader2,
  ChevronLeft,
  ChevronRight,
  Upload,
  Trash2,
  X, // Icon for closing dialog
} from "lucide-react";

// Types
import type { UserImage } from "@/types/next-auth";

interface PhotosSectionProps {
  images: UserImage[];
  isUploading: boolean; // Note: Changed interpretation, this prop seems external loading state, use internal `isProcessing` for actions within component
  disabled?: boolean;
  maxImages?: number;
  onUpload: (file: File) => Promise<void>;
  onSetMain: (imageId: string) => Promise<void>;
  onDelete: (imageId: string) => Promise<void>;
  // Removed style props as per previous fix request and current design goals
}

const PhotosSection: React.FC<PhotosSectionProps> = ({
  images,
  isUploading: isExternallyUploading, // Renamed to avoid confusion with internal processing state
  disabled = false,
  maxImages = 5,
  onUpload,
  onSetMain,
  onDelete,
}) => {
  // Refs
  const fileInputRef = useRef<HTMLInputElement>(null);

  // State
  const [showImageViewer, setShowImageViewer] = useState(false);
  const [selectedViewerIndex, setSelectedViewerIndex] = useState<number | null>(null);
  const [isProcessing, setIsProcessing] = useState(false); // Internal state for actions like delete, set main
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [imageToDelete, setImageToDelete] = useState<string | null>(null);
  const [lastUploadedImageId, setLastUploadedImageId] = useState<string | null>(null); // Track ID instead of index

  // Combined Loading State
  const isLoading = isExternallyUploading || isProcessing;

  // Effect to open viewer for newly uploaded image
  useEffect(() => {
    if (lastUploadedImageId) {
      const newIndex = images.findIndex(img => img.id === lastUploadedImageId);
      if (newIndex !== -1) {
          setSelectedViewerIndex(newIndex);
          setShowImageViewer(true);
      }
      setLastUploadedImageId(null); // Reset tracker
    }
  }, [images, lastUploadedImageId]); // Depend on images array as well

  // --- Event Handlers ---

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Basic Validations (already implemented, kept as is)
    const validTypes = ["image/jpeg", "image/png", "image/jpg", "image/webp"]; // Added webp
    if (!validTypes.includes(file.type)) {
      toast.error("סוג קובץ לא חוקי. יש להעלות JPG, PNG, או WEBP.");
      return;
    }
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      toast.error("הקובץ גדול מדי (מקסימום 5MB).");
      return;
    }

    // Prevent multiple uploads
    if (isLoading) return;

    // Use the external onUpload handler
    try {
      // Note: We don't set isProcessing here, assuming isExternallyUploading reflects the upload state
      await onUpload(file);
      // We need the ID of the new image to track it.
      // Assuming onUpload updates the `images` prop via the parent component,
      // we'll rely on the useEffect to find and show the new image.
      // We need a way to get the ID - this might require adjustment in the parent or API response.
      // For now, we'll assume the parent handles setting the ID correctly and updates `images`.
      // A potential workaround is to find the image added (if only one is added)
      // This is brittle. A better approach is if `onUpload` returns the new image ID.
      // Let's simulate getting the last image ID for the effect hook.
      // This requires the parent component to update `images` prop immediately after upload success.
      // const newImage = images[images.length - 1]; // Risky assumption
      // if (newImage) setLastUploadedImageId(newImage.id);

      toast.success("התמונה הועלתה בהצלחה.");

      // Automatically set as main if it's the very first image
      if (images.length === 0) {
        // Need the ID here too. This logic might need to move to the parent
        // or the API should return the ID for immediate use.
        // Assuming the `images` prop updates quickly after onUpload resolves:
        const newImageId = images.find(img => !img.isMain)?.id; // Find the first non-main, likely the new one
        if (newImageId) {
            await handleSetMainImage(newImageId, false); // Set main without toast
        }
      }

    } catch (error) {
      console.error("Error during upload process:", error);
      // Toast handled by onUpload or here as fallback
      if (!(error instanceof Error && error.message.includes("Toast"))) {
         toast.error("שגיאה בהעלאת התמונה.");
      }
    } finally {
      // Reset file input regardless of success/fail
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      //setIsProcessing(false); // Only manage internal processing state
    }
  };

  const triggerFileInput = () => {
    if (!isLoading && !disabled && images.length < maxImages) {
      fileInputRef.current?.click();
    }
  };

  const handleImageClick = (index: number) => {
    setSelectedViewerIndex(index);
    setShowImageViewer(true);
  };

  const closeImageViewer = useCallback(() => { // Use useCallback for keydown listener
    setShowImageViewer(false);
    setSelectedViewerIndex(null);
  }, []);

  const handleNextImage = useCallback(() => { // Use useCallback
      setSelectedViewerIndex((prevIndex) => {
          if (prevIndex === null || prevIndex >= images.length - 1) return prevIndex;
          return prevIndex + 1;
      });
  }, [images.length]);

  const handlePreviousImage = useCallback(() => { // Use useCallback
      setSelectedViewerIndex((prevIndex) => {
          if (prevIndex === null || prevIndex <= 0) return prevIndex;
          return prevIndex - 1;
      });
  }, []); // Dependency images.length removed as index check handles boundary


  // Handler for delete confirmation
  const confirmDelete = async () => {
    if (!imageToDelete || isProcessing) return;

    setIsProcessing(true);
    try {
      const imageIndex = images.findIndex((img) => img.id === imageToDelete);
      if (imageIndex === -1) throw new Error("Image not found for deletion.");

      const imageObj = images[imageIndex];

      // If deleting the main image, and there are others, set a new main one
      if (imageObj.isMain && images.length > 1) {
        const nextMainIndex = imageIndex === 0 ? 1 : 0; // Pick first or second
        await onSetMain(images[nextMainIndex].id);
      }

      // Call the external delete handler
      await onDelete(imageToDelete);

      toast.success("התמונה נמחקה בהצלחה.");
      closeImageViewer(); // Close viewer if open
      setDeleteConfirmOpen(false); // Close confirmation dialog
      setImageToDelete(null); // Reset delete target

    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error("שגיאה במחיקת התמונה.");
    } finally {
      setIsProcessing(false);
    }
  };

  // Open confirmation dialog
  const requestDelete = (imageId: string, event?: React.MouseEvent) => {
    event?.stopPropagation(); // Prevent grid click or other triggers
    if (isLoading) return;
    setImageToDelete(imageId);
    setDeleteConfirmOpen(true);
  };


  // Handler for setting main image
  const handleSetMainImage = async (imageId: string, showToast = true, event?: React.MouseEvent) => {
    event?.stopPropagation();
    if (isLoading) return;

    const currentImage = images.find(img => img.id === imageId);
    if (!currentImage || currentImage.isMain) return; // Already main or not found

    setIsProcessing(true);
    try {
      await onSetMain(imageId);
      if (showToast) {
        toast.success("התמונה הראשית עודכנה.");
      }
    } catch (error) {
      console.error("Error setting main image:", error);
      toast.error("שגיאה בעדכון התמונה הראשית.");
    } finally {
      setIsProcessing(false);
    }
  };

   // Prevent event bubbling for controls
   const handleControlClick = (e: React.MouseEvent) => {
    e.stopPropagation();
   };

   // Keyboard navigation for viewer
   useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!showImageViewer) return;

      switch (e.key) {
        case "ArrowRight": // Assuming RTL means right arrow goes to PREVIOUS visually (index decreases)
          handlePreviousImage();
          break;
        case "ArrowLeft": // Assuming RTL means left arrow goes to NEXT visually (index increases)
          handleNextImage();
          break;
        case "Escape":
          closeImageViewer();
          break;
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [showImageViewer, handlePreviousImage, handleNextImage, closeImageViewer]); // Add dependencies


  // --- Render ---

  return (
    // Inspired Card Structure
    <div dir="rtl" className="bg-white/80 backdrop-blur-lg rounded-3xl shadow-xl p-6 md:p-8">
      {/* Header */}
      <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-6 pb-4 border-b border-gray-200/80">
        <div className="mb-3 sm:mb-0 text-right">
          <h2 className="text-xl font-semibold text-gray-800">תמונות פרופיל</h2>
          <p className="mt-1 text-sm text-gray-600">
            העלה עד {maxImages} תמונות. התמונה הראשית תוצג בכרטיס. (מומלץ: תמונות ברורות של הפנים)
          </p>
        </div>
        {!disabled && (
          <Button
            variant="outline"
            onClick={triggerFileInput}
            disabled={isLoading || images.length >= maxImages}
            className="rounded-full border-2 border-cyan-300 text-cyan-700 hover:bg-cyan-50/50 hover:border-cyan-400 transition-all duration-300 px-5 py-2.5 text-sm font-medium flex items-center gap-2 self-end sm:self-center" // Adjusted padding/text size
          >
            {isExternallyUploading ? ( // Show spinner only for external upload
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Upload className="w-4 h-4" />
            )}
            <span>העלאת תמונה</span>
          </Button>
        )}
      </div>

      {/* Input for file selection (hidden) */}
      <input
        type="file"
        ref={fileInputRef}
        className="hidden"
        accept="image/jpeg,image/png,image/jpg,image/webp" // Added webp
        onChange={handleFileSelect}
        disabled={isLoading || disabled || images.length >= maxImages}
      />

      {/* Images Grid */}
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 md:gap-5">
        {/* Render Images */}
        {images.map((image, index) => (
          <div
            key={image.id}
            className="relative group aspect-square rounded-xl overflow-hidden cursor-pointer bg-gray-100 shadow-md hover:shadow-lg transition-all duration-300 ease-in-out"
            onClick={() => handleImageClick(index)}
          >
            <Image
              src={image.url}
              alt={`תמונת פרופיל ${index + 1}`}
              fill
              className="object-cover transition-transform duration-300 group-hover:scale-105"
              sizes="(max-width: 640px) 50vw, (max-width: 768px) 33vw, (max-width: 1024px) 25vw, 20vw"
              priority={index < 2} // Prioritize loading first few images
            />

            {/* Controls Overlay - Always visible, subtle */}
            {!disabled && (
              <div
                className="absolute top-2 right-2 z-10 flex gap-1.5 opacity-85 group-hover:opacity-100 transition-opacity duration-200"
                onClick={handleControlClick} // Prevent triggering image click
              >
                {/* Set Main Button */}
                <Button
                  variant="secondary"
                  size="icon"
                  className={cn(
                    "w-8 h-8 rounded-full shadow-md border border-white/30 bg-black/40 text-white hover:bg-black/60 transition-colors",
                    image.isMain ? "cursor-default" : "hover:text-yellow-300" // Visual cue for main
                  )}
                  onClick={(e) => handleSetMainImage(image.id, true, e)}
                  disabled={image.isMain || isLoading}
                  title={image.isMain ? "תמונה ראשית" : "הפוך לתמונה ראשית"}
                >
                  <Star
                    className={cn(
                      "w-4 h-4 transition-colors",
                      image.isMain ? "text-yellow-400 fill-yellow-400" : "text-white"
                    )}
                  />
                </Button>

                {/* Delete Button */}
                <Button
                  variant="secondary"
                  size="icon"
                  className="w-8 h-8 rounded-full shadow-md border border-white/30 bg-black/40 text-white hover:bg-red-600 hover:border-red-700 transition-colors"
                  onClick={(e) => requestDelete(image.id, e)}
                  disabled={isLoading}
                  title="מחק תמונה"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            )}

            {/* Main Image Badge */}
            {image.isMain && (
              <Badge className="absolute bottom-2 left-2 rounded-full px-2.5 py-0.5 text-xs font-medium shadow-md text-white bg-gradient-to-r from-cyan-500 to-pink-500 border-none">
                ראשי
              </Badge>
            )}
          </div>
        ))}

        {/* Upload Placeholder */}
        {!disabled && images.length < maxImages && (
          <div
            onClick={triggerFileInput}
            className="flex flex-col items-center justify-center text-center p-4 aspect-square rounded-xl border-2 border-dashed border-cyan-300/70 bg-cyan-50/30 hover:bg-cyan-50/60 hover:border-cyan-400 transition-colors duration-300 cursor-pointer group"
          >
            <Upload className="w-8 h-8 text-cyan-500 mb-2 transition-transform group-hover:scale-110" />
            <span className="text-sm font-medium text-cyan-700">העלאת תמונה</span>
            <span className="text-xs text-cyan-600/90 mt-1">
              עד {maxImages - images.length} תמונות נוספות
            </span>
          </div>
        )}
      </div>

      {/* Empty State (if no images and not disabled) */}
      {images.length === 0 && !disabled && (
         <div className="text-center py-16 mt-6 bg-gradient-to-br from-cyan-50/20 to-pink-50/20 rounded-xl border border-dashed border-gray-300">
              <Camera className="w-12 h-12 mx-auto text-gray-400/80" />
              <p className="mt-4 text-gray-600 font-medium">
                אין עדיין תמונות בפרופיל
              </p>
         <p className="text-sm text-gray-500 mt-1 px-4">
  תמונה טובה היא הרושם הראשוני שלכם. כדאי להעלות אחת כדי להשלים את הפרופיל.
</p>
          </div>
      )}
      {/* Empty State (if disabled and no images) */}
       {images.length === 0 && disabled && (
         <div className="text-center py-16 mt-6 bg-gray-50/50 rounded-xl border border-gray-200">
              <Camera className="w-12 h-12 mx-auto text-gray-400" />
              <p className="mt-4 text-gray-500 font-medium">
                לא הועלו תמונות לפרופיל זה.
              </p>
          </div>
      )}

      {/* Delete Confirmation Dialog */}
      <Dialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
        <DialogContent className="sm:max-w-md bg-white/95 backdrop-blur-md rounded-2xl shadow-2xl border-none p-6" dir="rtl">
          <DialogHeader>
            <DialogTitle className="text-lg font-semibold text-gray-800">אישור מחיקת תמונה</DialogTitle>
            <DialogDescription className="text-sm text-gray-600 mt-2">
              האם למחוק את התמונה לצמיתות? לא ניתן לשחזר פעולה זו.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="mt-6 flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 sm:space-x-reverse gap-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => setDeleteConfirmOpen(false)}
              disabled={isLoading}
              className="rounded-full px-5"
            >
              ביטול
            </Button>
            <Button
              type="button"
              variant="destructive"
              onClick={confirmDelete}
              disabled={isLoading}
               className="rounded-full px-5"
            >
              {isProcessing ? (
                <Loader2 className="w-4 h-4 ml-2 animate-spin" />
              ) : (
                <Trash2 className="w-4 h-4 ml-2" /> // Keep icon consistent
              )}
              <span>מחק</span>
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

       {/* Image Viewer Dialog */}
       <Dialog open={showImageViewer} onOpenChange={setShowImageViewer}>
        <DialogContent
            className="p-0 m-0 w-screen h-screen max-w-none sm:max-w-full sm:h-full bg-black/90 backdrop-blur-sm border-none rounded-none flex items-center justify-center outline-none"
            aria-describedby={undefined} // Remove default description link if header is hidden
            >
            {/* Close Button */}
            <Button
                variant="ghost"
                size="icon"
                className="absolute top-4 left-4 z-50 bg-black/40 hover:bg-black/60 text-white rounded-full w-10 h-10 sm:w-12 sm:h-12 transition-colors"
                onClick={closeImageViewer}
                aria-label="סגור תצוגת תמונה"
            >
                <X className="w-6 h-6" />
            </Button>

            {/* Image Display Area */}
            {selectedViewerIndex !== null && images[selectedViewerIndex] && (
                <div className="relative w-full h-full flex items-center justify-center">
                    {/* Image */}
                     <div className="relative w-[95%] h-[85%] sm:w-[90%] sm:h-[90%]">
                        <Image
                            src={images[selectedViewerIndex].url}
                            alt={`תצוגה מוגדלת של תמונה ${selectedViewerIndex + 1}`}
                            fill
                            className="object-contain select-none" // Prevent image selection/drag
                            sizes="90vw" // Simplified sizes for viewer
                            priority // Load the viewed image with high priority
                        />
                    </div>


                    {/* Viewer Controls (Nav + Actions) */}
                    <div className="absolute top-0 left-0 w-full h-full pointer-events-none">
                         {/* Navigation */}
                         {images.length > 1 && (
                            <>
                            {/* Previous Button (Visually Right in RTL) */}
                            <Button
                                variant="ghost"
                                size="icon"
                                className="absolute right-2 sm:right-4 top-1/2 transform -translate-y-1/2 z-40 bg-black/40 hover:bg-black/60 text-white rounded-full w-10 h-10 sm:w-12 sm:h-12 transition-colors pointer-events-auto"
                                onClick={(e) => {e.stopPropagation(); handlePreviousImage();}}
                                disabled={selectedViewerIndex === 0}
                                aria-label="התמונה הקודמת"
                            >
                                <ChevronRight className="w-7 h-7" />
                            </Button>
                             {/* Next Button (Visually Left in RTL) */}
                            <Button
                                variant="ghost"
                                size="icon"
                                className="absolute left-2 sm:left-4 top-1/2 transform -translate-y-1/2 z-40 bg-black/40 hover:bg-black/60 text-white rounded-full w-10 h-10 sm:w-12 sm:h-12 transition-colors pointer-events-auto"
                                onClick={(e) => {e.stopPropagation(); handleNextImage();}}
                                disabled={selectedViewerIndex === images.length - 1}
                                aria-label="התמונה הבאה"
                            >
                                <ChevronLeft className="w-7 h-7" />
                            </Button>
                            </>
                         )}

                        {/* Action Buttons (Top Right) */}
                         {!disabled && (
                            <div className="absolute top-4 right-4 z-50 flex flex-col sm:flex-row gap-2 pointer-events-auto">
                                {/* Set as Main Button */}
                                {!images[selectedViewerIndex].isMain && (
                                <Button
                                    variant="secondary"
                                    className="rounded-full bg-white/70 backdrop-blur-sm shadow-md hover:bg-white/90 text-gray-800 px-3 py-1.5 text-xs sm:text-sm border border-white/20 flex items-center gap-1.5"
                                    onClick={(e) => handleSetMainImage(images[selectedViewerIndex].id, true, e)}
                                    size="sm"
                                    disabled={isLoading}
                                >
                                    <Star className="w-4 h-4" />
                                    <span>הפוך לראשי</span>
                                </Button>
                                )}

                                {/* Delete Button */}
                                <Button
                                    variant="destructive" // Using destructive variant directly
                                    className="rounded-full bg-red-600/80 hover:bg-red-700 text-white px-3 py-1.5 text-xs sm:text-sm shadow-md border-none flex items-center gap-1.5"
                                    onClick={(e) => requestDelete(images[selectedViewerIndex].id, e)}
                                    size="sm"
                                    disabled={isLoading}
                                >
                                    <Trash2 className="w-4 h-4" />
                                    <span>מחק תמונה</span>
                                </Button>
                            </div>
                        )}

                        {/* Counter */}
                        {images.length > 0 && (
                           <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/60 text-white px-3 py-1 rounded-full text-xs sm:text-sm font-medium select-none">
                             {selectedViewerIndex + 1} / {images.length}
                           </div>
                        )}
                    </div>
                 </div>
            )}
        </DialogContent>
       </Dialog>
    </div>
  );
};

export default PhotosSection;

--- End of Content for PhotosSection.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\PreferencesSection.tsx
--------------------------------------------------------------------------------
Content:
// src/app/(authenticated)/profile/components/dashboard/PreferencesSection.tsx
"use client";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Info } from "lucide-react";
import React, { useState, useEffect } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Pencil,
  Save,
  X,
  FileText, // Icon for General Description
  SlidersHorizontal, // Icon for Age/Height
  MapPin, // Icon for Location/Religious (expanded)
  GraduationCap, // Icon for Education/Occupation (expanded)
  Users, // Icon for Family/Personal Background (new)
  Sparkles, // Icon for Character/Hobbies (new)
  Heart, // For shomer negiah, children etc.
  Briefcase, // For service type
  Shield, // Could be for traits
  Palette, // Could be for hobbies
  Smile, // Could be for traits
} from "lucide-react";
import { UserProfile } from "@/types/next-auth";
import { cn } from "@/lib/utils";
import {
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
} from "@prisma/client";
interface PreferencesSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onChange: (data: Partial<UserProfile>) => void;
}

// --- Options for existing multi-select fields ---
const locationOptions = [
  { value: "צפון", label: "צפון" },
  { value: "מרכז", label: "מרכז" },
  { value: "דרום", label: "דרום" },
  { value: "ירושלים", label: "ירושלים" },
  { value: "יהודה ושומרון", label: "יהודה ושומרון" },
  { value: 'חו"ל', label: 'חו"ל' },
];

const religiousLevelOptions = [
  { value: "חרדי", label: "חרדי" },
  { value: "חרדי מודרני", label: "חרדי מודרני" },
  { value: "דתי", label: "דתי" },
  { value: "דתי-לייט", label: "דתי-לייט" },
  { value: "מסורתי", label: "מסורתי" },
  { value: "חילוני", label: "חילוני" },
  { value: "לא משנה", label: "ללא העדפה / גמיש" },
];

const educationPreferenceOptions = [
  { value: "תיכונית", label: "תיכונית" },
  { value: "על תיכונית", label: "על תיכונית" },
  { value: "אקדמית", label: "אקדמית" },
  { value: "תורנית", label: "תורנית" },
  { value: "ללא העדפה", label: "ללא העדפה" },
];

const occupationPreferenceOptions = [
  { value: "עובד/ת", label: "עובד/ת" },
  { value: "סטודנט/ית", label: "סטודנט/ית" },
  { value: "אברך/כולל", label: "אברך/כולל" },
  { value: "עצמאי/ת", label: "עצמאי/ת" },
  { value: "שירות צבאי/לאומי", label: "שירות צבאי/לאומי" },
  { value: "ללא העדפה", label: "ללא העדפה" },
];

// --- Options for NEW fields ---
const preferredShomerNegiahOptions = [
  { value: "yes", label: "כן, חשוב לי" },
  { value: "no", label: "לא, אין העדפה" }, // Or "לא, לא רלוונטי"
  { value: "flexible", label: "גמיש/תלוי באדם" },
];

const preferredPartnerHasChildrenOptions = [
  { value: "yes_ok", label: "כן, זה בסדר גמור" },
  { value: "no_preferred", label: "מעדיפ/ה שלא יהיו" },
  { value: "does_not_matter", label: "לא משנה לי" },
];

const preferredOriginOptions = [
  { value: "ashkenazi", label: "אשכנזי/ה" },
  { value: "sephardi", label: "ספרדי/ה" },
  { value: "mizrachi", label: "מזרחי/ה" },
  { value: "temani", label: "תימני/ה" },
  { value: "mixed", label: "מעורב/ת" },
  { value: "ethiopian", label: "אתיופי/ה" },
  { value: "american", label: "אמריקאי/ה" },
  { value: "european", label: "אירופאי/ה" },
  { value: "russian_speaking", label: "ממדינות דוברות רוסית" },
  { value: "french_speaking", label: "ממדינות דוברות צרפתית" },
  { value: "south_american", label: "דרום אמריקאי/ה" },
  { value: "other", label: "אחר" },
  { value: "no_preference", label: "ללא העדפה מיוחדת" },
];

const preferredAliyaStatusOptions = [
  { value: "oleh", label: "עולה חדש/ה" },
  { value: "tzabar", label: "צבר/ית" },
  { value: "no_preference", label: "ללא העדפה" },
];

// Options copied/adapted from ProfileSection.tsx (or similar source)
const maritalStatusOptions = [
  // For preferredMaritalStatuses
  { value: "single", label: "רווק/ה" },
  { value: "divorced", label: "גרוש/ה" },
  { value: "widowed", label: "אלמן/ה" },
  { value: "annulled", label: "נישואין שבוטלו" },
  { value: "any", label: "כל האפשרויות פתוחות" },
];

const serviceTypeOptions = [
  // For preferredServiceTypes
  { value: ServiceType.MILITARY_COMBATANT, label: "צבאי - לוחם/ת" },
  { value: ServiceType.MILITARY_SUPPORT, label: "צבאי - תומכ/ת לחימה" },
  { value: ServiceType.MILITARY_OFFICER, label: "צבאי - קצונה" },
  {
    value: ServiceType.MILITARY_INTELLIGENCE_CYBER_TECH,
    label: "צבאי - מודיעין/סייבר/טכנולוגי",
  },
  { value: ServiceType.NATIONAL_SERVICE_ONE_YEAR, label: "שירות לאומי - שנה" },
  {
    value: ServiceType.NATIONAL_SERVICE_TWO_YEARS,
    label: "שירות לאומי - שנתיים",
  },
  { value: ServiceType.HESDER_YESHIVA, label: "ישיבת הסדר" },
  {
    value: ServiceType.YESHIVA_ONLY_POST_HS,
    label: "ישיבה גבוהה / מדרשה (ללא שירות)",
  },
  {
    value: ServiceType.PRE_MILITARY_ACADEMY_AND_SERVICE,
    label: "מכינה קדם-צבאית ושירות",
  },
  { value: ServiceType.EXEMPTED, label: "פטור משירות" },
  { value: ServiceType.CIVILIAN_SERVICE, label: "שירות אזרחי" },
  { value: ServiceType.OTHER, label: "אחר / לא רלוונטי" },
  { value: "no_preference", label: "ללא העדפה / לא משנה" },
];

const headCoveringOptions = [
  // For preferredHeadCoverings (if user is Male)
  { value: HeadCoveringType.FULL_COVERAGE, label: "כיסוי ראש מלא" },
  { value: HeadCoveringType.PARTIAL_COVERAGE, label: "כיסוי ראש חלקי" },
  { value: HeadCoveringType.HAT_BERET, label: "כובע / ברט" },
  {
    value: HeadCoveringType.SCARF_ONLY_SOMETIMES,
    label: "מטפחת (רק באירועים/בית כנסת)",
  },
  { value: HeadCoveringType.NONE, label: "ללא כיסוי ראש" },
  { value: "any", label: "כל האפשרויות פתוחות" },
];

const kippahTypeOptions = [
  // For preferredKippahTypes (if user is Female)
  { value: KippahType.BLACK_VELVET, label: "קטיפה שחורה" },
  { value: KippahType.KNITTED_SMALL, label: "סרוגה קטנה" },
  { value: KippahType.KNITTED_LARGE, label: "סרוגה גדולה" },
  { value: KippahType.CLOTH, label: "בד" },
  { value: KippahType.BRESLEV, label: "ברסלב (לבנה גדולה)" },
  { value: KippahType.NONE_AT_WORK_OR_CASUAL, label: "לא בעבודה / ביומיום" },
  { value: KippahType.NONE_USUALLY, label: "לרוב לא חובש" },
  { value: KippahType.OTHER, label: "אחר" },
  { value: "any", label: "כל האפשרויות פתוחות" },
];

const characterTraitsOptions = [
  // For preferredCharacterTraits
  { value: "empathetic", label: "אמפתי/ת", icon: Heart },
  { value: "driven", label: "שאפתן/ית", icon: Briefcase },
  { value: "optimistic", label: "אופטימי/ת", icon: Smile },
  { value: "family_oriented", label: "משפחתי/ת", icon: Users },
  { value: "intellectual", label: "אינטלקטואל/ית", icon: GraduationCap },
  { value: "organized", label: "מאורגנ/ת", icon: Palette },
  { value: "calm", label: "רגוע/ה", icon: Heart },
  { value: "humorous", label: "בעל/ת חוש הומור", icon: Smile },
  { value: "sociable", label: "חברותי/ת", icon: Users },
  { value: "sensitive", label: "רגיש/ה", icon: Heart },
  { value: "independent", label: "עצמאי/ת", icon: MapPin }, // Icon might need adjustment
  { value: "creative", label: "יצירתי/ת", icon: Palette },
  { value: "honest", label: "כן/ה וישר/ה", icon: Shield },
  { value: "responsible", label: "אחראי/ת", icon: Shield },
  { value: "easy_going", label: "זורם/ת וקליל/ה", icon: Smile },
  { value: "no_strong_preference", label: "ללא העדפה חזקה", icon: Sparkles },
];

const hobbiesOptions = [
  // For preferredHobbies
  { value: "travel", label: "טיולים", icon: MapPin },
  { value: "sports", label: "ספורט", icon: Briefcase }, // Icon might need adjustment
  { value: "reading", label: "קריאה", icon: GraduationCap },
  { value: "cooking_baking", label: "בישול/אפיה", icon: Palette },
  { value: "music_playing_instrument", label: "מוזיקה/נגינה", icon: Palette }, // Icon might need adjustment
  { value: "art_crafts", label: "אומנות/יצירה", icon: Palette },
  { value: "volunteering", label: "התנדבות", icon: Heart },
  { value: "learning_courses", label: "למידה/קורסים", icon: GraduationCap },
  { value: "board_games_puzzles", label: "משחקי קופסא/פאזלים", icon: Smile },
  { value: "movies_theater", label: "סרטים/תיאטרון", icon: Smile },
  { value: "dancing", label: "ריקוד", icon: Users },
  { value: "writing", label: "כתיבה", icon: GraduationCap },
  { value: "nature_hiking", label: "טבע/טיולים רגליים", icon: MapPin },
  { value: "photography", label: "צילום", icon: Palette },
  { value: "no_strong_preference", label: "ללא העדפה חזקה", icon: Sparkles },
];

const PreferencesSection: React.FC<PreferencesSectionProps> = ({
  profile,
  isEditing,
  viewOnly = false,
  setIsEditing,
  onChange,
}) => {
  const [formData, setFormData] = useState<Partial<UserProfile>>({});
  const [initialData, setInitialData] = useState<Partial<UserProfile>>({});

  useEffect(() => {
    if (profile) {
      const nullToUndefined = <T,>(value: T | null): T | undefined =>
        value === null ? undefined : value;

      const newFormData: Partial<UserProfile> = {
        ...profile,
        // Numeric fields
        preferredAgeMin: nullToUndefined(profile.preferredAgeMin),
        preferredAgeMax: nullToUndefined(profile.preferredAgeMax),
        preferredHeightMin: nullToUndefined(profile.preferredHeightMin),
        preferredHeightMax: nullToUndefined(profile.preferredHeightMax),

        // String fields
        matchingNotes: profile.matchingNotes ?? "",
        contactPreference: nullToUndefined(profile.contactPreference),
        preferredShomerNegiah: nullToUndefined(profile.preferredShomerNegiah),
        preferredPartnerHasChildren: nullToUndefined(
          profile.preferredPartnerHasChildren
        ),
        preferredAliyaStatus: nullToUndefined(profile.preferredAliyaStatus),

        // Array fields
        preferredLocations: profile.preferredLocations ?? [],
        preferredReligiousLevels: profile.preferredReligiousLevels ?? [],
        preferredEducation: profile.preferredEducation ?? [],
        preferredOccupations: profile.preferredOccupations ?? [],
        preferredMaritalStatuses: profile.preferredMaritalStatuses ?? [],
        preferredOrigins: profile.preferredOrigins ?? [],
        preferredServiceTypes: profile.preferredServiceTypes ?? [],
        preferredHeadCoverings: profile.preferredHeadCoverings ?? [],
        preferredKippahTypes: profile.preferredKippahTypes ?? [],
        preferredCharacterTraits: profile.preferredCharacterTraits ?? [],
        preferredHobbies: profile.preferredHobbies ?? [],
      };
      setFormData(newFormData);
      setInitialData(newFormData);
    }
  }, [profile]);

  useEffect(() => {
    if (!isEditing && initialData) {
      // Check initialData to prevent reset before it's set
      setFormData(initialData);
    }
  }, [isEditing, initialData]);

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value, type } = e.target;
    const field = name as keyof UserProfile;

    setFormData((prev) => {
      let processedValue: string | number | undefined;
      if (type === "number") {
        const num = parseInt(value, 10);
        processedValue = isNaN(num) ? undefined : num;
      } else {
        processedValue = value === "" ? undefined : value; // Treat empty string as undefined for optional fields
      }
      return { ...prev, [field]: processedValue };
    });
  };

  const handleSelectChange = (field: keyof UserProfile, value: string) => {
    setFormData((prev) => ({
      ...prev,
      [field]:
        value === "" ||
        value === "לא_משנה" ||
        value === "any" ||
        value === "no_preference"
          ? undefined
          : (value as UserProfile[typeof field]),
    }));
  };

  const handleMultiSelectChange = (field: keyof UserProfile, value: string) => {
    setFormData((prev) => {
      const currentValues =
        (Array.isArray(prev[field]) ? (prev[field] as string[]) : []) ?? [];
      let newValues;
      if (
        value === "any" ||
        value === "no_preference" ||
        value === "לא_משנה" ||
        value === "no_strong_preference"
      ) {
        newValues = currentValues.includes(value) ? [] : [value]; // Select "any" deselects others, or selects only "any"
      } else {
        // Remove "any" or "no_preference" if another specific option is selected
        const filteredValues = currentValues.filter(
          (v) =>
            v !== "any" &&
            v !== "no_preference" &&
            v !== "לא_משנה" &&
            v !== "no_strong_preference"
        );
        newValues = filteredValues.includes(value)
          ? filteredValues.filter((v) => v !== value)
          : [...filteredValues, value];
      }
      return { ...prev, [field]: newValues };
    });
  };

  const handleSave = () => {
    // Filter out empty strings from array fields before saving, if desired
    const dataToSave = { ...formData };
    // Example: dataToSave.preferredLocations = dataToSave.preferredLocations?.filter(loc => loc !== "");
    onChange(dataToSave);
    setIsEditing(false);
    setInitialData(dataToSave);
  };

  const handleCancel = () => {
    setFormData(initialData);
    setIsEditing(false);
  };

  const renderMultiSelectBadges = (
    fieldValues: string[] | undefined | null,
    options: { value: string; label: string; icon?: React.ElementType }[],
    badgeClass: string = "bg-sky-100 text-sky-700",
    emptyPlaceholder: string = "לא נבחרו פריטים."
  ) => {
    if (!fieldValues || fieldValues.length === 0) {
      return <p className="text-sm text-gray-500 italic">{emptyPlaceholder}</p>;
    }
    return fieldValues.map((value) => {
      const option = options.find((opt) => opt.value === value);
      return option ? (
        <Badge
          key={value}
          variant="secondary"
          className={cn(
            "mr-1 mb-1 text-xs px-2 py-0.5 rounded-full flex items-center",
            badgeClass
          )}
        >
          {option.icon && <option.icon className="w-3 h-3 rtl:ml-1 mr-1" />}
          {option.label}
        </Badge>
      ) : null;
    });
  };

  const getSelectDisplayValue = (
    value: string | undefined | null,
    options: { value: string; label: string }[],
    placeholder: string = "לא צוין."
  ) => {
    if (!value)
      return <span className="text-gray-500 italic">{placeholder}</span>;
    const option = options.find((opt) => opt.value === value);
    return option ? (
      option.label
    ) : (
      <span className="text-gray-500 italic">{placeholder}</span>
    );
  };

  return (
    <div className="relative" dir="rtl">
      <div className="sticky top-0 z-10 bg-gradient-to-b from-white via-white/95 to-white/0 pt-4 pb-3 backdrop-blur-sm">
        <div className="container mx-auto max-w-screen-xl px-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-xl md:text-2xl font-bold text-slate-800">
                העדפות התאמה
              </h1>
              <p className="text-sm text-slate-500">
                {isEditing && !viewOnly
                  ? "ערוך/י את העדפותיך למציאת התאמה."
                  : "העדפות שהוגדרו לחיפוש התאמה."}
              </p>
            </div>
            {!viewOnly && (
              <div className="flex gap-2">
                {!isEditing ? (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setIsEditing(true)}
                    className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-cyan-400 text-cyan-700 hover:bg-cyan-50"
                  >
                    <Pencil className="w-3.5 h-3.5 ml-1.5" />
                    עריכה
                  </Button>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleCancel}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-gray-300 text-gray-700 hover:bg-gray-50"
                    >
                      <X className="w-3.5 h-3.5 ml-1.5" />
                      ביטול
                    </Button>
                    <Button
                      variant="default"
                      size="sm"
                      onClick={handleSave}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 bg-cyan-600 hover:bg-cyan-700 text-white"
                    >
                      <Save className="w-3.5 h-3.5 ml-1.5" />
                      שמירה
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="container mx-auto max-w-screen-xl py-6 px-4">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* --- Column 1 --- */}
          <div className="space-y-6">
            {/* Card: General Description & Contact Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-slate-50/40 to-gray-100/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <FileText className="w-5 h-5 text-slate-600" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  תיאור כללי והעדפות קשר
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-5">
                <div>
              <div className="flex items-center gap-1.5">
    <Label htmlFor="matchingNotes" className="text-sm font-medium text-gray-700">
        תיאור כללי על המועמד/ת המבוקש/ת
    </Label>
    <TooltipProvider delayDuration={100}>
        <Tooltip>
            <TooltipTrigger type="button"><Info className="w-4 h-4 text-gray-400 hover:text-gray-600" /></TooltipTrigger>
            <TooltipContent side="top" className="max-w-xs text-center">
                <p>זהו אחד השדות החשובים ביותר! תאר/י במילים שלך את סוג האדם שאת/ה מחפש/ת. התיאור הזה יעזור לשדכנים להבין את הראש שלך מעבר לנתונים היבשים.</p>
            </TooltipContent>
        </Tooltip>
    </TooltipProvider>
</div>
                  {isEditing ? (
                    <Textarea
                      id="matchingNotes"
                      name="matchingNotes"
                      value={formData.matchingNotes || ""}
                      onChange={handleInputChange}
                      placeholder="פרט/י על סוג האדם שאת/ה מחפש/ת, תכונות חשובות, ציפיות וכו'..."
                      className="text-sm focus:ring-cyan-500 min-h-[100px] rounded-lg"
                      rows={4}
                    />
                  ) : (
                    <p className="mt-1 text-sm text-gray-700 whitespace-pre-wrap min-h-[60px] bg-slate-50/70 p-3 rounded-lg border border-slate-200/50">
                      {formData.matchingNotes || (
                        <span className="text-gray-500 italic">
                          לא הוזן תיאור.
                        </span>
                      )}
                    </p>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="contactPreference"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    אופן יצירת קשר מועדף (לאחר אישור הצעה)
                  </Label>
                  {isEditing ? (
                    <Select
                      name="contactPreference"
                      value={formData.contactPreference || ""}
                      onValueChange={(value: string) =>
                        handleSelectChange("contactPreference", value)
                      }
                    >
                      <SelectTrigger
                        id="contactPreference"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י אפשרות..." />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="direct">ישירות</SelectItem>
                        <SelectItem value="matchmaker">דרך השדכן/ית</SelectItem>
                        <SelectItem value="both">שתי האפשרויות</SelectItem>
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.contactPreference,
                        [
                          { value: "direct", label: "ישירות" },
                          { value: "matchmaker", label: "דרך השדכן/ית" },
                          { value: "both", label: "שתי האפשרויות" },
                        ],
                        "לא צוין"
                      )}
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Card: Age & Height Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-indigo-50/40 to-purple-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <SlidersHorizontal className="w-5 h-5 text-indigo-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  העדפות גיל וגובה
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                  <div>
                <div className="flex items-center gap-1.5">
    <Label className="text-xs font-medium text-gray-600">
      טווח גילאים מועדף
    </Label>
    <TooltipProvider delayDuration={100}>
        <Tooltip>
            <TooltipTrigger type="button"><Info className="w-4 h-4 text-gray-400 hover:text-gray-600" /></TooltipTrigger>
            <TooltipContent side="top">
                <p>הגדרת טווח גילאים רחב יותר תגדיל את כמות ההצעות שתקבל/י.</p>
            </TooltipContent>
        </Tooltip>
    </TooltipProvider>
</div>
                    <div className="flex items-center gap-2">
                      <Input
                        type="number"
                        name="preferredAgeMin"
                        placeholder="מגיל"
                        aria-label="גיל מינימלי מועדף"
                        value={formData.preferredAgeMin ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                      <span className="text-gray-500">-</span>
                      <Input
                        type="number"
                        name="preferredAgeMax"
                        placeholder="עד גיל"
                        aria-label="גיל מקסימלי מועדף"
                        value={formData.preferredAgeMax ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                    </div>
                    {!isEditing &&
                      !formData.preferredAgeMin &&
                      !formData.preferredAgeMax && (
                        <p className="text-xs text-gray-500 italic mt-1">
                          לא הוגדר טווח גילאים.
                        </p>
                      )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      טווח גבהים מועדף (סמ)
                    </Label>
                    <div className="flex items-center gap-2">
                      <Input
                        type="number"
                        name="preferredHeightMin"
                        placeholder="מ-"
                        aria-label="גובה מינימלי מועדף בסנטימטרים"
                        value={formData.preferredHeightMin ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                      <span className="text-gray-500">-</span>
                      <Input
                        type="number"
                        name="preferredHeightMax"
                        placeholder="עד-"
                        aria-label="גובה מקסימלי מועדף בסנטימטרים"
                        value={formData.preferredHeightMax ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                    </div>
                    {!isEditing &&
                      !formData.preferredHeightMin &&
                      !formData.preferredHeightMax && (
                        <p className="text-xs text-gray-500 italic mt-1">
                          לא הוגדר טווח גבהים.
                        </p>
                      )}
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* --- Column 2 --- */}
          <div className="space-y-6">
            {/* Card: Location, Religious & Lifestyle Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-sky-50/40 to-blue-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <MapPin className="w-5 h-5 text-sky-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  מיקום, רמה דתית ואורח חיים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    אזורי מגורים מועדפים
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {locationOptions.map((loc) => (
                        <Button
                          key={loc.value}
                          type="button"
                          variant={
                            (formData.preferredLocations || []).includes(
                              loc.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredLocations",
                              loc.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredLocations || []).includes(
                              loc.value
                            )
                              ? "bg-sky-500 hover:bg-sky-600 text-white border-sky-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {loc.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredLocations,
                        locationOptions,
                        "bg-sky-100 text-sky-700",
                        "לא נבחרו אזורי מגורים."
                      )}
                    </div>
                  )}
                </div>
                <div>
                 <div className="flex items-center gap-1.5">
    <Label className="text-xs font-medium text-gray-600">
      רמות דתיות מועדפות
    </Label>
    <TooltipProvider delayDuration={100}>
        <Tooltip>
            <TooltipTrigger type="button"><Info className="w-4 h-4 text-gray-400 hover:text-gray-600" /></TooltipTrigger>
            <TooltipContent side="top" className="max-w-xs text-center">
                <p>מומלץ לבחור 1-3 רמות שמתאימות לך. בחירה רחבה מדי עלולה להוביל להצעות פחות מדויקות.</p>
            </TooltipContent>
        </Tooltip>
    </TooltipProvider>
</div>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {religiousLevelOptions.map((level) => (
                        <Button
                          key={level.value}
                          type="button"
                          variant={
                            (formData.preferredReligiousLevels || []).includes(
                              level.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredReligiousLevels",
                              level.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredReligiousLevels || []).includes(
                              level.value
                            )
                              ? "bg-pink-500 hover:bg-pink-600 text-white border-pink-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {level.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredReligiousLevels,
                        religiousLevelOptions,
                        "bg-pink-100 text-pink-700",
                        "לא נבחרו רמות דתיות."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="preferredShomerNegiah"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    שמירת נגיעה אצל הצד השני
                  </Label>
                  {isEditing ? (
                    <Select
                      name="preferredShomerNegiah"
                      value={formData.preferredShomerNegiah || ""}
                      onValueChange={(value) =>
                        handleSelectChange("preferredShomerNegiah", value)
                      }
                    >
                      <SelectTrigger
                        id="preferredShomerNegiah"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י העדפה..." />
                      </SelectTrigger>
                      <SelectContent>
                        {preferredShomerNegiahOptions.map((opt) => (
                          <SelectItem key={opt.value} value={opt.value}>
                            {opt.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.preferredShomerNegiah,
                        preferredShomerNegiahOptions
                      )}
                    </p>
                  )}
                </div>
                {/* Conditional rendering for preferredHeadCoverings / preferredKippahTypes */}
                {profile?.gender === Gender.MALE && (
                  <div>
                    <Label className="block mb-2 text-xs font-medium text-gray-600">
                      העדפת כיסוי ראש לבת הזוג
                    </Label>
                    {isEditing ? (
                      <div className="flex flex-wrap gap-2">
                        {headCoveringOptions.map((opt) => (
                          <Button
                            key={opt.value}
                            type="button"
                            variant={
                              (formData.preferredHeadCoverings || []).includes(
                                opt.value as HeadCoveringType
                              )
                                ? "default"
                                : "outline"
                            }
                            size="sm"
                            onClick={() =>
                              handleMultiSelectChange(
                                "preferredHeadCoverings",
                                opt.value as HeadCoveringType
                              )
                            }
                            className={cn(
                              "rounded-full text-xs px-3 py-1.5 transition-all",
                              (formData.preferredHeadCoverings || []).includes(
                                opt.value as HeadCoveringType
                              )
                                ? "bg-purple-500 hover:bg-purple-600 text-white border-purple-500"
                                : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                            )}
                          >
                            {opt.label}
                          </Button>
                        ))}
                      </div>
                    ) : (
                      <div className="mt-1 flex flex-wrap gap-1.5">
                        {renderMultiSelectBadges(
                          formData.preferredHeadCoverings as string[],
                          headCoveringOptions,
                          "bg-purple-100 text-purple-700",
                          "לא נבחרו העדפות כיסוי ראש."
                        )}
                      </div>
                    )}
                  </div>
                )}
                {profile?.gender === Gender.FEMALE && (
                  <div>
                    <Label className="block mb-2 text-xs font-medium text-gray-600">
                      העדפת סוג כיפה לבן הזוג
                    </Label>
                    {isEditing ? (
                      <div className="flex flex-wrap gap-2">
                        {kippahTypeOptions.map((opt) => (
                          <Button
                            key={opt.value}
                            type="button"
                            variant={
                              (formData.preferredKippahTypes || []).includes(
                                opt.value as KippahType
                              )
                                ? "default"
                                : "outline"
                            }
                            size="sm"
                            onClick={() =>
                              handleMultiSelectChange(
                                "preferredKippahTypes",
                                opt.value as KippahType
                              )
                            }
                            className={cn(
                              "rounded-full text-xs px-3 py-1.5 transition-all",
                              (formData.preferredKippahTypes || []).includes(
                                opt.value as KippahType
                              )
                                ? "bg-orange-500 hover:bg-orange-600 text-white border-orange-500"
                                : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                            )}
                          >
                            {opt.label}
                          </Button>
                        ))}
                      </div>
                    ) : (
                      <div className="mt-1 flex flex-wrap gap-1.5">
                        {renderMultiSelectBadges(
                          formData.preferredKippahTypes as string[],
                          kippahTypeOptions,
                          "bg-orange-100 text-orange-700",
                          "לא נבחרו העדפות סוג כיפה."
                        )}
                      </div>
                    )}
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Card: Education, Occupation & Service Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-teal-50/40 to-green-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <GraduationCap className="w-5 h-5 text-teal-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  השכלה, תעסוקה ושירות
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    רמות השכלה מועדפות
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {educationPreferenceOptions.map((edu) => (
                        <Button
                          key={edu.value}
                          type="button"
                          variant={
                            (formData.preferredEducation || []).includes(
                              edu.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredEducation",
                              edu.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredEducation || []).includes(
                              edu.value
                            )
                              ? "bg-teal-500 hover:bg-teal-600 text-white border-teal-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {edu.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredEducation,
                        educationPreferenceOptions,
                        "bg-teal-100 text-teal-700",
                        "לא נבחרו רמות השכלה."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    תחומי עיסוק מועדפים
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {occupationPreferenceOptions.map((occ) => (
                        <Button
                          key={occ.value}
                          type="button"
                          variant={
                            (formData.preferredOccupations || []).includes(
                              occ.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredOccupations",
                              occ.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredOccupations || []).includes(
                              occ.value
                            )
                              ? "bg-green-500 hover:bg-green-600 text-white border-green-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {occ.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredOccupations,
                        occupationPreferenceOptions,
                        "bg-green-100 text-green-700",
                        "לא נבחרו תחומי עיסוק."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    סוג שירות מועדף (צבאי/לאומי)
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {serviceTypeOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredServiceTypes || []).includes(
                              opt.value as ServiceType
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredServiceTypes",
                              opt.value as ServiceType
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredServiceTypes || []).includes(
                              opt.value as ServiceType
                            )
                              ? "bg-lime-500 hover:bg-lime-600 text-white border-lime-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredServiceTypes as string[],
                        serviceTypeOptions,
                        "bg-lime-100 text-lime-700",
                        "לא נבחרו העדפות שירות."
                      )}
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>

          {/* --- Column 3 --- */}
          <div className="space-y-6">
            {/* Card: Personal & Family Background Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-rose-50/40 to-fuchsia-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Users className="w-5 h-5 text-rose-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  רקע אישי ומשפחתי
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    מצב משפחתי מועדף
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {maritalStatusOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredMaritalStatuses || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredMaritalStatuses",
                              opt.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredMaritalStatuses || []).includes(
                              opt.value
                            )
                              ? "bg-rose-500 hover:bg-rose-600 text-white border-rose-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredMaritalStatuses,
                        maritalStatusOptions,
                        "bg-rose-100 text-rose-700",
                        "לא נבחרו העדפות למצב משפחתי."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="preferredPartnerHasChildren"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    העדפה לגבי ילדים מקשר קודם
                  </Label>
                  {isEditing ? (
                    <Select
                      name="preferredPartnerHasChildren"
                      value={formData.preferredPartnerHasChildren || ""}
                      onValueChange={(value) =>
                        handleSelectChange("preferredPartnerHasChildren", value)
                      }
                    >
                      <SelectTrigger
                        id="preferredPartnerHasChildren"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י העדפה..." />
                      </SelectTrigger>
                      <SelectContent>
                        {preferredPartnerHasChildrenOptions.map((opt) => (
                          <SelectItem key={opt.value} value={opt.value}>
                            {opt.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.preferredPartnerHasChildren,
                        preferredPartnerHasChildrenOptions
                      )}
                    </p>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    מוצא/עדה מועדפים
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {preferredOriginOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredOrigins || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredOrigins",
                              opt.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredOrigins || []).includes(
                              opt.value
                            )
                              ? "bg-fuchsia-500 hover:bg-fuchsia-600 text-white border-fuchsia-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredOrigins,
                        preferredOriginOptions,
                        "bg-fuchsia-100 text-fuchsia-700",
                        "לא נבחרו העדפות מוצא/עדה."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="preferredAliyaStatus"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    העדפת סטטוס עליה
                  </Label>
                  {isEditing ? (
                    <Select
                      name="preferredAliyaStatus"
                      value={formData.preferredAliyaStatus || ""}
                      onValueChange={(value) =>
                        handleSelectChange("preferredAliyaStatus", value)
                      }
                    >
                      <SelectTrigger
                        id="preferredAliyaStatus"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י העדפה..." />
                      </SelectTrigger>
                      <SelectContent>
                        {preferredAliyaStatusOptions.map((opt) => (
                          <SelectItem key={opt.value} value={opt.value}>
                            {opt.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.preferredAliyaStatus,
                        preferredAliyaStatusOptions
                      )}
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Card: Character & Hobbies Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-amber-50/40 to-yellow-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Sparkles className="w-5 h-5 text-amber-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  אופי ותחומי עניין
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    תכונות אופי מועדפות (עד 3)
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {characterTraitsOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredCharacterTraits || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredCharacterTraits",
                              opt.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.preferredCharacterTraits || []).length >=
                              3 &&
                            !(formData.preferredCharacterTraits || []).includes(
                              opt.value
                            ) &&
                            opt.value !== "no_strong_preference"
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all flex items-center",
                            (formData.preferredCharacterTraits || []).includes(
                              opt.value
                            )
                              ? "bg-yellow-500 hover:bg-yellow-600 text-white border-yellow-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.icon && (
                            <opt.icon className="w-3.5 h-3.5 rtl:ml-1.5 mr-1.5" />
                          )}
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredCharacterTraits,
                        characterTraitsOptions,
                        "bg-yellow-100 text-yellow-700",
                        "לא נבחרו תכונות אופי מועדפות."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    תחביבים מועדפים (עד 3)
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {hobbiesOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredHobbies || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredHobbies",
                              opt.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.preferredHobbies || []).length >= 3 &&
                            !(formData.preferredHobbies || []).includes(
                              opt.value
                            ) &&
                            opt.value !== "no_strong_preference"
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all flex items-center",
                            (formData.preferredHobbies || []).includes(
                              opt.value
                            )
                              ? "bg-amber-500 hover:bg-amber-600 text-white border-amber-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.icon && (
                            <opt.icon className="w-3.5 h-3.5 rtl:ml-1.5 mr-1.5" />
                          )}
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredHobbies,
                        hobbiesOptions,
                        "bg-amber-100 text-amber-700",
                        "לא נבחרו תחביבים מועדפים."
                      )}
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PreferencesSection;
--- End of Content for PreferencesSection.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\ProfileSection.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/profile/sections/ProfileSection.tsx
"use client";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import React, { useState, useEffect } from "react";
import {
  Gender,
  AvailabilityStatus,
  ServiceType,
  HeadCoveringType,
  KippahType,
} from "@prisma/client";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Pencil,
  Save,
  X,
  Users,
  BookOpen,
  Briefcase,
  Shield,
  Heart,
  MapPin,
  Languages,
  Palette,
  Smile,
  UserCircle,
  Info,
} from "lucide-react";
import { UserProfile } from "@/types/next-auth";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { languageOptions } from "@/lib/languageOptions"; 
import { toast } from "sonner";

const maritalStatusOptions = [
  { value: "single", label: "רווק/ה" },
  { value: "divorced", label: "גרוש/ה" },
  { value: "widowed", label: "אלמן/ה" },
  { value: "annulled", label: "נישואין שבוטלו" },
];

const religiousLevelOptions = [
  { value: "charedi", label: "חרדי/ת" },
  { value: "charedi_modern", label: "חרדי/ת מודרני/ת" },
  { value: "dati_leumi_torani", label: "דתי/ה לאומי/ת תורני/ת" },
  { value: "dati_leumi_liberal", label: "דתי/ה לאומי/ת ליברלי/ת" },
  { value: "dati_leumi_standard", label: "דתי/ה לאומי/ת (סטנדרטי)" },
  { value: "masorti_strong", label: "מסורתי/ת (קרוב/ה לדת)" },
  { value: "masorti_light", label: "מסורתי/ת (קשר קל למסורת)" },
  { value: "secular_traditional_connection", label: "חילוני/ת עם זיקה למסורת" },
  { value: "secular", label: "חילוני/ת" },
  { value: "spiritual_not_religious", label: "רוחני/ת (לאו דווקא דתי/ה)" },
  { value: "other", label: "אחר (נא לפרט ב'אודות')" },
];

const educationLevelOptions = [
  { value: "high_school", label: "תיכונית" },
  { value: "vocational", label: "מקצועית / תעודה" },
  { value: "academic_student", label: "סטודנט/ית לתואר" },
  { value: "academic_ba", label: "תואר ראשון (BA/BSc)" },
  { value: "academic_ma", label: "תואר שני (MA/MSc)" },
  { value: "academic_phd", label: "דוקטורט (PhD)" },
  { value: "yeshiva_seminary", label: "לימודים תורניים (ישיבה/מדרשה/כולל)" },
  { value: "other", label: "אחר" },
];

const serviceTypeOptions = [
  { value: ServiceType.MILITARY_COMBATANT, label: "צבאי - לוחם/ת" },
  { value: ServiceType.MILITARY_SUPPORT, label: "צבאי - תומכ/ת לחימה" },
  { value: ServiceType.MILITARY_OFFICER, label: "צבאי - קצונה" },
  {
    value: ServiceType.MILITARY_INTELLIGENCE_CYBER_TECH,
    label: "צבאי - מודיעין/סייבר/טכנולוגי",
  },
  { value: ServiceType.NATIONAL_SERVICE_ONE_YEAR, label: "שירות לאומי - שנה" },
  {
    value: ServiceType.NATIONAL_SERVICE_TWO_YEARS,
    label: "שירות לאומי - שנתיים",
  },
  { value: ServiceType.HESDER_YESHIVA, label: "ישיבת הסדר" },
  {
    value: ServiceType.YESHIVA_ONLY_POST_HS,
    label: "ישיבה גבוהה / מדרשה (ללא שירות צבאי/לאומי)",
  },
  {
    value: ServiceType.PRE_MILITARY_ACADEMY_AND_SERVICE,
    label: "מכינה קדם-צבאית ושירות",
  },
  { value: ServiceType.EXEMPTED, label: "פטור משירות" },
  { value: ServiceType.CIVILIAN_SERVICE, label: "שירות אזרחי" },
  { value: ServiceType.OTHER, label: "אחר / לא רלוונטי" },
];

const headCoveringOptions = [
  { value: HeadCoveringType.FULL_COVERAGE, label: "כיסוי ראש מלא" },
  { value: HeadCoveringType.PARTIAL_COVERAGE, label: "כיסוי ראש חלקי" },
  { value: HeadCoveringType.HAT_BERET, label: "כובע / ברט" },
  {
    value: HeadCoveringType.SCARF_ONLY_SOMETIMES,
    label: "מטפחת (רק באירועים/בית כנסת)",
  },
  { value: HeadCoveringType.NONE, label: "ללא כיסוי ראש" },
];

const kippahTypeOptions = [
  { value: KippahType.BLACK_VELVET, label: "קטיפה שחורה" },
  { value: KippahType.KNITTED_SMALL, label: "סרוגה קטנה" },
  { value: KippahType.KNITTED_LARGE, label: "סרוגה גדולה" },
  { value: KippahType.CLOTH, label: "בד" },
  { value: KippahType.BRESLEV, label: "ברסלב (לבנה גדולה)" },
  { value: KippahType.NONE_AT_WORK_OR_CASUAL, label: "לא בעבודה / ביומיום" },
  { value: KippahType.NONE_USUALLY, label: "לרוב לא חובש" },
  { value: KippahType.OTHER, label: "אחר" },
];

const characterTraitsOptions = [
  { value: "empathetic", label: "אמפתי/ת", icon: Heart },
  { value: "driven", label: "שאפתן/ית", icon: Briefcase },
  { value: "optimistic", label: "אופטימי/ת", icon: Smile },
  { value: "family_oriented", label: "משפחתי/ת", icon: Users },
  { value: "intellectual", label: "אינטלקטואל/ית", icon: BookOpen },
  { value: "organized", label: "מאורגנ/ת", icon: Palette },
  { value: "calm", label: "רגוע/ה", icon: Heart },
  { value: "humorous", label: "בעל/ת חוש הומור", icon: Smile },
  { value: "sociable", label: "חברותי/ת", icon: Users },
  { value: "sensitive", label: "רגיש/ה", icon: Heart },
  { value: "independent", label: "עצמאי/ת", icon: MapPin },
  { value: "creative", label: "יצירתי/ת", icon: Palette },
  { value: "honest", label: "כן/ה וישר/ה", icon: Shield },
  { value: "responsible", label: "אחראי/ת", icon: Shield },
  { value: "easy_going", label: "זורם/ת וקליל/ה", icon: Smile },
];

const hobbiesOptions = [
  { value: "travel", label: "טיולים", icon: MapPin },
  { value: "sports", label: "ספורט", icon: Briefcase }, 
  { value: "reading", label: "קריאה", icon: BookOpen },
  { value: "cooking_baking", label: "בישול/אפיה", icon: Palette },
  { value: "music_playing_instrument", label: "מוזיקה/נגינה", icon: Languages },
  { value: "art_crafts", label: "אומנות/יצירה", icon: Palette },
  { value: "volunteering", label: "התנדבות", icon: Heart },
  { value: "learning_courses", label: "למידה/קורסים", icon: BookOpen },
  { value: "board_games_puzzles", label: "משחקי קופסא/פאזלים", icon: Smile },
  { value: "movies_theater", label: "סרטים/תיאטרון", icon: Smile },
  { value: "dancing", label: "ריקוד", icon: Users },
  { value: "writing", label: "כתיבה", icon: BookOpen },
  { value: "nature_hiking", label: "טבע/טיולים רגליים", icon: MapPin },
  { value: "photography", label: "צילום", icon: Palette },
];

const preferredMatchmakerGenderOptions = [
  { value: "MALE", label: "משדך" },
  { value: "FEMALE", label: "שדכנית" },
  { value: "NONE", label: "ללא העדפה" },
];

interface ProfileSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  setIsEditing: (value: boolean) => void;
  viewOnly?: boolean;
  onSave: (data: Partial<UserProfile>) => void;
}

const ensureDateObject = (
  value: string | number | Date | null | undefined
): Date | undefined => {
  if (!value) return undefined;
  if (value instanceof Date && !isNaN(value.getTime())) {
    return value;
  }
  if (typeof value === "string" || typeof value === "number") {
    const date = new Date(value);
    if (!isNaN(date.getTime())) {
      return date;
    }
  }
  return undefined;
};

const ProfileSection: React.FC<ProfileSectionProps> = ({
  profile: profileProp,
  isEditing,
  setIsEditing,
  viewOnly = false,
  onSave,
}) => {
  const [formData, setFormData] = useState<Partial<UserProfile>>({});
  const [loading, setLoading] = useState(true);
  const [initialData, setInitialData] = useState<Partial<UserProfile>>({});

  const initializeFormData = (profileData: UserProfile | null) => {
    const dataToSet: Partial<UserProfile> = {
      gender: profileData?.gender || undefined,
      birthDate: ensureDateObject(profileData?.birthDate),
      nativeLanguage: profileData?.nativeLanguage || undefined,
      additionalLanguages: profileData?.additionalLanguages || [],
      height: profileData?.height ?? undefined,
      maritalStatus: profileData?.maritalStatus || undefined,
      occupation: profileData?.occupation || "",
      education: profileData?.education || "",
      educationLevel: profileData?.educationLevel || undefined,
      city: profileData?.city || "",
      origin: profileData?.origin || "",
      religiousLevel: profileData?.religiousLevel || undefined,
      about: profileData?.about || "",
      parentStatus: profileData?.parentStatus || undefined,
      siblings: profileData?.siblings ?? undefined,
      position: profileData?.position ?? undefined,
      isProfileVisible: profileData?.isProfileVisible ?? true,
      preferredMatchmakerGender:
        profileData?.preferredMatchmakerGender || undefined,
      availabilityStatus:
        profileData?.availabilityStatus || AvailabilityStatus.AVAILABLE,
      availabilityNote: profileData?.availabilityNote || "",
      availabilityUpdatedAt: ensureDateObject(
        profileData?.availabilityUpdatedAt
      ),
      matchingNotes: profileData?.matchingNotes || "",
      shomerNegiah: profileData?.shomerNegiah ?? undefined,
      serviceType: profileData?.serviceType || undefined,
      serviceDetails: profileData?.serviceDetails || "",
      headCovering: profileData?.headCovering || undefined,
      kippahType: profileData?.kippahType || undefined,
      hasChildrenFromPrevious:
        profileData?.hasChildrenFromPrevious ?? undefined,
      profileCharacterTraits: profileData?.profileCharacterTraits || [],
      profileHobbies: profileData?.profileHobbies || [],
      aliyaCountry: profileData?.aliyaCountry || "",
      aliyaYear: profileData?.aliyaYear ?? undefined,
      preferredAgeMin: profileData?.preferredAgeMin ?? undefined,
      preferredAgeMax: profileData?.preferredAgeMax ?? undefined,
      preferredHeightMin: profileData?.preferredHeightMin ?? undefined,
      preferredHeightMax: profileData?.preferredHeightMax ?? undefined,
      preferredReligiousLevels: profileData?.preferredReligiousLevels || [],
      preferredLocations: profileData?.preferredLocations || [],
      preferredEducation: profileData?.preferredEducation || [],
      preferredOccupations: profileData?.preferredOccupations || [],
      contactPreference: profileData?.contactPreference || undefined,
      id: profileData?.id,
      userId: profileData?.userId,
      createdAt: ensureDateObject(profileData?.createdAt),
      updatedAt: ensureDateObject(profileData?.updatedAt),
      lastActive: ensureDateObject(profileData?.lastActive),
    };
    setFormData(dataToSet);
    setInitialData(dataToSet);
  };

  useEffect(() => {
    setLoading(true);
    if (profileProp) {
      initializeFormData(profileProp);
      setLoading(false);
    } else {
      const fetchProfileAndInitialize = async () => {
        try {
          const response = await fetch("/api/profile");
          if (!response.ok) throw new Error("Failed to fetch profile");
          const data = await response.json();
          if (data.success && data.profile) {
            initializeFormData(data.profile);
          } else {
            initializeFormData(null);
          }
        } catch (error) {
          console.error("Failed to fetch profile:", error);
          initializeFormData(null);
        } finally {
          setLoading(false);
        }
      };
      fetchProfileAndInitialize();
    }
  }, [profileProp]);

  const handleChange = (
    field: keyof UserProfile,
    value:
      | UserProfile[keyof UserProfile]
      | string
      | number
      | boolean
      | Date
      | string[]
      | null
  ) => {
    setFormData((prev) => {
      let finalValue: UserProfile[keyof UserProfile] | undefined = undefined;

      if (
        field === "height" ||
        field === "siblings" ||
        field === "position" ||
        field === "aliyaYear" ||
        field === "preferredAgeMin" ||
        field === "preferredAgeMax" ||
        field === "preferredHeightMin" ||
        field === "preferredHeightMax"
      ) {
        const rawValue = value as string | number;
        if (rawValue === "" || rawValue === null || rawValue === undefined) {
          finalValue = undefined;
        } else {
          const parsed = parseInt(String(rawValue), 10);
          finalValue = !isNaN(parsed)
            ? (parsed as UserProfile[typeof field])
            : undefined;
        }
      } else if (field === "birthDate") {
        finalValue = ensureDateObject(
          value as string | Date | null | undefined
        ) as UserProfile[typeof field];
      } else if (
        typeof prev[field] === "boolean" ||
        field === "shomerNegiah" ||
        field === "hasChildrenFromPrevious" ||
        field === "isProfileVisible"
      ) {
        finalValue = value as boolean as UserProfile[typeof field];
      } else if (Array.isArray(prev[field])) {
        finalValue = value as string[] as UserProfile[typeof field];
      } else if (value === "" || value === null) {
        const nullableStringFields: (keyof UserProfile)[] = [
          "nativeLanguage",
          "occupation",
          "education",
          "city",
          "origin",
          "religiousLevel",
          "about",
          "parentStatus",
          "serviceDetails",
          "aliyaCountry",
          "availabilityNote",
          "matchingNotes",
          "educationLevel",
          "maritalStatus",
          "serviceType",
          "headCovering",
          "kippahType",
          "preferredMatchmakerGender",
          "contactPreference",
        ];
        if (nullableStringFields.includes(field as keyof UserProfile)) {
          finalValue = undefined;
        } else {
          finalValue = value as UserProfile[typeof field];
        }
      } else {
        finalValue = value as UserProfile[typeof field];
      }

      return {
        ...prev,
        [field]: finalValue,
      };
    });
  };

  const handleMultiSelectToggle = (
    field: keyof UserProfile,
    optionValue: string
  ) => {
    setFormData((prev) => {
      const currentValues = (prev[field] as string[]) || [];
      const newValues = currentValues.includes(optionValue)
        ? currentValues.filter((v) => v !== optionValue)
        : [...currentValues, optionValue];
      return { ...prev, [field]: newValues };
    });
  };

  const handleSave = () => {
    if (formData.about && formData.about.trim().length < 100) {
      toast.error("שגיאת ולידציה", {
        description: 'השדה "קצת עליי" חייב להכיל לפחות 100 תווים.',
        duration: 5000,
      });
      return;
    }
    const dataToSave = { ...formData };
    onSave(dataToSave);
    setIsEditing(false);
    setInitialData(dataToSave);
  };

  const handleCancel = () => {
    setFormData(initialData);
    setIsEditing(false);
  };

  const renderDisplayValue = (
    value: string | number | Date | undefined | null,
    placeholder: string = "לא צוין"
  ) => {
    if (value === undefined || value === null || value === "") {
      return <span className="italic text-gray-500">{placeholder}</span>;
    }
    if (value instanceof Date && !isNaN(value.getTime())) {
      return new Intl.DateTimeFormat("he-IL").format(value);
    }
    return String(value);
  };

  const renderSelectDisplayValue = (
    value: string | undefined | null,
    options: { value: string; label: string }[],
    placeholder: string = "לא צוין"
  ) => {
    if (!value) {
      return <span className="italic text-gray-500">{placeholder}</span>;
    }
    const option = options.find((opt) => opt.value === value);
    return option ? (
      option.label
    ) : (
      <span className="italic text-gray-500">{placeholder}</span>
    );
  };

  const renderBooleanDisplayValue = (
    value: boolean | undefined | null,
    trueLabel: string = "כן",
    falseLabel: string = "לא",
    placeholder: string = "לא צוין"
  ) => {
    if (value === undefined || value === null) {
      return <span className="italic text-gray-500">{placeholder}</span>;
    }
    return value ? trueLabel : falseLabel;
  };

  if (loading) {
    return <div className="text-center p-4">טוען נתוני פרופיל...</div>;
  }

  const renderMultiSelectBadges = (
    fieldValues: string[] | undefined,
    options: { value: string; label: string; icon?: React.ElementType }[],
    emptyPlaceholder: string = "לא נבחרו פריטים."
  ) => {
    if (!fieldValues || fieldValues.length === 0) {
      return <p className="text-sm text-gray-500 italic">{emptyPlaceholder}</p>;
    }
    return fieldValues.map((value) => {
      const option = options.find((opt) => opt.value === value);
      return option ? (
        <Badge
          key={value}
          variant="secondary"
          className="mr-1 mb-1 bg-sky-100 text-sky-700 text-xs px-2 py-0.5 rounded-full"
        >
          {option.icon && <option.icon className="w-3 h-3 mr-1" />}
          {option.label}
        </Badge>
      ) : null;
    });
  };

  return (
    <div className="relative" dir="rtl">
      <div className="sticky top-0 z-10 bg-gradient-to-b from-white via-white/95 to-white/0 pt-4 pb-3 backdrop-blur-sm">
        <div className="container mx-auto max-w-screen-xl px-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-xl md:text-2xl font-bold text-slate-800">
                פרופיל אישי
              </h1>
              <p className="text-sm text-slate-500">
                {isEditing && !viewOnly
                  ? "ערוך/י את פרטי הפרופיל שלך."
                  : "פרטי הפרופיל של המועמד/ת."}
              </p>
            </div>
            {!viewOnly && (
              <div className="flex gap-2">
                {!isEditing ? (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setIsEditing(true)}
                    className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-cyan-400 text-cyan-700 hover:bg-cyan-50"
                  >
                    <Pencil className="w-3.5 h-3.5 ml-1.5" />
                    עריכה
                  </Button>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleCancel}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-gray-300 text-gray-700 hover:bg-gray-50"
                    >
                      <X className="w-3.5 h-3.5 ml-1.5" />
                      ביטול
                    </Button>
                    <Button
                      variant="default"
                      size="sm"
                      onClick={handleSave}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 bg-cyan-600 hover:bg-cyan-700 text-white"
                    >
                      <Save className="w-3.5 h-3.5 ml-1.5" />
                      שמירה
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="container mx-auto max-w-screen-xl py-6 px-4">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div className="space-y-6">
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-cyan-50/40 to-pink-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <UserCircle className="w-5 h-5 text-cyan-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  פרטים אישיים ודמוגרפיים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מגדר
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.gender || ""}
                        onValueChange={(value) =>
                          handleChange("gender", value as Gender)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י מגדר" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="MALE">זכר</SelectItem>
                          <SelectItem value="FEMALE">נקבה</SelectItem>
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.gender === "MALE"
                            ? "זכר"
                            : formData.gender === "FEMALE"
                            ? "נקבה"
                            : undefined
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      תאריך לידה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="date"
                        value={
                          formData.birthDate instanceof Date &&
                          !isNaN(formData.birthDate.getTime())
                            ? formData.birthDate.toISOString().split("T")[0]
                            : ""
                        }
                        onChange={(e) =>
                          handleChange("birthDate", e.target.value || undefined)
                        }
                        className="h-9 text-sm focus:ring-cyan-500"
                        max={new Date().toISOString().split("T")[0]}
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.birthDate)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      גובה (סמ)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.height ?? ""}
                        onChange={(e) => handleChange("height", e.target.value)}
                        className="h-9 text-sm focus:ring-cyan-500"
                        placeholder="גובה בסמ"
                        min="100"
                        max="250"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.height ? `${formData.height} ס"מ` : undefined
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      עיר מגורים
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.city || ""}
                        onChange={(e) => handleChange("city", e.target.value)}
                        placeholder="לדוגמה: ירושלים"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.city)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מוצא / עדה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.origin || ""}
                        onChange={(e) => handleChange("origin", e.target.value)}
                        placeholder="לדוגמה: אשכנזי, ספרדי"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.origin)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      עלה/תה לארץ
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.aliyaCountry || ""}
                        onChange={(e) =>
                          handleChange("aliyaCountry", e.target.value)
                        }
                        placeholder="אם רלוונטי, מאיזו מדינה?"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.aliyaCountry,
                          "לא רלוונטי"
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שנת עליה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.aliyaYear ?? ""}
                        onChange={(e) =>
                          handleChange("aliyaYear", e.target.value)
                        }
                        disabled={!formData.aliyaCountry}
                        placeholder="אם רלוונטי"
                        className="h-9 text-sm focus:ring-cyan-500"
                        min="1900"
                        max={new Date().getFullYear()}
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.aliyaYear,
                          formData.aliyaCountry ? "לא צוינה שנה" : "לא רלוונטי"
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שפת אם
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.nativeLanguage || ""}
                        onValueChange={(value) =>
                          handleChange("nativeLanguage", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י שפת אם" />
                        </SelectTrigger>
                        <SelectContent className="max-h-[200px]">
                          {languageOptions.map((lang) => (
                            <SelectItem key={lang.value} value={lang.value}>
                              {lang.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.nativeLanguage,
                          languageOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2 lg:col-span-1">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שפות נוספות
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        onValueChange={(value) => {
                          const currentLanguages =
                            formData.additionalLanguages || [];
                          if (!currentLanguages.includes(value)) {
                            handleChange("additionalLanguages", [
                              ...currentLanguages,
                              value,
                            ]);
                          }
                        }}
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="הוסף/י שפה..." />
                        </SelectTrigger>
                        <SelectContent className="max-h-[200px]">
                          {languageOptions
                            .filter(
                              (lang) =>
                                !(formData.additionalLanguages || []).includes(
                                  lang.value
                                ) && lang.value !== formData.nativeLanguage
                            )
                            .map((lang) => (
                              <SelectItem key={lang.value} value={lang.value}>
                                {lang.label}
                              </SelectItem>
                            ))}
                        </SelectContent>
                      </Select>
                    ) : null}
                    <div className="mt-2 flex flex-wrap gap-1.5">
                      {(formData.additionalLanguages || []).map((langValue) => {
                        const lang = languageOptions.find(
                          (l) => l.value === langValue
                        );
                        return lang ? (
                          <Badge
                            key={lang.value}
                            variant="secondary"
                            className="bg-cyan-100/70 text-cyan-800 px-2 py-0.5 rounded-full text-[11px] font-medium flex items-center"
                          >
                            {lang.label}
                            {isEditing && !viewOnly && (
                              <button
                                type="button"
                                onClick={() =>
                                  handleChange(
                                    "additionalLanguages",
                                    (formData.additionalLanguages || []).filter(
                                      (l) => l !== langValue
                                    )
                                  )
                                }
                                className="mr-1.5 text-cyan-600 hover:text-cyan-800 text-xs"
                                aria-label={`הסר ${lang.label}`}
                              >
                                ×
                              </button>
                            )}
                          </Badge>
                        ) : null;
                      })}
                      {(!isEditing || viewOnly) &&
                        (!formData.additionalLanguages ||
                          formData.additionalLanguages.length === 0) && (
                          <p className="text-sm text-gray-500 italic">
                            לא צוינו שפות נוספות.
                          </p>
                        )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-purple-50/40 to-indigo-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Users className="w-5 h-5 text-purple-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  מצב משפחתי ורקע
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-5 items-start">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מצב משפחתי
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.maritalStatus || ""}
                        onValueChange={(value) =>
                          handleChange("maritalStatus", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י מצב" />
                        </SelectTrigger>
                        <SelectContent>
                          {maritalStatusOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.maritalStatus,
                          maritalStatusOptions
                        )}
                      </p>
                    )}
                  </div>
                  {(formData.maritalStatus === "divorced" ||
                    formData.maritalStatus === "widowed" ||
                    formData.maritalStatus === "annulled") && (
                    <div
                      className={cn(
                        "pt-1 sm:pt-0",
                        isEditing && !viewOnly ? "sm:pt-5" : "sm:pt-0"
                      )}
                    >
                      <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                        ילדים מקשר קודם?
                      </Label>
                      {isEditing && !viewOnly ? (
                        <div className="flex items-center space-x-2 rtl:space-x-reverse mt-2">
                          <Checkbox
                            id="hasChildrenFromPrevious"
                            checked={formData.hasChildrenFromPrevious || false}
                            onCheckedChange={(checked) =>
                              handleChange(
                                "hasChildrenFromPrevious",
                                checked as boolean
                              )
                            }
                          />
                          <Label
                            htmlFor="hasChildrenFromPrevious"
                            className="text-sm font-normal text-gray-700"
                          >
                            יש ילדים
                          </Label>
                        </div>
                      ) : (
                        <p className="text-sm text-gray-800 font-medium mt-1">
                          {renderBooleanDisplayValue(
                            formData.hasChildrenFromPrevious
                          )}
                        </p>
                      )}
                    </div>
                  )}
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מצב הורים
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.parentStatus || ""}
                        onChange={(e) =>
                          handleChange("parentStatus", e.target.value)
                        }
                        placeholder="לדוגמה: נשואים, גרושים"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.parentStatus)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מספר אחים/אחיות
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.siblings ?? ""}
                        onChange={(e) =>
                          handleChange("siblings", e.target.value)
                        }
                        className="h-9 text-sm focus:ring-cyan-500"
                        placeholder="כולל אותך"
                        min="0"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.siblings)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מיקום במשפחה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.position ?? ""}
                        onChange={(e) =>
                          handleChange("position", e.target.value)
                        }
                        className="h-9 text-sm focus:ring-cyan-500"
                        placeholder="לדוגמה: 1 (בכור/ה)"
                        min="0"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.position)}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-yellow-50/40 to-amber-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <BookOpen className="w-5 h-5 text-amber-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  דת ואורח חיים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-5 items-start">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      רמה דתית
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.religiousLevel || ""}
                        onValueChange={(value) =>
                          handleChange("religiousLevel", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י רמה" />
                        </SelectTrigger>
                        <SelectContent className="max-h-[250px]">
                          {religiousLevelOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.religiousLevel,
                          religiousLevelOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div
                    className={cn(
                      "pt-1 sm:pt-0",
                      isEditing && !viewOnly ? "sm:pt-5" : "sm:pt-0"
                    )}
                  >
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שומר/ת נגיעה?
                    </Label>
                    {isEditing && !viewOnly ? (
                      <div className="flex items-center space-x-2 rtl:space-x-reverse mt-2">
                        <Checkbox
                          id="shomerNegiah"
                          checked={formData.shomerNegiah || false}
                          onCheckedChange={(checked) =>
                            handleChange("shomerNegiah", checked as boolean)
                          }
                        />
                        <Label
                          htmlFor="shomerNegiah"
                          className="text-sm font-normal text-gray-700"
                        >
                          כן
                        </Label>
                      </div>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderBooleanDisplayValue(formData.shomerNegiah)}
                      </p>
                    )}
                  </div>
                  {formData.gender === Gender.FEMALE && (
                    <div>
                      <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                        כיסוי ראש
                      </Label>
                      {isEditing && !viewOnly ? (
                        <Select
                          value={formData.headCovering || ""}
                          onValueChange={(value) =>
                            handleChange(
                              "headCovering",
                              (value as HeadCoveringType) || undefined
                            )
                          }
                        >
                          <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                            <SelectValue placeholder="בחר/י סוג כיסוי" />
                          </SelectTrigger>
                          <SelectContent>
                            {headCoveringOptions.map((opt) => (
                              <SelectItem key={opt.value} value={opt.value}>
                                {opt.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      ) : (
                        <p className="text-sm text-gray-800 font-medium mt-1">
                          {renderSelectDisplayValue(
                            formData.headCovering,
                            headCoveringOptions,
                            "ללא"
                          )}
                        </p>
                      )}
                    </div>
                  )}
                  {formData.gender === Gender.MALE && (
                    <div>
                      <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                        סוג כיפה
                      </Label>
                      {isEditing && !viewOnly ? (
                        <Select
                          value={formData.kippahType || ""}
                          onValueChange={(value) =>
                            handleChange(
                              "kippahType",
                              (value as KippahType) || undefined
                            )
                          }
                        >
                          <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                            <SelectValue placeholder="בחר/י סוג כיפה" />
                          </SelectTrigger>
                          <SelectContent className="max-h-[200px]">
                            {kippahTypeOptions.map((opt) => (
                              <SelectItem key={opt.value} value={opt.value}>
                                {opt.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      ) : (
                        <p className="text-sm text-gray-800 font-medium mt-1">
                          {renderSelectDisplayValue(
                            formData.kippahType,
                            kippahTypeOptions,
                            "ללא"
                          )}
                        </p>
                      )}
                    </div>
                  )}
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מגדר שדכן/ית מועדף
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.preferredMatchmakerGender || ""}
                        onValueChange={(value) =>
                          handleChange(
                            "preferredMatchmakerGender",
                            (value as Gender) || undefined
                          )
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י העדפה (לא חובה)" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="MALE">משדך</SelectItem>
                          <SelectItem value="FEMALE">שדכנית</SelectItem>
                          <SelectItem value="NONE">ללא העדפה</SelectItem>
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.preferredMatchmakerGender,
                          preferredMatchmakerGenderOptions,
                          "ללא העדפה"
                        )}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>

          <div className="space-y-6">
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-slate-50/40 to-gray-100/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Info className="w-5 h-5 text-slate-600" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  קצת עלי ומידע נוסף
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="space-y-6">
                  <div>
                  <div className="flex items-center gap-1.5 mb-2">
                    <Label htmlFor="about" className="text-sm font-medium text-gray-700">
                        ספר/י קצת על עצמך (תיאור חופשי)
                    </Label>
                    <TooltipProvider delayDuration={100}>
                        <Tooltip>
                            <TooltipTrigger type="button" className="text-gray-400 hover:text-gray-600">
                                <Info className="w-4 h-4" />
                            </TooltipTrigger>
                            <TooltipContent side="top" className="max-w-xs text-center">
                                <p>כאן המקום שלך לבלוט! ספר/י על התשוקות שלך, מה מצחיק אותך, ומה את/ה מחפש/ת. 
                                <br/>
                                <strong className="text-cyan-600">שים/י לב: נדרשים לפחות 100 תווים.</strong></p>
                            </TooltipContent>
                        </Tooltip>
                    </TooltipProvider>
                  </div>
                    {isEditing && !viewOnly ? (
                      <div>
                        <Textarea
                          id="about"
                          value={formData.about || ""}
                          onChange={(e) => handleChange("about", e.target.value)}
                          className={cn(
                            "text-sm focus:ring-cyan-500 min-h-[120px] rounded-lg",
                            formData.about && formData.about.trim().length < 100 ? "border-red-400 focus:ring-red-300" : ""
                          )}
                          placeholder="תאר/י את עצמך, מה מאפיין אותך, מה חשוב לך..."
                          rows={5}
                        />
                         {formData.about && (
                            <div className={cn(
                                "text-xs mt-1 text-right",
                                formData.about.trim().length < 100 ? "text-red-600" : "text-gray-500"
                            )}>
                                {formData.about.trim().length} / 100+ תווים
                            </div>
                         )}
                      </div>
                    ) : (
                      <p className="mt-1 text-sm text-gray-700 whitespace-pre-wrap min-h-[60px] bg-slate-50/70 p-3 rounded-lg border border-slate-200/50">
                        {formData.about || (
                          <span className="text-gray-500 italic">
                            לא הוזן תיאור אישי.
                          </span>
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                   <div className="flex items-center gap-1.5 mb-2">
                    <Label className="text-sm font-medium text-gray-700">
                        הערות נוספות לשדכן/ית (לא יוצג לצד השני)
                    </Label>
                    <TooltipProvider delayDuration={100}>
                        <Tooltip>
                        <TooltipTrigger type="button" className="text-gray-400 hover:text-gray-600">
                            <Info className="w-4 h-4" />
                        </TooltipTrigger>
                        <TooltipContent side="top" className="max-w-xs text-center">
                            <p>מידע שחשוב לנו לדעת כדי למצוא התאמה טובה, אך לא תרצה/י שיופיע בפרופיל הגלוי. למשל: נושאים רגישים, העדפות ספציפיות מאוד, או רקע נוסף.</p>
                        </TooltipContent>
                        </Tooltip>
                    </TooltipProvider>
                    </div>
                    {isEditing && !viewOnly ? (
                      <Textarea
                        value={formData.matchingNotes || ""}
                        onChange={(e) =>
                          handleChange("matchingNotes", e.target.value)
                        }
                        className="text-sm focus:ring-cyan-500 min-h-[90px] rounded-lg"
                        placeholder="דברים נוספים שחשוב שהשדכן/ית יידעו עליך..."
                        rows={3}
                      />
                    ) : (
                      <p className="mt-1 text-sm text-gray-700 whitespace-pre-wrap min-h-[50px] bg-slate-50/70 p-3 rounded-lg border border-slate-200/50">
                        {formData.matchingNotes || (
                          <span className="text-gray-500 italic">
                            אין הערות נוספות לשדכן/ית.
                          </span>
                        )}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-teal-50/40 to-green-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Briefcase className="w-5 h-5 text-teal-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  השכלה, עיסוק ושירות
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      רמת השכלה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.educationLevel || ""}
                        onValueChange={(value) =>
                          handleChange("educationLevel", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י רמה" />
                        </SelectTrigger>
                        <SelectContent>
                          {educationLevelOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.educationLevel,
                          educationLevelOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      פירוט השכלה (מוסד, תחום)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.education || ""}
                        onChange={(e) =>
                          handleChange("education", e.target.value)
                        }
                        placeholder="לדוגמה: אוני' בר אילן, משפטים"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.education)}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      עיסוק נוכחי
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.occupation || ""}
                        onChange={(e) =>
                          handleChange("occupation", e.target.value)
                        }
                        placeholder="לדוגמה: מורה, מהנדס תוכנה"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.occupation)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שירות (צבאי/לאומי/אחר)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.serviceType || ""}
                        onValueChange={(value) =>
                          handleChange(
                            "serviceType",
                            (value as ServiceType) || undefined
                          )
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י סוג שירות" />
                        </SelectTrigger>
                        <SelectContent className="max-h-[250px]">
                          {serviceTypeOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.serviceType,
                          serviceTypeOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      פירוט על השירות
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.serviceDetails || ""}
                        onChange={(e) =>
                          handleChange("serviceDetails", e.target.value)
                        }
                        placeholder="חיל, יחידה, תפקיד, שם ישיבה/מכינה"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.serviceDetails)}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-amber-50/40 to-yellow-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Smile className="w-5 h-5 text-amber-600" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  תכונות אופי ותחביבים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-sm font-medium text-gray-700">
                    תכונות אופי בולטות (עד 3)
                  </Label>
                  {isEditing && !viewOnly ? (
                    <div className="flex flex-wrap gap-2">
                      {characterTraitsOptions.map((trait) => (
                        <Button
                          key={trait.value}
                          type="button"
                          variant={
                            (formData.profileCharacterTraits || []).includes(
                              trait.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectToggle(
                              "profileCharacterTraits",
                              trait.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.profileCharacterTraits || []).length >=
                              3 &&
                            !(formData.profileCharacterTraits || []).includes(
                              trait.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all", 
                            (formData.profileCharacterTraits || []).includes(
                              trait.value
                            )
                              ? "bg-amber-500 hover:bg-amber-600 text-white border-amber-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {trait.icon && (
                            <trait.icon className="w-3.5 h-3.5 ml-1.5 rtl:mr-1.5 rtl:ml-0" />
                          )}
                          {trait.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.profileCharacterTraits,
                        characterTraitsOptions,
                        "לא נבחרו תכונות אופי."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-sm font-medium text-gray-700">
                    תחביבים עיקריים (עד 3)
                  </Label>
                  {isEditing && !viewOnly ? (
                    <div className="flex flex-wrap gap-2">
                      {hobbiesOptions.map((hobby) => (
                        <Button
                          key={hobby.value}
                          type="button"
                          variant={
                            (formData.profileHobbies || []).includes(
                              hobby.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectToggle(
                              "profileHobbies",
                              hobby.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.profileHobbies || []).length >= 3 &&
                            !(formData.profileHobbies || []).includes(
                              hobby.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.profileHobbies || []).includes(
                              hobby.value
                            )
                              ? "bg-sky-500 hover:bg-sky-600 text-white border-sky-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {hobby.icon && (
                            <hobby.icon className="w-3.5 h-3.5 ml-1.5 rtl:mr-1.5 rtl:ml-0" />
                          )}
                          {hobby.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.profileHobbies,
                        hobbiesOptions,
                        "לא נבחרו תחביבים."
                      )}
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ProfileSection;
--- End of Content for ProfileSection.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\QuestionnaireResponsesSection.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/profile/sections/QuestionnaireResponsesSection.tsx

import React, { useState, useMemo, useEffect } from "react"; // Added useEffect
import Link from "next/link";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import {
  Book,
  CheckCircle,
  Clock,
  Pencil,
  X,
  Save,
  Eye,
  EyeOff,
  Loader2,
  ArrowRight,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type {
  QuestionnaireResponse,
  FormattedAnswer,
  UpdateValue,
} from "@/types/next-auth";

import { WORLDS } from "../constants";

// --- קבוע עבור כתובת השאלון ---
const QUESTIONNAIRE_URL = "/questionnaire"; // שימוש בנתיב יחסי אם האפליקציה רצה באותו דומיין
// אם אתה צריך את הכתובת המלאה (פחות מומלץ אם זה באותו אתר):
// const QUESTIONNAIRE_URL = "http://localhost:3000/questionnaire";

interface QuestionnaireResponsesSectionProps {
  questionnaire: QuestionnaireResponse | null;
  onUpdate?: (
    world: string,
    questionId: string,
    value: UpdateValue
  ) => Promise<void>;
  isEditable?: boolean;
  isFirstInList?: boolean;
  viewMode?: "matchmaker" | "candidate";
}

// --- QuestionCard Component ---
interface QuestionCardProps {
  question: string;
  answer: FormattedAnswer;
  isEditingGlobally: boolean;
  worldKey: string;
  onUpdate: (
    world: string,
    questionId: string,
    value: UpdateValue
  ) => Promise<void>;
  isFirstInList?: boolean;
}

const QuestionCard: React.FC<QuestionCardProps> = ({
  question,
  answer,
  isEditingGlobally,
  worldKey,
  onUpdate,
  isFirstInList,
}) => {
  const [isEditingText, setIsEditingText] = useState(false);
  const [editValue, setEditValue] = useState(answer.displayText);
  const [isSavingText, setIsSavingText] = useState(false);
  const [isSavingVisibility, setIsSavingVisibility] = useState(false);

  // --- START OF MODIFIED SECTION ---
  // Local state for optimistic UI update of visibility
  const [currentIsVisible, setCurrentIsVisible] = useState(
    answer.isVisible ?? true
  );

  // Sync local state if the prop changes (e.g., due to parent update or initial load)
  useEffect(() => {
    setCurrentIsVisible(answer.isVisible ?? true);
  }, [answer.isVisible]);
  // --- END OF MODIFIED SECTION ---

  const isSaving = isSavingText || isSavingVisibility;

  const handleStartEdit = () => {
    if (isSaving) return;
    setIsEditingText(true);
    setEditValue(answer.displayText);
  };

  const handleSaveText = async () => {
    if (!editValue?.trim()) {
      toast.error("לא ניתן לשמור תשובה ריקה.");
      return;
    }
    if (editValue.trim() === answer.displayText) {
      setIsEditingText(false);
      return;
    }

    setIsSavingText(true);
    try {
      await onUpdate(worldKey, answer.questionId, {
        type: "answer",
        value: editValue.trim(),
      });
      toast.success("התשובה עודכנה בהצלחה");
      setIsEditingText(false);
      // No need to update editValue here, as parent will re-render with new answer prop
    } catch (error) {
      console.error("Error updating answer:", error);
      toast.error("שגיאה בעדכון התשובה");
    } finally {
      setIsSavingText(false);
    }
  };

  const handleCancelEdit = () => {
    setIsEditingText(false);
    setEditValue(answer.displayText);
  };

  const handleVisibilityChange = async (newIsVisibleState: boolean) => {
    // --- START OF MODIFIED SECTION ---
    // Optimistically update the local UI state
    setCurrentIsVisible(newIsVisibleState);
    // --- END OF MODIFIED SECTION ---
    setIsSavingVisibility(true);
    try {
      await onUpdate(worldKey, answer.questionId, {
        type: "visibility",
        isVisible: newIsVisibleState,
      });
      toast.success("הגדרות הנראות עודכנו");
      // If successful, the parent should eventually re-render with the updated answer.isVisible,
      // and the useEffect will sync if needed, but currentIsVisible is already correct.
    } catch (error) {
      console.error("Error updating visibility:", error);
      toast.error("שגיאה בעדכון הנראות");
      // --- START OF MODIFIED SECTION ---
      // Revert optimistic update on error
      setCurrentIsVisible(answer.isVisible ?? true);
      // --- END OF MODIFIED SECTION ---
    } finally {
      setIsSavingVisibility(false);
    }
  };

  // --- START OF MODIFIED SECTION ---
  // Update visibilityLabel to use currentIsVisible
  const visibilityLabel = `הצג תשובה זו למועמדים: ${
    currentIsVisible ? "מופעל" : "כבוי"
  }`;
  // --- END OF MODIFIED SECTION ---

  return (
    <div className="rounded-lg border bg-card p-4 shadow-sm transition-shadow duration-300 hover:shadow-md">
      <div className="flex items-start justify-between gap-4">
        <div className="flex-1 min-w-0">
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-3 gap-2">
            <h4 className="font-medium text-sm sm:text-base flex-1 text-right">
              {question}
            </h4>
            <div
              className="flex items-center gap-2 self-end sm:self-center"
              dir="ltr"
            >
              {isSavingVisibility && (
                <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
              )}
              <TooltipProvider delayDuration={200}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div
                      className={cn(
                        "flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs shrink-0 flex-row-reverse",
                        "transition-colors duration-200",
                        // --- START OF MODIFIED SECTION ---
                        currentIsVisible // Use currentIsVisible for styling
                          ? // --- END OF MODIFIED SECTION ---
                            "bg-emerald-100/70 text-emerald-800"
                          : "bg-gray-100 text-gray-600"
                      )}
                    >
                      {/* --- START OF MODIFIED SECTION --- */}
                      {currentIsVisible ? ( // Use currentIsVisible for icon and text
                        <Eye className="h-3.5 w-3.5" />
                      ) : (
                        <EyeOff className="h-3.5 w-3.5" />
                      )}
                      <span className="font-medium whitespace-nowrap" dir="rtl">
                        {currentIsVisible ? "גלוי למועמדים" : "מוסתר"}
                      </span>
                      {/* --- END OF MODIFIED SECTION --- */}
                    </div>
                  </TooltipTrigger>
                  <TooltipContent side="top" dir="rtl">
                    <p>
                      {/* --- START OF MODIFIED SECTION --- */}
                      {currentIsVisible // Use currentIsVisible for tooltip content
                        ? // --- END OF MODIFIED SECTION ---
                          "תשובה זו גלויה למועמדים פוטנציאליים"
                        : "תשובה זו מוסתרת וגלויה רק לך ולשדכנים"}
                    </p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>

              {isEditingGlobally && (
                <div id={isFirstInList ? 'onboarding-target-visibility-control' : undefined}>
                <Switch
                  // --- START OF MODIFIED SECTION ---
                  checked={currentIsVisible} // Control Switch with local state
                  // --- END OF MODIFIED SECTION ---
                  onCheckedChange={handleVisibilityChange}
                  disabled={isSaving}
                  className="data-[state=checked]:bg-emerald-500 data-[state=unchecked]:bg-gray-300 transform scale-90"
                  aria-label={visibilityLabel}
                />
                </div>
              )}
            </div>
          </div>

          {isEditingText ? (
            <div className="space-y-2 mt-1">
              <Textarea
                value={editValue}
                onChange={(e) => setEditValue(e.target.value)}
                className="min-h-[80px] text-sm focus:ring-cyan-500 focus:border-cyan-500"
                placeholder="הקלד/י את תשובתך כאן..."
                disabled={isSavingText}
              />
              <div className="flex justify-end gap-2">
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={handleCancelEdit}
                  disabled={isSavingText}
                  className="text-gray-600 hover:bg-gray-100"
                >
                  <X className="h-4 w-4 ml-1" />
                  ביטול
                </Button>
                <Button
                  size="sm"
                  onClick={handleSaveText}
                  disabled={isSavingText || !editValue?.trim()}
                  className="bg-cyan-600 hover:bg-cyan-700 text-white"
                >
                  {isSavingText ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <CheckCircle className="h-4 w-4 ml-1" />
                  )}
                  שמירה
                </Button>
              </div>
            </div>
          ) : (
            <div className="relative group overflow-hidden mt-1">
              <div className="p-3 bg-gray-50/50 rounded-md border border-gray-200/60 min-h-[40px]">
                <p className="text-sm text-gray-800 break-words overflow-wrap-anywhere whitespace-pre-wrap">
                  {answer.displayText}
                </p>
                <TooltipProvider delayDuration={200}>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <span className="text-xs text-gray-400 block mt-2 text-left">
                        {new Date(answer.answeredAt).toLocaleDateString(
                          "he-IL",
                          { year: "numeric", month: "2-digit", day: "2-digit" }
                        )}
                      </span>
                    </TooltipTrigger>
                    <TooltipContent side="top" dir="rtl">
                      <p>תאריך עדכון אחרון</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              {isEditingGlobally && !isSaving && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="absolute top-0 right-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200 h-7 w-7 text-cyan-600 hover:bg-cyan-50"
                  onClick={handleStartEdit}
                  title="עריכת תשובה"
                >
                  <Pencil className="h-4 w-4" />
                  <span className="sr-only">עריכת תשובה</span>
                </Button>
              )}
              {isSavingText && !isEditingText && (
                <div className="absolute top-1 right-1">
                  <Loader2 className="h-4 w-4 animate-spin text-cyan-500" />
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

// --- WorldSection Component ---
// (ללא שינוי)
interface WorldSectionProps {
  worldKey: keyof typeof WORLDS;
  worldConfig: (typeof WORLDS)[keyof typeof WORLDS];
  answers: FormattedAnswer[];
  isEditingGlobally: boolean;
  onUpdate: (
    world: string,
    questionId: string,
    value: UpdateValue
  ) => Promise<void>;
  isCompleted: boolean;
  className?: string;
}

const WorldSection: React.FC<WorldSectionProps> = ({
  worldKey,
  worldConfig,
  answers,
  isEditingGlobally,
  onUpdate,
  isCompleted,
  className,
}) => {
  const { title, icon: Icon, color, bgColor, borderColor } = worldConfig;

  return (
    <Card
      className={cn(
        "overflow-hidden shadow-sm border",
        bgColor,
        borderColor,
        className
      )}
    >
      <CardHeader
        className="p-4 border-b"
        style={{
          borderColor: `rgba(var(--${color.split("-")[1]}-200-rgb), 0.5)`,
        }}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div
              className={cn(
                "p-2 rounded-full",
                color.replace("text-", "bg-") + "/10"
              )}
            >
              <Icon className={cn("h-5 w-5", color)} />
            </div>
            <div>
              <CardTitle className="text-md sm:text-lg text-gray-800">
                {title}
              </CardTitle>
              <CardDescription className="text-xs text-gray-500 mt-0.5">
                {answers.length} {answers.length === 1 ? "תשובה" : "תשובות"}
              </CardDescription>
            </div>
          </div>
          <Badge
            variant={isCompleted ? "success" : "secondary"}
            className={cn(
              "gap-1 text-xs px-2 py-0.5 rounded-full",
              isCompleted
                ? "bg-emerald-100 text-emerald-800"
                : "bg-blue-100 text-blue-800"
            )}
          >
            {isCompleted ? (
              <CheckCircle className="h-3 w-3" />
            ) : (
              <Clock className="h-3 w-3" />
            )}
            {isCompleted ? "הושלם" : "בתהליך"}
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-4">
        <div className="space-y-4">
          {answers.map((answer, index) => (
            <QuestionCard
              key={answer.questionId}
              question={answer.question}
              answer={answer}
              isFirstInList={index === 0}
              isEditingGlobally={isEditingGlobally}
              worldKey={worldKey}
              onUpdate={onUpdate}
              
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

// --- QuestionnaireResponsesSection Component ---
const QuestionnaireResponsesSection: React.FC<
  QuestionnaireResponsesSectionProps
> = ({ questionnaire, onUpdate, isEditable = false }) => {
  const [isEditingGlobally, setIsEditingGlobally] = useState(false);

  const worldsWithAnswers = useMemo(() => {
    if (!questionnaire?.formattedAnswers) return [];
    return Object.entries(WORLDS)
      .map(([key, config]) => ({
        key: key as keyof typeof WORLDS,
        config,
        answers:
          questionnaire.formattedAnswers?.[
            key as keyof typeof questionnaire.formattedAnswers
          ] ?? [],
        isCompleted:
          (questionnaire[
            `${key}Completed` as keyof QuestionnaireResponse
          ] as boolean) ?? false,
      }))
      .filter((world) => world.answers.length > 0);
  }, [questionnaire]);

  if (!questionnaire) {
    return (
      <Card className="text-center py-12 text-gray-500 bg-gray-50 rounded-lg border border-dashed">
        <Book className="h-10 w-10 mx-auto mb-3 opacity-50 text-gray-400" />
        <p className="font-medium">לא מולא שאלון עבור פרופיל זה.</p>
        <p className="text-sm mt-1">אין תשובות להציג.</p>
        <div className="mt-6">
          <Button
            asChild
            variant="default"
            className="bg-cyan-600 hover:bg-cyan-700"
          >
            <Link
              href={QUESTIONNAIRE_URL}
              className="flex items-center gap-1.5"
            >
              מלא את השאלון
              <ArrowRight className="h-4 w-4" />
            </Link>
          </Button>
        </div>
      </Card>
    );
  }

  const hasAnyAnswers = worldsWithAnswers.length > 0;

  return (
    <div className="space-y-6">
      <Card className="shadow-sm border">
        <CardHeader className="p-4">
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
            <div className="flex items-center gap-3">
              {questionnaire.completed ? (
                <CheckCircle className="h-5 w-5 text-emerald-500 flex-shrink-0" />
              ) : (
                <Clock className="h-5 w-5 text-blue-500 flex-shrink-0" />
              )}
              <div>
                <p className="font-semibold text-base text-gray-800">
                  {questionnaire.completed ? "שאלון הושלם" : "שאלון בתהליך"}
                </p>
                <p className="text-xs text-gray-500 mt-0.5">
                  {hasAnyAnswers
                    ? `עודכן לאחרונה: ${new Date(
                        questionnaire.lastSaved
                      ).toLocaleDateString("he-IL")}`
                    : "השאלון טרם החל"}
                </p>
              </div>
            </div>

            <div className="flex flex-col sm:flex-row items-center gap-2 self-end sm:self-center">
              <Button
                asChild
                variant="outline"
                size="sm"
                className="rounded-full px-4 py-2 text-xs sm:text-sm"
              >
                <Link
                  href={QUESTIONNAIRE_URL}
                  className="flex items-center gap-1.5"
                >
                  עבור לשאלון
                  <ArrowRight className="h-4 w-4" />
                </Link>
              </Button>
              {isEditable && hasAnyAnswers && onUpdate && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setIsEditingGlobally(!isEditingGlobally)}
                  className="gap-1.5 rounded-full px-4 py-2 text-xs sm:text-sm"
                >
                  {isEditingGlobally ? (
                    <>
                      <Save className="h-4 w-4" />
                      סיום עריכה
                    </>
                  ) : (
                    <>
                      <Pencil className="h-4 w-4" />
                      עריכת תשובות
                    </>
                  )}
                </Button>
              )}
            </div>
          </div>
        </CardHeader>
      </Card>

      {hasAnyAnswers ? (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {worldsWithAnswers.map(({ key, config, answers, isCompleted }) => (
            <WorldSection
              key={key}
              worldKey={key}
              worldConfig={config}
              answers={answers}
              isEditingGlobally={isEditingGlobally}
              onUpdate={onUpdate!}
              isCompleted={isCompleted}
            />
          ))}
        </div>
      ) : (
        <div className="text-center py-10 text-gray-500 bg-gray-50/50 rounded-lg border border-gray-200">
          <Book className="h-8 w-8 mx-auto mb-2 opacity-50 text-gray-400" />
          <p className="font-medium text-lg">השאלון טרם מולא במלואו</p>
          <p className="text-sm mt-1 text-gray-600">
            עדיין אין תשובות להציג, אך ניתן להמשיך למלא את השאלון.
          </p>
          <div className="mt-6">
            <Button
              asChild
              variant="default"
              className="bg-cyan-600 hover:bg-cyan-700 text-white"
            >
              <Link
                href={QUESTIONNAIRE_URL}
                className="flex items-center gap-1.5 px-6 py-2"
              >
                המשך מילוי השאלון
                <ArrowRight className="h-4 w-4" />
              </Link>
            </Button>
          </div>
        </div>
      )}
    </div>
  );
};

export default QuestionnaireResponsesSection;
--- End of Content for QuestionnaireResponsesSection.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\types
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\types\profile.ts
--------------------------------------------------------------------------------
Content:
import type { UserProfile, UserImage, QuestionnaireResponse } from "@/types/next-auth";

// Define specific types for questionnaire updates
export interface QuestionnaireUpdateValue {
  type: 'answer' | 'visibility';
  value?: string;
  isVisible?: boolean;
}

// Interfaces for the main sections
export interface PhotosSectionProps {
  images: UserImage[];
  isUploading: boolean;
  disabled?: boolean;
  onUpload: (file: File) => Promise<void>;
  onSetMain: (imageId: string) => Promise<void>;
  onDelete: (imageId: string) => Promise<void>;
}


export interface PreferencesSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onChange: (data: Partial<UserProfile>) => void;
}

export interface QuestionnaireResponsesSectionProps {
  questionnaire: QuestionnaireResponse | null;
  onUpdate?: (world: string, questionId: string, value: QuestionnaireUpdateValue) => Promise<void>;
  isEditable?: boolean;
  viewMode?: "matchmaker" | "candidate";
}

// Types for the extended profile data
export interface ExtendedProfileData {
  personalityTraits?: {
    temperament?: string;
    decisionMaking?: string;
    stressManagement?: string;
    communicationStyle?: string;
  };
  spiritualProfile?: {
    prayerStyle?: string;
    secularStudiesAttitude?: string;
    modestyLevel?: string;
    childrenEducationApproach?: string;
  };
  familyBackground?: {
    parentsSpiritualLevel?: string;
    parentsOccupations?: {
      father?: string;
      mother?: string;
    };
    familyDynamics?: string;
  };
  lifestylePreferences?: {
    careerAspiration?: string;
    futureStudyPlans?: string;
    livingPreferences?: {
      proximity?: string;
    };
    relationshipExpectations?: string;
  };
  healthProfile?: {
    generalHealth?: string;
    dietaryRestrictions?: string[];
    physicalActivity?: string;
  };
  personalValues?: {
    parentalRespect?: number;
    communityInvolvement?: string;
    volunteeringPreferences?: string;
    financialManagement?: string;
  };
  futureGoals?: string[];
  [key: string]: unknown;
}

// Additional utility types
export type ViewMode = "matchmaker" | "candidate";
export type CardSize = "sm" | "md" | "lg";
--- End of Content for profile.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\types\questionnaire.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/types/questionnaire.ts

export type QuestionnaireAnswerValue = {
  type: 'answer';
  value: string;
} | {
  type: 'visibility';
  isVisible: boolean;
} | string | number | boolean;

export interface FormattedAnswer {
  questionId: string;
  question: string;
  value: QuestionnaireAnswerValue;
  displayText: string;
  answeredAt: string;
  category?: string;
  isVisible: boolean;
}

export interface QuestionnaireResponse {
  id: string;
  userId: string;
  formattedAnswers: {
    values: FormattedAnswer[];
    personality: FormattedAnswer[];
    relationship: FormattedAnswer[];
    partner: FormattedAnswer[];
    religion: FormattedAnswer[];
  };
  valuesCompleted: boolean;
  personalityCompleted: boolean;
  relationshipCompleted: boolean;
  partnerCompleted: boolean;
  religionCompleted: boolean;
  worldsCompleted: string[];
  completed: boolean;
  startedAt: string | Date;
  completedAt?: string | Date;
  lastSaved: string | Date;
}

export interface QuestionnaireWorld {
  key: string;
  title: string;
  icon: React.ElementType;
  color: string;
  bgColor: string;
  borderColor: string;
}

export interface QuestionCardProps {
  question: string;
  answer: FormattedAnswer;
  isEditing: boolean;
  onEdit: (value: string) => void;
  onVisibilityChange: (isVisible: boolean) => void;
}

export interface WorldSectionProps {
  title: string;
  icon: React.ElementType;
  answers: FormattedAnswer[];
  isEditing: boolean;
  onEdit: (questionId: string, value: string) => void;
  onVisibilityChange: (questionId: string, isVisible: boolean) => void;
  isCompleted: boolean;
  className?: string;
}
--- End of Content for questionnaire.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\MatchSuggestionsContainer.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/MatchSuggestionsContainer.tsx

"use client";

import React, { useState, useEffect, useCallback } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { 
  Clock, 
  History, 
  AlertCircle, 
  RefreshCw, 
  Bell, 
  TrendingUp,
  Users,
  CheckCircle,
  Target,
  Sparkles,
  Heart,
  Zap
} from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";

import SuggestionsList from "./list/SuggestionsList";
import type { ExtendedMatchSuggestion } from "./types";
import { cn } from "@/lib/utils";
import { getEnhancedStatusInfo, getPartyIndicator } from "@/lib/utils/suggestionUtils";

interface MatchSuggestionsContainerProps {
  userId: string;
  className?: string;
}

// קומפוננטת סטטיסטיקות מפושטת ונקייה עם עיצוב חדש
const WelcomeStats: React.FC<{
  activeSuggestions: ExtendedMatchSuggestion[];
  historySuggestions: ExtendedMatchSuggestion[];
  pendingCount: number;
  userId: string; // הוספנו את userId כדי לדעת איזה צד אנחנו
}> = ({ activeSuggestions, historySuggestions, pendingCount, userId }) => {
  const totalSuggestions = activeSuggestions.length + historySuggestions.length;
  const approvedCount = [...activeSuggestions, ...historySuggestions].filter(s => 
    s.status === "FIRST_PARTY_APPROVED" || s.status === "SECOND_PARTY_APPROVED"
  ).length;

  // ספירת הצעות שממתינות לתורו של המשתמש
  const myTurnCount = activeSuggestions.filter(s => {
    const isFirstParty = s.firstPartyId === userId;
    return (
      (s.status === "PENDING_FIRST_PARTY" && isFirstParty) ||
      (s.status === "PENDING_SECOND_PARTY" && !isFirstParty)
    );
  }).length;

  const stats = [
    {
      label: "הצעות חדשות",
      value: activeSuggestions.length,
      icon: <Sparkles className="w-5 h-5" />,
      color: "from-cyan-500 to-blue-500",
      description: "ממתינות לתשובתך"
    },
    {
      label: "התור שלך", // התור שלך במקום "בטיפול"
      value: myTurnCount,
      icon: <Zap className="w-5 h-5" />,
      color: "from-orange-500 to-amber-500", // 🧡 כתום חזק לדחיפות
      description: "דורשות החלטה ממך",
      pulse: myTurnCount > 0 // רק אם יש משהו בתור שלו
    },
    {
      label: "אושרו",
      value: approvedCount,
      icon: <CheckCircle className="w-5 h-5" />,
      color: "from-emerald-500 to-green-500",
      description: "הצעות שאושרו"
    },
  ];

  return (
    <div className="mb-8">
      {/* כותרת ראשית */}
      <div className="text-center mb-8">
        <div className="inline-flex items-center gap-3 mb-4">
         <div className="p-3 rounded-full bg-gradient-to-r from-purple-100 to-cyan-100">
  <Heart className="w-8 h-8 text-purple-600" />
</div>
        </div>
    <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-purple-600 via-cyan-600 to-emerald-600 bg-clip-text text-transparent mb-3">
  ההצעות שלך
</h1>

        <p className="text-lg text-gray-600 max-w-2xl mx-auto">
          הזדמנויות מיוחדות להכיר את האדם המושלם עבורך
        </p>
      </div>

      {/* סטטיסטיקות */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {stats.map((stat, index) => (
          <Card key={index} className="border-0 shadow-lg overflow-hidden bg-white hover:shadow-xl transition-all duration-300 group">
            <CardContent className="p-6">
              <div className="flex items-center justify-between mb-4">
                <div className={cn(
                  "p-3 rounded-xl bg-gradient-to-r text-white shadow-lg group-hover:scale-110 transition-transform duration-300", 
                  stat.color,
                  stat.pulse && "animate-pulse"
                )}>
                  {stat.icon}
                </div>
                <div className="text-right">
                  <div className={cn(
                    "text-3xl font-bold text-gray-900",
                    stat.pulse && "animate-bounce"
                  )}>{stat.value}</div>
                </div>
              </div>
              <div className="space-y-1">
                <h3 className="font-bold text-lg text-gray-800">{stat.label}</h3>
                <p className="text-sm text-gray-600">{stat.description}</p>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
};

const MatchSuggestionsContainer: React.FC<MatchSuggestionsContainerProps> = ({
  userId,
  className,
}) => {
  // States
  const [activeSuggestions, setActiveSuggestions] = useState<ExtendedMatchSuggestion[]>([]);
  const [historySuggestions, setHistorySuggestions] = useState<ExtendedMatchSuggestion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("active");
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [hasNewSuggestions, setHasNewSuggestions] = useState(false);
  const [isUserInActiveProcess, setIsUserInActiveProcess] = useState(false);

  // Calculate counts
  const pendingCount = activeSuggestions.filter(
    (s) => s.status === "PENDING_FIRST_PARTY" || s.status === "PENDING_SECOND_PARTY"
  ).length;

  // ספירת הצעות שדורשות תשובה מהמשתמש הנוכחי
  const myTurnCount = activeSuggestions.filter(s => {
    const isFirstParty = s.firstPartyId === userId;
    return (
      (s.status === "PENDING_FIRST_PARTY" && isFirstParty) ||
      (s.status === "PENDING_SECOND_PARTY" && !isFirstParty)
    );
  }).length;

  // Fetch suggestions function
  const fetchSuggestions = useCallback(
    async (showLoadingState = true) => {
      try {
        if (showLoadingState) {
          setIsLoading(true);
        } else {
          setIsRefreshing(true);
        }
        setError(null);

        const [activeResponse, historyResponse] = await Promise.all([
          fetch(`/api/suggestions/active`),
          fetch(`/api/suggestions/history`),
        ]);

        if (!activeResponse.ok || !historyResponse.ok) {
          const activeError = !activeResponse.ok ? await activeResponse.text() : "";
          const historyError = !historyResponse.ok ? await historyResponse.text() : "";
          console.error("Fetch errors:", { activeError, historyError });
          throw new Error(
            `Failed to fetch suggestions (${activeResponse.status}/${historyResponse.status})`
          );
        }

        const activeData = await activeResponse.json();
        const historyData = await historyResponse.json();

        // Check for new suggestions
        if (!showLoadingState && activeData.suggestions.length > activeSuggestions.length) {
          setHasNewSuggestions(true);
          toast.success("התקבלו הצעות שידוך חדשות!", {
            description: "בדוק את ההצעות החדשות שמחכות לך",
            duration: 5000,
          });
        }

        setActiveSuggestions(activeData.suggestions);
        setHistorySuggestions(historyData.suggestions);
      } catch (error) {
        console.error("Error loading suggestions:", error);
        setError(
          `אירעה שגיאה בטעינת ההצעות: ${
            error instanceof Error ? error.message : "שגיאה לא ידועה"
          }`
        );
        toast.error("שגיאה בטעינת ההצעות", {
          description: "נסה לרענן את הדף או פנה לתמיכה",
        });
      } finally {
        setIsLoading(false);
        setIsRefreshing(false);
      }
    },
    [activeSuggestions.length]
  );

  // Initial load and periodic refresh
  useEffect(() => {
    fetchSuggestions();

    const intervalId = setInterval(() => {
      fetchSuggestions(false);
    }, 5 * 60 * 1000); // Refresh every 5 minutes

    return () => clearInterval(intervalId);
  }, [userId, fetchSuggestions]);

  // Effect to determine if user is in an active process
  useEffect(() => {
    const activeProcessStatuses: MatchSuggestion['status'][] = [
      'FIRST_PARTY_APPROVED',
      'SECOND_PARTY_APPROVED',
      'AWAITING_MATCHMAKER_APPROVAL',
      'CONTACT_DETAILS_SHARED',
      'AWAITING_FIRST_DATE_FEEDBACK',
      'THINKING_AFTER_DATE',
      'PROCEEDING_TO_SECOND_DATE',
      'MEETING_PENDING',
      'MEETING_SCHEDULED',
      'MATCH_APPROVED',
      'DATING',
      'ENGAGED',
    ];

    const hasActiveProcess = activeSuggestions.some(s =>
      activeProcessStatuses.includes(s.status)
    );
    setIsUserInActiveProcess(hasActiveProcess);
  }, [activeSuggestions]);

  // Clear new suggestions notification when changing to active tab
  useEffect(() => {
    if (activeTab === "active") {
      setHasNewSuggestions(false);
    }
  }, [activeTab]);

  // Handle suggestion status change
  // Handle suggestion status change
  const handleStatusChange = useCallback(
    async (suggestionId: string, newStatus: string, notes?: string) => {
      try {
        const response = await fetch(`/api/suggestions/${suggestionId}/status`, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ status: newStatus, notes }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || "Failed to update suggestion status");
        }

        await fetchSuggestions(false);

        const statusMessages: Record<string, string> = {
          FIRST_PARTY_APPROVED: "אישרת את ההצעה בהצלחה",
          SECOND_PARTY_APPROVED: "אישרת את ההצעה בהצלחה",
          FIRST_PARTY_DECLINED: "דחית את ההצעה בהצלחה",
          SECOND_PARTY_DECLINED: "דחית את ההצעה בהצלחה",
        };

        let description: string;
        if (newStatus === 'FIRST_PARTY_APPROVED') {
          description = "באישורך, ההצעה נשלחה לצד השני. אם גם הצד השני יאשר, פרטי הקשר המלאים שלכם יוחלפו.";
        } else if (newStatus === 'SECOND_PARTY_APPROVED') {
          description = "מעולה! כעת, מאחר ושניכם אישרתם, פרטי הקשר שלך יישלחו לצד הראשון ופרטיו יישלחו אליך.";
        } else if (newStatus.includes("DECLINED")) {
          description = "תודה על המשוב - זה עוזר לנו להציע התאמות טובות יותר";
        } else {
          description = "השדכן יקבל הודעה ויתקדם עם התהליך";
        }

        toast.success(statusMessages[newStatus] || "הסטטוס עודכן בהצלחה", { description });

      } catch (error) {
        console.error("Error updating suggestion status:", error);
        toast.error(
          `אירעה שגיאה בעדכון הסטטוס: ${
            error instanceof Error ? error.message : "שגיאה לא ידועה"
          }`
        );
      }
    },
    [fetchSuggestions]
  );

  // Handle manual refresh
  const handleRefresh = useCallback(async () => {
    await fetchSuggestions(false);
    toast.success("הנתונים עודכנו בהצלחה", {
      description: "כל ההצעות עודכנו למצב הנוכחי"
    });
  }, [fetchSuggestions]);

  return (
    <div className={cn("min-h-screen bg-gradient-to-br from-slate-50 via-cyan-50/20 to-emerald-50/20", className)}>
      <div className="container mx-auto px-4 py-8">
        {/* כותרת וסטטיסטיקות */}
        <WelcomeStats
          activeSuggestions={activeSuggestions}
          historySuggestions={historySuggestions}
          pendingCount={pendingCount}
          userId={userId}
        />

        {/* תוכן ראשי */}
        <Card className="shadow-2xl border-0 bg-white/95 backdrop-blur-sm overflow-hidden">
          {/* כותרת עם כפתור רענון */}
          <CardHeader className="pb-4 bg-gradient-to-r from-white via-cyan-50/30 to-emerald-50/30 border-b border-gray-100">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={handleRefresh}
                  disabled={isRefreshing || isLoading}
                  className="rounded-full h-10 w-10 hover:bg-cyan-100 transition-colors"
                  aria-label="רענן הצעות"
                >
                  <RefreshCw
                    className={cn(
                      "h-5 w-5 text-cyan-600",
                      isRefreshing && "animate-spin"
                    )}
                  />
                </Button>
                
               {hasNewSuggestions && (
  <Badge className="bg-gradient-to-r from-orange-500 to-amber-500 text-white border-0 shadow-xl animate-pulse">
    <Bell className="w-3 h-3 ml-1" />
    הצעות חדשות
  </Badge>
)}
              </div>

              <div className="text-center flex-grow">
                <CardTitle className="text-xl font-bold text-gray-800">
                  ניהול ההצעות
                </CardTitle>
              </div>

              <div className="w-16"></div> {/* Spacer for balance */}
            </div>
          </CardHeader>

          <CardContent className="p-6">
            <Tabs value={activeTab} onValueChange={setActiveTab} dir="rtl" className="space-y-6">
              {/* טאבים מעוצבים */}
              <div className="flex justify-center">

<TabsList className="grid grid-cols-3 bg-purple-50/50 rounded-2xl p-1 h-14 w-fit">
  <TabsTrigger
    value="active"
    className="relative flex items-center gap-3 px-6 py-3 rounded-xl transition-all data-[state=active]:bg-white data-[state=active]:shadow-lg font-semibold text-base"
  >
    <Target className="w-5 h-5 text-purple-500" />
    <span>פעילות</span>
    {activeSuggestions.length > 0 && (
      <Badge className="bg-purple-500 text-white border-0 px-2 py-1 text-xs font-bold rounded-full min-w-[24px] h-6">
        {activeSuggestions.length}
      </Badge>
    )}
  </TabsTrigger>

  {/* הטאב הדחוף עם כתום מחוזק */}
  {myTurnCount > 0 && (
    <TabsTrigger
      value="urgent"
      className="flex items-center gap-3 px-6 py-3 rounded-xl transition-all data-[state=active]:bg-white data-[state=active]:shadow-lg font-semibold text-base"
    >
      <Zap className="w-5 h-5 text-orange-500" />
      <span>התור שלך</span>
      <Badge className="bg-gradient-to-r from-orange-500 to-amber-500 text-white border-0 px-2 py-1 text-xs font-bold rounded-full min-w-[24px] h-6 animate-pulse shadow-lg">
        {myTurnCount}
      </Badge>
    </TabsTrigger>
  )}

  <TabsTrigger
    value="history"
    className="flex items-center gap-3 px-6 py-3 rounded-xl transition-all data-[state=active]:bg-white data-[state=active]:shadow-lg font-semibold text-base"
  >
    <History className="w-5 h-5 text-gray-500" />
    <span>היסטוריה</span>
    {historySuggestions.length > 0 && (
      <Badge className="bg-gray-500 text-white border-0 px-2 py-1 text-xs font-bold rounded-full min-w-[24px] h-6">
        {historySuggestions.length}
      </Badge>
    )}
  </TabsTrigger>
</TabsList>
              </div>

              {error && (
                <Alert variant="destructive" className="border-red-200 bg-red-50" dir="rtl">
                  <AlertCircle className="h-5 w-5 ml-2" />
                  <AlertDescription className="text-red-800 font-medium">{error}</AlertDescription>
                </Alert>
              )}

              {/* תוכן הטאבים */}
              <TabsContent value="active" className="space-y-6">
                <SuggestionsList
                  suggestions={activeSuggestions}
                  userId={userId}
                  viewMode={viewMode}
                  isLoading={isLoading}
                  onStatusChange={handleStatusChange}
                  onRefresh={handleRefresh}
                  isUserInActiveProcess={isUserInActiveProcess}
                />
              </TabsContent>

              <TabsContent value="history" className="space-y-6">
                <SuggestionsList
                  suggestions={historySuggestions}
                  userId={userId}
                  viewMode={viewMode}
                  isLoading={isLoading}
                  isHistory={true}
                  onRefresh={handleRefresh}
                  isUserInActiveProcess={isUserInActiveProcess}
                />
              </TabsContent>

              <TabsContent value="urgent" className="space-y-6">
                <SuggestionsList
                  suggestions={activeSuggestions.filter(s => {
                    const isFirstParty = s.firstPartyId === userId;
                    return (
                      (s.status === "PENDING_FIRST_PARTY" && isFirstParty) ||
                      (s.status === "PENDING_SECOND_PARTY" && !isFirstParty)
                    );
                  })}
                  userId={userId}
                  viewMode={viewMode}
                  isLoading={isLoading}
                  onStatusChange={handleStatusChange}
                  onRefresh={handleRefresh}
                  isUserInActiveProcess={isUserInActiveProcess}
                />
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default MatchSuggestionsContainer;
--- End of Content for MatchSuggestionsContainer.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\types.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/types.ts

import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";

// הטיפוסים המורחבים שהגדרנו, כעת במקום מרכזי
// ועם `export` כדי שניתן יהיה לייבא אותם בכל מקום

export interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

export interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

export interface StatusHistoryItem {
  id: string;
  suggestionId: string;
  status: string;
  notes?: string | null;
  createdAt: Date | string;
}

export interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: StatusHistoryItem[];
}
--- End of Content for types.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\cards
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\cards\MinimalSuggestionCard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/cards/MinimalSuggestionCard.tsx

import React from "react";
import Image from "next/image";
import { formatDistanceToNow, isAfter, subDays } from "date-fns";
import { he } from "date-fns/locale";
import {
  User,
  MapPin,
  Briefcase,
  Eye,
  CheckCircle,
  XCircle,
  MessageCircle,
  Heart,
  BookOpen,
  Scroll,
  Calendar,
  AlertTriangle,
  Sparkles,
  ChevronLeft,
  Star,
  Quote,
  Zap
} from "lucide-react";

import { Card, CardContent, CardFooter } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { toast } from "sonner";
import { cn } from "@/lib/utils";
import { getInitials } from "@/lib/utils";
import { getEnhancedStatusInfo, getPartyIndicator } from "@/lib/utils/suggestionUtils";
import type { ExtendedMatchSuggestion } from "../types";

interface MinimalSuggestionCardProps {
  suggestion: ExtendedMatchSuggestion;
  userId: string;
  onClick: (suggestion: ExtendedMatchSuggestion) => void;
  onApprove?: (suggestion: ExtendedMatchSuggestion) => void;
  onInquiry?: (suggestion: ExtendedMatchSuggestion) => void;
  onDecline?: (suggestion: ExtendedMatchSuggestion) => void;
  className?: string;
  isHistory?: boolean;
  isApprovalDisabled?: boolean;
}

const calculateAge = (birthDate?: Date | string | null): number | null => {
    if (!birthDate) return null;
    const today = new Date();
    const birth = new Date(birthDate);
    if (isNaN(birth.getTime())) return null;
    let age = today.getFullYear() - birth.getFullYear();
    const m = today.getMonth() - birth.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < birth.getDate())) {
        age--;
    }
    return age > 0 ? age : null;
};

const MinimalSuggestionCard: React.FC<MinimalSuggestionCardProps> = ({
  suggestion,
  userId,
  onClick,
  onApprove,
  onInquiry,
  onDecline,
  className,
  isHistory = false,
  isApprovalDisabled = false,
}) => {
  const targetParty = suggestion.firstPartyId === userId ? suggestion.secondParty : suggestion.firstParty;
  const isFirstParty = suggestion.firstPartyId === userId;

  if (!targetParty || !targetParty.profile) {
    console.error("MinimalSuggestionCard: targetParty or profile is missing.", { suggestion });
    return null;
  }

  const mainImage = targetParty.images?.find((img) => img.isMain);
  const age = calculateAge(targetParty.profile.birthDate);
  
  // Use the enhanced status info
  const statusInfo = getEnhancedStatusInfo(suggestion.status, isFirstParty);
  const partyIndicator = getPartyIndicator(suggestion.status, isFirstParty);

  const hasDeadline = suggestion.decisionDeadline && new Date(suggestion.decisionDeadline) > new Date();
  const isUrgent = hasDeadline && subDays(new Date(suggestion.decisionDeadline!), 2) < new Date();
  
  // Truncate matching reason for the teaser
  const reasonTeaser = suggestion.matchingReason
    ? suggestion.matchingReason.length > 100
      ? `${suggestion.matchingReason.substring(0, 100)}...`
      : suggestion.matchingReason
    : 'השדכן/ית זיהו פוטנציאל מיוחד שכדאי לבדוק!';

  return (
    <Card
      className={cn(
        "group w-full rounded-2xl overflow-hidden shadow-lg border-0 bg-white transition-all duration-500 hover:shadow-xl hover:-translate-y-1 cursor-pointer",
        isUrgent && "ring-2 ring-orange-300 ring-opacity-60",
        className
      )}
      onClick={(e) => {
        // Allow clicking the card to open details, but not if a button was clicked
        if (!(e.target as Element).closest("button")) {
          onClick(suggestion);
        }
      }}
    >
      {/* Header עם מידע השדכן ו-STATUS ENHANCED */}
      <div className="relative p-4 bg-gradient-to-r from-cyan-50/80 via-white to-emerald-50/50 border-b border-cyan-100/50">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Avatar className="w-10 h-10 border-2 border-white shadow-md">
              <AvatarFallback className="bg-gradient-to-br from-cyan-500 to-emerald-500 text-white font-bold text-sm">
                {getInitials(`${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`)}
              </AvatarFallback>
            </Avatar>
            <div>
              <p className="text-xs text-cyan-600 font-medium">הצעה מ</p>
              <p className="text-sm font-bold text-gray-800">
                {suggestion.matchmaker.firstName} {suggestion.matchmaker.lastName}
              </p>
            </div>
          </div>
          
          {/* Enhanced Status Section */}
          <div className="flex flex-col items-end gap-1">
            <Badge className={cn(
              "flex items-center gap-1.5 border shadow-sm font-semibold text-xs",
              statusInfo.className,
              statusInfo.pulse && "animate-pulse"
            )}>
              <statusInfo.icon className="w-3 h-3" />
              <span>{statusInfo.shortLabel}</span>
            </Badge>
            
            {/* Party Indicator - רק אם יש תור של מישהו */}
            {partyIndicator.show && (
              <Badge className={cn(
                "text-xs px-2 py-0.5 font-bold shadow-sm",
                partyIndicator.className
              )}>
                {partyIndicator.text === "תורך!" && <Zap className="w-2.5 h-2.5 ml-1" />}
                {partyIndicator.text}
              </Badge>
            )}
          </div>
        </div>
        
        {isUrgent && (
          <div className="absolute top-2 left-2">
            <Badge className="flex items-center gap-1.5 bg-gradient-to-r from-orange-500 to-red-500 text-white border-0 shadow-lg animate-pulse">
                <AlertTriangle className="w-3 h-3" />
                <span className="font-semibold text-xs">דחוף</span>
            </Badge>
          </div>
        )}
      </div>

      {/* Image Section */}
      <div className="relative h-64">
        {mainImage?.url ? (
          <Image
            src={mainImage.url}
            alt={`תמונה של ${targetParty.firstName}`}
            fill
            className="object-cover object-center transition-transform duration-700 group-hover:scale-105"
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          />
        ) : (
          <div className="w-full h-full bg-gradient-to-br from-slate-100 to-slate-200 flex items-center justify-center">
            <User className="w-20 h-20 text-slate-400" />
          </div>
        )}
        <div className="absolute inset-0 bg-gradient-to-t from-black/70 via-black/20 to-transparent" />
        
        {/* Name and Age overlay */}
        <div className="absolute bottom-4 right-4 left-4 text-white">
          <div className="flex items-end justify-between">
            <div>
              <h3 className="text-2xl font-bold tracking-tight [text-shadow:0_2px_8px_rgba(0,0,0,0.8)]">
                {targetParty.firstName}
              </h3>
              {age && (
                <p className="text-lg font-medium text-white/90 [text-shadow:0_1px_4px_rgba(0,0,0,0.8)]">
                  {age} שנים
                </p>
              )}
            </div>
            
            {/* אייקון מיוחד */}
            <div className="p-2 rounded-full bg-white/20 backdrop-blur-sm">
              <Sparkles className="w-5 h-5 text-white" />
            </div>
          </div>
        </div>
      </div>
      
      <CardContent className="p-5 space-y-4">
        {/* Enhanced Status Description */}
        {statusInfo.description && (
          <div className="p-3 bg-gradient-to-r from-slate-50 to-gray-50 rounded-lg border border-slate-200">
            <div className="flex items-start gap-2">
              <statusInfo.icon className="w-4 h-4 text-slate-600 mt-0.5 flex-shrink-0" />
              <p className="text-sm text-slate-700 font-medium leading-relaxed">
                {statusInfo.description}
              </p>
            </div>
          </div>
        )}

        {/* Core Info Grid */}
        <div className="grid grid-cols-2 gap-3">
            {targetParty.profile.city && (
              <div className="flex items-center gap-2 p-2 bg-cyan-50/50 rounded-lg border border-cyan-100/50">
                  <MapPin className="w-4 h-4 text-cyan-600 flex-shrink-0" />
                  <span className="text-sm font-medium text-gray-700 truncate">{targetParty.profile.city}</span>
              </div>
            )}
            {targetParty.profile.occupation && (
              <div className="flex items-center gap-2 p-2 bg-emerald-50/50 rounded-lg border border-emerald-100/50">
                  <Briefcase className="w-4 h-4 text-emerald-600 flex-shrink-0" />
                  <span className="text-sm font-medium text-gray-700 truncate">{targetParty.profile.occupation}</span>
              </div>
            )}
            {targetParty.profile.religiousLevel && (
              <div className="flex items-center gap-2 p-2 bg-blue-50/50 rounded-lg border border-blue-100/50">
                  <Scroll className="w-4 h-4 text-blue-600 flex-shrink-0" />
                  <span className="text-sm font-medium text-gray-700 truncate">{targetParty.profile.religiousLevel}</span>
              </div>
            )}
            {targetParty.profile.education && (
              <div className="flex items-center gap-2 p-2 bg-green-50/50 rounded-lg border border-green-100/50">
                  <BookOpen className="w-4 h-4 text-green-600 flex-shrink-0" />
                  <span className="text-sm font-medium text-gray-700 truncate">{targetParty.profile.education}</span>
              </div>
            )}
        </div>
        
        {/* Matchmaker's reasoning highlight */}
        <div className="relative p-4 bg-gradient-to-r from-cyan-50/50 to-blue-50/50 border border-cyan-100/50 rounded-xl">
            <div className="flex items-start gap-3">
              <Quote className="w-4 h-4 text-cyan-500 mt-1 flex-shrink-0" />
              <div className="flex-1">
                <h4 className="text-sm font-bold text-cyan-800 mb-1">למה זו התאמה מיוחדת?</h4>
                <p className="text-sm text-cyan-700 leading-relaxed">
                    {reasonTeaser}
                </p>
              </div>
            </div>
            
            {/* זווית עיצובית */}
            <div className="absolute top-0 right-0 w-6 h-6 bg-gradient-to-br from-cyan-200/50 to-blue-200/50 rounded-bl-xl"></div>
        </div>
        
        {/* CTA hint */}
        <div className="text-center py-2">
          <p className="text-xs text-gray-500 font-medium">לחץ לפרטים מלאים ועוד תובנות</p>
        </div>
      </CardContent>

      {!isHistory && (
        <CardFooter className="p-4 bg-gradient-to-r from-gray-50/50 to-slate-50/50 border-t border-gray-100">
          {((suggestion.status === "PENDING_FIRST_PARTY" && isFirstParty) || (suggestion.status === "PENDING_SECOND_PARTY" && !isFirstParty)) ? (
             <div className="grid grid-cols-2 gap-3 w-full">
                <Button
                  size="sm"
                  variant="outline"
                  className="w-full text-red-600 hover:text-red-700 hover:bg-red-50 border-red-200 rounded-xl font-medium transition-all duration-300"
                  onClick={(e) => { e.stopPropagation(); onDecline?.(suggestion); }}
                >
                  <XCircle className="w-4 h-4 ml-2" />
                  לא מתאים
                </Button>
                <TooltipProvider>
                  <Tooltip delayDuration={100}>
                    <TooltipTrigger asChild>
                      <div className="w-full">
                        <Button
                          size="sm"
                          variant="default"
                          className="w-full bg-gradient-to-r from-emerald-500 to-green-500 hover:from-emerald-600 hover:to-green-600 text-white shadow-lg hover:shadow-xl transition-all duration-300 rounded-xl font-medium"
                          disabled={isApprovalDisabled}
                          onClick={(e) => {
                            e.stopPropagation();
                            if (isApprovalDisabled) {
                              toast.info("לא ניתן לאשר הצעה חדשה", {
                                description: "יש לך כבר הצעה אחרת בתהליך פעיל.",
                              });
                            } else {
                              onApprove?.(suggestion);
                            }
                          }}
                        >
                          <Heart className="w-4 h-4 ml-2" />
                          מעוניין/ת להכיר!
                        </Button>
                      </div>
                    </TooltipTrigger>
                    {isApprovalDisabled && (
                      <TooltipContent>
                        <p>לא ניתן לאשר הצעה חדשה כשיש הצעה בתהליך פעיל.</p>
                      </TooltipContent>
                    )}
                  </Tooltip>
                </TooltipProvider>
             </div>
          ) : (
            <div className="grid grid-cols-2 gap-3 w-full">
                <Button
                    size="sm"
                    variant="outline"
                    className="w-full border-gray-200 hover:bg-cyan-50 hover:border-cyan-200 rounded-xl font-medium transition-all duration-300"
                    onClick={(e) => { e.stopPropagation(); onInquiry?.(suggestion); }}
                >
                    <MessageCircle className="w-4 h-4 ml-2" />
                    שאלה לשדכן/ית
                </Button>
                <Button
                    size="sm"
                    variant="default"
                    className="w-full bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-600 hover:to-blue-600 text-white shadow-lg hover:shadow-xl transition-all duration-300 rounded-xl font-medium"
                    onClick={() => onClick(suggestion)}
                >
                    <Eye className="w-4 h-4 ml-2" />
                    צפה בפרטים
                    <ChevronLeft className="w-3 h-3 mr-1" />
                </Button>
            </div>
          )}
        </CardFooter>
      )}
    </Card>
  );
};

export default MinimalSuggestionCard;
--- End of Content for MinimalSuggestionCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\cards\SuggestionQuickView.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/cards/SuggestionQuickView.tsx

import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  User,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  MessageCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import type { ExtendedMatchSuggestion } from "../types";

interface SuggestionQuickViewProps {
  suggestion: ExtendedMatchSuggestion;
  userId?: string;
  onAction: (action: "approve" | "reject" | "ask" | "view") => void;
}

const SuggestionQuickView: React.FC<SuggestionQuickViewProps> = ({
  suggestion,
  userId,
  onAction,
}) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = userId
    ? suggestion.firstPartyId === userId
      ? suggestion.secondParty.profile
      : suggestion.firstParty.profile
    : suggestion.secondParty.profile;

  return (
    <div
      className="bg-white/95 backdrop-blur-sm p-4 rounded-lg shadow-lg flex flex-col"
      onClick={handleClick}
    >
      <div className="flex-1 space-y-4 text-right overflow-y-auto max-h-96">
        <div className="grid grid-cols-2 gap-3">
          {profile.height && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.height} ס״מ</span>
              <User className="w-4 h-4" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.maritalStatus}</span>
              <Heart className="w-4 h-4" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.religiousLevel}</span>
              <Scroll className="w-4 h-4" />
            </div>
          )}

          {profile.education && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.education}</span>
              <GraduationCap className="w-4 h-4" />
            </div>
          )}
        </div>

        {profile.about && (
          <div className="border-t border-gray-100 pt-3">
            <h4 className="text-sm font-medium mb-1">אודות:</h4>
            <p className="text-sm text-gray-600 leading-relaxed line-clamp-3">
              {profile.about}
            </p>
          </div>
        )}

        {suggestion.matchingReason && (
          <div className="border-t border-gray-100 pt-3">
            <h4 className="text-sm font-medium mb-1">סיבת ההצעה:</h4>
            <p className="text-sm text-gray-600 leading-relaxed line-clamp-3">
              {suggestion.matchingReason}
            </p>
          </div>
        )}

        <div className="border-t border-gray-100 pt-3 space-y-2">
          {profile.city && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.city}</span>
              <MapPin className="w-4 h-4" />
            </div>
          )}

          {profile.occupation && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.occupation}</span>
              <Briefcase className="w-4 h-4" />
            </div>
          )}
        </div>

        {suggestion.decisionDeadline && (
          <div className="border-t border-gray-100 pt-3">
            <div className="flex items-center justify-end gap-2 text-sm text-yellow-600">
              <span>
                נדרשת תשובה עד{" "}
                {new Date(suggestion.decisionDeadline).toLocaleDateString(
                  "he-IL"
                )}
              </span>
              <Clock className="w-4 h-4" />
            </div>
          </div>
        )}
      </div>

      <div className="grid grid-cols-2 gap-2 mt-4 pt-3 border-t border-gray-100">
        <Button
          variant="default"
          className="w-full"
          onClick={() => onAction("view")}
        >
          <Eye className="w-4 h-4 ml-2" />
          צפייה בפרופיל
        </Button>

        <Button
          variant="default"
          className="w-full bg-green-600 hover:bg-green-700"
          onClick={() => onAction("approve")}
        >
          <CheckCircle className="w-4 h-4 ml-2" />
          אישור הצעה
        </Button>

        <Button
          variant="outline"
          className="w-full text-red-600 hover:text-red-700 hover:bg-red-50"
          onClick={() => onAction("reject")}
        >
          <XCircle className="w-4 h-4 ml-2" />
          דחיית הצעה
        </Button>

        <Button
          variant="outline"
          className="w-full"
          onClick={() => onAction("ask")}
        >
          <MessageCircle className="w-4 h-4 ml-2" />
          שאלה לשדכן
        </Button>
      </div>
    </div>
  );
};

export default SuggestionQuickView;
--- End of Content for SuggestionQuickView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\compatibility
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\compatibility\MatchCompatibilityView.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/compatibility/MatchCompatibilityView.tsx

import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import {
  Heart,
  User,
  Scroll,
  GraduationCap,
  MapPin,
  BookOpen,
  Home,
  Languages,
  Star,
  CheckCircle,
  XCircle,
  AlertTriangle,
  TrendingUp,
  Target,
  Users,
  Calendar,
} from "lucide-react";
import { cn } from "@/lib/utils";
import type { PartyInfo } from "../types";
import type { UserProfile } from "@/types/next-auth";

interface CompatibilityItem {
  criterion: string;
  icon: React.ReactNode;
  compatible: boolean;
  reason: string;
  first?: string | number | null;
  second?: string | number | null;
  importance: 'high' | 'medium' | 'low';
  category: 'basic' | 'lifestyle' | 'values' | 'preferences';
}

interface MatchCompatibilityProps {
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  matchingReason?: string | null;
  className?: string;
}

const calculateAge = (birthDate?: Date | string | null): number | null => {
  if (!birthDate) return null;

  try {
    const today = new Date();
    const birth = new Date(birthDate);
    if (isNaN(birth.getTime())) return null;

    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();

    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    return age >= 0 ? age : null;
  } catch (error) {
    console.error("Error calculating age:", error);
    return null;
  }
};

const getImportanceColor = (importance: string) => {
  switch (importance) {
    case 'high':
      return 'from-red-400 to-red-500';
    case 'medium':
      return 'from-amber-400 to-orange-500';
    case 'low':
      return 'from-cyan-400 to-blue-500';
    default:
      return 'from-gray-400 to-gray-500';
  }
};

const getCategoryColor = (category: string) => {
  switch (category) {
    case 'basic':
      return 'from-cyan-50 to-blue-50';
    case 'lifestyle':
      return 'from-emerald-50 to-green-50';
    case 'values':
      return 'from-blue-50 to-cyan-50';
    case 'preferences':
      return 'from-green-50 to-emerald-50';
    default:
      return 'from-gray-50 to-slate-50';
  }
};

const CompatibilityCard: React.FC<{
  item: CompatibilityItem;
  index: number;
  firstParty: PartyInfo;
  secondParty: PartyInfo;
}> = ({ item, index, firstParty, secondParty }) => {
  const importanceColor = getImportanceColor(item.importance);
  const categoryColor = getCategoryColor(item.category);
  
  return (
    <Card className={cn(
      "border-0 shadow-lg transition-all duration-300 hover:shadow-xl hover:-translate-y-1 overflow-hidden bg-gradient-to-br",
      categoryColor
    )}>
      <CardContent className="p-5">
        <div className="flex items-start gap-4">
          {/* Icon */}
          <div className={cn(
            "flex-shrink-0 w-12 h-12 rounded-xl bg-gradient-to-br text-white flex items-center justify-center shadow-md",
            item.compatible 
              ? "from-emerald-500 to-green-500" 
              : "from-red-400 to-rose-500"
          )}>
            {item.icon}
          </div>
          
          {/* Content */}
          <div className="flex-1 space-y-3">
            <div className="flex items-start justify-between gap-2">
              <div className="flex-1">
                <div className="flex items-center gap-2 mb-1">
                  <h4 className="font-bold text-gray-800 text-base">{item.criterion}</h4>
                  <Badge 
                    variant="outline" 
                    className={cn(
                      "text-xs px-2 py-0.5 font-semibold border-0 text-white",
                      importanceColor
                    )}
                  >
                    {item.importance === 'high' ? 'חשוב' : 
                     item.importance === 'medium' ? 'בינוני' : 'נמוך'}
                  </Badge>
                </div>
                <p className={cn(
                  "text-sm font-medium leading-relaxed",
                  item.compatible ? "text-emerald-700" : "text-red-700"
                )}>
                  {item.reason}
                </p>
              </div>
              
              <div className="flex-shrink-0">
                {item.compatible ? (
                  <CheckCircle className="w-6 h-6 text-emerald-500" />
                ) : (
                  <XCircle className="w-6 h-6 text-red-500" />
                )}
              </div>
            </div>

            {/* Details */}
            {(item.first != null || item.second != null) && (
              <div className="grid grid-cols-2 gap-3 pt-3 border-t border-white/50">
                <div className="text-center bg-white/60 backdrop-blur-sm rounded-lg p-2">
                  <div className="text-xs text-gray-500 font-medium mb-1">
                    {firstParty.firstName}
                  </div>
                  <div className="font-semibold text-gray-800 text-sm">
                    {item.first ?? "לא צוין"}
                  </div>
                </div>
                <div className="text-center bg-white/60 backdrop-blur-sm rounded-lg p-2">
                  <div className="text-xs text-gray-500 font-medium mb-1">
                    {secondParty.firstName}
                  </div>
                  <div className="font-semibold text-gray-800 text-sm">
                    {item.second ?? "לא צוין"}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

const CategorySection: React.FC<{
  title: string;
  icon: React.ElementType;
  items: CompatibilityItem[];
  color: string;
  firstParty: PartyInfo;
  secondParty: PartyInfo;
}> = ({ title, icon: Icon, items, color, firstParty, secondParty }) => {
  const compatibleCount = items.filter(item => item.compatible).length;
  const compatibilityRate = items.length > 0 ? (compatibleCount / items.length) * 100 : 0;
  
  if (items.length === 0) return null;
  
  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className={cn("p-2 rounded-lg bg-gradient-to-r text-white shadow-md", color)}>
            <Icon className="w-5 h-5" />
          </div>
          <div>
            <h3 className="text-lg font-bold text-gray-800">{title}</h3>
            <p className="text-sm text-gray-600">{compatibleCount} מתוך {items.length} קריטריונים תואמים</p>
          </div>
        </div>
        <div className="text-center">
          <div className={cn("text-2xl font-bold", compatibilityRate >= 70 ? "text-emerald-600" : compatibilityRate >= 50 ? "text-amber-600" : "text-red-600")}>
            {Math.round(compatibilityRate)}%
          </div>
          <div className="text-xs text-gray-500">התאמה</div>
        </div>
      </div>
      
      <div className="grid gap-4">
        {items.map((item, index) => (
          <CompatibilityCard key={index} item={item} index={index} firstParty={firstParty} secondParty={secondParty} />
        ))}
      </div>
    </div>
  );
};

const MatchCompatibilityView: React.FC<MatchCompatibilityProps> = ({
  firstParty,
  secondParty,
  matchingReason,
  className,
}) => {
  const firstPartyAge = calculateAge(firstParty.profile.birthDate);
  const secondPartyAge = calculateAge(secondParty.profile.birthDate);

  // Helper functions
  const isWithinRange = (value: number | null | undefined, min: number | null | undefined, max: number | null | undefined): boolean => {
    if (value == null) return false;
    const minOk = min == null || value >= min;
    const maxOk = max == null || value <= max;
    return minOk && maxOk;
  }

  const isInPreferredList = (value: string | null | undefined, preferredList: string[] | null | undefined): boolean => {
    if (value == null) return false;
    if (preferredList == null || preferredList.length === 0) return true;
    return preferredList.includes(value);
  }

  // Calculate compatibility items
  const calculateCompatibilityItems = (): CompatibilityItem[] => {
    const items: CompatibilityItem[] = [];

    // Age compatibility
    if (firstPartyAge != null && secondPartyAge != null) {
      const firstAgePreferenceMatch = isWithinRange(
        secondPartyAge,
        firstParty.profile.preferredAgeMin,
        firstParty.profile.preferredAgeMax
      );

      const secondAgePreferenceMatch = isWithinRange(
        firstPartyAge,
        secondParty.profile.preferredAgeMin,
        secondParty.profile.preferredAgeMax
      );

      const compatible = firstAgePreferenceMatch && secondAgePreferenceMatch;
      items.push({
        criterion: "גיל",
        icon: <User className="w-6 h-6" />,
        compatible,
        reason: compatible ? "התאמה הדדית בציפיות הגיל" : "אי התאמה בציפיות הגיל",
        first: firstPartyAge,
        second: secondPartyAge,
        importance: 'high',
        category: 'basic'
      });
    }

    // Height compatibility
    const firstHeight = firstParty.profile.height;
    const secondHeight = secondParty.profile.height;
    if (firstHeight != null && secondHeight != null) {
      const firstHeightPreferenceMatch = isWithinRange(
        secondHeight,
        firstParty.profile.preferredHeightMin,
        firstParty.profile.preferredHeightMax
      );

      const secondHeightPreferenceMatch = isWithinRange(
        firstHeight,
        secondParty.profile.preferredHeightMin,
        secondParty.profile.preferredHeightMax
      );

      const compatible = firstHeightPreferenceMatch && secondHeightPreferenceMatch;
      items.push({
        criterion: "גובה",
        icon: <TrendingUp className="w-6 h-6" />,
        compatible,
        reason: compatible ? "התאמה הדדית בציפיות הגובה" : "אי התאמה בציפיות הגובה",
        first: `${firstHeight} ס"מ`,
        second: `${secondHeight} ס"מ`,
        importance: 'medium',
        category: 'basic'
      });
    }

    // Location compatibility
    const firstCity = firstParty.profile.city;
    const secondCity = secondParty.profile.city;
    if (firstCity != null && secondCity != null) {
      const firstLocationPreferenceMatch = isInPreferredList(
        secondCity,
        firstParty.profile.preferredLocations
      );

      const secondLocationPreferenceMatch = isInPreferredList(
        firstCity,
        secondParty.profile.preferredLocations
      );

      const compatible = firstLocationPreferenceMatch && secondLocationPreferenceMatch;
      items.push({
        criterion: "מקום מגורים",
        icon: <MapPin className="w-6 h-6" />,
        compatible,
        reason: compatible ? "התאמה הדדית בהעדפות מיקום" : "אי התאמה בהעדפות מיקום",
        first: firstCity,
        second: secondCity,
        importance: 'high',
        category: 'lifestyle'
      });
    }

    // Religious level compatibility
    const firstReligious = firstParty.profile.religiousLevel;
    const secondReligious = secondParty.profile.religiousLevel;
    if (firstReligious != null && secondReligious != null) {
      const firstReligiousPreferenceMatch = isInPreferredList(
        secondReligious,
        firstParty.profile.preferredReligiousLevels
      );

      const secondReligiousPreferenceMatch = isInPreferredList(
        firstReligious,
        secondParty.profile.preferredReligiousLevels
      );

      const compatible = firstReligiousPreferenceMatch && secondReligiousPreferenceMatch;
      items.push({
        criterion: "רמה דתית",
        icon: <Scroll className="w-6 h-6" />,
        compatible,
        reason: compatible ? "התאמה הדדית בהעדפות רמה דתית" : "אי התאמה בהעדפות רמה דתית",
        first: firstReligious,
        second: secondReligious,
        importance: 'high',
        category: 'values'
      });
    }

    // Education compatibility
    const firstEdu = firstParty.profile.education;
    const secondEdu = secondParty.profile.education;
    if (firstEdu != null && secondEdu != null) {
      const firstEducationPreferenceMatch = isInPreferredList(
        secondEdu,
        firstParty.profile.preferredEducation
      );

      const secondEducationPreferenceMatch = isInPreferredList(
        firstEdu,
        secondParty.profile.preferredEducation
      );

      const compatible = firstEducationPreferenceMatch && secondEducationPreferenceMatch;
      items.push({
        criterion: "השכלה",
        icon: <GraduationCap className="w-6 h-6" />,
        compatible,
        reason: compatible ? "התאמה הדדית בהעדפות השכלה" : "אי התאמה בהעדפות השכלה",
        first: firstEdu,
        second: secondEdu,
        importance: 'medium',
        category: 'preferences'
      });
    }

    // Occupation compatibility
    const firstOcc = firstParty.profile.occupation;
    const secondOcc = secondParty.profile.occupation;
    if (firstOcc != null && secondOcc != null) {
      const firstOccupationPreferenceMatch = isInPreferredList(
        secondOcc,
        firstParty.profile.preferredOccupations
      );

      const secondOccupationPreferenceMatch = isInPreferredList(
        firstOcc,
        secondParty.profile.preferredOccupations
      );

      const compatible = firstOccupationPreferenceMatch && secondOccupationPreferenceMatch;
      items.push({
        criterion: "תעסוקה",
        icon: <BookOpen className="w-6 h-6" />,
        compatible,
        reason: compatible ? "התאמה הדדית בהעדפות תעסוקה" : "אי התאמה בהעדפות תעסוקה",
        first: firstOcc,
        second: secondOcc,
        importance: 'medium',
        category: 'lifestyle'
      });
    }

    // Origin compatibility
    const firstOrigin = firstParty.profile.origin;
    const secondOrigin = secondParty.profile.origin;
    if (firstOrigin != null && secondOrigin != null) {
      const sameOrigin = firstOrigin === secondOrigin;
      items.push({
        criterion: "מוצא",
        icon: <Home className="w-6 h-6" />,
        compatible: true,
        reason: sameOrigin ? "מוצא זהה" : "מוצא שונה - מעשיר את הקשר",
        first: firstOrigin,
        second: secondOrigin,
        importance: 'low',
        category: 'values'
      });
    }

    // Language compatibility
    const firstLang = firstParty.profile.nativeLanguage;
    const secondLang = secondParty.profile.nativeLanguage;
    if (firstLang != null && secondLang != null) {
      const nativeMatch = firstLang === secondLang;
      const firstSpeaksSecondNative = firstParty.profile.additionalLanguages?.includes(secondLang) ?? false;
      const secondSpeaksFirstNative = secondParty.profile.additionalLanguages?.includes(firstLang) ?? false;

      const sharedLanguage = nativeMatch || firstSpeaksSecondNative || secondSpeaksFirstNative;

      items.push({
        criterion: "שפה",
        icon: <Languages className="w-6 h-6" />,
        compatible: sharedLanguage,
        reason: sharedLanguage ? "יש שפה משותפת" : "אין שפה משותפת מוכרת",
        first: firstLang,
        second: secondLang,
        importance: 'medium',
        category: 'lifestyle'
      });
    }

    return items;
  };

  const compatibilityItems = calculateCompatibilityItems();
  const compatibleCount = compatibilityItems.filter(item => item.compatible).length;
  const compatibilityScore = compatibilityItems.length > 0 
    ? Math.round((compatibleCount / compatibilityItems.length) * 100) 
    : 0;

  // Group items by category
  const basicItems = compatibilityItems.filter(item => item.category === 'basic');
  const lifestyleItems = compatibilityItems.filter(item => item.category === 'lifestyle');
  const valuesItems = compatibilityItems.filter(item => item.category === 'values');
  const preferencesItems = compatibilityItems.filter(item => item.category === 'preferences');

  const getScoreColor = (score: number) => {
    if (score >= 80) return "text-emerald-600";
    if (score >= 60) return "text-cyan-600";
    if (score >= 40) return "text-amber-600";
    return "text-red-600";
  };

  const getScoreDescription = (score: number) => {
    if (score >= 80) return "התאמה מעולה";
    if (score >= 60) return "התאמה טובה";
    if (score >= 40) return "התאמה בינונית";
    return "התאמה מאתגרת";
  };

  return (
    <Card className={cn("shadow-xl border-0 overflow-hidden", className)}>
      <CardHeader className="bg-gradient-to-r from-cyan-50/80 via-white to-emerald-50/50 border-b border-gray-100">
        <CardTitle className="flex items-center gap-3 text-2xl">
          <div className="p-3 rounded-xl bg-gradient-to-r from-cyan-500 to-emerald-500 text-white shadow-lg">
            <Heart className="w-6 h-6" />
          </div>
          <div>
            <span className="font-bold text-gray-800">ניתוח התאמה מפורט</span>
            <p className="text-sm text-gray-600 font-normal mt-1">
              ניתוח מעמיק של נקודות החיבור והאתגרים הפוטנציאליים
            </p>
          </div>
        </CardTitle>
      </CardHeader>

      <CardContent className="p-8 space-y-8">
        {/* Overall Score */}
        <Card className="border-0 shadow-lg bg-gradient-to-r from-slate-50 to-gray-50">
          <CardContent className="p-6">
            <div className="text-center space-y-4">
              <div className="flex items-center justify-center gap-3">
                <Star className="w-8 h-8 text-yellow-500 fill-current" />
                <div>
                  <div className={cn("text-4xl font-bold", getScoreColor(compatibilityScore))}>
                    {compatibilityScore}%
                  </div>
                  <div className="text-lg font-semibold text-gray-700">
                    {getScoreDescription(compatibilityScore)}
                  </div>
                </div>
              </div>
              
              <Progress value={compatibilityScore} className="h-3" />
              
              <div className="flex justify-between text-sm text-gray-600">
                <span>{compatibleCount} מתוך {compatibilityItems.length} קריטריונים תואמים</span>
                <span>ציון כללי: {compatibilityScore}%</span>
              </div>
            </div>
          </CardContent>
        </Card>

        {compatibilityItems.length > 0 ? (
          <div className="space-y-8">
            {/* Basic Info */}
            <CategorySection
              title="מידע בסיסי"
              icon={User}
              items={basicItems}
              color="from-cyan-500 to-blue-500"
              firstParty={firstParty}
              secondParty={secondParty}
            />

            {/* Values */}
            <CategorySection
              title="ערכים והשקפה"
              icon={Heart}
              items={valuesItems}
              color="from-emerald-500 to-green-500"
              firstParty={firstParty}
              secondParty={secondParty}
            />

            {/* Lifestyle */}
            <CategorySection
              title="סגנון חיים"
              icon={Target}
              items={lifestyleItems}
              color="from-blue-500 to-cyan-500"
              firstParty={firstParty}
              secondParty={secondParty}
            />

            {/* Preferences */}
            <CategorySection
              title="העדפות אישיות"
              icon={Star}
              items={preferencesItems}
              color="from-green-500 to-emerald-500"
              firstParty={firstParty}
              secondParty={secondParty}
            />
          </div>
        ) : (
          <div className="text-center py-12">
            <AlertTriangle className="w-16 h-16 mx-auto mb-4 text-gray-400" />
            <h3 className="text-lg font-semibold text-gray-600 mb-2">אין מספיק נתונים</h3>
            <p className="text-gray-500 max-w-md mx-auto">
              לא נמצא מספיק מידע משותף כדי לבצע ניתוח התאמה מפורט
            </p>
          </div>
        )}

        {/* Matchmaker Rationale */}
        {matchingReason && (
          <Card className="border-0 shadow-lg bg-gradient-to-r from-cyan-50 to-emerald-50">
            <CardContent className="p-6">
              <div className="flex items-start gap-4">
                <div className="p-3 rounded-xl bg-gradient-to-r from-cyan-500 to-emerald-500 text-white shadow-md flex-shrink-0">
                  <Users className="w-6 h-6" />
                </div>
                <div className="flex-1">
                  <h3 className="font-bold text-cyan-800 text-lg mb-2">
                    נימוק השדכן להצעה
                  </h3>
                  <p className="text-cyan-700 leading-relaxed">{matchingReason}</p>
                </div>
              </div>
            </CardContent>
          </Card>
        )}
      </CardContent>
    </Card>
  );
};

export default MatchCompatibilityView;
--- End of Content for MatchCompatibilityView.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\compatibility\UserAiAnalysisDisplay.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/compatibility/UserAiAnalysisDisplay.tsx
"use client";

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { 
  Heart, 
  Lightbulb, 
  MessageSquareQuote, 
  Sparkles, 
  TrendingUp,
  Target,
  Brain,
  Users,
  CheckCircle,
  AlertCircle,
  Star
} from 'lucide-react';
import type { AiSuggestionAnalysisResult } from '@/lib/services/aiService';
import { cn } from '@/lib/utils';

interface UserAiAnalysisDisplayProps {
  analysis: AiSuggestionAnalysisResult;
}

// Score color helper עם הפלטה החדשה
const getScoreColor = (score: number) => {
  if (score >= 85) return {
    text: 'text-emerald-600',
    bg: 'from-emerald-50 to-green-50',
    progress: 'bg-gradient-to-r from-emerald-500 to-green-500',
    badge: 'bg-gradient-to-r from-emerald-500 to-green-500'
  };
  if (score >= 70) return {
    text: 'text-cyan-600',
    bg: 'from-cyan-50 to-blue-50',
    progress: 'bg-gradient-to-r from-cyan-500 to-blue-500',
    badge: 'bg-gradient-to-r from-cyan-500 to-blue-500'
  };
  if (score >= 55) return {
    text: 'text-blue-600',
    bg: 'from-blue-50 to-cyan-50',
    progress: 'bg-gradient-to-r from-blue-500 to-cyan-500',
    badge: 'bg-gradient-to-r from-blue-500 to-cyan-500'
  };
  return {
    text: 'text-amber-600',
    bg: 'from-amber-50 to-orange-50',
    progress: 'bg-gradient-to-r from-amber-500 to-orange-500',
    badge: 'bg-gradient-to-r from-amber-500 to-orange-500'
  };
};

// Score interpretation helper
const getScoreInterpretation = (score: number) => {
  if (score >= 85) return {
    level: 'התאמה מעולה',
    description: 'רמת התאמה גבוהה מאוד עם פוטנציאל רב להצלחה',
    icon: <Star className="w-5 h-5" fill="currentColor" />
  };
  if (score >= 70) return {
    level: 'התאמה טובה',
    description: 'בסיס חזק לקשר משמעותי עם אתגרים מינימליים',
    icon: <CheckCircle className="w-5 h-5" />
  };
  if (score >= 55) return {
    level: 'התאמה בינונית',
    description: 'פוטנציאל טוב עם נקודות לעבודה משותפת',
    icon: <Target className="w-5 h-5" />
  };
  return {
    level: 'התאמה מאתגרת',
    description: 'דורש השקעה ותקשורת מעמיקה יותר',
    icon: <AlertCircle className="w-5 h-5" />
  };
};

const Section: React.FC<{
  title: string;
  icon: React.ElementType;
  iconColorClass: string;
  bgColorClass: string;
  children: React.ReactNode;
}> = ({ title, icon: Icon, iconColorClass, bgColorClass, children }) => (
  <Card className={cn("overflow-hidden border-0 shadow-lg", bgColorClass)}>
    <CardHeader className="pb-4">
      <CardTitle className="flex items-center gap-3 text-xl">
        <div className={cn("p-3 rounded-xl shadow-md", iconColorClass.replace('text-', 'bg-').replace('-600', '-100'))}>
          <Icon className={cn("w-6 h-6", iconColorClass)} />
        </div>
        <span className="font-bold text-gray-800">{title}</span>
      </CardTitle>
    </CardHeader>
    <CardContent className="pt-0">{children}</CardContent>
  </Card>
);

const CompatibilityPoint: React.FC<{
  point: { area: string; explanation: string };
  index: number;
}> = ({ point, index }) => (
  <div className="group p-4 bg-white/70 backdrop-blur-sm rounded-xl border border-emerald-100 shadow-sm hover:shadow-md transition-all duration-300 hover:-translate-y-1">
    <div className="flex items-start gap-3">
      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gradient-to-r from-emerald-400 to-green-500 text-white flex items-center justify-center text-sm font-bold shadow-md">
        {index + 1}
      </div>
      <div className="flex-1 space-y-2">
        <h4 className="font-semibold text-emerald-800 text-base leading-tight">{point.area}</h4>
        <p className="text-sm text-emerald-900/80 leading-relaxed">{point.explanation}</p>
      </div>
    </div>
  </div>
);

const ConsiderationPoint: React.FC<{
  point: { area: string; explanation: string };
  index: number;
}> = ({ point, index }) => (
  <div className="group p-4 bg-white/70 backdrop-blur-sm rounded-xl border border-cyan-100 shadow-sm hover:shadow-md transition-all duration-300 hover:-translate-y-1">
    <div className="flex items-start gap-3">
      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gradient-to-r from-cyan-400 to-blue-500 text-white flex items-center justify-center text-sm font-bold shadow-md">
        {index + 1}
      </div>
      <div className="flex-1 space-y-2">
        <h4 className="font-semibold text-cyan-800 text-base leading-tight">{point.area}</h4>
        <p className="text-sm text-cyan-900/80 leading-relaxed">{point.explanation}</p>
      </div>
    </div>
  </div>
);

const ConversationStarter: React.FC<{
  starter: string;
  index: number;
}> = ({ starter, index }) => (
  <div className="group flex items-start gap-3 p-3 bg-white/60 backdrop-blur-sm rounded-lg border border-blue-100 hover:bg-white/80 transition-all duration-300 hover:shadow-sm">
    <div className="flex-shrink-0 w-6 h-6 rounded-full bg-gradient-to-r from-blue-400 to-cyan-500 text-white flex items-center justify-center text-xs font-bold shadow-sm">
      {index + 1}
    </div>
    <p className="text-sm text-blue-900 leading-relaxed font-medium">{starter}</p>
  </div>
);

const UserAiAnalysisDisplay: React.FC<UserAiAnalysisDisplayProps> = ({ analysis }) => {
  const scoreColors = getScoreColor(analysis.overallScore);
  const scoreInterpretation = getScoreInterpretation(analysis.overallScore);

  return (
    <div className="space-y-8 p-2">
      {/* Header Summary */}
      <Card className={cn("text-center border-0 shadow-xl overflow-hidden bg-gradient-to-br", scoreColors.bg)}>
        <CardContent className="p-8 relative">
          {/* Background decoration */}
          <div className="absolute top-0 right-0 w-32 h-32 bg-white/10 rounded-full blur-2xl"></div>
          <div className="absolute bottom-0 left-0 w-24 h-24 bg-white/10 rounded-full blur-xl"></div>
          
          <div className="relative z-10 space-y-6">
            <div className="flex justify-center mb-4">
              <div className={cn("p-4 rounded-2xl shadow-lg", scoreColors.badge)}>
                <Brain className="w-8 h-8 text-white" />
              </div>
            </div>
            
            <div className="space-y-3">
              <h2 className="text-3xl font-bold text-gray-800 tracking-tight">
                {analysis.matchTitle}
              </h2>
              <p className="text-lg text-gray-700 max-w-2xl mx-auto leading-relaxed">
                {analysis.matchSummary}
              </p>
            </div>

            <div className="space-y-4">
              <div className="flex items-center justify-center gap-3">
                {scoreInterpretation.icon}
                <Badge 
                  className={cn(
                    "text-xl font-bold px-6 py-3 rounded-2xl text-white border-0 shadow-lg",
                    scoreColors.badge
                  )}
                >
                  ציון התאמה: {analysis.overallScore}%
                </Badge>
              </div>
              
              <div className="max-w-md mx-auto space-y-2">
                <Progress 
                  value={analysis.overallScore} 
                  className="h-3 bg-white/50"
                />
                <div className="flex justify-between text-sm font-medium text-gray-600">
                  <span>{scoreInterpretation.level}</span>
                  <span>{analysis.overallScore}%</span>
                </div>
                <p className="text-sm text-gray-600 text-center">
                  {scoreInterpretation.description}
                </p>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Compatibility Points */}
      <Section 
        title="נקודות חיבור חזקות" 
        icon={Heart} 
        iconColorClass="text-emerald-600"
        bgColorClass="bg-gradient-to-br from-emerald-50/80 to-green-50/60"
      >
        <div className="space-y-4">
          {analysis.compatibilityPoints.length > 0 ? (
            analysis.compatibilityPoints.map((point, index) => (
              <CompatibilityPoint key={index} point={point} index={index} />
            ))
          ) : (
            <div className="text-center py-8 text-gray-500">
              <Heart className="w-12 h-12 mx-auto mb-3 opacity-50" />
              <p>לא נמצאו נקודות חיבור ספציפיות בניתוח</p>
            </div>
          )}
        </div>
      </Section>

      {/* Points to Consider */}
      <Section 
        title="נקודות למחשבה וצמיחה" 
        icon={Lightbulb} 
        iconColorClass="text-cyan-600"
        bgColorClass="bg-gradient-to-br from-cyan-50/80 to-blue-50/60"
      >
        <div className="space-y-4">
          {analysis.pointsToConsider.length > 0 ? (
            analysis.pointsToConsider.map((point, index) => (
              <ConsiderationPoint key={index} point={point} index={index} />
            ))
          ) : (
            <div className="text-center py-8 text-gray-500">
              <Lightbulb className="w-12 h-12 mx-auto mb-3 opacity-50" />
              <p>לא נמצאו נקודות מיוחדות לתשומת לב</p>
            </div>
          )}
        </div>
      </Section>

      {/* Conversation Starters */}
      <Section 
        title="נושאים מומלצים לפתיחת שיחה" 
        icon={MessageSquareQuote} 
        iconColorClass="text-blue-600"
        bgColorClass="bg-gradient-to-br from-blue-50/80 to-cyan-50/60"
      >
        <div className="space-y-3">
          {analysis.suggestedConversationStarters.length > 0 ? (
            analysis.suggestedConversationStarters.map((starter, index) => (
              <ConversationStarter key={index} starter={starter} index={index} />
            ))
          ) : (
            <div className="text-center py-8 text-gray-500">
              <MessageSquareQuote className="w-12 h-12 mx-auto mb-3 opacity-50" />
              <p>לא נמצאו הצעות ספציפיות לפתיחת שיחה</p>
            </div>
          )}
        </div>
      </Section>

      {/* Bottom Note */}
      <Card className="border-0 shadow-lg bg-gradient-to-r from-cyan-50 to-emerald-50">
        <CardContent className="p-6 text-center">
          <div className="flex items-center justify-center gap-2 mb-3">
            <Sparkles className="w-5 h-5 text-cyan-600" />
            <span className="font-semibold text-cyan-800">הערה חשובה</span>
          </div>
          <p className="text-sm text-cyan-700 leading-relaxed max-w-2xl mx-auto">
            הניתוח מבוסס על נתונים זמינים ומהווה נקודת מוצא לחשיבה. 
            כל קשר אנושי הוא ייחודי ודורש הכרות אישית עמוקה יותר.
          </p>
        </CardContent>
      </Card>
    </div>
  );
};

export default UserAiAnalysisDisplay;
--- End of Content for UserAiAnalysisDisplay.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\dialogs
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\dialogs\AskMatchmakerDialog.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/dialogs/AskMatchmakerDialog.tsx

import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { 
  MessageCircle, 
  Send, 
  AlertCircle, 
  Heart,
  Users,
  BookOpen,
  Calendar,
  Lightbulb,
  Clock,
  User,
  Sparkles
} from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { cn } from "@/lib/utils";

interface AskMatchmakerDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (question: string) => Promise<void>;
  matchmakerName?: string;
  suggestionId?: string;
}

interface QuestionTopic {
  id: string;
  label: string;
  icon: React.ElementType;
  color: string;
  description: string;
  questions: string[];
}

const questionTopics: QuestionTopic[] = [
  {
    id: "values",
    label: "ערכים ואמונות",
    icon: Heart,
    color: "from-cyan-500 to-blue-500",
    description: "שאלות על השקפת עולם ומערכת ערכים",
    questions: [
      "האם יש משהו שחשוב לדעת לגבי השקפת העולם שלו/ה?",
      "מה מידת החשיבות שהוא/היא מייחס/ת לנושאים דתיים?",
      "האם יש לו/ה קווים אדומים בנושאי השקפה?",
      "איך הוא/היא רואה את התפקיד של המסורת בחיי היומיום?",
    ]
  },
  {
    id: "family",
    label: "משפחה ורקע",
    icon: Users,
    color: "from-emerald-500 to-green-500",
    description: "שאלות על המשפחה והרקע האישי",
    questions: [
      "איך ניתן לתאר את המשפחה שלו/ה?",
      "האם יש דברים חשובים לדעת לגבי המשפחה?",
      "מה חשוב לו/ה בנושא בניית משפחה?",
      "איך הקשר שלו/ה עם המשפחה המורחבת?",
    ]
  },
  {
    id: "career",
    label: "תעסוקה ולימודים",
    icon: BookOpen,
    color: "from-blue-500 to-cyan-500",
    description: "שאלות על קריירה והשכלה",
    questions: [
      "מה התוכניות המקצועיות שלו/ה לטווח הארוך?",
      "האם הוא/היא מעוניין/ת בשינוי תעסוקתי?",
      "איך הוא/היא רואה את האיזון בין קריירה ומשפחה?",
      "מה התחומים שמעניינים אותו/ה ללימוד נוסף?",
    ]
  },
  {
    id: "personality",
    label: "אופי ומזג",
    icon: Sparkles,
    color: "from-pink-500 to-rose-500",
    description: "שאלות על אישיות ותכונות אופי",
    questions: [
      "איך היית מתאר/ת את האופי שלו/ה?",
      "מה הן התכונות החזקות ביותר שלו/ה?",
      "האם יש משהו שכדאי לדעת לגבי המזג?",
      "איך הוא/היא מתמודל/ת עם לחץ ואתגרים?",
    ]
  },
  {
    id: "future",
    label: "תוכניות לעתיד",
    icon: Calendar,
    color: "from-amber-500 to-orange-500",
    description: "שאלות על חזון ותוכניות עתידיות",
    questions: [
      "מה החלומות שלו/ה לטווח הארוך?",
      "האם יש לו/ה תוכניות לשינוי מקום מגורים?",
      "מה החזון שלו/ה לחיי המשפחה?",
      "איך הוא/היא רואה את החיים שלו/ה בעוד 10 שנים?",
    ]
  },
  {
    id: "other",
    label: "שאלה אחרת",
    icon: Lightbulb,
    color: "from-gray-500 to-slate-500",
    description: "שאלה ספציפית או נושא אחר",
    questions: ["יש לי שאלה ספציפית..."]
  }
];

export const AskMatchmakerDialog: React.FC<AskMatchmakerDialogProps> = ({
  isOpen,
  onClose,
  onSubmit,
  matchmakerName,
}) => {
  const [question, setQuestion] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedTopic, setSelectedTopic] = useState<string | null>(null);

  const handleSubmit = async () => {
    if (!question.trim()) return;

    try {
      setIsSubmitting(true);
      setError(null);
      await onSubmit(question);
      setQuestion("");
      setSelectedTopic(null);
      onClose();
    } catch (error) {
      console.error("Error submitting question:", error);
      setError("אירעה שגיאה בשליחת השאלה. אנא נסה שוב מאוחר יותר.");
    } finally {
      setIsSubmitting(false);
    }
  };

  const getInitials = (name?: string) => {
    if (!name) return "שד";
    const parts = name.split(" ");
    if (parts.length === 1) return parts[0].charAt(0);
    return `${parts[0].charAt(0)}${parts[parts.length - 1].charAt(0)}`;
  };

  const selectedTopicData = questionTopics.find(t => t.id === selectedTopic);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] flex flex-col p-0 border-0 shadow-2xl rounded-3xl bg-white overflow-hidden">
        {/* Header */}
        <DialogHeader className="px-8 py-6 bg-gradient-to-r from-cyan-50/80 via-white to-emerald-50/50 border-b border-gray-100">
          <div className="flex items-center gap-4 mb-4">
            <Avatar className="w-16 h-16 border-4 border-white shadow-lg">
              <AvatarFallback className="bg-gradient-to-br from-cyan-500 to-emerald-500 text-white text-xl font-bold">
                {getInitials(matchmakerName)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1">
              <DialogTitle className="text-2xl font-bold text-gray-800 mb-1">
                שאלה ל{matchmakerName ? ` ${matchmakerName}` : "שדכן"}
              </DialogTitle>
              <DialogDescription className="text-gray-600 text-base">
                השדכן/ית זמין/ה לענות על כל שאלה שיש לך לגבי המועמד/ת
              </DialogDescription>
            </div>
            <Badge className="bg-gradient-to-r from-green-500 to-emerald-500 text-white border-0 shadow-md px-3 py-1">
              <Clock className="w-3 h-3 ml-1" />
              זמין/ה עכשיו
            </Badge>
          </div>
        </DialogHeader>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-8 space-y-6">
          {error && (
            <Alert variant="destructive" className="border-red-200 bg-red-50">
              <AlertCircle className="h-5 w-5" />
              <AlertDescription className="text-red-800 font-medium">{error}</AlertDescription>
            </Alert>
          )}

          {/* Topic Selection */}
          <div className="space-y-4">
            <div className="text-center">
              <h3 className="text-lg font-semibold text-gray-800 mb-2">איזה נושא מעניין אותך?</h3>
              <p className="text-sm text-gray-600">בחר קטגוריה כדי לקבל שאלות לדוגמה</p>
            </div>
            
            <div className="grid grid-cols-2 lg:grid-cols-3 gap-3">
              {questionTopics.map((topic) => (
                <Card
                  key={topic.id}
                  className={cn(
                    "cursor-pointer transition-all duration-300 border-2 hover:shadow-lg hover:-translate-y-1",
                    selectedTopic === topic.id
                      ? "border-cyan-300 bg-cyan-50 shadow-md"
                      : "border-gray-200 hover:border-cyan-200"
                  )}
                  onClick={() => setSelectedTopic(topic.id)}
                >
                  <CardContent className="p-4 text-center">
                    <div className={cn("w-12 h-12 rounded-xl mx-auto mb-3 flex items-center justify-center bg-gradient-to-r text-white shadow-md", topic.color)}>
                      <topic.icon className="w-6 h-6" />
                    </div>
                    <h4 className="font-semibold text-gray-800 text-sm mb-1">{topic.label}</h4>
                    <p className="text-xs text-gray-600 leading-relaxed">{topic.description}</p>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>

          {/* Sample Questions */}
          {selectedTopicData && (
            <Card className="bg-gradient-to-r from-cyan-50/50 to-emerald-50/50 border-cyan-200/50">
              <CardContent className="p-6">
                <div className="flex items-center gap-2 mb-4">
                  <selectedTopicData.icon className="w-5 h-5 text-cyan-600" />
                  <h4 className="font-semibold text-cyan-800">שאלות לדוגמה - {selectedTopicData.label}</h4>
                </div>
                <div className="space-y-2 max-h-32 overflow-y-auto scrollbar-elegant">
                  {selectedTopicData.questions.map((q, index) => (
                    <Button
                      key={index}
                      variant="ghost"
                      className="w-full justify-end text-right hover:bg-cyan-100 hover:text-cyan-800 transition-colors rounded-lg p-3 h-auto"
                      onClick={() => setQuestion(q)}
                    >
                      <span className="text-sm leading-relaxed">{q}</span>
                    </Button>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}

          {/* Question Input */}
          <div className="space-y-3">
            <Label htmlFor="question" className="text-base font-semibold text-gray-800">
              שאלתך
            </Label>
            <Textarea
              id="question"
              value={question}
              onChange={(e) => setQuestion(e.target.value)}
              placeholder="כתוב כאן את שאלתך... השדכן/ית ישמח/תשמח לעזור ולהשיב"
              className="min-h-[120px] text-right border-gray-200 focus:border-cyan-300 focus:ring-cyan-200 rounded-xl text-base leading-relaxed resize-none"
            />
            <div className="flex justify-between items-center text-xs text-gray-500">
              <span>{question.length}/500 תווים</span>
              <span>השאלה תישלח ישירות לשדכן/ית</span>
            </div>
          </div>
        </div>

        {/* Footer */}
        <DialogFooter className="px-8 py-6 border-t border-gray-100 bg-gray-50/50">
          <div className="flex gap-3 w-full">
            <Button
              type="button"
              variant="outline"
              onClick={onClose}
              disabled={isSubmitting}
              className="flex-1 border-gray-200 hover:bg-gray-50 rounded-xl font-medium"
            >
              ביטול
            </Button>
            <Button
              type="submit"
              onClick={handleSubmit}
              disabled={!question.trim() || isSubmitting}
              className="flex-1 bg-gradient-to-r from-cyan-500 to-emerald-500 hover:from-cyan-600 hover:to-emerald-600 text-white shadow-lg hover:shadow-xl transition-all duration-300 rounded-xl font-medium"
            >
              {isSubmitting ? (
                <>
                  <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin ml-2" />
                  שולח...
                </>
              ) : (
                <>
                  <Send className="w-4 h-4 ml-2" />
                  שלח שאלה
                </>
              )}
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default AskMatchmakerDialog;
--- End of Content for AskMatchmakerDialog.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\dialogs\UserAiAnalysisDialog.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/dialogs/UserAiAnalysisDialog.tsx
"use client";

import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Loader2, Sparkles, AlertTriangle, Bot, Brain, Heart } from 'lucide-react';
import { toast } from 'sonner';

import UserAiAnalysisDisplay from '../compatibility/UserAiAnalysisDisplay'; 
import type { AiSuggestionAnalysisResult } from '@/lib/services/aiService';

interface UserAiAnalysisDialogProps {
  suggestedUserId: string;
}

export const UserAiAnalysisDialog: React.FC<UserAiAnalysisDialogProps> = ({ suggestedUserId }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [analysis, setAnalysis] = useState<AiSuggestionAnalysisResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleGetAnalysis = async () => {
    if (analysis) {
      setIsOpen(true);
      return;
    }
    
    setIsOpen(true);
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/ai/analyze-suggestion', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ suggestedUserId }),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'שגיאה בקבלת ניתוח ההצעה.');
      }

      setAnalysis(result.data);

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'אירעה שגיאה לא צפויה.';
      setError(errorMessage);
      toast.error('שגיאה בתהליך הניתוח', {
        description: errorMessage,
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    if (!open) {
      setError(null); 
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>
        <Button
          onClick={handleGetAnalysis}
          variant="outline"
          size="lg"
          className="relative overflow-hidden group bg-gradient-to-r from-cyan-50 to-emerald-50 border-2 border-cyan-200 text-cyan-700 hover:from-cyan-100 hover:to-emerald-100 hover:border-cyan-300 transition-all duration-300 shadow-lg hover:shadow-xl rounded-2xl px-8 py-4 font-semibold"
          disabled={isLoading}
        >
          {/* Shimmer effect */}
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent transform -translate-x-full group-hover:animate-shimmer"></div>
          
          <div className="relative z-10 flex items-center gap-3">
            {isLoading ? (
              <Loader2 className="w-5 h-5 animate-spin text-cyan-600" />
            ) : (
              <div className="relative">
                <Brain className="w-5 h-5 transition-transform duration-500 group-hover:rotate-12 group-hover:scale-110 text-cyan-600" />
                <Sparkles className="w-3 h-3 absolute -top-1 -right-1 text-emerald-500 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
              </div>
            )}
            <span>{isLoading ? 'מכין ניתוח...' : 'ייעוץ AI על ההתאמה'}</span>
          </div>
        </Button>
      </DialogTrigger>
      
      <DialogContent 
        className="max-w-5xl w-[95vw] h-[90vh] flex flex-col p-0 border-0 shadow-2xl rounded-3xl bg-gradient-to-br from-white via-cyan-50/20 to-emerald-50/20"
        dir="rtl"
      >
        <DialogHeader className="p-8 border-b border-cyan-100 bg-white/80 backdrop-blur-sm rounded-t-3xl">
          <DialogTitle className="flex items-center gap-3 text-2xl font-bold text-gray-800">
            <div className="p-3 rounded-full bg-gradient-to-br from-cyan-500 to-emerald-500 text-white shadow-lg">
              <Bot className="w-6 h-6" />
            </div>
            <span>ניתוח התאמה מבוסס AI</span>
          </DialogTitle>
          <DialogDescription className="text-lg text-gray-600 mt-2">
            סקירה חכמה של נקודות החיבור והאתגרים הפוטנציאליים בהצעה זו
          </DialogDescription>
        </DialogHeader>

        <div className="flex-grow overflow-y-auto p-6 md:p-8">
          {isLoading ? (
            <div className="flex flex-col items-center justify-center h-full text-center space-y-6">
              <div className="relative">
                <div className="w-20 h-20 rounded-full bg-gradient-to-br from-cyan-200 to-emerald-200 animate-pulse"></div>
                <Loader2 className="w-12 h-12 text-cyan-600 animate-spin absolute inset-0 m-auto" />
              </div>
              <div className="space-y-2">
                <p className="text-xl font-semibold text-gray-700">ה-AI שלנו בוחן את ההתאמה...</p>
                <p className="text-gray-500 max-w-md">זה עשוי לקחת מספר שניות. אנו מנתחים עשרות פרמטרים להבנה מעמיקה של ההתאמה.</p>
              </div>
              
              <div className="grid grid-cols-3 gap-4 mt-8">
                {[
                  { icon: Brain, label: 'ניתוח אישיות', delay: '0ms', color: 'text-cyan-600' },
                  { icon: Heart, label: 'התאמת ערכים', delay: '200ms', color: 'text-emerald-600' },
                  { icon: Sparkles, label: 'פוטנציאל יחד', delay: '400ms', color: 'text-blue-600' }
                ].map((item, index) => (
                  <div 
                    key={index} 
                    className="flex flex-col items-center gap-2 opacity-50 animate-pulse"
                    style={{ animationDelay: item.delay }}
                  >
                    <div className="p-3 rounded-full bg-white shadow-md">
                      <item.icon className={`w-6 h-6 ${item.color}`} />
                    </div>
                    <span className="text-sm text-gray-600 font-medium">{item.label}</span>
                  </div>
                ))}
              </div>
            </div>
          ) : error ? (
            <div className="flex flex-col items-center justify-center h-full text-center space-y-6">
              <div className="p-4 rounded-full bg-red-100">
                <AlertTriangle className="h-12 w-12 text-red-600" />
              </div>
              <Alert variant="destructive" className="max-w-md border-red-200 bg-red-50">
                <AlertTriangle className="h-5 w-5" />
                <AlertTitle className="text-red-800">אופס, משהו השתבש</AlertTitle>
                <AlertDescription className="text-red-700">
                  <p>לא הצלחנו להשלים את ניתוח ההתאמה כרגע.</p>
                  <p className="text-sm mt-2 opacity-90">{error}</p>
                </AlertDescription>
              </Alert>
              <Button 
                onClick={handleGetAnalysis} 
                variant="outline" 
                className="mt-4 border-red-200 text-red-600 hover:bg-red-50"
              >
                <Brain className="w-4 h-4 ml-2" />
                נסה שוב
              </Button>
            </div>
          ) : analysis ? (
            <UserAiAnalysisDisplay analysis={analysis} />
          ) : (
            <div className="flex items-center justify-center h-full">
              <div className="text-center space-y-4">
                <div className="w-16 h-16 rounded-full bg-gradient-to-br from-cyan-100 to-emerald-100 flex items-center justify-center mx-auto">
                  <Brain className="w-8 h-8 text-cyan-600" />
                </div>
                <p className="text-gray-600 font-medium">מכין את הניתוח...</p>
              </div>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};
--- End of Content for UserAiAnalysisDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\inquiries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\inquiries\InquiryThreadView.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/inquiries/InquiryThreadView.tsx

import React, { useState, useEffect, useCallback } from "react";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardFooter,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { format } from "date-fns";
import { he } from "date-fns/locale";
import { 
  Send, 
  MessageCircle, 
  Loader2, 
  CheckCircle, 
  Clock, 
  AlertTriangle,
  User,
  MessageSquare,
  Sparkles,
  ArrowDown
} from "lucide-react";
import { toast } from "sonner";
import { cn } from "@/lib/utils";

interface Inquiry {
  id: string;
  suggestionId: string;
  fromUserId: string;
  toUserId: string;
  question: string;
  answer: string | null;
  status: "PENDING" | "ANSWERED" | "CLOSED";
  createdAt: string | Date;
  answeredAt: string | Date | null;
  fromUser: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
  toUser: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface InquiryThreadViewProps {
  suggestionId: string;
  userId: string;
  showComposer?: boolean;
  className?: string;
}

const getStatusInfo = (status: Inquiry["status"]) => {
  switch (status) {
    case "PENDING":
      return {
        label: "ממתין לתשובה",
        className: "bg-gradient-to-r from-amber-100 to-orange-100 text-amber-800 border-amber-200",
        icon: <Clock className="w-3 h-3" />,
        pulse: true,
      };
    case "ANSWERED":
      return {
        label: "נענה",
        className: "bg-gradient-to-r from-emerald-100 to-green-100 text-emerald-800 border-emerald-200",
        icon: <CheckCircle className="w-3 h-3" />,
        pulse: false,
      };
    case "CLOSED":
      return {
        label: "סגור",
        className: "bg-gradient-to-r from-gray-100 to-slate-100 text-gray-700 border-gray-200",
        icon: <MessageCircle className="w-3 h-3" />,
        pulse: false,
      };
    default:
      return {
        label: String(status),
        className: "bg-gradient-to-r from-gray-100 to-slate-100 text-gray-700 border-gray-200",
        icon: <AlertTriangle className="w-3 h-3" />,
        pulse: false,
      };
  }
};

const MessageBubble: React.FC<{
  inquiry: Inquiry;
  userId: string;
  isLatest: boolean;
}> = ({ inquiry, userId, isLatest }) => {
  const isMyQuestion = inquiry.fromUserId === userId;
  const statusInfo = getStatusInfo(inquiry.status);
  
  const formatDate = (date: string | Date | null) => {
    if (!date) return "";
    try {
      return format(new Date(date), "dd בMMMM yyyy, HH:mm", { locale: he });
    } catch (e) {
      console.error("Error formatting date:", date, e);
      return "תאריך לא תקין";
    }
  };

  const getInitials = (firstName: string, lastName: string) => {
    return `${firstName.charAt(0)}${lastName.charAt(0)}`.toUpperCase();
  };

  return (
    <div className={cn(
      "relative transition-all duration-300",
      isLatest && "animate-fade-in-up"
    )}>
      {/* Question */}
      <div className={cn(
        "flex gap-4 mb-4",
        isMyQuestion ? "flex-row-reverse" : "flex-row"
      )}>
        <Avatar className="w-10 h-10 flex-shrink-0 shadow-md">
          <AvatarFallback className={cn(
            "font-bold text-sm",
            isMyQuestion 
              ? "bg-gradient-to-br from-cyan-500 to-blue-500 text-white" 
              : "bg-gradient-to-br from-emerald-500 to-green-500 text-white"
          )}>
            {getInitials(inquiry.fromUser.firstName, inquiry.fromUser.lastName)}
          </AvatarFallback>
        </Avatar>

        <div className={cn("flex-1 max-w-[85%]", isMyQuestion ? "ml-auto" : "mr-auto")}>
          {/* Header */}
          <div className={cn(
            "flex items-center gap-2 mb-2",
            isMyQuestion ? "flex-row-reverse justify-start" : "flex-row justify-start"
          )}>
            <span className="font-semibold text-gray-800 text-sm">
              {inquiry.fromUser.firstName} {inquiry.fromUser.lastName}
            </span>
            <Badge 
              className={cn(
                "text-xs px-2 py-1 font-medium border shadow-sm",
                statusInfo.className,
                statusInfo.pulse && "animate-pulse-subtle"
              )}
            >
              {statusInfo.icon}
              <span className="mr-1">{statusInfo.label}</span>
            </Badge>
            <span className="text-xs text-gray-400">
              {formatDate(inquiry.createdAt)}
            </span>
          </div>

          {/* Question Bubble */}
          <div className={cn(
            "p-4 rounded-2xl shadow-md relative max-w-full",
            isMyQuestion
              ? "bg-gradient-to-r from-cyan-500 to-blue-500 text-white rounded-br-md"
              : "bg-white border border-gray-200 text-gray-800 rounded-bl-md"
          )}>
            <p className="text-sm leading-relaxed whitespace-pre-wrap break-words">
              {inquiry.question}
            </p>
            
            {/* Triangle pointer */}
            <div className={cn(
              "absolute top-4 w-3 h-3 transform rotate-45",
              isMyQuestion
                ? "-right-1.5 bg-cyan-600"
                : "-left-1.5 bg-white border-l border-b border-gray-200"
            )} />
          </div>
        </div>
      </div>

      {/* Answer */}
      {inquiry.answer && inquiry.answeredAt && (
        <div className="flex gap-4 mt-6 mb-2">
          <Avatar className="w-10 h-10 flex-shrink-0 shadow-md">
            <AvatarFallback className="bg-gradient-to-br from-emerald-500 to-green-600 text-white font-bold text-sm">
              {getInitials(inquiry.toUser.firstName, inquiry.toUser.lastName)}
            </AvatarFallback>
          </Avatar>

          <div className="flex-1 max-w-[85%]">
            {/* Answer Header */}
            <div className="flex items-center gap-2 mb-2">
              <span className="font-semibold text-gray-800 text-sm">
                {inquiry.toUser.firstName} {inquiry.toUser.lastName}
              </span>
              <Badge className="bg-gradient-to-r from-emerald-500 to-green-500 text-white border-0 text-xs px-2 py-1 font-medium">
                <CheckCircle className="w-3 h-3 mr-1" />
                תשובה
              </Badge>
              <span className="text-xs text-gray-400">
                {formatDate(inquiry.answeredAt)}
              </span>
            </div>

            {/* Answer Bubble */}
            <div className="p-4 bg-gradient-to-r from-emerald-50 to-green-50 border border-emerald-200 rounded-2xl rounded-bl-md shadow-md relative">
              <p className="text-sm text-emerald-900 leading-relaxed whitespace-pre-wrap break-words">
                {inquiry.answer}
              </p>
              
              {/* Triangle pointer */}
              <div className="absolute top-4 -left-1.5 w-3 h-3 bg-emerald-50 border-l border-b border-emerald-200 transform rotate-45" />
            </div>
          </div>
        </div>
      )}

      {/* Separator */}
      {!isLatest && (
        <div className="flex items-center my-6">
          <div className="flex-1 h-px bg-gradient-to-r from-transparent via-gray-200 to-transparent" />
          <ArrowDown className="w-4 h-4 text-gray-400 mx-3" />
          <div className="flex-1 h-px bg-gradient-to-r from-transparent via-gray-200 to-transparent" />
        </div>
      )}
    </div>
  );
};

const InquiryThreadView: React.FC<InquiryThreadViewProps> = ({
  suggestionId,
  userId,
  showComposer = true,
  className,
}) => {
  const [inquiries, setInquiries] = useState<Inquiry[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [newQuestion, setNewQuestion] = useState("");
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchInquiries = useCallback(async () => {
    if (!suggestionId) {
      setInquiries([]);
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(`/api/suggestions/${suggestionId}/inquiries`);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error("Failed to fetch inquiries:", response.status, errorData);
        throw new Error(`Failed to fetch inquiries (${response.status})`);
      }

      const data = await response.json();
      setInquiries(Array.isArray(data.inquiries) ? data.inquiries : []);
    } catch (error) {
      console.error("Error fetching inquiries:", error);
      setError("אירעה שגיאה בטעינת השאלות");
    } finally {
      setIsLoading(false);
    }
  }, [suggestionId]);

  useEffect(() => {
    fetchInquiries();
  }, [fetchInquiries]);

  const handleSendQuestion = async () => {
    if (!newQuestion.trim()) return;

    try {
      setIsSending(true);
      setError(null);

      const response = await fetch(`/api/suggestions/${suggestionId}/inquiries`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ question: newQuestion }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error("Failed to send inquiry:", response.status, errorData);
        throw new Error(`Failed to send inquiry (${response.status})`);
      }

      await fetchInquiries();
      setNewQuestion("");
      toast.success("השאלה נשלחה בהצלחה", {
        description: "השדכן יקבל הודעה ויחזור אליך בהקדם"
      });
    } catch (error) {
      console.error("Error sending inquiry:", error);
      setError("אירעה שגיאה בשליחת השאלה");
      toast.error("אירעה שגיאה בשליחת השאלה");
    } finally {
      setIsSending(false);
    }
  };

  const pendingCount = inquiries.filter(i => i.status === "PENDING").length;
  const answeredCount = inquiries.filter(i => i.status === "ANSWERED").length;

  return (
    <Card className={cn("shadow-xl border-0 bg-white overflow-hidden", className)}>
      <CardHeader className="pb-4 bg-gradient-to-r from-cyan-50/80 via-white to-emerald-50/50 border-b border-gray-100">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="p-2 rounded-lg bg-gradient-to-r from-cyan-500 to-emerald-500 text-white shadow-md">
              <MessageSquare className="w-5 h-5" />
            </div>
            <div>
              <CardTitle className="text-xl font-bold text-gray-800">
                שיחה עם השדכן
              </CardTitle>
              <p className="text-sm text-gray-600 mt-1">
                שאל שאלות וקבל תשובות מקצועיות
              </p>
            </div>
          </div>
          
          {inquiries.length > 0 && (
            <div className="flex items-center gap-2">
              {answeredCount > 0 && (
                <Badge className="bg-gradient-to-r from-emerald-500 to-green-500 text-white border-0 px-3 py-1 shadow-md">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  {answeredCount} נענו
                </Badge>
              )}
              {pendingCount > 0 && (
                <Badge className="bg-gradient-to-r from-amber-500 to-orange-500 text-white border-0 px-3 py-1 shadow-md animate-pulse-subtle">
                  <Clock className="w-3 h-3 ml-1" />
                  {pendingCount} ממתינות
                </Badge>
              )}
            </div>
          )}
        </div>
      </CardHeader>

      <CardContent className="flex-1 max-h-[500px] overflow-y-auto p-6 space-y-6 scrollbar-elegant">
        {isLoading ? (
          <div className="space-y-6">
            {Array.from({ length: 2 }).map((_, i) => (
              <div key={i} className="flex gap-4">
                <Skeleton className="h-10 w-10 rounded-full" />
                <div className="space-y-2 flex-1">
                  <Skeleton className="h-4 w-24" />
                  <Skeleton className="h-16 w-full rounded-2xl" />
                </div>
              </div>
            ))}
          </div>
        ) : error ? (
          <div className="text-center py-8">
            <div className="w-16 h-16 rounded-full bg-red-100 flex items-center justify-center mx-auto mb-4">
              <AlertTriangle className="w-8 h-8 text-red-500" />
            </div>
            <h3 className="font-semibold text-red-800 mb-2">שגיאה בטעינה</h3>
            <p className="text-red-600 text-sm mb-4">{error}</p>
            <Button
              variant="outline"
              size="sm"
              onClick={fetchInquiries}
              className="border-red-300 text-red-600 hover:bg-red-50"
            >
              נסה שוב
            </Button>
          </div>
        ) : inquiries.length === 0 ? (
          <div className="text-center py-12">
            <div className="w-20 h-20 rounded-full bg-gradient-to-br from-cyan-100 to-emerald-100 flex items-center justify-center mx-auto mb-6">
              <MessageCircle className="w-10 h-10 text-cyan-500" />
            </div>
            <h3 className="text-xl font-semibold text-gray-700 mb-2">
              התחל שיחה עם השדכן
            </h3>
            <p className="text-gray-500 max-w-md mx-auto leading-relaxed">
              יש לך שאלות על המועמד/ת? השדכן כאן כדי לעזור ולספק מידע נוסף שיעזור לך להחליט
            </p>
            {showComposer && (
              <div className="mt-6">
                <Sparkles className="w-6 h-6 text-cyan-500 mx-auto mb-2" />
                <p className="text-sm text-cyan-600 font-medium">
                  התחל לכתוב שאלה למטה
                </p>
              </div>
            )}
          </div>
        ) : (
          <div className="space-y-6">
            {inquiries.map((inquiry, index) => (
              <MessageBubble
                key={inquiry.id}
                inquiry={inquiry}
                userId={userId}
                isLatest={index === inquiries.length - 1}
              />
            ))}
          </div>
        )}
      </CardContent>

      {showComposer && (
        <CardFooter className="p-6 border-t border-gray-100 bg-gradient-to-r from-gray-50 to-white space-y-4">
          <div className="w-full space-y-3">
            <div className="flex items-center gap-2 text-sm text-gray-600">
              <User className="w-4 h-4 text-cyan-500" />
              <span>שאלה חדשה לשדכן</span>
            </div>
            
            <Textarea
              placeholder="כתוב כאן את שאלתך... השדכן ישמח לעזור ולהשיב"
              value={newQuestion}
              onChange={(e) => setNewQuestion(e.target.value)}
              className="text-right border-gray-200 focus:border-cyan-300 focus:ring-cyan-200 rounded-xl resize-none"
              rows={3}
              disabled={isSending}
            />
            
            <div className="flex justify-between items-center">
              <span className="text-xs text-gray-500">
                {newQuestion.length}/500 תווים
              </span>
              
              <Button
                onClick={handleSendQuestion}
                disabled={!newQuestion.trim() || isSending || isLoading}
                className="bg-gradient-to-r from-cyan-500 to-emerald-500 hover:from-cyan-600 hover:to-emerald-600 text-white shadow-lg hover:shadow-xl transition-all duration-300 rounded-xl"
              >
                {isSending ? (
                  <>
                    <Loader2 className="h-4 w-4 animate-spin ml-2" />
                    שולח...
                  </>
                ) : (
                  <>
                    <Send className="h-4 w-4 ml-2" />
                    שלח שאלה
                  </>
                )}
              </Button>
            </div>
          </div>
        </CardFooter>
      )}
    </Card>
  );
};

export default InquiryThreadView;
--- End of Content for InquiryThreadView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\list
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\list\SuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/list/SuggestionsList.tsx

"use client";
import React, { useState, useEffect } from "react";
import {
  User,
  Search,
  Filter,
  SortAsc,
  SortDesc,
  Calendar,
  Grid3X3,
  List as ListIcon,
  Check,
  XCircle,
  Sparkles,
  Heart,
  Clock,
  Users,
  TrendingUp,
  BarChart3,
} from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { toast } from "sonner";
import MinimalSuggestionCard from "../cards/MinimalSuggestionCard";
import SuggestionDetailsModal from "../modals/SuggestionDetailsModal";
import AskMatchmakerDialog from "../dialogs/AskMatchmakerDialog";
import { cn } from "@/lib/utils";
import type { ExtendedMatchSuggestion } from "../types";

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  userId: string;
  isHistory?: boolean;
  viewMode: "grid" | "list";
  isLoading?: boolean;
  className?: string;
  onStatusChange?: (
    suggestionId: string,
    newStatus: string,
    notes?: string
  ) => Promise<void>;
  onRefresh?: () => void;
  // --- START OF CHANGE ---
  isUserInActiveProcess?: boolean;
  // --- END OF CHANGE ---
}

type SortOption = "newest" | "oldest" | "deadline" | "priority";
type FilterOption =
  | "all"
  | "pending"
  | "accepted"
  | "declined"
  | "contact_shared";

// קומפוננטת EmptyState מעוצבת
const EmptyState: React.FC<{
  isFiltered: boolean;
  isHistory: boolean;
  onClearFilters: () => void;
}> = ({ isFiltered, isHistory, onClearFilters }) => (
  <div className="flex flex-col items-center justify-center min-h-[400px] text-center p-8">
    <div className="relative mb-8">
      <div className="w-32 h-32 rounded-full bg-gradient-to-br from-purple-100 to-pink-100 flex items-center justify-center shadow-lg">
        {isFiltered ? (
          <Search className="w-16 h-16 text-purple-400" />
        ) : isHistory ? (
          <Clock className="w-16 h-16 text-gray-400" />
        ) : (
          <Heart className="w-16 h-16 text-pink-400" />
        )}
      </div>
      {!isFiltered && !isHistory && (
        <div className="absolute -top-2 -right-2 w-8 h-8 rounded-full bg-gradient-to-r from-cyan-400 to-blue-500 flex items-center justify-center shadow-lg">
          <Sparkles className="w-4 h-4 text-white" />
        </div>
      )}
    </div>
    
    <h3 className="text-2xl font-bold text-gray-800 mb-3">
      {isFiltered
        ? "לא נמצאו תוצאות"
        : isHistory
        ? "אין הצעות בהיסטוריה"
        : "ההצעות בדרך אליך"}
    </h3>
    
    <p className="text-gray-600 max-w-md mx-auto mb-6 leading-relaxed">
      {isFiltered
        ? "נסה לשנות את קריטריוני החיפוש או הסינון כדי למצוא את מה שאתה מחפש"
        : isHistory
        ? "כשיהיו לך הצעות שהושלמו, הן יופיעו כאן"
        : "השדכנים שלנו עובדים עכשיו על מציאת ההתאמות המושלמות עבורך"}
    </p>
    
    {isFiltered && (
      <Button
        onClick={onClearFilters}
        className="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white shadow-lg hover:shadow-xl transition-all duration-300 rounded-xl"
      >
        <XCircle className="w-4 h-4 ml-2" />
        נקה סינון
      </Button>
    )}
  </div>
);

// קומפוננטת סטטיסטיקות
const StatsBar: React.FC<{
  total: number;
  filtered: number;
  pending: number;
  isHistory: boolean;
}> = ({ total, filtered, pending, isHistory }) => (
  <Card className="mb-6 border-0 shadow-lg bg-gradient-to-r from-white via-purple-50/50 to-pink-50/50">
    <CardContent className="p-4">
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div className="text-center">
          <div className="flex items-center justify-center gap-2 mb-1">
            <BarChart3 className="w-4 h-4 text-blue-500" />
            <span className="text-2xl font-bold text-blue-600">{filtered}</span>
          </div>
          <p className="text-xs text-gray-600 font-medium">מוצגות כעת</p>
        </div>
        
        <div className="text-center">
          <div className="flex items-center justify-center gap-2 mb-1">
            <Users className="w-4 h-4 text-purple-500" />
            <span className="text-2xl font-bold text-purple-600">{total}</span>
          </div>
          <p className="text-xs text-gray-600 font-medium">סהכ הצעות</p>
        </div>
        
        {!isHistory && (
          <div className="text-center">
            <div className="flex items-center justify-center gap-2 mb-1">
              <Clock className="w-4 h-4 text-orange-500" />
              <span className="text-2xl font-bold text-orange-600">{pending}</span>
            </div>
            <p className="text-xs text-gray-600 font-medium">ממתינות</p>
          </div>
        )}
        
        <div className="text-center">
          <div className="flex items-center justify-center gap-2 mb-1">
            <TrendingUp className="w-4 h-4 text-green-500" />
            <span className="text-2xl font-bold text-green-600">
              {total > 0 ? Math.round((total - pending) / total * 100) : 0}%
            </span>
          </div>
          <p className="text-xs text-gray-600 font-medium">קצב התקדמות</p>
        </div>
      </div>
    </CardContent>
  </Card>
);

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions: initialSuggestions,
  isHistory = false,
  viewMode: initialViewMode,
  isLoading = false,
  userId,
  className,
  onStatusChange,
  onRefresh,
  // --- START OF CHANGE ---
  isUserInActiveProcess = false,
  // --- END OF CHANGE ---
}) => {
  // State
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<ExtendedMatchSuggestion | null>(null);
  const [showAskDialog, setShowAskDialog] = useState(false);
  const [showStatusDialog, setShowStatusDialog] = useState(false);
  const [actionType, setActionType] = useState<"approve" | "decline" | null>(
    null
  );
  const [searchQuery, setSearchQuery] = useState("");
  const [sortOption, setSortOption] = useState<SortOption>("newest");
  const [filterOption, setFilterOption] = useState<FilterOption>("all");
  const [viewMode, setViewMode] = useState<"grid" | "list">(initialViewMode);
  const [filteredSuggestions, setFilteredSuggestions] =
    useState<ExtendedMatchSuggestion[]>(initialSuggestions);

  // Calculate stats
  const pendingCount = initialSuggestions.filter(
    (s) =>
      s.status === "PENDING_FIRST_PARTY" || s.status === "PENDING_SECOND_PARTY"
  ).length;

  // Filter and sort suggestions
  useEffect(() => {
    let result = [...initialSuggestions];

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter((suggestion) => {
        const targetParty =
          suggestion.firstPartyId === userId
            ? suggestion.secondParty
            : suggestion.firstParty;
        return (
          targetParty.firstName.toLowerCase().includes(query) ||
          targetParty.lastName.toLowerCase().includes(query) ||
          targetParty.profile?.city?.toLowerCase().includes(query) ||
          targetParty.profile?.occupation?.toLowerCase().includes(query) ||
          targetParty.profile?.religiousLevel?.toLowerCase().includes(query)
        );
      });
    }

    // Apply status filter
    if (filterOption !== "all") {
      switch (filterOption) {
        case "pending":
          result = result.filter(
            (s) =>
              s.status === "PENDING_FIRST_PARTY" ||
              s.status === "PENDING_SECOND_PARTY"
          );
          break;
        case "accepted":
          result = result.filter(
            (s) =>
              s.status === "FIRST_PARTY_APPROVED" ||
              s.status === "SECOND_PARTY_APPROVED"
          );
          break;
        case "declined":
          result = result.filter(
            (s) =>
              s.status === "FIRST_PARTY_DECLINED" ||
              s.status === "SECOND_PARTY_DECLINED"
          );
          break;
        case "contact_shared":
          result = result.filter((s) => s.status === "CONTACT_DETAILS_SHARED");
          break;
      }
    }

    // Apply sorting
    switch (sortOption) {
      case "newest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) =>
            (priorityOrder[a.priority as keyof typeof priorityOrder] || 4) -
            (priorityOrder[b.priority as keyof typeof priorityOrder] || 4)
        );
        break;
    }

    setFilteredSuggestions(result);
  }, [initialSuggestions, searchQuery, sortOption, filterOption, userId]);

  // Handlers
  const handleOpenDetails = (suggestion: ExtendedMatchSuggestion) => {
    console.log("[SuggestionsList] handleOpenDetails triggered. Setting selected suggestion.");
    console.log("[SuggestionsList] Suggestion data being passed to modal:", JSON.stringify(suggestion, null, 2));
    setSelectedSuggestion(suggestion);
  };

  const handleInquiry = (suggestion: ExtendedMatchSuggestion) => {
    setSelectedSuggestion(suggestion);
    setShowAskDialog(true);
  };

  const handleStatusAction = (
    suggestion: ExtendedMatchSuggestion,
    action: "approve" | "decline"
  ) => {
    setSelectedSuggestion(suggestion);
    setActionType(action);
    setShowStatusDialog(true);
  };

  const handleActionConfirm = async () => {
    if (!selectedSuggestion || !actionType || !onStatusChange) return;

    try {
      const isFirstParty = selectedSuggestion.firstPartyId === userId;

      let newStatus = "";
      if (actionType === "approve") {
        newStatus = isFirstParty
          ? "FIRST_PARTY_APPROVED"
          : "SECOND_PARTY_APPROVED";
      } else {
        newStatus = isFirstParty
          ? "FIRST_PARTY_DECLINED"
          : "SECOND_PARTY_DECLINED";
      }

      await onStatusChange(selectedSuggestion.id, newStatus);

      toast.success(
        actionType === "approve" ? "ההצעה אושרה בהצלחה" : "ההצעה נדחתה בהצלחה",
        {
          description: actionType === "approve" 
            ? "השדכן יקבל הודעה ויתקדם עם התהליך"
            : "תודה על המשוב - זה עוזר לנו להציע התאמות טובות יותר"
        }
      );

      if (onRefresh) {
        onRefresh();
      }
    } catch (error) {
      console.error("Error updating suggestion status:", error);
      toast.error("אירעה שגיאה בעדכון הסטטוס");
    } finally {
      setShowStatusDialog(false);
      setSelectedSuggestion(null);
      setActionType(null);
    }
  };

  const handleSendQuestion = async (questionText: string) => {
    if (!selectedSuggestion) return;

    try {
      const response = await fetch(
        `/api/suggestions/${selectedSuggestion.id}/inquiries`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ question: questionText }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to send inquiry");
      }

      toast.success("השאלה נשלחה בהצלחה לשדכן", {
        description: "השדכן יחזור אליך עם תשובה בהקדם"
      });
      setShowAskDialog(false);
    } catch (error) {
      console.error("Error sending question:", error);
      toast.error("אירעה שגיאה בשליחת השאלה");
    }
  };

  const clearFilters = () => {
    setSearchQuery("");
    setFilterOption("all");
  };

  // Render loading state
  if (isLoading) {
    return (
      <div className={cn("space-y-6", className)}>
        {/* Loading stats */}
        <Card className="border-0 shadow-lg">
          <CardContent className="p-4">
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              {Array.from({ length: 4 }).map((_, i) => (
                <div key={i} className="text-center space-y-2">
                  <Skeleton className="h-6 w-12 mx-auto" />
                  <Skeleton className="h-3 w-16 mx-auto" />
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
        
        {/* Loading filters */}
        <div className="flex flex-col gap-4">
          <div className="flex gap-2">
            <Skeleton className="h-10 flex-1" />
            <Skeleton className="h-10 w-20" />
            <Skeleton className="h-10 w-32" />
          </div>
        </div>
        
        {/* Loading cards */}
        <div
          className={cn(
            viewMode === "grid"
              ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
              : "space-y-4"
          )}
        >
          {Array.from({ length: 6 }).map((_, i) => (
            <Skeleton key={i} className="h-80 w-full rounded-2xl" />
          ))}
        </div>
      </div>
    );
  }

  return (
    <>
      <div className={cn("space-y-6", className)}>
        {/* Stats Bar */}
        <StatsBar
          total={initialSuggestions.length}
          filtered={filteredSuggestions.length}
          pending={pendingCount}
          isHistory={isHistory}
        />

        {/* Filters and search bar */}
        <Card className="border-0 shadow-lg bg-white/80 backdrop-blur-sm">
          <CardContent className="p-6">
            <div className="flex flex-col gap-4">
              <div className="flex items-center gap-3">
                <div className="relative flex-1">
                  <Search className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
                  <Input
                    type="text"
                    placeholder="חיפוש לפי שם, עיר, או מקצוע..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="pr-12 text-right border-gray-200 focus:border-purple-300 focus:ring-purple-200 rounded-xl h-12"
                  />
                </div>

                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button 
                      variant="outline" 
                      size="icon"
                      className="h-12 w-12 border-gray-200 hover:border-purple-300 hover:bg-purple-50 rounded-xl transition-colors"
                    >
                      <Filter className="h-5 w-5" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end" className="w-56">
                    <DropdownMenuLabel className="text-right">סינון הצעות</DropdownMenuLabel>
                    <DropdownMenuGroup>
                      <DropdownMenuItem onClick={() => setFilterOption("all")}>
                        <Check
                          className={cn(
                            "mr-2 h-4 w-4",
                            filterOption === "all" ? "opacity-100" : "opacity-0"
                          )}
                        />
                        הכל
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => setFilterOption("pending")}>
                        <Check
                          className={cn(
                            "mr-2 h-4 w-4",
                            filterOption === "pending" ? "opacity-100" : "opacity-0"
                          )}
                        />
                        ממתינות לתשובה
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => setFilterOption("accepted")}>
                        <Check
                          className={cn(
                            "mr-2 h-4 w-4",
                            filterOption === "accepted" ? "opacity-100" : "opacity-0"
                          )}
                        />
                        מאושרות
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => setFilterOption("declined")}>
                        <Check
                          className={cn(
                            "mr-2 h-4 w-4",
                            filterOption === "declined" ? "opacity-100" : "opacity-0"
                          )}
                        />
                        שנדחו
                      </DropdownMenuItem>
                      <DropdownMenuItem
                        onClick={() => setFilterOption("contact_shared")}
                      >
                        <Check
                          className={cn(
                            "mr-2 h-4 w-4",
                            filterOption === "contact_shared"
                              ? "opacity-100"
                              : "opacity-0"
                          )}
                        />
                        פרטי קשר שותפו
                      </DropdownMenuItem>
                    </DropdownMenuGroup>
                  </DropdownMenuContent>
                </DropdownMenu>

                <Select
                  value={sortOption}
                  onValueChange={(value) => setSortOption(value as SortOption)}
                >
                  <SelectTrigger className="w-48 h-12 border-gray-200 focus:border-purple-300 rounded-xl">
                    <SelectValue placeholder="מיון לפי" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="newest">
                      <div className="flex items-center gap-2">
                        <SortDesc className="h-4 w-4" />
                        החדש ביותר
                      </div>
                    </SelectItem>
                    <SelectItem value="oldest">
                      <div className="flex items-center gap-2">
                        <SortAsc className="h-4 w-4" />
                        הישן ביותר
                      </div>
                    </SelectItem>
                    <SelectItem value="deadline">
                      <div className="flex items-center gap-2">
                        <Calendar className="h-4 w-4" />
                        תאריך יעד
                      </div>
                    </SelectItem>
                    <SelectItem value="priority">
                      <div className="flex items-center gap-2">
                        <Filter className="h-4 w-4" />
                        עדיפות
                      </div>
                    </SelectItem>
                  </SelectContent>
                </Select>

                <div className="flex border border-gray-200 rounded-xl overflow-hidden">
                  <Button
                    variant={viewMode === "grid" ? "default" : "ghost"}
                    size="icon"
                    className={cn(
                      "h-12 w-12 rounded-none",
                      viewMode === "grid" 
                        ? "bg-purple-500 hover:bg-purple-600" 
                        : "hover:bg-purple-50"
                    )}
                    onClick={() => setViewMode("grid")}
                  >
                    <Grid3X3 className="h-4 w-4" />
                  </Button>
                  <Button
                    variant={viewMode === "list" ? "default" : "ghost"}
                    size="icon"
                    className={cn(
                      "h-12 w-12 rounded-none",
                      viewMode === "list" 
                        ? "bg-purple-500 hover:bg-purple-600" 
                        : "hover:bg-purple-50"
                    )}
                    onClick={() => setViewMode("list")}
                  >
                    <ListIcon className="h-4 w-4" />
                  </Button>
                </div>
              </div>

              {/* Active filters display */}
              {(searchQuery || filterOption !== "all") && (
                <div className="flex items-center gap-2 pt-2 border-t border-gray-100">
                  <span className="text-sm text-gray-500 font-medium">סינון פעיל:</span>
                  {searchQuery && (
                    <Badge variant="outline" className="flex items-center gap-1 bg-purple-50 text-purple-700 border-purple-200">
                      חיפוש: {searchQuery}
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-4 w-4 p-0 hover:bg-transparent"
                        onClick={() => setSearchQuery("")}
                      >
                        <XCircle className="h-3 w-3" />
                      </Button>
                    </Badge>
                  )}
                  {filterOption !== "all" && (
                    <Badge variant="outline" className="flex items-center gap-1 bg-pink-50 text-pink-700 border-pink-200">
                      {filterOption === "pending" && "ממתינות לתשובה"}
                      {filterOption === "accepted" && "מאושרות"}
                      {filterOption === "declined" && "שנדחו"}
                      {filterOption === "contact_shared" && "פרטי קשר שותפו"}
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-4 w-4 p-0 hover:bg-transparent"
                        onClick={() => setFilterOption("all")}
                      >
                        <XCircle className="h-3 w-3" />
                      </Button>
                    </Badge>
                  )}
                  <Button
                    variant="ghost"
                    size="sm"
                    className="text-xs text-gray-500 hover:text-gray-700"
                    onClick={clearFilters}
                  >
                    נקה הכל
                  </Button>
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Results count */}
        <div className="flex justify-between items-center text-sm text-gray-600">
          <span>
            מציג {filteredSuggestions.length}{" "}
            {filteredSuggestions.length === 1 ? "הצעה" : "הצעות"} מתוך{" "}
            {initialSuggestions.length}
          </span>
          {filteredSuggestions.length > 0 && (
            <div className="flex items-center gap-2">
              <Sparkles className="w-4 h-4 text-purple-500" />
              <span className="font-medium">התאמות איכותיות עבורך</span>
            </div>
          )}
        </div>

        {/* Suggestions grid/list or empty state */}
        {filteredSuggestions.length === 0 ? (
          <EmptyState
            isFiltered={searchQuery !== "" || filterOption !== "all"}
            isHistory={isHistory}
            onClearFilters={clearFilters}
          />
        ) : (
          <div
            className={cn(
              viewMode === "grid"
                ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
                : "space-y-6",
              "animate-fade-in-up"
            )}
          >
            {filteredSuggestions.map((suggestion, index) => (
              <div 
                key={suggestion.id} 
                className="animate-scale-in"
                style={{ 
                  animationDelay: `${index * 100}ms`,
                  animationFillMode: 'both'
                }}
              >
                <MinimalSuggestionCard
                  suggestion={suggestion}
                  userId={userId}
                  onClick={() => handleOpenDetails(suggestion)}
                  onInquiry={() => handleInquiry(suggestion)}
                  onApprove={() => handleStatusAction(suggestion, "approve")}
                  onDecline={() => handleStatusAction(suggestion, "decline")}
                  isHistory={isHistory}
                  // --- START OF CHANGE ---
                  isApprovalDisabled={isUserInActiveProcess}
                  // --- END OF CHANGE ---
                  className={cn(
                    "card-hover-elegant",
                    viewMode === "list" ? "flex" : ""
                  )}
                />
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Modals */}
      {console.log(`[SuggestionsList] Rendering SuggestionDetailsModal. isOpen: ${!!selectedSuggestion && !showAskDialog && !showStatusDialog}`)}

      <SuggestionDetailsModal
        suggestion={selectedSuggestion}
        userId={userId}
        isOpen={!!selectedSuggestion && !showAskDialog && !showStatusDialog}
        onClose={() => setSelectedSuggestion(null)}
        onStatusChange={onStatusChange}
      />

      <AskMatchmakerDialog
        isOpen={showAskDialog}
        onClose={() => setShowAskDialog(false)}
        onSubmit={handleSendQuestion}
        matchmakerName={selectedSuggestion?.matchmaker.firstName}
        suggestionId={selectedSuggestion?.id}
      />

      <AlertDialog open={showStatusDialog} onOpenChange={setShowStatusDialog}>
        <AlertDialogContent className="border-0 shadow-2xl rounded-2xl">
          <AlertDialogHeader>
            <AlertDialogTitle className="text-xl font-bold text-center">
              {actionType === "approve"
                ? "אישור הצעת השידוך"
                : "דחיית הצעת השידוך"}
            </AlertDialogTitle>
            <AlertDialogDescription className="text-center text-gray-600 leading-relaxed">
              {actionType === "approve"
                ? "האם אתה בטוח שברצונך לאשר את הצעת השידוך? לאחר האישור, השדכן יקבל הודעה ויתקדם עם התהליך."
                : "האם אתה בטוח שברצונך לדחות את הצעת השידוך? המשוב שלך עוזר לנו להציע התאמות טובות יותר בעתיד."}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="gap-3">
            <AlertDialogCancel className="rounded-xl">ביטול</AlertDialogCancel>
            <AlertDialogAction 
              onClick={handleActionConfirm}
              className={cn(
                "rounded-xl font-medium shadow-lg hover:shadow-xl transition-all duration-300",
                actionType === "approve"
                  ? "bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700"
                  : "bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700"
              )}
            >
              {actionType === "approve" ? "אישור ההצעה" : "דחיית ההצעה"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default SuggestionsList;
--- End of Content for SuggestionsList.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\modals
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\modals\SuggestionDetailsModal.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/modals/SuggestionDetailsModal.tsx
"use client";

import React, { useState, useEffect, useRef, useCallback } from "react";
import Image from "next/image";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { 
  CheckCircle, 
  XCircle, 
  MessageCircle, 
  X, 
  Loader2,
  Sparkles,
  User,
  Info,
  Heart,
  Quote,
  MapPin,
  Briefcase,
  GraduationCap,
  Scroll as ScrollIcon,
  GitCompareArrows,
  Star,
  Eye,
  Calendar,
  ArrowRight,
  Users,
  Target,
  Lightbulb,
  Gift,
  Phone,
  MessageSquare,
  Crown,
  Zap,
  Telescope,
  ChevronDown,
  BookOpen,
  Home,
  Music,
  Camera,
  Coffee,
  Globe,
  Maximize,
  Minimize,
  AlertTriangle,
  Bot
} from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
    Alert,
    AlertDescription,
    AlertTitle as UiAlertTitle, // Renamed to avoid conflict
} from "@/components/ui/alert";
import { toast } from "sonner";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { getInitials, cn } from "@/lib/utils";
import type { QuestionnaireResponse } from "@/types/next-auth";
import type { AiSuggestionAnalysisResult } from '@/lib/services/aiService';

import { ProfileCard } from "@/app/components/profile";
import SuggestionTimeline from "../timeline/SuggestionTimeline";
import InquiryThreadView from "../inquiries/InquiryThreadView";
import { AskMatchmakerDialog } from "../dialogs/AskMatchmakerDialog";
import { UserAiAnalysisDialog } from '../dialogs/UserAiAnalysisDialog';
import UserAiAnalysisDisplay from "../compatibility/UserAiAnalysisDisplay";
import type { ExtendedMatchSuggestion } from "../types";

// ===============================
// TYPES & INTERFACES
// ===============================

interface SuggestionDetailsModalProps {
  suggestion: ExtendedMatchSuggestion | null;
  userId: string;
  isOpen: boolean;
  onClose: () => void;
  onStatusChange?: (suggestionId: string, newStatus: string) => Promise<void>;
}

// ===============================
// ENHANCED HERO SECTION
// ===============================

const EnhancedHeroSection: React.FC<{
  matchmaker: { firstName: string; lastName: string; };
  targetParty: ExtendedMatchSuggestion['secondParty'];
  personalNote?: string | null;
  matchingReason?: string | null;
  onViewProfile: () => void;
  onStartConversation: () => void;
}> = ({ 
  matchmaker, 
  targetParty, 
  personalNote, 
  matchingReason,
  onViewProfile,
  onStartConversation
}) => {
  const age = targetParty.profile?.birthDate ? 
    new Date().getFullYear() - new Date(targetParty.profile.birthDate).getFullYear() : null;
  const mainImage = targetParty.images?.find(img => img.isMain)?.url;

  // Define the excitement factor type
  interface ExcitementFactor {
    icon: React.ElementType;
    label: string;
    value: string;
    color: string;
  }

  // Generate excitement factors
  const getExcitementFactors = (): ExcitementFactor[] => {
    const factors: ExcitementFactor[] = [];
    
    if (targetParty.profile?.religiousLevel) {
      factors.push({
        icon: ScrollIcon,
        label: "השקפת עולם משותפת",
        value: targetParty.profile.religiousLevel,
        color: "from-purple-500 to-violet-600"
      });
    }
    
    if (targetParty.profile?.city) {
      factors.push({
        icon: MapPin,
        label: "מיקום נוח",
        value: targetParty.profile.city,
        color: "from-emerald-500 to-green-600"
      });
    }
    
    if (targetParty.profile?.education) {
      factors.push({
        icon: GraduationCap,
        label: "רקע השכלתי",
        value: targetParty.profile.education,
        color: "from-blue-500 to-cyan-600"
      });
    }
    
    if (targetParty.profile?.occupation) {
      factors.push({
        icon: Briefcase,
        label: "תחום מקצועי",
        value: targetParty.profile.occupation,
        color: "from-amber-500 to-orange-600"
      });
    }

    return factors;
  };

  const excitementFactors = getExcitementFactors();

  return (
    <div className="relative min-h-[80vh] overflow-hidden bg-gradient-to-br from-slate-50 via-white to-blue-50">
      {/* Animated Background Elements */}
      <div className="absolute inset-0">
        <div className="absolute top-10 right-10 w-72 h-72 bg-gradient-to-br from-purple-200/30 to-pink-200/30 rounded-full blur-3xl animate-pulse"></div>
        <div className="absolute bottom-10 left-10 w-64 h-64 bg-gradient-to-br from-cyan-200/30 to-blue-200/30 rounded-full blur-2xl animate-pulse" style={{ animationDelay: "1s" }}></div>
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-96 h-96 bg-gradient-to-br from-emerald-200/20 to-green-200/20 rounded-full blur-3xl animate-pulse" style={{ animationDelay: "2s" }}></div>
      </div>

      <div className="relative z-10 p-8 md:p-12">
        {/* Matchmaker Introduction with Crown */}
        <div className="text-center mb-8">
          <div className="inline-flex items-center gap-4 mb-6 p-6 bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl border border-purple-100">
            <div className="relative">
              <Avatar className="w-16 h-16 border-4 border-white shadow-xl">
                <AvatarFallback className="bg-gradient-to-br from-purple-600 to-pink-600 text-white text-xl font-bold">
                  {getInitials(`${matchmaker.firstName} ${matchmaker.lastName}`)}
                </AvatarFallback>
              </Avatar>
              <div className="absolute -top-2 -right-2 w-8 h-8 bg-gradient-to-r from-yellow-400 to-amber-500 rounded-full flex items-center justify-center shadow-lg">
                <Crown className="w-4 h-4 text-white" />
              </div>
            </div>
            <div className="text-right">
              <div className="flex items-center gap-2 mb-1">
                <Sparkles className="w-4 h-4 text-purple-500" />
                <p className="text-sm font-bold text-purple-600">הצעה מיוחדת מהשדכן המוביל</p>
              </div>
              <p className="text-xl font-bold text-gray-800">{matchmaker.firstName} {matchmaker.lastName}</p>
              <p className="text-sm text-gray-600">מומחה בהתאמות מוצלחות</p>
            </div>
          </div>
        </div>

        {/* Main Content Grid */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-12 mb-12">
          {/* Enhanced Profile Image Section */}
          <div className="relative">
            <div className="relative group">
              <div className="absolute inset-0 bg-gradient-to-r from-purple-400 to-pink-400 rounded-3xl blur opacity-75 group-hover:opacity-100 transition-opacity animate-pulse"></div>
              <div className="relative h-96 lg:h-[500px] rounded-3xl overflow-hidden shadow-2xl">
                {mainImage ? (
                  <Image 
                    src={mainImage} 
                    alt={`תמונה של ${targetParty.firstName}`} 
                    fill 
                    className="object-cover transition-transform duration-700 group-hover:scale-105"
                    sizes="(max-width: 1024px) 100vw, 50vw"
                  />
                ) : (
                  <div className="w-full h-full bg-gradient-to-br from-purple-100 via-pink-100 to-blue-100 flex items-center justify-center">
                    <div className="text-center">
                      <User className="w-24 h-24 text-purple-400 mx-auto mb-4" />
                      <p className="text-purple-600 font-semibold">תמונה בדרך אליך</p>
                      <p className="text-sm text-purple-500">כל הפרטים בפרופיל המלא</p>
                    </div>
                  </div>
                )}
                
                <div className="absolute inset-0 bg-gradient-to-t from-black/70 via-black/20 to-transparent" />
                
                {/* Profile Overlay */}
                <div className="absolute bottom-6 right-6 left-6">
                  <div className="bg-white/95 backdrop-blur-md rounded-2xl p-6 shadow-2xl">
                    <div className="flex items-center justify-between mb-4">
                      <div>
                        <h3 className="text-3xl font-bold text-gray-900 mb-1">
                          {targetParty.firstName}
                        </h3>
                        {age && (
                          <div className="flex items-center gap-2">
                            <Badge className="bg-gradient-to-r from-purple-500 to-pink-500 text-white border-0 shadow-lg">
                              {age} שנים
                            </Badge>
                            <Badge className="bg-gradient-to-r from-cyan-500 to-blue-500 text-white border-0 shadow-lg">
                              <Heart className="w-3 h-3 ml-1" />
                              זמין להכרות
                            </Badge>
                          </div>
                        )}
                      </div>
                      <Button 
                        onClick={onViewProfile}
                        className="bg-gradient-to-r from-emerald-500 to-green-500 hover:from-emerald-600 hover:to-green-600 text-white shadow-xl rounded-full px-6 py-3 font-bold"
                      >
                        <Telescope className="w-4 h-4 ml-2" />
                        גלה עוד
                      </Button>
                    </div>
                    
                    {/* Key Info Grid */}
                    <div className="grid grid-cols-2 gap-3">
                      {targetParty.profile?.city && (
                        <div className="flex items-center gap-2 p-2 bg-purple-50 rounded-lg">
                          <MapPin className="w-4 h-4 text-purple-500" />
                          <span className="text-sm font-medium text-gray-700">{targetParty.profile.city}</span>
                        </div>
                      )}
                      {targetParty.profile?.occupation && (
                        <div className="flex items-center gap-2 p-2 bg-blue-50 rounded-lg">
                          <Briefcase className="w-4 h-4 text-blue-500" />
                          <span className="text-sm font-medium text-gray-700 truncate">{targetParty.profile.occupation}</span>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Enhanced Content Section */}
          <div className="space-y-8">
            {/* Excitement Header */}
            <Card className="border-0 shadow-2xl bg-gradient-to-br from-purple-50 via-pink-50 to-white overflow-hidden">
              <CardContent className="p-8">
                <div className="text-center mb-6">
                  <div className="inline-flex items-center gap-2 mb-4">
                    <div className="w-3 h-3 bg-purple-500 rounded-full animate-pulse"></div>
                    <div className="w-2 h-2 bg-pink-500 rounded-full animate-pulse" style={{ animationDelay: "0.5s" }}></div>
                    <div className="w-4 h-4 bg-blue-500 rounded-full animate-pulse" style={{ animationDelay: "1s" }}></div>
                  </div>
                  <h2 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-purple-600 via-pink-600 to-blue-600 bg-clip-text text-transparent mb-4">
                    זו יכולה להיות הנשמה התאומה שלך
                  </h2>
                  <p className="text-lg text-gray-600 leading-relaxed">
                    השדכן שלנו זיהה כאן משהו מיוחד - שילוב נדיר של התאמה עמוקה ופוטנציאל אמיתי
                  </p>
                </div>

                {/* Excitement Factors */}
                {excitementFactors.length > 0 && (
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    {excitementFactors.map((factor, index) => (
                      <div 
                        key={index}
                        className="relative p-4 bg-white/70 rounded-xl shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1"
                      >
                        <div className="flex items-center gap-3">
                          <div className={cn("w-10 h-10 rounded-full bg-gradient-to-r text-white flex items-center justify-center shadow-md", factor.color)}>
                            <factor.icon className="w-5 h-5" />
                          </div>
                          <div className="flex-1">
                            <p className="font-semibold text-gray-800 text-sm">{factor.label}</p>
                            <p className="text-gray-600 text-xs truncate">{factor.value}</p>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}

                {/* CTA Buttons */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <Button 
                    onClick={onViewProfile}
                    className="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white shadow-xl rounded-xl h-12 font-bold text-base"
                  >
                    <User className="w-5 h-5 ml-2" />
                    רוצה לראות הכל
                  </Button>
                  <Button 
                    onClick={onStartConversation}
                    variant="outline"
                    className="border-2 border-purple-300 text-purple-600 hover:bg-purple-50 shadow-lg rounded-xl h-12 font-bold text-base"
                  >
                    <MessageSquare className="w-5 h-5 ml-2" />
                    יש לי שאלות
                  </Button>
                </div>
              </CardContent>
            </Card>

            {/* Matchmaker's Special Insight */}
            {(personalNote || matchingReason) && (
              <Card className="border-0 shadow-xl bg-gradient-to-br from-cyan-50 to-blue-50">
                <CardContent className="p-6">
                  <div className="flex items-start gap-4">
                    <div className="p-3 rounded-full bg-gradient-to-r from-cyan-500 to-blue-500 text-white shadow-lg flex-shrink-0">
                      <Lightbulb className="w-6 h-6" />
                    </div>
                    <div className="flex-1">
                      <h3 className="font-bold text-cyan-800 text-lg mb-3 flex items-center gap-2">
                        <Quote className="w-5 h-5" />
                        התובנה המיוחדת של השדכן
                      </h3>
                      
                      {personalNote && (
                        <div className="mb-4 p-4 bg-white/70 rounded-xl">
                          <h4 className="font-semibold text-cyan-700 mb-2">מיועד אישית עבורך:</h4>
                          <p className="text-cyan-900 leading-relaxed italic">“{personalNote}”</p>
                        </div>
                      )}
                      
                      {matchingReason && (
                        <div className="p-4 bg-white/70 rounded-xl">
                          <h4 className="font-semibold text-blue-700 mb-2">הסיבה להתאמה:</h4>
                          <p className="text-blue-900 leading-relaxed">“{matchingReason}”</p>
                        </div>
                      )}
                    </div>
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Success Stories Teaser */}
            <Card className="border-0 shadow-xl bg-gradient-to-br from-green-50 to-emerald-50">
              <CardContent className="p-6 text-center">
                <div className="flex justify-center mb-4">
                  <div className="relative">
                    <Star className="w-12 h-12 text-yellow-500 fill-current" />
                    <Sparkles className="w-6 h-6 text-emerald-500 absolute -top-1 -right-1" />
                  </div>
                </div>
                <h3 className="text-xl font-bold text-emerald-800 mb-2">
                  הצלחות מדברות בעד עצמן
                </h3>
                <p className="text-emerald-700 mb-4">
                  השדכן שלנו כבר הוביל זוגות מאושרים השנה
                </p>
                <div className="flex justify-center">
                  <UserAiAnalysisDialog suggestedUserId={targetParty.id} />
                </div>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Bottom Action Section */}
        <Card className="border-0 shadow-2xl bg-gradient-to-r from-gray-900 via-purple-900 to-blue-900 text-white overflow-hidden">
          <CardContent className="p-8">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6 items-center">
              <div className="text-center md:text-right">
                <div className="flex items-center justify-center md:justify-end gap-2 mb-2">
                  <Zap className="w-6 h-6 text-yellow-400" />
                  <h3 className="text-xl font-bold">רגע האמת</h3>
                </div>
                <p className="text-gray-300">
                  כל סיפור אהבה מתחיל בהחלטה אחת
                </p>
              </div>
              
              <div className="text-center">
                <div className="w-20 h-20 rounded-full bg-gradient-to-r from-pink-500 to-purple-500 flex items-center justify-center mx-auto mb-4 animate-pulse">
                  <Heart className="w-10 h-10 text-white" />
                </div>
                <p className="text-sm text-gray-300">
                  {targetParty.firstName} מחכה להכיר אותך
                </p>
              </div>
              
              <div className="text-center md:text-left">
                <div className="flex items-center justify-center md:justify-start gap-2 mb-2">
                  <Target className="w-6 h-6 text-green-400" />
                  <h3 className="text-xl font-bold">הזמן הוא עכשיו</h3>
                </div>
                <p className="text-gray-300">
                  ההזדמנויות הטובות לא מחכות
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

// ===============================
// QUICK ACTIONS ENHANCED
// ===============================

const EnhancedQuickActions: React.FC<{
  canAct: boolean;
  isSubmitting: boolean;
  onApprove: () => void;
  onDecline: () => void;
  onAskQuestion: () => void;
}> = ({ 
  canAct, 
  isSubmitting, 
  onApprove, 
  onDecline, 
  onAskQuestion 
}) => (
  <div className="flex-shrink-0 bg-gradient-to-r from-white via-purple-50/30 to-pink-50/30 backdrop-blur-sm border-t border-purple-100 p-6">
    <div className="flex gap-4 max-w-4xl mx-auto">
      {/* Ask Question Button */}
      <Button 
        variant="outline" 
        onClick={onAskQuestion} 
        disabled={isSubmitting}
        className="flex-1 border-2 border-purple-200 text-purple-600 hover:bg-purple-50 hover:border-purple-300 transition-all duration-300 rounded-xl h-14 font-semibold text-base shadow-lg"
      >
        <MessageCircle className="w-5 h-5 ml-2" />
        שאלות לשדכן
      </Button>
      
      {canAct && (
        <>
          {/* Decline Button */}
          <Button 
            variant="outline" 
            className="flex-1 text-gray-600 border-2 border-gray-200 hover:bg-gray-50 hover:text-gray-700 hover:border-gray-300 transition-all duration-300 rounded-xl h-14 font-semibold text-base shadow-lg" 
            disabled={isSubmitting} 
            onClick={onDecline}
          >
            {isSubmitting ? (
              <Loader2 className="w-5 h-5 ml-2 animate-spin" />
            ) : (
              <XCircle className="w-5 h-5 ml-2" />
            )}
            לא מתאים כרגע
          </Button>
          
          {/* Approve Button */}
          <Button 
            className="flex-1 bg-gradient-to-r from-emerald-500 via-green-500 to-emerald-600 hover:from-emerald-600 hover:via-green-600 hover:to-emerald-700 text-white shadow-xl hover:shadow-2xl transition-all duration-300 rounded-xl h-14 font-bold text-base transform hover:scale-105" 
            disabled={isSubmitting} 
            onClick={onApprove}
          >
            {isSubmitting ? (
              <Loader2 className="w-5 h-5 ml-2 animate-spin" />
            ) : (
              <div className="flex items-center">
                <Heart className="w-5 h-5 ml-2 animate-pulse" />
                <span>בואו נכיר! 💫</span>
              </div>
            )}
          </Button>
        </>
      )}
    </div>
    
    {/* Motivational Footer */}
    <div className="text-center mt-4">
      <p className="text-sm text-gray-600 font-medium">
        ✨ כל סיפור אהבה מתחיל במילה אחת: כן ✨
      </p>
    </div>
  </div>
);

// ===============================
// MAIN COMPONENT
// ===============================

const SuggestionDetailsModal: React.FC<SuggestionDetailsModalProps> = ({
  suggestion,
  userId,
  isOpen,
  onClose,
  onStatusChange,
}) => {
  // ===============================
  // STATE MANAGEMENT
  // ===============================
  
  const [activeTab, setActiveTab] = useState("presentation");
  const [showAskDialog, setShowAskDialog] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [actionToConfirm, setActionToConfirm] = useState<'approve' | 'decline' | null>(null);
  const [isFullScreen, setIsFullScreen] = useState(false);
  const dialogContentRef = useRef<HTMLDivElement>(null);

  const [questionnaire, setQuestionnaire] = useState<QuestionnaireResponse | null>(null);
  const [isQuestionnaireLoading, setIsQuestionnaireLoading] = useState(false);
  
  const [aiAnalysis, setAiAnalysis] = useState<AiSuggestionAnalysisResult | null>(null);
  const [isAnalysisLoading, setIsAnalysisLoading] = useState(false);
  const [analysisError, setAnalysisError] = useState<string | null>(null);

  // ===============================
  // COMPUTED VALUES & HOOKS
  // ===============================

  const isFirstParty = suggestion?.firstPartyId === userId;
  const targetParty = suggestion ? (isFirstParty ? suggestion.secondParty : suggestion.firstParty) : null;
  const targetPartyId = targetParty?.id;

  const fetchAiAnalysis = useCallback(async () => {
    if (!suggestion || !targetPartyId) return;
    
    setIsAnalysisLoading(true);
    setAnalysisError(null);
    try {
        const response = await fetch('/api/ai/analyze-suggestion', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ suggestedUserId: targetPartyId }),
        });
        const result = await response.json();
        if (!response.ok || !result.success) {
            throw new Error(result.message || 'שגיאה בקבלת ניתוח ההצעה.');
        }
        setAiAnalysis(result.data);
    } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'אירעה שגיאה לא צפויה.';
        setAnalysisError(errorMessage);
        toast.error('שגיאה בטעינת ניתוח ההתאמה.');
    } finally {
        setIsAnalysisLoading(false);
    }
  }, [suggestion, targetPartyId]);

  useEffect(() => {
    if (isOpen && activeTab === 'compatibility' && !aiAnalysis && !analysisError) {
      fetchAiAnalysis();
    }
  }, [isOpen, activeTab, aiAnalysis, analysisError, fetchAiAnalysis]);

  useEffect(() => {
    if (!isOpen) {
      setAiAnalysis(null);
      setAnalysisError(null);
      setIsAnalysisLoading(false);
    } else {
      setActiveTab("presentation");
      setQuestionnaire(null);
      setIsFullScreen(!!document.fullscreenElement);

      if (targetPartyId) {
        const fetchQuestionnaire = async () => {
          setIsQuestionnaireLoading(true);
          try {
            const response = await fetch(`/api/profile/questionnaire?userId=${targetPartyId}`);
            const data = await response.json();
            if (response.ok && data.success) {
              setQuestionnaire(data.questionnaireResponse);
            }
          } catch (error) {
            console.error("Error fetching questionnaire:", error);
          } finally {
            setIsQuestionnaireLoading(false);
          }
        };
        fetchQuestionnaire();
      }
    }

    const handleFullScreenChange = () => setIsFullScreen(!!document.fullscreenElement);
    document.addEventListener('fullscreenchange', handleFullScreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullScreenChange);
  }, [isOpen, targetPartyId]);

  // ===============================
  // EARLY RETURN & RENDER LOGIC
  // ===============================
  
  if (!suggestion || !targetParty) return null;

  const canActOnSuggestion = 
    (isFirstParty && suggestion.status === "PENDING_FIRST_PARTY") ||
    (!isFirstParty && suggestion.status === "PENDING_SECOND_PARTY");

  // ===============================
  // EVENT HANDLERS
  // ===============================
  const toggleFullScreen = () => {
    if (!dialogContentRef.current) return;

    if (!document.fullscreenElement) {
      dialogContentRef.current.requestFullscreen().catch(err => {
        toast.error("לא ניתן לעבור למסך מלא", {
          description: "יתכן שהדפדפן שלך אינו תומך או חוסם אפשרות זו."
        });
      });
    } else {
      document.exitFullscreen();
    }
  };

  const triggerConfirmDialog = (action: 'approve' | 'decline') => {
    setActionToConfirm(action);
    setShowConfirmDialog(true);
  };
  
  const executeConfirmedAction = async () => {
    if (!onStatusChange || !suggestion || !actionToConfirm) return;

    const newStatus = actionToConfirm === 'approve'
      ? (isFirstParty ? "FIRST_PARTY_APPROVED" : "SECOND_PARTY_APPROVED")
      : (isFirstParty ? "FIRST_PARTY_DECLINED" : "SECOND_PARTY_DECLINED");

    setIsSubmitting(true);
    setShowConfirmDialog(false);
    try {
      await onStatusChange(suggestion.id, newStatus);
      toast.success("הסטטוס עודכן בהצלחה! 🎉", {
        description: newStatus.includes("APPROVED") 
          ? "השדכן/ית יקבל הודעה ויתקדם עם התהליך - זה מרגש!"
          : "תודה על המשוב הכנה - זה עוזר לנו להכיר אותך טוב יותר"
      });
      onClose();
    } catch (error) {
      console.error("Failed to update status:", error);
      toast.error("אירעה שגיאה בעדכון הסטטוס.");
    } finally {
      setIsSubmitting(false);
      setActionToConfirm(null);
    }
  };
  
  const handleSendQuestion = async (question: string) => {
    setIsSubmitting(true);
    try {
      const response = await fetch(`/api/suggestions/${suggestion.id}/inquiries`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ question }),
      });
      
      if (!response.ok) throw new Error("Failed to send inquiry.");
      
      toast.success("שאלתך נשלחה בהצלחה! 📩", {
        description: "השדכן/ית יחזור אליך בהקדם עם תשובה מקצועית"
      });
      setShowAskDialog(false);
    } catch (error) {
      console.error("Error sending question:", error);
      toast.error("אירעה שגיאה בשליחת השאלה.");
    } finally {
      setIsSubmitting(false);
    }
  };

  // ===============================
  // RENDER
  // ===============================

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent 
          ref={dialogContentRef}
          className="max-w-7xl w-[95vw] h-[95vh] flex flex-col p-0 shadow-2xl rounded-3xl border-0 bg-white overflow-hidden" 
          dir="rtl"
        >
          {/* Enhanced Header */}
          <DialogHeader className="px-6 py-4 border-b border-purple-100 flex-shrink-0 flex flex-row items-center justify-between bg-gradient-to-r from-purple-50/80 via-white to-pink-50/80 backdrop-blur-sm sticky top-0 z-30">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-gradient-to-r from-purple-500 to-pink-500 flex items-center justify-center shadow-lg">
                <Heart className="w-5 h-5 text-white" />
              </div>
              <div>
                <DialogTitle className="text-xl font-bold text-gray-800">
                  הצעה מיוחדת
                </DialogTitle>
                <p className="text-sm text-gray-600">אהבה אמיתית מתחילה כאן</p>
              </div>
            </div>
            <div className="flex items-center gap-2">
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={toggleFullScreen}
                        className="rounded-full h-10 w-10 text-gray-400 hover:text-gray-600 hover:bg-gray-100 transition-colors"
                      >
                        {isFullScreen ? <Minimize className="w-5 h-5" /> : <Maximize className="w-5 h-5" />}
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>{isFullScreen ? 'צא ממסך מלא' : 'מסך מלא'}</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={onClose}
                  className="rounded-full h-10 w-10 text-gray-400 hover:text-gray-600 hover:bg-gray-100 transition-colors">
                  <X className="w-5 h-5" />
                </Button>
            </div>
          </DialogHeader>
          
          <ScrollArea className="flex-grow min-h-0">
            <Tabs value={activeTab} onValueChange={setActiveTab}>
              {/* Enhanced Tabs Navigation */}
              <div className="border-b border-purple-100 px-6 pt-2 bg-gradient-to-r from-purple-50/50 to-pink-50/50 backdrop-blur-sm sticky top-0 z-20">
                <TabsList className="grid w-full grid-cols-4 bg-white/80 backdrop-blur-sm rounded-2xl p-1 h-16 shadow-lg border border-purple-100">
                  <TabsTrigger 
                    value="presentation" 
                    className="flex items-center gap-2 rounded-xl transition-all data-[state=active]:bg-gradient-to-r data-[state=active]:from-purple-500 data-[state=active]:to-pink-500 data-[state=active]:text-white data-[state=active]:shadow-lg font-semibold"
                  >
                    <Sparkles className="w-5 h-5" />
                    <span>ההצעה המיוחדת</span>
                  </TabsTrigger>
                  <TabsTrigger 
                    value="profile" 
                    className="flex items-center gap-2 rounded-xl transition-all data-[state=active]:bg-gradient-to-r data-[state=active]:from-emerald-500 data-[state=active]:to-green-500 data-[state=active]:text-white data-[state=active]:shadow-lg font-semibold"
                  >
                    <User className="w-5 h-5" />
                    <span>פרופיל מלא</span>
                  </TabsTrigger>
                  <TabsTrigger 
                    value="compatibility" 
                    className="flex items-center gap-2 rounded-xl transition-all data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500 data-[state=active]:to-cyan-500 data-[state=active]:text-white data-[state=active]:shadow-lg font-semibold"
                  >
                    <GitCompareArrows className="w-5 h-5" />
                    <span>ניתוח התאמה</span>
                  </TabsTrigger>
                  <TabsTrigger 
                    value="details" 
                    className="flex items-center gap-2 rounded-xl transition-all data-[state=active]:bg-gradient-to-r data-[state=active]:from-gray-500 data-[state=active]:to-slate-500 data-[state=active]:text-white data-[state=active]:shadow-lg font-semibold"
                  >
                    <Info className="w-5 h-5" />
                    <span>פרטים נוספים</span>
                  </TabsTrigger>
                </TabsList>
              </div>
              
              {/* Tab Contents */}
              
              {/* Enhanced Presentation Tab */}
              <TabsContent value="presentation" className="mt-0">
                <EnhancedHeroSection 
                  matchmaker={suggestion.matchmaker}
                  targetParty={targetParty}
                  personalNote={isFirstParty ? suggestion.firstPartyNotes : suggestion.secondPartyNotes}
                  matchingReason={suggestion.matchingReason}
                  onViewProfile={() => setActiveTab('profile')}
                  onStartConversation={() => setShowAskDialog(true)}
                />
              </TabsContent>
              
              {/* Profile Tab */}
              <TabsContent value="profile" className="mt-0 p-4 md:p-6">
                {isQuestionnaireLoading ? (
                  <div className="flex justify-center items-center h-64">
                    <div className="text-center">
                      <Loader2 className="w-8 h-8 animate-spin text-purple-600 mx-auto mb-4" />
                      <p className="text-gray-600 font-medium">טוען פרופיל מלא...</p>
                      <p className="text-sm text-gray-500">הכנו משהו מיוחד בשבילך</p>
                    </div>
                  </div>
                ) : (
                  <ProfileCard
                    profile={targetParty.profile}
                    images={targetParty.images}
                    questionnaire={questionnaire}
                    viewMode="candidate"
                  />
                )}
              </TabsContent>

              {/* Compatibility Tab */}
              <TabsContent value="compatibility" className="mt-0 p-2 md:p-4 bg-slate-50 min-h-full">
                {isAnalysisLoading ? (
                  <div className="flex flex-col items-center justify-center h-full min-h-[500px] text-center space-y-6">
                    <div className="relative">
                      <div className="w-20 h-20 rounded-full bg-gradient-to-br from-cyan-200 to-emerald-200 animate-pulse"></div>
                      <Loader2 className="w-12 h-12 text-cyan-600 animate-spin absolute inset-0 m-auto" />
                    </div>
                    <div className="space-y-2">
                      <p className="text-xl font-semibold text-gray-700">ה-AI שלנו בוחן את ההתאמה...</p>
                      <p className="text-gray-500 max-w-md">זה עשוי לקחת מספר שניות. אנו מנתחים עשרות פרמטרים להבנה מעמיקה של ההתאמה.</p>
                    </div>
                  </div>
                ) : analysisError ? (
                  <div className="flex flex-col items-center justify-center h-full min-h-[500px] text-center space-y-6">
                    <div className="p-4 rounded-full bg-red-100">
                      <AlertTriangle className="h-12 w-12 text-red-600" />
                    </div>
                    <Alert variant="destructive" className="max-w-md border-red-200 bg-red-50">
                      <AlertTriangle className="h-5 w-5" />
                      <UiAlertTitle className="text-red-800">אופס, משהו השתבש</UiAlertTitle>
                      <AlertDescription className="text-red-700">
                        <p>לא הצלחנו להשלים את ניתוח ההתאמה כרגע.</p>
                        <p className="text-sm mt-2 opacity-90">{analysisError}</p>
                      </AlertDescription>
                    </Alert>
                    <Button
                      onClick={fetchAiAnalysis}
                      variant="outline"
                      className="mt-4 border-red-200 text-red-600 hover:bg-red-50"
                    >
                      <Bot className="w-4 h-4 ml-2" />
                      נסה שוב
                    </Button>
                  </div>
                ) : aiAnalysis ? (
                  <UserAiAnalysisDisplay analysis={aiAnalysis} />
                ) : null}
              </TabsContent>

              {/* Enhanced Details Tab */}
              <TabsContent value="details" className="mt-0 p-6 md:p-8 space-y-8">
                {/* Suggestion Information */}
                <Card className="border-0 shadow-xl bg-gradient-to-br from-white to-gray-50">
                  <CardContent className="p-6">
                    <h3 className="text-xl font-semibold mb-4 text-gray-800 flex items-center gap-2">
                      <Calendar className="w-5 h-5 text-purple-600" />
                      מידע על ההצעה
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="space-y-3">
                        <div className="flex justify-between items-center p-3 bg-purple-50 rounded-lg">
                          <span className="font-semibold text-gray-700">סטטוס נוכחי:</span>
                          <Badge className="bg-gradient-to-r from-purple-500 to-pink-500 text-white border-0 shadow-md">
                            {suggestion.status}
                          </Badge>
                        </div>
                        {suggestion.decisionDeadline && (
                          <div className="flex justify-between items-center p-3 bg-amber-50 rounded-lg">
                            <span className="font-semibold text-gray-700">תאריך יעד:</span>
                            <span className="text-gray-600 font-medium">
                              {new Date(suggestion.decisionDeadline).toLocaleDateString('he-IL')}
                            </span>
                          </div>
                        )}
                      </div>
                      <div className="space-y-3">
                        <div className="flex justify-between items-center p-3 bg-blue-50 rounded-lg">
                          <span className="font-semibold text-gray-700">תאריך יצירה:</span>
                          <span className="text-gray-600 font-medium">
                            {new Date(suggestion.createdAt).toLocaleDateString('he-IL')}
                          </span>
                        </div>
                        <div className="flex justify-between items-center p-3 bg-green-50 rounded-lg">
                          <span className="font-semibold text-gray-700">עדיפות:</span>
                          <Badge 
                            variant="outline" 
                            className={cn(
                              "border-2 font-semibold",
                              suggestion.priority === "HIGH" ? "border-red-300 text-red-700 bg-red-50" :
                              suggestion.priority === "MEDIUM" ? "border-amber-300 text-amber-700 bg-amber-50" :
                              "border-green-300 text-green-700 bg-green-50"
                            )}
                          >
                            {suggestion.priority}
                          </Badge>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
                
                {/* Process Timeline */}
                <SuggestionTimeline statusHistory={suggestion.statusHistory} />

                {/* Conversation with Matchmaker */}
                <InquiryThreadView 
                  suggestionId={suggestion.id}
                  userId={userId}
                  showComposer={true}
                />
              </TabsContent>
            </Tabs>
          </ScrollArea>
          
          {/* Enhanced Action Buttons */}
          <EnhancedQuickActions
            canAct={canActOnSuggestion}
            isSubmitting={isSubmitting}
            onApprove={() => triggerConfirmDialog('approve')}
            onDecline={() => triggerConfirmDialog('decline')}
            onAskQuestion={() => setShowAskDialog(true)}
          />
        </DialogContent>
      </Dialog>
      
      {/* Ask Matchmaker Dialog */}
      <AskMatchmakerDialog
        isOpen={showAskDialog}
        onClose={() => setShowAskDialog(false)}
        onSubmit={handleSendQuestion}
        matchmakerName={`${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`}
        suggestionId={suggestion.id}
      />

      {/* Confirmation Dialog */}
      <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
        <AlertDialogContent className="border-0 shadow-2xl rounded-2xl">
          <AlertDialogHeader>
            <AlertDialogTitle className="text-xl font-bold text-center">
              {actionToConfirm === "approve"
                ? "אישור הצעת השידוך"
                : "דחיית הצעת השידוך"}
            </AlertDialogTitle>
            <AlertDialogDescription className="text-center text-gray-600 leading-relaxed">
              {actionToConfirm === 'approve'
                ? isFirstParty ? (
                  <>
                    אתה עומד לאשר את ההצעה.
                    <br />
                    לאחר אישורך, ההצעה תועבר לצד השני. אם גם הוא/היא יאשרו, פרטי הקשר של שניכם יוחלפו.
                  </>
                ) : (
                  <>
                    הצד הראשון כבר אישר את ההצעה, וזה מרגש!
                    <br />
                    באישור שלך, פרטי הקשר שלך יישלחו לצד הראשון ופרטיו יישלחו אליך.
                  </>
                ) : "האם אתה בטוח שברצונך לדחות את הצעת השידוך? המשוב שלך עוזר לנו להציע התאמות טובות יותר בעתיד."
              }
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="gap-3">
            <AlertDialogCancel className="rounded-xl" disabled={isSubmitting}>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={executeConfirmedAction}
              disabled={isSubmitting}
              className={cn("rounded-xl font-medium shadow-lg hover:shadow-xl transition-all duration-300",
                actionToConfirm === "approve" ? "bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700" : "bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700"
              )}>
              {isSubmitting ? <Loader2 className="w-4 h-4 animate-spin" /> : (actionToConfirm === "approve" ? "כן, אני מאשר/ת!" : "דחיית ההצעה")}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default SuggestionDetailsModal;
--- End of Content for SuggestionDetailsModal.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\presentation
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\presentation\CompatibilityHighlights.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/presentation/CompatibilityHighlights.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from '@/components/ui/badge';
import { Check, BookOpen, Scroll, MapPin, Briefcase, Heart } from 'lucide-react';

interface ProfileData {
  religiousLevel?: string | null;
  education?: string | null;
  city?: string | null;
  occupation?: string | null;
}

interface CompatibilityHighlightsProps {
  firstPartyProfile: ProfileData;
  secondPartyProfile: ProfileData;
  matchingReason?: string | null;
}

interface Highlight {
  icon: React.ElementType;
  title: string;
  description: string;
  color: 'green' | 'blue' | 'indigo' | 'rose' | 'teal' | 'amber';
}

const CompatibilityHighlights: React.FC<CompatibilityHighlightsProps> = ({ firstPartyProfile, secondPartyProfile, matchingReason }) => {
  const highlights: Highlight[] = [];

  // 1. Religious Level
  if (firstPartyProfile.religiousLevel && firstPartyProfile.religiousLevel === secondPartyProfile.religiousLevel) {
    highlights.push({ icon: Scroll, title: "השקפת עולם דומה", description: `שניכם הגדרתם את עצמכם כ: ${firstPartyProfile.religiousLevel}`, color: 'indigo' });
  }

  // 2. Location (proximity logic would be better, but for now we'll check same city)
  if (firstPartyProfile.city && firstPartyProfile.city === secondPartyProfile.city) {
    highlights.push({ icon: MapPin, title: "קירבה גיאוגרפית", description: `שניכם גרים ב${firstPartyProfile.city}`, color: 'teal' });
  }

  // 3. Education - simple check for existence
  if (firstPartyProfile.education && secondPartyProfile.education) {
     highlights.push({ icon: BookOpen, title: "רקע והשכלה", description: `רקע לימודי ותעסוקתי שמשתלב היטב`, color: 'blue' });
  }
  
  // 4. From matching reason text
  const reasonText = matchingReason?.toLowerCase() || '';
  if (reasonText.includes('אופי') || reasonText.includes('אישיות')) {
     highlights.push({ icon: Heart, title: "התאמה אישיותית", description: 'השדכן/ית זיהו פוטנציאל לחיבור עמוק ברמה האישית.', color: 'rose' });
  }

  if (highlights.length === 0) {
      // Add a default highlight if none were found
      highlights.push({ icon: Check, title: "פוטנציאל להתאמה", description: 'השדכן/ית זיהו כאן הזדמנות שכדאי לבדוק!', color: 'green' });
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-xl text-center">נקודות החיבור המרכזיות</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {highlights.slice(0, 3).map((item, index) => (
            <div key={index} className={`p-4 rounded-lg border-2 border-${item.color}-200 bg-${item.color}-50 text-center transition-transform hover:scale-105`}>
              <div className={`mx-auto w-12 h-12 rounded-full bg-${item.color}-500 text-white flex items-center justify-center mb-3 shadow-lg`}>
                <item.icon className="w-6 h-6" />
              </div>
              <h4 className={`font-bold text-lg text-${item.color}-800`}>{item.title}</h4>
              <p className="text-sm text-gray-600 mt-1">{item.description}</p>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

export default CompatibilityHighlights;
--- End of Content for CompatibilityHighlights.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\presentation\MatchPresentationView.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import React from "react";
import Image from "next/image";
import {
  Heart,
  Sparkles,
  User,
  BookOpen,
  Scroll,
  MapPin,
  Briefcase,
  Quote,
  GraduationCap,
  ChevronLeft,
  type LucideProps // Import LucideProps for type safety if needed, though ElementType is simpler
} from "lucide-react";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { UserAiAnalysisDialog } from '../dialogs/UserAiAnalysisDialog';
import { getInitials } from '@/lib/utils';
import { cn } from "@/lib/utils";
import type { ExtendedMatchSuggestion } from "../types";

// --- קומפוננטות עזר פנימיות לעיצוב החדש ---

/**
 * HeroIntroduction: פתיח אישי מהשדכן.
 * יוצר את המסגרת הרגשית להצעה.
 */
const HeroIntroduction: React.FC<{
  matchmaker: { firstName: string; lastName: string; };
  personalNote?: string | null;
}> = ({ matchmaker, personalNote }) => (
  <div className="text-center p-6 rounded-2xl bg-gradient-to-br from-purple-100/50 via-pink-100/50 to-blue-100/50 border border-purple-200/40 shadow-lg">
    <div className="flex justify-center mb-4">
      <Avatar className="w-16 h-16 border-4 border-white shadow-md">
        <AvatarFallback className="bg-purple-500 text-white text-xl font-bold">
          {getInitials(`${matchmaker.firstName} ${matchmaker.lastName}`)}
        </AvatarFallback>
      </Avatar>
    </div>
    <h2 className="text-2xl md:text-3xl font-bold text-gray-800 tracking-tight">הצעה מיוחדת בדרך אליך...</h2>
    <p className="text-gray-600 mt-2">מחשבות מהשדכן/ית, {matchmaker.firstName}:</p>
    {personalNote && (
      <div className="mt-4 max-w-2xl mx-auto">
        <div className="relative bg-white/60 p-4 rounded-xl shadow-inner border border-purple-100">
          <Quote className="absolute top-2 right-2 w-8 h-8 text-purple-200/80 transform scale-x-[-1]" />
          <p className="text-lg text-purple-800 italic font-medium leading-relaxed">
            {personalNote}
          </p>
          <Quote className="absolute bottom-2 left-2 w-8 h-8 text-purple-200/80" />
        </div>
      </div>
    )}
  </div>
);

/**
 * ProfilePeek: כרטיס הצצה למועמד/ת.
 * עונה על השאלה "מי?" ויוצר סקרנות.
 */
const ProfilePeek: React.FC<{
  targetParty: ExtendedMatchSuggestion['secondParty'];
  onViewProfileClick: () => void;
}> = ({ targetParty, onViewProfileClick }) => {
  const age = targetParty.profile?.birthDate ? new Date().getFullYear() - new Date(targetParty.profile.birthDate).getFullYear() : null;
  const mainImage = targetParty.images?.find(img => img.isMain)?.url;
  return (
    <Card className="overflow-hidden shadow-xl transition-all hover:shadow-2xl">
      <div className="grid grid-cols-1 md:grid-cols-3">
        <div className="relative h-64 md:h-auto">
          {mainImage ? (
            <Image src={mainImage} alt={`תמונה של ${targetParty.firstName}`} fill className="object-cover" />
          ) : (
            <div className="w-full h-full bg-slate-200 flex items-center justify-center">
              <User className="w-16 h-16 text-slate-400" />
            </div>
          )}
        </div>
        <div className="md:col-span-2 p-6 flex flex-col justify-between bg-white">
          <div>
            <p className="text-sm font-semibold text-blue-600">הזדמנות להכיר את</p>
            <h3 className="text-3xl font-extrabold text-gray-900 mt-1">
              {targetParty.firstName} {targetParty.lastName}
              {age && <span className="text-2xl font-bold text-gray-500 ml-2">, {age}</span>}
            </h3>
            <div className="mt-4 grid grid-cols-2 gap-4 text-sm">
              <div className="flex items-center gap-2 text-gray-700">
                <MapPin className="w-4 h-4 text-teal-500" />
                <span>{targetParty.profile?.city || "לא צוין"}</span>
              </div>
              <div className="flex items-center gap-2 text-gray-700">
                <Briefcase className="w-4 h-4 text-emerald-500" />
                <span>{targetParty.profile?.occupation || "לא צוין"}</span>
              </div>
            </div>
          </div>
          <div className="mt-6 text-left">
            <Button onClick={onViewProfileClick} size="lg" className="font-bold">
              לפרופיל המלא
              <ChevronLeft className="w-5 h-5 mr-2" />
            </Button>
          </div>
        </div>
      </div>
    </Card>
  );
};

/**
 * KeyIngredients: רכיבי המפתח להתאמה.
 * הופך נתונים לסיפור שיווקי ומשכנע.
 */
const KeyIngredients: React.FC<{
  matchingReason?: string | null;
}> = ({ matchingReason }) => {
  // לוגיקה פשוטה לחילוץ נקודות מסיבת ההתאמה
  const getHighlightsFromReason = () => {
    // FIX: Explicitly type the array to prevent it from being inferred as 'never[]'
    const highlights: { icon: React.ElementType; text: string }[] = [];
    const reason = matchingReason?.toLowerCase() || '';
    if (reason.includes('ערכים') || reason.includes('השקפה')) {
      highlights.push({ icon: Scroll, text: 'ערכים והשקפת עולם' });
    }
    if (reason.includes('אישיות') || reason.includes('אופי')) {
      highlights.push({ icon: Heart, text: 'חיבור אישיותי' });
    }
    if (reason.includes('רקע') || reason.includes('השכלה')) {
      highlights.push({ icon: GraduationCap, text: 'רקע וסגנון חיים' });
    }
    if (highlights.length === 0 && matchingReason) {
      highlights.push({ icon: Sparkles, text: 'ניצוץ מיוחד' });
    }
    return highlights;
  }
  const highlights = getHighlightsFromReason();
  if (highlights.length === 0) return null;
  return (
    <div className="text-center">
      <h3 className="text-2xl font-bold text-gray-800 mb-6">רכיבי מפתח להתאמה מוצלחת</h3>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {highlights.map((item, index) => (
          <div key={index} className="bg-white p-6 rounded-xl shadow-lg border-t-4 border-blue-500 transform transition-transform hover:-translate-y-2">
            <div className="mx-auto w-14 h-14 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center mb-4">
              <item.icon className="w-7 h-7" />
            </div>
            <h4 className="font-bold text-xl text-gray-800">{item.text}</h4>
          </div>
        ))}
      </div>
      {matchingReason &&
        <Card className="mt-6 bg-blue-50 border-blue-200">
          <CardContent className="p-4">
            <p className="text-gray-700 text-center"><span className="font-semibold">פירוט מהשדכן/ית:</span> {matchingReason}</p>
          </CardContent>
        </Card>
      }
    </div>
  );
};


// --- הקומפוננטה הראשית המעודכנת ---
interface MatchPresentationViewProps {
  suggestion: ExtendedMatchSuggestion;
  userId: string;
  onSwitchTab: (tab: 'profile' | 'details') => void;
}
const MatchPresentationView: React.FC<MatchPresentationViewProps> = ({ suggestion, userId, onSwitchTab }) => {
  const isFirstParty = suggestion.firstPartyId === userId;
  const targetParty = isFirstParty ? suggestion.secondParty : suggestion.firstParty;
  // פונקציה שתעביר את המשתמש לטאב הפרופיל
  const handleViewProfile = () => {
    onSwitchTab('profile');
  };
  return (
    <div className="p-4 md:p-8 space-y-8 bg-gradient-to-b from-slate-50 to-blue-50">
      {/* 1. הפתיח האישי */}
      <HeroIntroduction
        matchmaker={suggestion.matchmaker}
        personalNote={isFirstParty ? suggestion.firstPartyNotes : suggestion.secondPartyNotes}
      />

      {/* 2. כרטיס הצצה למועמד/ת */}
      <ProfilePeek
        targetParty={targetParty}
        onViewProfileClick={handleViewProfile}
      />

      {/* 3. רכיבי המפתח להתאמה */}
      <KeyIngredients
        matchingReason={suggestion.matchingReason}
      />

      {/* 4. חוות דעת נוספת - AI */}
      <div className="text-center pt-4 border-t border-gray-200">
        <h3 className="text-xl font-semibold text-gray-700 mb-3">רוצה חוות דעת נוספת?</h3>
        <UserAiAnalysisDialog suggestedUserId={targetParty.id} />
      </div>

    </div>
  );
};
export default MatchPresentationView;
--- End of Content for MatchPresentationView.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\presentation\MatchmakerRationale.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/presentation/MatchmakerRationale.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Heart, MessageSquareQuote, Sparkles } from 'lucide-react';
// --- START OF CHANGE ---
// Now this import will work correctly
import { getInitials } from '@/lib/utils';
// --- END OF CHANGE ---

interface MatchmakerRationaleProps {
  matchmaker: { firstName: string; lastName: string; };
  generalReason?: string | null;
  personalNote?: string | null;
  targetPartyName: string;
}

const MatchmakerRationale: React.FC<MatchmakerRationaleProps> = ({ matchmaker, generalReason, personalNote, targetPartyName }) => {
  const fullName = `${matchmaker.firstName} ${matchmaker.lastName}`;

  return (
    <Card className="bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50 shadow-xl border-purple-200/50">
      <CardHeader className="text-center">
        <div className="flex justify-center items-center gap-3 mb-3">
          <Avatar className="w-12 h-12 border-2 border-white shadow-lg">
            {/* You can add an AvatarImage here in the future if matchmakers have profile pictures */}
            {/* <AvatarImage src={matchmaker.avatarUrl} /> */}
            <AvatarFallback className="bg-purple-500 text-white font-bold">
              {/* This function call is now valid */}
              {getInitials(fullName)}
            </AvatarFallback>
          </Avatar>
          <div>
            <CardDescription className="text-sm text-purple-800">מחשבות מהשדכן/ית {fullName}</CardDescription>
            <CardTitle className="text-2xl font-bold text-gray-800">הצעה מיוחדת עבורך</CardTitle>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-6 text-center">
        {personalNote && (
          <div className="bg-white/70 p-4 rounded-xl shadow-inner border border-purple-100">
            <h3 className="font-semibold text-lg text-purple-700 flex items-center justify-center gap-2 mb-2">
              <Heart className="w-5 h-5" />
              למה חשבתי שזה מתאים במיוחד עבורך
            </h3>
            <p className="text-gray-700 text-base leading-relaxed italic">
              {personalNote}
            </p>
          </div>
        )}
        
        {generalReason && (
          <div className="bg-white/70 p-4 rounded-xl shadow-inner border border-blue-100">
            <h3 className="font-semibold text-lg text-blue-700 flex items-center justify-center gap-2 mb-2">
              <Sparkles className="w-5 h-5" />
              החיבור הכללי שאנו רואים
            </h3>
            <p className="text-gray-600 text-base leading-relaxed">
              {generalReason}
            </p>
          </div>
        )}

        {!personalNote && !generalReason && (
            <p className="text-gray-500">השדכן/ית סומך/ת על הנתונים שידברו בעד עצמם.</p>
        )}
      </CardContent>
    </Card>
  );
};

export default MatchmakerRationale;
--- End of Content for MatchmakerRationale.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\timeline
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\timeline\SuggestionTimeline.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/suggestions/timeline/SuggestionTimeline.tsx

import React from "react";
import { format } from "date-fns";
import { he } from "date-fns/locale";
import {
  Clock,
  MessageCircle,
  User,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { getEnhancedStatusInfo } from "@/lib/utils/suggestionUtils";
import type { MatchSuggestionStatus } from "@prisma/client";

interface StatusHistoryItem {
  id: string;
  status: string;
  notes?: string | null;
  createdAt: Date | string;
}

interface SuggestionTimelineProps {
  statusHistory: StatusHistoryItem[];
  userId?: string;
  className?: string;
}

const getCategoryColor = (category: string) => {
  switch (category) {
    case "pending":
      return "border-purple-200";
    case "approved":
      return "border-emerald-200";
    case "progress":
      return "border-blue-200";
    case "completed":
      return "border-yellow-200";
    case "declined":
      return "border-red-200";
    default:
      return "border-gray-200";
  }
};

const TimelineNode: React.FC<{
  statusInfo: ReturnType<typeof getEnhancedStatusInfo>;
  isLatest: boolean;
  isLast: boolean;
}> = ({ statusInfo, isLatest, isLast }) => {
  const IconComponent = statusInfo.icon;
  
  return (
    <div className="relative flex items-center">
      {/* Connecting Line */}
      {!isLast && (
        <div 
          className={cn(
            "absolute top-12 right-6 w-0.5 h-16 bg-gradient-to-b rounded-full",
            isLatest ? "from-cyan-300 to-cyan-100" : "from-gray-300 to-gray-100"
          )}
        />
      )}
      
      {/* Node Circle */}
      <div className={cn(
        "relative z-10 w-12 h-12 rounded-full shadow-lg flex items-center justify-center text-white",
        statusInfo.className.includes('purple') ? "bg-gradient-to-br from-purple-400 to-purple-500" :
        statusInfo.className.includes('emerald') || statusInfo.className.includes('green') ? "bg-gradient-to-br from-emerald-400 to-green-500" :
        statusInfo.className.includes('blue') || statusInfo.className.includes('cyan') ? "bg-gradient-to-br from-blue-400 to-cyan-500" :
        statusInfo.className.includes('red') || statusInfo.className.includes('rose') ? "bg-gradient-to-br from-red-400 to-rose-500" :
        statusInfo.className.includes('yellow') || statusInfo.className.includes('amber') ? "bg-gradient-to-br from-yellow-400 to-amber-500" :
        statusInfo.className.includes('orange') ? "bg-gradient-to-br from-orange-400 to-orange-500" :
        "bg-gradient-to-br from-gray-400 to-gray-500",
        isLatest && "ring-4 ring-cyan-200 animate-pulse-subtle"
      )}>
        <IconComponent className="w-6 h-6" />
      </div>
    </div>
  );
};

const SuggestionTimeline: React.FC<SuggestionTimelineProps> = ({ 
  statusHistory,
  userId,
  className
}) => {
  // Sort history from newest to oldest
  const sortedHistory = [...statusHistory].sort((a, b) => 
    new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  );

  if (sortedHistory.length === 0) {
    return (
      <Card className={cn("border-0 shadow-lg", className)}>
        <CardContent className="p-8 text-center">
          <Clock className="w-12 h-12 mx-auto mb-4 text-gray-400" />
          <h3 className="text-lg font-semibold text-gray-600 mb-2">אין היסטוריה זמינה</h3>
          <p className="text-gray-500">עדיין לא בוצעו פעולות על ההצעה הזו</p>
        </CardContent>
      </Card>
    );
  }

  // Get info for the latest status to use in the summary section
  const latestStatusInfo = getEnhancedStatusInfo(
    sortedHistory[0].status as MatchSuggestionStatus,
    userId ? true : false
  );

  return (
    <Card className={cn("border-0 shadow-lg overflow-hidden", className)}>
      <CardContent className="p-6">
        <div className="flex items-center gap-3 mb-6">
          <div className="p-2 rounded-lg bg-gradient-to-r from-cyan-500 to-emerald-500 text-white shadow-md">
            <Clock className="w-5 h-5" />
          </div>
          <div>
            <h3 className="text-xl font-bold text-gray-800">מסלול ההצעה</h3>
            <p className="text-sm text-gray-600">עקוב אחר התקדמות ההצעה לאורך זמן</p>
          </div>
        </div>
        
        <div className="space-y-6">
          {sortedHistory.map((item, index) => {
            const statusInfo = getEnhancedStatusInfo(
              item.status as MatchSuggestionStatus,
              userId ? true : false
            );
            const isLatest = index === 0;
            const isLast = index === sortedHistory.length - 1;
            
            const formattedDate = format(
              new Date(item.createdAt),
              "dd בMMMM yyyy",
              { locale: he }
            );
            
            const formattedTime = format(
              new Date(item.createdAt),
              "HH:mm",
              { locale: he }
            );
            
            return (
              <div key={item.id} className="flex gap-4">
                <TimelineNode 
                  statusInfo={statusInfo}
                  isLatest={isLatest}
                  isLast={isLast}
                />
                
                <div className="flex-1 pb-4">
                  <Card className={cn(
                    "border-2 transition-all duration-300 hover:shadow-md",
                    getCategoryColor(statusInfo.category),
                    isLatest && "shadow-md"
                  )}>
                    <CardContent className={cn(
                      "p-4",
                      statusInfo.className.includes('purple') ? "bg-purple-50" :
                      statusInfo.className.includes('emerald') || statusInfo.className.includes('green') ? "bg-emerald-50" :
                      statusInfo.className.includes('blue') || statusInfo.className.includes('cyan') ? "bg-blue-50" :
                      statusInfo.className.includes('red') || statusInfo.className.includes('rose') ? "bg-red-50" :
                      statusInfo.className.includes('yellow') || statusInfo.className.includes('amber') ? "bg-yellow-50" :
                      statusInfo.className.includes('orange') ? "bg-orange-50" :
                      "bg-gray-50"
                    )}>
                      <div className="flex justify-between items-start mb-3">
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <Badge 
                              className={cn(
                                "border-0 shadow-sm font-semibold",
                                statusInfo.className
                              )}
                            >
                              {statusInfo.label}
                            </Badge>
                            {isLatest && (
                              <Badge variant="outline" className="bg-white/80 text-cyan-600 border-cyan-200 text-xs">
                                עכשיו
                              </Badge>
                            )}
                          </div>
                          <p className={cn(
                            "text-sm font-medium mb-2",
                            statusInfo.className.includes('purple') ? "text-purple-700" :
                            statusInfo.className.includes('emerald') || statusInfo.className.includes('green') ? "text-emerald-700" :
                            statusInfo.className.includes('blue') || statusInfo.className.includes('cyan') ? "text-blue-700" :
                            statusInfo.className.includes('red') || statusInfo.className.includes('rose') ? "text-red-700" :
                            statusInfo.className.includes('yellow') || statusInfo.className.includes('amber') ? "text-yellow-700" :
                            statusInfo.className.includes('orange') ? "text-orange-700" :
                            "text-gray-700"
                          )}>
                            {statusInfo.description}
                          </p>
                        </div>
                        
                        <div className="text-left text-xs text-gray-500 space-y-1">
                          <div className="font-medium">{formattedDate}</div>
                          <div className="flex items-center gap-1">
                            <Clock className="w-3 h-3" />
                            {formattedTime}
                          </div>
                        </div>
                      </div>
                      
                      {item.notes && (
                        <div className="mt-3 p-3 bg-white/60 backdrop-blur-sm rounded-lg border border-white/40">
                          <div className="flex items-start gap-2">
                            <MessageCircle className="w-4 h-4 text-gray-500 mt-0.5 flex-shrink-0" />
                            <p className="text-sm text-gray-700 leading-relaxed">{item.notes}</p>
                          </div>
                        </div>
                      )}
                    </CardContent>
                  </Card>
                </div>
              </div>
            );
          })}
        </div>

        {/* Summary */}
        <div className="mt-8 pt-6 border-t border-gray-200">
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
            <div className="space-y-1">
              <div className="text-2xl font-bold text-cyan-600">{sortedHistory.length}</div>
              <div className="text-xs text-gray-500 font-medium">שלבים סה״כ</div>
            </div>
            <div className="space-y-1">
              <div className="text-2xl font-bold text-emerald-600">
                {Math.ceil((Date.now() - new Date(sortedHistory[sortedHistory.length - 1].createdAt).getTime()) / (1000 * 60 * 60 * 24))}
              </div>
              <div className="text-xs text-gray-500 font-medium">ימים פעילים</div>
            </div>
            <div className="space-y-1">
              <div className="text-2xl font-bold text-blue-600">
                {sortedHistory.filter(s => s.status.includes('APPROVED')).length}
              </div>
              <div className="text-xs text-gray-500 font-medium">אישורים</div>
            </div>
            <div className="space-y-1">
              <div className="text-2xl font-bold text-amber-600">
                {latestStatusInfo.category === 'completed' ? '🎉' : 
                 latestStatusInfo.category === 'progress' ? '⏳' : 
                 latestStatusInfo.category === 'approved' ? '✅' : '📋'}
              </div>
              <div className="text-xs text-gray-500 font-medium">סטטוס נוכחי</div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default SuggestionTimeline;
--- End of Content for SuggestionTimeline.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\contact\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/contact/page.tsx
"use client";

import React, { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, ArrowRight, Send, CheckCircle, AlertTriangle } from "lucide-react";
import { z } from "zod";

// Zod schema for client-side validation
const contactSchema = z.object({
  name: z.string().min(2, { message: "השם חייב להכיל לפחות 2 תווים" }),
  email: z.string().email({ message: "כתובת מייל לא תקינה" }),
  message: z.string().min(10, { message: "ההודעה חייבת להכיל לפחות 10 תווים" }),
});

export default function ContactPage() {
  const router = useRouter();
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [message, setMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [validationErrors, setValidationErrors] = useState<Record<string, string[] | undefined> | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setSuccess(false);
    setValidationErrors(null);

    // Client-side validation using Zod
    const validationResult = contactSchema.safeParse({ name, email, message });
    if (!validationResult.success) {
      setValidationErrors(validationResult.error.flatten().fieldErrors);
      setIsLoading(false);
      return;
    }

    try {
      // Send the request to the dedicated contact API endpoint
      const response = await fetch("/api/contact", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: validationResult.data.name,
          email: validationResult.data.email,
          message: validationResult.data.message,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "אירעה שגיאה בשליחת ההודעה");
      }

      setSuccess(true);
      // Clear the form fields on success
      setName("");
      setEmail("");
      setMessage("");
    } catch (err: unknown) {
      setError(err instanceof Error ? err.message : "אירעה שגיאה לא צפויה");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 sm:p-8">
      <button
        onClick={() => router.push("/")}
        className="absolute top-4 left-4 rtl:right-4 rtl:left-auto text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm z-20"
      >
        <ArrowRight className="h-4 w-4" />
        חזרה לדף הבית
      </button>

      <Card className="w-full max-w-lg shadow-xl border-t-4 border-t-cyan-500">
        <CardHeader className="text-center">
          <div className="inline-block mx-auto mb-4 p-3 bg-cyan-100 rounded-full">
            <Send className="w-8 h-8 text-cyan-600" />
          </div>
          <CardTitle className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-600 to-pink-600">
            צור קשר
          </CardTitle>
          <CardDescription className="text-gray-600 pt-2">
            יש לך שאלה? הצעה? נשמח לשמוע ממך!
          </CardDescription>
        </CardHeader>
        <CardContent>
          {success ? (
            <Alert variant="default" className="bg-green-50 border-green-200 text-green-800">
              <CheckCircle className="h-5 w-5 text-green-600" />
              <AlertTitle className="font-semibold">ההודעה נשלחה בהצלחה!</AlertTitle>
              <AlertDescription>
                תודה על פנייתך. צוות Match Point ייצור איתך קשר בהקדם האפשרי.
              </AlertDescription>
            </Alert>
          ) : (
            <form onSubmit={handleSubmit} className="space-y-4">
              <div className="space-y-2">
                <Input
                  id="name"
                  type="text"
                  placeholder="שם מלא"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  disabled={isLoading}
                  className={`transition-colors focus:border-cyan-500 ${validationErrors?.name ? "border-red-500 focus:border-red-500" : ""}`}
                />
                {validationErrors?.name && <p className="text-xs text-red-600">{validationErrors.name[0]}</p>}
              </div>
              <div className="space-y-2">
                <Input
                  id="email"
                  type="email"
                  placeholder="כתובת אימייל לחזרה"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  disabled={isLoading}
                  className={`transition-colors focus:border-cyan-500 ${validationErrors?.email ? "border-red-500 focus:border-red-500" : ""}`}
                />
                 {validationErrors?.email && <p className="text-xs text-red-600">{validationErrors.email[0]}</p>}
              </div>
              <div className="space-y-2">
                <Textarea
                  id="message"
                  placeholder="הודעה"
                  rows={6}
                  value={message}
                  onChange={(e) => setMessage(e.target.value)}
                  disabled={isLoading}
                  className={`transition-colors focus:border-cyan-500 ${validationErrors?.message ? "border-red-500 focus:border-red-500" : ""}`}
                />
                {validationErrors?.message && <p className="text-xs text-red-600">{validationErrors.message[0]}</p>}
              </div>

              {error && (
                <Alert variant="destructive">
                  <AlertTriangle className="h-4 w-4" />
                  <AlertTitle>שגיאה</AlertTitle>
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}

              <Button type="submit" className="w-full bg-cyan-600 hover:bg-cyan-700" disabled={isLoading}>
                {isLoading ? (
                  <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                ) : (
                  <Send className="ml-2 h-4 w-4" />
                )}
                {isLoading ? "שולח..." : "שלח הודעה"}
              </Button>
            </form>
          )}
        </CardContent>
      </Card>
        <div className="mt-8 text-center text-sm text-gray-500">
            © {new Date().getFullYear()} Match Point. כל הזכויות שמורות.
        </div>
    </div>
  );
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\contexts
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\contexts\LanguageContext.tsx
--------------------------------------------------------------------------------
Content:
// src/app/contexts/LanguageContext.tsx
"use client";

import React, { createContext, useContext, useState, useEffect } from "react";

type Language = "he" | "en";

interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
}

const LanguageContext = createContext<LanguageContextType | undefined>(
  undefined
);

export function useLanguage() {
  const context = useContext(LanguageContext);
  if (context === undefined) {
    throw new Error("useLanguage must be used within a LanguageProvider");
  }
  return context;
}

// app/contexts/LanguageContext.tsx
export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [language, setLanguage] = useState<Language>("he");
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
    const savedLanguage = localStorage.getItem("language") as Language;
    if (savedLanguage) {
      setLanguage(savedLanguage);
    }
  }, []);

  const handleSetLanguage = (lang: Language) => {
    setLanguage(lang);
    if (mounted) {
      localStorage.setItem("language", lang);
    }
  };

  // החזרת הקונטקסט תמיד, עם ערכי ברירת מחדל
  return (
    <LanguageContext.Provider
      value={{ language, setLanguage: handleSetLanguage }}
    >
      {children}
    </LanguageContext.Provider>
  );
}
--- End of Content for LanguageContext.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\contexts\NotificationContext.tsx
--------------------------------------------------------------------------------
Content:
// src/app/contexts/NotificationContext.tsx
"use client";
import React, {
  createContext,
  useContext,
  useEffect,
  useRef,
  useState,
  useCallback, // הוסף useCallback
} from "react";
import { useSession } from "next-auth/react";
import type { Session } from "next-auth"; // Import Session type
import type { NotificationCount } from "@/types/messages"; // ודא שהנתיב לטיפוסים שלך נכון

interface NotificationContextType {
  notifications: NotificationCount;
  refreshNotifications: () => Promise<void>;
  isLoadingNotifications: boolean; // הוסף מצב טעינה
}

const NotificationContext = createContext<NotificationContextType>({
  notifications: { availabilityRequests: 0, messages: 0, total: 0 },
  refreshNotifications: async () => {},
  isLoadingNotifications: true, // ערך התחלתי
});

export const useNotifications = () => useContext(NotificationContext);

export function NotificationProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { data: session, status } = useSession() as {
    data: Session | null;
    status: string;
  };
  const [notifications, setNotifications] = useState<NotificationCount>({
    availabilityRequests: 0,
    messages: 0,
    total: 0,
  });
  const [isLoadingNotifications, setIsLoadingNotifications] = useState(true); // מצב טעינה

  const pollingInterval = useRef<NodeJS.Timeout | undefined>(); // שנה את הטיפוס כדי לאפשר undefined

  const fetchNotifications = useCallback(async () => {
    if (
      status !== "authenticated" ||
      !session?.user?.id ||
      !session?.user.isPhoneVerified
    ) {
      // console.log(
      //   "[NotificationContext] Skipping fetchNotifications: User session not ready or phone not verified.",
      //   { status, userId: session?.user?.id, isPhoneVerified: session?.user?.isPhoneVerified }
      // );
      setNotifications({ availabilityRequests: 0, messages: 0, total: 0 });
      setIsLoadingNotifications(false); // סיים טעינה גם אם לא קוראים ל-API
      return;
    }

    // console.log("[NotificationContext] Attempting to fetch notifications...");
    setIsLoadingNotifications(true);
    try {
      const response = await fetch("/api/notifications");
      if (!response.ok) {
        // אם התגובה היא הפנייה (למשל 307), זה יגיע לכאן
        // console.warn(
        //   `[NotificationContext] Failed to fetch notifications. Status: ${response.status}`
        // );
        // במקרה של הפנייה, ה-response.json() ייכשל למטה, אז נצא כאן
        // או שנאפס נוטיפיקציות אם רוצים
        setNotifications({ availabilityRequests: 0, messages: 0, total: 0 });
        // החזר שגיאה ספציפית או אל תעשה כלום
        throw new Error(`Server responded with ${response.status}`);
      }
      const data = await response.json();
      setNotifications(data);
      // console.log("[NotificationContext] Notifications fetched successfully:", data);
    } catch {
      // <-- שינוי: שימוש ב-_error כדי לציין שהמשתנה אינו בשימוש
      // console.error(
      //   "[NotificationContext] Error fetching or parsing notifications:",
      //   _error // <-- גם כאן, אם נוריד את ההערה
      // );
      // אם יש שגיאה (כולל JSON לא תקין), אפס נוטיפיקציות
      setNotifications({ availabilityRequests: 0, messages: 0, total: 0 });
    } finally {
      setIsLoadingNotifications(false);
    }
  }, [status, session?.user?.id, session?.user?.isPhoneVerified]); // תלויות של useCallback

  useEffect(() => {
    // console.log("[NotificationContext] useEffect triggered. Status:", status, "User ID:", session?.user?.id, "Phone Verified:", session?.user?.isPhoneVerified);

    if (
      status === "authenticated" &&
      session?.user?.id &&
      session.user.isPhoneVerified
    ) {
      // console.log(
      //   "[NotificationContext] User is authenticated and phone verified. Setting up notifications fetch and polling."
      // );
      fetchNotifications(); // קריאה ראשונית

      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
      }
      pollingInterval.current = setInterval(fetchNotifications, 30000); // 30 שניות

      return () => {
        if (pollingInterval.current) {
          clearInterval(pollingInterval.current);
          pollingInterval.current = undefined;
          // console.log(
          //   "[NotificationContext] Cleared notification polling interval on cleanup."
          // );
        }
      };
    } else {
      // אם המשתמש לא מחובר, או שהסשן בטעינה, או שהטלפון לא מאומת
      // console.log(
      //   "[NotificationContext] Conditions not met for notifications. Clearing interval and resetting notifications.",
      //   { status, userId: session?.user?.id, isPhoneVerified: session?.user?.isPhoneVerified }
      // );
      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
        pollingInterval.current = undefined;
      }
      setNotifications({ availabilityRequests: 0, messages: 0, total: 0 });
      // קבע את מצב הטעינה ל-false אם התנאים לא מתקיימים והאפקט רץ
      // כדי למנוע מצב טעינה תמידי אם המשתמש לא יאמת טלפון
      if (status !== "loading") {
        // רק אם הסשן לא באמצע טעינה
        setIsLoadingNotifications(false);
      }
    }
  }, [
    session?.user?.id,
    session?.user?.isPhoneVerified,
    status,
    fetchNotifications,
  ]); // הוסף fetchNotifications לתלויות

  const value = {
    notifications,
    refreshNotifications: fetchNotifications,
    isLoadingNotifications,
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
}
--- End of Content for NotificationContext.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\legal
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\legal\privacy-policy
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\legal\privacy-policy\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/legal/privacy-policy/page.tsx
import React from 'react';
import Head from 'next/head';

const PrivacyPolicyPage = () => {
  const companyNameLegal = `ג'ואיש מאצ'פוינט בע"מ`;
  const companyNameJsx = <>{`ג'ואיש מאצ'פוינט בע"מ`}</>; // נשאר כפי שהיה אצלך
  const companyNumber = '517172631';
  const pageTitle = `מדיניות פרטיות | ${companyNameLegal}`;
  const pageDescription = `מדיניות הפרטיות של מערכת השידוכים Matchpoint. כיצד אנו אוספים, משתמשים ושומרים על המידע האישי שלך.`;
  const lastUpdatedDate = '9 ביוני 2025'; // עודכן תאריך
  const companyEmail = 'jewish.matchpoint@gmail.com';
  const siteUrl = 'https://www.jewishmatchpoint.com'; // יש לוודא שזה ה-URL הסופי
  const companyRegisteredAddress = 'גולומב 7, רעננה, ישראל'; // תוקן פסיק

  return (
    <>
      <Head>
        <title>{pageTitle}</title>
        <meta name='description' content={pageDescription} />
        <meta property='og:title' content={pageTitle} />
        <meta property='og:description' content={pageDescription} />
        <meta property='og:url' content={`${siteUrl}/legal/privacy-policy`} />
        <meta name='twitter:card' content='summary_large_image' />
      </Head>
      <div className='bg-gradient-to-br from-cyan-50 via-white to-pink-50 min-h-screen py-12 px-4 sm:px-6 lg:px-8'>
        <div className='container mx-auto max-w-4xl bg-white shadow-xl rounded-lg p-8 sm:p-12'>
          <header className='mb-10 text-center border-b pb-6 border-gray-200'>
            <h1 className='text-4xl sm:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-pink-500'>
              מדיניות פרטיות
            </h1>
            <p className='mt-3 text-lg text-gray-600'>
              של מערכת השידוכים Matchpoint (מופעלת על ידי {companyNameJsx})
            </p>
            <p className='mt-2 text-sm text-gray-500'>
              עדכון אחרון: {lastUpdatedDate}
            </p>
          </header>

          <article className='prose prose-lg max-w-none text-gray-700 leading-relaxed text-right'>
            <p><strong>הקדמה</strong></p>
            <p>
              אנו ב-{companyNameJsx} (ח.פ. {companyNumber}) (להלן: <strong>{`"המערכת"`}</strong>, <strong>{`"השירות"`}</strong>, <strong>{`"אנו"`}</strong>, <strong>{`"שלנו"`}</strong> או <strong>{`"Matchpoint"`}</strong>) מכבדים את פרטיותך ומחויבים להגן על המידע האישי שאתה חולק איתנו. מדיניות פרטיות זו (להלן: <strong>{`"המדיניות"`}</strong>) מתארת את האופן בו אנו אוספים, משתמשים, מעבדים, חושפים, מעבירים ומאחסנים את המידע האישי שלך. מדיניות זו מהווה חלק בלתי נפרד מתנאי השימוש של המערכת.
              אנו ממליצים לך לקרוא מדיניות זו בעיון רב על מנת להבין את נהלינו ביחס למידע האישי שלך ואת זכויותיך.
            </p>

            <h2 id='consent'>1. הסכמה ומאגר מידע</h2>
            <p>
              {`בעצם הרשמתך למערכת Matchpoint, השימוש בה, ובפרט במסירת פרטיך האישיים (בין אם ישירות ובין אם באמצעות שדכן מורשה של Matchpoint הפועל בהסכמתך), הינך מביע את הסכמתך החופשית, המפורשת והמיודעת לתנאים המפורטים במדיניות פרטיות זו. הסכמה זו כוללת את איסוף, עיבוד, שמירה, שימוש ושיתוף המידע האישי שלך, `}<strong>לרבות מידע רגיש</strong> (כהגדרתו בחוק הגנת הפרטיות, {`התשמ"א-1981`}, להלן: <strong>{`"החוק"`}</strong>), כמפורט במדיניות זו.
            </p>
            <p>
              הינך מאשר כי ידוע לך שהמידע שתמסור, בין אם ישירות ובין אם באמצעות שדכן של Matchpoint, יישמר במאגר המידע של {companyNameJsx} (להלן: <strong>{`"מאגר המידע"`}</strong>), אשר רשום (או יירשם) כדין בפנקס מאגרי המידע המנוהל על ידי הרשות להגנת הפרטיות. שם החברה בעלת המאגר הוא {companyNameJsx}, מספר ח.פ. {companyNumber}, כתובת רשומה {companyRegisteredAddress}.
            </p>
            <p>
              <strong>{`אם אינך מסכים/ה לתנאי מדיניות זו, במלואם או בחלקם, עליך להימנע משימוש במערכת וממסירת פרטיך האישיים.`}</strong>
            </p>

            <h2 id='collected-info'>2. איזה מידע אנו אוספים?</h2>
            <p>
              אנו אוספים סוגים שונים של מידע אישי, בין אם נמסר ישירות על ידך, בין אם נאסף באופן אוטומטי במהלך שימושך במערכת, ובין אם נמסר לנו על ידי שדכנים של Matchpoint הפועלים בהסכמתך:
            </p>
            <p><strong>2.1. מידע הנמסר ישירות על ידך:</strong></p>
            <ul>
              <li><strong>פרטי זיהוי וקשר בסיסיים:</strong> {`שם מלא (פרטי ומשפחה), כתובת דוא'ל, מספר טלפון (אשר ישמש גם לאימות וליצירת קשר), סיסמה (מוצפנת).`}</li>
              <li>
                <strong>מידע פרופיל מפורט (העשוי לכלול מידע רגיש):</strong>
                <ul>
                  <li><strong>דמוגרפיה ואישיות:</strong> {`מין, תאריך לידה (והאם משוער), שפת אם, שפות נוספות, גובה, מצב משפחתי, עיסוק/מקצוע, מוסד השכלה ורמת השכלה, עיר מגורים, ארץ מוצא (עדתיות), רקע דתי/רמת דתיות (כגון הגדרה עצמית, סוג כיפה, סוג כיסוי ראש, שמירת נגיעה), סוג שירות (צבאי/לאומי) ופרטיו, האם יש ילדים מקשר קודם, תכונות אופי המאפיינות אותך, תחביבים ותחומי עניין, ארץ עלייה ושנת עלייה (אם רלוונטי), טקסט חופשי "על עצמי" לתיאור אישי, סטטוס הורי (למשל, יתום/ה מהורה, הורים גרושים), מספר אחים, ומיקומך במשפחה.`}</li>
                  <li><strong>העדפות לשידוך (העשוי לכלול מידע רגיש):</strong> {`טווחי גיל וגובה מועדפים לבן/בת הזוג, רמות דתיות מועדפות, מיקומים גאוגרפיים מועדפים, סוגי השכלה ועיסוקים מועדפים, העדפה ליצירת קשר, העדפה לגבי קיום ילדים מקשר קודם אצל בן/בת הזוג, האם בן/בת הזוג שומר/ת נגיעה, מוצאים עדתיים מועדפים, סוגי שירות (צבאי/לאומי) מועדפים, סוגי כיסוי ראש (לנשים) או כיפה (לגברים) מועדפים, תכונות אופי ותחביבים מועדפים, סטטוס עלייה מועדף, העדפה למין השדכן (אם רלוונטי), והערות כלליות על השידוך המבוקש.`}</li>
                </ul>
              </li>
              <li><strong>תמונות וסרטונים:</strong> {`תמונות שהעלית לפרופיל שלך, וסרטוני וידאו (כגון סרטון היכרות, סיפור אישי) שהעלית למערכת.`}</li>
              <li><strong>תשובות לשאלונים (מידע רגיש ביותר):</strong> {`תשובות מפורטות ומעמיקות לשאלונים של Matchpoint בנושאי ערכים, אישיות, תפיסות לגבי זוגיות, העדפות בבן/בת הזוג, ואמונה ודת. מידע זה נשמר במאגר ועשוי לכלול פרטים אינטימיים ורגישים ביותר אודותיך, דעותיך ואמונותיך.`}</li>
              <li><strong>מידע על אינטראקציות ומשובים:</strong> {`תגובות להצעות שידוך, משובים על פגישות (דייטים), העדפות ליצירת קשר עם הצעה ספציפית.`}</li>
            </ul>
            <p><strong>2.2. מידע הנאסף או נוצר באופן אוטומטי במהלך שימושך במערכת:</strong></p>
            <ul>
              <li><strong>פרטי חשבון ושימוש:</strong> {`מזהה משתמש ייחודי, תאריכי יצירה ועדכון של החשבון והפרופיל, תאריך כניסה אחרונה, סטטוס משתמש (למשל, PENDING_PHONE_VERIFICATION, ACTIVE, INACTIVE, BLOCKED), תפקיד במערכת (CANDIDATE, MATCHMAKER, ADMIN), האם הפרופיל הושלם (isProfileComplete).`}</li>
              <li><strong>מידע טכני:</strong> {`כתובת IP (עשויה להיאסף באופן זמני או קבוע לצורכי אבטחה וניתוח), סוג דפדפן ומערכת הפעלה, נתוני שימוש אגרגטיביים (ללא זיהוי אישי), פרטי התחברות לחשבונות צד שלישי (Account provider, providerAccountId - אם רלוונטי בעתיד).`}</li>
              <li><strong>מידע על הצעות ופגישות:</strong> {`היסטוריית הצעות שידוך (MatchSuggestion) שנשלחו והתקבלו, סטטוסים של הצעות (MatchSuggestionStatus), תזמוני פגישות שנקבעו (Meeting), משובים על פגישות (DateFeedback).`}</li>
              <li><strong>תיעוד הסכמות:</strong> {`תאריך ושעה של אישור תנאי השימוש ומדיניות הפרטיות (termsAndPrivacyAcceptedAt).`}</li>
            </ul>
            <p><strong>2.3. מידע שהוזן למערכת על ידי שדכן של Matchpoint (<code>{`source: 'MANUAL_ENTRY'`}</code>):</strong></p>
            <p>
              {`במקרים מסוימים, שדכן מורשה של Matchpoint עשוי להזין למערכת פרטים אודותיך (כולל מידע רגיש), אשר נמסרו לו על ידך ישירות (למשל, בפגישה אישית, בשיחת טלפון, או בהתכתבות מחוץ למערכת) או שהגיעו לידיעתו ממקורות בהם פרסמת את פרטיך בהסכמה (כגון קבוצות WhatsApp ייעודיות לשידוכים).`}
              במקרים אלו:
            </p>
            <ul>
              <li>{`השדכן יפעל לקבל את הסכמתך המפורשת לאיסוף המידע ולשמירתו במאגר Matchpoint, בהתאם למדיניות זו.`}</li>
              <li>{`אנו נפעל ליידע אותך, ככל הניתן ובאמצעים סבירים (למשל, באמצעות שליחת הודעת דוא'ל או SMS עם קישור למדיניות זו ולהוראות ליצירת חשבון וגישה למידע), על הכללת פרטיך במאגר.`}</li>
              <li>{`תינתן לך האפשרות ליצור חשבון משתמש, לעיין במידע שנאסף אודותיך, לעדכנו, ולהפעיל את זכויותיך האחרות כמפורט בסעיף 7 להלן. אם לא תיצור חשבון או לא תאשר את המידע באופן פעיל, השימוש במידע שלך יוגבל בהתאם.`}</li>
            </ul>
            <p><strong>2.4. מידע מאימותים (Verifications):</strong></p>
            <p>
              {`פרטי תהליכי אימות שבוצעו במערכת (כגון אימות כתובת דוא'ל, אימות מספר טלפון באמצעות קוד, אימות מסמכים אם יידרש בעתיד, תהליכי איפוס סיסמה). מידע זה כולל את סוג האימות (VerificationType), סטטוס האימות (VerificationStatus), ומועדי האימות.`}
            </p>

            <h2 id='how-we-use'>3. כיצד אנו משתמשים במידע שלך (מטרות העיבוד)?</h2>
            <p>
              המידע האישי שאנו אוספים, <strong>ובכלל זה מידע רגיש</strong>, משמש אותנו למטרות הבאות, החיוניות למתן השירות:
            </p>
            <ul>
              <li><strong>לספק לך את שירותי השידוכים של Matchpoint:</strong>
                <ul>
                  <li>יצירה וניהול של הפרופיל האישי שלך.</li>
                  <li>{`ניתוח המידע האישי שלך, העדפותיך, ותשובותיך לשאלונים, לצורך איתור והצעת התאמות זוגיות פוטנציאליות עם משתמשים אחרים במערכת. תהליך זה עשוי לכלול שימוש באלגוריתמים ובמודלי בינה מלאכותית (AI) לסיוע לשדכנים.`}</li>
                  <li>{`הצגת פרופילים (חלקיים או מלאים, בהתאם לשלב בתהליך) של מועמדים פוטנציאליים בפניך, ולהיפך.`}</li>
                  <li>תיווך ותיאום יצירת קשר ופגישות בין משתמשים, בהתאם להתקדמות תהליך השידוך.</li>
                </ul>
              </li>
              <li><strong>{`ניהול חשבונך ותפעול שוטף של המערכת:`}</strong> {`יצירת חשבונך, אימות פרטיך (דוא'ל, טלפון), מתן תמיכה טכנית ואחרת, אבטחת המערכת, טיפול בתקלות.`}</li>
              <li><strong>שיפור והתאמה אישית של השירותים שלנו:</strong>
                <ul>
                  <li>{`ניתוח השימוש במערכת ובשירותים (לעיתים תוך שימוש במידע שעבר אנונימיזציה או אגרגציה, כך שאינו מזהה אותך אישית) לצורך הבנת צרכי המשתמשים, שיפור חווית המשתמש, ייעול תהליכי השידוך, ופיתוח כלים ותכונות חדשות.`}</li>
                  <li>התאמה אישית של התוכן וההצעות המוצגות לך (במידת האפשר).</li>
                </ul>
              </li>
              <li><strong>יצירת קשר איתך:</strong>
                <ul>
                  <li>{`שליחת הודעות מערכת חיוניות (למשל, אישורי הרשמה, הודעות על אימותים, עדכונים קריטיים).`}</li>
                  <li>{`שליחת עדכונים הנוגעים לתהליך השידוך שלך (הצעות חדשות, תגובות להצעות, פניות משדכנים, בקשות למשוב).`}</li>
                  <li>שליחת הודעות ממשתמשים אחרים, בתיווך המערכת או השדכן, במסגרת תהליך שידוך מאושר.</li>
                  <li>{`בכפוף להסכמתך הנפרדת (שתינתן, למשל, על ידי סימון תיבת בחירה בעת ההרשמה או בהגדרות החשבון), שליחת דיוורים שיווקיים, ניוזלטרים, או עדכונים כלליים מ-Matchpoint על אירועים, תכנים חדשים או שירותים נוספים. תוכל לבטל הסכמה זו בכל עת באמצעות קישור "הסרה מרשימה" המופיע בהודעות אלו או בפנייה אלינו.`}</li>
                </ul>
              </li>
              <li><strong>{`אכיפת תנאי השימוש שלנו`}</strong> והגנה על זכויותינו המשפטיות, זכויות המשתמשים שלנו, וזכויות צדדים שלישיים.</li>
              <li><strong>{`מילוי אחר הוראות כל דין,`}</strong> תקנה, צו שיפוטי, או דרישה של רשות מוסמכת.</li>
              <li><strong>שימוש בסיפורי הצלחה (בכפוף להסכמה נפרדת):</strong> {`במקרה של אירוסין או חתונה כתוצאה מהיכרות דרך המערכת, אנו עשויים לפנות אליך בבקשה לקבל את הסכמתך הנפרדת והמפורשת לשימוש בשמותיכם (או בפרטים מזהים אחרים שתאשרו) ו/או בסיפורכם לצורך פרסום ברשימת ההצלחות באתר, בחומרי שיווק, או בדיווחי יחסי ציבור של Matchpoint. לא ייעשה כל שימוש כזה ללא הסכמתכם המפורשת והאקטיבית.`}</li>
            </ul>

            {/* ... שאר סעיפי מדיניות הפרטיות (4-11) יועתקו לכאן מהטיוטה המלאה הקודמת שהכנו ... */}
            {/* חשוב להעתיק את התוכן המלא והמעודכן של סעיפים 4 עד 11 לכאן */}
             <h2 id='sharing-info'>4. שיתוף מידע עם צדדים שלישיים</h2>
            <p>
              {`אנו לוקחים את פרטיותך ברצינות ולא נמכור, נשכיר או נחליף את המידע האישי שלך עם צדדים שלישיים למטרות שיווקיות שלהם ללא הסכמתך המפורשת. אנו עשויים לשתף את המידע האישי שלך עם הגורמים הבאים, ולמטרות המפורטות בלבד:`}
            </p>
            <ul>
              <li><strong>משתמשים אחרים במערכת (מועמדים פוטנציאליים):</strong>
                כאשר שדכן של Matchpoint מזהה התאמה פוטנציאלית בינך לבין משתמש אחר, חלק מפרטי הפרופיל שלך ישותפו עם אותו משתמש. היקף המידע המשותף ישתנה בהתאם לשלב בתהליך השידוך:
                <ul>
                  <li><strong>בשלב הצגת הצעה ראשונית:</strong> {`ישותף מידע כגון שם פרטי, גיל (או טווח גילאים), עיר מגורים כללית, תיאור כללי מתומצת (שנערך לעיתים על ידי השדכן על בסיס המידע שלך), תחומי עניין עיקריים, רמה דתית, תמונה ראשית (אם הסכמת לשיתופה בשלב זה), ותמצית מידע רלוונטי אחר שהשדכן, בשיקול דעתו המקצועית, ימצא לנכון וחיוני לבחינת ההתאמה הראשונית.`}</li>
                  <li><strong>לאחר הסכמה הדדית ראשונית:</strong> {`מידע נוסף ומפורט יותר מהפרופיל (לרבות, אך לא רק, שם משפחה, פרטים נוספים על עיסוק והשכלה, תמונות נוספות, תיאורים מורחבים יותר, ותשובות נבחרות משאלונים כפי שהשדכן ימצא לנכון) עשוי להיות משותף, בהדרגה ובהתאם להתקדמות הקשר ובשיקול דעת השדכן ו/או בהסכמתך.`}</li>
                  <li><strong>פרטי קשר ישירים</strong> {`(כגון מספר טלפון או כתובת דוא'ל) ישותפו רק לאחר הסכמה הדדית מפורשת של שני הצדדים ליצירת קשר, ובהתאם לנוהלי המערכת (למשל, לאחר שהשדכן אישר את המעבר לשלב זה).`}</li>
                </ul>
                אנו מדגישים כי לא ישותף מידע מעבר למינימום הדרוש לצורך בחינת ההתאמה בכל שלב, והתהליך מנוהל תוך רגישות מרבית לפרטיותך.
              </li>
              <li><strong>שדכנים בתוך Matchpoint (צוות החברה):</strong>
                {`המידע האישי שלך, כולל כל הפרטים שמסרת והתשובות לשאלונים, יהיה נגיש לשדכנים המורשים הפועלים במסגרת Matchpoint. גישה זו חיונית לצורך ביצוע עבודתם המקצועית באיתור, ניתוח והצעת התאמות עבורך ועבור משתמשים אחרים, וכן למתן ליווי ותמיכה בתהליך השידוך. כל השדכנים של Matchpoint מחויבים לסודיות ולאבטחת המידע בהתאם למדיניות זו ולהנחיות החברה.`}
              </li>
              <li>
                <strong>ספקי שירותים (צדדים שלישיים המעבדים מידע עבורנו):</strong>
                {`אנו נעזרים בספקי שירותים חיצוניים (מעבדי מידע) המסייעים לנו בתפעול, פיתוח, תחזוקה ואבטחה של המערכת. ספקים אלו עשויים לקבל גישה למידע אישי שלך, אך ורק ככל הנדרש לצורך מתן השירותים עבורנו. ספקים אלו כוללים, בין היתר:`}
                <ul>
                  <li><strong>ספקי אחסון ענן ושירותי בסיס נתונים:</strong> {`כדוגמת Neon Technologies Inc. (שרתיהם עשויים להיות ממוקמים מחוץ לישראל, כפי שמפורט בסעיף 8 להלן), ופלטפורמת Heroku (לצורך אירוח האפליקציה, שרתיהם גם כן עשויים להיות מחוץ לישראל).`}</li>
                  <li>{`ספקי שירותי דיוור אלקטרוני (למשל, לשליחת הודעות מערכת, עדכונים, או דיוורים שיווקיים בהסכמתך).`}</li>
                  <li>{`ספקי שירותי אימות (למשל, לאימות מספר טלפון באמצעות SMS או WhatsApp).`}</li>
                  <li>ספקי שירותי אנליטיקה וניטור (לרוב על בסיס מידע אגרגטיבי ואנונימי).</li>
                </ul>
                אנו בוחרים את ספקי השירותים שלנו בקפידה, ודורשים מהם, באמצעות הסכמים חוזיים, לשמור על סודיות המידע, להשתמש בו אך ורק למטרה שלשמה נמסר להם, ולנקוט באמצעי אבטחה טכניים וארגוניים נאותים להגנה על המידע, בהתאם לדרישות הדין ומדיניות זו.
              </li>
              <li><strong>רשויות אכיפת חוק, גופים ממשלתיים וגורמים משפטיים:</strong>
                {`נשתף מידע אישי שלך אם נידרש לכך על פי כל דין, תקנה, צו שיפוטי, או דרישה מחייבת של רשות מוסמכת. כמו כן, אנו עשויים לחשוף מידע אם נאמין בתום לב כי הדבר נחוץ כדי להגן על זכויותינו המשפטיות, על בטיחותנו, על בטיחות המשתמשים שלנו או הציבור, לחקור או למנוע הונאה, או במסגרת הליכים משפטיים.`}
              </li>
              <li><strong>במקרה של שינוי מבני בעסק:</strong>
                {`במקרה של מיזוג, רכישה, ארגון מחדש, פשיטת רגל, או מכירת כל או חלק מנכסי ${companyNameLegal}, המידע האישי שלך, לרבות מאגר המידע, עשוי להיות מועבר לישות הרוכשת או לישות החדשה שתקום. במקרה כזה, אנו נודיע לך (ככל שהדין מחייב זאת) והישות הרוכשת תהיה מחויבת לכבד את התחייבויות הפרטיות המפורטות במדיניות זו, או שתעדכן אותך לגבי מדיניות פרטיות חדשה.`}
              </li>
            </ul>

            <h2 id='security'>5. אבטחת מידע</h2>
            <p>
              {`אנו מייחסים חשיבות עליונה לאבטחת המידע האישי שלך. אנו נוקטים באמצעי אבטחה טכנולוגיים, פיזיים (במקרה של ספקי ענן, אנו מסתמכים על אמצעי האבטחה הפיזיים שלהם) וארגוניים סבירים ומקובלים בתעשייה כדי להגן על המידע האישי שלך מפני גישה בלתי מורשית, שימוש לרעה, שינוי, חשיפה, אובדן או השמדה.`}
            </p>
            <p>
              אמצעים אלו כוללים, בין היתר:
            </p>
            <ul>
              <li>הצפנת סיסמאות בצורה חזקה (Hashing & Salting).</li>
              <li>{`שימוש בפרוטוקולי תקשורת מאובטחים (SSL/TLS) להצפנת תעבורת המידע בין הדפדפן שלך לשרתי המערכת (למשל, דרך Heroku).`}</li>
              <li>בקרות גישה מבוססות תפקידים (Role-Based Access Control) והרשאות מינימליות, המבטיחות שרק מורשי גישה רלוונטיים יוכלו לגשת למידע הנדרש להם.</li>
              <li>{`חומות אש (Firewalls) והגנות רשת נוספות, המסופקות לרוב על ידי ספקי התשתית שלנו (כגון Heroku ו-Neon).`}</li>
              <li>נהלי פיתוח מאובטח ועדכוני תוכנה ואבטחה שוטפים.</li>
              <li>{`מנגנוני גיבוי ושחזור נתונים, לרבות שימוש ביכולות גיבוי של ספקי הענן (כגון Point-In-Time Recovery ב-Neon) וגיבויים נוספים ככל שיידרש.`}</li>
              <li>מנגנוני גישה מאובטחים למפתחות הצפנה ופרטי גישה למערכות.</li>
              <li>הטמעה מתוכננת של מנגנוני ניטור ותיעוד גישה (לוגים) בהתאם לתקנות.</li>
            </ul>
            <p>
              <strong>{`עם זאת, חשוב לזכור כי אף מערכת אינה מאובטחת במאת האחוזים, ואיננו יכולים להבטיח באופן מוחלט את אבטחת המידע שלך.`}</strong> {`העברת מידע דרך האינטרנט כרוכה בסיכונים אינהרנטיים. הינך אחראי/ת באופן אישי לשמירת סודיות פרטי הגישה לחשבונך (שם משתמש וסיסמה), ולא לשתפם עם אחרים. אם נודע לך על פגיעה אפשרית באבטחת חשבונך, עליך להודיע לנו על כך מיד.`}
            </p>

            <h2 id='retention'>6. שמירת מידע (Data Retention)</h2>
            <p>
              אנו נשמור את המידע האישי שלך למשך הזמן הדרוש כדי לספק לך את שירותינו, כל עוד חשבונך פעיל, או כל עוד הדבר נחוץ למטרות המפורטות במדיניות זו, ובהתאם להוראות הדין.
              הקריטריונים לקביעת תקופות השמירה כוללים:
            </p>
            <ul>
              <li>{`משך הזמן בו יש לנו קשר פעיל איתך ואנו מספקים לך את השירותים (למשל, כל עוד יש לך חשבון אצלנו או שאתה נמצא בתהליך שידוך פעיל).`}</li>
              <li>{`קיום חובה חוקית לשמור את המידע (למשל, תיעוד חשבונאי, דרישות משפטיות מסוימות, שמירת לוגים כנדרש בתקנות אבטחת מידע).`}</li>
              <li>{`האם שמירת המידע נחוצה לצורך התגוננות מפני תביעות משפטיות פוטנציאליות (למשל, שמירת תיעוד הסכמות או התקשרויות).`}</li>
              <li>{`צרכים תפעוליים ולגיטימיים של העסק, כגון שמירת מידע לצורכי ניתוח ושיפור השירות (לרוב בצורה אנונימית או מצטברת).`}</li>
            </ul>
            <p>
              {`לאחר שתבקש למחוק את חשבונך (ראה סעיף 7), או כאשר המידע אינו נחוץ עוד למטרות שלשמן נאסף, אנו נפעל למחוק את המידע המזהה אותך אישית, או להפוך אותו לאנונימי, בתוך פרק זמן סביר ובהתאם למדיניות המחיקה שלנו ולהוראות הדין. שים לב כי גם לאחר מחיקה, עותקי גיבוי של המידע עשויים להישמר במערכות הגיבוי שלנו לפרק זמן מוגבל, עד למחיקתם במסגרת מחזור הגיבויים הרגיל, והם לא ישמשו לפעילות שוטפת.`}
            </p>

            <h2 id='your-rights'>{`7. זכויותיך בנוגע למידע האישי שלך ("זכות עיון, תיקון ומחיקה")`}</h2>
            <p>
              {`על פי חוק הגנת הפרטיות, התשמ"א-1981, ובהתאם להוראותיו, הינך זכאי/ת למספר זכויות בנוגע למידע האישי שלך המוחזק אצלנו במאגר המידע. מימוש זכויות אלו כפוף למגבלות מסוימות הקבועות בחוק ובתקנות:`}
            </p>
            <ul>
              <li><strong>הזכות לעיין במידע (זכות הגישה):</strong> {`הינך זכאי/ת לבקש לעיין במידע האישי שאנו מחזיקים אודותיך. המערכת מאפשרת לך לצפות ולערוך חלק גדול מהמידע שלך ישירות דרך הפרופיל האישי שלך לאחר התחברות לחשבונך. לבקשת עיון במידע נוסף שאינו זמין דרך הפרופיל, אנא פנה/י אלינו.`}</li>
              <li><strong>הזכות לבקש תיקון מידע:</strong> {`אם המידע שאנו מחזיקים אודותיך אינו נכון, שלם, ברור או מעודכן, הינך זכאי/ת לבקש את תיקונו או השלמתו. כאמור, רוב פרטי הפרופיל שלך ניתנים לעריכה ועדכון על ידך באופן ישיר.`}</li>
              <li><strong>הזכות לבקש מחיקת מידע ({`"הזכות להישכח"`}):</strong> {`הינך זכאי/ת לבקש את מחיקת המידע האישי שלך ממאגר המידע שלנו. המערכת תאפשר לך לבקש מחיקת חשבון (דרך הגדרות החשבון או בפנייה אלינו). בקשה למחיקה תטופל בהתאם להוראות החוק. שים/י לב כי מחיקת מידע מסוים עלולה למנוע מאיתנו להמשיך ולספק לך את השירות, כיוון שמידע זה חיוני לתפעולו. כמו כן, ייתכן שנצטרך לשמור מידע מסוים כנדרש או מותר על פי דין, גם לאחר בקשת מחיקה (כמפורט בסעיף 6).`}</li>
              <li><strong>הזכות להגביל עיבוד או להתנגד לו:</strong> {`במקרים מסוימים הקבועים בחוק, הינך רשאי/ת לבקש להגביל את עיבוד המידע שלך או להתנגד לעיבוד מסוים (לדוגמה, הזכות להתנגד לקבלת דיוורים שיווקיים, אשר ניתנת למימוש בקלות דרך קישורי "הסר מרשימה" בהודעות אלו או בפנייה אלינו).`}</li>
            </ul>
            <p>
              <strong>מימוש זכויות עבור משתמשים שהוזנו ידנית על ידי שדכן:</strong> {`אם פרטיך הוזנו למערכת על ידי שדכן של Matchpoint, וברצונך לממש את זכויותיך (עיון, תיקון, מחיקה), אנא פנה/י אלינו באמצעות פרטי הקשר המופיעים מטה. אנו נפעל לאמת את זהותך ולסייע לך במימוש זכויותיך בהתאם לדין. אנו מעודדים משתמשים כאלה ליצור חשבון אישי במערכת, אשר יאפשר להם גישה ישירה ונוחה יותר לניהול המידע שלהם.`}
            </p>
            <p>
              {`למימוש זכויותיך, מעבר לאפשרויות הקיימות ישירות במערכת, או לכל שאלה בנושא, אנא פנה/י אלינו באמצעות פרטי הקשר המופיעים בסעיף 11 להלן. אנו נשיב לפנייתך בתוך זמן סביר (לרוב עד 30 יום, אלא אם נקבע אחרת בחוק) ובהתאם להוראות הדין. ייתכן שנצטרך לבקש ממך פרטים נוספים לצורך אימות זהותך לפני טיפול בבקשתך.`}
            </p>

            <h2 id='cross-border'>8. העברת מידע מחוץ לגבולות ישראל</h2>
            <p>
              {`הינך מאשר/ת ומסכים/ה במפורש כי המידע האישי שלך, לרבות מידע רגיש, עשוי להיות מועבר, מעובד ומאוחסן בשרתים הממוקמים מחוץ לגבולות מדינת ישראל, ובכלל זה במדינות בהן דיני הגנת הפרטיות עשויים להעניק רמת הגנה שונה מזו הנהוגה בישראל.`}
              {`לדוגמה, אנו משתמשים בשירותי אחסון בסיס נתונים של חברת Neon Technologies Inc., וכן בשירותי אירוח אפליקציה של Heroku (Salesforce), אשר מרכזי הנתונים שלהם ממוקמים ברחבי העולם, כולל בארצות הברית ובאירופה.`}
              {`אנו ננקוט בצעדים סבירים הנדרשים על פי דין כדי להבטיח שכל העברת מידע כזו תתבצע תוך שמירה על רמה נאותה של הגנה על המידע האישי שלך, למשל, על ידי התקשרות עם ספקים המחויבים לסטנדרטים בינלאומיים של אבטחת מידע ופרטיות (כגון עמידה בתנאי ה-GDPR, סעיפים חוזיים סטנדרטיים, או הסמכות רלוונטיות).`}
              <strong>{`עצם הסכמתך למדיניות זו מהווה הסכמה מפורשת להעברת המידע שלך אל מחוץ לגבולות ישראל, כמפורט לעיל.`}</strong>
            </p>

            <h2 id='minors'>9. קטינים</h2>
            <p>
              {`השירות שלנו מיועד ומותר לשימוש אך ורק לבגירים מעל גיל 18 (או גיל הבגרות החוקי הרלוונטי בתחום שיפוטך, אם הוא גבוה יותר). איננו אוספים ביודעין מידע אישי מקטינים מתחת לגיל 18. אם ייוודע לנו כי אספנו מידע אישי מקטין ללא הסכמת הורה או אפוטרופוס (ככל שנדרש על פי דין), אנו נפעל למחוק מידע זה בהקדם האפשרי. אם הנך הורה או אפוטרופוס ונודע לך שילדך מסר לנו מידע אישי, אנא פנה/י אלינו מיד.`}
            </p>

            <h2 id='changes'>10. שינויים במדיניות הפרטיות</h2>
            <p>
              {`אנו שומרים לעצמנו את הזכות לעדכן ולשנות מדיניות פרטיות זו מעת לעת, לפי שיקול דעתנו הבלעדי, כדי לשקף שינויים בשירותינו, בנהלינו, או בדרישות החוק והרגולציה.`}
              {`במקרה של שינויים מהותיים במדיניות, אנו נודיע לך על כך מראש ובאופן בולט, על ידי פרסום הודעה במערכת Matchpoint, ו/או על ידי שליחת הודעת דוא'ל לכתובת הדוא'ל המשויכת לחשבונך. תאריך "העדכון האחרון" בראש המדיניות ישקף את מועד כניסת השינויים לתוקף.`}
              {`המשך שימושך במערכת לאחר פרסום השינויים ועדכונם ייחשב כהסכמה מצדך למדיניות המעודכנת. אם אינך מסכים/ה לשינויים, עליך להפסיק את השימוש במערכת. אנו ממליצים לך לעיין במדיניות זו באופן תקופתי כדי להישאר מעודכנ/ת.`}
            </p>

            <h2 id='contact'>11. יצירת קשר</h2>
            <p>
              {`בכל שאלה, הבהרה, בקשה למימוש זכויותיך, או אם לדעתך פרטיותך נפגעה כתוצאה מפעילותינו, אנא אל תהסס/י לפנות אלינו. אנו נעשה כמיטב יכולתנו לטפל בפנייתך בהקדם:`}
              <br />
              <strong>שם החברה:</strong> {companyNameJsx} (ח.פ. {companyNumber})
              <br />
              <strong>{`דוא'ל לממונה על הגנת הפרטיות / תמיכת פרטיות:`}</strong> <a href={`mailto:${companyEmail}`} className='text-cyan-600 hover:text-cyan-700'>{companyEmail}</a>
              <br />
              <strong>כתובת למשלוח דואר:</strong> {companyRegisteredAddress}
            </p>
            <p className='mt-6'>
              אנו ממליצים לך לשמור עותק של מדיניות פרטיות זו לתיעודך.
            </p>
          </article>
        </div>
      </div>
    </>
  );
};

export default PrivacyPolicyPage;
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\legal\terms-of-service
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\legal\terms-of-service\page.tsx
--------------------------------------------------------------------------------
Content:
// src/app/legal/terms-of-service/page.tsx
import React from 'react';
import Head from 'next/head';

const TermsOfServicePage = () => {
  const companyNameLegal = `ג'ואיש מאצ'פוינט בע"מ`;
  const companyNameJsx = <>{`ג'ואיש מאצ'פוינט בע"מ`}</>; // נשאר כפי שהיה אצלך
  const companyNumber = '517172631';
  const pageTitle = `תנאי שימוש | ${companyNameLegal}`;
  const pageDescription = `תנאי השימוש של מערכת השידוכים Matchpoint. קרא בעיון לפני השימוש במערכת.`;
  const lastUpdatedDate = '9 ביוני 2025'; // עודכן תאריך
  const supportEmail = 'jewish.matchpoint@gmail.com';
  const siteUrl = 'https://www.jewishmatchpoint.com'; // יש לוודא שזה ה-URL הסופי
  const privacyPolicyUrl = '/legal/privacy-policy'; // נתיב יחסי למדיניות הפרטיות
  const jurisdictionDistrict = 'מרכז'; // עודכן מחוז שיפוט
  const initialFreeSuggestionsCount = '3-5'; // יש לוודא שזה המספר הנכון
  const paidSuggestionsCount = '3-5'; // יש לוודא שזה המספר הנכון

  return (
    <>
      <Head>
        <title>{pageTitle}</title>
        <meta name='description' content={pageDescription} />
        <meta property='og:title' content={pageTitle} />
        <meta property='og:description' content={pageDescription} />
        <meta property='og:url' content={`${siteUrl}/legal/terms-of-service`} />
        <meta name='twitter:card' content='summary_large_image' />
      </Head>
      <div className='bg-gradient-to-br from-cyan-50 via-white to-pink-50 min-h-screen py-12 px-4 sm:px-6 lg:px-8'>
        <div className='container mx-auto max-w-4xl bg-white shadow-xl rounded-lg p-8 sm:p-12'>
          <header className='mb-10 text-center border-b pb-6 border-gray-200'>
            <h1 className='text-4xl sm:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-pink-500'>
              תנאי שימוש
            </h1>
            <p className='mt-3 text-lg text-gray-600'>
              של מערכת השידוכים Matchpoint (מופעלת על ידי {companyNameJsx})
            </p>
            <p className='mt-2 text-sm text-gray-500'>
              עדכון אחרון: {lastUpdatedDate}
            </p>
          </header>

          <article className='prose prose-lg max-w-none text-gray-700 leading-relaxed text-right'>
            <h2 id='intro'>1. מבוא והסכמה לתנאים</h2>
            <p>
              ברוכים הבאים למערכת השידוכים Matchpoint (להלן: <strong>{`"המערכת"`}</strong>, <strong>{`"השירות"`}</strong> או <strong>{`"Matchpoint"`}</strong>), המופעלת על ידי {companyNameJsx} (ח.פ. {companyNumber}) (להלן: <strong>{`"החברה"`}</strong>, <strong>{`"אנו"`}</strong>, <strong>{`"שלנו"`}</strong>).
              תנאי שימוש אלו (להלן: <strong>{`"תנאי השימוש"`}</strong> או <strong>{`"ההסכם"`}</strong>) מסדירים את הגישה והשימוש שלך במערכת, ובכלל זה בכל התכנים, התכונות, השירותים והפונקציונליות המוצעים בה.
              <strong>{`אנא קרא/י תנאי שימוש אלו בעיון רב לפני השימוש במערכת.`}</strong>
              {`עצם הרשמתך למערכת, הגישה אליה או כל שימוש אחר בה, מהווה הסכמה מפורשת, חופשית ומיודעת מצדך לכל התנאים המפורטים בהסכם זה, וכן ל`}<a href={privacyPolicyUrl} target='_blank' rel='noopener noreferrer' className='text-cyan-600 hover:text-cyan-700'>מדיניות הפרטיות שלנו</a> (להלן: <strong>{`"מדיניות הפרטיות"`}</strong>), המהווה חלק בלתי נפרד מהסכם זה.
              <strong>{`אם אינך מסכים/ה לתנאי כלשהו מתנאי שימוש אלו או ממדיניות הפרטיות, במלואם או בחלקם, אינך רשאי/ת לעשות כל שימוש במערכת ועליך להימנע מכך.`}</strong>
            </p>
            <p>
              אנו שומרים לעצמנו את הזכות לשנות או לעדכן תנאי שימוש אלו מעת לעת, לפי שיקול דעתנו הבלעדי, כמפורט בסעיף 13 להלן.
            </p>

            <h2 id='definitions'>2. הגדרות</h2>
            <p>בהסכם זה, למונחים הבאים תהיה המשמעות המפורטת לצדם:</p>
            <ul>
              <li><strong>{`"המשתמש/ת"`}</strong> או <strong>{`"אתה"`}</strong>: כל אדם היוצר חשבון, ניגש או עושה שימוש כלשהו במערכת, לרבות מועמדים לשידוך ושדכנים מורשים.</li>
              <li><strong>{`"מועמד/ת"`}</strong>: משתמש הרשום למערכת במטרה למצוא התאמה זוגית.</li>
              <li><strong>{`"שדכן/ית"`}</strong>: אדם המורשה על ידי החברה להשתמש במערכת לצורך ביצוע שידוכים, ניהול מאגר מועמדים, והפעלת כלי המערכת.</li>
              <li><strong>{`"תוכן משתמש"`}</strong>: כל מידע, טקסט, תמונה, וידאו, או חומר אחר שאתה מעלה, מוסר, או מפרסם במערכת או דרכה.</li>
              <li><strong>{`"תוכן המערכת"`}</strong>: כל התכנים והחומרים במערכת שאינם תוכן משתמש, לרבות עיצוב, קוד, טקסטים, גרפיקה, לוגו, ממשקים, וכלי הבינה המלאכותית.</li>
            </ul>

            <h2 id='service-description'>3. תיאור השירות</h2>
            <p>
              3.1. מערכת Matchpoint הינה פלטפורמה טכנולוגית מתקדמת לשידוכים, המיועדת ליהודים רווקים ברחבי העולם המחפשים קשר זוגי משמעותי וארוך טווח.
            </p>
            <p>
              3.2. המערכת מאפשרת למועמדים ליצור פרופיל אישי מפורט, לענות על שאלונים מעמיקים, ולקבל הצעות שידוך מותאמות אישית משדכני Matchpoint ו/או באמצעות אלגוריתמים וטכנולוגיית AI.
            </p>
            <p>
              3.3. המערכת כוללת כלים לניהול מאגר מועמדים, סינון, מיון, ביצוע התאמות, שליחת הצעות ותקשורת מאובטחת (בתיווך או ישירה, בהתאם לשלב).
            </p>
            <p>
              3.4. החברה שומרת לעצמה את הזכות לשנות, להשעות, או להפסיק את מתן השירות, כולו או חלקו, באופן זמני או קבוע, לפי שיקול דעתה הבלעדי, עם או ללא הודעה מוקדמת, ולא תהיה לך כל טענה, תביעה או דרישה כלפי החברה בקשר לכך.
            </p>

            <h2 id='eligibility'>4. כשירות לשימוש</h2>
            <p>
              4.1. השימוש במערכת כ<strong>מועמד/ת</strong> מותר אך ורק לבגירים (מעל גיל 18, או גיל הבגרות החוקי הרלוונטי בתחום שיפוטך, אם הוא גבוה יותר), הפנויים מבחינה חוקית ואישית לקשר זוגי מחייב, ומחפשים קשר למטרת נישואין.
            </p>
            <p>
              4.2. {`בהרשמתך ובשימושך במערכת, הינך מצהיר/ה ומאשר/ת כי את/ה עומד/ת בתנאי כשירות אלו, וכי כל המידע שמסרת אודותיך הינו נכון, מדויק ומלא.`}
            </p>
            <p>
              4.3. החברה רשאית, לפי שיקול דעתה, לסרב להעניק שירות או לחסום גישה למערכת לכל משתמש שאינו עומד בתנאי הכשירות או שמפר תנאי הסכם זה.
            </p>

            <h2 id='registration'>5. הרשמה, חשבון משתמש ומידע אישי</h2>
            <p>
              5.1. <strong>יצירת חשבון:</strong> {`לצורך שימוש ברוב שירותי המערכת, תידרש/י ליצור חשבון אישי. בעת יצירת החשבון ו/או מילוי הפרופיל והשאלונים, הינך מתחייב/ת למסור מידע נכון, מדויק, מלא ועדכני אודותיך, כפי שמתבקש בטפסי ההרשמה והפרופיל.`}
            </p>
            <p>
              5.2. <strong>מידע כוזב:</strong> {`מסירת מידע כוזב, מטעה, חלקי או לא עדכני מהווה הפרה של תנאי שימוש אלו, ועלולה לפגוע ביכולתנו לספק לך (ולאחרים) שירות מיטבי, לפגוע באמינות המערכת, ואף לחשוף אותך לאחריות משפטית. החברה שומרת לעצמה את הזכות לנקוט בכל האמצעים העומדים לרשותה, לרבות חסימת חשבונך או נקיטת הליכים משפטיים, במקרה של מסירת מידע כוזב.`}
            </p>
            <p>
              5.3. <strong>אבטחת חשבון:</strong> {`האחריות המלאה לשמירת סודיות פרטי הגישה לחשבונך (כגון שם משתמש וסיסמה) חלה עליך בלבד. אין למסור פרטים אלו לאף אדם אחר. סיסמאות נשמרות במערכת בצורה מוצפנת.`}
            </p>
            <p>
              5.4. <strong>אחריות לפעולות בחשבון:</strong> {`הינך אחראי/ת באופן מלא לכל הפעולות המתבצעות דרך חשבונך, בין אם נעשו בהרשאתך ובין אם לאו. עליך להודיע לנו באופן מיידי על כל שימוש לא מורשה בחשבונך או על כל פרצת אבטחה אחרת.`}
            </p>
            <p>
              5.5. <strong>הזנת מידע על ידי שדכן:</strong> {`במקרים בהם פרטיך הוזנו למערכת על ידי שדכן של Matchpoint ולא בהרשמה ישירה שלך (למשל, על בסיס מידע שמסרת לשדכן בעבר, או מידע שפורסם על ידך במקורות אחרים בהסכמה), אנו נפעל ליידע אותך על כך, ככל שהדבר אפשרי ובאמצעים סבירים. המשך השימוש שלך במערכת (לרבות אימות חשבונך, השלמת פרטים, או מתן משוב) לאחר קבלת הודעה כאמור, ו/או אישור מפורש שלך לשדכן לפעול בשמך, מהווה הסכמה מלאה לתנאי שימוש אלו ולמדיניות הפרטיות.`}
            </p>
            <p>
              5.6. <strong>פרטיות:</strong> {`איסוף המידע האישי שלך והשימוש בו כפופים ל`}<a href={privacyPolicyUrl} target='_blank' rel='noopener noreferrer' className='text-cyan-600 hover:text-cyan-700'>מדיניות הפרטיות שלנו</a>.
            </p>
            <p>
              5.7. <strong>שימוש בשמות וסיפורי הצלחה בשיווק (בכפוף להסכמה נפרדת):</strong> {`הינך מבין ומסכים כי במקרה של אירוסין או חתונה כתוצאה מהיכרות דרך המערכת, החברה עשויה לפנות אליך ו/או לבן/בת זוגך בבקשה לקבל את הסכמתכם הנפרדת, המפורשת והאקטיבית, לשימוש בשמותיכם, בתמונתכם (אם תסופק על ידכם למטרה זו) ו/או בסיפור ההצלחה שלכם, לצורך פרסום ברשימת ההצלחות באתר, בחומרי שיווק, בדפי רשתות חברתיות של החברה, או בדיווחי יחסי ציבור של Matchpoint. מובהר כי לא ייעשה כל שימוש כאמור ללא קבלת הסכמתכם המפורשת והנפרדת לכך, ולא תהיה לך כל טענה אם תסרב/י למתן הסכמה כזו.`}
            </p>

            <h2 id='service-fees'>6. עלויות ודמי שירות (המודל העסקי)</h2>
            <p>
              6.1. <strong>הרשמה ראשונית:</strong> ההרשמה הראשונית למערכת ומילוי הפרופיל והשאלונים הינם ללא עלות (חינם).
            </p>
            <p>
              6.2. <strong>דמי הצלחה:</strong> {`במקרה של הצלחת שידוך דרך המערכת, אשר יוביל לחתונה בין שני משתמשים שהכירו באמצעות Matchpoint, כל אחד מבני הזוג (או מי מטעמם) יהיה מחויב בתשלום דמי הצלחה בסך 4,000 ש"ח (ארבעת אלפים שקלים חדשים), כולל מע"מ כחוק (להלן: `}<strong>{`"דמי ההצלחה"`}</strong>).
            </p>
            <ul>
              <li>{`"הצלחת שידוך" תיחשב כהיכרות שנוצרה ישירות דרך הצעה או תיווך של המערכת או שדכן של Matchpoint, ואשר הובילה לקשר זוגי שהבשיל לנישואין.`}</li>
              <li>תשלום דמי ההצלחה יבוצע בתוך 30 (שלושים) ימים ממועד החתונה.</li>
              <li>אי תשלום דמי ההצלחה במועד יהווה הפרה יסודית של הסכם זה, והחברה תהיה רשאית לנקוט בכל האמצעים החוקיים העומדים לרשותה לגביית החוב, לרבות ריבית פיגורים והוצאות גבייה.</li>
            </ul>
            <p>
              6.3. <strong>שירותים נוספים בתשלום (אופציונלי):</strong>
            </p>
            <ul>
              <li><strong>חבילת הצעות נוספות:</strong> {`ככלל, המערכת תספק מספר ראשוני של ${initialFreeSuggestionsCount} הצעות שידוך למשתמשים פעילים ללא עלות נוספת (מעבר לדמי ההצלחה הפוטנציאליים). אם משתמש יהיה מעוניין לקבל הצעות נוספות מעבר למכסה זו, או ליווי מורחב, הוא עשוי להתבקש לשלם תשלום חד-פעמי בסך 350 ש"ח (שלוש מאות וחמישים שקלים חדשים), כולל מע"מ (להלן: `}<strong>{`"דמי טיפול בהצעות נוספות"`}</strong>). {`התשלום יקנה זכאות למספר נוסף של ${paidSuggestionsCount} הצעות, או לליווי לתקופה מוגדרת, כפי שיוגדר ויוסכם מראש עם המשתמש. דמי טיפול בהצעות נוספות, לאחר ששולמו והשירות הרלוונטי סופק (קרי, ניתנה האפשרות לקבלת הצעות נוספות או החל הליווי המורחב), אינם ניתנים להחזר.`}</li>
              <li>החברה שומרת לעצמה את הזכות להציע בעתיד שירותי פרימיום או תכונות נוספות בתשלום, ולהגדיר את תנאיהם ומחיריהם. כל תשלום כזה יהיה כפוף להסכמתך המפורשת.</li>
            </ul>
            <p>
              6.4. <strong>אמצעי תשלום וחשבוניות:</strong> פרטים לגבי אמצעי תשלום מקובלים והנפקת חשבוניות/קבלות יימסרו במועד הרלוונטי. כל התשלומים יבוצעו בשקלים חדשים, אלא אם צוין אחרת.
            </p>
            <p>
              6.5. <strong>שינויים בתמחור:</strong> החברה רשאית לשנות את מבנה העלויות ודמי השירות מעת לעת, לפי שיקול דעתה. שינויים כאלו לא יחולו רטרואקטיבית על שירותים שכבר נצרכו או על התחייבויות קודמות, אלא אם צוין אחרת במפורש ובהסכמתך.
            </p>

            {/* ... שאר סעיפי תנאי השימוש (7-16) יועתקו לכאן מהטיוטה המלאה הקודמת שהכנו, עם התאמות קלות אם נדרש לשם החברה ופרטי הקשר ... */}
            {/* חשוב להעתיק את התוכן המלא והמעודכן של סעיפים 7 עד 16 לכאן */}
            <h2 id='user-conduct'>7. התנהגות משתמשים ואחריות לתוכן</h2>
            <p>
              7.1. {`הינך מתחייב/ת להשתמש במערכת בתום לב, למטרות שידוך לגיטימיות בלבד, בהתאם לתנאי הסכם זה, להוראות כל דין, ולכבד את כללי ההתנהגות המקובלים.`}
            </p>
            <p>
              7.2. <strong>איסורים והגבלות:</strong> במסגרת השימוש במערכת, נאסר עליך באופן מוחלט:
            </p>
            <ul>
                <li>{`למסור מידע כוזב, שקרי, מטעה או לא מדויק אודותיך, אודות כוונותיך או אודות העדפותיך.`}</li>
                <li>{`להתחזות לאדם או גוף אחר, או ליצור מצג שווא של קשר לאדם או גוף אחר.`}</li>
                <li>{`להעלות, לשלוח, לפרסם או להפיץ כל תוכן משתמש שהוא פוגעני, מאיים, מטריד, גזעני, משמיץ, דיבתי, פורנוגרפי, אלים, גס, או בלתי חוקי באופן אחר.`}</li>
                <li>{`להעלות או להעביר תוכן המפר זכויות קניין רוחני של צד שלישי (לרבות זכויות יוצרים, סימני מסחר, פטנטים, סודות מסחריים, או זכות לפרטיות/פרסום).`}</li>
                <li>{`לעשות שימוש במערכת למטרות מסחריות, שיווקיות, פרסומיות, או לגיוס כספים, ללא אישור מפורש מראש ובכתב מאת החברה.`}</li>
                <li>{`להפיץ "דואר זבל" (spam), הודעות שרשרת, או כל צורה אחרת של דיוור המוני בלתי רצוי למשתמשים אחרים.`}</li>
                <li>{`לאסוף או לאגור מידע אישי על משתמשים אחרים ללא הסכמתם המפורשת ולמטרות שאינן קשורות ישירות לתהליך השידוך דרך המערכת.`}</li>
                <li>{`להפריע או לשבש את פעולת המערכת, שרתיה או הרשתות המחוברות אליה, או לנסות לעקוף אמצעי אבטחה.`}</li>
                <li>{`להשתמש בכלים אוטומטיים (כגון בוטים, עכבישים, סקריפטים) לאיסוף מידע מהמערכת, לניתוחה, או לאינטראקציה עימה, ללא אישור מפורש מראש ובכתב מהחברה, למעט שימוש במנועי חיפוש ציבוריים סטנדרטיים לצורך יצירת אינדקסים זמינים לציבור (אך לא לשמירת עותקים של חומרי המערכת).`}</li>
                <li>{`לבצע פעולות של הנדסה הפוכה (reverse engineer), פירוק (decompile), או כל ניסיון אחר לחשוף את קוד המקור של המערכת או חלקים ממנו.`}</li>
                <li>{`להתנהג באופן פוגעני, מאיים, מטריד, או בלתי הולם בכל צורה שהיא כלפי עובדי החברה (כאשר יהיו), שדכנים מורשים, נציגי שירות לקוחות, או כל משתמש אחר במערכת.`}</li>
            </ul>
            <p>
              7.3. <strong>אחריות לתוכן משתמש:</strong> {`הינך אחראי/ת באופן בלעדי לכל תוכן משתמש שאת/ה מוסר/ת, מעלה/ה או מפרסם/ת במערכת. הינך מצהיר/ה ומתחייב/ת כי יש לך את כל הזכויות, ההיתרים וההסכמות הנדרשים למסירת תוכן כאמור, וכי תוכן זה אינו מפר כל דין או זכות של צד שלישי.`}
            </p>
            <p>
              7.4. <strong>זכות החברה לפעול:</strong> {`החברה אינה מחויבת לבדוק או לנטר את תוכן המשתמשים, אך שומרת לעצמה את הזכות (אך לא החובה) לעשות זאת, ולהסיר או לערוך כל תוכן משתמש, לחסום גישה של משתמש, או להשעות או לסיים חשבון של משתמש, אשר יפר תנאי הסכם זה או יפעל באופן שאינו הולם, פוגעני, או מזיק למערכת, למשתמשיה או לחברה, והכל לפי שיקול דעתה הבלעדי וללא הודעה מוקדמת.`}
            </p>

            <h2 id='intellectual-property'>8. קניין רוחני</h2>
            <p>
              8.1. <strong>בעלות החברה:</strong> {`כל זכויות הקניין הרוחני במערכת ובתוכן המערכת, לרבות אך לא רק, עיצוב המערכת, קוד התוכנה, אלגוריתמים, מודלי AI, טקסטים, גרפיקה, תמונות (למעט תוכן משתמש), סמלים, לוגואים, ממשקי משתמש, השאלונים (מבנה ותוכן), שיטות עבודה, וכל חומר אחר הקשור למערכת, הינם רכושה הבלעדי של החברה ו/או של צדדים שלישיים שהעניקו לחברה רישיון שימוש בהם. אין להעתיק, לשכפל, להפיץ, לשנות, להציג בפומבי, לבצע בפומבי, או ליצור יצירות נגזרות מכל חלק של המערכת או תוכן המערכת ללא הסכמה מפורשת מראש ובכתב מאת החברה.`}
            </p>
            <p>
              8.2. <strong>רישיון שימוש מוגבל:</strong> {`בכפוף לעמידתך בתנאי הסכם זה, החברה מעניקה לך רישיון אישי, מוגבל, לא בלעדי, בלתי ניתן להעברה, וניתן לביטול, לגשת ולהשתמש במערכת למטרותיך האישיות והלא מסחריות בלבד, בהתאם למטרות המוגדרות של המערכת (שידוכים).`}
            </p>
            <p>
              8.3. <strong>תוכן משתמש:</strong> {`במסירת תוכן משתמש למערכת (כגון תמונות, טקסטים בפרופיל, תשובות לשאלונים), הינך מעניק/ה לחברה רישיון עולמי, לא בלעדי, תמידי (כל עוד חשבונך קיים או כנדרש לשמירת מידע לפי מדיניות הפרטיות), ללא תמורה, וניתן להעברה (למשל, לספקי שירותים או במקרה של שינוי מבני), להשתמש, לשכפל, לעבד, להתאים, לשנות (למשל, התאמות טכניות או עריכה מינורית על ידי שדכן לצורך הצגה), לפרסם (במסגרת המערכת ולמטרות השירות בלבד), להציג, להפיץ, ולאחסן תוכן זה, אך ורק בקשר עם תפעול המערכת, מתן שירותי השידוכים, ושיפורם, והכל בהתאם למדיניות הפרטיות. הינך מצהיר/ה כי יש לך את כל הזכויות וההרשאות הנדרשות להעניק רישיון זה.`}
            </p>

            <h2 id='limitation-of-liability'>9. הגבלת אחריות</h2>
            <p>
              9.1. <strong>{`השירות ניתן "כמות שהוא" (AS IS) ו"ככל שיהיה זמין" (AS AVAILABLE):`}</strong> {`השימוש במערכת הוא על אחריותך הבלעדית. החברה, עובדיה, מנהליה, דירקטורים, שותפיה, והשדכנים הפועלים מטעמה (להלן ביחד: `}<strong>{`"גורמי החברה"`}</strong>{`) אינם מעניקים כל מצג או התחייבות, מפורשת או משתמעת, לגבי פעולת המערכת, זמינותה, אמינותה, דיוק המידע בה (לרבות מידע הנמסר על ידי משתמשים אחרים), היעדר תקלות, וירוסים או רכיבים מזיקים אחרים, או התאמתה לצרכיך או לציפיותיך הספציפיות.`}
            </p>
            <p>
              9.2. <strong>אי ביצוע בדיקות רקע:</strong> {`הינך מאשר/ת ומבין/ה כי החברה אינה מבצעת בדיקות רקע, אימות פלילי, או אימות מעמיק של זהותם או נכונות פרטיהם של המשתמשים במערכת, מעבר לאמצעי האימות הבסיסיים המפורטים במדיניות הפרטיות (כגון אימות דוא'ל או מספר טלפון). האחריות לבדיקת כל אדם שאיתו הינך יוצר/ת קשר או נפגש/ת דרך המערכת, ולנקיטת כל אמצעי הזהירות הנדרשים לשמירה על ביטחונך האישי, חלה עליך באופן בלעדי. מומלץ לנהוג בשיקול דעת ובזהירות סבירה בכל אינטראקציה עם משתמשים אחרים.`}
            </p>
            <p>
              9.3. <strong>הצלחת השידוך אינה מובטחת:</strong> החברה אינה מתחייבת כי השימוש במערכת יוביל למציאת התאמה זוגית, לפגישות מוצלחות, או לנישואין. תהליך השידוך תלוי בגורמים רבים שאינם בשליטת החברה.
            </p>
            <p>
              9.4. <strong>אי אחריות לתוכן משתמשים ולהתנהגותם:</strong> {`גורמי החברה אינם אחראים לתוכן המועלה על ידי משתמשים, לנכונותו, למהימנותו, או לחוקיותו. כמו כן, גורמי החברה אינם אחראים להתנהגותם של משתמשים, בין אם בתוך המערכת ובין אם מחוצה לה (למשל, במהלך פגישות).`}
            </p>
            <p>
              9.5. <strong>אי אחריות לנזקים:</strong> {`בשום מקרה לא יהיו גורמי החברה אחראים כלפיך או כלפי כל צד שלישי בגין כל נזק, ישיר, עקיף, מיוחד, תוצאתי, או עונשי (לרבות, אך לא רק, אובדן נתונים, אובדן רווחים, פגיעה במוניטין, עוגמת נפש), הנובע מהשימוש שלך במערכת או מחוסר היכולת להשתמש בה, או מהסתמכות על מידע או הצעות שהתקבלו דרכה, גם אם נודע לגורמי החברה על האפשרות לנזקים כאמור. אחריות זו כוללת גם אי אחריות למחיקה, שיבוש או אי-שמירה של הודעות, הצעות, או כל תוכן אחר במערכת.`}
            </p>
            <p>
              9.6. <strong>הגבלת סכום האחריות:</strong> {`ככל שתיקבע אחריות כלשהי על גורמי החברה, על אף האמור לעיל, אחריותם המצטברת הכוללת כלפיך בגין כל עילה שהיא הנובעת מהסכם זה או מהשימוש במערכת, לא תעלה על הסכום הכולל ששילמת בפועל לחברה (אם בכלל) עבור השימוש בשירותים בתקופה של שלושה (3) חודשים שקדמו לאירוע שבגינו קמה עילת התביעה, או סך של 100 ש"ח, הנמוך מביניהם.`}
            </p>

            <h2 id='indemnification'>10. שיפוי</h2>
            <p>
              {`הינך מתחייב/ת לשפות ולפצות את גורמי החברה, מיד עם דרישתם הראשונה, בגין כל נזק, הפסד, אובדן רווח, תשלום, חבות או הוצאה (לרבות שכר טרחת עורך דין והוצאות משפט סבירות) שייגרמו להם, במישרין או בעקיפין, עקב או בקשר עם: (א) הפרת תנאי כלשהו מתנאי הסכם זה על ידך; (ב) כל טענה, תביעה או דרישה שתועלה נגדם על ידי צד שלישי כלשהו כתוצאה מתוכן המשתמש שמסרת, מפעולותיך במערכת, או מאינטראקציות שלך עם משתמשים אחרים מחוץ למערכת; (ג) כל הפרה של דין או זכות של צד שלישי על ידך. התחייבות שיפוי זו תחול ללא קשר לרשלנות של צד כלשהו, לרבות גורם משופה.`}
            </p>

            <h2 id='third-party-links'>11. קישורים לאתרים ושירותים של צדדים שלישיים</h2>
            <p>
              {`המערכת עשויה להכיל קישורים לאתרים, יישומים או שירותים המופעלים על ידי צדדים שלישיים. קישורים אלו ניתנים לנוחותך בלבד. לחברה אין שליטה על אתרים או שירותים אלו, והיא אינה אחראית לתוכנם, לזמינותם, למדיניות הפרטיות שלהם, או לכל היבט אחר הקשור אליהם. הכללת קישור אינה מהווה המלצה או אישור מצד החברה. השימוש באתרים ושירותים של צדדים שלישיים הוא על אחריותך בלבד ובכפוף לתנאי השימוש ומדיניות הפרטיות שלהם.`}
            </p>

            <h2 id='termination'>12. סיום ההתקשרות והשעיית חשבון</h2>
            <p>
              12.1. <strong>סיום על ידך:</strong> {`הינך רשאי/ת להפסיק את השימוש במערכת ולמחוק את חשבונך בכל עת, בהתאם להוראות המערכת או על ידי פנייה אלינו. סיום ההתקשרות לא יפטור אותך מהתחייבויות שנוצרו טרם הסיום (כגון תשלום דמי הצלחה אם רלוונטי).`}
            </p>
            <p>
              12.2. <strong>סיום או השעיה על ידי החברה:</strong> {`החברה רשאית, לפי שיקול דעתה הבלעדי, להשעות או לסיים את חשבונך ואת גישתך למערכת, באופן מיידי וללא הודעה מוקדמת, במקרה של הפרת תנאי הסכם זה, התנהגות בלתי הולמת כמפורט בסעיף 7, חשד לפעילות בלתי חוקית או הונאה, או מכל סיבה אחרת שתראה לנכון.`}
            </p>
            <p>
              12.3. <strong>תוצאות סיום:</strong> {`עם סיום ההתקשרות, מכל סיבה שהיא, הרישיון שלך לשימוש במערכת יפקע. החברה תטפל במידע האישי שלך בהתאם למדיניות הפרטיות ולדרישות הדין. סעיפים מסוימים בהסכם זה (כגון קניין רוחני, הגבלת אחריות, שיפוי, דין וסמכות שיפוט, והתחייבויות לתשלום שנצברו) ימשיכו לחול גם לאחר סיום ההתקשרות.`}
            </p>

            <h2 id='changes-to-terms'>13. שינויים בתנאי השימוש</h2>
            <p>
              {`החברה שומרת לעצמה את הזכות לשנות או לעדכן תנאי שימוש אלו מעת לעת, לפי שיקול דעתה הבלעדי. במקרה של שינויים מהותיים, אנו נפעל להודיע לך על כך באמצעות פרסום הודעה בולטת במערכת ו/או שליחת הודעת דוא'ל לכתובת המשויכת לחשבונך. תאריך "העדכון האחרון" בראש ההסכם ישקף את מועד כניסת השינויים לתוקף.`}
              {`המשך שימושך במערכת לאחר פרסום השינויים ועדכונם ייחשב כהסכמה מצדך לתנאים המעודכנים. אם אינך מסכים/ה לשינויים, עליך להפסיק את השימוש במערכת. אנו ממליצים לך לעיין בתנאי שימוש אלו באופן תקופתי.`}
            </p>

            <h2 id='governing-law'>14. דין וסמכות שיפוט</h2>
            <p>
              על הסכם זה ועל כל הנובע ממנו או הקשור אליו, לרבות פרשנותו ואכיפתו, יחולו אך ורק דיני מדינת ישראל. סמכות השיפוט הבלעדית והייחודית בכל סכסוך או מחלוקת הנובעים מהסכם זה או מהשימוש במערכת תהא נתונה לבתי המשפט המוסמכים במחוז {jurisdictionDistrict}, ישראל.
            </p>

            <h2 id='miscellaneous'>15. שונות</h2>
            <p>
              15.1. <strong>הסכם ממצה:</strong> הסכם זה, יחד עם מדיניות הפרטיות, מהווים את מלוא ההסכמות בינך לבין החברה בנוגע לשימוש במערכת, ומחליפים כל הסכמה, הבנה או מצג קודמים, בין בעל פה ובין בכתב.
            </p>
            <p>
              15.2. <strong>אי ויתור:</strong> אי מימוש או אכיפה של זכות או הוראה כלשהי מתנאי הסכם זה על ידי החברה, לא ייחשבו כוויתור על זכות או הוראה כאמור.
            </p>
            <p>
              15.3. <strong>הפרדה (Severability):</strong> אם ייקבע על ידי בית משפט מוסמך כי הוראה כלשהי מתנאי הסכם זה הינה בלתי חוקית, בטלה או בלתי אכיפה, אזי הוראה זו תיחשב כמופרדת משאר הוראות ההסכם, ושאר ההוראות יישארו בתוקפן המלא.
            </p>
            <p>
              15.4. <strong>כותרות:</strong> הכותרות בהסכם זה נועדו לנוחות בלבד ואין להן כל משמעות פרשנית.
            </p>
            <p>
              15.5. <strong>המחאת זכויות:</strong> {`אינך רשאי/ת להמחות או להעביר את זכויותיך או התחייבויותיך על פי הסכם זה ללא הסכמתה המפורשת מראש ובכתב של החברה. החברה רשאית להמחות או להעביר את זכויותיה והתחייבויותיה על פי הסכם זה, כולן או מקצתן, לכל צד שלישי, ללא צורך בהסכמתך, לרבות במסגרת העברת בעלות על המערכת או מיזוג.`}
            </p>

            <h2 id='contact-terms'>16. יצירת קשר</h2>
            <p>
              {`בכל שאלה, הבהרה, או דיווח בנוגע לתנאי שימוש אלו או לפעילות המערכת, ניתן לפנות אלינו בכתובת הדוא'ל: `}<a href={`mailto:${supportEmail}`} className='text-cyan-600 hover:text-cyan-700'>{supportEmail}</a>
            </p>
            <p className='mt-4'>
              אנו מאחלים לך שימוש פורה ומוצלח במערכת Matchpoint!
            </p>
          </article>
        </div>
      </div>
    </>
  );
};

export default TermsOfServicePage;
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\questionnaire\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import QuestionnairePage from "@/components/questionnaire/QuestionnairePage";

export default function Page() {
  return <QuestionnairePage />;
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\questionnaire\complete\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import QuestionnaireComplete from "@/components/questionnaire/QuestionnaireComplete";

export default function Page() {
  return <QuestionnaireComplete />;
}
--- End of Content for page.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\questionnaire\restore
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\questionnaire\restore\page.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import QuestionnaireRestore from "@/components/questionnaire/QuestionnaireRestore";

export default function Page() {
  return <QuestionnaireRestore />;
}
--- End of Content for page.tsx ---

