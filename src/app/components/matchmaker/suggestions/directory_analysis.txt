מבנה התיקייה:
suggestions
  EditSuggestionForm.tsx
  MessageForm.tsx
  NewSuggestionForm
    CandidateSelector.tsx
    MatchPreview.tsx
    SuggestionDetails.tsx
    index.tsx
    schema.ts
  cards
    SuggestionCard.tsx
  container
    MatchmakerDashboard.tsx
    MonthlyTrendModal.tsx
    SuggestionActionBar.tsx
    SuggestionsStats.tsx
  details
    SuggestionDetailsDialog.tsx
  hooks
    useMatchmaking.ts
  list
    ManagerSuggestionsList.tsx
    SuggestionsList.tsx
  services
    email
      EmailService.ts
    suggestions
      StatusTransitionService.ts
      SuggestionService.ts
  utils
    matchingAlgorithm.ts
    statisticsCalculator.ts

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\EditSuggestionForm.tsx:
==================================================
// קוד מתוקן ב-EditSuggestionForm.tsx עם פתרון לבעיית הטיפוסים

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { DatePicker } from "@/components/ui/date-picker";
import type { Suggestion } from "@/types/suggestions";

interface EditSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSave: (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      status?: MatchSuggestionStatus;
      statusNotes?: string;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => Promise<void>;
}

const EditSuggestionForm: React.FC<EditSuggestionFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSave,
}) => {
  const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
  // נשתמש בסוג נפרד לתיעוד אם נבחר סטטוס חדש או לא
  const [selectedStatus, setSelectedStatus] = useState<string | null>(null);
  // נשתמש במשתנה נפרד שיחזיק את הסטטוס האמיתי שיישלח לשרת
  const [statusToUpdate, setStatusToUpdate] =
    useState<MatchSuggestionStatus | null>(null);
  const [statusNotes, setStatusNotes] = useState("");
  const [matchingReason, setMatchingReason] = useState("");
  const [firstPartyNotes, setFirstPartyNotes] = useState("");
  const [secondPartyNotes, setSecondPartyNotes] = useState("");
  const [internalNotes, setInternalNotes] = useState("");
  const [decisionDeadline, setDecisionDeadline] = useState<Date | undefined>(
    undefined
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showStatusChange, setShowStatusChange] = useState(false);

  // עדכון הטופס כאשר נתוני ההצעה משתנים
  useEffect(() => {
    if (suggestion) {
      // עדכון כל השדות עם הנתונים הקיימים בהצעה
      setPriority(suggestion.priority as Priority);
      setSelectedStatus(null);
      setStatusToUpdate(null);
      setStatusNotes("");
      setMatchingReason(suggestion.matchingReason || "");
      setFirstPartyNotes(suggestion.firstPartyNotes || "");
      setSecondPartyNotes(suggestion.secondPartyNotes || "");
      setInternalNotes(suggestion.internalNotes || "");

      // טיפול נכון בתאריך
      if (suggestion.decisionDeadline) {
        // וידוא שמדובר בתאריך תקין
        const deadlineDate = new Date(suggestion.decisionDeadline);
        if (!isNaN(deadlineDate.getTime())) {
          setDecisionDeadline(deadlineDate);
        }
      } else {
        setDecisionDeadline(undefined);
      }
    }
  }, [suggestion]);

  const handleSubmit = async () => {
    if (!suggestion) return;

    try {
      setIsSubmitting(true);

      // מבנה העדכון עם אפשרות לסטטוס
      const updateData: {
        priority: Priority;
        status?: MatchSuggestionStatus;
        statusNotes?: string;
        matchingReason: string;
        firstPartyNotes: string;
        secondPartyNotes: string;
        internalNotes: string;
        decisionDeadline: string | null;
      } = {
        priority,
        matchingReason,
        firstPartyNotes,
        secondPartyNotes,
        internalNotes,
        decisionDeadline: decisionDeadline
          ? decisionDeadline.toISOString()
          : null,
      };

      // הוספת סטטוס רק אם נבחר סטטוס חדש לעדכון
      if (statusToUpdate) {
        updateData.status = statusToUpdate;
        updateData.statusNotes =
          statusNotes || `סטטוס שונה ל-${getStatusLabel(statusToUpdate)}`;
      }

      // קריאה ל-API לעדכון ההצעה
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestion.id}`,
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(updateData),
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "Failed to update suggestion");
      }

      // עדכון הקומפוננטה ההורה
      await onSave({
        suggestionId: suggestion.id,
        updates: {
          priority,
          status: statusToUpdate || undefined,
          statusNotes: statusToUpdate ? statusNotes : undefined,
          matchingReason,
          firstPartyNotes,
          secondPartyNotes,
          internalNotes,
          decisionDeadline,
        },
      });

      toast.success("פרטי ההצעה עודכנו בהצלחה");
      onClose();
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    } finally {
      setIsSubmitting(false);
    }
  };

  // פונקציה להחזרת התווית המתאימה לסטטוס
  const getStatusLabel = (statusValue: string): string => {
    const statusLabels: Record<string, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
      FIRST_PARTY_APPROVED: "צד א׳ אישר",
      FIRST_PARTY_DECLINED: "צד א׳ דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
      SECOND_PARTY_APPROVED: "צד ב׳ אישר",
      SECOND_PARTY_DECLINED: "צד ב׳ דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
      PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
      ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
      MEETING_PENDING: "ממתין לקביעת פגישה",
      MEETING_SCHEDULED: "פגישה נקבעה",
      MATCH_APPROVED: "ההצעה אושרה",
      MATCH_DECLINED: "ההצעה נדחתה",
      DATING: "בתהליך היכרות",
      ENGAGED: "מאורסים",
      MARRIED: "נישאו",
      EXPIRED: "פג תוקף",
      CLOSED: "ההצעה נסגרה",
      CANCELLED: "ההצעה בוטלה",
    };

    return statusLabels[statusValue] || statusValue;
  };

  // הסטטוסים שניתן לשנות אליהם - יכול להשתנות לפי הסטטוס הנוכחי
  const getAvailableStatuses = (): MatchSuggestionStatus[] => {
    if (!suggestion) return [];

    // סטטוסים מרכזיים שתמיד זמינים
    const commonStatuses: MatchSuggestionStatus[] = [
      "PENDING_FIRST_PARTY",
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "PENDING_SECOND_PARTY",
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "CONTACT_DETAILS_SHARED",
      "DATING",
      "EXPIRED",
      "CLOSED",
      "CANCELLED",
    ];

    return commonStatuses;
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>עריכת הצעת שידוך</DialogTitle>
          <DialogDescription>
            עריכת הפרטים עבור ההצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Status and Priority Section */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Priority */}
            <div className="space-y-2">
              <Label>עדיפות ההצעה</Label>
              <Select
                value={priority}
                onValueChange={(value) => setPriority(value as Priority)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י עדיפות" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
                  <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                  <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                  <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Status */}
            <div className="space-y-2">
              <Label>שינוי סטטוס (אופציונלי)</Label>
              <Select
                value={selectedStatus || undefined}
                onValueChange={(value) => {
                  setSelectedStatus(value);

                  // אם נבחר "ללא שינוי" או ערך ריק
                  if (value === "NO_CHANGE" || !value) {
                    setStatusToUpdate(null);
                    setShowStatusChange(false);
                  } else {
                    // אחרת, מעדכנים את הסטטוס שיישלח לשרת
                    setStatusToUpdate(value as MatchSuggestionStatus);
                    setShowStatusChange(true);
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י סטטוס חדש (אופציונלי)" />
                </SelectTrigger>
                <SelectContent>
                  {/* משתמשים בערך חוקי מהמערכת */}
                  <SelectItem value="NO_CHANGE">ללא שינוי</SelectItem>
                  {getAvailableStatuses().map((availableStatus) => (
                    <SelectItem key={availableStatus} value={availableStatus}>
                      {getStatusLabel(availableStatus)}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Status Notes - מוצג רק אם נבחר סטטוס לעדכון */}
          {showStatusChange && statusToUpdate && (
            <div className="space-y-2 bg-slate-50 p-4 rounded-md border">
              <Label>הערות לשינוי הסטטוס</Label>
              <Textarea
                value={statusNotes}
                onChange={(e) => setStatusNotes(e.target.value)}
                placeholder="הערות אופציונליות לשינוי הסטטוס..."
                className="h-20"
              />
              <div className="text-xs text-gray-500 mt-1">
                הערות אלו יוצגו בהיסטוריית השינויים של ההצעה
              </div>
            </div>
          )}

          {/* Decision Deadline */}
          <div className="space-y-2">
            <Label>מועד החלטה אחרון</Label>
            <DatePicker
              value={{ from: decisionDeadline, to: undefined }}
              onChange={({ from }) => setDecisionDeadline(from)}
            />
          </div>

          {/* Matching Reason */}
          <div className="space-y-2">
            <Label>סיבת ההתאמה</Label>
            <Textarea
              value={matchingReason}
              onChange={(e) => setMatchingReason(e.target.value)}
              placeholder="פרט/י מדוע יש התאמה בין המועמדים..."
              className="h-24"
            />
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label>הערות לצד א׳ ({suggestion.firstParty.firstName})</Label>
              <Textarea
                value={firstPartyNotes}
                onChange={(e) => setFirstPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד א׳..."
                className="h-24"
              />
            </div>

            <div className="space-y-2">
              <Label>הערות לצד ב׳ ({suggestion.secondParty.firstName})</Label>
              <Textarea
                value={secondPartyNotes}
                onChange={(e) => setSecondPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד ב׳..."
                className="h-24"
              />
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-2">
            <Label>הערות פנימיות</Label>
            <Textarea
              value={internalNotes}
              onChange={(e) => setInternalNotes(e.target.value)}
              placeholder="הערות פנימיות לשימוש השדכנים בלבד..."
              className="h-24"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? "שומר..." : "שמור שינויים"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default EditSuggestionForm;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\MessageForm.tsx:
==================================================
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { MessageCircle, Send, AlertCircle } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";

interface MessageFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSend: (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => Promise<void>;
}

const MessageForm: React.FC<MessageFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSend,
}) => {
  const [partyType, setPartyType] = useState<"first" | "second" | "both">(
    "both"
  );
  const [messageType, setMessageType] = useState<
    "message" | "reminder" | "update"
  >("message");
  const [messageContent, setMessageContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async () => {
    if (!suggestion || !messageContent.trim()) return;

    try {
      setIsSubmitting(true);

      // Call the API to send the message
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestion.id}/message`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            partyType,
            messageType,
            content: messageContent,
          }),
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "Failed to send message");
      }

      // Notify the parent component
      await onSend({
        suggestionId: suggestion.id,
        partyType,
        messageType,
        messageContent,
      });

      toast.success(
        `ההודעה נשלחה ${
          partyType === "first"
            ? `ל${suggestion.firstParty.firstName}`
            : partyType === "second"
            ? `ל${suggestion.secondParty.firstName}`
            : "לשני הצדדים"
        }`
      );
      onClose();
    } catch (error) {
      toast.error("שגיאה בשליחת ההודעה");
      console.error("Error sending message:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getMessagePlaceholder = () => {
    switch (messageType) {
      case "reminder":
        return "הודעת תזכורת למועמד/ת לגבי ההצעה...";
      case "update":
        return "עדכון לגבי סטטוס ההצעה או מידע חדש...";
      default:
        return "הודעה אישית למועמד/ת...";
    }
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>שליחת הודעה</DialogTitle>
          <DialogDescription>
            שליחת הודעה הקשורה להצעת השידוך בין{" "}
            {suggestion.firstParty.firstName} {suggestion.firstParty.lastName} ל
            {suggestion.secondParty.firstName} {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Recipient Selection */}
          <div className="space-y-2">
            <Label>שלח אל</Label>
            <Select
              value={partyType}
              onValueChange={(value) =>
                setPartyType(value as "first" | "second" | "both")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר נמען" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="first">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} (צד א׳)
                </SelectItem>
                <SelectItem value="second">
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName} (צד ב׳)
                </SelectItem>
                <SelectItem value="both">שני הצדדים</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Type */}
          <div className="space-y-2">
            <Label>סוג ההודעה</Label>
            <Select
              value={messageType}
              onValueChange={(value) =>
                setMessageType(value as "message" | "reminder" | "update")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר סוג הודעה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="message">
                  <div className="flex items-center">
                    <MessageCircle className="w-4 h-4 ml-2" />
                    הודעה רגילה
                  </div>
                </SelectItem>
                <SelectItem value="reminder">
                  <div className="flex items-center">
                    <AlertCircle className="w-4 h-4 ml-2" />
                    תזכורת
                  </div>
                </SelectItem>
                <SelectItem value="update">
                  <div className="flex items-center">
                    <Send className="w-4 h-4 ml-2" />
                    עדכון סטטוס
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Content */}
          <div className="space-y-2">
            <Label>תוכן ההודעה</Label>
            <Textarea
              value={messageContent}
              onChange={(e) => setMessageContent(e.target.value)}
              placeholder={getMessagePlaceholder()}
              className="h-36"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={isSubmitting || !messageContent.trim()}
            className="gap-2"
          >
            <Send className="w-4 h-4" />
            {isSubmitting ? "שולח..." : "שלח הודעה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default MessageForm;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\cards\SuggestionCard.tsx:
==================================================
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import Image from "next/image";
import {
  Clock,
  User,
  MessageCircle,
  Eye,
  AlertCircle,
  MoreHorizontal,
  Send,
  RefreshCw,
  Trash2,
  Edit,
  CheckCircle,
  XCircle,
  CalendarClock,
  Heart,
  MapPin,
  Calendar,
  Star,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestionStatus, Priority } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import { Progress } from "@/components/ui/progress";

interface SuggestionCardProps {
  suggestion: Suggestion;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const getStatusInfo = (status: MatchSuggestionStatus) => {
  switch (status) {
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לתשובת צד א׳",
        className: "bg-yellow-100 text-yellow-800 border-yellow-200",
        color: "text-yellow-600",
        bgColor: "bg-yellow-50",
        icon: Clock,
        progress: 25,
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לתשובת צד ב׳",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        color: "text-blue-600",
        bgColor: "bg-blue-50",
        icon: Clock,
        progress: 50,
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "צד א׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 40,
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "צד ב׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 60,
      };
    case "FIRST_PARTY_DECLINED":
      return {
        label: "צד א׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "SECOND_PARTY_DECLINED":
      return {
        label: "צד ב׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        className: "bg-purple-100 text-purple-800 border-purple-200",
        color: "text-purple-600",
        bgColor: "bg-purple-50",
        icon: Send,
        progress: 70,
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        className: "bg-pink-100 text-pink-800 border-pink-200",
        color: "text-pink-600",
        bgColor: "bg-pink-50",
        icon: Heart,
        progress: 80,
      };
    case "AWAITING_FIRST_DATE_FEEDBACK":
      return {
        label: "ממתין למשוב פגישה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        color: "text-orange-600",
        bgColor: "bg-orange-50",
        icon: AlertCircle,
        progress: 75,
      };
    case "EXPIRED":
      return {
        label: "פג תוקף",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: Clock,
        progress: 100,
      };
    default:
      return {
        label: "בטיפול",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: RefreshCw,
        progress: 30,
      };
  }
};

const getPriorityInfo = (priority: Priority) => {
  switch (priority) {
    case "URGENT":
      return {
        label: "דחוף",
        className: "bg-red-100 text-red-800 border-red-200",
        icon: AlertCircle,
        color: "text-red-600",
      };
    case "HIGH":
      return {
        label: "גבוה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        icon: Star,
        color: "text-orange-600",
      };
    case "MEDIUM":
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
    case "LOW":
      return {
        label: "נמוך",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: Star,
        color: "text-gray-600",
      };
    default:
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
  }
};

// Days left until deadline if applicable
const getDaysLeft = (decisionDeadline?: Date | string | null) => {
  if (!decisionDeadline) return null;

  const deadline = new Date(decisionDeadline);
  const today = new Date();
  const diffTime = deadline.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? diffDays : 0;
};

const SuggestionCard: React.FC<SuggestionCardProps> = ({
  suggestion,
  onAction,
  className,
}) => {
  const { firstParty, secondParty } = suggestion;
  const statusInfo = getStatusInfo(suggestion.status);
  const priorityInfo = getPriorityInfo(suggestion.priority);
  const StatusIcon = statusInfo.icon;
  const PriorityIcon = priorityInfo.icon;
  const daysLeft = getDaysLeft(suggestion.decisionDeadline);

  // Check if the suggestion is waiting for response
  const isWaitingForResponse =
    suggestion.status === "PENDING_FIRST_PARTY" ||
    suggestion.status === "PENDING_SECOND_PARTY";

  // Check if the suggestion has feedback requirement
  const needsFeedback = suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK";

  // Check if the suggestion can be resent
  const canBeResent =
    suggestion.status === "EXPIRED" ||
    suggestion.status === "FIRST_PARTY_DECLINED" ||
    suggestion.status === "SECOND_PARTY_DECLINED";

  const firstPartyAge = calculateAge(firstParty.profile.birthDate);
  const secondPartyAge = calculateAge(secondParty.profile.birthDate);

  const firstPartyMainImage = firstParty.images.find((img) => img.isMain);
  const secondPartyMainImage = secondParty.images.find((img) => img.isMain);

  return (
    <Card
      className={`${className} overflow-hidden hover:shadow-md transition-shadow`}
    >
      {/* Header with status and progress */}
      <div className={`p-4 ${statusInfo.bgColor} border-b relative`}>
        <div className="flex justify-between items-center mb-2">
          <div className="flex items-center gap-2">
            <StatusIcon className={`w-5 h-5 ${statusInfo.color}`} />
            <span className="font-medium text-gray-900">
              {statusInfo.label}
            </span>
          </div>
          <Badge className={priorityInfo.className}>
            <PriorityIcon className="w-3 h-3 ml-1" />
            {priorityInfo.label}
          </Badge>
        </div>

        <Progress value={statusInfo.progress} className="h-1.5" />

        {/* Deadline warning if needed */}
        {daysLeft !== null &&
          daysLeft <= 3 &&
          suggestion.status !== "EXPIRED" && (
            <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 bg-red-500 text-white text-xs font-bold py-0.5 px-2 rounded-full whitespace-nowrap z-10">
              <Clock className="w-3 h-3 inline-block ml-1" />
              {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים נותרו`}
            </div>
          )}
      </div>

      {/* Main content */}
      <div className="p-4">
        {/* Parties info */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          {/* First party */}
          <div className="space-y-2 border-l pl-4 order-1">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-blue-50">
                צד א׳
              </Badge>
              {suggestion.status === "FIRST_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "FIRST_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {firstPartyMainImage ? (
                  <Image
                    src={firstPartyMainImage.url}
                    alt={`${firstParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {firstParty.firstName} {firstParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{firstPartyAge} שנים</span>
                  </div>
                  {firstParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{firstParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Second party */}
          <div className="space-y-2 order-0">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-purple-50">
                צד ב׳
              </Badge>
              {suggestion.status === "SECOND_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "SECOND_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {secondPartyMainImage ? (
                  <Image
                    src={secondPartyMainImage.url}
                    alt={`${secondParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {secondParty.firstName} {secondParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{secondPartyAge} שנים</span>
                  </div>
                  {secondParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{secondParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Matching reason snippet */}
        {suggestion.matchingReason && (
          <div className="mb-4 p-3 bg-gray-50 rounded-lg border text-sm">
            <h5 className="text-xs font-semibold text-gray-600 mb-1">
              סיבת ההתאמה:
            </h5>
            <p className="text-gray-800 line-clamp-2">
              {suggestion.matchingReason.length > 120
                ? `${suggestion.matchingReason.substring(0, 120)}...`
                : suggestion.matchingReason}
            </p>
          </div>
        )}

        {/* Info and time */}
        <div className="flex justify-between text-xs text-gray-500 mb-4">
          <div className="flex items-center">
            <Clock className="w-3.5 h-3.5 ml-1" />
            {formatDistanceToNow(new Date(suggestion.createdAt), {
              addSuffix: true,
              locale: he,
            })}
          </div>

          {suggestion.decisionDeadline && (
            <div className="flex items-center">
              <CalendarClock className="w-3.5 h-3.5 ml-1" />
              {daysLeft !== null
                ? daysLeft === 0
                  ? "היום!"
                  : `${daysLeft} ימים להחלטה`
                : "אין מועד אחרון"}
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="flex items-center justify-between pt-2 border-t">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onAction("message", suggestion)}
            className="text-gray-600 hover:text-primary"
          >
            <MessageCircle className="w-4 h-4 ml-1" />
            הודעה
          </Button>

          {/* סקציית פעולות בקובץ SuggestionCard.tsx */}
          {isWaitingForResponse && (
            <Button
              variant="outline"
              size="sm"
              className="text-yellow-600"
              onClick={() =>
                onAction("reminder", suggestion, {
                  partyType:
                    suggestion.status === "PENDING_FIRST_PARTY"
                      ? "first"
                      : "second",
                })
              }
            >
              <Send className="w-4 h-4 ml-1" />
              {suggestion.status === "PENDING_FIRST_PARTY"
                ? "שלח תזכורת לצד ראשון"
                : suggestion.status === "PENDING_SECOND_PARTY"
                ? "שלח תזכורת לצד שני"
                : suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK"
                ? "שלח בקשת עדכון מפגש"
                : "שלח תזכורת"}
            </Button>
          )}

          {needsFeedback && (
            <Button
              variant="outline"
              size="sm"
              className="text-blue-600"
              onClick={() =>
                onAction("contact", suggestion, { type: "feedback" })
              }
            >
              <MessageCircle className="w-4 h-4 ml-1" />
              בקש משוב
            </Button>
          )}

          <div className="flex items-center gap-1">
            {canBeResent && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAction("resend", suggestion)}
                className="px-2"
              >
                <RefreshCw className="w-4 h-4" />
              </Button>
            )}

            <Button
              variant="outline"
              size="sm"
              onClick={() => onAction("edit", suggestion)}
              className="px-2"
            >
              <Edit className="w-4 h-4" />
            </Button>

            <Button
              variant="default"
              size="sm"
              onClick={() => onAction("view", suggestion)}
            >
              <Eye className="w-4 h-4 ml-1" />
              פרטים
            </Button>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button size="sm" variant="ghost" className="px-1">
                  <MoreHorizontal className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => onAction("edit", suggestion)}>
                  <Edit className="w-4 h-4 ml-2" />
                  <span>ערוך הצעה</span>
                </DropdownMenuItem>

                {canBeResent && (
                  <DropdownMenuItem
                    onClick={() => onAction("resend", suggestion)}
                  >
                    <RefreshCw className="w-4 h-4 ml-2" />
                    <span>שלח מחדש</span>
                  </DropdownMenuItem>
                )}

                <DropdownMenuItem
                  onClick={() => onAction("delete", suggestion)}
                  className="text-red-600"
                >
                  <Trash2 className="w-4 h-4 ml-2" />
                  <span>מחק הצעה</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </Card>
  );
};

export default SuggestionCard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx:
==================================================
"use client";

import React, { useState, useCallback, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Plus, Download, RefreshCw, BarChart } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import type {
  Suggestion,
  SuggestionFilters,
  ActionAdditionalData,
} from "@/types/suggestions";
import type { NewSuggestionFormData } from "../../suggestions/NewSuggestionForm/schema";
import { MatchSuggestionStatus, Priority } from "@prisma/client";
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import SuggestionCard from "../cards/SuggestionCard";
import { toast } from "sonner";
import EditSuggestionForm from "../EditSuggestionForm";
import MessageForm from "../MessageForm";
import MonthlyTrendModal from "./MonthlyTrendModal";
type DialogActionData = {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyType?: "first" | "second" | "both";
  type?: string;
};
type ConfirmActionData = {
  suggestionId: string;
  partyType?: "first" | "second" | "both";
  type?: string;
};

export default function MatchmakerDashboard() {
  // State management
  const [activeTab, setActiveTab] = useState("pending"); // Changed default tab to "pending"
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<SuggestionFilters>({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmAction, setConfirmAction] = useState<{
    type: string;
    data: ConfirmActionData;
  } | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [showEditForm, setShowEditForm] = useState(false);
  const [showMessageForm, setShowMessageForm] = useState(false);
  const [, setMessageRecipient] = useState<"first" | "second" | "both">("both");
  const [showMonthlyTrendDialog, setShowMonthlyTrendDialog] = useState(false);

  // Calculate suggestion counts
  const activeCount = suggestions.filter((s) => s.category === "ACTIVE").length;
  const pendingCount = suggestions.filter(
    (s) => s.category === "PENDING"
  ).length;
  const historyCount = suggestions.filter(
    (s) => s.category === "HISTORY"
  ).length;

  // Fetch suggestions data
  const fetchSuggestions = async () => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/matchmaker/suggestions");
      if (!response.ok) {
        throw new Error("Failed to fetch suggestions");
      }

      const data = await response.json();
      setSuggestions(data);

      // Log suggestions data for debugging
      console.log("Fetched suggestions:", data);
      console.log("Total suggestions count:", data.length);

      // Log suggestions by status
      const activeCount = data.filter(
        (s: Suggestion) => s.category === "ACTIVE"
      ).length;
      const pendingCount = data.filter(
        (s: Suggestion) => s.category === "PENDING"
      ).length;
      const historyCount = data.filter(
        (s: Suggestion) => s.category === "HISTORY"
      ).length;
      console.log("Suggestions by status:", {
        active: activeCount,
        pending: pendingCount,
        history: historyCount,
      });
    } catch (error) {
      console.error("Error fetching suggestions:", error);
      toast.error("שגיאה בטעינת ההצעות");
    } finally {
      setIsLoading(false);
    }
  };

  // Initial data fetch
  useEffect(() => {
    fetchSuggestions();
  }, []);

  // Handle refresh button
  const handleRefresh = async () => {
    setIsRefreshing(true);
    await fetchSuggestions();
    setIsRefreshing(false);
    toast.success("נתוני ההצעות עודכנו");
  };

  // Handle new suggestion creation
  const handleNewSuggestion = async (data: NewSuggestionFormData) => {
    try {
      const response = await fetch("/api/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      setShowNewSuggestion(false);
      toast.success("ההצעה נוצרה בהצלחה");
      await fetchSuggestions();
    } catch (error) {
      console.error("Error creating suggestion:", error);
      toast.error("שגיאה ביצירת ההצעה");
    }
  };

  // Handle suggestion deletion
  const handleSuggestionDeleted = useCallback((deletedId: string) => {
    setSuggestions((prevSuggestions) =>
      prevSuggestions.filter((suggestion) => suggestion.id !== deletedId)
    );
    toast.success("ההצעה נמחקה בהצלחה");
  }, []);

  // Export suggestions to CSV
  const handleExport = async () => {
    try {
      const response = await fetch("/api/suggestions/export", {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        throw new Error("Failed to export suggestions");
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `suggestions-export-${new Date().toISOString()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      toast.success("הקובץ הורד בהצלחה");
    } catch (error) {
      console.error("Error exporting suggestions:", error);
      toast.error("שגיאה בייצוא ההצעות");
    }
  };

  // Handle suggestion actions
  const handleSuggestionAction = (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => {
    console.log(
      `Action ${type} for suggestion ${suggestion.id}`,
      additionalData
    );

    switch (type) {
      case "view":
        setSelectedSuggestion(suggestion);
        break;
      case "delete":
        setConfirmAction({
          type: "delete",
          data: { suggestionId: suggestion.id },
        });
        setShowConfirmDialog(true);
        break;
      case "contact":
        // Show reminder sending confirmation
        setConfirmAction({
          type: "contact",
          data: {
            suggestionId: suggestion.id,
            partyType:
              suggestion.status === "PENDING_FIRST_PARTY" ? "first" : "second",
          },
        });
        setShowConfirmDialog(true);
        break;
      case "reminder":
        // Handle reminder action
        setConfirmAction({
          type: "contact", // או "reminder" אם יש טיפול שונה
          data: {
            suggestionId: suggestion.id,
            partyType: additionalData?.partyType || "both",
          },
        });
        setShowConfirmDialog(true);
        break;
      case "edit":
        // לפתיחת חלון עריכה
        setSelectedSuggestion(suggestion);
        setShowEditForm(true);
        break;
      case "message":
        // לפתיחת חלון הודעה
        setSelectedSuggestion(suggestion);
        setShowMessageForm(true);
        break;
      case "resend":
        // Show resend confirmation
        setConfirmAction({
          type: "resend",
          data: { suggestionId: suggestion.id },
        });
        setShowConfirmDialog(true);
        break;
      case "changeStatus":
        if (additionalData?.newStatus) {
          handleStatusChange(
            suggestion.id,
            additionalData.newStatus,
            additionalData?.notes
          );
        } else {
          console.error("Status change requested without providing new status");
          toast.error("שגיאה: סטטוס חדש לא סופק");
        }
        break;
    }
  };
  const getCategoryFromStatus = (
    status: MatchSuggestionStatus
  ): "ACTIVE" | "PENDING" | "HISTORY" => {
    switch (status) {
      case "DRAFT":
      case "AWAITING_MATCHMAKER_APPROVAL":
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return "PENDING";

      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
      case "MATCH_DECLINED":
      case "ENDED_AFTER_FIRST_DATE":
      case "ENGAGED":
      case "MARRIED":
      case "EXPIRED":
      case "CLOSED":
      case "CANCELLED":
        return "HISTORY";

      default:
        return "ACTIVE";
    }
  };
  // Handle status change
  const handleStatusChange = async (
    suggestionId: string,
    newStatus: MatchSuggestionStatus,
    notes?: string
  ) => {
    try {
      console.log(
        `Updating status for ${suggestionId} to ${newStatus}`,
        notes ? `with notes: ${notes}` : ""
      );

      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/status`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            status: newStatus,
            notes: notes || `סטטוס שונה מממשק ניהול הצעות`,
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Status update API error:", errorData);
        throw new Error(
          errorData.error ||
            `Failed to update status: ${response.status} ${response.statusText}`
        );
      }

      const data = await response.json();
      console.log("Status update success:", data);

      toast.success("סטטוס ההצעה עודכן בהצלחה");

      // עדכון רשימת ההצעות ללא צורך בטעינה מחדש
      setSuggestions((prevSuggestions) =>
        prevSuggestions.map((suggestion) =>
          suggestion.id === suggestionId
            ? {
                ...suggestion,
                status: newStatus,
                // עדכון קטגוריית ההצעה בהתאם לסטטוס החדש
                category: getCategoryFromStatus(newStatus),
                lastActivity: new Date().toISOString(),
                lastStatusChange: new Date().toISOString(),
                previousStatus: suggestion.status,
              }
            : suggestion
        )
      );
    } catch (error) {
      console.error("Error updating suggestion status:", error);
      toast.error(
        `שגיאה בעדכון סטטוס ההצעה: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Handle dialog actions
  const handleDialogAction = (action: string, data?: DialogActionData) => {
    console.log(`Dialog action: ${action}`, data);

    switch (action) {
      case "changeStatus":
        if (data?.suggestionId && data?.newStatus) {
          handleStatusChange(data.suggestionId, data.newStatus, data?.notes);
        }
        setSelectedSuggestion(null);
        break;
      case "delete":
        setConfirmAction({
          type: "delete",
          data: { suggestionId: data?.suggestionId as string },
        });
        setShowConfirmDialog(true);
        setSelectedSuggestion(null);
        break;
      case "message":
        // פתיחת טופס שליחת הודעה
        if (data?.suggestion) {
          setSelectedSuggestion(data.suggestion);
          setShowMessageForm(true);
          setMessageRecipient(data.partyType || "both");
        }
        break;
      case "edit":
        // פתיחת טופס עריכה
        if (data?.suggestion) {
          setSelectedSuggestion(data.suggestion);
          setShowEditForm(true);
        } else if (data?.suggestionId) {
          // מצב שבו יש רק מזהה הצעה
          const suggestion = suggestions.find(
            (s) => s.id === data.suggestionId
          );
          if (suggestion) {
            setSelectedSuggestion(suggestion);
            setShowEditForm(true);
          }
        }
        break;
      case "contact":
      case "reminder":
        if (data?.partyType && data?.suggestionId) {
          sendReminder(data.suggestionId, data.partyType);
        }
        break;
      case "sendReminder":
        if (data?.suggestionId && data?.type) {
          sendReminder(
            data.suggestionId,
            data.type as "first" | "second" | "both"
          );
        }
        break;
      case "resendToAll":
        if (data?.suggestionId) {
          resendSuggestion(data.suggestionId, "both");
        }
        break;
      case "export":
      case "exportHistory":
        toast.info("פונקציונליות ייצוא בפיתוח");
        break;
      case "scheduleMeeting":
        toast.info("פונקציונליות תיאום פגישה בפיתוח");
        break;
      case "shareContacts":
        if (data?.suggestionId) {
          setConfirmAction({
            type: "shareContacts",
            data: { suggestionId: data.suggestionId },
          });
          setShowConfirmDialog(true);
        }
        break;
    }
  };
  const handleUpdateSuggestion = async (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => {
    try {
      const response = await fetch(`/api/suggestions/${data.suggestionId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data.updates),
      });

      if (!response.ok) throw new Error("Failed to update suggestion");

      toast.success("פרטי ההצעה עודכנו בהצלחה");

      // Update suggestions list without refetching
      setSuggestions((prevSuggestions) =>
        prevSuggestions.map((s) =>
          s.id === data.suggestionId ? { ...s, ...data.updates } : s
        )
      );

      setShowEditForm(false);
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    }
  };

  // Handle sending message
  const handleSendMessage = async (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => {
    try {
      // שימוש בנתיב API הנכון
      const response = await fetch(
        `/api/matchmaker/suggestions/${data.suggestionId}/message`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            partyType: data.partyType,
            messageType: data.messageType,
            content: data.messageContent,
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send message");
      }

      toast.success("ההודעה נשלחה בהצלחה");
      setShowMessageForm(false);
      fetchSuggestions(); // רענון נתונים לאחר שליחת הודעה
    } catch (error) {
      console.error("Error sending message:", error);
      toast.error(
        `שגיאה בשליחת ההודעה: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Send reminder function
  const sendReminder = async (
    suggestionId: string,
    partyType: "first" | "second" | "both" = "both" // Default value
  ) => {
    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/remind`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ partyType }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send reminder");
      }

      toast.success(
        `תזכורת נשלחה ${
          partyType === "first"
            ? "לצד א'"
            : partyType === "second"
            ? "לצד ב'"
            : "לשני הצדדים"
        }`
      );
    } catch (error) {
      console.error("Error sending reminder:", error);
      toast.error(
        `שגיאה בשליחת התזכורת: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Resend suggestion function
  const resendSuggestion = async (
    suggestionId: string,
    partyType: "first" | "second" | "both"
  ) => {
    try {
      const response = await fetch(`/api/suggestions/${suggestionId}/resend`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ partyType }),
      });

      if (!response.ok) throw new Error("Failed to resend suggestion");

      toast.success(
        `ההצעה נשלחה מחדש ${
          partyType === "first"
            ? "לצד א'"
            : partyType === "second"
            ? "לצד ב'"
            : "לשני הצדדים"
        }`
      );
      fetchSuggestions();
    } catch (error) {
      console.error("Error resending suggestion:", error);
      toast.error("שגיאה בשליחת ההצעה מחדש");
    }
  };

  // Share contact details function
  const shareContactDetails = async (suggestionId: string) => {
    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/share-contact`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to share contact details");
      }

      toast.success("פרטי הקשר שותפו בהצלחה בין שני הצדדים");
      fetchSuggestions(); // רענון הנתונים לאחר שיתוף פרטי קשר
    } catch (error) {
      console.error("Error sharing contact details:", error);
      toast.error(
        `שגיאה בשיתוף פרטי הקשר: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Handle confirm dialog actions
  const handleConfirmAction = async () => {
    if (!confirmAction) return;

    try {
      switch (confirmAction.type) {
        case "delete":
          const deleteResponse = await fetch(
            `/api/suggestions/${confirmAction.data.suggestionId}/delete`,
            {
              method: "DELETE",
            }
          );

          if (!deleteResponse.ok)
            throw new Error("Failed to delete suggestion");

          handleSuggestionDeleted(confirmAction.data.suggestionId);
          break;
        case "contact":
          await sendReminder(
            confirmAction.data.suggestionId,
            confirmAction.data.partyType || "both" // Provide a default value
          );
          break;
        case "resend":
          await resendSuggestion(confirmAction.data.suggestionId, "both");
          break;
        case "shareContacts":
          await shareContactDetails(confirmAction.data.suggestionId);
          break;
      }
    } catch (error) {
      console.error(`Error processing ${confirmAction.type} action:`, error);
      toast.error(`שגיאה בביצוע הפעולה: ${confirmAction.type}`);
    } finally {
      setShowConfirmDialog(false);
      setConfirmAction(null);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6 rtl matchmaker-dashboard">
      <div className="container mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4 justify-end">
            <Badge variant="outline" className="text-sm">
              {suggestions.length} הצעות
            </Badge>
            <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
          </div>

          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={isRefreshing}
            >
              <RefreshCw
                className={`w-4 h-4 mr-2 ${isRefreshing ? "animate-spin" : ""}`}
              />
              {isRefreshing ? "מעדכן..." : "רענן נתונים"}
            </Button>

            <Button variant="outline" size="sm" onClick={handleExport}>
              <Download className="w-4 h-4 mr-2" />
              ייצוא
            </Button>

            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowMonthlyTrendDialog(true)}
            >
              <BarChart className="w-4 h-4 mr-2" />
              מגמה חודשית
            </Button>

            <Button onClick={() => setShowNewSuggestion(true)}>
              <Plus className="w-4 h-4 mr-2" />
              הצעה חדשה
            </Button>
          </div>
        </div>

        {/* Stats Overview */}
        <SuggestionsStats
          suggestions={suggestions}
          className="mb-6"
          onFilterChange={(filter) => {
            if (filter) {
              setFilters((currentFilters) => ({
                ...currentFilters,
                ...filter,
              }));
            }
          }}
        />

        {/* Main Content */}
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <div className="flex items-center justify-between mb-6">
            <TabsList dir="rtl" className="flex-row-reverse">
              <TabsTrigger value="pending">ממתין לאישור</TabsTrigger>
              <TabsTrigger value="active">הצעות פעילות</TabsTrigger>
              <TabsTrigger value="history">היסטוריה</TabsTrigger>
            </TabsList>
          </div>

          {/* Action Bar */}
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
            totalCount={suggestions.length}
            activeCount={activeCount}
            pendingCount={pendingCount}
            historyCount={historyCount}
          />

          {/* Loading State */}
          {isLoading ? (
            <div className="flex items-center justify-center h-64">
              <div className="text-gray-500">טוען...</div>
            </div>
          ) : (
            <>
              {/* Suggestions Lists */}
              <TabsContent value="pending">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "PENDING")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "PENDING").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות ממתינות</p>
                  </div>
                )}
              </TabsContent>

              <TabsContent value="active">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "ACTIVE")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "ACTIVE").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות פעילות</p>
                  </div>
                )}
              </TabsContent>

              <TabsContent value="history">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "HISTORY")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "HISTORY").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות בהיסטוריה</p>
                  </div>
                )}
              </TabsContent>
            </>
          )}
        </Tabs>
      </div>

      {/* New Suggestion Form */}
      <NewSuggestionForm
        isOpen={showNewSuggestion}
        onClose={() => setShowNewSuggestion(false)}
        candidates={[]}
        onSubmit={handleNewSuggestion}
      />

      {/* Suggestion Details Dialog */}
      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleDialogAction}
      />

      {/* Monthly Trend Dialog */}
      <Dialog
        open={showMonthlyTrendDialog}
        onOpenChange={setShowMonthlyTrendDialog}
      >
        <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>מגמה חודשית</DialogTitle>
            <DialogDescription>ניתוח מגמות הצעות לאורך זמן</DialogDescription>
          </DialogHeader>

          <div className="p-4">
            <MonthlyTrendModal suggestions={suggestions} />
          </div>

          <DialogFooter>
            <Button onClick={() => setShowMonthlyTrendDialog(false)}>
              סגור
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Confirm Action Dialog */}
      {showConfirmDialog && (
        <AlertDialog>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
              <AlertDialogDescription>
                {confirmAction?.type === "delete" &&
                  "פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה."}
                {confirmAction?.type === "contact" &&
                  "האם לשלוח תזכורת למועמד לגבי ההצעה?"}
                {confirmAction?.type === "resend" &&
                  "האם לשלוח את ההצעה מחדש לשני הצדדים?"}
                {confirmAction?.type === "shareContacts" &&
                  "האם לשתף את פרטי הקשר בין שני הצדדים?"}
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel onClick={() => setShowConfirmDialog(false)}>
                ביטול
              </AlertDialogCancel>
              <AlertDialogAction
                onClick={() => {
                  handleConfirmAction();
                  setShowConfirmDialog(false);
                }}
                className={
                  confirmAction?.type === "delete"
                    ? "bg-red-600 hover:bg-red-700"
                    : ""
                }
              >
                {confirmAction?.type === "delete" ? "מחק" : "אשר"}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}

      {/* Edit Suggestion Form */}
      <EditSuggestionForm
        isOpen={showEditForm}
        onClose={() => setShowEditForm(false)}
        suggestion={selectedSuggestion}
        onSave={handleUpdateSuggestion}
      />

      {/* Message Form */}
      <MessageForm
        isOpen={showMessageForm}
        onClose={() => setShowMessageForm(false)}
        suggestion={selectedSuggestion}
        onSend={handleSendMessage}
      />
    </div>
  );
}


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\MonthlyTrendModal.tsx:
==================================================
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface MonthlyTrendModalProps {
  suggestions: Suggestion[];
}

interface MonthlyData {
  month: string;
  year: number;
  count: number;
  active: number;
  pending: number;
  success: number;
  declined: number;
}

const MonthlyTrendModal: React.FC<MonthlyTrendModalProps> = ({
  suggestions,
}) => {
  // Group suggestions by month to prepare data for chart
  const monthlyData = useMemo(() => {
    const data = suggestions.reduce((acc, s) => {
      const createdDate = new Date(s.createdAt);
      const month = createdDate.getMonth();
      const year = createdDate.getFullYear();
      const key = `${year}-${month + 1}`;

      if (!acc[key]) {
        acc[key] = {
          month: new Date(year, month).toLocaleString("he", {
            month: "short",
          }),
          year: year,
          count: 0,
          active: 0,
          pending: 0,
          success: 0,
          declined: 0,
        };
      }

      acc[key].count += 1;

      if (s.category === "ACTIVE") acc[key].active += 1;
      if (s.category === "PENDING") acc[key].pending += 1;
      if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
      if (
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
      ) {
        acc[key].declined += 1;
      }

      return acc;
    }, {} as Record<string, MonthlyData>);

    // Convert to array and sort by date
    return Object.values(data).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      const monthA = new Date(
        a.year,
        a.month === "ינו" ? 0 : new Date(`1 ${a.month} 2000`).getMonth()
      ).getMonth();
      const monthB = new Date(
        b.year,
        b.month === "ינו" ? 0 : new Date(`1 ${b.month} 2000`).getMonth()
      ).getMonth();
      return monthA - monthB;
    });
  }, [suggestions]);

  // Calculate trends
  const trends = useMemo(() => {
    if (monthlyData.length < 2)
      return { active: 0, pending: 0, success: 0, total: 0 };

    const current = monthlyData[monthlyData.length - 1];
    const previous = monthlyData[monthlyData.length - 2];

    const calculateTrend = (current: number, previous: number) => {
      if (previous === 0) return current > 0 ? 100 : 0;
      return Math.round(((current - previous) / previous) * 100);
    };

    return {
      active: calculateTrend(current.active, previous.active),
      pending: calculateTrend(current.pending, previous.pending),
      success: calculateTrend(current.success, previous.success),
      total: calculateTrend(current.count, previous.count),
    };
  }, [monthlyData]);

  if (monthlyData.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        <p>אין מספיק נתונים להצגת מגמה חודשית</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Summary stats */}
      <div className="grid grid-cols-4 gap-3">
        <Card className="p-3">
          <div className="text-sm text-gray-500"> סך כל ההצעות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].count}
            <span
              className={`text-xs ml-2 ${
                trends.total >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.total > 0 ? "+" : ""}
              {trends.total}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות פעילות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].active}
            <span
              className={`text-xs ml-2 ${
                trends.active >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.active > 0 ? "+" : ""}
              {trends.active}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">ממתינות לאישור</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].pending}
            <span
              className={`text-xs ml-2 ${
                trends.pending >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.pending > 0 ? "+" : ""}
              {trends.pending}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות מוצלחות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].success}
            <span
              className={`text-xs ml-2 ${
                trends.success >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.success > 0 ? "+" : ""}
              {trends.success}%
            </span>
          </div>
        </Card>
      </div>

      {/* Main chart */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={monthlyData}
              margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip
                formatter={(value) => [`${value} הצעות`, ""]}
                labelFormatter={(label) => `חודש ${label}`}
              />
              <Legend />
              <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
              <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
              <Bar dataKey="success" name="הצלחות" fill="#10B981" />
              <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* Monthly breakdown table */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">פירוט חודשי</h3>
        <div className="overflow-x-auto">
          <table className="w-full border-collapse">
            <thead>
              <tr className="bg-gray-50">
                <th className="p-2 border text-right">חודש</th>
                <th className="p-2 border text-center">סך הכל</th>
                <th className="p-2 border text-center">פעילות</th>
                <th className="p-2 border text-center">ממתינות</th>
                <th className="p-2 border text-center">הצלחות</th>
                <th className="p-2 border text-center">נדחו</th>
              </tr>
            </thead>
            <tbody>
              {monthlyData
                .slice()
                .reverse()
                .map((month, idx) => (
                  <tr
                    key={idx}
                    className={idx % 2 === 0 ? "bg-white" : "bg-gray-50"}
                  >
                    <td className="p-2 border font-medium">
                      {month.month} {month.year}
                    </td>
                    <td className="p-2 border text-center">{month.count}</td>
                    <td className="p-2 border text-center">{month.active}</td>
                    <td className="p-2 border text-center">{month.pending}</td>
                    <td className="p-2 border text-center">{month.success}</td>
                    <td className="p-2 border text-center">{month.declined}</td>
                  </tr>
                ))}
            </tbody>
          </table>
        </div>
      </Card>
    </div>
  );
};

export default MonthlyTrendModal;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx:
==================================================
import React, { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { DatePicker } from "@/components/ui/date-picker";
import {
  Search,
  Filter,
  X,
  Calendar,
  User,
  Clock,
  ChevronDown,
  AlertCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import type { SuggestionFilters, SortByOption } from "@/types/suggestions";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: SuggestionFilters;
  onFiltersChange: (filters: SuggestionFilters) => void;
  totalCount: number;
  activeCount: number;
  pendingCount: number;
  historyCount: number;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
  totalCount,
  activeCount,
  pendingCount,
  historyCount,
}) => {
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const activeFilters = Object.keys(filters).length;
  const [dateRange, setDateRange] = useState<{
    from: Date | undefined;
    to: Date | undefined;
  }>({
    from: filters.dateRange?.start,
    to: filters.dateRange?.end,
  });

  const handleRemoveFilter = (key: keyof SuggestionFilters) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  const handleDateRangeChange = (range: {
    from: Date | undefined;
    to: Date | undefined;
  }) => {
    setDateRange(range);
    if (range.from) {
      onFiltersChange({
        ...filters,
        dateRange: {
          start: range.from,
          end: range.to || new Date(),
        },
      });
    } else {
      const newFilters = { ...filters };
      delete newFilters.dateRange;
      onFiltersChange(newFilters);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return <Clock className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_APPROVED":
      case "SECOND_PARTY_APPROVED":
        return <CheckCircle className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
        return <XCircle className="h-4 w-4 ml-1" />;
      default:
        return <AlertCircle className="h-4 w-4 ml-1" />;
    }
  };

  return (
    <div className="space-y-4 mb-6">
      {/* Main filters and search */}
      <div className="flex items-center gap-4">
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות לפי שם, עיר או כל מידע אחר..."
            className="pl-10 text-right pr-10"
          />
        </div>

        <Select
          value={filters.priority?.[0] || "all"}
          onValueChange={(value) =>
            onFiltersChange({
              ...filters,
              priority: value === "all" ? undefined : [value as Priority],
            })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">כל העדיפויות</SelectItem>
            <SelectItem value={Priority.URGENT}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-red-500"></span>
                דחוף
              </div>
            </SelectItem>
            <SelectItem value={Priority.HIGH}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-orange-500"></span>
                גבוהה
              </div>
            </SelectItem>
            <SelectItem value={Priority.MEDIUM}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-blue-500"></span>
                רגילה
              </div>
            </SelectItem>
            <SelectItem value={Priority.LOW}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-gray-500"></span>
                נמוכה
              </div>
            </SelectItem>
          </SelectContent>
        </Select>

        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" className="flex items-center">
              <Calendar className="h-4 w-4 ml-2" />
              <span>טווח זמן</span>
              <ChevronDown className="h-4 w-4 mr-2" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-4" align="end">
            <div className="space-y-2">
              <h4 className="font-medium">בחר טווח תאריכים</h4>
              <DatePicker
                onChange={handleDateRangeChange}
                value={dateRange}
                isRange={true}
              />
              <div className="flex justify-end mt-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() =>
                    handleDateRangeChange({ from: undefined, to: undefined })
                  }
                >
                  נקה
                </Button>
              </div>
            </div>
          </PopoverContent>
        </Popover>

        <Button
          variant={showAdvancedFilters ? "default" : "outline"}
          onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
        >
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Stats Row */}
      <div className="flex justify-between bg-slate-50 rounded-md p-3">
        <div className="flex items-center gap-6">
          <div className="flex items-center">
            <Badge variant="outline" className="rounded-full px-2 py-0 mr-2">
              {totalCount}
            </Badge>
            <span className="text-sm font-medium">סה״כ הצעות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="default" className="rounded-full px-2 py-0 mr-2">
              {activeCount}
            </Badge>
            <span className="text-sm font-medium">פעילות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="warning" className="rounded-full px-2 py-0 mr-2">
              {pendingCount}
            </Badge>
            <span className="text-sm font-medium">ממתינות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="secondary" className="rounded-full px-2 py-0 mr-2">
              {historyCount}
            </Badge>
            <span className="text-sm font-medium">היסטוריה</span>
          </div>
        </div>

        {activeFilters > 0 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה את כל המסננים ({activeFilters})
          </Button>
        )}
      </div>

      {/* Advanced Filters */}
      {showAdvancedFilters && (
        <div className="bg-slate-50 p-4 rounded-md space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="font-medium">מסננים מתקדמים</h3>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 px-2"
              onClick={() => setShowAdvancedFilters(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Status Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">סטטוס</h4>
              <div className="space-y-2">
                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-first"
                    checked={filters.status?.includes("PENDING_FIRST_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_FIRST_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_FIRST_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-first"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-yellow-600" />
                    ממתין לתשובת צד א׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-second"
                    checked={filters.status?.includes("PENDING_SECOND_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_SECOND_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_SECOND_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-second"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-blue-600" />
                    ממתין לתשובת צד ב׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-approved"
                    checked={
                      filters.status?.includes("FIRST_PARTY_APPROVED") ||
                      filters.status?.includes("SECOND_PARTY_APPROVED")
                    }
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "FIRST_PARTY_APPROVED",
                          "SECOND_PARTY_APPROVED",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) =>
                              s !== "FIRST_PARTY_APPROVED" &&
                              s !== "SECOND_PARTY_APPROVED"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-approved"
                    className="text-sm mr-2 flex items-center"
                  >
                    <CheckCircle className="h-3 w-3 ml-1 text-green-600" />
                    אושר ע״י אחד הצדדים
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-dating"
                    checked={filters.status?.includes("DATING")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [...(filters.status || []), "DATING"];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "DATING"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-dating"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Calendar className="h-3 w-3 ml-1 text-pink-600" />
                    בתהליך היכרות
                  </label>
                </div>
              </div>
            </div>

            {/* User Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">משתתפים</h4>
              <Select
                value={filters.userId || "all"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    userId: value === "all" ? undefined : value,
                  })
                }
              >
                <SelectTrigger>
                  <User className="h-4 w-4 ml-1" />
                  <SelectValue placeholder="בחר משתתף" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">כל המשתתפים</SelectItem>
                  {/* Replace with dynamic user data */}
                  <SelectItem value="user1">ישראל ישראלי</SelectItem>
                  <SelectItem value="user2">שרה כהן</SelectItem>
                  <SelectItem value="user3">דוד לוי</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Sort By */}
            <div>
              <h4 className="text-sm font-medium mb-2">מיון לפי</h4>
              <Select
                value={filters.sortBy || "lastActivity"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    sortBy: value as SortByOption, // Cast to SortByOption
                  })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="מיון לפי" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="lastActivity">פעילות אחרונה</SelectItem>
                  <SelectItem value="createdAt">תאריך יצירה</SelectItem>
                  <SelectItem value="priority">עדיפות</SelectItem>
                  <SelectItem value="decisionDeadline">תאריך יעד</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      )}

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2 flex-wrap">
          {filters.priority && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                עדיפות:{" "}
                {filters.priority[0] === "URGENT"
                  ? "דחוף"
                  : filters.priority[0] === "HIGH"
                  ? "גבוהה"
                  : filters.priority[0] === "MEDIUM"
                  ? "רגילה"
                  : "נמוכה"}
              </span>
              <button
                onClick={() => handleRemoveFilter("priority")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.dateRange && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                תאריך:{" "}
                {new Date(filters.dateRange.start).toLocaleDateString("he-IL")}
                {filters.dateRange.end &&
                  ` - ${new Date(filters.dateRange.end).toLocaleDateString(
                    "he-IL"
                  )}`}
              </span>
              <button
                onClick={() => handleRemoveFilter("dateRange")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.status && filters.status.length > 0 && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                סטטוס:{" "}
                {filters.status.length === 1
                  ? ""
                  : `(${filters.status.length})`}
                {filters.status.length === 1 && (
                  <span className="flex items-center">
                    {getStatusIcon(filters.status[0])}
                    {filters.status[0] === "PENDING_FIRST_PARTY"
                      ? "ממתין לצד א׳"
                      : filters.status[0] === "PENDING_SECOND_PARTY"
                      ? "ממתין לצד ב׳"
                      : filters.status[0]}
                  </span>
                )}
              </span>
              <button
                onClick={() => handleRemoveFilter("status")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.userId && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>משתתף מסוים</span>
              <button
                onClick={() => handleRemoveFilter("userId")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx:
==================================================
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  Users,
  CheckCircle,
  Clock,
  Calendar,
  AlertCircle,
  Ban,
  X,
} from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion, SuggestionFilters } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  onClick?: () => void;
  isClickable?: boolean;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
  onFilterChange?: (filter: Partial<SuggestionFilters>) => void;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
  onClick,
  isClickable = false,
}) => (
  <Card
    className={`p-4 ${className} ${
      isClickable ? "cursor-pointer hover:shadow-md transition-shadow" : ""
    }`}
    onClick={onClick}
  >
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value > 0 ? "+" : ""}
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
  onFilterChange,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter((s) => s.category === "ACTIVE").length;
    const pending = suggestions.filter((s) => s.category === "PENDING").length;
    const history = suggestions.filter((s) => s.category === "HISTORY").length;

    const approvedByFirst = suggestions.filter(
      (s) => s.status === "FIRST_PARTY_APPROVED"
    ).length;
    const approvedBySecond = suggestions.filter(
      (s) => s.status === "SECOND_PARTY_APPROVED"
    ).length;
    const declined = suggestions.filter(
      (s) =>
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
    ).length;
    const expired = suggestions.filter((s) => s.status === "EXPIRED").length;
    const dating = suggestions.filter((s) => s.status === "DATING").length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Group suggestions by month
    const monthlyData = suggestions.reduce(
      (acc, s) => {
        const month = new Date(s.createdAt).getMonth();
        const year = new Date(s.createdAt).getFullYear();
        const key = `${year}-${month + 1}`;

        if (!acc[key]) {
          acc[key] = {
            month: new Date(year, month).toLocaleString("he", {
              month: "short",
            }),
            year: year,
            count: 0,
            active: 0,
            pending: 0,
            success: 0,
            declined: 0,
          };
        }

        acc[key].count += 1;

        if (s.category === "ACTIVE") acc[key].active += 1;
        if (s.category === "PENDING") acc[key].pending += 1;
        if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
        if (
          s.status === "FIRST_PARTY_DECLINED" ||
          s.status === "SECOND_PARTY_DECLINED"
        ) {
          acc[key].declined += 1;
        }

        return acc;
      },
      {} as Record<
        string,
        {
          month: string;
          year: number;
          count: number;
          active: number;
          pending: number;
          success: number;
          declined: number;
        }
      >
    );

    // Convert to array and sort by date
    const monthlyArray = Object.values(monthlyData).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      return a.month.localeCompare(b.month);
    });

    // Calculate trends
    const calculateTrend = (currentValue: number, previousValue: number) => {
      if (previousValue === 0) return currentValue > 0 ? 100 : 0;
      return Math.round(((currentValue - previousValue) / previousValue) * 100);
    };

    // Calculate success rate
    const successRate = total > 0 ? Math.round((success / total) * 100) : 0;

    // Get current month stats vs previous month for trend
    let activeTrend = 0;
    let pendingTrend = 0;
    let successTrend = 0;

    if (monthlyArray.length >= 2) {
      const currentMonth = monthlyArray[monthlyArray.length - 1];
      const previousMonth = monthlyArray[monthlyArray.length - 2];

      activeTrend = calculateTrend(currentMonth.active, previousMonth.active);
      pendingTrend = calculateTrend(
        currentMonth.pending,
        previousMonth.pending
      );
      successTrend = calculateTrend(
        currentMonth.success,
        previousMonth.success
      );
    }

    return {
      total,
      active,
      pending,
      history,
      approvedByFirst,
      approvedBySecond,
      declined,
      expired,
      dating,
      success,
      successRate,
      byStatus,
      monthlyData: monthlyArray,
      trends: {
        active: activeTrend,
        pending: pendingTrend,
        success: successTrend,
      },
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() => onFilterChange && onFilterChange({})}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: [
                "DATING",
                "FIRST_PARTY_APPROVED",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            })
          }
        />
        <StatsCard
          icon={Clock}
          title="ממתינות לתגובה"
          value={stats.pending}
          trend={{
            value: stats.trends.pending,
            isPositive: stats.trends.pending >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY"],
            })
          }
        />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${stats.successRate}%`}
          trend={{
            value: stats.trends.success,
            isPositive: stats.trends.success >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING", "ENGAGED", "MARRIED"],
            })
          }
        />
      </div>

      {/* Action Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-3 mt-4">
        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-yellow-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-yellow-600" />
            <div className="text-xs">ממתין לצד א׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_FIRST_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-blue-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_SECOND_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-blue-600" />
            <div className="text-xs">ממתין לצד ב׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_SECOND_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-red-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <X className="w-4 h-4 text-red-600" />
            <div className="text-xs">הצעות שנדחו</div>
            <div className="font-bold ml-auto">{stats.declined}</div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-pink-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Calendar className="w-4 h-4 text-pink-600" />
            <div className="text-xs">בתהליך היכרות</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["DATING"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-gray-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["EXPIRED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Ban className="w-4 h-4 text-gray-600" />
            <div className="text-xs">פג תוקף</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["EXPIRED"] || 0}
            </div>
          </div>
        </Card>
      </div>

      {/* מגמה חודשית נשארת כאן אבל עכשיו היא מוצגת בדיאלוג מודלי */}
      <div className="hidden">
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={stats.monthlyData}
                margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip
                  formatter={(value) => [`${value} הצעות`, ""]}
                  labelFormatter={(label) => `חודש ${label}`}
                />
                <Legend />
                <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
                <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
                <Bar dataKey="success" name="הצלחות" fill="#10B981" />
                <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx:
==================================================
// SuggestionDetailsDialog.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ProfileCard } from "@/app/components/shared/shared/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  AlertCircle,
  CheckCircle,
  XCircle,
  MessageCircle,
  Send,
  RefreshCw,
  Edit,
  Calendar,
  Clock,
  Download,
  AlarmClock,
  Trash2,
  MapPin,
  Mail,
  Phone,
  User,
  ExternalLink,
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { MatchSuggestionStatus } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";
import Image from "next/image";

interface DialogActionData extends ActionAdditionalData {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyId?: string;
  type?: string;
  partyType?: "first" | "second" | "both";
}

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  onAction: (action: string, data?: DialogActionData) => void;
}

// Map status to its display info
const getStatusInfo = (status: MatchSuggestionStatus) => {
  const statusMap: Record<
    string,
    { label: string; icon: React.ElementType; color: string }
  > = {
    DRAFT: { label: "טיוטה", icon: Edit, color: "text-gray-600" },
    PENDING_FIRST_PARTY: {
      label: "ממתין לתשובת צד א׳",
      icon: Clock,
      color: "text-yellow-600",
    },
    FIRST_PARTY_APPROVED: {
      label: "צד א׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    FIRST_PARTY_DECLINED: {
      label: "צד א׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    PENDING_SECOND_PARTY: {
      label: "ממתין לתשובת צד ב׳",
      icon: Clock,
      color: "text-blue-600",
    },
    SECOND_PARTY_APPROVED: {
      label: "צד ב׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    SECOND_PARTY_DECLINED: {
      label: "צד ב׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    AWAITING_MATCHMAKER_APPROVAL: {
      label: "ממתין לאישור שדכן",
      icon: AlertCircle,
      color: "text-purple-600",
    },
    CONTACT_DETAILS_SHARED: {
      label: "פרטי קשר שותפו",
      icon: Send,
      color: "text-purple-600",
    },
    AWAITING_FIRST_DATE_FEEDBACK: {
      label: "ממתין למשוב פגישה",
      icon: MessageCircle,
      color: "text-orange-600",
    },
    DATING: {
      label: "בתהליך היכרות",
      icon: Calendar,
      color: "text-pink-600",
    },
    EXPIRED: { label: "פג תוקף", icon: AlarmClock, color: "text-gray-600" },
    CLOSED: { label: "סגור", icon: XCircle, color: "text-gray-600" },
  };
  return (
    statusMap[status] || {
      label: status as string,
      icon: AlertCircle as React.ElementType,
      color: "text-gray-600",
    }
  );
};

// Status groups for the progress indicator
const statusGroups = [
  ["DRAFT", "PENDING_FIRST_PARTY"],
  ["FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY"],
  ["SECOND_PARTY_APPROVED", "AWAITING_MATCHMAKER_APPROVAL"],
  ["CONTACT_DETAILS_SHARED", "AWAITING_FIRST_DATE_FEEDBACK"],
  ["DATING", "ENGAGED", "MARRIED"],
];
// הוספת מיפוי מלא של כל הסטטוסים האפשריים
const getAllStatusLabels = () => {
  // יצירת מיפוי של כל הסטטוסים האפשריים לפי הסכמה
  const statusLabels: Record<MatchSuggestionStatus, string> = {
    DRAFT: "טיוטה",
    PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
    FIRST_PARTY_APPROVED: "צד א׳ אישר",
    FIRST_PARTY_DECLINED: "צד א׳ דחה",
    PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
    SECOND_PARTY_APPROVED: "צד ב׳ אישר",
    SECOND_PARTY_DECLINED: "צד ב׳ דחה",
    AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
    CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
    AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
    THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
    PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
    ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
    MEETING_PENDING: "ממתין לקביעת פגישה",
    MEETING_SCHEDULED: "פגישה נקבעה",
    MATCH_APPROVED: "ההצעה אושרה",
    MATCH_DECLINED: "ההצעה נדחתה",
    DATING: "בתהליך היכרות",
    ENGAGED: "מאורסים",
    MARRIED: "נישאו",
    EXPIRED: "פג תוקף",
    CLOSED: "סגור",
    CANCELLED: "בוטל",
  };

  return statusLabels;
};
// Helper to determine if a status change is possible
const canChangeStatus = (
  currentStatus: MatchSuggestionStatus
): MatchSuggestionStatus[] => {
  // Status changes that are allowed directly by the matchmaker
  const allowedChanges: Partial<
    Record<MatchSuggestionStatus, MatchSuggestionStatus[]>
  > = {
    // סטטוסים קיימים
    DRAFT: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_FIRST_PARTY: [
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    FIRST_PARTY_APPROVED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    FIRST_PARTY_DECLINED: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_SECOND_PARTY: [
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    SECOND_PARTY_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    SECOND_PARTY_DECLINED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    CONTACT_DETAILS_SHARED: [
      "AWAITING_FIRST_DATE_FEEDBACK",
      "DATING",
      "CANCELLED",
      "CLOSED",
    ],
    AWAITING_FIRST_DATE_FEEDBACK: ["DATING", "CANCELLED", "CLOSED"],
    DATING: ["ENGAGED", "CLOSED"],
    ENGAGED: ["MARRIED", "CLOSED"],
    MARRIED: ["CLOSED"],
    EXPIRED: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY", "CLOSED"],
    CANCELLED: ["DRAFT"],
    CLOSED: [],

    // הוספת הסטטוסים החסרים
    AWAITING_MATCHMAKER_APPROVAL: [
      "CONTACT_DETAILS_SHARED",
      "CANCELLED",
      "CLOSED",
    ],
    THINKING_AFTER_DATE: [
      "PROCEEDING_TO_SECOND_DATE",
      "ENDED_AFTER_FIRST_DATE",
      "CLOSED",
    ],
    PROCEEDING_TO_SECOND_DATE: ["DATING", "CLOSED"],
    ENDED_AFTER_FIRST_DATE: ["CLOSED"],
    MEETING_PENDING: ["MEETING_SCHEDULED", "CANCELLED", "CLOSED"],
    MEETING_SCHEDULED: ["AWAITING_FIRST_DATE_FEEDBACK", "CANCELLED", "CLOSED"],
    MATCH_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    MATCH_DECLINED: ["CLOSED"],
  };

  return allowedChanges[currentStatus] || [];
};

const formatDateSafely = (
  dateInput: Date | string | null | undefined
): string => {
  if (!dateInput) return "לא נקבע";

  // Ensure we're working with a Date object
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;

  // Validate that the date is valid before formatting
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    return "תאריך לא תקין";
  }

  return new Intl.DateTimeFormat("he-IL", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(date);
};

const getDaysRemaining = (
  deadline: Date | string | null | undefined
): number | null => {
  if (!deadline) return null;

  // Convert string to Date if needed
  const deadlineDate =
    typeof deadline === "string" ? new Date(deadline) : deadline;

  // Validate date
  if (!(deadlineDate instanceof Date) || isNaN(deadlineDate.getTime())) {
    return null;
  }

  const today = new Date();
  const diffTime = deadlineDate.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
};

// Get the status group index for progress indicator
const getStatusGroupIndex = (status: MatchSuggestionStatus): number => {
  for (let i = 0; i < statusGroups.length; i++) {
    if (statusGroups[i].includes(status)) {
      return i;
    }
  }
  return -1;
};

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [statusChangeNote, setStatusChangeNote] = useState("");
  const [newStatus, setNewStatus] = useState<MatchSuggestionStatus | null>(
    null
  );
  const [showStatusChange, setShowStatusChange] = useState(false);

  // Calculate allowed status changes based on current status
  const allowedStatusChanges = suggestion
    ? canChangeStatus(suggestion.status as MatchSuggestionStatus)
    : [];

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  // Handle status change
  const handleStatusChange = async () => {
    if (!newStatus || !suggestion) return;

    setIsLoading(true);
    try {
      console.log(
        `שולח בקשה לשינוי סטטוס: ${newStatus} עם הערות: ${
          statusChangeNote || "ללא הערות"
        }`
      );

      // קריאה לנתיב ה-API הנכון עם הפרמטרים המתאימים
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestion.id}/status`,
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            status: newStatus,
            notes:
              statusChangeNote ||
              `סטטוס שונה ל-${getAllStatusLabels()[newStatus]}`,
          }),
        }
      );

      // בדיקת השגיאות בפורמט מפורט יותר
      if (!response.ok) {
        const errorData = await response.json();
        console.error("Server response:", errorData);
        throw new Error(
          errorData.error ||
            `Failed to update status: ${response.status} ${response.statusText}`
        );
      }

      const responseData = await response.json();
      console.log("Status update response:", responseData);

      // עדכון הצליח - הקפצת הודעת הצלחה
      toast.success("סטטוס ההצעה עודכן בהצלחה");

      // עדכון הקומפוננטה ההורה
      onAction("changeStatus", {
        suggestionId: suggestion.id,
        newStatus,
        notes: statusChangeNote,
      });

      // איפוס מצב הטופס
      setShowStatusChange(false);
      setStatusChangeNote("");
      setNewStatus(null);
    } catch (error) {
      console.error("Error changing status:", error);
      toast.error(
        `שגיאה בעדכון הסטטוס: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  };

  if (!suggestion) return null;

  // Get status display info
  const statusInfo = getStatusInfo(suggestion.status as MatchSuggestionStatus);
  const StatusIcon = statusInfo.icon;

  // Format suggestion dates
  const createdDate = suggestion.createdAt;
  const lastActivityDate = suggestion.lastActivity;
  const decisionDeadlineDate = suggestion.decisionDeadline
    ? suggestion.decisionDeadline
    : null;

  // Days remaining for decision if applicable
  const daysRemaining = decisionDeadlineDate
    ? getDaysRemaining(decisionDeadlineDate)
    : null;

  // Get status progress index for the progress indicator
  const statusGroupIndex = getStatusGroupIndex(
    suggestion.status as MatchSuggestionStatus
  );

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="max-w-6xl max-h-[90vh] flex flex-col p-0"
        style={{ direction: "rtl" }}
      >
        {/* Header with Progress Bar */}
        <div className="bg-gradient-to-r from-slate-50 to-white border-b flex-shrink-0">
          <DialogHeader className="p-6 pb-3">
            <div className="flex items-center justify-between">
              <div>
                <DialogTitle className="text-2xl font-bold">
                  הצעת שידוך #{suggestion.id.toString().split("-")[0]}
                </DialogTitle>
                <DialogDescription className="text-lg mt-1">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} ו
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName}
                </DialogDescription>
              </div>
              <div className="flex items-center gap-3">
                <Badge
                  className={`px-3 py-1.5 ${statusInfo.color} flex items-center gap-1 text-sm shadow-sm`}
                >
                  <StatusIcon className="w-4 h-4" />
                  {statusInfo.label}
                </Badge>
                <Badge
                  variant="outline"
                  className={`px-3 shadow-sm ${
                    suggestion.priority === "URGENT"
                      ? "bg-red-50 text-red-600 border-red-200"
                      : suggestion.priority === "HIGH"
                      ? "bg-orange-50 text-orange-600 border-orange-200"
                      : suggestion.priority === "MEDIUM"
                      ? "bg-blue-50 text-blue-600 border-blue-200"
                      : "bg-gray-50 text-gray-600 border-gray-200"
                  }`}
                >
                  {suggestion.priority === "URGENT"
                    ? "דחוף"
                    : suggestion.priority === "HIGH"
                    ? "עדיפות גבוהה"
                    : suggestion.priority === "MEDIUM"
                    ? "עדיפות רגילה"
                    : "עדיפות נמוכה"}
                </Badge>
              </div>
            </div>
          </DialogHeader>

          {/* Status Progress Indicator */}
          <div className="px-6 pb-4">
            <div className="relative flex items-center justify-between w-full h-3 bg-gray-100 rounded-full mt-4">
              {statusGroupIndex >= 0 && (
                <div
                  className="absolute h-3 bg-gradient-to-r from-blue-400 to-blue-600 rounded-full"
                  style={{
                    width: `${Math.min(
                      ((statusGroupIndex + 1) / statusGroups.length) * 100,
                      100
                    )}%`,
                  }}
                ></div>
              )}
              {statusGroups.map((_, index) => (
                <div
                  key={index}
                  className={`relative z-10 w-6 h-6 rounded-full flex items-center justify-center border-2 ${
                    index <= statusGroupIndex
                      ? "bg-blue-600 border-blue-700 text-white"
                      : "bg-white border-gray-300"
                  }`}
                >
                  {index + 1}
                </div>
              ))}
            </div>
            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
              <span>יצירת הצעה</span>
              <span>אישור ראשוני</span>
              <span>אישור סופי</span>
              <span>שיתוף פרטים</span>
              <span>בתהליך היכרות</span>
            </div>
          </div>
        </div>
        {/* Main Content Area */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex-1 flex flex-col overflow-hidden"
        >
          <TabsList className="px-6 pt-2 border-b justify-end gap-1 flex-shrink-0">
            <TabsTrigger
              value="overview"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              סקירה כללית
            </TabsTrigger>
            <TabsTrigger
              value="firstParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד ראשון
            </TabsTrigger>
            <TabsTrigger
              value="secondParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד שני
            </TabsTrigger>
            <TabsTrigger
              value="timeline"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              ציר זמן
            </TabsTrigger>
            <TabsTrigger
              value="communication"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              תקשורת
            </TabsTrigger>
            <TabsTrigger
              value="actions"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              פעולות
            </TabsTrigger>
          </TabsList>

          <div className="flex-1 overflow-y-auto">
            {/* Overview Tab */}

            <TabsContent
              value="overview"
              className="p-0 m-0 h-full overflow-auto"
            >
              <div className="p-6">
                {/* שינוי 1: שינוי המבנה כך שפרטי ההצעה יהיו בחלק העליון ושני הצדדים יהיו זה לצד זה */}
                <div className="space-y-3">
                  {/* פרטי הצעה - עיצוב מסודר וקומפקטי */}
                  <div className="bg-white rounded-xl shadow-sm border p-4 mb-3 hover:shadow-md transition-shadow">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="text-md font-semibold flex items-center">
                        <Calendar className="w-4 h-4 ml-1 text-blue-600" />
                        פרטי הצעה
                      </h3>
                      <Badge
                        className={`${statusInfo.color} px-2 py-0.5 text-xs`}
                      >
                        <StatusIcon className="w-3 h-3 ml-1" />
                        {statusInfo.label}
                      </Badge>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">תאריך יצירה:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(createdDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">עדכון אחרון:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(lastActivityDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">שדכן:</span>
                        <span className="font-medium mr-1">
                          {`${suggestion.matchmaker?.firstName} ${suggestion.matchmaker?.lastName}`}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">דחיפות:</span>
                        <span
                          className={`font-medium mr-1 ${
                            suggestion.priority === "URGENT"
                              ? "text-red-600"
                              : suggestion.priority === "HIGH"
                              ? "text-orange-600"
                              : suggestion.priority === "MEDIUM"
                              ? "text-blue-600"
                              : "text-gray-600"
                          }`}
                        >
                          {suggestion.priority === "URGENT"
                            ? "דחוף"
                            : suggestion.priority === "HIGH"
                            ? "עדיפות גבוהה"
                            : suggestion.priority === "MEDIUM"
                            ? "עדיפות רגילה"
                            : "עדיפות נמוכה"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד תגובה:</span>
                        <span className="font-medium mr-1">
                          {suggestion.responseDeadline
                            ? formatDateSafely(suggestion.responseDeadline)
                            : "לא נקבע"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד להחלטה:</span>
                        <span
                          className={
                            daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED"
                              ? "text-red-600 font-medium"
                              : "font-medium"
                          }
                        >
                          {decisionDeadlineDate
                            ? formatDateSafely(decisionDeadlineDate)
                            : "לא נקבע"}
                          {daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED" && (
                              <span className="mr-1 text-red-600 text-xs">
                                (
                                {daysRemaining === 0
                                  ? "היום!"
                                  : `נותרו ${daysRemaining} ימים`}
                                )
                              </span>
                            )}
                        </span>
                      </div>
                    </div>

                    <div className="flex justify-end mt-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowStatusChange(true)}
                        disabled={allowedStatusChanges.length === 0}
                        className="text-blue-600 border-blue-200 hover:bg-blue-50 text-xs py-1 h-7"
                      >
                        <RefreshCw className="w-3 h-3 ml-1" />
                        שנה סטטוס
                      </Button>
                    </div>
                  </div>

                  {/* שינוי 2: כרטיסי הצדדים מסודרים זה לצד זה בגריד עם 2 עמודות */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* First Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-blue-800">
                        <User className="w-5 h-5 ml-2 text-blue-600" />
                        צד א׳: {suggestion.firstParty.firstName}{" "}
                        {suggestion.firstParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.firstParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-blue-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.firstParty.firstName}{" "}
                            {suggestion.firstParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.firstPartySent
                              ? formatDateSafely(suggestion.firstPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "FIRST_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "FIRST_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_FIRST_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "FIRST_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "FIRST_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_FIRST_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.firstPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-blue-50 rounded-lg p-3 text-sm border border-blue-100">
                            {suggestion.firstPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-blue-200 hover:bg-blue-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_FIRST_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-yellow-500 hover:bg-yellow-600"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.firstParty.id,
                                partyType: "first",
                              })
                            }
                          >
                            <AlertCircle className="w-4 h-4 ml-2" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>

                    {/* Second Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-purple-800">
                        <User className="w-5 h-5 ml-2 text-purple-600" />
                        צד ב׳: {suggestion.secondParty.firstName}{" "}
                        {suggestion.secondParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.secondParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-purple-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.secondParty.firstName}{" "}
                            {suggestion.secondParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.secondPartySent
                              ? formatDateSafely(suggestion.secondPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "SECOND_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "SECOND_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_SECOND_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "SECOND_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "SECOND_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_SECOND_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.secondPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-purple-50 rounded-lg p-3 text-sm border border-purple-100">
                            {suggestion.secondPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-purple-200 hover:bg-purple-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_SECOND_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-purple-600 hover:bg-purple-700"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.secondParty.id,
                                partyType: "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* מידע נוסף */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
                    {/* Matching Reason Card */}
                    {suggestion.matchingReason && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <User className="w-5 h-5 ml-2 text-green-600" />
                          סיבת ההתאמה
                        </h3>
                        <div className="bg-green-50 rounded-lg border border-green-100 p-4 text-gray-700">
                          {suggestion.matchingReason}
                        </div>
                      </div>
                    )}

                    {/* Internal Notes */}
                    {suggestion.internalNotes && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <AlertCircle className="w-5 h-5 ml-2 text-amber-600" />
                          הערות פנימיות
                        </h3>
                        <div className="bg-amber-50 rounded-lg border border-amber-100 p-4 text-gray-700">
                          {suggestion.internalNotes}
                        </div>
                      </div>
                    )}

                    {/* Quick Actions */}
                    <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center">
                        <RefreshCw className="w-5 h-5 ml-2 text-gray-600" />
                        פעולות מהירות
                      </h3>

                      <div className="grid grid-cols-2 gap-2">
                        <Button
                          variant="outline"
                          className="justify-start"
                          onClick={() =>
                            onAction("edit", { suggestionId: suggestion.id })
                          }
                        >
                          <Edit className="w-4 h-4 ml-1" />
                          ערוך הצעה
                        </Button>

                        {(suggestion.status === "PENDING_FIRST_PARTY" ||
                          suggestion.status === "PENDING_SECOND_PARTY") && (
                          <Button
                            variant="outline"
                            className="justify-start"
                            onClick={() =>
                              onAction("sendReminder", {
                                suggestionId: suggestion.id,
                                type:
                                  suggestion.status === "PENDING_FIRST_PARTY"
                                    ? "first"
                                    : "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}

                        {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                          suggestion.status === "SECOND_PARTY_APPROVED") && (
                          <Button
                            variant="default"
                            className="justify-start bg-green-600 hover:bg-green-700"
                            onClick={() =>
                              onAction("shareContacts", {
                                suggestionId: suggestion.id,
                              })
                            }
                          >
                            <ExternalLink className="w-4 h-4 ml-1" />
                            שתף פרטי קשר
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* First Party Tab */}
            <TabsContent value="firstParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-blue-800">
                      {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-blue-100 text-blue-700 border-blue-200">
                      צד א׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.firstParty.images.find((img) => img.isMain)
                            ?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-blue-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty?.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.birthDate
                              ? new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-blue-200 hover:bg-blue-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.firstParty.id,
                          partyType: "first",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_FIRST_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד ראשון
                      </Button>
                    )}

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד שני
                      </Button>
                    )}

                    {suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyType: "both",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח בקשת עדכון מפגש
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.firstParty.profile}
                  images={suggestion.firstParty.images}
                  questionnaire={firstPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-blue-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.firstParty.firstName}
                  </h3>
                  {suggestion.firstPartyNotes ? (
                    <p>{suggestion.firstPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Second Party Tab */}
            <TabsContent value="secondParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-purple-800">
                      {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-purple-100 text-purple-700 border-purple-200">
                      צד ב׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.secondParty.images.find(
                            (img) => img.isMain
                          )?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-purple-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.birthDate
                              ? new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-purple-200 hover:bg-purple-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.secondParty.id,
                          partyType: "second",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="flex-1 bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-1" />
                        שלח תזכורת
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.secondParty.profile}
                  images={suggestion.secondParty.images}
                  questionnaire={secondPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-purple-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.secondParty.firstName}
                  </h3>
                  {suggestion.secondPartyNotes ? (
                    <p>{suggestion.secondPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Timeline Tab */}
            <TabsContent value="timeline" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 mb-4">
                  <h3 className="text-lg font-semibold flex items-center">
                    <Calendar className="w-5 h-5 ml-2 text-blue-600" />
                    התקדמות ההצעה
                  </h3>
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="p-2 rounded-full bg-blue-100 mr-2">
                        <Clock className="w-5 h-5 text-blue-600" />
                      </div>
                      <div>
                        <div className="font-medium">
                          נוצר: {formatDateSafely(suggestion.createdAt)}
                        </div>
                        <div className="text-sm text-gray-500">
                          פעילות אחרונה:{" "}
                          {formatDateSafely(suggestion.lastActivity)}
                        </div>
                      </div>
                    </div>
                    <Badge
                      className={`px-3 py-1.5 flex items-center gap-1 ${statusInfo.color}`}
                    >
                      <StatusIcon className="w-4 h-4" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border p-5">
                  <h3 className="text-lg font-semibold mb-4">
                    היסטוריית סטטוסים
                  </h3>

                  <ScrollArea className="h-[400px] pr-4">
                    {isLoading ? (
                      <div className="flex items-center justify-center h-32">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-700"></div>
                      </div>
                    ) : (
                      <Timeline
                        items={(suggestion?.statusHistory || []).map(
                          (history) => ({
                            title: getStatusInfo(
                              history.status as MatchSuggestionStatus
                            ).label,
                            description: history.notes || "אין הערות",
                            date:
                              typeof history.createdAt === "string"
                                ? new Date(history.createdAt)
                                : history.createdAt,
                            icon: history.status.includes("APPROVED")
                              ? CheckCircle
                              : history.status.includes("DECLINED")
                              ? XCircle
                              : history.status.includes("PENDING")
                              ? Clock
                              : AlertCircle,
                            iconColor: history.status.includes("APPROVED")
                              ? "text-green-600"
                              : history.status.includes("DECLINED")
                              ? "text-red-600"
                              : history.status.includes("PENDING")
                              ? "text-yellow-600"
                              : "text-blue-600",
                          })
                        )}
                      />
                    )}
                  </ScrollArea>

                  <div className="mt-4 flex justify-end">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() =>
                        onAction("exportHistory", {
                          suggestionId: suggestion.id,
                        })
                      }
                    >
                      <Download className="w-4 h-4 ml-1" />
                      ייצא היסטוריה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* Communication Tab */}
            <TabsContent value="communication" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-blue-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">תקשורת</h3>
                  <p className="text-gray-600">
                    ניהול התקשורת עם הצדדים השונים בהצעה. שליחת הודעות ותזכורות.
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* First Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-blue-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-blue-600" />
                      תקשורת עם {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full justify-start border-blue-200 hover:bg-blue-50"
                        onClick={() =>
                          onAction("message", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <MessageCircle className="w-4 h-4 ml-2" />
                        שלח הודעה
                      </Button>

                      {suggestion.status === "PENDING_FIRST_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>

                  {/* Second Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-purple-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-purple-600" />
                      תקשורת עם {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full"
                        onClick={() =>
                          onAction("edit", {
                            suggestionId: suggestion.id,
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <Edit className="w-4 h-4 ml-2" />
                        ערוך פרטי הצעה
                      </Button>

                      {suggestion.status === "PENDING_SECOND_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {/* Meeting Arrangement Section */}
                {(suggestion.status === "CONTACT_DETAILS_SHARED" ||
                  suggestion.status === "DATING") && (
                  <div className="mt-6 bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Calendar className="w-5 h-5 ml-2 text-pink-600" />
                      תיאום פגישה
                    </h4>
                    <div className="space-y-3">
                      <p className="text-gray-600">
                        סיוע בתיאום פגישה בין הצדדים ותיעוד מועדי הפגישות
                      </p>
                      <div className="flex gap-2">
                        <Button
                          className="flex-1 bg-pink-600 hover:bg-pink-700"
                          onClick={() =>
                            onAction("scheduleMeeting", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Calendar className="w-4 h-4 ml-2" />
                          תאם פגישה חדשה
                        </Button>
                        <Button
                          variant="outline"
                          className="flex-1"
                          onClick={() =>
                            onAction("viewMeetings", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Clock className="w-4 h-4 ml-2" />
                          צפה בפגישות קודמות
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </TabsContent>

            {/* Actions Tab */}
            <TabsContent value="actions" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-gray-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">פעולות נוספות</h3>
                  <p className="text-gray-600">
                    פעולות נוספות שניתן לבצע על הצעת השידוך
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {/* Status Change */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-blue-100 w-fit mb-3">
                      <RefreshCw className="w-6 h-6 text-blue-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">שינוי סטטוס</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עדכון סטטוס ההצעה בהתאם להתקדמות התהליך
                    </p>
                    <Button
                      className="w-full"
                      onClick={() => setShowStatusChange(true)}
                      disabled={allowedStatusChanges.length === 0}
                    >
                      <RefreshCw className="w-4 h-4 ml-2" />
                      שנה סטטוס
                    </Button>
                  </div>

                  {/* Edit Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-amber-100 w-fit mb-3">
                      <Edit className="w-6 h-6 text-amber-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">עריכת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עריכת פרטי ההצעה, סיבת ההתאמה והערות
                    </p>
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() =>
                        onAction("edit", { suggestionId: suggestion.id })
                      }
                    >
                      <Edit className="w-4 h-4 ml-2" />
                      ערוך פרטי הצעה
                    </Button>
                  </div>

                  {/* Delete Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-red-100 w-fit mb-3">
                      <Trash2 className="w-6 h-6 text-red-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">מחיקת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      מחיקת ההצעה לצמיתות מהמערכת
                    </p>
                    <Button
                      variant="destructive"
                      className="w-full"
                      onClick={() =>
                        onAction("delete", { suggestionId: suggestion.id })
                      }
                    >
                      <Trash2 className="w-4 h-4 ml-2" />
                      מחק הצעה
                    </Button>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Resend to Both Parties */}
                  {canChangeStatus(
                    suggestion.status as MatchSuggestionStatus
                  ).includes("PENDING_FIRST_PARTY") && (
                    <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                      <h4 className="text-lg font-semibold mb-3 flex items-center">
                        <Send className="w-5 h-5 ml-2 text-purple-600" />
                        שליחה מחדש
                      </h4>
                      <p className="text-sm text-gray-600 mb-3">
                        שליחת ההצעה מחדש לשני הצדדים
                      </p>
                      <Button
                        className="w-full bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("resendToAll", {
                            suggestionId: suggestion.id,
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-2" />
                        שלח מחדש לשני הצדדים
                      </Button>
                    </div>
                  )}

                  {/* Export Suggestion Details */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Download className="w-5 h-5 ml-2 text-green-600" />
                      ייצוא פרטי הצעה
                    </h4>
                    <p className="text-sm text-gray-600 mb-3">
                      ייצוא כל פרטי ההצעה בפורמט PDF או CSV
                    </p>
                    <Button
                      variant="outline"
                      className="w-full border-green-200 hover:bg-green-50 text-green-700"
                      onClick={() =>
                        onAction("export", { suggestionId: suggestion.id })
                      }
                    >
                      <Download className="w-4 h-4 ml-2" />
                      ייצא פרטי הצעה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>
          </div>
        </Tabs>
        {/* Status Change Dialog */}
        {showStatusChange && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-xl max-w-md w-full shadow-lg">
              <h3 className="text-xl font-bold mb-4 flex items-center">
                <RefreshCw className="w-5 h-5 ml-2 text-blue-600" />
                שינוי סטטוס הצעה
              </h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס נוכחי
                  </label>
                  <div className="flex items-center p-2 bg-gray-50 rounded border">
                    <StatusIcon
                      className={`w-5 h-5 ml-2 ${statusInfo.color}`}
                    />
                    <span className="font-medium">{statusInfo.label}</span>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס חדש
                  </label>
                  <Select
                    value={newStatus || undefined}
                    onValueChange={(value) => {
                      console.log("Selected new status:", value);
                      setNewStatus(value as MatchSuggestionStatus);
                    }}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="בחר/י סטטוס חדש" />
                    </SelectTrigger>
                    <SelectContent className="max-h-80 overflow-y-auto">
                      {/* מציג את כל הסטטוסים האפשריים במערכת */}
                      {Object.entries(getAllStatusLabels()).map(
                        ([status, label]) => (
                          <SelectItem key={status} value={status}>
                            {label}
                          </SelectItem>
                        )
                      )}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    הערות לשינוי סטטוס
                  </label>
                  <Textarea
                    value={statusChangeNote}
                    onChange={(e) => setStatusChangeNote(e.target.value)}
                    placeholder="הערות אופציונליות לשינוי הסטטוס..."
                    className="min-h-[100px] resize-none"
                  />
                </div>

                <div className="flex justify-end gap-2 pt-2">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowStatusChange(false);
                      setNewStatus(null);
                      setStatusChangeNote("");
                    }}
                  >
                    ביטול
                  </Button>
                  <Button
                    onClick={handleStatusChange}
                    disabled={!newStatus || isLoading}
                    className="bg-blue-600 hover:bg-blue-700"
                  >
                    {isLoading ? (
                      <>
                        <div className="h-4 w-4 ml-2 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                        מעדכן...
                      </>
                    ) : (
                      "שמור שינוי"
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}
        <DialogFooter className="px-6 py-4 border-t bg-gray-50">
          <div className="flex justify-between w-full">
            <Button
              variant="outline"
              className="border-red-200 hover:bg-red-50 text-red-600"
              onClick={() =>
                onAction("delete", { suggestionId: suggestion.id })
              }
            >
              <Trash2 className="w-4 h-4 ml-1" />
              מחק הצעה
            </Button>

            <div className="flex gap-2">
              <Button variant="outline" onClick={onClose}>
                סגור
              </Button>
              <Button
                // תיקון: המקום השלישי בו צריך לוודא שהפונקציה מופעלת נכון
                onClick={() => setShowStatusChange(true)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <RefreshCw className="w-4 h-4 ml-1" />
                עדכן סטטוס
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\hooks\useMatchmaking.ts:
==================================================
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS } from '../../new/constants/matchingCriteria';
import type { User } from '@/types/next-auth';
// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: User[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: User;
  candidateB: User;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: User;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile?.gender === candidateB.profile?.gender ||
          candidateA.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA.profile, candidateB.profile);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx:
==================================================
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Users } from "lucide-react";

import type { Suggestion, SuggestionFilters } from "@/types/suggestions";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: SuggestionFilters;
  searchQuery: string;
  type: "active" | "pending" | "history";
  onSuggestionDeleted?: (id: string) => void;
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
  onSuggestionDeleted,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [, setShowDeleteDialog] = useState(false);
  const [suggestionToDelete, setSuggestionToDelete] = useState<string | null>(
    null
  );

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Priority filter
      if (
        filters.priority?.length &&
        !filters.priority.includes(suggestion.priority)
      ) {
        return false;
      }

      // Date range filter
      if (filters.dateRange) {
        const createdAt = new Date(suggestion.createdAt);
        if (
          createdAt < filters.dateRange.start ||
          createdAt > filters.dateRange.end
        ) {
          return false;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const confirmDelete = async () => {
    if (!suggestionToDelete) return;

    try {
      const response = await fetch(
        `/api/suggestions/${suggestionToDelete}/delete`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to delete suggestion");
      }

      toast.success("ההצעה נמחקה בהצלחה");
      if (onSuggestionDeleted) {
        onSuggestionDeleted(suggestionToDelete);
      }
    } catch (error) {
      console.error("Error deleting suggestion:", error);
      toast.error("שגיאה במחיקת ההצעה");
    } finally {
      setShowDeleteDialog(false);
      setSuggestionToDelete(null);
    }
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                {/* Rest of the JSX remains the same */}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />

      <AlertDialog>
        {" "}
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
            <AlertDialogDescription>
              פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              מחיקה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default ManagerSuggestionsList;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionsList.tsx:
==================================================
import React, { useState, useMemo } from "react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Search, Filter, SortDesc } from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";
import SuggestionCard from "../cards/SuggestionCard";
import { LoadingContainer } from "../../new/shared/LoadingStates";
import type {
  Suggestion,
  ActionAdditionalData,
  SuggestionStatusHistory,
} from "@/types/suggestions";

interface PartyInfo {
  id: string;
  firstName: string;
  lastName: string;
  profile: UserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: SuggestionStatusHistory[]; // הוספת השדה החסר
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  isLoading?: boolean;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const SORT_OPTIONS = [
  { value: "latest", label: "החדשים ביותר" },
  { value: "oldest", label: "הישנים ביותר" },
  { value: "deadline", label: "לפי תאריך יעד" },
  { value: "priority", label: "לפי דחיפות" },
];

const STATUS_OPTIONS = [
  { value: "PENDING_FIRST_PARTY", label: "ממתין לצד א׳" },
  { value: "PENDING_SECOND_PARTY", label: "ממתין לצד ב׳" },
  { value: "FIRST_PARTY_APPROVED", label: "צד א׳ אישר" },
  { value: "SECOND_PARTY_APPROVED", label: "צד ב׳ אישר" },
  { value: "CONTACT_DETAILS_SHARED", label: "פרטי קשר שותפו" },
  { value: "DATING", label: "בתהליך היכרות" },
];

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions,
  isLoading = false,
  onAction,
  className,
}) => {
  // Filters state
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState("latest");
  const [statusFilter, setStatusFilter] = useState<string[]>([]);
  const [showFilters, setShowFilters] = useState(false);

  // Filter and sort suggestions
  const filteredSuggestions = useMemo(() => {
    let result = [...suggestions];

    // Apply status filter
    if (statusFilter.length > 0) {
      result = result.filter((s) => statusFilter.includes(s.status));
    }

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (s) =>
          s.firstParty.firstName.toLowerCase().includes(query) ||
          s.firstParty.lastName.toLowerCase().includes(query) ||
          s.secondParty.firstName.toLowerCase().includes(query) ||
          s.secondParty.lastName.toLowerCase().includes(query) ||
          s.firstParty.profile.city?.toLowerCase().includes(query) ||
          s.secondParty.profile.city?.toLowerCase().includes(query)
      );
    }

    // Apply sorting
    switch (sortBy) {
      case "latest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
        );
        break;
    }

    return result;
  }, [suggestions, searchQuery, sortBy, statusFilter]);

  return (
    <div className={className}>
      {/* Filters Bar */}
      <div className="mb-6 space-y-4">
        <div className="flex gap-4">
          <div className="relative flex-1">
            <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
            <Input
              placeholder="חיפוש לפי שם או עיר..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 text-right"
            />
          </div>

          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-48">
              <SortDesc className="w-4 h-4 ml-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {SORT_OPTIONS.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Button
            variant="outline"
            onClick={() => setShowFilters(!showFilters)}
          >
            <Filter className="w-4 h-4 ml-2" />
            סינון
          </Button>
        </div>

        {showFilters && (
          <div className="flex gap-4">
            {STATUS_OPTIONS.map((status) => (
              <Button
                key={status.value}
                variant={
                  statusFilter.includes(status.value) ? "default" : "outline"
                }
                onClick={() => {
                  setStatusFilter((prev) =>
                    prev.includes(status.value)
                      ? prev.filter((s) => s !== status.value)
                      : [...prev, status.value]
                  );
                }}
                className="text-sm"
              >
                {status.label}
              </Button>
            ))}
          </div>
        )}
      </div>

      {/* Suggestions Grid */}
      {isLoading ? (
        <LoadingContainer>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <div
                key={i}
                className="h-64 bg-gray-100 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </LoadingContainer>
      ) : (
        // בערך בשורה 196 - שנה את הגריד להצגה מימין לשמאל
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
          {filteredSuggestions.map((suggestion) => (
            <SuggestionCard
              key={suggestion.id}
              suggestion={suggestion as unknown as Suggestion}
              onAction={onAction}
              className="rtl" // הוסף מחלקה זו
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default SuggestionsList;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\CandidateSelector.tsx:
==================================================
import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../../new/types/candidates";

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={(value) => {
                  setInputValue(value);
                  setActiveIndex(-1);
                }}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => (
                    <div
                      key={candidate.id}
                      onClick={() => handleSelect(candidate)}
                      className={`flex items-center gap-2 text-right p-2 hover:bg-accent/50 cursor-pointer ${
                        index === activeIndex ? "bg-accent" : ""
                      }`}
                      role="option"
                      id={`candidate-${candidate.id}`}
                      aria-selected={index === activeIndex}
                      onMouseEnter={() => setActiveIndex(index)}
                    >
                      <div className="flex-1">
                        <div className="font-medium">
                          {formatCandidateDisplay(candidate)}
                        </div>
                        <div className="text-sm text-gray-500">
                          {candidate.profile.religiousLevel} |
                          {candidate.profile.occupation &&
                            ` ${candidate.profile.occupation} |`}
                          {candidate.profile.education &&
                            ` ${candidate.profile.education}`}
                        </div>
                      </div>
                    </div>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => {
                /* Add view profile handler */
              }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\index.tsx:
==================================================
"use client";
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/toast/use-toast";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { CheckCircle, UserPlus } from "lucide-react";
import { Steps } from "@/components/ui/steps";
import type { Candidate } from "../../new/types/candidates";
import { newSuggestionSchema } from "./schema";
import type { NewSuggestionFormData } from "./schema";
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const STEPS = [
  {
    title: "בחירת מועמדים",
    description: "בחירת שני הצדדים להצעה",
    icon: UserPlus,
  },
  {
    title: "פרטי ההצעה",
    description: "הגדרת פרטי ההצעה ותזמונים",
    icon: CheckCircle,
  },
];

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({
  isOpen,
  onClose,
  candidates,
  selectedCandidate,
  onSubmit,
}) => {
  const [step, setStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(
    selectedCandidate || null
  );
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);

  const { toast } = useToast();

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      firstPartyId: selectedCandidate?.id || "",
      secondPartyId: "",
    },
  });

  // Debug logging for form state changes
  useEffect(() => {
    const subscription = form.watch((value, { name, type }) => {
      console.log("Form value changed:", {
        name,
        value,
        type,
        allValues: form.getValues(),
        formState: form.formState,
      });
    });

    return () => subscription.unsubscribe();
  }, [form]);

  // Handle candidate selection
  const handleCandidateSelect =
    (type: "first" | "second") => (candidate: Candidate | null) => {
      console.log(`${type} party selection:`, { candidate });

      if (type === "first") {
        setFirstParty(candidate);
        if (candidate) {
          form.setValue("firstPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("firstPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      } else {
        setSecondParty(candidate);
        if (candidate) {
          form.setValue("secondPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("secondPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      }

      // Log form state after update
      console.log("Form state after selection:", {
        values: form.getValues(),
        errors: form.formState.errors,
        isDirty: form.formState.isDirty,
        isValid: form.formState.isValid,
      });
    };

  const handleSubmit = async (data: NewSuggestionFormData) => {
    console.log("Submit attempt:", {
      formData: data,
      formState: form.formState,
      firstParty,
      secondParty,
    });

    if (!firstParty || !secondParty) {
      console.log("Missing parties:", { firstParty, secondParty });
      return;
    }

    try {
      setIsSubmitting(true);
      console.log("=== Before API call ===");
      await onSubmit(data);
      console.log("=== After successful API call ===");
      toast({
        title: "ההצעה נוצרה בהצלחה",
        description: "ההצעה נשמרה במערכת והועברה לטיפול",
      });
      onClose();
    } catch (error) {
      console.log("=== API call failed ===", error);
      console.error("Submission error:", error);
      toast({
        title: "שגיאה",
        description: "אירעה שגיאה בעת יצירת ההצעה",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle form validation before moving to next step
  const handleNextStep = () => {
    form.trigger(["firstPartyId", "secondPartyId"]).then((isValid) => {
      if (isValid) {
        setStep(2);
      } else {
        console.log("Validation failed:", form.formState.errors);
      }
    });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto p-0">
        <DialogHeader className="px-8 pt-6 pb-2">
          <DialogTitle className="text-2xl">יצירת הצעת שידוך חדשה</DialogTitle>
          <DialogDescription>
            יצירת הצעת שידוך בין שני מועמדים והגדרת פרטי ההצעה
          </DialogDescription>
        </DialogHeader>

        {/* Steps Indicator */}
        <div className="px-8 py-4">
          <Steps steps={STEPS} currentStep={step} />
        </div>

        <Separator />

        <FormProvider {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="p-8 pt-6">
            {/* Step 1: Candidate Selection */}
            <div className={step !== 1 ? "hidden" : "space-y-8"}>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <CandidateSelector
                  label="צד א׳"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={candidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />

                <CandidateSelector
                  label="צד ב׳"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={candidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

              {firstParty && secondParty && (
                <div className="rounded-lg border bg-card">
                  <div className="px-6 py-4 border-b">
                    <h3 className="text-lg font-semibold">
                      התאמה בין המועמדים
                    </h3>
                  </div>
                  <div className="p-6">
                    <MatchPreview
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  </div>
                </div>
              )}

              <div className="flex justify-end mt-8">
                <Button
                  type="button"
                  size="lg"
                  onClick={handleNextStep}
                  disabled={!firstParty || !secondParty}
                >
                  המשך להגדרת פרטי ההצעה
                </Button>
              </div>
            </div>

            {/* Step 2: Suggestion Details */}
            <div className={step !== 2 ? "hidden" : "space-y-8"}>
              <div className="rounded-lg border bg-card">
                <div className="px-6 py-4 border-b">
                  <h3 className="text-lg font-semibold">פרטי ההצעה</h3>
                </div>
                <div className="p-6">
                  {firstParty && secondParty ? (
                    <SuggestionDetails
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  ) : (
                    <div className="text-center py-4 text-gray-500">
                      יש לבחור את שני הצדדים בשלב הראשון
                    </div>
                  )}
                </div>
              </div>

              <div className="flex justify-between mt-8">
                <Button
                  type="button"
                  variant="outline"
                  size="lg"
                  onClick={() => setStep(1)}
                >
                  חזרה לבחירת מועמדים
                </Button>

                <Button
                  type="submit"
                  size="lg"
                  disabled={isSubmitting || !form.formState.isValid}
                >
                  {isSubmitting ? "שומר הצעה..." : "שמור הצעה"}
                </Button>
              </div>
            </div>
          </form>
        </FormProvider>
      </DialogContent>
    </Dialog>
  );
};

export default NewSuggestionForm;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\MatchPreview.tsx:
==================================================
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../../new/types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\schema.ts:
==================================================
import { z } from "zod";
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\SuggestionDetails.tsx:
==================================================
"use client";
import React from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { calculateAge } from "@/lib/utils";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../../new/types/candidates";

interface SuggestionDetailsProps {
  className?: string;
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({
  firstParty,
  secondParty,
}) => {
  const {
    register,
    formState: { errors },
    setValue,
    getValues,
  } = useFormContext<NewSuggestionFormData>();

  // Format candidate display
  const formatCandidateInfo = (candidate: Candidate): string => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  };

  // Register all form fields
  React.useEffect(() => {
    // Set default values if not already set
    const currentValues = getValues();
    if (!currentValues.priority) {
      setValue("priority", Priority.MEDIUM);
    }
  }, [setValue, getValues]);

  return (
    <div className="space-y-6">
      {/* Selected Candidates Summary */}
      <Card className="bg-slate-50">
        <CardHeader className="pb-3">
          <h3 className="text-lg font-semibold">הצדדים המוצעים</h3>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד א׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(firstParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {firstParty.profile.religiousLevel} |
                {firstParty.profile.occupation &&
                  ` ${firstParty.profile.occupation} |`}
                {firstParty.profile.education &&
                  ` ${firstParty.profile.education}`}
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד ב׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(secondParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {secondParty.profile.religiousLevel} |
                {secondParty.profile.occupation &&
                  ` ${secondParty.profile.occupation} |`}
                {secondParty.profile.education &&
                  ` ${secondParty.profile.education}`}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Priority Selection with Visual Indicators */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <Label className="text-lg">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => {
                setValue("priority", value, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              value={getValues("priority") || Priority.MEDIUM}
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י עדיפות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="destructive"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    דחופה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.HIGH}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="warning"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    גבוהה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.MEDIUM}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="default"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    רגילה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.LOW}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="secondary"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    נמוכה
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && (
              <p className="text-sm text-red-500">{errors.priority.message}</p>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Matching Details */}
      <Card>
        <CardContent className="pt-6 space-y-6">
          {/* Matching Reason */}
          <div className="space-y-3">
            <Label className="text-lg">סיבת ההתאמה</Label>
            <div className="text-sm text-gray-500 mb-2">
              פרט/י מדוע לדעתך יש התאמה בין המועמדים. מידע זה יוצג לשני הצדדים.
            </div>
            <Textarea
              {...register("matchingReason")}
              placeholder="לדוגמה: שני הצדדים מחפשים בן/בת זוג עם השקפת עולם דומה, שאיפות דומות..."
              className="min-h-[120px] resize-none"
            />
            {errors.matchingReason && (
              <p className="text-sm text-red-500">
                {errors.matchingReason.message}
              </p>
            )}
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-3">
              <Label className="text-lg">הערות לצד א׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{firstParty.firstName}
              </div>
              <Textarea
                {...register("firstPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.firstPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.firstPartyNotes.message}
                </p>
              )}
            </div>

            <div className="space-y-3">
              <Label className="text-lg">הערות לצד ב׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{secondParty.firstName}
              </div>
              <Textarea
                {...register("secondPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.secondPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.secondPartyNotes.message}
                </p>
              )}
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-3">
            <Label className="text-lg">הערות פנימיות</Label>
            <div className="text-sm text-gray-500 mb-2">
              הערות אלו יהיו גלויות רק לצוות השדכנים
            </div>
            <Textarea
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשדכנים..."
              className="min-h-[100px] resize-none"
            />
            {errors.internalNotes && (
              <p className="text-sm text-red-500">
                {errors.internalNotes.message}
              </p>
            )}
          </div>

          {/* Decision Days */}
          <div className="space-y-3">
            <Label className="text-lg">זמן להחלטה</Label>
            <div className="text-sm text-gray-500 mb-2">
              תוך כמה ימים נדרשת החלטה סופית משני הצדדים
            </div>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              defaultValue="14"
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י מספר ימים" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="2">2 ימים</SelectItem>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="5">5 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && (
              <p className="text-sm text-red-500">
                {errors.decisionDeadline.message}
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\services\email\EmailService.ts:
==================================================
import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import nodemailer from 'nodemailer';

type UserWithProfile = User & {
  profile: Profile | null;
};

type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type EmailTemplate = {
  subject: string;
  body: (data: SuggestionWithParties) => string;
};

// Helper function to format user details with proper RTL support
const formatUserDetails = (user: UserWithProfile) => {
  const details = [
    `שם: ${user.firstName} ${user.lastName}`,
    `אימייל: ${user.email}`,
  ];

  if (user?.phone) {
    details.push(`טלפון: ${user?.phone}`);
  }

  return details.join('\n');
};

// Base HTML template with RTL support
const createHtmlTemplate = (content: string) => `
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            direction: rtl;
            text-align: right;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }
    </style>
</head>
<body>
    ${content}
</body>
</html>
`;

// Email templates for different statuses
const emailTemplates: Record<MatchSuggestionStatus, EmailTemplate | null> = {
  DRAFT: {
    subject: 'טיוטת הצעת שידוך נשמרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>טיוטת הצעת השידוך נשמרה בהצלחה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטי ההצעה</a></p>
      </div>
    `)
  },
  
  PENDING_FIRST_PARTY: {
    subject: 'הצעת שידוך חדשה עבורך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.firstParty.firstName},</h2>
        <p>${data.matchmaker.firstName} ${data.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p>
        <p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/review">לצפייה בהצעה</a></p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  FIRST_PARTY_APPROVED: {
    subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.firstParty.firstName} ${data.firstParty.lastName} אישר/ה את הצעת השידוך.</p>
        <p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  FIRST_PARTY_DECLINED: {
    subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.firstParty.firstName} ${data.firstParty.lastName} דחה/תה את הצעת השידוך.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  PENDING_SECOND_PARTY: {
    subject: 'הצעת שידוך חדשה עבורך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.secondParty.firstName},</h2>
        <p>${data.matchmaker.firstName} ${data.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p>
        <p>הצד הראשון כבר אישר את ההצעה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/review">לצפייה בפרטי ההצעה ומענה</a></p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  SECOND_PARTY_APPROVED: {
    subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.secondParty.firstName} ${data.secondParty.lastName} אישר/ה את הצעת השידוך.</p>
        <p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  SECOND_PARTY_DECLINED: {
    subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.secondParty.firstName} ${data.secondParty.lastName} דחה/תה את הצעת השידוך.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  AWAITING_MATCHMAKER_APPROVAL: {
    subject: 'נדרש אישור שדכן להצעה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>נדרש אישורך להצעת השידוך בין ${data.firstParty.firstName} ל${data.secondParty.firstName}.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים ואישור</a></p>
      </div>
    `)
  },

  CONTACT_DETAILS_SHARED: {
    subject: 'פרטי קשר להצעת השידוך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2>
        <p>פרטי הקשר של הצד הראשון:</p>
        <pre>${formatUserDetails(data.firstParty)}</pre>
        <p>פרטי הקשר של הצד השני:</p>
        <pre>${formatUserDetails(data.secondParty)}</pre>
        <p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p>
        <p>בהצלחה!</p>
      </div>
    `)
  },

  AWAITING_FIRST_DATE_FEEDBACK: {
    subject: 'בקשה למשוב על הפגישה הראשונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/feedback">לשליחת המשוב</a></p>
      </div>
    `)
  },

  THINKING_AFTER_DATE: {
    subject: 'בקשת זמן למחשבה לאחר הפגישה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  PROCEEDING_TO_SECOND_DATE: {
    subject: 'עדכון סטטוס - ממשיכים לפגישה שנייה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>שני הצדדים הסכימו להמשיך לפגישה שנייה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  ENDED_AFTER_FIRST_DATE: {
    subject: 'עדכון סטטוס - סיום לאחר פגישה ראשונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה הסתיימה לאחר הפגישה הראשונה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים והמשוב</a></p>
      </div>
    `)
  },

  MEETING_PENDING: {
    subject: 'הצעה לקביעת פגישה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>התקבלה הצעה לקביעת פגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/meetings">לצפייה בפרטי ההצעה</a></p>
      </div>
    `)
  },

  MEETING_SCHEDULED: {
    subject: 'פגישה נקבעה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>אנו שמחים לעדכן שנקבעה פגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/meetings">לצפייה בפרטי הפגישה</a></p>
      </div>
    `)
  },

  MATCH_APPROVED: {
    subject: 'ההצעה אושרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה אושרה על ידי שני הצדדים.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  MATCH_DECLINED: {
    subject: 'ההצעה נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה נדחתה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  DATING: {
    subject: 'עדכון סטטוס - בתהליך היכרות',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הזוג נמצא בתהליך היכרות.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  ENGAGED: {
    subject: 'מזל טוב! - אירוסין',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>מזל טוב ${data.firstParty.firstName} ו${data.secondParty.firstName}!</h2>
        <p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  MARRIED: {
    subject: 'מזל טוב! - חתונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>מזל טוב ${data.firstParty.firstName} ו${data.secondParty.firstName}!</h2>
        <p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  EXPIRED: {
    subject: 'הצעת השידוך פגה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך פגה עקב חוסר מענה במועד.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  CLOSED: {
    subject: 'הצעת השידוך נסגרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך נסגרה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  CANCELLED: {
    subject: 'הצעת השידוך בוטלה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך בוטלה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },
  
};

export class EmailService {
  private static instance: EmailService;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure nodemailer for Gmail
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD,
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on startup
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig() {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw - allow the service to continue running even if email verification fails
    }
  }

  public static getInstance(): EmailService {
    if (!EmailService.instance) {
      EmailService.instance = new EmailService();
    }
    return EmailService.instance;
  }

  async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
  
  ): Promise<void> {
    try {
      console.log('email222:------------');
      const template = emailTemplates[suggestion.status];
      if (!template) {
        console.log(`No email template for status: ${suggestion.status}`);
        return;
      }

      const recipients = this.getRecipientsByStatus(suggestion);
      
      console.log(`Preparing to send emails for suggestion ${suggestion.id}`, {
        status: suggestion.status,
        recipientCount: recipients.length
      });

      await Promise.all(
        recipients.map(async (recipient) => {
          await this.sendEmail({
            to: recipient,
            subject: template.subject,
            html: template.body(suggestion),
          });
        })
      );

      console.log(`Successfully sent ${recipients.length} emails for suggestion ${suggestion.id}`);
    } catch (error) {
      console.error('Error sending suggestion emails:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        suggestionId: suggestion.id,
        status: suggestion.status
      });
      throw new Error('Failed to send suggestion emails');
    }
  }

  private getRecipientsByStatus(suggestion: SuggestionWithParties): string[] {
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return [suggestion.firstParty.email];
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return [suggestion.secondParty.email];
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
          suggestion.matchmaker.email,
        ];
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
        ];

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
      case MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE:
      case MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE:
        return [suggestion.matchmaker.email];

      case MatchSuggestionStatus.MEETING_PENDING:
      case MatchSuggestionStatus.MEETING_SCHEDULED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
        ];

      case MatchSuggestionStatus.MATCH_APPROVED:
      case MatchSuggestionStatus.MATCH_DECLINED:
      case MatchSuggestionStatus.DATING:
        return [suggestion.matchmaker.email];

      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
          suggestion.matchmaker.email,
        ];
      
      case MatchSuggestionStatus.EXPIRED:
      case MatchSuggestionStatus.CLOSED:
      case MatchSuggestionStatus.CANCELLED:
        return [suggestion.matchmaker.email];
      
      default:
        return [];
    }
  }

  async sendEmail({
    to,
    subject,
    html,
  }: {
    to: string;
    subject: string;
    html: string;
  }): Promise<void> {
    try {
      console.log('Attempting to send email:', {
        to,
        subject,
        fromEmail: process.env.GMAIL_USER,
        fromName: process.env.EMAIL_FROM_NAME,
      });

      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME} <${process.env.GMAIL_USER}>`,
        to,
        subject,
        html,
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
      });
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        emailConfig: {
          to,
          subject,
          fromEmail: process.env.GMAIL_USER,
          fromName: process.env.EMAIL_FROM_NAME,
        }
      });
      throw error;
    }
  }
}

// Export singleton instance
export const emailService = EmailService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\StatusTransitionService.ts:
==================================================
import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { EmailService } from "../email/EmailService";

type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Send email notifications using EmailService
    try {
      await EmailService.getInstance().handleSuggestionStatusChange(
        updatedSuggestion,
      );
    } catch (error) {
      // Log error but don't fail the transition
      console.error('Error sending status transition emails:', error);
    }

    return updatedSuggestion;
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\SuggestionService.ts:
==================================================
import { MatchSuggestionStatus, Priority, UserRole, MatchSuggestion } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { emailService } from "../email/EmailService";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
} from "@/types/suggestions";

export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    if (!matchmaker || matchmaker.role !== UserRole.MATCHMAKER) {
      throw new Error("Unauthorized - User is not a matchmaker");
    }

  /*   // 2. בדיקת זמינות המועמדים
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: data.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: data.secondPartyId },
        include: { profile: true },
      }),
    ]); 

    if (!firstParty || !secondParty) {
      throw new Error("One or both parties not found");
    }

    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      throw new Error("One or both parties are not available for matching");
    } 
 */
  /*   // 3. בדיקת הצעות קיימות
    const existingSuggestion = await this.checkExistingSuggestion(
      data.firstPartyId,
      data.secondPartyId
    );

    if (existingSuggestion) {
      throw new Error("Active suggestion already exists between these parties");
    }
 */
    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
console.log('Decision deadline type:', typeof data.decisionDeadline);
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות מייל
    console.log('email:------------');
    await emailService.handleSuggestionStatusChange(
      suggestion,
    );

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: MatchSuggestion,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;
    const isSecondParty = userId === suggestion.secondPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        if (!isSecondParty) throw new Error("Only second party can approve/decline at this stage");
        break;

      case MatchSuggestionStatus.CANCELLED:
        if (!isMatchmaker && !isFirstParty && !isSecondParty) {
          throw new Error("Only involved parties can cancel the suggestion");
        }
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<MatchSuggestion | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
    });
  }
}

export const suggestionService = SuggestionService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\utils\matchingAlgorithm.ts:
==================================================
import { AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

const matchingAlgorithm = {
  calculateMatchScore,
  findBestMatches
};

export default matchingAlgorithm;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\suggestions\utils\statisticsCalculator.ts:
==================================================
// /utils/statisticsCalculator.ts
import type { Candidate } from '../../new/types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const  stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.referenceName1 || candidate.profile.referenceName2) stats.hasReferences++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      (candidate.profile.referenceName1 || candidate.profile.referenceName2) &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

const statisticsCalculator = {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

export default statisticsCalculator;
