################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker
# Generated on: 2025-06-23 16:33:59
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\MatchmakerEditProfile.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/MatchmakerEditProfile.tsx

import React, { useState, useEffect, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { toast } from "sonner";
import { ProfileSection } from "@/app/components/profile";
import { PhotosSection } from "@/app/components/profile";
import { PreferencesSection } from "@/app/components/profile";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Loader2, X, UserCog, Image as ImageIcon, Sliders, Trash2, AlertCircle, Send } from "lucide-react";
import type { UserProfile, UserImage } from "@/types/next-auth";
import type { Candidate } from "./types/candidates";
import { motion } from "framer-motion";
import { useSession } from "next-auth/react";

interface MatchmakerEditProfileProps {
  isOpen: boolean;
  onClose: () => void;
  candidate: Candidate | null;
  onCandidateDeleted?: (candidateId: string) => void; 
}

const DELETE_CANDIDATE_CONFIRMATION_PHRASE = "אני מאשר מחיקה";

const MatchmakerEditProfile: React.FC<MatchmakerEditProfileProps> = ({
  isOpen,
  onClose,
  candidate,
  onCandidateDeleted,
}) => {
  const { data: session } = useSession();
  const isAdmin = session?.user?.role === "ADMIN";

  const [activeTab, setActiveTab] = useState("profile");
  const [isEditing, setIsEditing] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [images, setImages] = useState<UserImage[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // States for delete candidate confirmation
  const [isDeleteCandidateDialogOpen, setIsDeleteCandidateDialogOpen] = useState(false);
  const [deleteCandidateConfirmText, setDeleteCandidateConfirmText] = useState("");
  const [isDeletingCandidate, setIsDeletingCandidate] = useState(false);

  // --- NEW: States for Account Setup Invite ---
  const [isSetupInviteOpen, setIsSetupInviteOpen] = useState(false);
  const [inviteEmail, setInviteEmail] = useState("");
  const [isSendingInvite, setIsSendingInvite] = useState(false);
  // --- END NEW ---

  const fetchProfileData = useCallback(async () => {
    if (!candidate) return;
    setIsLoading(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}`);
      if (!response.ok) throw new Error("Failed to fetch candidate profile");
      const data = await response.json();
      if (data.success) {
        setProfile(data.profile);
        setImages(data.images || []);
        // --- NEW: Populate email for invite dialog ---
        // Check if the email is a real one, not a placeholder
        if (candidate.email && !candidate.email.endsWith('@shidduch.placeholder.com')) {
          setInviteEmail(candidate.email);
        } else {
          setInviteEmail(""); // Clear if it's a placeholder
        }
        // --- END NEW ---
      } else {
        throw new Error(data.error || "Failed to load profile data");
      }
    } catch (error) {
      console.error("Error fetching profile:", error);
      toast.error("שגיאה בטעינת נתוני המועמד");
    } finally {
      setIsLoading(false);
    }
  }, [candidate]);

  useEffect(() => {
    if (isOpen && candidate) {
      fetchProfileData();
    } else if (!isOpen) {
      setProfile(null);
      setImages([]);
      setActiveTab("profile");
      setIsLoading(true);
      setDeleteCandidateConfirmText("");
      setIsDeleteCandidateDialogOpen(false);
      // --- NEW: Reset invite state on close ---
      setIsSetupInviteOpen(false);
      setInviteEmail("");
      setIsSendingInvite(false);
      // --- END NEW ---
    }
  }, [isOpen, candidate, fetchProfileData]);

  const handleProfileUpdate = async (updatedProfile: Partial<UserProfile>) => {
    if (!candidate || !profile) return;
    setIsSaving(true);
    try {
      const cleanedProfile = { ...updatedProfile };
      if (cleanedProfile.gender === undefined) { /* Keep undefined */ }
      if (cleanedProfile.preferredMatchmakerGender === undefined) { /* Keep undefined */ }

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(cleanedProfile),
        }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to update profile");
      }
      setProfile(prevProfile => ({ ...prevProfile, ...cleanedProfile } as UserProfile));
      toast.success("פרופיל המועמד עודכן בהצלחה", { position: "top-center", duration: 3000 });
    } catch (error) {
      console.error("Error updating profile:", error);
      toast.error(
        "שגיאה בעדכון פרופיל המועמד: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"),
        { duration: 5000 }
      );
    } finally {
      setIsSaving(false);
    }
  };

  const handleImageUpload = async (file: File) => {
    if (!candidate) return;
    setIsUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      formData.append("userId", candidate.id);

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images`,
        { method: "POST", body: formData }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to upload image");
      }
      setImages((prev) => [...prev, data.image]);
      toast.success("התמונה הועלתה בהצלחה");
    } catch (error) {
      console.error("Error uploading image:", error);
      toast.error("שגיאה בהעלאת התמונה");
    } finally {
      setIsUploading(false);
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    if (!candidate) return;
    try {
      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}/main`,
        { method: "PATCH" }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to set main image");
      }
      setImages((prev) => prev.map((img) => ({ ...img, isMain: img.id === imageId })));
      toast.success("התמונה הראשית עודכנה בהצלחה");
    } catch (error) {
      console.error("Error setting main image:", error);
      toast.error("שגיאה בעדכון התמונה הראשית");
    }
  };

  const handleDeleteImage = async (imageId: string) => {
    if (!candidate) return;
    setIsUploading(true);
    try {
      const isMainImage = images.find((img) => img.id === imageId)?.isMain;
      let nextMainImageId: string | undefined;
      if (isMainImage) {
        nextMainImageId = images.find((img) => img.id !== imageId)?.id;
      }

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}`,
        { method: "DELETE" }
      );

      if (response.status === 204) {
         setImages((prev) => prev.filter((img) => img.id !== imageId));
         if (isMainImage && nextMainImageId) {
           await handleSetMainImage(nextMainImageId);
         }
         toast.success("התמונה נמחקה בהצלחה", { position: "top-center" });
         return;
      }

      const data = await response.json();
      if (!response.ok || !data.success) {
        const errorText = data.error || await response.text();
        throw new Error(`שגיאה במחיקת התמונה: ${errorText}`);
      }
      
      setImages((prev) => prev.filter((img) => img.id !== imageId));
      if (isMainImage && nextMainImageId) {
        await handleSetMainImage(nextMainImageId);
      }
      toast.success("התמונה נמחקה בהצלחה", { position: "top-center" });

    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה במחיקת התמונה");
    } finally {
      setIsUploading(false);
    }
  };

  const handleDeleteCandidateRequest = async () => {
    if (!candidate) return;
    if (deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE) {
      toast.error("אישור לא תקין", { description: `נא להקליד "${DELETE_CANDIDATE_CONFIRMATION_PHRASE}" בדיוק כדי לאשר מחיקה.` });
      return;
    }
    setIsDeletingCandidate(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}`, { method: "DELETE" });
      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to delete candidate profile");
      }

      toast.success("המועמד נמחק בהצלחה", { position: "top-center", duration: 3000 });
      if (onCandidateDeleted) {
        onCandidateDeleted(candidate.id);
      }
      setIsDeleteCandidateDialogOpen(false);
      onClose();
    } catch (error) {
      console.error("Error deleting candidate:", error);
      toast.error("שגיאה במחיקת המועמד: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"), { duration: 5000 });
    } finally {
      setIsDeletingCandidate(false);
    }
  };
  
  // --- NEW: Handler for sending setup invite ---
  const handleSendSetupInvite = async () => {
    if (!candidate || !inviteEmail) {
      toast.error("נא להזין כתובת אימייל תקינה.");
      return;
    }
    setIsSendingInvite(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}/invite-setup`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: inviteEmail }),
      });
      const result = await response.json();
      if (!response.ok || !result.success) {
        throw new Error(result.error || 'שגיאה בשליחת ההזמנה.');
      }
      toast.success("הזמנה להגדרת חשבון נשלחה בהצלחה!");
      setIsSetupInviteOpen(false);
    } catch (error) {
      console.error("Error sending setup invite:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה בשליחת ההזמנה.");
    } finally {
      setIsSendingInvite(false);
    }
  };
  // --- END NEW ---

  if (!candidate && isOpen) return null;
  if (!candidate) return null;

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-5xl max-h-[90vh] p-0 overflow-hidden">
          {isLoading && !profile ? (
            <div className="flex items-center justify-center h-64"><Loader2 className="w-10 h-10 animate-spin text-primary" /></div>
          ) : (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }} className="flex flex-col h-full max-h-[90vh]">
              <DialogHeader className="p-6 border-b">
                <div className="flex items-center justify-between">
                  <div>
                    <DialogTitle className="text-2xl font-bold text-primary/90">עריכת פרופיל - {candidate.firstName} {candidate.lastName}</DialogTitle>
                    <DialogDescription className="text-gray-500 mt-1">עריכת פרטי המועמד והעדפותיו במערכת</DialogDescription>
                  </div>
                  {isSaving && <div className="flex items-center bg-blue-50 text-blue-700 py-1 px-2 rounded-full text-sm"><Loader2 className="w-3 h-3 animate-spin mr-1" />שומר שינויים...</div>}
                </div>
              </DialogHeader>

              <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col min-h-0">
                <div className="px-6 pt-4">
                  <TabsList className="w-full bg-muted/30 p-1 rounded-xl shadow-sm">
                    <TabsTrigger value="profile" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <UserCog className="w-4 h-4" />פרטים אישיים
                    </TabsTrigger>
                    <TabsTrigger value="photos" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <ImageIcon className="w-4 h-4" />תמונות
                    </TabsTrigger>
                    <TabsTrigger value="preferences" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <Sliders className="w-4 h-4" />העדפות
                    </TabsTrigger>
                  </TabsList>
                </div>

                <div className="flex-1 overflow-hidden flex flex-col min-h-0">
                  <TabsContent value="profile" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    {profile ? <div className="bg-white rounded-xl shadow-sm border"><ProfileSection profile={profile} isEditing={isEditing} setIsEditing={setIsEditing} onSave={handleProfileUpdate} /></div> : <div className="flex items-center justify-center h-full"><Loader2 className="w-8 h-8 animate-spin text-muted-foreground" /></div>}
                  </TabsContent>
                  <TabsContent value="photos" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    <div className="bg-white rounded-xl shadow-sm border"><PhotosSection images={images} isUploading={isUploading} disabled={isSaving || isDeletingCandidate} onUpload={handleImageUpload} onSetMain={handleSetMainImage} onDelete={handleDeleteImage} maxImages={10} /></div>
                  </TabsContent>
                  <TabsContent value="preferences" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    {profile ? <div className="bg-white rounded-xl shadow-sm border"><PreferencesSection profile={profile} isEditing={isEditing} setIsEditing={setIsEditing} onChange={handleProfileUpdate} /></div> : <div className="flex items-center justify-center h-full"><Loader2 className="w-8 h-8 animate-spin text-muted-foreground" /></div>}
                  </TabsContent>
                </div>
              </Tabs>

              <div className="p-4 border-t flex justify-between items-center mt-auto bg-white/80 backdrop-blur-sm sticky bottom-0">
                <div>
                  <span className="text-sm text-muted-foreground">{activeTab === "profile" ? "עריכת פרטים אישיים" : activeTab === "photos" ? "ניהול תמונות" : "עריכת העדפות"}</span>
                </div>
                <div className="flex items-center gap-3">
                  <Button variant="outline" onClick={() => setIsSetupInviteOpen(true)} disabled={isSaving || isDeletingCandidate || isSendingInvite}>
                    <Send className="w-4 h-4 ml-2" />
                    שלח הזמנה לניהול החשבון
                  </Button>
                  {isAdmin && <Button variant="destructive" onClick={() => setIsDeleteCandidateDialogOpen(true)} disabled={isSaving || isUploading || isDeletingCandidate} size="sm"><Trash2 className="w-4 h-4 mr-2" />מחק מועמד</Button>}
                  <Button variant="outline" onClick={onClose} disabled={isSaving || isDeletingCandidate} className="bg-white hover:bg-gray-100 transition-colors shadow-sm" size="sm"><X className="w-4 h-4 mr-2" />סגור</Button>
                </div>
              </div>
            </motion.div>
          )}
        </DialogContent>
      </Dialog>
      
      {/* --- NEW: Invite Setup Dialog --- */}
      {candidate && (
        <Dialog open={isSetupInviteOpen} onOpenChange={setIsSetupInviteOpen}>
            <DialogContent className="sm:max-w-md">
                <DialogHeader>
                    <DialogTitle>הזמנת מועמד לניהול החשבון</DialogTitle>
                    <DialogDescription>
                        שלח הזמנה ל<strong>{candidate.firstName} {candidate.lastName}</strong> להגדיר סיסמה ולקחת שליטה על הפרופיל.
                    </DialogDescription>
                </DialogHeader>
                <div className="grid gap-4 py-4">
                    <Label htmlFor="inviteEmail" className="text-right">
                        כתובת אימייל
                    </Label>
                    <Input
                        id="inviteEmail"
                        type="email"
                        value={inviteEmail}
                        onChange={(e) => setInviteEmail(e.target.value)}
                        placeholder="user@example.com"
                        className="col-span-3"
                        dir="ltr"
                    />
                </div>
                <DialogFooter>
                    <DialogClose asChild>
                        <Button type="button" variant="secondary" disabled={isSendingInvite}>ביטול</Button>
                    </DialogClose>
                    <Button type="button" onClick={handleSendSetupInvite} disabled={isSendingInvite || !inviteEmail}>
                        {isSendingInvite ? <Loader2 className="ml-2 h-4 w-4 animate-spin" /> : <Send className="ml-2 h-4 w-4" />}
                        {isSendingInvite ? "שולח..." : "שלח הזמנה"}
                    </Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
      )}
      {/* --- END NEW --- */}

      {/* Delete Candidate Confirmation Dialog */}
      {candidate && (
        <Dialog open={isDeleteCandidateDialogOpen} onOpenChange={(open) => !isDeletingCandidate && setIsDeleteCandidateDialogOpen(open)}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle className="text-xl flex items-center gap-2 text-red-600"><AlertCircle className="h-5 w-5" />אישור מחיקת מועמד</DialogTitle>
              <DialogDescription>האם אתה בטוח שברצונך למחוק את המועמד <strong>{candidate.firstName} {candidate.lastName}</strong>? פעולה זו הינה בלתי הפיכה ותסיר את כל נתוני המועמד מהמערכת.</DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
              <Label htmlFor="deleteCandidateConfirm" className="text-gray-700">לאישור המחיקה, אנא הקלד: <strong className="text-red-700">{DELETE_CANDIDATE_CONFIRMATION_PHRASE}</strong></Label>
              <Input id="deleteCandidateConfirm" value={deleteCandidateConfirmText} onChange={(e) => setDeleteCandidateConfirmText(e.target.value)} disabled={isDeletingCandidate} className="border-gray-300 focus:border-red-500" placeholder={DELETE_CANDIDATE_CONFIRMATION_PHRASE} dir="rtl" />
              {deleteCandidateConfirmText && deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE && (<p className="text-xs text-red-600">הטקסט שהוקלד אינו תואם.</p>)}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => { setIsDeleteCandidateDialogOpen(false); setDeleteCandidateConfirmText(""); }} disabled={isDeletingCandidate} className="border-gray-300">ביטול</Button>
              <Button variant="destructive" onClick={handleDeleteCandidateRequest} disabled={isDeletingCandidate || deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE}>
                {isDeletingCandidate ? (<span className="flex items-center gap-2"><Loader2 className="w-4 h-4 animate-spin" />מוחק...</span>) : (<><Trash2 className="w-4 h-4 mr-2" />מחק מועמד לצמיתות</>)}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </>
  );
};

export default MatchmakerEditProfile;
--- End of Content for MatchmakerEditProfile.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\Actions.tsx
--------------------------------------------------------------------------------
Content:
// /components/matchmaker/CandidateCard/Actions.tsx

"use client";

import React from "react";

import { Button } from "@/components/ui/button";
import { Heart, Mail, FileText, Eye, Clock } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface ActionsProps {
  candidate: Candidate;
  onInvite: (candidate: Candidate) => void;
  onSuggest: (candidate: Candidate) => void;
  onCheckAvailability: (candidate: Candidate) => void;
  onViewProfile: (candidate: Candidate) => void;
  className?: string;
}

const Actions: React.FC<ActionsProps> = ({
  candidate,
  onInvite,
  onSuggest,
  onCheckAvailability,
  onViewProfile,
  className,
}) => {
  // מונע התפשטות הקליק לכרטיס המינימלי
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  return (
    <div className={`flex flex-wrap gap-2 ${className}`} onClick={handleClick}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onViewProfile(candidate)}
      >
        <Eye className="w-4 h-4 ml-2" />
        צפייה בפרופיל
      </Button>

      <Button variant="outline" size="sm" onClick={() => onInvite(candidate)}>
        <Mail className="w-4 h-4 ml-2" />
        שליחת הזמנה
      </Button>

      <Button variant="outline" size="sm" onClick={() => onSuggest(candidate)}>
        <FileText className="w-4 h-4 ml-2" />
        הצעת שידוך
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => onCheckAvailability(candidate)}
      >
        <Clock className="w-4 h-4 ml-2" />
        בדיקת זמינות
      </Button>

      <Button
        variant="ghost"
        size="sm"
        className="text-red-600 hover:text-red-700 hover:bg-red-50"
      >
        <Heart className="w-4 h-4" />
      </Button>
    </div>
  );
};

export default Actions;
--- End of Content for Actions.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\MinimalCard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/CandidateCard/MinimalCard.tsx

"use client";

import React, { useState } from "react";
import Image from "next/image";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { User, MapPin, Briefcase, Calendar, Edit2, Sparkles, Star } from "lucide-react";
import type { Candidate } from "../types/candidates";
import { UserSource } from "@prisma/client";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import { motion } from "framer-motion";
import { Skeleton } from "@/components/ui/skeleton";
import { cn } from "@/lib/utils";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";


interface MinimalCandidateCardProps {
  candidate: Candidate;
  onClick: (candidate: Candidate) => void;
  onEdit?: (candidate: Candidate, e: React.MouseEvent) => void;
  isHighlighted?: boolean;
  highlightTerm?: string;
  className?: string;
  
  // --- AI-Related Props ---
  aiScore?: number;
  isAiTarget?: boolean;
  onSetAiTarget?: (candidate: Candidate, e: React.MouseEvent) => void;
  isSelectableForComparison?: boolean;
  isSelectedForComparison?: boolean;
  onToggleComparison?: (candidate: Candidate, e: React.MouseEvent) => void;
}

const calculateAge = (birthDate: Date | string): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const MinimalCandidateCard: React.FC<MinimalCandidateCardProps> = ({
  candidate,
  onClick,
  onEdit,
  isHighlighted = false,
  highlightTerm = "",
  className,
  aiScore,
  isAiTarget = false,
  onSetAiTarget,
  isSelectableForComparison = false,
  isSelectedForComparison = false,
  onToggleComparison,
}) => {
  const mainImage = candidate.images.find((img) => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);

  const highlightText = (text: string | undefined | null): React.ReactNode => {
    if (!highlightTerm || !text) return text;
    const parts = text.split(new RegExp(`(${highlightTerm})`, "gi"));
    return (
      <>
        {parts.map((part, i) =>
          part.toLowerCase() === highlightTerm.toLowerCase() ? (
            <mark key={i} className="bg-yellow-200 px-0.5 rounded-sm">
              {part}
            </mark>
          ) : (
            part
          )
        )}
      </>
    );
  };

  const getAvailabilityBadge = () => {
    switch (candidate.profile.availabilityStatus) {
      case "AVAILABLE": return { label: "פנוי/ה", className: "bg-emerald-100 text-emerald-800 border-emerald-200" };
      case "DATING": return { label: "בתהליך הכרות", className: "bg-amber-100 text-amber-800 border-amber-200" };
      case "UNAVAILABLE": return { label: "לא פנוי/ה", className: "bg-red-100 text-red-800 border-red-200" };
      default: return { label: "לא ידוע", className: "bg-gray-100 text-gray-800 border-gray-200" };
    }
  };

  const availabilityBadge = getAvailabilityBadge();
  const isManualEntry = candidate.source === UserSource.MANUAL_ENTRY;

  return (
    <motion.div
      whileHover={{ y: -4 }}
      transition={{ type: "spring", stiffness: 300, damping: 15 }}
    >
      <Card
        className={cn(
          "relative overflow-hidden cursor-pointer transition-all hover:shadow-lg duration-300 group border-2",
          isAiTarget ? "border-green-500 shadow-lg" : 
          isSelectedForComparison ? "border-blue-500 shadow-md" :
          typeof aiScore === 'number' ? "border-teal-400/50" :
          isHighlighted ? "border-yellow-400" :
          "border-gray-200",
          className || ""
        )}
        onClick={() => onClick(candidate)}
      >
        {/* --- Top-left Badges Area --- */}
        <div className="absolute top-2 left-2 z-20 flex flex-col items-start gap-1.5">
          {typeof aiScore === 'number' && (
            <Badge className="bg-gradient-to-r from-teal-400 to-cyan-500 text-white border-0 shadow-lg px-2.5 py-1 text-xs font-bold flex items-center gap-1.5 animate-pulse-slow">
              <Sparkles className="w-3.5 h-3.5" />
              {aiScore}% התאמה
            </Badge>
          )}
        </div>

        {/* --- Top-right Badges Area --- */}
        <div className="absolute top-2 right-2 z-10 flex flex-col gap-1 items-end">
          <Badge variant="outline" className={`px-2 py-0.5 text-xs font-medium shadow-sm ${availabilityBadge.className}`}>
            {availabilityBadge.label}
          </Badge>
          {isManualEntry && (
            <Badge variant="outline" className="px-2 py-0.5 text-xs font-medium shadow-sm bg-purple-100 text-purple-800 border-purple-200 flex items-center gap-1">
              <Edit2 className="w-2.5 h-2.5" /> מועמד ידני
            </Badge>
          )}
        </div>

        <div className="relative h-48 sm:h-56 bg-gradient-to-b from-blue-50 to-blue-100">
          {mainImage && !imageError ? (
            <>
              {!imageLoaded && <Skeleton className="absolute inset-0 h-full w-full" />}
              <Image
                src={mainImage.url}
                alt={`${candidate.firstName} ${candidate.lastName}`}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                priority={false}
                className={`object-cover transition-opacity duration-300 ${imageLoaded ? "opacity-100" : "opacity-0"}`}
                onLoad={() => setImageLoaded(true)}
                onError={() => setImageError(true)}
              />
              <div className="absolute inset-0 bg-gradient-to-t from-gray-900/80 via-gray-900/40 to-transparent" />
            </>
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-blue-50">
              <User className="w-20 h-20 text-gray-400" />
            </div>
          )}

          <div className="absolute bottom-0 w-full p-3 text-right">
            <h3 className="font-bold mb-0.5 text-white drop-shadow-md text-lg">
              {highlightText(`${candidate.firstName} ${candidate.lastName}`)}
            </h3>
            <div className="flex items-center justify-end gap-2 text-white/90 text-sm">
              <span>{age}</span>
              <Calendar className="w-3 h-3" />
            </div>
          </div>
        </div>

        <div className="p-4">
          <div className="space-y-1.5 text-gray-700 text-sm">
            {isManualEntry && candidate.profile.manualEntryText ? (
              <p className="line-clamp-3 text-gray-600 text-sm leading-relaxed">
                {highlightText(candidate.profile.manualEntryText)}
              </p>
            ) : (
              <>
                {candidate.profile.city && (
                  <div className="flex items-center justify-end gap-1">
                    <span className="font-medium">{highlightText(candidate.profile.city)}</span>
                    <MapPin className="w-4 h-4 text-blue-600" />
                  </div>
                )}
                {candidate.profile.occupation && (
                  <div className="flex items-center justify-end gap-1">
                    <span>{highlightText(candidate.profile.occupation)}</span>
                    <Briefcase className="w-4 h-4 text-blue-600" />
                  </div>
                )}
              </>
            )}
            {candidate.profile.lastActive && (
              <div className="flex items-center justify-end gap-1 mt-2 text-xs text-gray-400">
                <span>{`פעיל/ה ${formatDistanceToNow(new Date(candidate.profile.lastActive), { addSuffix: true, locale: he })}`}</span>
                <Edit2 className="w-3 h-3" />
              </div>
            )}
          </div>
        </div>

        {/* --- Bottom Action Buttons --- */}
        <div className="absolute bottom-2 left-2 z-10 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
          {onEdit && (
            <Button variant="outline" size="icon" className="h-8 w-8 bg-white/80 backdrop-blur-sm shadow-md" onClick={(e) => onEdit(candidate, e)} title="ערוך פרופיל">
              <Edit2 className="h-4 w-4 text-blue-600" />
            </Button>
          )}
          {onSetAiTarget && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                   <Button variant="outline" size="icon" className={cn("h-8 w-8 bg-white/80 backdrop-blur-sm shadow-md", isAiTarget && "bg-green-200")} onClick={(e) => onSetAiTarget(candidate, e)}>
                      <Star className={cn("h-4 w-4", isAiTarget ? "text-green-600 fill-current" : "text-gray-500")} />
                   </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{isAiTarget ? "בטל בחירת מטרה" : "בחר כמטרה לחיפוש AI"}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}
        </div>
        
      {/* --- Comparison Checkbox --- */}
      {isSelectableForComparison && onToggleComparison && (
          <div 
              className="absolute bottom-2 right-2 z-10 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity"
              onClick={(e) => {
                  e.stopPropagation(); // מונע את הקליק על הכרטיס
                  onToggleComparison(candidate, e); // מפעיל את הפונקציה הנכונה
              }}
          >
              <div 
                  className="flex items-center space-x-2 bg-white/80 backdrop-blur-sm p-1.5 rounded-md shadow-md cursor-pointer"
              >
                  <Checkbox
                      id={`compare-${candidate.id}`}
                      checked={isSelectedForComparison}
                      // --- START OF FIX ---
                      // הסרת readOnly והוספת pointer-events-none
                      // זה הופך את ה-Checkbox לויזואלי בלבד, והקליק מטופל ב-div החיצוני
                      className="pointer-events-none"
                      // --- END OF FIX ---
                  />
                  <label
                      htmlFor={`compare-${candidate.id}`}
                      className="text-xs font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 text-gray-700 cursor-pointer"
                  >
                      השווה
                  </label>
              </div>
          </div>
      )}
      </Card>
    </motion.div>
  );
};

export default MinimalCandidateCard;
--- End of Content for MinimalCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\QuickView.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidateCard/QuickView.tsx

"use client";
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  Mail,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  User,
  FileText,
  CalendarClock,
  Edit,
  Info,
  Star, // הוספת ייבוא לכוכב
} from "lucide-react";

import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";
import { UserSource } from "@prisma/client";
import { cn } from "@/lib/utils"; // הוספת ייבוא עבור cn

// פונקציה לחישוב גיל
const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

interface QuickViewProps {
  candidate: Candidate;
  onAction: (
    action: "view" | "invite" | "suggest" | "contact" | "favorite" | "edit"
  ) => void;
  // --- Props חדשים עבור AI ---
  onSetAiTarget?: (candidate: Candidate, e: React.MouseEvent) => void;
  isAiTarget?: boolean;
}

const QuickView: React.FC<QuickViewProps> = ({ 
  candidate, 
  onAction,
  onSetAiTarget,
  isAiTarget = false 
}) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = candidate.profile;
  const isManualEntry = candidate.source === UserSource.MANUAL_ENTRY;

  return (
    <div
      className="bg-white shadow-xl flex flex-col border border-gray-200 overflow-hidden max-w-md sm:max-w-lg w-full rounded-lg"
      onClick={handleClick}
    >
      {/* Header with name and avatar */}
      <div className="px-6 py-4 bg-gradient-to-r from-blue-500 to-blue-600 border-b text-white">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Badge className="bg-white text-blue-700 border-0 font-medium shadow-sm px-3 py-1">
              {profile.availabilityStatus === "AVAILABLE"
                ? "פנוי/ה"
                : profile.availabilityStatus === "DATING"
                ? "בתהליך הכרות"
                : profile.availabilityStatus === "UNAVAILABLE"
                ? "לא פנוי/ה"
                : "לא ידוע"}
            </Badge>
            {isManualEntry && (
              <Badge className="bg-purple-200 text-purple-800 border-0 font-medium shadow-sm px-3 py-1">
                מועמד ידני
              </Badge>
            )}
          </div>
          
          <div className="flex items-center gap-2">
            {onSetAiTarget && (
              <Button
                size="icon"
                variant="ghost"
                className="h-8 w-8 text-white hover:bg-white/20"
                onClick={(e) => onSetAiTarget(candidate, e)}
                title={isAiTarget ? "בטל בחירת מטרה" : "בחר כמטרה לחיפוש AI"}
              >
                <Star className={cn("h-5 w-5", isAiTarget ? "fill-current text-yellow-300" : "text-white/80")} />
              </Button>
            )}
            <h3 className="text-lg font-bold">
              {candidate.firstName} {candidate.lastName}
            </h3>
          </div>
        </div>
      </div>

      {/* Main content container */}
      <div className="flex-1 p-6 space-y-6 text-right overflow-y-auto max-h-[calc(80vh-200px)] sm:max-h-96 bg-white">
        {/* Key information section */}
        <div className="grid grid-cols-2 gap-y-4 gap-x-6">
          {profile.birthDate && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">
                {calculateAge(new Date(profile.birthDate))} שנים
              </span>
              <CalendarClock className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.height && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.height} ס״מ</span>
              <User className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.maritalStatus}</span>
              <Heart className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.religiousLevel}</span>
              <Scroll className="w-5 h-5 text-blue-500" />
            </div>
          )}
        </div>

        <Separator className="my-4 bg-gray-200" />

        {/* Manual Entry Text (if applicable) */}
        {isManualEntry && profile.manualEntryText && (
          <div className="space-y-3">
            <div className="flex items-center justify-end gap-2">
              <h4 className="text-sm font-bold text-gray-600">
                תיאור ידני מהשדכן
              </h4>
              <Info className="w-5 h-5 text-purple-500" />
            </div>
            <p className="text-sm leading-relaxed py-3 px-4 bg-purple-50 rounded-md border border-purple-200 shadow-sm whitespace-pre-wrap">
              {profile.manualEntryText}
            </p>
          </div>
        )}

        {/* Education & Occupation (if not manual entry, or if manual entry but these fields are filled) */}
        {(!isManualEntry ||
          (isManualEntry &&
            (profile.education || profile.occupation || profile.city))) && (
          <div className="space-y-4">
            <h4 className="text-sm font-bold text-gray-600 mb-3">מידע נוסף</h4>
            {profile.education && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md">
                <span className="font-medium">{profile.education}</span>
                <GraduationCap className="w-5 h-5 text-blue-500" />
              </div>
            )}

            {profile.occupation && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
                <span className="font-medium">{profile.occupation}</span>
                <Briefcase className="w-5 h-5 text-blue-500" />
              </div>
            )}

            {profile.city && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
                <span className="font-medium">{profile.city}</span>
                <MapPin className="w-5 h-5 text-blue-500" />
              </div>
            )}
          </div>
        )}

        {/* About section (if not manual entry with text, or if manual entry but 'about' is also filled) */}
        {(!isManualEntry || !profile.manualEntryText) && profile.about && (
          <>
            <Separator className="my-4 bg-gray-200" />
            <div className="space-y-3">
              <h4 className="text-sm font-bold text-gray-600">אודות</h4>
              <p className="text-sm leading-relaxed py-3 px-4 bg-gray-50 rounded-md border border-gray-200 shadow-sm whitespace-pre-wrap">
                {profile.about}
              </p>
            </div>
          </>
        )}
      </div>

      {/* Action Buttons with improved layout */}
      <div className="p-4 bg-gray-50 border-t border-gray-200">
        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
          <Button
            variant="default"
            className="w-full bg-blue-500 hover:bg-blue-600 transition-colors shadow-sm"
            onClick={() => onAction("view")}
          >
            <Eye className="w-4 h-4 ml-1.5" />
            <span className="text-sm">צפייה בפרופיל</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("suggest")}
          >
            <FileText className="w-4 h-4 ml-1.5" />
            <span className="text-sm">הצעת שידוך</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("invite")}
          >
            <Mail className="w-4 h-4 ml-1.5" />
            <span className="text-sm">שליחת הזמנה</span>
          </Button>

          <Button
            variant="outline"
            className="w-full sm:col-span-2 border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("contact")}
          >
            <Clock className="w-4 h-4 ml-1.5" />
            <span className="text-sm">בדיקת זמינות</span>
          </Button>

          <Button
            variant="ghost"
            className="w-full hover:bg-blue-50 transition-colors bg-blue-50/50"
            onClick={() => onAction("edit")}
          >
            <Edit className="w-4 h-4 ml-1.5" />
            <span className="text-sm">עריכת פרופיל</span>
          </Button>
        </div>
      </div>
    </div>
  );
};

export default QuickView;
--- End of Content for QuickView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesList.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/CandidatesList.tsx

import React, { useState, useCallback, useEffect, useRef, useMemo } from "react";
import { UserX, Edit } from "lucide-react";
import MinimalCard from "../CandidateCard/MinimalCard";
import QuickView from "../CandidateCard/QuickView";
import { ProfileCard } from "@/app/components/profile";
import type { Candidate, CandidateAction, MobileView } from "../types/candidates";
import type { QuestionnaireResponse } from "@/types/next-auth";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { ActionDialogs } from "../dialogs/ActionDialogs";
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import MatchmakerEditProfile from "../MatchmakerEditProfile";
import { cn } from "@/lib/utils";

interface CreateSuggestionData {
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  firstPartyId: string;
  secondPartyId: string;
  status:
    | "DRAFT"
    | "PENDING_FIRST_PARTY"
    | "FIRST_PARTY_APPROVED"
    | "FIRST_PARTY_DECLINED"
    | string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
}

interface CandidatesListProps {
  candidates: (Candidate & { aiScore?: number })[];
  allCandidates: Candidate[];
  onCandidateClick?: (candidate: Candidate) => void;
  onCandidateAction?: (type: CandidateAction, candidate: Candidate) => void;
  viewMode: "grid" | "list";
  mobileView: MobileView;
  isLoading?: boolean;
  className?: string;
  highlightTerm?: string;
  
  // --- AI-RELATED PROPS ---
  aiTargetCandidate: Candidate | null;
  onSetAiTarget: (candidate: Candidate, e: React.MouseEvent) => void;
  comparisonSelection: Record<string, Candidate>;
  onToggleComparison: (candidate: Candidate, e: React.MouseEvent) => void;
}

const CandidatesList: React.FC<CandidatesListProps> = ({
  candidates,
  allCandidates,
  onCandidateClick,
  onCandidateAction,
  viewMode,
  mobileView,
  isLoading = false,
  className,
  highlightTerm,
  aiTargetCandidate,
  onSetAiTarget,
  comparisonSelection,
  onToggleComparison,
}) => {
  // Base states
  const [selectedCandidate, setSelectedCandidate] = useState<Candidate | null>(
    null
  );
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [isMatchmaker, setIsMatchmaker] = useState(false);
  const [hoveredCandidate, setHoveredCandidate] = useState<Candidate | null>(
    null
  );
  const [hoverPosition, setHoverPosition] = useState({ top: 0, left: 0 });
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const quickViewRef = useRef<HTMLDivElement>(null);

  // Dialog states
  const [showInviteDialog, setShowInviteDialog] = useState(false);
  const [showAvailabilityDialog, setShowAvailabilityDialog] = useState(false);
  const [showSuggestDialog, setShowSuggestDialog] = useState(false);
  const [showEditProfileDialog, setShowEditProfileDialog] = useState(false);
  const [dialogCandidate, setDialogCandidate] = useState<Candidate | null>(
    null
  );

  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    return () => {
      window.removeEventListener("resize", checkScreenSize);
    };
  }, []);

  // Close QuickView when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        hoveredCandidate &&
        quickViewRef.current &&
        !quickViewRef.current.contains(event.target as Node)
      ) {
        setHoveredCandidate(null);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [hoveredCandidate]);

  // Clean up timeout on unmount
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Load questionnaire when candidate is selected
  useEffect(() => {
    const loadQuestionnaire = async () => {
      if (!selectedCandidate) {
        setQuestionnaireResponse(null);
        return;
      }

      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${selectedCandidate.id}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          const formattedQuestionnaire = {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
          setQuestionnaireResponse(formattedQuestionnaire);
        }
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
      }
    };

    loadQuestionnaire();
  }, [selectedCandidate]);

  // Action handlers
  const handleInvite = async (candidate: Candidate, email: string) => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}/invite-setup`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          candidateId: candidate.id,
          email,
        }),
      });

      if (!response.ok) throw new Error("Failed to send invitation");

      toast.success("ההזמנה נשלחה בהצלחה");
      onCandidateAction?.("invite", candidate);
    } catch (error) {
      console.error("Error sending invite:", error);
      throw error;
    }
  };

  const handleAvailabilityCheck = async (candidate: Candidate) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clientId: candidate.id }),
      });

      if (!response.ok) throw new Error("Failed to check availability");

      toast.success("בדיקת הזמינות נשלחה");
      onCandidateAction?.("contact", candidate);
    } catch (error) {
      console.error("Error checking availability:", error);
      throw error;
    }
  };

  const handleCreateSuggestion = async (data: CreateSuggestionData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      toast.success("ההצעה נוצרה בהצלחה");
      onCandidateAction?.("suggest", dialogCandidate!);
    } catch (error) {
      console.error("Error creating suggestion:", error);
      throw error;
    }
  };

  const handleEditProfile = (candidate: Candidate) => {
    setDialogCandidate(candidate);
    setShowEditProfileDialog(true);
  };

  const handleMouseEnter = (candidate: Candidate, e?: React.MouseEvent) => {
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }

    let top = window.scrollY + window.innerHeight / 3;
    let left = window.innerWidth / 2;

    if (e) {
      const element = e.currentTarget as HTMLElement;
      if (element) {
        const rect = element.getBoundingClientRect();
        const screenMiddle = window.innerWidth / 2;
        const isRightPanel = rect.left < screenMiddle;

        top = rect.top + window.scrollY;

        if (isRightPanel) {
          left = Math.min(rect.right + 10, window.innerWidth - 430);
        } else {
          left = Math.max(rect.left - 430, 10);
        }
      }
    }

    hoverTimeoutRef.current = setTimeout(() => {
      setHoverPosition({ top, left });
      setHoveredCandidate(candidate);
    }, 300);
  };

  const handleMouseLeave = () => {
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
      hoverTimeoutRef.current = null;
    }

    setTimeout(() => {
      if (!quickViewRef.current?.matches(":hover")) {
        setHoveredCandidate(null);
      }
    }, 100);
  };

  const handleAction = useCallback(
    (action: CandidateAction, candidate: Candidate) => {
      setDialogCandidate(candidate);
      setHoveredCandidate(null);

      switch (action) {
        case "invite":
          setShowInviteDialog(true);
          break;
        case "contact":
          setShowAvailabilityDialog(true);
          break;
        case "suggest":
          setShowSuggestDialog(true);
          break;
        case "view":
          setSelectedCandidate(candidate);
          onCandidateClick?.(candidate);
          break;
        case "edit":
          handleEditProfile(candidate);
          break;
        default:
          onCandidateAction?.(action, candidate);
      }
    },
    [onCandidateAction, onCandidateClick]
  );
  
  const gridLayoutClass = useMemo(() => {
    if (isMobile) {
      // Mobile view logic
      return mobileView === 'double'
        ? 'grid grid-cols-2 gap-2' // Two columns for mobile
        : 'grid grid-cols-1 gap-3'; // Single column for mobile
    }
    // Desktop view logic
    return viewMode === 'grid'
      ? 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-3 gap-y-4'
      : 'space-y-4';
  }, [isMobile, mobileView, viewMode]);

  // Loading states render
  if (isLoading) {
    return (
      <div
        className={`${
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            : "space-y-4"
        } ${className || ""}`}
      >
        {Array.from({ length: 6 }).map((_, i) => (
          <div key={i} className="relative">
            <Skeleton
              className={
                viewMode === "list" ? "h-32 w-full" : "h-[350px] w-full"
              }
            />
            <div className="absolute top-3 right-3">
              <Skeleton className="h-6 w-16 rounded-full" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  // Empty state render with improved UI
  if (candidates.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-32 bg-gray-50 rounded-lg border border-dashed border-gray-300 p-4 text-center">
        <UserX className="w-8 h-8 mb-2 text-gray-400" />
        <p className="text-sm font-medium text-gray-500 mb-1">
          לא נמצאו מועמדים
        </p>
        <p className="text-xs text-gray-400">
          נסו להרחיב את החיפוש או להסיר חלק מהמסננים.
        </p>
      </div>
    );
  }

  return (
    <>
      <div className={cn(gridLayoutClass, className || "")}>
        {candidates.map((candidate) => (
          <div
            key={candidate.id}
            className="group relative"
            onMouseEnter={(e) => handleMouseEnter(candidate, e)}
            onMouseLeave={handleMouseLeave}
            onClick={() => handleAction("view", candidate)}
          >
            <MinimalCard
              candidate={candidate}
              onClick={() => handleAction("view", candidate)}
              onEdit={(c, e) => {
                e.stopPropagation();
                handleAction("edit", c);
              }}
              className={cn(
                viewMode === "list" && !isMobile ? "flex flex-row-reverse gap-4 h-32" : "",
                isMobile && mobileView === 'double' ? 'transform scale-90' : '',
                isMobile && mobileView === 'single' ? 'transform scale-95' : ''
              )}
              highlightTerm={highlightTerm}
              aiScore={candidate.aiScore}
              onSetAiTarget={onSetAiTarget}
              isAiTarget={aiTargetCandidate?.id === candidate.id}
              isSelectableForComparison={
                !!aiTargetCandidate &&
                aiTargetCandidate.profile.gender !== candidate.profile.gender &&
                aiTargetCandidate.id !== candidate.id
              }
              isSelectedForComparison={!!comparisonSelection[candidate.id]}
              onToggleComparison={onToggleComparison}
            />
            <button
              className="absolute top-2 left-2 bg-primary text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity z-10"
              onClick={(e) => {
                e.stopPropagation();
                handleAction("edit", candidate);
              }}
              aria-label="ערוך פרופיל"
              title="ערוך פרופיל"
            >
              <Edit className="w-4 h-4" />
            </button>
          </div>
        ))}
      </div>

      {hoveredCandidate && !isMobile && (
        <div
          ref={quickViewRef}
          className="fixed z-50 md:absolute transform -translate-x-1/2 sm:translate-x-0"
          style={{
            top: `${hoverPosition.top}px`,
            left: `${hoverPosition.left}px`,
            maxWidth: window.innerWidth < 768 ? "calc(100vw - 32px)" : "420px",
            ...(window.innerWidth < 768
              ? {
                  left: "50%",
                  transform: "translateX(-50%)",
                  maxHeight: "85vh",
                }
              : {}),
          }}
        >
          <div className="drop-shadow-2xl">
            <QuickView
              candidate={hoveredCandidate}
              onAction={(action) => handleAction(action, hoveredCandidate)}
              onSetAiTarget={(c, e) => onSetAiTarget(c, e)}
              isAiTarget={aiTargetCandidate?.id === hoveredCandidate.id}
            />
          </div>
        </div>
      )}

      <Dialog
        open={!!selectedCandidate}
        onOpenChange={(open) => {
          if (!open) {
            setSelectedCandidate(null);
            setQuestionnaireResponse(null);
          }
        }}
      >
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <div className="flex items-center justify-between">
              <DialogTitle>פרופיל מועמד</DialogTitle>
              <Button
                variant="outline"
                onClick={() => handleAction("edit", selectedCandidate!)}
                className="flex items-center gap-2"
              >
                <Edit className="w-4 h-4" />
                עריכת פרופיל
              </Button>
            </div>
            <DialogDescription>צפייה בפרטי המועמד</DialogDescription>
            <Select
              value={isMatchmaker ? "matchmaker" : "candidate"}
              onValueChange={(value) => setIsMatchmaker(value === "matchmaker")}
            >
              <SelectTrigger className="w-full sm:w-48">
                <SelectValue placeholder="בחר תצוגה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="candidate">תצוגת מועמד</SelectItem>
                <SelectItem value="matchmaker">תצוגת שדכן</SelectItem>
              </SelectContent>
            </Select>
          </DialogHeader>

          {selectedCandidate && (
            <div className="space-y-6">
              <ProfileCard
                profile={selectedCandidate.profile}
                images={selectedCandidate.images}
                questionnaire={questionnaireResponse}
                viewMode={isMatchmaker ? "matchmaker" : "candidate"}
              />
            </div>
          )}
        </DialogContent>
      </Dialog>

      <ActionDialogs
        suggestDialog={{
          isOpen: showSuggestDialog,
          onClose: () => setShowSuggestDialog(false),
          onSubmit: handleCreateSuggestion,
          selectedCandidate: dialogCandidate,
        }}
        availabilityDialog={{
          isOpen: showAvailabilityDialog,
          onClose: () => setShowAvailabilityDialog(false),
          onCheck: handleAvailabilityCheck,
          selectedCandidate: dialogCandidate,
        }}
        inviteDialog={{
          isOpen: showInviteDialog,
          onClose: () => setShowInviteDialog(false),
          onInvite: handleInvite,
          selectedCandidate: dialogCandidate,
        }}
      />

      <NewSuggestionForm
        isOpen={showSuggestDialog}
        onClose={() => setShowSuggestDialog(false)}
        candidates={allCandidates}
        selectedCandidate={selectedCandidate}
        onSubmit={handleCreateSuggestion}
      />

      <MatchmakerEditProfile
        isOpen={showEditProfileDialog}
        onClose={() => setShowEditProfileDialog(false)}
        candidate={dialogCandidate}
      />
    </>
  );
};

export default CandidatesList;
--- End of Content for CandidatesList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesStats.tsx
--------------------------------------------------------------------------------
Content:
// /CandidatesManager/CandidatesStats.tsx

"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Users,
  UserSquare2,
  Clock,
  MapPin,
  CheckCircle,
  Image as ImageIcon,
} from "lucide-react";
import { useStatistics } from "../hooks/useStatistics";
import type { Candidate } from "../types/candidates";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from "recharts";

interface StatCardProps {
  title: string;
  value: string | number;
  description?: string;
  icon: React.ReactNode;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

interface CandidatesStatsProps {
  candidates: Candidate[];
  className?: string;
}

const CHART_COLORS = [
  "#3B82F6", // כחול
  "#EF4444", // אדום
  "#10B981", // ירוק
  "#F59E0B", // כתום
  "#6366F1", // סגול
  "#EC4899", // ורוד
];

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  icon,
  trend,
  className,
}) => (
  <Card className={`p-6 ${className}`}>
    <div className="flex items-start justify-between">
      <div className="space-y-2">
        <p className="text-sm text-gray-500">{title}</p>
        <p className="text-2xl font-semibold">{value}</p>
        {description && <p className="text-xs text-gray-400">{description}</p>}
        {trend && (
          <div
            className={`text-xs flex items-center gap-1 ${
              trend.isPositive ? "text-green-600" : "text-red-600"
            }`}
          >
            <span>{trend.isPositive ? "↑" : "↓"}</span>
            <span>{Math.abs(trend.value)}%</span>
            <span>מהחודש שעבר</span>
          </div>
        )}
      </div>
      <div className="bg-blue-50 p-3 rounded-lg">{icon}</div>
    </div>
  </Card>
);

const CandidatesStats: React.FC<CandidatesStatsProps> = ({
  candidates,
  className,
}) => {
  const {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats,
  } = useStatistics(candidates);

  const genderRatio = getGenderRatio();
  const activeUsers = getActiveUsersPercent();
  const completionStats = getProfileCompletionStats();
  const ageDistribution = getAgeGroupDistribution();
  const religiousDistribution = getReligiousDistribution();
  const activityTrend = getActivityTrend();
  const topCities = getTopCities(5);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* סטטיסטיקות עיקריות */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          title="סה״כ מועמדים"
          value={stats.gender.total}
          icon={<Users className="w-6 h-6 text-blue-600" />}
          description="סה״כ מועמדים פעילים במערכת"
        />
        <StatCard
          title="יחס מועמדים/ות"
          value={genderRatio.formattedRatio}
          icon={<UserSquare2 className="w-6 h-6 text-blue-600" />}
          description="גברים/נשים"
        />
        <StatCard
          title="פעילות בשבוע האחרון"
          value={`${activeUsers}%`}
          icon={<Clock className="w-6 h-6 text-blue-600" />}
          trend={{
            value: 5,
            isPositive: true,
          }}
        />
        <StatCard
          title="פרופילים מלאים"
          value={`${completionStats.percentage}%`}
          icon={<CheckCircle className="w-6 h-6 text-blue-600" />}
          description={`${completionStats.completed} מתוך ${stats.gender.total}`}
        />
      </div>

      {/* טאבים לניתוחים מתקדמים */}
      <Tabs defaultValue="demographics" className="w-full">
        <TabsList className="w-full justify-start">
          <TabsTrigger value="demographics">דמוגרפיה</TabsTrigger>
          <TabsTrigger value="activity">פעילות</TabsTrigger>
          <TabsTrigger value="completion">שלמות פרופילים</TabsTrigger>
        </TabsList>

        {/* דמוגרפיה */}
        <TabsContent value="demographics">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* התפלגות גילאים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות גילאים</h3>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={ageDistribution}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="range" />
                  <YAxis />
                  <Tooltip />
                  <Bar dataKey="count" fill="#3B82F6" />
                </BarChart>
              </ResponsiveContainer>
            </Card>

            {/* התפלגות דתית */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות רמת דתיות</h3>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={religiousDistribution}
                    dataKey="count"
                    nameKey="level"
                    cx="50%"
                    cy="50%"
                    outerRadius={100}
                    label
                  >
                    {religiousDistribution.map((_, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={CHART_COLORS[index % CHART_COLORS.length]}
                      />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </Card>

            {/* מיקומים מובילים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">ערים מובילות</h3>
              <div className="space-y-4">
                {topCities.map((city) => (
                  <div
                    key={city.city}
                    className="flex items-center justify-between"
                  >
                    <div className="flex items-center gap-2">
                      <MapPin className="w-4 h-4 text-blue-600" />
                      <span>{city.city}</span>
                    </div>
                    <span className="font-medium">{city.count}</span>
                  </div>
                ))}
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* פעילות */}
        <TabsContent value="activity">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* פעילות לאורך זמן */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">פעילות משתמשים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <span>פעילים בשבוע האחרון</span>
                  <span className="font-medium">{activityTrend.weekly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>פעילים בחודש האחרון</span>
                  <span className="font-medium">{activityTrend.monthly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>ממוצע ימים בין התחברויות</span>
                  <span className="font-medium">
                    {activityTrend.average} ימים
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* שלמות פרופילים */}
        <TabsContent value="completion">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">שלמות פרופילים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <ImageIcon className="w-4 h-4 text-blue-600" />
                    <span>תמונות פרופיל</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasPhotos}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <CheckCircle className="w-4 h-4 text-blue-600" />
                    <span>פרופיל מאומת</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.isVerified}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Users className="w-4 h-4 text-blue-600" />
                    <span>המלצות</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasReferences}%
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default CandidatesStats;
--- End of Content for CandidatesStats.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\SplitView.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/SplitView.tsx

"use client";

import React, { useMemo, useEffect, useState } from "react";
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import CandidatesList from "./CandidatesList";
import { Badge } from "@/components/ui/badge";
import { Sparkles, XCircle, Users, User } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import type { Candidate, CandidateAction, MobileView } from "../types/candidates";
import type { FilterState } from "../types/filters";
import SearchBar from "../Filters/SearchBar";
import { toast } from "sonner";
import { cn } from "@/lib/utils";
import { Gender } from "@prisma/client";

interface AiMatch {
  userId: string;
  score: number;
}

interface SplitViewProps {
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  allCandidates: Candidate[];
  onCandidateAction: (type: CandidateAction, candidate: Candidate) => void;
  onCandidateClick: (candidate: Candidate) => void;
  viewMode: "grid" | "list";
  mobileView: MobileView;
  isLoading?: boolean;
  className?: string;
  
  // --- AI State and Handlers (Received from Parent) ---
  aiTargetCandidate: Candidate | null;
  aiMatches: AiMatch[];
  isAiLoading: boolean;
  onSetAiTarget: (candidate: Candidate, e: React.MouseEvent) => void;
  onClearAiTarget: (e: React.MouseEvent) => void;
  setAiMatches: React.Dispatch<React.SetStateAction<AiMatch[]>>;
  setIsAiLoading: React.Dispatch<React.SetStateAction<boolean>>;
  comparisonSelection: Record<string, Candidate>;
  onToggleComparison: (candidate: Candidate, e: React.MouseEvent) => void;

  // --- Filter Props ---
  separateFiltering: boolean;
  maleFilters?: Partial<FilterState>;
  femaleFilters?: Partial<FilterState>;
  onMaleFiltersChange: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange: (filters: Partial<FilterState>) => void;
  onCopyFilters: (source: "male" | "female", target: "male" | "female") => void;
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  onMaleSearchChange?: (query: string) => void;
  onFemaleSearchChange?: (query: string) => void;
}

const SplitView: React.FC<SplitViewProps> = (props) => {
  const {
    maleCandidates,
    femaleCandidates,
    allCandidates,
    onCandidateAction,
    onCandidateClick,
    viewMode,
    mobileView,
    isLoading = false,
    className,
    maleSearchQuery = "",
    femaleSearchQuery = "",
    onMaleSearchChange,
    onFemaleSearchChange,
    // --- Destructure AI props ---
    aiTargetCandidate,
    aiMatches,
    isAiLoading,
    onSetAiTarget,
    onClearAiTarget,
    setAiMatches,
    setIsAiLoading,
    comparisonSelection,
    onToggleComparison,
  } = props;

  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreenSize = () => setIsMobile(window.innerWidth < 768);
    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);
    return () => window.removeEventListener("resize", checkScreenSize);
  }, []);

  const handleFindAiMatches = async (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!aiTargetCandidate) return;

    setIsAiLoading(true);
    setAiMatches([]);

    const targetGender = aiTargetCandidate.profile.gender;
    const candidatePool = targetGender === Gender.MALE ? femaleCandidates : maleCandidates;
    const candidatePoolIds = candidatePool.map(c => c.id);

    if (candidatePoolIds.length === 0) {
      toast.error("אין מועמדים במאגר לחיפוש התאמות.", { position: "top-center" });
      setIsAiLoading(false);
      return;
    }
    
    try {
      const response = await fetch('/api/ai/find-matches', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ targetUserId: aiTargetCandidate.id, candidatePoolIds }),
      });

      const data = await response.json();
      if (!response.ok || !data.success) throw new Error(data.error || 'Failed to fetch AI matches');
      
      setAiMatches(data.matches);
      toast.success(`נמצאו ${data.matches.length} התאמות AI פוטנציאליות.`, {
         position: "top-center",
         description: "המועמדים המומלצים מסומנים ומוינו לראש הרשימה."
      });
    } catch (error) {
      console.error("Error finding AI matches:", error);
      toast.error("שגיאה במציאת התאמות AI.", {
          description: error instanceof Error ? error.message : "נסה שוב מאוחר יותר.",
      });
    } finally {
      setIsAiLoading(false);
    }
  };
  
  const maleCandidatesWithScores = useMemo(() => {
    if (aiMatches.length === 0) return maleCandidates;
    const scoreMap = new Map(aiMatches.map(m => [m.userId, m.score]));
    return maleCandidates
      .map(c => ({ ...c, aiScore: scoreMap.get(c.id) }))
      .sort((a, b) => (b.aiScore ?? -1) - (a.aiScore ?? -1));
  }, [maleCandidates, aiMatches]);

  const femaleCandidatesWithScores = useMemo(() => {
    if (aiMatches.length === 0) return femaleCandidates;
    const scoreMap = new Map(aiMatches.map(m => [m.userId, m.score]));
    return femaleCandidates
      .map(c => ({ ...c, aiScore: scoreMap.get(c.id) }))
      .sort((a, b) => (b.aiScore ?? -1) - (a.aiScore ?? -1));
  }, [femaleCandidates, aiMatches]);

  const renderPanelHeader = (gender: 'male' | 'female', isMobileView: boolean = false) => {
      const panelGenderEnum = gender === 'male' ? Gender.MALE : Gender.FEMALE;
      const isTargetPanel = aiTargetCandidate?.profile.gender === panelGenderEnum;
      const isSearchPanel = aiTargetCandidate && aiTargetCandidate.profile.gender !== panelGenderEnum;
      const count = gender === 'male' ? maleCandidates.length : femaleCandidates.length;

      return (
        <div className={cn("flex justify-between items-center mb-2 p-2 rounded-t-lg", !isMobileView && "bg-gray-50 border-b")}>
          <h2 className={cn("text-lg font-bold", gender === 'male' ? "text-blue-800" : "text-purple-800")}>
            {gender === 'male' ? `מועמדים (${count})` : `מועמדות (${count})`}
          </h2>
          <div className="flex-grow" />
          <div className="flex items-center gap-2">
              {isTargetPanel && aiTargetCandidate && (
                <div className="flex items-center gap-2 bg-green-100 p-1.5 rounded-full shadow-sm animate-fade-in">
                  <span className="text-xs font-medium text-green-800 px-2">מטרה: {aiTargetCandidate.firstName}</span>
                  <Button size="icon" variant="ghost" className="h-6 w-6 text-green-700 hover:bg-green-200 rounded-full" onClick={onClearAiTarget}>
                    <XCircle className="h-4 w-4"/>
                  </Button>
                </div>
              )}
              {isSearchPanel && (
                <Button size="sm" onClick={handleFindAiMatches} disabled={isAiLoading}>
                  <Sparkles className={`ml-2 h-4 w-4 ${isAiLoading ? 'animate-spin' : ''}`}/>
                  {isAiLoading ? 'מחפש...' : 'מצא התאמות AI'}
                </Button>
              )}
          </div>
        </div>
      );
  };

  // --- Mobile View Logic ---
  if (isMobile) {
    if (mobileView === 'split') {
      // --- START OF CHANGE ---
      // The container now has h-full to take the height from its parent in CandidatesManager
      return (
        <div className="grid grid-cols-2 gap-2 h-full">
          {/* Male Candidates Column */}
          <div className="flex flex-col h-full">
            <div className="p-2 text-center flex-shrink-0">
              <h2 className="text-sm font-bold text-blue-800 flex items-center justify-center gap-1">
                <User className="w-4 h-4" /> מועמדים <Badge variant="secondary">{maleCandidates.length}</Badge>
              </h2>
            </div>
            {/* This div will grow to fill the space and handle its own scrolling */}
            <div className="flex-grow min-h-0 overflow-y-auto">
              <CandidatesList
                candidates={maleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode="grid"
                mobileView="single"
                isLoading={isLoading}
                highlightTerm={maleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>

          {/* Female Candidates Column */}
          <div className="flex flex-col h-full">
            <div className="p-2 text-center flex-shrink-0">
              <h2 className="text-sm font-bold text-purple-800 flex items-center justify-center gap-1">
                <User className="w-4 h-4" /> מועמדות <Badge variant="secondary">{femaleCandidates.length}</Badge>
              </h2>
            </div>
            <div className="flex-grow min-h-0 overflow-y-auto">
              <CandidatesList
                candidates={femaleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode="grid"
                mobileView="single"
                isLoading={isLoading}
                highlightTerm={femaleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </div>
      );
      // --- END OF CHANGE ---
    }

    // Original Tabs view for 'single' or 'double' column modes
    return (
        <div className={cn("w-full h-full", className)}>
            <Tabs defaultValue="male" className="w-full h-full flex flex-col">
                <TabsList className="grid w-full grid-cols-2 flex-shrink-0">
                    <TabsTrigger value="male" className="flex items-center gap-2">
                        <User className="h-4 w-4"/> מועמדים <Badge variant="secondary">{maleCandidates.length}</Badge>
                    </TabsTrigger>
                    <TabsTrigger value="female" className="flex items-center gap-2">
                        <User className="h-4 w-4"/> מועמדות <Badge variant="secondary">{femaleCandidates.length}</Badge>
                    </TabsTrigger>
                </TabsList>
                <TabsContent value="male" className="mt-4 flex-1 min-h-0">
                    <div className="p-1 flex flex-col h-full">
                        {renderPanelHeader('male', true)}
                        {onMaleSearchChange && <SearchBar value={maleSearchQuery} onChange={onMaleSearchChange} placeholder="חיפוש מועמדים..." genderTarget="male" separateMode={true} />}
                        <div className="flex-grow min-h-0 overflow-y-auto">
                            <CandidatesList
                                candidates={maleCandidatesWithScores}
                                allCandidates={allCandidates}
                                onCandidateClick={onCandidateClick}
                                onCandidateAction={onCandidateAction}
                                viewMode={viewMode}
                                mobileView={mobileView}
                                isLoading={isLoading}
                                highlightTerm={maleSearchQuery}
                                aiTargetCandidate={aiTargetCandidate}
                                onSetAiTarget={onSetAiTarget}
                                comparisonSelection={comparisonSelection}
                                onToggleComparison={onToggleComparison}
                            />
                        </div>
                    </div>
                </TabsContent>
                <TabsContent value="female" className="mt-4 flex-1 min-h-0">
                    <div className="p-1 flex flex-col h-full">
                        {renderPanelHeader('female', true)}
                        {onFemaleSearchChange && <SearchBar value={femaleSearchQuery} onChange={onFemaleSearchChange} placeholder="חיפוש מועמדות..." genderTarget="female" separateMode={true} />}
                        <div className="flex-grow min-h-0 overflow-y-auto">
                            <CandidatesList
                                candidates={femaleCandidatesWithScores}
                                allCandidates={allCandidates}
                                onCandidateClick={onCandidateClick}
                                onCandidateAction={onCandidateAction}
                                viewMode={viewMode}
                                mobileView={mobileView}
                                isLoading={isLoading}
                                highlightTerm={femaleSearchQuery}
                                aiTargetCandidate={aiTargetCandidate}
                                onSetAiTarget={onSetAiTarget}
                                comparisonSelection={comparisonSelection}
                                onToggleComparison={onToggleComparison}
                            />
                        </div>
                    </div>
                </TabsContent>
            </Tabs>
        </div>
    );
  }

  // --- Desktop View using Resizable Panels ---
  return (
    <div className={cn("h-full", className)}>
      <ResizablePanelGroup direction="horizontal" className="h-full rounded-lg bg-white shadow-sm border">
        <ResizablePanel defaultSize={50} minSize={30}>
          <div className="p-3 flex flex-col h-full">
            {renderPanelHeader('male')}
            {onMaleSearchChange && <SearchBar value={maleSearchQuery} onChange={onMaleSearchChange} placeholder="חיפוש מועמדים..." genderTarget="male" separateMode={true} />}
            <div className="flex-grow min-h-0 overflow-y-auto">
              <CandidatesList
                candidates={maleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={isLoading}
                highlightTerm={maleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </ResizablePanel>
        <ResizableHandle withHandle />
        <ResizablePanel defaultSize={50} minSize={30}>
          <div className="p-3 flex flex-col h-full">
            {renderPanelHeader('female')}
            {onFemaleSearchChange && <SearchBar value={femaleSearchQuery} onChange={onFemaleSearchChange} placeholder="חיפוש מועמדות..." genderTarget="female" separateMode={true} />}
            <div className="flex-grow min-h-0 overflow-y-auto">
               <CandidatesList
                candidates={femaleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={isLoading}
                highlightTerm={femaleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  );
};

export default SplitView;
--- End of Content for SplitView.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\StatsCard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };
  variant?: "default" | "success" | "warning" | "destructive";
  bgGradient?: string;
  iconColor?: string;
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  variant = "default",
  bgGradient,
  iconColor = "text-primary",
  className,
}) => {
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "border-emerald-200";
      case "warning":
        return "border-amber-200";
      case "destructive":
        return "border-red-200";
      default:
        return "border-gray-200";
    }
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-all duration-300 p-4 overflow-hidden",
        bgGradient ? `bg-gradient-to-br ${bgGradient}` : "bg-card",
        getVariantStyles(),
        className
      )}
    >
      <div className="flex items-start justify-between">
        <div className="mr-4 flex-shrink-0">
          <div className={`p-2.5 rounded-full bg-white/60 backdrop-blur-sm shadow-sm`}>
            <Icon className={`w-4 h-4 ${iconColor}`} />
          </div>
        </div>

        <div className="flex-1 text-right">
          <p className="text-xs text-muted-foreground mb-1">{title}</p>
          <h3 className="text-xl font-bold">{value}</h3>

          {trend && (
            <div className="flex items-center justify-end gap-1 mt-1">
              <span
                className={cn(
                  "text-sm font-medium flex items-center gap-0.5",
                  trend.isPositive ? "text-emerald-600" : "text-red-600"
                )}
              >
                {trend.isPositive ? "+" : "-"}{trend.value}%
                <span className={`${trend.isPositive ? "rotate-0" : "rotate-180"} transition-transform`}>
                  ↑
                </span>
              </span>
              <span className="text-[11px] text-muted-foreground">
                {trend.label}
              </span>
            </div>
          )}
        </div>
      </div>

      {/* Animated background pattern for more visual appeal */}
      <div className="absolute right-0 bottom-0 opacity-10 pointer-events-none">
        <svg width="80" height="80" viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="60" cy="60" r="40" fill="currentColor" />
        </svg>
      </div>
    </Card>
  );
};

export default StatsCard;
--- End of Content for StatsCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\index.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/index.tsx

"use client";

import React, { useState, useCallback, useEffect, useMemo } from "react";
import { Button } from "@/components/ui/button";
import { UserPlus, Filter, LayoutGrid, List, ArrowUpDown, RotateCw, BarChart2, Bot, Loader2, Columns, View, Users, Split } from "lucide-react";
import { toast } from "sonner";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuRadioGroup, DropdownMenuRadioItem } from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useSession } from "next-auth/react";

// Custom Hooks
import { useCandidates } from "../hooks/useCandidates";
import { useFilterLogic } from "../hooks/useFilterLogic";

// Components
import SplitView from "./SplitView";
import FilterPanel from "../Filters/FilterPanel";
import ActiveFilters from "../Filters/ActiveFilters";
import SearchBar from "../Filters/SearchBar";
import { LoadingContainer } from "../shared/LoadingStates";
import { AddManualCandidateDialog } from "../dialogs/AddManualCandidateDialog";
import { AiMatchAnalysisDialog } from "../dialogs/AiMatchAnalysisDialog";

// Types
import type { Candidate, ViewMode, CandidatesFilter, CandidateAction, MobileView } from "../types/candidates"; 

// Constants
import { SORT_OPTIONS, VIEW_OPTIONS } from "../constants/filterOptions";

interface AiMatch {
  userId: string;
  score: number;
}

const CandidatesManager: React.FC = () => {
  // --- UI and General State ---
  const [viewMode, setViewMode] = useState<ViewMode>("grid");
  const [mobileView, setMobileView] = useState<MobileView>('split'); 
  const [showFiltersPanel, setShowFiltersPanel] = useState(false);
  const [showFiltersMobile, setShowFiltersMobile] = useState(false);
  const [showManualAddDialog, setShowManualAddDialog] = useState(false);
  
  // --- AI State Management ---
  const [aiTargetCandidate, setAiTargetCandidate] = useState<Candidate | null>(null);
  const [comparisonSelection, setComparisonSelection] = useState<Record<string, Candidate>>({});
  const [aiMatches, setAiMatches] = useState<AiMatch[]>([]);
  const [isAiLoading, setIsAiLoading] = useState(false);
  const [isAnalysisDialogOpen, setIsAnalysisDialogOpen] = useState(false);
  const [isBulkUpdating, setIsBulkUpdating] = useState(false); 

  // --- Session and Permissions ---
  const { data: session } = useSession();
  const isAdmin = session?.user?.role === 'ADMIN';

  // Custom Hooks
  const {
    loading,
    candidates,
    maleCandidates,
    femaleCandidates,
    setSorting,
    setFilters,
    refresh,
  } = useCandidates();

  const {
    filters,
    savedFilters,
    recentSearches,
    popularFilters,
    activeFilters,
    saveFilter,
    resetFilters,
    clearRecentSearches,
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
  } = useFilterLogic({
    onFilterChange: setFilters,
  });

  // --- Handlers ---
  const handleCandidateAdded = useCallback(() => { refresh(); toast.success("מועמד חדש נוסף בהצלחה!"); }, [refresh]);
  const handleSearch = useCallback((value: string) => { if (!filters.separateFiltering) { setFilters(prev => ({ ...prev, searchQuery: value })); } }, [setFilters, filters.separateFiltering]);
  const handleRemoveFilter = useCallback((key: keyof CandidatesFilter, value?: string) => { setFilters(prev => { const newFilters = { ...prev }; if (key === "cities" && value) newFilters.cities = newFilters.cities?.filter(city => city !== value); else if (key === "occupations" && value) newFilters.occupations = newFilters.occupations?.filter(occ => occ !== value); else delete newFilters[key]; return newFilters; }); }, [setFilters]);
  const handleCandidateAction = useCallback(async (type: CandidateAction, candidate: Candidate) => { console.log(`Action '${type}' triggered for candidate: ${candidate.firstName}`); }, []);
  const handleFilterSave = useCallback(async (name: string) => { try { await saveFilter(name, filters); toast.success("הפילטר נשמר בהצלחה"); } catch { toast.error("שגיאה בשמירת הפילטר"); } }, [filters, saveFilter]);
  const handleSetAiTarget = useCallback((candidate: Candidate, e: React.MouseEvent) => { e.stopPropagation(); if (aiTargetCandidate?.id === candidate.id) { handleClearAiTarget(e); return; } setAiTargetCandidate(candidate); setAiMatches([]); setComparisonSelection({}); toast.info(`מועמד מטרה נבחר: ${candidate.firstName}. כעת ניתן לחפש התאמות בפאנל הנגדי.`, { position: "bottom-center" }); }, [aiTargetCandidate]);
  const handleClearAiTarget = (e: React.MouseEvent) => { e.stopPropagation(); setAiTargetCandidate(null); setAiMatches([]); setComparisonSelection({}); toast.info("בחירת מועמד מטרה בוטלה.", { position: "bottom-center" }); };
  const handleToggleComparison = useCallback((candidate: Candidate, e: React.MouseEvent) => { e.stopPropagation(); setComparisonSelection(prev => { const newSelection = {...prev}; if (newSelection[candidate.id]) { delete newSelection[candidate.id]; } else { newSelection[candidate.id] = candidate; } return newSelection; }); }, []);
  const handleUpdateAllProfiles = async () => { setIsBulkUpdating(true); toast.info("מתחיל תהליך עדכון פרופילי AI...", { description: "התהליך ירוץ ברקע. אין צורך להישאר בעמוד זה.", }); try { const response = await fetch('/api/ai/update-all-profiles', { method: 'POST', }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'שגיאה בהפעלת העדכון הכללי.'); toast.success("העדכון הכללי הופעל בהצלחה!", { description: data.message, duration: 8000, }); } catch (error) { console.error("Failed to initiate bulk AI profile update:", error); toast.error("שגיאה בהפעלת העדכון", { description: error instanceof Error ? error.message : 'אנא נסה שוב מאוחר יותר.', }); } finally { setIsBulkUpdating(false); } };
  
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreen = () => {
      const isDesktop = window.innerWidth >= 1024;
      const isMob = window.innerWidth < 768;
      setShowFiltersPanel(isDesktop);
      setIsMobile(isMob);
    };
    checkScreen();
    window.addEventListener('resize', checkScreen);
    return () => window.removeEventListener('resize', checkScreen);
  }, []);

  const activeFilterCount = useMemo(() => activeFilters.length, [activeFilters]);

  return (
    // --- START OF FIX ---
    // 1. שינוי מבנה העמוד הראשי ל-flex-col עם גובה מסך מלא (h-screen)
    //    זה מאפשר לנו לשלוט בגובה של אזור התוכן הראשי.
    <div className="h-screen flex flex-col bg-gray-50/50">
      {/* 2. הכותרת הופכת ל-flex-shrink-0 כדי לא לתפוס גובה גמיש.
          הסרנו את "sticky" כדי לאפשר layout יציב ופשוט יותר. */}
      <header className="flex-shrink-0 z-30 bg-white/80 backdrop-blur-sm border-b shadow-sm">
        <div className="container mx-auto py-3 px-4">
          <div className="flex justify-between items-center mb-4">
            <h1 className="text-2xl font-bold text-primary/90">ניהול מועמדים</h1>
            <div className="flex items-center gap-2">
              <Button onClick={() => setShowManualAddDialog(true)} size="sm">
                <UserPlus className="w-4 h-4 ml-2" />
                הוסף מועמד ידנית
              </Button>
               {Object.keys(comparisonSelection).length > 0 && aiTargetCandidate && (
                <Button onClick={() => setIsAnalysisDialogOpen(true)} size="sm" variant="secondary">
                    <BarChart2 className="w-4 h-4 ml-2"/>
                    נתח התאמה ({Object.keys(comparisonSelection).length})
                </Button>
              )}
              
              {isAdmin && (
                <AlertDialog>
                    <AlertDialogTrigger asChild>
                        <Button variant="destructive" size="sm" disabled={isBulkUpdating || loading}>
                            {isBulkUpdating ? <Loader2 className="w-4 h-4 ml-2 animate-spin" /> : <Bot className="w-4 h-4 ml-2" />}
                            עדכון כללי AI
                        </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent dir="rtl">
                        <AlertDialogHeader>
                            <AlertDialogTitle>אישור עדכון AI כללי</AlertDialogTitle>
                            <AlertDialogDescription>
                                פעולה זו תפעיל תהליך עדכון וקטורים עבור **כל** המשתמשים הפעילים. 
                                התהליך ירוץ ברקע ועשוי לקחת מספר דקות. 
                                האם אתה בטוח שברצונך להמשיך?
                            </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                            <AlertDialogCancel>ביטול</AlertDialogCancel>
                            <AlertDialogAction onClick={handleUpdateAllProfiles}>כן, הפעל עדכון</AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialog>
              )}

              <Button onClick={refresh} variant="outline" size="icon" title="רענן רשימה" disabled={loading}>
                <RotateCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </Button>
            </div>
          </div>
          <div className="flex flex-col sm:flex-row gap-2">
            {!filters.separateFiltering && (
              <div className="flex-1">
                <SearchBar
                  value={filters.searchQuery || ""}
                  onChange={handleSearch}
                  placeholder="חיפוש כללי בשם, עיר, עיסוק..."
                  recentSearches={recentSearches}
                  onClearRecentSearches={clearRecentSearches}
                />
              </div>
            )}
            <div className="flex gap-2 justify-between">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm"><ArrowUpDown className="w-4 h-4 ml-2" />מיון</Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuLabel>מיון לפי</DropdownMenuLabel>
                  <DropdownMenuSeparator />
                  {SORT_OPTIONS.map((option) => (
                    <DropdownMenuItem key={option.value} onClick={() => setSorting(option.value, option.defaultOrder as "asc" | "desc")}>
                      {option.label}
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>

              <div className="hidden lg:flex">
                <Button variant="outline" size="sm" onClick={() => setShowFiltersPanel(!showFiltersPanel)}>
                  <Filter className="w-4 h-4 ml-2" />
                  {showFiltersPanel ? "הסתר סינון" : "הצג סינון"}
                </Button>
              </div>

              <Sheet open={showFiltersMobile} onOpenChange={setShowFiltersMobile}>
                <SheetTrigger asChild>
                  <Button variant="outline" size="sm" className="lg:hidden relative">
                    <Filter className="w-4 h-4 ml-2" />
                    סינון
                    {activeFilterCount > 0 && <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center">{activeFilterCount}</Badge>}
                  </Button>
                </SheetTrigger>
                <SheetContent>
                    <FilterPanel
                        filters={filters}
                        onFiltersChange={setFilters}
                        onSavePreset={handleFilterSave}
                        onReset={resetFilters}
                        savedFilters={savedFilters.map((f) => ({ id: f.id, name: f.name, isDefault: f.isDefault }))}
                        popularFilters={popularFilters}
                        separateFiltering={filters.separateFiltering}
                        onToggleSeparateFiltering={toggleSeparateFiltering}
                        onMaleFiltersChange={updateMaleFilters}
                        onFemaleFiltersChange={updateFemaleFilters}
                        onCopyFilters={copyFilters}
                    />
                </SheetContent>
              </Sheet>
              
               <div className="flex gap-1 bg-gray-100 p-1 rounded-lg">
                {isMobile ? (
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="outline" size="sm" className="w-32 justify-between px-2">
                        {mobileView === 'split' && (
                          <>
                            <Users className="w-4 h-4" />
                            <span>מפוצל</span>
                          </>
                        )}
                        {mobileView === 'single' && (
                          <>
                            <View className="w-4 h-4" />
                            <span>טור אחד</span>
                          </>
                        )}
                        {mobileView === 'double' && (
                          <>
                            <Columns className="w-4 h-4" />
                            <span>שני טורים</span>
                          </>
                        )}
                        <ArrowUpDown className="w-3 h-3 opacity-50 ml-2" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuLabel>תצוגת מובייל</DropdownMenuLabel>
                      <DropdownMenuSeparator />
                      <DropdownMenuRadioGroup value={mobileView} onValueChange={(value) => setMobileView(value as MobileView)}>
                        <DropdownMenuRadioItem value="split">
                          <Users className="w-4 h-4 mr-2" />
                          תצוגה מפוצלת (גברים/נשים)
                        </DropdownMenuRadioItem>
                        <DropdownMenuRadioItem value="single">
                          <View className="w-4 h-4 mr-2" />
                          תצוגת טור אחד
                        </DropdownMenuRadioItem>
                        <DropdownMenuRadioItem value="double">
                          <Columns className="w-4 h-4 mr-2" />
                          תצוגת שני טורים
                        </DropdownMenuRadioItem>
                      </DropdownMenuRadioGroup>
                    </DropdownMenuContent>
                  </DropdownMenu>
                ) : (
                  VIEW_OPTIONS.map((option) => (
                    <Button key={option.value} variant={viewMode === option.value ? "default" : "ghost"} size="icon" onClick={() => setViewMode(option.value as ViewMode)}>
                      {option.value === 'grid' ? <LayoutGrid className="w-4 h-4"/> : <List className="w-4 h-4"/>}
                    </Button>
                  ))
                )}
              </div>
            </div>
          </div>
          <div className="mt-4">
            <ActiveFilters filters={filters} onRemoveFilter={handleRemoveFilter} onResetAll={resetFilters} />
          </div>
        </div>
      </header>
      
      {/* 3. אזור התוכן הראשי מקבל flex-1 ו-min-h-0 כדי למלא את הגובה הנותר ולא לגלוש החוצה. */}
      <main className="flex-1 min-h-0 container mx-auto py-6 px-4">
        {/* 4. הקונטיינר הפנימי מקבל h-full כדי להעביר את הגובה הלאה לילדיו. */}
        <div className="flex gap-6 h-full">
          {showFiltersPanel && (
            // 5. פאנל הסינון בצד - אם הוא נהיה ארוך מדי, הוא יגלוש פנימית.
            <aside className="hidden lg:block w-80 flex-shrink-0 overflow-y-auto">
              <FilterPanel
                filters={filters}
                onFiltersChange={setFilters}
                onSavePreset={handleFilterSave}
                onReset={resetFilters}
                savedFilters={savedFilters.map((f) => ({ id: f.id, name: f.name, isDefault: f.isDefault }))}
                popularFilters={popularFilters}
                separateFiltering={filters.separateFiltering}
                onToggleSeparateFiltering={toggleSeparateFiltering}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
              />
            </aside>
          )}

          {/* 6. הקונטיינר של SplitView מקבל h-full כדי שהוא ידע מה הגובה שלו. */}
          <div className="flex-1 min-w-0 h-full">
            {loading ? (
              <LoadingContainer>
                {/* התאמת גובה הסקלטון לגובה המלא של הקונטיינר */}
                <div className="h-full bg-gray-200 rounded-lg animate-pulse"></div>
              </LoadingContainer>
            ) : (
              // 7. SplitView מקבלת h-full וכעת יכולה לממש את הגלילה הפנימית הנפרדת לכל עמודה.
              <SplitView
                maleCandidates={maleCandidates}
                femaleCandidates={femaleCandidates}
                allCandidates={candidates}
                onCandidateAction={handleCandidateAction}
                onCandidateClick={() => {}}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={loading || isAiLoading}
                className="h-full" // הוספת h-full כאן היא קריטית
                
                aiTargetCandidate={aiTargetCandidate}
                aiMatches={aiMatches}
                isAiLoading={isAiLoading}
                onSetAiTarget={handleSetAiTarget}
                onClearAiTarget={handleClearAiTarget}
                setAiMatches={setAiMatches}
                setIsAiLoading={setIsAiLoading}
                comparisonSelection={comparisonSelection}
                onToggleComparison={handleToggleComparison}
                
                separateFiltering={filters.separateFiltering ?? false}
                maleFilters={filters.maleFilters}
                femaleFilters={filters.femaleFilters}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
                maleSearchQuery={filters.maleSearchQuery}
                femaleSearchQuery={filters.femaleSearchQuery}
                onMaleSearchChange={updateMaleSearchQuery}
                onFemaleSearchChange={updateFemaleSearchQuery}
              />
            )}
          </div>
        </div>
      </main>
      {/* --- END OF FIX --- */}

      {/* Dialogs */}
      <AddManualCandidateDialog
        isOpen={showManualAddDialog}
        onClose={() => setShowManualAddDialog(false)}
        onCandidateAdded={handleCandidateAdded}
      />

      <AiMatchAnalysisDialog
        isOpen={isAnalysisDialogOpen}
        onClose={() => setIsAnalysisDialogOpen(false)}
        targetCandidate={aiTargetCandidate}
        comparisonCandidates={Object.values(comparisonSelection)}
      />
    </div>
  );
};

export default CandidatesManager;
--- End of Content for index.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\ActiveFilters.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { X, RefreshCw, Sparkles } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import type { CandidatesFilter } from "../types/candidates";
import { motion, AnimatePresence } from "framer-motion";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ActiveFiltersProps {
  filters: CandidatesFilter;
  onRemoveFilter: (key: keyof CandidatesFilter, value?: string) => void;
  onResetAll: () => void;
  onSuggestFilter?: () => void;
  className?: string;
}

interface ActiveFilter {
  key: keyof CandidatesFilter;
  label: string;
  value?: string;
  color?: string;
}

const ActiveFilters: React.FC<ActiveFiltersProps> = ({
  filters,
  onRemoveFilter,
  onResetAll,
  onSuggestFilter,
  className,
}) => {
  const getActiveFilters = (): ActiveFilter[] => {
    const activeFilters: ActiveFilter[] = [];

    // חיפוש כללי (מופיע רק אם אין סינון נפרד)
    if (!filters.separateFiltering && filters.searchQuery) {
      activeFilters.push({
        key: "searchQuery",
        label: `חיפוש: ${filters.searchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לגברים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.maleSearchQuery) {
      activeFilters.push({
        key: "maleSearchQuery",
        label: `חיפוש מועמדים: ${filters.maleSearchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לנשים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.femaleSearchQuery) {
      activeFilters.push({
        key: "femaleSearchQuery",
        label: `חיפוש מועמדות: ${filters.femaleSearchQuery}`,
        color: "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // מצב סינון נפרד
    if (filters.separateFiltering) {
      activeFilters.push({
        key: "separateFiltering",
        label: `סינון וחיפוש נפרד`,
        color: "bg-indigo-100 text-indigo-800 border-indigo-200",
      });
    }

    // Gender
    if (filters.gender) {
      activeFilters.push({
        key: "gender",
        label: `מגדר: ${filters.gender === "MALE" ? "גברים" : "נשים"}`,
        color:
          filters.gender === "MALE"
            ? "bg-blue-100 text-blue-800 border-blue-200"
            : "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // Age Range
    if (filters.ageRange) {
      const isDefaultMin = filters.ageRange.min === 18;
      const isDefaultMax = filters.ageRange.max === 99;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גיל: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.ageRange.min}-${filters.ageRange.max}`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.ageRange.min}`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.ageRange.max}`;
        }

        activeFilters.push({
          key: "ageRange",
          label,
        });
      }
    }

    // Height Range
    if (filters.heightRange) {
      const isDefaultMin = filters.heightRange.min === 140;
      const isDefaultMax = filters.heightRange.max === 210;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גובה: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.heightRange.min}-${filters.heightRange.max} ס"מ`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.heightRange.min} ס"מ`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.heightRange.max} ס"מ`;
        }

        activeFilters.push({
          key: "heightRange",
          label,
        });
      }
    }

    // Religious Level
    if (filters.religiousLevel) {
      activeFilters.push({
        key: "religiousLevel",
        label: `רמת דתיות: ${filters.religiousLevel}`,
        color: "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Education Level
    if (filters.educationLevel) {
      activeFilters.push({
        key: "educationLevel",
        label: `השכלה: ${filters.educationLevel}`,
      });
    }

    // Cities
    filters.cities?.forEach((city) => {
      activeFilters.push({
        key: "cities",
        value: city,
        label: `עיר: ${city}`,
        color: "bg-green-100 text-green-800 border-green-200",
      });
    });

    // Occupations
    filters.occupations?.forEach((occupation) => {
      activeFilters.push({
        key: "occupations",
        value: occupation,
        label: `תחום עיסוק: ${occupation}`,
      });
    });

    // Availability Status
    if (filters.availabilityStatus) {
      const statusLabel =
        filters.availabilityStatus === "AVAILABLE"
          ? "פנוי/ה"
          : filters.availabilityStatus === "DATING"
          ? "בתהליך הכרות"
          : filters.availabilityStatus === "UNAVAILABLE"
          ? "לא פנוי/ה"
          : filters.availabilityStatus;

      activeFilters.push({
        key: "availabilityStatus",
        label: `סטטוס: ${statusLabel}`,
        color:
          filters.availabilityStatus === "AVAILABLE"
            ? "bg-emerald-100 text-emerald-800 border-emerald-200"
            : "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Marital Status
    if (filters.maritalStatus) {
      activeFilters.push({
        key: "maritalStatus",
        label: `מצב משפחתי: ${filters.maritalStatus}`,
      });
    }

    // Verified Filter
    if (filters.isVerified !== undefined) {
      activeFilters.push({
        key: "isVerified",
        label: `מאומתים בלבד`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // References Filter
    if (filters.hasReferences !== undefined) {
      activeFilters.push({
        key: "hasReferences",
        label: `עם המלצות`,
      });
    }

    // Profile Completeness
    if (filters.isProfileComplete !== undefined) {
      activeFilters.push({
        key: "isProfileComplete",
        label: `פרופיל מלא`,
      });
    }

    // Last Activity
    if (filters.lastActiveDays !== undefined) {
      let label: string;

      switch (filters.lastActiveDays) {
        case 1:
          label = "פעילים היום";
          break;
        case 3:
          label = "פעילים ב-3 ימים אחרונים";
          break;
        case 7:
          label = "פעילים בשבוע האחרון";
          break;
        case 30:
          label = "פעילים בחודש האחרון";
          break;
        default:
          label = `פעילים ב-${filters.lastActiveDays} ימים אחרונים`;
      }

      activeFilters.push({
        key: "lastActiveDays",
        label,
        color: "bg-cyan-100 text-cyan-800 border-cyan-200",
      });
    }

    return activeFilters;
  };

  const activeFilters = getActiveFilters();

  if (activeFilters.length === 0) {
    return null;
  }

  return (
    <div className={`${className || ""}`}>
      <div className="bg-white border rounded-lg p-3">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-sm font-medium text-gray-700 flex items-center gap-1.5">
            <span>סינון פעיל</span>
            <Badge variant="outline" className="bg-blue-50 text-xs">
              {activeFilters.length}
            </Badge>
          </h3>

          <div className="flex items-center gap-2">
            {onSuggestFilter && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={onSuggestFilter}
                      className="h-7 text-xs text-blue-600 hover:text-blue-700 hover:bg-blue-50"
                    >
                      <Sparkles className="w-3 h-3 mr-1" />
                      הצע פילטרים נוספים
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>הצעת פילטרים נוספים המתאימים לתוצאות הנוכחיות</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}

            <Button
              variant="ghost"
              size="sm"
              onClick={onResetAll}
              className="h-7 text-xs text-gray-600 hover:text-gray-700"
            >
              <RefreshCw className="w-3 h-3 mr-1" />
              נקה הכל
            </Button>
          </div>
        </div>

        <div className="flex flex-wrap gap-2">
          <AnimatePresence>
            {activeFilters.map((filter, index) => (
              <motion.div
                key={`${filter.key}-${filter.value || index}`}
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                transition={{ duration: 0.15 }}
              >
                <Badge
                  variant="secondary"
                  className={`px-2 py-0.5 whitespace-nowrap border ${
                    filter.color || "bg-gray-100 text-gray-800 border-gray-200"
                  }`}
                >
                  <span className="max-w-[200px] truncate">{filter.label}</span>
                  <button
                    className="ml-1.5 hover:bg-gray-200/40 rounded-full p-0.5 transition-colors"
                    onClick={() => onRemoveFilter(filter.key, filter.value)}
                    aria-label={`הסר פילטר ${filter.label}`}
                  >
                    <X className="w-3 h-3" />
                  </button>
                </Badge>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
};

export default ActiveFilters;
--- End of Content for ActiveFilters.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\FilterPanel.tsx
--------------------------------------------------------------------------------
Content:
// /Filters/FilterPanel.tsx - גרסה משופרת
import React, { useState } from "react";
import { Card } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { UserSource } from "@prisma/client"; // At the top
import { UserStatus } from "@prisma/client";

import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { UserPlus } from "lucide-react"; // Add UserPlus for the button

import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Save,
  User,
  GraduationCap,
  MapPin,
  Scroll,
  Calendar,
  ChevronDown,
  ChevronUp,
  Clock,
  Ruler,
  Heart,
  Briefcase,
  Star,
  RefreshCw,
  Bookmark,
  Check,
  Filter as FilterIcon,
  Copy,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type { FilterState } from "../types/filters";
import type { CandidatesFilter } from "../types/candidates";
import SavedFilters from "./SavedFilters";
import {
  AGE_RANGE,
  HEIGHT_RANGE,
  RELIGIOUS_LEVELS,
  EDUCATION_LEVELS,
  OCCUPATION_CATEGORIES,
  POPULAR_CITIES,
  AVAILABILITY_STATUS_OPTIONS,
  MARITAL_STATUS,
} from "../constants/filterOptions";

interface PopularFilterOption {
  id: string;
  label: string;
  icon: React.ReactNode;
  filter: Partial<CandidatesFilter>;
}

interface FilterPanelProps {
  filters: CandidatesFilter;
  onFiltersChange: (filters: CandidatesFilter) => void;
  onSavePreset?: (name: string) => void;
  onReset: () => void;
  onApplySavedFilter?: (id: string) => void;
  savedFilters?: Array<{
    id: string;
    name: string;
    isDefault?: boolean;
  }>;
  popularFilters?: string[];
  className?: string;
  compactMode?: boolean;

  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering?: boolean;
  onToggleSeparateFiltering?: () => void;
  onMaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}

interface FilterSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
  defaultOpen?: boolean;
  badge?: number;
}

const POPULAR_FILTERS: PopularFilterOption[] = [
  {
    id: "active-recently",
    label: "פעילים לאחרונה",
    icon: <Clock className="w-4 h-4 text-blue-600" />,
    filter: {
      lastActiveDays: 7,
    },
  },
  {
    id: "verified-only",
    label: "מאומתים בלבד",
    icon: <Check className="w-4 h-4 text-blue-600" />,
    filter: {
      isVerified: true,
    },
  },
  {
    id: "has-recommendations",
    label: "עם המלצות",
    icon: <Star className="w-4 h-4 text-blue-600" />,
    filter: {
      hasReferences: true,
    },
  },
  {
    id: "available-only",
    label: "פנויים בלבד",
    icon: <Heart className="w-4 h-4 text-blue-600" />,
    filter: {
      availabilityStatus: "AVAILABLE",
    },
  },
  {
    id: "complete-profiles",
    label: "פרופילים מלאים",
    icon: <User className="w-4 h-4 text-blue-600" />,
    filter: {
      isProfileComplete: true,
    },
  },
];

const FilterSection: React.FC<FilterSectionProps> = ({
  title,
  icon,
  children,
  defaultOpen = false,
  badge,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <Collapsible
      open={isOpen}
      onOpenChange={setIsOpen}
      className="border rounded-lg mb-3 overflow-hidden bg-white"
    >
      <CollapsibleTrigger asChild>
        <div className="flex items-center justify-between p-4 cursor-pointer hover:bg-blue-50/30 transition-colors">
          <div className="flex items-center gap-2">
            <div className="bg-blue-50 p-2 rounded-md text-blue-600">
              {icon}
            </div>
            <span className="font-medium">{title}</span>
            {badge !== undefined && (
              <Badge
                variant="secondary"
                className="bg-blue-100 text-blue-800 text-xs mr-2"
              >
                {badge}
              </Badge>
            )}
          </div>
          {isOpen ? (
            <ChevronUp size={16} className="text-gray-500" />
          ) : (
            <ChevronDown size={16} className="text-gray-500" />
          )}
        </div>
      </CollapsibleTrigger>
      <CollapsibleContent className="px-4 pb-4 pt-1 border-t">
        {children}
      </CollapsibleContent>
    </Collapsible>
  );
};

// קומפוננט חדש לסינון מגדרי
const GenderFilterPanel = ({
  gender,
  filters,
  onFiltersChange,
  className,
  copyTarget,
  onCopyFilters,
}: {
  gender: "male" | "female";
  filters: Partial<FilterState>;
  onFiltersChange: (filters: Partial<FilterState>) => void;
  className?: string;
  copyTarget: "male" | "female";
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}) => {
  const genderColors = {
    male: {
      bg: "bg-blue-50/50",
      border: "border-blue-200",
      text: "text-blue-800",
      icon: <User className="w-4 h-4 text-blue-600" />,
      title: "סינון מועמדים",
    },
    female: {
      bg: "bg-purple-50/50",
      border: "border-purple-200",
      text: "text-purple-800",
      icon: <User className="w-4 h-4 text-purple-600" />,
      title: "סינון מועמדות",
    },
  };

  const colorConfig = genderColors[gender];

  return (
    <div className={`${className} mb-4 border rounded-lg overflow-hidden`}>
      {/* כותרת עם צבע תואם מגדר */}
      <div
        className={`flex justify-between items-center px-4 py-2 ${colorConfig.bg} ${colorConfig.border} border-b`}
      >
        <div className="flex items-center gap-2">
          {colorConfig.icon}
          <h3 className={`text-sm font-medium ${colorConfig.text}`}>
            {colorConfig.title}
          </h3>
        </div>
        {onCopyFilters && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onCopyFilters(gender, copyTarget)}
            className="text-xs h-7 py-0 px-2 flex items-center gap-1"
            title={`העתק הגדרות ל${
              copyTarget === "male" ? "מועמדים" : "מועמדות"
            }`}
          >
            <Copy className="w-3 h-3" />
            <span>העתק ל{copyTarget === "male" ? "מועמדים" : "מועמדות"}</span>
          </Button>
        )}
      </div>

      {/* תוכן הפאנל */}
      <div className="p-3 space-y-4">
        {/* סינון גיל - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">גיל</Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.min || AGE_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= AGE_RANGE.min &&
                      newMin <= AGE_RANGE.max
                    ) {
                      const currentMax =
                        filters?.ageRange?.max || AGE_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.max || AGE_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= AGE_RANGE.min &&
                      newMax <= AGE_RANGE.max
                    ) {
                      const currentMin =
                        filters?.ageRange?.min || AGE_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                value={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                min={AGE_RANGE.min}
                max={AGE_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    ageRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{AGE_RANGE.min}</span>
              <span className="text-xs text-gray-400">{AGE_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* סינון גובה - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">
            גובה (סמ)
          </Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.min || HEIGHT_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= HEIGHT_RANGE.min &&
                      newMin <= HEIGHT_RANGE.max
                    ) {
                      const currentMax =
                        filters?.heightRange?.max || HEIGHT_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.max || HEIGHT_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= HEIGHT_RANGE.min &&
                      newMax <= HEIGHT_RANGE.max
                    ) {
                      const currentMin =
                        filters?.heightRange?.min || HEIGHT_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                value={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                min={HEIGHT_RANGE.min}
                max={HEIGHT_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    heightRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.min}</span>
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* רמת דתיות */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">רמת דתיות</Label>
          <div className="px-2">
            <Select
              value={filters?.religiousLevel || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  religiousLevel: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר רמת דתיות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {RELIGIOUS_LEVELS.map((level) => (
                  <SelectItem key={level.value} value={level.value}>
                    {level.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* מצב משפחתי */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">מצב משפחתי</Label>
          <div className="px-2">
            <Select
              value={filters?.maritalStatus || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  maritalStatus: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר מצב משפחתי" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {MARITAL_STATUS.map((status) => (
                  <SelectItem key={status.value} value={status.value}>
                    {status.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* ערים */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">ערים מבוקשות</Label>
          <div className="px-2">
            <Select
              value={filters.cities?.[0] || ""}
              onValueChange={(value) => {
                if (value === "all") {
                  onFiltersChange({ cities: [] });
                } else {
                  onFiltersChange({ cities: [value] });
                }
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר עיר" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">כל הערים</SelectItem>
                {POPULAR_CITIES.map((city) => (
                  <SelectItem key={city} value={city}>
                    {city}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* סטטוס אימות ותוספות */}
        <div className="space-y-2 pt-2 border-t border-gray-100">
          <div className="flex items-center justify-between px-2">
            <span className="text-xs font-medium">מאומתים בלבד</span>
            <Switch
              checked={filters?.isVerified || false}
              onCheckedChange={(checked) => {
                onFiltersChange({
                  isVerified: checked || undefined,
                });
              }}
            />
          </div>
        </div>

        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">עם המלצות</span>
          <Switch
            checked={filters?.hasReferences || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                hasReferences: checked || undefined,
              });
            }}
          />
        </div>
        <FilterSection
          title="מקור המועמד"
          icon={<UserPlus className="w-4 h-4" />}
        >
          <div className="pt-2">
            <Select
              value={filters.source || ""}
              onValueChange={(value) =>
                onFiltersChange({
                  ...filters,
                  source: value ? (value as UserSource) : undefined,
                })
              }
            >
              <SelectTrigger className="w-full bg-white">
                <SelectValue placeholder="בחר מקור המועמד" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">הכל</SelectItem>
                <SelectItem value={UserSource.REGISTRATION}>
                  רישום עצמי
                </SelectItem>
                <SelectItem value={UserSource.MANUAL_ENTRY}>
                  הוספה ידנית
                </SelectItem>
              </SelectContent>
            </Select>
          </div>
        </FilterSection>
        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">פרופיל מלא</span>
          <Switch
            checked={filters?.isProfileComplete || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                isProfileComplete: checked || undefined,
              });
            }}
          />
        </div>
      </div>
    </div>
  );
};

const FilterPanel: React.FC<FilterPanelProps> = ({
  filters,
  onFiltersChange,
  onSavePreset,
  onReset,
  onApplySavedFilter,
  savedFilters = [],
  popularFilters = [],
  className,
  compactMode = false,
  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering = false,
  onToggleSeparateFiltering,
  onMaleFiltersChange,
  onFemaleFiltersChange,
  onCopyFilters,
}) => {
  const [showSavePreset, setShowSavePreset] = useState(false);
  const [presetName, setPresetName] = useState("");
  const [activeTab, setActiveTab] = useState<string>("basic");
  const [activeGenderFilter, setActiveGenderFilter] = useState<
    "male" | "female"
  >("male");

  const handleSavePreset = () => {
    if (presetName && onSavePreset) {
      onSavePreset(presetName);
      setPresetName("");
      setShowSavePreset(false);
    }
  };
  const layoutClasses = compactMode
    ? "p-1 space-y-1 text-xs" // הרבה יותר קומפקטי
    : "p-4 space-y-4"; // תצוגה רגילה

  const handleAgeRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      ageRange: { min: value[0], max: value[1] },
    });
  };

  const handleHeightRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      heightRange: { min: value[0], max: value[1] },
    });
  };
  const handleApplyPopularFilter = (filter: Partial<CandidatesFilter>) => {
    onFiltersChange({
      ...filters,
      ...filter,
    });
  };

  const countActiveFilters = (category: string): number => {
    let count = 0;

    switch (category) {
      case "basic":
        // Count basic filters
        if (filters.gender) count++;
        if (
          filters.ageRange &&
          (filters.ageRange.min !== AGE_RANGE.default.min ||
            filters.ageRange.max !== AGE_RANGE.default.max)
        )
          count++;
        if (filters.cities?.length) count++;
        if (filters.religiousLevel) count++;
        break;
      case "advanced":
        // Count advanced filters
        if (
          filters.heightRange &&
          (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
            filters.heightRange.max !== HEIGHT_RANGE.default.max)
        )
          count++;
        if (filters.occupations?.length) count++;
        if (filters.educationLevel) count++;
        if (filters.maritalStatus) count++;
        break;
      case "status":
        // Count status filters
        if (filters.availabilityStatus) count++;
        if (filters.isVerified !== undefined) count++;
        if (filters.hasReferences !== undefined) count++;
        if (filters.lastActiveDays !== undefined) count++;
        if (filters.isProfileComplete !== undefined) count++;
        break;
      case "saved":
        // Count of saved filters is just the length
        return savedFilters.length;
    }

    return count;
  };

  return (
    <Card
      className={`${layoutClasses} border border-slate-200 bg-white/90 shadow-sm ${className}`}
    >
      {/* Header */}
      {!compactMode && (
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <FilterIcon className="w-5 h-5 text-blue-600" />
            <h3 className="font-semibold text-lg">סינון מועמדים</h3>
          </div>
          <div className="flex gap-2">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={onReset}
                    className="h-8 w-8 p-0"
                  >
                    <RefreshCw className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>איפוס כל הפילטרים</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>

            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowSavePreset(!showSavePreset)}
                    className="h-8 w-8 p-0"
                  >
                    <Bookmark className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>שמירת הפילטר הנוכחי</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </div>
      )}

      {/* Popular Filters */}
      {!compactMode && (
        <div className="mb-4">
          <div className="flex flex-wrap gap-2">
            {POPULAR_FILTERS.map((option) => (
              <Button
                key={option.id}
                variant="outline"
                size="sm"
                onClick={() => handleApplyPopularFilter(option.filter)}
                className="bg-white flex items-center gap-1.5 transition-all hover:bg-blue-50 hover:text-blue-700 hover:border-blue-200"
              >
                {option.icon}
                <span>{option.label}</span>
              </Button>
            ))}
          </div>
        </div>
      )}

      {/* Save Preset Form */}
      {showSavePreset && !compactMode && (
        <div className="p-4 border rounded-lg bg-blue-50/50 mb-4">
          <Label>שם לשמירת הפילטר</Label>
          <div className="flex gap-2 mt-2">
            <Input
              value={presetName}
              onChange={(e) => setPresetName(e.target.value)}
              placeholder="פילטר מותאם אישית"
              className="h-9"
            />
            <Button size="sm" onClick={handleSavePreset}>
              <Save className="w-4 h-4 ml-1.5" />
              שמור
            </Button>
          </div>
        </div>
      )}

      {/* Separate Filtering Toggle */}
      <div className="mb-4 border rounded-lg p-4 bg-blue-50/10">
        <div className="flex items-center justify-between">
          <div className="space-y-1">
            <div className="font-medium">סינון וחיפוש נפרד לפי מגדר</div>
            <p className="text-sm text-gray-500">
              סנן מועמדים ומועמדות עם קריטריונים שונים
            </p>
          </div>
          <div className="flex items-center gap-2">
            <Switch
              checked={separateFiltering}
              onCheckedChange={onToggleSeparateFiltering}
            />
            {separateFiltering && (
              <Button
                variant="outline"
                size="sm"
                onClick={onToggleSeparateFiltering}
                className="text-sm"
              >
                <RefreshCw className="w-3.5 h-3.5 mr-1.5" />
                בטל סינון נפרד
              </Button>
            )}
          </div>
        </div>
      </div>

      {/* Separate Filtering UI */}
      {separateFiltering ? (
        <div className="space-y-4">
          {/* Gender Filter Switcher */}
          <div className="flex border rounded-lg overflow-hidden mb-2">
            <Button
              type="button"
              variant={activeGenderFilter === "male" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("male")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "male" ? "bg-blue-600" : ""
              }`}
            >
              סינון מועמדים
              <User className="w-4 h-4 mr-2" />
            </Button>
            <Button
              type="button"
              variant={activeGenderFilter === "female" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("female")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "female" ? "bg-purple-600" : ""
              }`}
            >
              סינון מועמדות
              <User className="w-4 h-4 mr-2" />
            </Button>
          </div>

          {/* Conditionally render based on active gender filter */}
          {activeGenderFilter === "male" ? (
            <GenderFilterPanel
              gender="male"
              filters={filters.maleFilters || {}}
              onFiltersChange={onMaleFiltersChange || (() => {})}
              copyTarget="female"
              onCopyFilters={onCopyFilters}
            />
          ) : (
            <GenderFilterPanel
              gender="female"
              filters={filters.femaleFilters || {}}
              onFiltersChange={onFemaleFiltersChange || (() => {})}
              copyTarget="male"
              onCopyFilters={onCopyFilters}
            />
          )}
        </div>
      ) : (
        // Standard Filtering Tabs
        <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
          <TabsList
            className={`grid grid-cols-4 w-full bg-muted/30 p-1 rounded-xl shadow-sm ${
              compactMode ? "text-xs" : ""
            }`}
          >
            <TabsTrigger
              value="basic"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                בסיסי
                {countActiveFilters("basic") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("basic")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="advanced"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                מתקדם
                {countActiveFilters("advanced") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("advanced")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="status"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                סטטוס
                {countActiveFilters("status") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("status")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="saved"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                שמורים
                {countActiveFilters("saved") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("saved")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
          </TabsList>

          <div className={compactMode ? "mt-2" : "mt-4"}>
            {/* Basic Filters Tab */}
            <TabsContent value="basic" className="space-y-4">
              {/* Gender Filter */}
              <FilterSection
                title="מגדר"
                icon={<User className="w-4 h-4" />}
                defaultOpen={true}
              >
                <div className="grid grid-cols-2 gap-2 pt-2">
                  <Button
                    type="button"
                    variant={filters.gender === "MALE" ? "default" : "outline"}
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "MALE" })
                    }
                    className={
                      filters.gender === "MALE" ? "bg-blue-600" : "bg-white"
                    }
                  >
                    גברים
                  </Button>
                  <Button
                    type="button"
                    variant={
                      filters.gender === "FEMALE" ? "default" : "outline"
                    }
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "FEMALE" })
                    }
                    className={
                      filters.gender === "FEMALE" ? "bg-purple-600" : "bg-white"
                    }
                  >
                    נשים
                  </Button>
                </div>
                {filters.gender && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: undefined })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                )}
              </FilterSection>
                           <FilterSection
                title="סטטוס משתמש"
                icon={<User className="w-4 h-4" />}
                defaultOpen={true}
                badge={filters.userStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  {/* --- START OF FIX --- */}
                  <Select
                    // 1. אם הסטטוס לא מוגדר, הערך של ה-Select יהיה "all"
                    value={filters.userStatus || "all"}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        // 2. אם המשתמש בחר "all", ננקה את הפילטר (undefined). אחרת, נגדיר את הערך שנבחר.
                        userStatus: value === "all" ? undefined : (value as UserStatus),
                      })
                    }
                  >
                  {/* --- END OF FIX --- */}
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="בחר סטטוס משתמש" />
                    </SelectTrigger>
                    <SelectContent>
                      {/* --- START OF FIX --- */}
                      {/* 3. שינוי הערך של "הכל" למחרוזת שאינה ריקה */}
                      <SelectItem value="all">הכל</SelectItem>
                      {/* --- END OF FIX --- */}
                      <SelectItem value={UserStatus.ACTIVE}>פעילים</SelectItem>
                      <SelectItem value={UserStatus.PENDING_PHONE_VERIFICATION}>ממתינים לאימות טלפון</SelectItem>
                      <SelectItem value={UserStatus.PENDING_EMAIL_VERIFICATION}>ממתינים לאימות מייל</SelectItem>
                    </SelectContent>
                  </Select>
                  {filters.userStatus && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          userStatus: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>
              {/* Age Range - משופר ומתוקן */}
              <FilterSection
                title="גיל"
                icon={<Calendar className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  filters.ageRange &&
                  (filters.ageRange.min !== AGE_RANGE.default.min ||
                    filters.ageRange.max !== AGE_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.max || AGE_RANGE.default.max}
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= AGE_RANGE.min &&
                            newMax <= AGE_RANGE.max
                          ) {
                            const currentMin =
                              filters.ageRange?.min || AGE_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.min || AGE_RANGE.default.min}
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= AGE_RANGE.min &&
                            newMin <= AGE_RANGE.max
                          ) {
                            const currentMax =
                              filters.ageRange?.max || AGE_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          AGE_RANGE.default.min,
                          AGE_RANGE.default.max,
                        ]}
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        step={1}
                        value={[
                          filters.ageRange?.min || AGE_RANGE.default.min,
                          filters.ageRange?.max || AGE_RANGE.default.max,
                        ]}
                        onValueChange={handleAgeRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.max}
                      </span>
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.min}
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Cities Filter */}
              <FilterSection
                title="ערים"
                icon={<MapPin className="w-4 h-4" />}
                badge={filters.cities?.length}
              >
                <ScrollArea className="h-48 mt-2 rounded-md border overflow-hidden bg-white pr-4">
                  <div className="p-2">
                    {POPULAR_CITIES.map((city) => (
                      <div
                        key={city}
                        className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                      >
                        <span className="text-sm">{city}</span>
                        <Switch
                          checked={filters.cities?.includes(city) || false}
                          onCheckedChange={(checked) => {
                            const newCities = checked
                              ? [...(filters.cities || []), city]
                              : filters.cities?.filter((c) => c !== city);
                            onFiltersChange({ ...filters, cities: newCities });
                          }}
                        />
                      </div>
                    ))}
                  </div>
                </ScrollArea>
                {filters.cities?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => onFiltersChange({ ...filters, cities: [] })}
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Religious Level */}
              <FilterSection
                title="רמת דתיות"
                icon={<Scroll className="w-4 h-4" />}
                badge={filters.religiousLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.religiousLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        religiousLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="בחר רמת דתיות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {RELIGIOUS_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Advanced Filters Tab */}
            <TabsContent value="advanced" className="space-y-4">
              {/* Height Range - משופר ומתוקן */}
              <FilterSection
                title="גובה (ס״מ)"
                icon={<Ruler className="w-4 h-4" />}
                badge={
                  filters.heightRange &&
                  (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
                    filters.heightRange.max !== HEIGHT_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.max || HEIGHT_RANGE.default.max
                        }
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= HEIGHT_RANGE.min &&
                            newMax <= HEIGHT_RANGE.max
                          ) {
                            const currentMin =
                              filters.heightRange?.min ||
                              HEIGHT_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.min || HEIGHT_RANGE.default.min
                        }
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= HEIGHT_RANGE.min &&
                            newMin <= HEIGHT_RANGE.max
                          ) {
                            const currentMax =
                              filters.heightRange?.max ||
                              HEIGHT_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          HEIGHT_RANGE.default.min,
                          HEIGHT_RANGE.default.max,
                        ]}
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        step={1}
                        value={[
                          filters.heightRange?.min || HEIGHT_RANGE.default.min,
                          filters.heightRange?.max || HEIGHT_RANGE.default.max,
                        ]}
                        onValueChange={handleHeightRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.min} ס״מ
                      </span>
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.max} ס״מ
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Occupation */}
              <FilterSection
                title="תחום עיסוק"
                icon={<Briefcase className="w-4 h-4" />}
                badge={filters.occupations?.length}
              >
                <ScrollArea className="h-48 rounded-md mt-2 border p-2 bg-white pr-4">
                  {OCCUPATION_CATEGORIES.map((occupation) => (
                    <div
                      key={occupation.value}
                      className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                    >
                      <span className="text-sm">{occupation.label}</span>
                      <Switch
                        checked={
                          filters.occupations?.includes(occupation.value) ||
                          false
                        }
                        onCheckedChange={(checked) => {
                          const newOccupations = checked
                            ? [...(filters.occupations || []), occupation.value]
                            : filters.occupations?.filter(
                                (o) => o !== occupation.value
                              );
                          onFiltersChange({
                            ...filters,
                            occupations: newOccupations,
                          });
                        }}
                      />
                    </div>
                  ))}
                </ScrollArea>
                {filters.occupations?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, occupations: [] })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Education Level */}
              <FilterSection
                title="השכלה"
                icon={<GraduationCap className="w-4 h-4" />}
                badge={filters.educationLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.educationLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        educationLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="רמת השכלה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {EDUCATION_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>

              {/* Marital Status */}
              <FilterSection
                title="מצב משפחתי"
                icon={<Heart className="w-4 h-4" />}
                badge={filters.maritalStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.maritalStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        maritalStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="מצב משפחתי" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {MARITAL_STATUS.map((status) => (
                        <SelectItem key={status.value} value={status.value}>
                          {status.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Status & Availability Filters Tab */}
            <TabsContent value="status" className="space-y-4">
              {/* Availability Status */}
              <FilterSection
                title="סטטוס זמינות"
                icon={<Clock className="w-4 h-4" />}
                defaultOpen={true}
                badge={filters.availabilityStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.availabilityStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        availabilityStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="סטטוס זמינות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {AVAILABILITY_STATUS_OPTIONS.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          <div className="flex items-center gap-2">
                            <div
                              className={`w-2 h-2 rounded-full ${
                                option.value === "AVAILABLE"
                                  ? "bg-emerald-500"
                                  : option.value === "DATING"
                                  ? "bg-amber-500"
                                  : "bg-red-500"
                              }`}
                            />
                            {option.label}
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {filters.availabilityStatus && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          availabilityStatus: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>

              {/* Verification Switches */}
              <FilterSection
                title="אימות ואיכות פרופיל"
                icon={<Check className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  (filters.isVerified !== undefined ? 1 : 0) +
                  (filters.hasReferences !== undefined ? 1 : 0) +
                  (filters.isProfileComplete !== undefined ? 1 : 0)
                }
              >
                <div className="space-y-3 pt-2">
                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">מועמדים מאומתים בלבד</span>
                    <Switch
                      checked={filters.isVerified || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isVerified: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">עם המלצות בלבד</span>
                    <Switch
                      checked={filters.hasReferences || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          hasReferences: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">פרופילים מלאים בלבד</span>
                    <Switch
                      checked={filters.isProfileComplete || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isProfileComplete: checked || undefined,
                        })
                      }
                    />
                  </div>
                </div>
              </FilterSection>

              {/* Activity Filter */}
              <FilterSection
                title="פעילות אחרונה"
                icon={<Clock className="w-4 h-4" />}
                badge={filters.lastActiveDays ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.lastActiveDays?.toString() || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        lastActiveDays: value ? parseInt(value) : undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="פעילות אחרונה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="1">היום</SelectItem>
                      <SelectItem value="3">3 ימים אחרונים</SelectItem>
                      <SelectItem value="7">שבוע אחרון</SelectItem>
                      <SelectItem value="30">חודש אחרון</SelectItem>
                    </SelectContent>
                  </Select>
                  {filters.lastActiveDays && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          lastActiveDays: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>
            </TabsContent>

            {/* Saved Filters Tab */}
            <TabsContent value="saved" className="space-y-4">
              {savedFilters.length === 0 ? (
                <div className="text-center py-8 text-gray-500 bg-white rounded-lg border p-4">
                  <Bookmark className="w-8 h-8 mx-auto mb-2 text-gray-400" />
                  <h3 className="mb-1 font-medium">אין פילטרים שמורים</h3>
                  <p className="text-sm">
                    שמור את הפילטר הנוכחי ע״י לחיצה על כפתור השמירה
                  </p>
                </div>
              ) : (
                <SavedFilters
                  filters={savedFilters.map((filter) => ({
                    id: filter.id,
                    name: filter.name,
                    filter: {},
                    isDefault: filter.isDefault,
                    createdAt: new Date(),
                  }))}
                  activeFilterId={filters.savedFilterId}
                  onSelect={(filter) => onApplySavedFilter?.(filter.id)}
                  onDelete={() => {}}
                  onEdit={() => {}}
                  onSetDefault={() => {}}
                />
              )}

              {popularFilters.length > 0 && (
                <div className="mt-4">
                  <h4 className="font-medium text-sm mb-2">
                    חיפושים פופולריים
                  </h4>
                  <div className="flex flex-wrap gap-2">
                    {popularFilters.map((term, index) => (
                      <Badge
                        key={index}
                        variant="outline"
                        className="cursor-pointer bg-blue-50 border-blue-200 hover:bg-blue-100 transition-colors"
                        onClick={() =>
                          onFiltersChange({
                            ...filters,
                            searchQuery: term,
                          })
                        }
                      >
                        {term}
                      </Badge>
                    ))}
                  </div>
                </div>
              )}
            </TabsContent>
          </div>
        </Tabs>
      )}

      {/* Action buttons */}
      <div
        className={`${
          compactMode ? "pt-2 mt-2" : "pt-4 mt-4"
        } border-t flex justify-end gap-2`}
      >
        <Button
          variant="outline"
          size={compactMode ? "sm" : "default"}
          onClick={onReset}
          className="bg-white"
        >
          איפוס
        </Button>
        {!compactMode && (
          <Button onClick={() => setShowSavePreset(true)} size="sm">
            <Save className="w-4 h-4 ml-1.5" />
            שמירת פילטר
          </Button>
        )}
      </div>
    </Card>
  );
};

export default FilterPanel;
--- End of Content for FilterPanel.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\SavedFilters.tsx
--------------------------------------------------------------------------------
Content:
// /components/matchmaker/Filters/SavedFilters.tsx
"use client";
import React from "react";
import { Star, MoreVertical, Edit, Trash } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import type { CandidatesFilter } from "../types/candidates";

interface SavedFilter {
  id: string;
  name: string;
  filter: CandidatesFilter;
  isDefault?: boolean;
  createdAt: Date;
}

interface SavedFiltersProps {
  filters: SavedFilter[];
  activeFilterId?: string;
  onSelect: (filter: SavedFilter) => void;
  onDelete: (filterId: string) => void;
  onEdit: (filter: SavedFilter) => void;
  onSetDefault: (filterId: string) => void;
  className?: string;
}

const SavedFilters: React.FC<SavedFiltersProps> = ({
  filters,
  activeFilterId,
  onSelect,
  onDelete,
  onEdit,
  onSetDefault,
  className,
}) => {
  return (
    <div className={`space-y-2 ${className}`}>
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-gray-700">פילטרים שמורים</h3>
        <Badge variant="secondary" className="text-xs">
          {filters.length}
        </Badge>
      </div>

      <ScrollArea className="h-[300px]">
        <div className="space-y-2">
          {filters.map((filter) => (
            <div
              key={filter.id}
              className={`
                flex items-center justify-between p-2 rounded-lg
                ${
                  activeFilterId === filter.id
                    ? "bg-blue-50 border border-blue-200"
                    : "bg-white hover:bg-gray-50"
                }
                transition-colors cursor-pointer
              `}
              onClick={() => onSelect(filter)}
            >
              <div className="flex items-center gap-2">
                {filter.isDefault && (
                  <Star className="w-4 h-4 text-yellow-400" />
                )}
                <div>
                  <p className="font-medium text-sm">{filter.name}</p>
                  <p className="text-xs text-gray-500">
                    {formatFilterSummary(filter.filter)}
                  </p>
                </div>
              </div>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8 w-8 p-0"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <MoreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onEdit(filter)}>
                    <Edit className="ml-2 h-4 w-4" />
                    עריכה
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => onSetDefault(filter.id)}
                    disabled={filter.isDefault}
                  >
                    <Star className="ml-2 h-4 w-4" />
                    הגדר כברירת מחדל
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onDelete(filter.id)}>
                    <Trash className="ml-2 h-4 w-4" />
                    מחיקה
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
};

// פונקציית עזר להצגת סיכום הפילטר
const formatFilterSummary = (filter: CandidatesFilter): string => {
  const parts: string[] = [];

  if (filter.ageRange) {
    parts.push(`גיל: ${filter.ageRange.min}-${filter.ageRange.max}`);
  }

  if (filter.cities?.length) {
    parts.push(`ערים: ${filter.cities.length}`);
  }

  if (filter.religiousLevel) {
    parts.push(`רמה דתית: ${filter.religiousLevel}`);
  }

  if (filter.occupations?.length) {
    parts.push(`תחומי עיסוק: ${filter.occupations.length}`);
  }

  return parts.join(" | ") || "פילטר ריק";
};

export default SavedFilters;
--- End of Content for SavedFilters.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\SearchBar.tsx
--------------------------------------------------------------------------------
Content:
// /Filters/SearchBar.tsx - גרסה עם לוגים לדיבאג
"use client";

import React, { useState, useEffect, useRef } from "react";
import { Search, X, History } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSelect?: (candidate: Candidate) => void;
  recentSearches?: string[];
  onSaveSearch?: (value: string) => void;
  onClearRecentSearches?: () => void;
  suggestions?: Candidate[];
  loading?: boolean;
  className?: string;
  placeholder?: string;
  autoFocus?: boolean;
  // הוספת שדה לציון לאיזה מגדר החיפוש מכוון
  genderTarget?: "male" | "female" | "all";
  // הוספת שדה לציון האם החיפוש מופעל במצב נפרד
  separateMode?: boolean;
}

const SEARCH_CATEGORIES = [
  { id: "name", label: "שם", placeholder: "חיפוש לפי שם..." },
  { id: "city", label: "עיר", placeholder: "חיפוש לפי עיר..." },
  {
    id: "occupation",
    label: "תחום עיסוק",
    placeholder: "חיפוש לפי תחום עיסוק...",
  },
  { id: "all", label: "הכל", placeholder: "חיפוש בכל השדות..." },
];

const SearchBar: React.FC<SearchBarProps> = ({
  value,
  onChange,
  onSelect,
  recentSearches = [],
  onSaveSearch,
  onClearRecentSearches,
  suggestions = [],
  loading = false,
  className = "",
  placeholder = "חיפוש מועמדים...",
  autoFocus = false,
  genderTarget = "all",
  separateMode = false,
}) => {
  const [open, setOpen] = useState(false);
  const [searchCategory, setSearchCategory] = useState<string>("all");
  const [inputValue, setInputValue] = useState(value);
  const [showClearButton, setShowClearButton] = useState(Boolean(value));
  const inputRef = useRef<HTMLInputElement>(null);
  const searchContainerRef = useRef<HTMLDivElement>(null);

  // לוג מצב התחלתי
  console.log("SearchBar mounted/updated. Props:", {
    initialValue: value,
    suggestionsCount: suggestions.length,
    recentSearchesCount: recentSearches.length,
  });

  // Sync input value with prop value
  useEffect(() => {
    console.log("Value prop changed:", value);
    setInputValue(value);
    setShowClearButton(Boolean(value));
  }, [value]);

  // Handle search when user presses Enter or selects a suggestion
  const handleSearch = (searchValue: string) => {
    console.log(
      `handleSearch called with: ${searchValue}, gender: ${genderTarget}, separate: ${separateMode}`
    );

    if (searchValue.trim()) {
      onChange(searchValue.trim());

      if (onSaveSearch) {
        // שמירת החיפוש בהיסטוריה
        // אפשר גם לשמור את המגדר אם יש צורך
        onSaveSearch(searchValue.trim());
      }
    }
  };
  // כשמשתמשים בחיפוש נפרד, נעדכן את הפלייסהולדר בהתאם
  const getSearchPlaceholder = () => {
    if (separateMode) {
      // מצא את ה-placeholder של הקטגוריה "all" או השתמש בברירת מחדל
      const allCategoryPlaceholder =
        SEARCH_CATEGORIES.find((cat) => cat.id === "all")?.placeholder ||
        "חיפוש בכל השדות...";

      if (genderTarget === "male") {
        return `חיפוש מועמדים - ${allCategoryPlaceholder}`;
      }
      if (genderTarget === "female") {
        return `חיפוש מועמדות - ${allCategoryPlaceholder}`;
      }
    }

    // אם לא במצב סינון נפרד, השתמש בקטגוריה הנוכחית שנבחרה
    const category = SEARCH_CATEGORIES.find((cat) => cat.id === searchCategory);
    return category?.placeholder || placeholder;
  };
  // Handle input change
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    console.log("handleInputChange:", { oldValue: inputValue, newValue });

    setInputValue(newValue);
    setShowClearButton(Boolean(newValue));

    // CRITICAL: הפעלת onChange בכל הקלדה כדי שהחיפוש יקרה בזמן אמת
    console.log(
      "Calling onChange directly from handleInputChange with:",
      newValue
    );
    onChange(newValue);
  };

  // Handle keyboard events
  const handleKeyDown = (e: React.KeyboardEvent) => {
    console.log("handleKeyDown:", e.key);

    if (e.key === "Enter" && inputValue.trim()) {
      console.log("Enter pressed with value:", inputValue);
      handleSearch(inputValue);
      setOpen(false);
    } else if (e.key === "Escape") {
      console.log("Escape pressed, closing dropdown");
      setOpen(false);
    }
  };

  // Clear search input
  const handleClear = () => {
    console.log("handleClear called");
    setInputValue("");
    console.log("Calling onChange with empty string from handleClear");
    onChange("");
    setShowClearButton(false);
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        searchContainerRef.current &&
        !searchContainerRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  // Handle suggestion selection
  const handleSuggestionSelect = (candidate: Candidate) => {
    console.log(
      "handleSuggestionSelect called with candidate:",
      `${candidate.firstName} ${candidate.lastName}`
    );

    if (onSelect) {
      console.log("Calling onSelect for the candidate");
      onSelect(candidate);
    } else {
      // אם אין פונקציית בחירה, התייחס לכך כחיפוש טקסט
      const searchText = `${candidate.firstName} ${candidate.lastName}`;
      console.log("No onSelect provided, using as text search:", searchText);
      setInputValue(searchText);
      console.log("Calling onChange with:", searchText);
      onChange(searchText);
    }
    setOpen(false);
  };

   return (
    <div className={`relative ${className}`} ref={searchContainerRef}>
      {/* Search Input Field */}
      <div className="relative flex items-center rounded-lg border border-input bg-background shadow-sm transition-colors focus-within:ring-1 focus-within:ring-blue-200">
        <Search className="absolute right-3 h-4 w-4 text-muted-foreground" />

        {/* הכנסת שדה הקלט */}
        <Input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onClick={() => {
            console.log("Search input clicked, opening dropdown");
            setOpen(true);
          }}
          placeholder={getSearchPlaceholder()}
          className={`border-0 pr-10 focus-visible:ring-0 focus-visible:ring-offset-0 ${
            separateMode ? "pl-16" : ""
          }`}
          autoFocus={autoFocus}
        />

        {/* תווית המגדר כתווית קבועה שלא חופפת את יתר האלמנטים */}
        {separateMode && (
          <div className="absolute left-4 top-1/2 -translate-y-1/2 z-10">
            <Badge
              variant="outline"
              className={
                genderTarget === "male"
                  ? "bg-blue-100 text-blue-800 border-blue-200"
                  : genderTarget === "female"
                  ? "bg-purple-100 text-purple-800 border-purple-200"
                  : ""
              }
            >
              {genderTarget === "male"
                ? "מועמדים"
                : genderTarget === "female"
                ? "מועמדות"
                : "הכל"}
            </Badge>
          </div>
        )}

        {/* כפתור ניקוי עם מיקום משופר */}
        {showClearButton && (
          <Button
            type="button"
            variant="ghost"
            size="icon"
            onClick={handleClear}
            className={`absolute ${
              separateMode ? "left-16" : "left-3 md:left-40"
            } top-1/2 -translate-y-1/2 h-7 w-7 z-10`}
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>

      {/* Suggestions Dropdown - Custom Styled */}
      {open && (
        <div
          className="absolute z-50 mt-1 w-full rounded-md border bg-white shadow-lg"
          style={{ maxHeight: "400px", overflowY: "auto" }}
        >
          {/* Search Input for Filtering */}
          <div className="p-2 border-b">
            <div className="relative">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-muted-foreground opacity-70" />
              <input
                type="text"
                value={inputValue}
                onChange={(e) => {
                  const newValue = e.target.value;
                  console.log("Dropdown filter input changed:", {
                    oldValue: inputValue,
                    newValue,
                  });
                  setInputValue(newValue);

                  // CRITICAL: וודא שהערך מועבר להורה בזמן הקלדה
                  console.log(
                    "Calling onChange from dropdown filter with:",
                    newValue
                  );
                  onChange(newValue);
                }}
                className="w-full border rounded-md px-3 pr-9 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-blue-300"
                placeholder="סנן תוצאות..."
                autoFocus
              />
            </div>
          </div>

          {/* No Results */}
          {suggestions.length === 0 && recentSearches.length === 0 && (
            <div className="p-4 text-center text-sm text-gray-500">
              {loading ? "טוען..." : "לא נמצאו תוצאות"}
            </div>
          )}

          {/* Recent Searches Section */}
          {recentSearches.length > 0 && (
            <div className="border-b">
              <div className="px-2 py-1.5 text-xs text-gray-500 flex justify-between">
                <span className="font-medium">חיפושים אחרונים</span>
                {onClearRecentSearches && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-5 text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      console.log("Clear recent searches clicked");
                      onClearRecentSearches();
                    }}
                  >
                    נקה היסטוריה
                  </Button>
                )}
              </div>
              <div className="p-1">
                {recentSearches.slice(0, 5).map((search, index) => (
                  <div
                    key={`recent-${index}`}
                    className="flex items-center gap-2 text-right px-3 py-1.5 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log("Recent search clicked:", search);
                      handleSearch(search);
                      setOpen(false);
                    }}
                  >
                    <History className="h-4 w-4 text-blue-400" />
                    <span className="text-sm">{search}</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Suggestions Section */}
          {suggestions.length > 0 && (
            <div>
              <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
                תוצאות
              </div>
              <div className="p-1">
                {suggestions.map((candidate) => (
                  <div
                    key={candidate.id}
                    className="flex items-center gap-2 text-right px-3 py-2 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log(
                        "Suggestion clicked:",
                        `${candidate.firstName} ${candidate.lastName}`
                      );
                      handleSuggestionSelect(candidate);
                    }}
                  >
                    <div className="flex-1">
                      <div className="font-medium text-sm">
                        {`${candidate.firstName} ${candidate.lastName}`}
                      </div>
                      <div className="text-xs text-gray-500 truncate">
                        {[
                          candidate.profile.city,
                          candidate.profile.occupation,
                          candidate.profile.religiousLevel,
                        ]
                          .filter(Boolean)
                          .join(" | ")}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}



          {/* Search Categories on Mobile */}
          <div className="md:hidden border-t">
            <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
              חפש לפי
            </div>
            <div className="flex flex-wrap gap-1 p-2">
              {SEARCH_CATEGORIES.map((category) => (
                <Badge
                  key={category.id}
                  variant={
                    searchCategory === category.id ? "default" : "outline"
                  }
                  className={`cursor-pointer ${
                    searchCategory === category.id
                      ? "bg-blue-500 text-white"
                      : "bg-transparent hover:bg-blue-50"
                  }`}
                  onClick={() => {
                    console.log("Mobile category changed to:", category.id);
                    setSearchCategory(category.id);
                  }}
                >
                  {category.label}
                </Badge>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SearchBar;
--- End of Content for SearchBar.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants\filterOptions.ts
--------------------------------------------------------------------------------
Content:
// /constants/filterOptions.ts
import { AvailabilityStatus } from '@prisma/client';

export const AGE_RANGE = {
  min: 18,
  max: 99,
  default: {
    min: 20,
    max: 35
  }
};

export const HEIGHT_RANGE = {
  min: 140,
  max: 210,
  default: {
    min: 150,
    max: 190
  }
};

export const RELIGIOUS_LEVELS = [
  { value: 'חרדי', label: 'חרדי' },
  { value: 'דתי לאומי', label: 'דתי לאומי' },
  { value: 'דתי', label: 'דתי' },
  { value: 'מסורתי', label: 'מסורתי' }
];

export const EDUCATION_LEVELS = [
  { value: 'תיכונית', label: 'השכלה תיכונית' },
  { value: 'ישיבה', label: 'ישיבה' },
  { value: 'סמינר', label: 'סמינר' },
  { value: 'תואר ראשון', label: 'תואר ראשון' },
  { value: 'תואר שני', label: 'תואר שני' },
  { value: 'דוקטורט', label: 'דוקטורט' }
];

export const MARITAL_STATUS = [
  { value: 'רווק/ה', label: 'רווק/ה' },
  { value: 'גרוש/ה', label: 'גרוש/ה' },
  { value: 'אלמן/ה', label: 'אלמן/ה' }
];

export const OCCUPATION_CATEGORIES = [
  { value: 'חינוך', label: 'חינוך והוראה' },
  { value: 'הייטק', label: 'הייטק ותוכנה' },
  { value: 'רפואה', label: 'רפואה ובריאות' },
  { value: 'משפטים', label: 'משפטים' },
  { value: 'עסקים', label: 'עסקים וכלכלה' },
  { value: 'שירותים', label: 'שירותים' },
  { value: 'אחר', label: 'אחר' }
];

export const REGIONS = [
  { value: 'ירושלים', label: 'ירושלים והסביבה' },
  { value: 'תל אביב', label: 'תל אביב והמרכז' },
  { value: 'חיפה', label: 'חיפה והצפון' },
  { value: 'באר שבע', label: 'באר שבע והדרום' },
  { value: 'יהודה ושומרון', label: 'יהודה ושומרון' }
];

export const POPULAR_CITIES = [
  'ירושלים',
  'תל אביב',
  'חיפה',
  'בני ברק',
  'פתח תקווה',
  'אשדוד',
  'נתניה',
  'באר שבע',
  'חולון',
  'רמת גן',
  'בית שמש',
  'מודיעין עילית',
  'אלעד',
  'ביתר עילית'
];

export const AVAILABILITY_STATUS_OPTIONS = [
  { 
    value: AvailabilityStatus.AVAILABLE, 
    label: 'פנוי/ה',
    description: 'מועמד/ת פנוי/ה להצעות'
  },
  { 
    value: AvailabilityStatus.DATING, 
    label: 'בתהליך הכרות',
    description: 'נמצא/ת בתהליך הכרות'
  },
  { 
    value: AvailabilityStatus.UNAVAILABLE, 
    label: 'לא פנוי/ה',
    description: 'לא פנוי/ה להצעות כרגע'
  }
];

export const SORT_OPTIONS = [
  { 
    value: 'lastActive',
    label: 'פעילות אחרונה',
    defaultOrder: 'desc'
  },
  { 
    value: 'age',
    label: 'גיל',
    defaultOrder: 'asc'
  },
  { 
    value: 'name',
    label: 'שם',
    defaultOrder: 'asc'
  },
  { 
    value: 'city',
    label: 'עיר',
    defaultOrder: 'asc'
  },
  { 
    value: 'religiousLevel',
    label: 'רמת דתיות',
    defaultOrder: 'asc'
  },
  { 
    value: 'height',
    label: 'גובה',
    defaultOrder: 'desc'
  },
  { 
    value: 'registrationDate',
    label: 'תאריך הרשמה',
    defaultOrder: 'desc'
  }
];

export const VIEW_OPTIONS = [
  {
    value: 'grid',
    label: 'תצוגת גריד',
    icon: 'LayoutGrid'
  },
  {
    value: 'list',
    label: 'תצוגת רשימה',
    icon: 'List'
  }
];

export const CARD_SIZES = [
  {
    value: 'sm',
    label: 'קטן',
    dimensions: {
      grid: 'h-64',
      list: 'h-24'
    }
  },
  {
    value: 'md',
    label: 'בינוני',
    dimensions: {
      grid: 'h-80',
      list: 'h-32'
    }
  },
  {
    value: 'lg',
    label: 'גדול',
    dimensions: {
      grid: 'h-96',
      list: 'h-40'
    }
  }
];

export const GROUP_BY_OPTIONS = [
  {
    value: 'none',
    label: 'ללא קיבוץ'
  },
  {
    value: 'city',
    label: 'עיר'
  },
  {
    value: 'religiousLevel',
    label: 'רמת דתיות'
  },
  {
    value: 'ageGroup',
    label: 'קבוצת גיל'
  },
  {
    value: 'availability',
    label: 'סטטוס זמינות'
  }
];

export const DEFAULT_FILTERS = {
  gender: undefined,
  ageRange: AGE_RANGE.default,
  heightRange: HEIGHT_RANGE.default,
  cities: [],
  religiousLevel: undefined,
  occupations: [],
  availability: undefined,
  searchQuery: '',
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined
};

export const FILTER_CATEGORIES = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'education', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availability', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];
--- End of Content for filterOptions.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants\matchingCriteria.ts
--------------------------------------------------------------------------------
Content:
// /constants/matchingCriteria.ts

export const CRITERIA_WEIGHTS = {
    // קריטריונים בסיסיים
    age: {
      weight: 15,
      description: 'התאמת גיל',
      thresholds: {
        perfect: 2,  // הפרש של עד שנתיים
        good: 5,     // הפרש של עד 5 שנים
        fair: 8      // הפרש של עד 8 שנים
      }
    },
    
    religiousLevel: {
      weight: 20,
      description: 'התאמה דתית',
      bonusPoints: {
        exactMatch: 1.0,        // התאמה מדויקת
        adjacentLevel: 0.8,     // רמה דתית סמוכה
        twoLevelsApart: 0.4     // הפרש של שתי רמות
      }
    },
  
    location: {
      weight: 10,
      description: 'מיקום גיאוגרפי',
      bonusPoints: {
        sameCity: 1.0,          // אותה עיר
        sameRegion: 0.8,        // אותו אזור
        preferredCity: 0.7,     // עיר מועדפת
        differentRegion: 0.4    // אזור אחר
      }
    },
  
    // קריטריונים מקצועיים והשכלתיים
    education: {
      weight: 8,
      description: 'רמת השכלה',
      bonusPoints: {
        sameLevel: 1.0,         // רמת השכלה זהה
        adjacentLevel: 0.8,     // רמת השכלה סמוכה
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    occupation: {
      weight: 7,
      description: 'תחום עיסוק',
      bonusPoints: {
        sameField: 1.0,         // אותו תחום
        relatedField: 0.8,      // תחום קרוב
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    // קריטריונים אישיים
    familyBackground: {
      weight: 12,
      description: 'רקע משפחתי',
      factors: {
        origin: 0.4,            // מוצא
        parentStatus: 0.3,      // מצב הורים
        familyType: 0.3         // סוג משפחה
      }
    },
  
    personalityMatch: {
      weight: 15,
      description: 'התאמה אישיותית',
      factors: {
        hobbies: 0.3,           // תחביבים משותפים
        lifestyle: 0.4,         // סגנון חיים
        values: 0.3             // ערכים משותפים
      }
    },
  
    // גורמים נוספים
    preferences: {
      weight: 8,
      description: 'העדפות אישיות',
      factors: {
        agePreference: 0.3,     // העדפות גיל
        locationPreference: 0.3, // העדפות מיקום
        otherPreferences: 0.4   // העדפות נוספות
      }
    },
  
    compatibility: {
      weight: 5,
      description: 'תאימות כללית',
      factors: {
        language: 0.3,          // שפה משותפת
        culture: 0.4,           // תרבות
        lifestyle: 0.3          // סגנון חיים
      }
    }
  };
  
  // סף ציון להתאמה טובה
  export const MATCH_THRESHOLDS = {
    EXCELLENT: 85,  // התאמה מצוינת
    GOOD: 75,       // התאמה טובה
    FAIR: 65,       // התאמה סבירה
    POOR: 50        // התאמה חלשה
  };
  
  // משקלים יחסיים לפי סוג התאמה
  export const MATCH_TYPE_WEIGHTS = {
    PRECISE: {     // התאמה מדויקת
      exact: 1.0,
      similar: 0.8,
      partial: 0.5
    },
    FLEXIBLE: {    // התאמה גמישה
      exact: 0.8,
      similar: 1.0,
      partial: 0.7
    },
    OPEN: {        // התאמה פתוחה
      exact: 0.7,
      similar: 0.9,
      partial: 1.0
    }
  };
  
  // הגדרת קטגוריות להתאמה
  export const MATCH_CATEGORIES = {
    IMMEDIATE: {
      minScore: 90,
      label: 'התאמה מיידית',
      description: 'התאמה גבוהה מאוד, מומלץ ליצור קשר בהקדם'
    },
    HIGH: {
      minScore: 80,
      label: 'התאמה גבוהה',
      description: 'התאמה טובה מאוד, שווה לבדוק'
    },
    GOOD: {
      minScore: 70,
      label: 'התאמה טובה',
      description: 'יש פוטנציאל טוב להתאמה'
    },
    MODERATE: {
      minScore: 60,
      label: 'התאמה בינונית',
      description: 'יש נקודות משותפות, אבל גם הבדלים'
    },
    LOW: {
      minScore: 50,
      label: 'התאמה נמוכה',
      description: 'יש פערים משמעותיים בין המועמדים'
    }
  };
--- End of Content for matchingCriteria.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\ActionDialogs.tsx
--------------------------------------------------------------------------------
Content:
"use client";

// --- שינוי: הוספת useEffect ליבוא ---
import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Clock, Mail, Loader2 } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface NewSuggestionFormData {
  firstPartyId: string;
  secondPartyId: string;
  priority: Priority;
  status: MatchSuggestionStatus;
}
interface ActionDialogsProps {
  suggestDialog: {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: NewSuggestionFormData) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  availabilityDialog: {
    isOpen: boolean;
    onClose: () => void;
    onCheck: (candidate: Candidate) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  inviteDialog: {
    isOpen: boolean;
    onClose: () => void;
    onInvite: (candidate: Candidate, email: string) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
}

export const ActionDialogs: React.FC<ActionDialogsProps> = ({
  suggestDialog,
  availabilityDialog,
  inviteDialog,
}) => {
  // State for invite dialog
  const [inviteEmail, setInviteEmail] = useState("");
  const [isInviting, setIsInviting] = useState(false);
  const [inviteError, setInviteError] = useState<string | null>(null);

  // State for availability dialog
  const [isChecking, setIsChecking] = useState(false);
  const [availabilityError, setAvailabilityError] = useState<string | null>(
    null
  );

  // --- הוספה: useEffect למילוי אוטומטי של האימייל ---
  useEffect(() => {
    // בודקים אם דיאלוג ההזמנה פתוח ויש מועמד שנבחר
    if (inviteDialog.isOpen && inviteDialog.selectedCandidate) {
      // מעדכנים את שדה האימייל עם האימייל של המועמד מהדאטהבייס.
      // אם אין לו אימייל, השדה יישאר ריק.
      setInviteEmail(inviteDialog.selectedCandidate.email || "");
    } else {
      // כאשר הדיאלוג נסגר, מנקים את שדה האימייל
      setInviteEmail("");
    }
  }, [inviteDialog.isOpen, inviteDialog.selectedCandidate]); // ה-hook יופעל בכל פעם שהדיאלוג נפתח/נסגר או שהמועמד משתנה

  // Handler for invite submission
  const handleInviteSubmit = async () => {
    if (!inviteDialog.selectedCandidate || !inviteEmail) return;

    try {
      setIsInviting(true);
      setInviteError(null);
      await inviteDialog.onInvite(inviteDialog.selectedCandidate, inviteEmail);
      // setInviteEmail(""); // השורה הזו כבר לא הכרחית כי ה-useEffect ינקה את השדה בסגירה
      inviteDialog.onClose();
    } catch (error) {
      setInviteError(
        error instanceof Error ? error.message : "Failed to send invitation"
      );
    } finally {
      setIsInviting(false);
    }
  };

  // Handler for availability check
  const handleAvailabilityCheck = async () => {
    if (!availabilityDialog.selectedCandidate) return;

    try {
      setIsChecking(true);
      setAvailabilityError(null);
      await availabilityDialog.onCheck(availabilityDialog.selectedCandidate);
      availabilityDialog.onClose();
    } catch (error) {
      setAvailabilityError(
        error instanceof Error ? error.message : "Failed to check availability"
      );
    } finally {
      setIsChecking(false);
    }
  };

  return (
    <>
      {/* Invite Dialog */}
      <Dialog open={inviteDialog.isOpen} onOpenChange={inviteDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>שליחת הזמנה למועמד</DialogTitle>
            <DialogDescription>
              {inviteDialog.selectedCandidate && (
                <span>
                  שליחת הזמנה ל: {inviteDialog.selectedCandidate.firstName}{" "}
                  {inviteDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            <div>
              <Label>כתובת אימייל</Label>
              <Input
                type="email"
                value={inviteEmail}
                onChange={(e) => setInviteEmail(e.target.value)}
                placeholder="הזן כתובת אימייל"
                className="mt-2"
              />
            </div>

            {inviteError && (
              <Alert variant="destructive">
                <AlertDescription>{inviteError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={inviteDialog.onClose}
              disabled={isInviting}
            >
              ביטול
            </Button>
            <Button
              onClick={handleInviteSubmit}
              disabled={isInviting || !inviteEmail}
            >
              {isInviting ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Mail className="ml-2 h-4 w-4" />
              )}
              {isInviting ? "שולח..." : "שלח הזמנה"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Availability Check Dialog */}
      <Dialog
        open={availabilityDialog.isOpen}
        onOpenChange={availabilityDialog.onClose}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>בדיקת זמינות</DialogTitle>
            <DialogDescription>
              {availabilityDialog.selectedCandidate && (
                <span>
                  בדיקת זמינות עבור:{" "}
                  {availabilityDialog.selectedCandidate.firstName}{" "}
                  {availabilityDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            {availabilityError && (
              <Alert variant="destructive">
                <AlertDescription>{availabilityError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={availabilityDialog.onClose}
              disabled={isChecking}
            >
              ביטול
            </Button>
            <Button onClick={handleAvailabilityCheck} disabled={isChecking}>
              {isChecking ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Clock className="ml-2 h-4 w-4" />
              )}
              {isChecking ? "בודק..." : "בדוק זמינות"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Suggest Match Dialog */}
      <Dialog open={suggestDialog.isOpen} onOpenChange={suggestDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>הצעת שידוך חדשה</DialogTitle>
            <DialogDescription>
              {suggestDialog.selectedCandidate && (
                <span>
                  יצירת הצעת שידוך עבור:{" "}
                  {suggestDialog.selectedCandidate.firstName}{" "}
                  {suggestDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>
          {/* תוכן הדיאלוג יועבר מהקומפוננטה NewSuggestionForm */}
        </DialogContent>
      </Dialog>
    </>
  );
};

export default ActionDialogs;
--- End of Content for ActionDialogs.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\AddManualCandidateDialog.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2, UserPlus, X, UploadCloud, Trash2 } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import Image from "next/image";
import { Gender } from "@prisma/client";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { DatePicker } from "@/components/ui/date-picker";
import {
  RadioGroup,
  RadioGroupItem,
} from "@/components/ui/radio-group";

interface AddManualCandidateDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onCandidateAdded: () => void;
}

const MAX_IMAGES = 5;
const MAX_IMAGE_SIZE_MB = 5;

export const AddManualCandidateDialog: React.FC<
  AddManualCandidateDialogProps
> = ({ isOpen, onClose, onCandidateAdded }) => {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [gender, setGender] = useState<Gender | undefined>(undefined);
  const [birthDate, setBirthDate] = useState<Date | undefined>(undefined);
  const [manualEntryText, setManualEntryText] = useState("");
  const [images, setImages] = useState<File[]>([]);
  const [imagePreviews, setImagePreviews] = useState<string[]>([]);
  const [sendInvite, setSendInvite] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [birthDateInputMode, setBirthDateInputMode] = useState<"date" | "age">(
    "date"
  );
  const [ageInput, setAgeInput] = useState<string>("");

  const resetForm = useCallback(() => {
    setFirstName("");
    setLastName("");
    setEmail("");
    setGender(undefined);
    setBirthDate(undefined);
    setManualEntryText("");
    setImages([]);
    setImagePreviews([]);
    setSendInvite(false);
    setIsSaving(false);
    setBirthDateInputMode("date");
    setAgeInput("");
  }, []);

  const handleClose = () => {
    resetForm();
    onClose();
  };

  const handleImageChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      const newFiles = Array.from(event.target.files);
      const validFiles: File[] = [];
      const validPreviews: string[] = [];

      newFiles.forEach((file) => {
        if (images.length + validFiles.length < MAX_IMAGES) {
          if (file.size <= MAX_IMAGE_SIZE_MB * 1024 * 1024) {
            validFiles.push(file);
            validPreviews.push(URL.createObjectURL(file));
          } else {
            toast.error(
              `הקובץ ${file.name} גדול מדי (מקסימום ${MAX_IMAGE_SIZE_MB}MB).`
            );
          }
        } else {
          toast.warning(`ניתן להעלות עד ${MAX_IMAGES} תמונות.`);
        }
      });

      setImages((prev) => [...prev, ...validFiles]);
      setImagePreviews((prev) => [...prev, ...validPreviews]);
    }
  };

  const removeImage = (index: number) => {
    const newImages = images.filter((_, i) => i !== index);
    const newImagePreviews = imagePreviews.filter((_, i) => i !== index);
    setImages(newImages);
    setImagePreviews(newImagePreviews);
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setIsSaving(true);

    if (!firstName || !lastName || !gender || !manualEntryText) {
      toast.error(
        "נא למלא את כל שדות החובה: שם פרטי, שם משפחה, מין וטקסט חופשי."
      );
      setIsSaving(false);
      return;
    }

    let finalBirthDate: Date | undefined;
    let isBirthDateApproximate: boolean = false;

    if (birthDateInputMode === "date") {
      if (!birthDate) {
        toast.error("נא לבחור תאריך לידה.");
        setIsSaving(false);
        return;
      }
      finalBirthDate = birthDate;
      isBirthDateApproximate = false;
    } else {
      const ageNum = parseInt(ageInput, 10);
      if (isNaN(ageNum) || ageNum <= 0 || ageNum > 120) {
        toast.error("נא להזין גיל תקין (בין 1 ל-120).");
        setIsSaving(false);
        return;
      }
      const currentYear = new Date().getFullYear();
      const birthYear = currentYear - ageNum;
      finalBirthDate = new Date(birthYear, 0, 1);
      isBirthDateApproximate = true;
    }

    if (!finalBirthDate) {
        toast.error("שגיאה בקביעת תאריך לידה. נא לבדוק את הקלט.");
        setIsSaving(false);
        return;
    }

    const formData = new FormData();
    formData.append("firstName", firstName);
    formData.append("lastName", lastName);
    if (email) formData.append("email", email);
    formData.append("gender", gender);
    formData.append("birthDate", finalBirthDate.toISOString());
    formData.append("birthDateIsApproximate", String(isBirthDateApproximate));
    formData.append("manualEntryText", manualEntryText);
    images.forEach((image) => {
      formData.append("images", image);
    });

    try {
      const response = await fetch("/api/matchmaker/candidates/manual", {
        method: "POST",
        body: formData,
      });

      const result = await response.json();

      if (response.ok && result.success) {
        if (sendInvite && email && result.candidate?.id) {
           const promise = fetch(`/api/matchmaker/candidates/${result.candidate.id}/invite-setup`, {
               method: 'POST',
               headers: { 'Content-Type': 'application/json' },
               body: JSON.stringify({ email }),
           }).then(async (inviteResponse) => {
               if (!inviteResponse.ok) {
                   const errorData = await inviteResponse.json().catch(() => ({}));
                   throw new Error(errorData.error || 'שליחת ההזמנה נכשלה.');
               }
               return inviteResponse.json();
           });

           toast.promise(promise, {
               loading: 'מוסיף מועמד ושולח הזמנה...',
               success: 'המועמד נוסף וההזמנה נשלחה בהצלחה!',
               error: (err: Error) => `המועמד נוסף, אך שליחת ההזמנה נכשלה: ${err.message}`,
           });
        } else {
            toast.success("המועמד הידני נוסף בהצלחה!");
        }

        onCandidateAdded();
        handleClose();
      } else {
        throw new Error(result.error || "שגיאה בהוספת המועמד.");
      }
    } catch (error) {
      console.error("Error adding manual candidate:", error);
      toast.error(
        "שגיאה בהוספת המועמד: " +
          (error instanceof Error ? error.message : "שגיאה לא ידועה")
      );
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => { if (!open) handleClose(); }}>
      <DialogContent className="max-w-2xl">
        <DialogClose asChild>
          <button className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground p-1">
            <X className="h-4 w-4" />
            <span className="sr-only">סגור</span>
          </button>
        </DialogClose>

        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-right">
            <UserPlus className="w-6 h-6 text-primary" />
            הוספת מועמד ידנית
          </DialogTitle>
          <DialogDescription className="text-right">
            הזן את פרטי המועמד שברצונך להוסיף למערכת באופן ידני.
          </DialogDescription>
        </DialogHeader>

        <form
          onSubmit={handleSubmit}
          className="space-y-6 py-4 max-h-[70vh] overflow-y-auto pr-2 pl-1"
        >
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="firstName" className="text-right block">
                שם פרטי <span className="text-red-500">*</span>
              </Label>
              <Input
                id="firstName"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                placeholder="לדוגמה: ישראל"
                required
                dir="rtl"
              />
            </div>
            <div>
              <Label htmlFor="lastName" className="text-right block">
                שם משפחה <span className="text-red-500">*</span>
              </Label>
              <Input
                id="lastName"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                placeholder="לדוגמה: ישראלי"
                required
                dir="rtl"
              />
            </div>
          </div>

          <div>
            <Label htmlFor="email" className="text-right block">
              כתובת אימייל (אופציונלי)
            </Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="לדוגמה: user@example.com"
              dir="ltr"
            />
            <p className="text-xs text-gray-500 mt-1 text-right">
              אם לא תסופק כתובת אימייל, תיווצר כתובת פנימית עבור המערכת.
            </p>
          </div>

          <div className="flex items-center space-x-2 rtl:space-x-reverse pt-2">
            <Checkbox
              id="sendInvite"
              checked={sendInvite}
              onCheckedChange={(checked) => setSendInvite(Boolean(checked))}
              disabled={!email || isSaving}
            />
            <Label
              htmlFor="sendInvite"
              className={`cursor-pointer transition-colors ${!email ? 'text-gray-400 cursor-not-allowed' : 'text-gray-700'}`}
            >
              שלח הזמנה למועמד/ת להגדרת חשבון לאחר ההוספה
            </Label>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="gender" className="text-right block">
                מין <span className="text-red-500">*</span>
              </Label>
              <Select
                value={gender}
                onValueChange={(value) => setGender(value as Gender)}
              >
                <SelectTrigger id="gender" dir="rtl">
                  <SelectValue placeholder="בחר/י מין" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Gender.MALE}>זכר</SelectItem>
                  <SelectItem value={Gender.FEMALE}>נקבה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div>
              <div>
                <Label className="text-right block mb-2">
                  אופן הזנת גיל/תאריך לידה <span className="text-red-500">*</span>
                </Label>
                <RadioGroup
                  dir="rtl"
                  value={birthDateInputMode}
                  onValueChange={(value: "date" | "age") => {
                    setBirthDateInputMode(value);
                    if (value === "date") {
                      setAgeInput("");
                    } else {
                      setBirthDate(undefined);
                    }
                  }}
                  className="flex space-x-4 rtl:space-x-reverse mb-3"
                >
                  <div className="flex items-center space-x-2 rtl:space-x-reverse">
                    <RadioGroupItem value="date" id="r-date" />
                    <Label htmlFor="r-date" className="cursor-pointer">לפי תאריך לידה</Label>
                  </div>
                  <div className="flex items-center space-x-2 rtl:space-x-reverse">
                    <RadioGroupItem value="age" id="r-age" />
                    <Label htmlFor="r-age" className="cursor-pointer">לפי גיל</Label>
                  </div>
                </RadioGroup>
              </div>

              {birthDateInputMode === "date" ? (
                <div>
                  <Label htmlFor="birthDate" className="text-right block">
                    תאריך לידה <span className="text-red-500">*</span>
                  </Label>
                  <DatePicker
                    value={
                      birthDate ? { from: birthDate, to: undefined } : undefined
                    }
                    onChange={({ from }) => setBirthDate(from)}
                    isRange={false}
                    placeholder="בחר תאריך לידה"
                    className="w-full"
                  />
                </div>
              ) : (
                <div>
                  <Label htmlFor="ageInput" className="text-right block">
                    גיל (משוער) <span className="text-red-500">*</span>
                  </Label>
                  <Input
                    id="ageInput"
                    type="number"
                    value={ageInput}
                    onChange={(e) => setAgeInput(e.target.value)}
                    placeholder="לדוגמה: 25"
                    required={birthDateInputMode === "age"}
                    dir="rtl"
                    min="1"
                    max="120"
                  />
                   <p className="text-xs text-gray-500 mt-1 text-right">
                    יוזן תאריך לידה משוער (1 בינואר של שנת הלידה) בהתאם לגיל שהוזן.
                  </p>
                </div>
              )}
            </div>
          </div>

          <div>
            <Label htmlFor="manualEntryText" className="text-right block">
              טקסט חופשי על המועמד <span className="text-red-500">*</span>
            </Label>
            <Textarea
              id="manualEntryText"
              value={manualEntryText}
              onChange={(e) => setManualEntryText(e.target.value)}
              placeholder="ספר על המועמד, רקע, תכונות, מה מחפש/ת וכו'..."
              rows={6}
              required
              className="min-h-[100px]"
              dir="rtl"
            />
          </div>

          <div>
            <Label htmlFor="image-upload" className="text-right block">
              תמונות (עד {MAX_IMAGES})
            </Label>
            <div className="mt-2 flex items-center justify-center w-full">
              <label
                htmlFor="image-upload"
                className="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100"
              >
                <div className="flex flex-col items-center justify-center pt-5 pb-6">
                  <UploadCloud className="w-8 h-8 mb-2 text-gray-500" />
                  <p className="mb-2 text-sm text-gray-500 text-center">
                    גרור ושחרר תמונות לכאן, או לחץ לבחירה
                  </p>
                  <p className="text-xs text-gray-500">
                    PNG, JPG, WEBP (עד {MAX_IMAGE_SIZE_MB}MB לתמונה)
                  </p>
                </div>
                <Input
                  id="image-upload"
                  type="file"
                  multiple
                  accept="image/png, image/jpeg, image/webp"
                  className="hidden"
                  onChange={handleImageChange}
                  disabled={images.length >= MAX_IMAGES}
                />
              </label>
            </div>
            {imagePreviews.length > 0 && (
              <div className="mt-4 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                {imagePreviews.map((preview, index) => (
                  <div key={index} className="relative group">
                    <Image
                      src={preview}
                      alt={`תצוגה מקדימה ${index + 1}`}
                      width={100}
                      height={100}
                      className="rounded-md object-cover w-full aspect-square"
                      onLoad={() => URL.revokeObjectURL(preview)} // Clean up object URLs
                    />
                    <Button
                      type="button"
                      variant="destructive"
                      size="icon"
                      className="absolute top-1 right-1 h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity p-0"
                      onClick={() => removeImage(index)}
                    >
                      <Trash2 className="h-3 w-3" />
                      <span className="sr-only">הסר תמונה</span>
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </div>

          <DialogFooter className="pt-4 sm:justify-start">
            <Button type="submit" disabled={isSaving} className="w-full sm:w-auto">
              {isSaving ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <UserPlus className="w-4 h-4 mr-2" />
              )}
              {isSaving ? "שומר..." : "הוסף מועמד"}
            </Button>
            <DialogClose asChild>
              <Button variant="outline" type="button" className="w-full sm:w-auto mt-2 sm:mt-0">
                <X className="w-4 h-4 mr-2" />
                ביטול
              </Button>
            </DialogClose>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};
--- End of Content for AddManualCandidateDialog.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\AiMatchAnalysisDialog.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/dialogs/AiMatchAnalysisDialog.tsx

"use client";

import React, { useState, useEffect, useMemo } from 'react';
import Image from 'next/image';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogClose } from "@/components/ui/dialog";
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Skeleton } from '@/components/ui/skeleton';
import { X, Sparkles, CheckCircle, AlertTriangle, MessageSquare, Info, XCircle, Star, Cake, MapPin, BookMarked, Users, ChevronsUpDown } from 'lucide-react';
import type { Candidate } from '../types/candidates';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from "framer-motion";

// --- Interfaces ---
interface AiAnalysis {
  overallScore: number;
  matchSummary: string;
  compatibilityPoints: { area: string; explanation: string; strength: 'HIGH' | 'MEDIUM' | 'LOW' }[];
  potentialChallenges: { area: string; explanation: string; severity: 'HIGH' | 'MEDIUM' | 'LOW' }[];
  suggestedConversationStarters: string[];
}

interface AiMatchAnalysisDialogProps {
  isOpen: boolean;
  onClose: () => void;
  targetCandidate: Candidate | null;
  comparisonCandidates: Candidate[];
}

// --- Helper Functions ---
const getInitials = (firstName?: string, lastName?: string): string => {
  let initials = "";
  if (firstName && firstName.length > 0) initials += firstName[0];
  if (lastName && lastName.length > 0) initials += lastName[0];
  return initials.toUpperCase() || "?";
};

const calculateAge = (birthDate: Date | string): number => {
    if (!birthDate) return 0;
    const today = new Date();
    const birth = new Date(birthDate);
    if (isNaN(birth.getTime())) return 0;
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
        age--;
    }
    return age > 0 ? age : 0;
};

// --- Sub-components ---

const MiniProfileHeader: React.FC<{ candidate: Candidate; score?: number; isTarget?: boolean }> = ({ candidate, score, isTarget = false }) => {
  const mainImage = candidate.images?.find(img => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);
  const initials = getInitials(candidate.firstName, candidate.lastName);

  return (
    <div className="p-4 rounded-t-lg bg-gradient-to-b from-slate-50 to-slate-100 border-b border-slate-200 text-center relative">
      <div className="relative w-24 h-24 mx-auto rounded-full overflow-hidden border-4 border-white shadow-lg ring-2 ring-offset-2 ring-cyan-400">
        {mainImage?.url ? (
          <Image src={mainImage.url} alt={`תמונת פרופיל של ${candidate.firstName}`} layout="fill" className="object-cover" />
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-slate-200 to-slate-300">
            <span className="text-4xl font-medium text-slate-500">{initials}</span>
          </div>
        )}
      </div>
      
      {!isTarget && typeof score === 'number' && (
        <Badge className="absolute top-4 left-4 bg-gradient-to-r from-teal-400 to-cyan-500 text-white border-0 shadow-lg px-3 py-1.5 text-sm font-bold flex items-center gap-1.5">
          <Sparkles className="w-4 h-4" />
          {score}% התאמה
        </Badge>
      )}

      {isTarget && (
        <Badge className="absolute top-4 right-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white border-0 shadow-lg px-3 py-1.5 text-sm font-bold flex items-center gap-1.5">
          <Star className="w-4 h-4" />
          מועמד מטרה
        </Badge>
      )}

      <h3 className="mt-3 text-lg font-bold text-slate-800">{candidate.firstName} {candidate.lastName}</h3>
      <div className="mt-2 flex justify-center items-center flex-wrap gap-x-3 gap-y-1 text-xs text-slate-600">
        <div className="flex items-center gap-1"><Cake className="w-3.5 h-3.5 text-slate-400"/> {age} שנים</div>
        <div className="flex items-center gap-1"><MapPin className="w-3.5 h-3.5 text-slate-400"/> {candidate.profile.city || 'לא צוין'}</div>
        <div className="flex items-center gap-1"><BookMarked className="w-3.5 h-3.5 text-slate-400"/> {candidate.profile.religiousLevel || 'לא צוין'}</div>
      </div>
    </div>
  );
};

const AnalysisItem: React.FC<{ icon: React.ElementType; iconColor: string; area: string; explanation: string; }> = ({ icon: Icon, iconColor, area, explanation }) => (
    <div className="flex items-start gap-4 p-3 rounded-lg hover:bg-slate-50/70 transition-colors">
        <div className={cn("mt-1 flex-shrink-0 rounded-full p-2 bg-opacity-10", iconColor.replace('text-', 'bg-'))}>
            <Icon className={cn("h-5 w-5", iconColor)} />
        </div>
        <div>
            <h4 className="font-semibold text-gray-800">{area}</h4>
            <p className="text-sm text-gray-600 leading-relaxed">{explanation}</p>
        </div>
    </div>
);

const ComparisonTable: React.FC<{ target: Candidate; comparison: Candidate; }> = ({ target, comparison }) => {
    const fieldsToCompare = [
        { key: 'age', label: 'גיל', formatter: (c: Candidate) => `${calculateAge(c.profile.birthDate)}${c.profile.birthDateIsApproximate ? ' (משוער)' : ''}` },
        { key: 'city', label: 'עיר', formatter: (c: Candidate) => c.profile.city || 'לא צוין' },
        { key: 'maritalStatus', label: 'מצב משפחתי', formatter: (c: Candidate) => c.profile.maritalStatus || 'לא צוין' },
        { key: 'religiousLevel', label: 'רמה דתית', formatter: (c: Candidate) => c.profile.religiousLevel || 'לא צוין' },
        { key: 'occupation', label: 'עיסוק', formatter: (c: Candidate) => c.profile.occupation || 'לא צוין' },
        { key: 'education', label: 'השכלה', formatter: (c: Candidate) => c.profile.education || 'לא צוין' },
    ];
  
    return (
      <div className="overflow-x-auto border rounded-lg">
        <table className="w-full text-sm text-right border-collapse">
          <thead>
            <tr className="bg-slate-50">
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200">קריטריון</th>
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200 text-center">{target.firstName}</th>
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200 text-center">{comparison.firstName}</th>
            </tr>
          </thead>
          <tbody>
            {fieldsToCompare.map((field, index) => (
              <tr key={field.key} className={index % 2 === 0 ? "bg-white" : "bg-slate-50/50"}>
                <td className="p-3 font-medium text-slate-500 border-b border-slate-200">{field.label}</td>
                <td className="p-3 text-slate-700 border-b border-slate-200 text-center">{field.formatter(target)}</td>
                <td className="p-3 text-slate-700 border-b border-slate-200 text-center">{field.formatter(comparison)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    );
};

const AnalysisSkeleton: React.FC = () => (
    <div className="space-y-6 p-4 animate-pulse">
        <div className="p-4 bg-gray-100 rounded-lg"><div className="h-20 bg-gray-200 rounded-md"></div></div>
        <div className="space-y-4">
            <div className="h-5 bg-gray-200 rounded-md w-1/3"></div>
            <div className="flex gap-4"><div className="rounded-full bg-gray-200 h-10 w-10"></div><div className="flex-1 space-y-2 py-1"><div className="h-4 bg-gray-200 rounded w-full"></div><div className="h-3 bg-gray-300 rounded w-5/6"></div></div></div>
            <div className="flex gap-4"><div className="rounded-full bg-gray-200 h-10 w-10"></div><div className="flex-1 space-y-2 py-1"><div className="h-4 bg-gray-200 rounded w-full"></div><div className="h-3 bg-gray-300 rounded w-4/6"></div></div></div>
        </div>
    </div>
);

// --- Main Dialog Component ---

export const AiMatchAnalysisDialog: React.FC<AiMatchAnalysisDialogProps> = ({ isOpen, onClose, targetCandidate, comparisonCandidates }) => {
  const [activeComparisonId, setActiveComparisonId] = useState<string | null>(null);
  const [analyses, setAnalyses] = useState<Record<string, AiAnalysis | 'error' | 'loading'>>({});
  const [language, setLanguage] = useState<'he' | 'en'>('he');
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const activeComparisonCandidate = useMemo(() => {
    return comparisonCandidates.find(c => c.id === activeComparisonId);
  }, [activeComparisonId, comparisonCandidates]);
  
  const activeAnalysis = useMemo(() => {
      if (!activeComparisonId) return null;
      return analyses[activeComparisonId] || null;
  }, [activeComparisonId, analyses]);

  useEffect(() => {
    if (isOpen && comparisonCandidates.length > 0 && !comparisonCandidates.some(c => c.id === activeComparisonId)) {
      setActiveComparisonId(comparisonCandidates[0].id);
    }
  }, [isOpen, comparisonCandidates, activeComparisonId]);

  useEffect(() => {
    if (isOpen && targetCandidate && activeComparisonId && analyses[activeComparisonId] === undefined) {
      const fetchAnalysis = async () => {
        setAnalyses(prev => ({ ...prev, [activeComparisonId]: 'loading' }));

        try {
          const response = await fetch('/api/ai/generate-rationale', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              userId1: targetCandidate.id,
              userId2: activeComparisonId,
              language: language,
            }),
          });

          const data = await response.json();
          if (response.ok && data.success) {
            setAnalyses(prev => ({ ...prev, [activeComparisonId]: data.analysis }));
          } else {
            throw new Error(data.error || "Failed to fetch analysis");
          }
        } catch (e) {
          console.error(`Failed to get analysis for ${activeComparisonId}:`, e);
          setAnalyses(prev => ({ ...prev, [activeComparisonId]: 'error' }));
        }
      };
      fetchAnalysis();
    }
  }, [isOpen, targetCandidate, activeComparisonId, language, analyses]);

  const handleLanguageChange = (newLang: 'he' | 'en') => {
    if (newLang !== language) {
      setLanguage(newLang);
      setAnalyses({});
    }
  };
  
  if (!isOpen || !targetCandidate) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl w-full h-[95vh] flex flex-col p-0 overflow-hidden" dir="rtl">
        <DialogHeader className="p-4 border-b flex-row justify-between items-center flex-shrink-0">
          <div className="flex items-center gap-3">
            <Sparkles className="w-7 h-7 text-teal-500" />
            <div>
              <DialogTitle className="text-xl">ניתוח התאמה מבוסס AI</DialogTitle>
              <DialogDescription>השוואה מפורטת בין מועמדים</DialogDescription>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Select value={language} onValueChange={handleLanguageChange}>
              <SelectTrigger className="w-[120px] text-xs h-9">
                <SelectValue placeholder="שפת ניתוח" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="he">עברית</SelectItem>
                <SelectItem value="en">English</SelectItem>
              </SelectContent>
            </Select>
            <DialogClose asChild>
              <Button variant="ghost" size="icon"><X className="h-5 w-5"/></Button>
            </DialogClose>
          </div>
        </DialogHeader>

        <div className="flex-1 flex flex-col md:flex-row min-h-0">
          {/* Sidebar (Desktop) or Select (Mobile) */}
          {isMobile ? (
            <div className="p-4 border-b md:hidden">
                <Select value={activeComparisonId || ''} onValueChange={setActiveComparisonId}>
                    <SelectTrigger className="w-full">
                        <SelectValue placeholder="בחר מועמד להשוואה" />
                    </SelectTrigger>
                    <SelectContent>
                        {comparisonCandidates.map(c => (
                            <SelectItem key={c.id} value={c.id}>{c.firstName} {c.lastName}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>
          ) : (
            <aside className="w-1/4 border-l bg-slate-50/50 flex flex-col flex-shrink-0">
              <h3 className="p-3 text-sm font-semibold text-slate-600 border-b">מועמדים להשוואה ({comparisonCandidates.length})</h3>
              <ScrollArea className="flex-1">
                {comparisonCandidates.map(candidate => (
                  <button
                    key={candidate.id}
                    onClick={() => setActiveComparisonId(candidate.id)}
                    className={cn(
                      "w-full text-right p-3 flex items-center gap-3 border-b border-slate-200/60 hover:bg-slate-100 transition-colors",
                      activeComparisonId === candidate.id && "bg-cyan-50 border-r-4 border-cyan-500 font-semibold"
                    )}
                  >
                    <div className="relative w-10 h-10 rounded-full overflow-hidden flex-shrink-0">
                       <Image src={candidate.images?.find(img => img.isMain)?.url || '/placeholder.jpg'} alt={candidate.firstName} layout="fill" className="object-cover" />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="truncate text-sm text-slate-800">{candidate.firstName} {candidate.lastName}</p>
                      <p className="text-xs text-slate-500">{calculateAge(candidate.profile.birthDate)} | {candidate.profile.city}</p>
                    </div>
                    {activeAnalysis && activeAnalysis !== 'error' && activeAnalysis !== 'loading' && (
                      <Badge variant="secondary" className="bg-teal-100 text-teal-800">{(activeAnalysis as AiAnalysis).overallScore}%</Badge>
                    )}
                  </button>
                ))}
              </ScrollArea>
            </aside>
          )}

          {/* Main content area */}
          <main className="flex-1 flex flex-col min-h-0 bg-white">
            {!activeComparisonCandidate ? (
                 <div className="flex-1 flex flex-col items-center justify-center text-center p-6 text-gray-500">
                    <Users className="w-16 h-16 text-gray-300 mb-4"/>
                    <h3 className="text-lg font-semibold">בחר מועמד/ת להשוואה</h3>
                    <p className="max-w-xs">בחר מועמד מהרשימה בצד (או מהתפריט הנפתח במובייל) כדי להתחיל בניתוח ההתאמה.</p>
                 </div>
            ) : (
                <>
                    <div className="grid grid-cols-1 md:grid-cols-2 flex-shrink-0">
                      <MiniProfileHeader candidate={targetCandidate} isTarget />
                      <MiniProfileHeader candidate={activeComparisonCandidate} score={(activeAnalysis as AiAnalysis)?.overallScore} />
                    </div>

                    <Tabs defaultValue="summary" className="flex-1 flex flex-col min-h-0">
                      <TabsList className="mx-4 mt-4 bg-slate-100 p-1 rounded-lg">
                        <TabsTrigger value="summary">סיכום וחוזקות</TabsTrigger>
                        <TabsTrigger value="challenges">אתגרים ופערים</TabsTrigger>
                        <TabsTrigger value="comparison">השוואת נתונים</TabsTrigger>
                        <TabsTrigger value="conversation">נושאים לשיחה</TabsTrigger>
                      </TabsList>
                      <ScrollArea className="flex-1">
                        <AnimatePresence mode="wait">
                          <motion.div
                            key={activeComparisonId}
                            initial={{ opacity: 0, y: 10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -10 }}
                            transition={{ duration: 0.2 }}
                            className="p-4 md:p-6"
                          >
                            {activeAnalysis === 'loading' && <AnalysisSkeleton />}
                            {activeAnalysis === 'error' && (
                                <div className="text-center py-10">
                                    <XCircle className="w-12 h-12 text-red-400 mx-auto mb-4"/>
                                    <h3 className="font-semibold text-xl text-red-600">שגיאה בניתוח ההתאמה</h3>
                                    <p className="text-gray-500 mt-2">לא הצלחנו להפיק ניתוח עבור זוג זה. אנא נסה שוב מאוחר יותר.</p>
                                </div>
                            )}
                            {activeAnalysis && activeAnalysis !== 'error' && activeAnalysis !== 'loading' && (
                              <>
                                <TabsContent value="summary" className="space-y-6 mt-0">
                                  <div className="p-4 bg-slate-50/70 rounded-lg border border-slate-200"><h3 className="font-semibold text-gray-800 mb-2 flex items-center gap-2"><Info className="w-5 h-5 text-blue-500"/> סיכום ההתאמה</h3><p className="text-sm text-gray-600 leading-relaxed">{(activeAnalysis as AiAnalysis).matchSummary}</p></div>
                                  <div><h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><CheckCircle className="w-5 h-5 text-green-500"/> נקודות חוזק וחיבור</h3><div className="space-y-4">{(activeAnalysis as AiAnalysis).compatibilityPoints.map(point => <AnalysisItem key={point.area} icon={CheckCircle} iconColor="text-green-500" {...point} />)}</div></div>
                                </TabsContent>
                                <TabsContent value="challenges" className="space-y-6 mt-0">
                                  <div><h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><AlertTriangle className="w-5 h-5 text-amber-500"/> אתגרים ופערים פוטנציאליים</h3><div className="space-y-4">{(activeAnalysis as AiAnalysis).potentialChallenges.map(challenge => <AnalysisItem key={challenge.area} icon={AlertTriangle} iconColor="text-amber-500" {...challenge} />)}</div></div>
                                </TabsContent>
                                <TabsContent value="comparison" className="mt-0"><ComparisonTable target={targetCandidate} comparison={activeComparisonCandidate} /></TabsContent>
                                <TabsContent value="conversation" className="space-y-4 mt-0">
                                  <h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><MessageSquare className="w-5 h-5 text-indigo-500"/> נושאים מומלצים לשיחה</h3>
                                  <ul className="space-y-3 list-inside">{(activeAnalysis as AiAnalysis).suggestedConversationStarters.map((starter, index) => (<li key={index} className="flex items-start gap-2 p-2 rounded-md hover:bg-indigo-50/50"><MessageSquare className="w-4 h-4 text-indigo-400 mt-1 flex-shrink-0"/><span className="text-sm text-gray-700">{starter}</span></li>))}</ul>
                                </TabsContent>
                              </>
                            )}
                          </motion.div>
                        </AnimatePresence>
                      </ScrollArea>
                    </Tabs>
                </>
            )}
          </main>
        </div>
      </DialogContent>
    </Dialog>
  );
};
--- End of Content for AiMatchAnalysisDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\filterUtils
--------------------------------------------------------------------------------
Content:
--- End of Content for filterUtils ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useCandidates.ts
--------------------------------------------------------------------------------
Content:
import { useState, useEffect, useMemo, useCallback } from 'react';
import Papa from 'papaparse';
import type { Candidate, CandidatesFilter } from '../types/candidates';
import type { CandidateProfile } from '../types/candidates';
import { Dispatch, SetStateAction } from 'react';

export interface UseCandidatesReturn {
  loading: boolean;
  error: string | null;
  candidates: Candidate[];
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  filteredCandidates: Candidate[];
  filters: CandidatesFilter;
  setFilters: Dispatch<SetStateAction<CandidatesFilter>>;
  refresh: () => Promise<void>;
  totalCount: number;
  filteredCount: number;
  maleCount: number;
  femaleCount: number;
  searchResults: {
    term: string;
    count: number;
    male: number;
    female: number;
  } | null;
  exportCandidates: (candidates: Candidate[], filters: CandidatesFilter) => Promise<void>;
  updateCandidate: (id: string, updates: Partial<CandidateProfile>) => Promise<void>;
  sorting: {
    field: string;
    direction: 'asc' | 'desc';
  };
  setSorting: (field: string, direction: 'asc' | 'desc') => void;
  searchSuggestions: (term: string) => Promise<Candidate[]>;
}

export const useCandidates = (initialFilters: CandidatesFilter = {}): UseCandidatesReturn => {
  // Base states
  const [candidates, setCandidates] = useState<Candidate[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<CandidatesFilter>(initialFilters);
  const [searchResults, setSearchResults] = useState<{
    term: string;
    count: number;
    male: number;
    female: number;
  } | null>(null);
  const [sorting, setSortingState] = useState<{
    field: string;
    direction: 'asc' | 'desc';
  }>({
    field: 'lastActive',
    direction: 'desc',
  });

  // Helper function to calculate age
  const calculateAge = useCallback((birthDate: Date): number => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    return age;
  }, []);

  // Fetch candidates data
  const fetchCandidates = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/matchmaker/candidates');
      if (!response.ok) {
        throw new Error(await response.text());
      }
      
      const data = await response.json();
     
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load candidates');
      }
  
      setCandidates(data.clients);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
      console.error('Error fetching candidates:', err);
    } finally {
      setLoading(false);
    }
  };

  // Set sorting field and direction
  const setSorting = useCallback((field: string, direction: 'asc' | 'desc') => {
    setSortingState({ field, direction });
  }, []);

  // Search suggestions based on a term
  const searchSuggestions = useCallback(async (term: string): Promise<Candidate[]> => {
    if (!term || term.length < 2) return [];
    
    // Local search implementation for quick response
    const searchTerm = term.toLowerCase();
    return candidates.filter(candidate => {
      const searchableText = `
        ${candidate.firstName} 
        ${candidate.lastName} 
        ${candidate.profile.occupation || ''} 
        ${candidate.profile.city || ''}
        ${candidate.profile.religiousLevel || ''}
      `.toLowerCase();
      
      return searchableText.includes(searchTerm);
    }).slice(0, 10);
    
    // Alternatively, you can implement an API call for server-side search
    // if the dataset is very large
  }, [candidates]);

  const sortCandidates = useCallback((candidatesList: Candidate[], field: string, direction: 'asc' | 'desc') => {
    return [...candidatesList].sort((a, b) => {
      let valueA, valueB;
      
      switch (field) {
        case 'name':
          valueA = `${a.firstName} ${a.lastName}`.toLowerCase();
          valueB = `${b.firstName} ${b.lastName}`.toLowerCase();
          break;
        case 'age':
          valueA = calculateAge(a.profile.birthDate);
          valueB = calculateAge(b.profile.birthDate);
          break;
        case 'city':
          valueA = (a.profile.city || '').toLowerCase();
          valueB = (b.profile.city || '').toLowerCase();
          break;
        case 'religiousLevel':
          valueA = (a.profile.religiousLevel || '').toLowerCase();
          valueB = (b.profile.religiousLevel || '').toLowerCase();
          break;
        case 'lastActive':
          valueA = a.profile.lastActive ? new Date(a.profile.lastActive).getTime() : 0;
          valueB = b.profile.lastActive ? new Date(b.profile.lastActive).getTime() : 0;
          break;
        case 'registrationDate':
          valueA = new Date(a.createdAt).getTime();
          valueB = new Date(b.createdAt).getTime();
          break;
        case 'height':
          valueA = a.profile.height || 0;
          valueB = b.profile.height || 0;
          break;
        default:
          valueA = 0;
          valueB = 0;
      }
      
      if (valueA < valueB) return direction === 'asc' ? -1 : 1;
      if (valueA > valueB) return direction === 'asc' ? 1 : -1;
      return 0;
    });
  }, [calculateAge]);
  
  // פונקציה לבדיקה אם מועמד עומד בקריטריוני חיפוש
  const checkSearchMatch = useCallback((candidate: Candidate, searchTerm: string): boolean => {
    if (!searchTerm) return true;
    
    // נרמול החיפוש
    const normalizedTerm = searchTerm.toLowerCase().trim();
    if (!normalizedTerm) return true;
    
    // בדיקת התאמה בשדות השונים
    const fullName = `${candidate.firstName} ${candidate.lastName}`.toLowerCase();
    const city = (candidate.profile.city || '').toLowerCase();
    const occupation = (candidate.profile.occupation || '').toLowerCase();
    const religiousLevel = (candidate.profile.religiousLevel || '').toLowerCase();
    
    return (
      fullName.includes(normalizedTerm) || 
      city.includes(normalizedTerm) || 
      occupation.includes(normalizedTerm) || 
      religiousLevel.includes(normalizedTerm)
    );
  }, []);

  // בקובץ useCandidates.ts - לעדכן את החלק של filteredCandidates
  const filteredCandidates = useMemo(() => {
    console.log("Filtering candidates with filters:", filters);
    
    // אם הסינון הנפרד מופעל, נשתמש בפילטרים הכלליים בלבד ללא מגדר
    const currentFilters = filters.separateFiltering 
      ? { ...filters, gender: undefined }
      : filters;

    let results = candidates.filter(candidate => {
      // סינון לפי מגדר רק אם הסינון הנפרד כבוי
      if (!filters.separateFiltering && currentFilters.gender && candidate.profile.gender !== currentFilters.gender) {
        return false;
      }
      if (currentFilters.source && candidate.source !== currentFilters.source) {
    return false;
}
      // בדיקת גיל מותאמת
      if (currentFilters.ageRange) {
        try {
          const age = calculateAge(candidate.profile.birthDate);
          if (age < currentFilters.ageRange.min || age > currentFilters.ageRange.max) {
            return false;
          }
        } catch (err) {
          console.error("Error calculating age for candidate:", candidate.id, err);
        }
      }
      
      // סינון סטטוס משתמש
      if (filters.userStatus && candidate.status !== filters.userStatus) {
        return false;
      }
   // סינון סטטוס משתמש
      if (filters.userStatus && candidate.status !== filters.userStatus) {
        return false;
      }
      // סינון סטטוס זמינות - ודא המרה נכונה של הטיפוס
      if (filters.availabilityStatus && 
          candidate.profile.availabilityStatus !== filters.availabilityStatus) {
        return false;
      }
      
      // בדיקת גובה
      if (filters.heightRange && candidate.profile.height) {
        if (
          candidate.profile.height < filters.heightRange.min || 
          candidate.profile.height > filters.heightRange.max
        ) {
          return false;
        }
      }

      // בדיקת רמת דתיות
      if (filters.religiousLevel && candidate.profile.religiousLevel !== filters.religiousLevel) {
        return false;
      }

      // בדיקת ערים
      if (filters.cities?.length && candidate.profile.city) {
        if (!filters.cities.includes(candidate.profile.city)) {
          return false;
        }
      }

      // בדיקת תחומי עיסוק
      if (filters.occupations?.length && candidate.profile.occupation) {
        if (!filters.occupations.includes(candidate.profile.occupation)) {
          return false;
        }
      }

      // בדיקת השכלה
      if (filters.educationLevel && candidate.profile.education !== filters.educationLevel) {
        return false;
      }

      // בדיקת מצב משפחתי
      if (filters.maritalStatus && candidate.profile.maritalStatus !== filters.maritalStatus) {
        return false;
      }

      // בדיקת אימות
      if (filters.isVerified !== undefined && candidate.isVerified !== filters.isVerified) {
        return false;
      }

      // בדיקת המלצות
   
      // בדיקת פעילות אחרונה
      if (filters.lastActiveDays && candidate.profile.lastActive) {
        const lastActive = new Date(candidate.profile.lastActive);
        const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
        if (daysDiff > filters.lastActiveDays) {
          return false;
        }
      }

      // בדיקת שלמות פרופיל
      if (filters.isProfileComplete !== undefined && 
          candidate.isProfileComplete !== filters.isProfileComplete) {
        return false;
      }

      // בדיקת חיפוש כללי - רק אם אין סינון נפרד
      if (!filters.separateFiltering && currentFilters.searchQuery) {
        return checkSearchMatch(candidate, currentFilters.searchQuery);
      }

      return true;
    });

    // מיון התוצאות
    if (sorting.field && sorting.direction) {
      results = sortCandidates(results, sorting.field, sorting.direction);
    }

    return results;
  }, [candidates, filters, calculateAge, sorting.field, sorting.direction, sortCandidates, checkSearchMatch]);

  // חלוקה למועמדים ומועמדות עם תמיכה בחיפוש נפרד
  const maleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לגברים
      return filteredCandidates
        .filter(c => c.profile.gender === 'MALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לגברים
          if (filters.maleFilters) {
            // בדיקת גיל
            if (filters.maleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.maleFilters.ageRange.min || age > filters.maleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.maleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.maleFilters.heightRange.min || 
                candidate.profile.height > filters.maleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.maleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.maleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.maleFilters.cities?.length && candidate.profile.city) {
              if (!filters.maleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.maleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.maleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.maleFilters.educationLevel && candidate.profile.education !== filters.maleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.maleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.maleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.maleFilters.isVerified !== undefined && candidate.isVerified !== filters.maleFilters.isVerified) {
              return false;
            }

    

            // בדיקת פעילות אחרונה
            if (filters.maleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.maleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.maleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.maleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הגברים
            if (filters.maleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.maleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לגברים
          if (filters.maleSearchQuery) {
            return checkSearchMatch(candidate, filters.maleSearchQuery);
          }
          
          return true;
        });
    
      }, [filteredCandidates, filters.maleFilters, filters.maleSearchQuery, calculateAge, checkSearchMatch]);
  const femaleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לנשים

      return filteredCandidates
        .filter(c => c.profile.gender === 'FEMALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לנשים
          if (filters.femaleFilters) {
            // בדיקת גיל
            if (filters.femaleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.femaleFilters.ageRange.min || age > filters.femaleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.femaleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.femaleFilters.heightRange.min || 
                candidate.profile.height > filters.femaleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.femaleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.femaleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.femaleFilters.cities?.length && candidate.profile.city) {
              if (!filters.femaleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.femaleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.femaleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.femaleFilters.educationLevel && candidate.profile.education !== filters.femaleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.femaleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.femaleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.femaleFilters.isVerified !== undefined && candidate.isVerified !== filters.femaleFilters.isVerified) {
              return false;
            }

       

            // בדיקת פעילות אחרונה
            if (filters.femaleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.femaleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.femaleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.femaleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הנשים
            if (filters.femaleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.femaleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לנשים
          if (filters.femaleSearchQuery) {
            return checkSearchMatch(candidate, filters.femaleSearchQuery);
          }
          
          return true;
        });
      }, [filteredCandidates, filters.femaleFilters, filters.femaleSearchQuery, calculateAge, checkSearchMatch]);
  // עדכון תוצאות החיפוש
  useEffect(() => {
    if (!filters.separateFiltering && filters.searchQuery) {
      // מצב חיפוש רגיל
      setSearchResults({
        term: filters.searchQuery,
        count: filteredCandidates.length,
        male: maleCandidates.length,
        female: femaleCandidates.length
      });
    } else if (filters.separateFiltering) {
      // במצב חיפוש נפרד, לא מציגים תוצאות חיפוש מאוחדות
      setSearchResults(null);
    } else {
      setSearchResults(null);
    }
  }, [filteredCandidates, maleCandidates, femaleCandidates, filters.searchQuery, filters.separateFiltering]);

  // Export candidates to CSV
  const exportCandidates = async (
    candidates: Candidate[], 
    filters: CandidatesFilter
  ): Promise<void> => {
    try {
      // Prepare data for export
      const exportData = candidates.map(candidate => ({
        'שם פרטי': candidate.firstName,
        'שם משפחה': candidate.lastName,
        'גיל': calculateAge(candidate.profile.birthDate),
        'מגדר': candidate.profile.gender === 'MALE' ? 'זכר' : 'נקבה',
        'עיר': candidate.profile.city || '',
        'גובה': candidate.profile.height || '',
        'רמת דתיות': candidate.profile.religiousLevel || '',
        'תעסוקה': candidate.profile.occupation || '',
        'השכלה': candidate.profile.education || '',
        'מצב משפחתי': candidate.profile.maritalStatus || '',
        'סטטוס זמינות': candidate.profile.availabilityStatus || '',
        'מאומת': candidate.isVerified ? 'כן' : 'לא',
        'פעילות אחרונה': candidate.profile.lastActive 
          ? new Date(candidate.profile.lastActive).toLocaleDateString('he-IL')
          : ''
      }));

      // Add filter info to filename
      const filenameSegments = ['candidates'];
      
      if (filters.gender) {
        filenameSegments.push(filters.gender === 'MALE' ? 'male' : 'female');
      }
      
      if (filters.religiousLevel) {
        filenameSegments.push(filters.religiousLevel.replace(/ /g, '-'));
      }
      
      if (filters.cities?.length === 1) {
        filenameSegments.push(filters.cities[0].replace(/ /g, '-'));
      }
      
      // Convert to CSV
      const csv = Papa.unparse(exportData);
      
      // Create and download file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      const timestamp = new Date().toISOString().split('T')[0];
      
      link.setAttribute('href', url);
      link.setAttribute('download', `${filenameSegments.join('_')}_${timestamp}.csv`);
      document.body.appendChild(link);
      
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Error exporting candidates:', error);
      throw new Error('Failed to export candidates');
    }
  };

  // Update candidate
  const updateCandidate = async (
    id: string, 
    updates: Partial<CandidateProfile>
  ): Promise<void> => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error('Failed to update candidate');
      }
      
      // Refresh candidates list after update
      await fetchCandidates();
    } catch (error) {
      console.error('Error updating candidate:', error);
      throw error;
    }
  };

  // Load candidates on mount
  useEffect(() => {
    fetchCandidates();
  }, []);

  // Return interface
  return {
    loading,
    error,
    candidates,
    filteredCandidates,
    maleCandidates,
    femaleCandidates,
    filters,
    setFilters,
    refresh: fetchCandidates,
    totalCount: candidates.length,
    filteredCount: filteredCandidates.length,
    maleCount: maleCandidates.length,
    femaleCount: femaleCandidates.length,
    searchResults,
    exportCandidates,
    updateCandidate,
    sorting,
    setSorting,
    searchSuggestions
  };
};
--- End of Content for useCandidates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useFilterLogic.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/hooks/useFilterLogic.ts - גרסה משופרת

import { useState, useEffect, useMemo, useCallback } from 'react';
import type {
  FilterState,
  SavedFilter,
  FilterOption,
  FilterChangeHandler,  
} from '../types/filters';
import { DEFAULT_FILTER_STATE } from '../types/filters'; 

type SavedFilterFromStorage = Omit<SavedFilter, 'createdAt'> & {
  createdAt: string;
};

interface SearchHistoryItemFromStorage {
  query: string;
  timestamp: string;
}
interface UseFilterLogicProps {
  onFilterChange?: FilterChangeHandler;
  defaultFilters?: Partial<FilterState>;
  localStorageKey?: string;
}

export const useFilterLogic = ({
  onFilterChange,
  defaultFilters = {},
  localStorageKey = 'candidateFilters'
}: UseFilterLogicProps = {}) => {
  // States
  const [filters, setFilters] = useState<FilterState>({
    ...DEFAULT_FILTER_STATE,
    ...defaultFilters
  });
  
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [searchHistory, setSearchHistory] = useState<{query: string, timestamp: Date}[]>([]);
  const [lastAppliedFilter, setLastAppliedFilter] = useState<string | null>(null);

  // Load saved filters and history from localStorage
  useEffect(() => {
    try {
      // Load saved filters
      const savedPrefs = localStorage.getItem(localStorageKey);
      if (savedPrefs) {
        const parsed = JSON.parse(savedPrefs);
        setSavedFilters(parsed.map((filter: SavedFilterFromStorage) => ({
          ...filter,
          createdAt: new Date(filter.createdAt)
        })));
      }

      // Load recent searches
      const searches = localStorage.getItem(`${localStorageKey}_recent_searches`);
      if (searches) {
        setRecentSearches(JSON.parse(searches));
      }

      // Load search history
      const history = localStorage.getItem(`${localStorageKey}_search_history`);
      if (history) {
        setSearchHistory(JSON.parse(history).map((item: SearchHistoryItemFromStorage) => ({
          ...item,
          timestamp: new Date(item.timestamp)
        })));
      }
    } catch (error) {
      console.error('Error loading saved filters:', error);
    }
  }, [localStorageKey]);

  // עדכון פילטרים כללי
  const updateFilters = useCallback((newFilters: Partial<FilterState>) => {
    console.log("updateFilters called with:", newFilters);
    
    setFilters(prev => {
      const updated = { ...prev, ...newFilters };
      console.log("Updated filters:", updated);
      
      // אם יש מחרוזת חיפוש חדשה, עדכן את היסטורית החיפוש
      if (newFilters.searchQuery && newFilters.searchQuery !== prev.searchQuery) {
        const newQuery = newFilters.searchQuery;
        console.log("New search query detected:", newQuery);
        
        // עדכון היסטוריית החיפוש
        const updatedHistory = [
          { query: newQuery, timestamp: new Date() },
          ...searchHistory.filter(item => item.query !== newQuery).slice(0, 9)
        ];
        
        setSearchHistory(updatedHistory);
        setRecentSearches(updatedHistory.map(item => item.query));
        
        // שמירה ב-localStorage
        try {
          localStorage.setItem(
            `${localStorageKey}_recent_searches`, 
            JSON.stringify(updatedHistory.map(item => item.query))
          );
          localStorage.setItem(
            `${localStorageKey}_search_history`,
            JSON.stringify(updatedHistory.map(item => ({
              query: item.query,
              timestamp: item.timestamp.toISOString()
            })))
          );
        } catch (e) {
          console.error("Error saving search history:", e);
        }
      }
      
      // טיפול בחיפוש נפרד לגברים
      if (newFilters.maleSearchQuery && newFilters.maleSearchQuery !== prev.maleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי גברים או לשמור בהיסטוריה הכללית
        console.log("New male search query:", newFilters.maleSearchQuery);
      }
      
      // טיפול בחיפוש נפרד לנשים
      if (newFilters.femaleSearchQuery && newFilters.femaleSearchQuery !== prev.femaleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי נשים או לשמור בהיסטוריה הכללית
        console.log("New female search query:", newFilters.femaleSearchQuery);
      }

      // קריאה לפונקציית callback
      if (onFilterChange) {
        console.log("Calling onFilterChange with updated filters");
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange, searchHistory, localStorageKey, setRecentSearches, setSearchHistory]);

  // Reset filters
  const resetFilters = useCallback(() => {
    const defaultState: FilterState = {
      ...DEFAULT_FILTER_STATE,
      ...defaultFilters
    };

    setFilters(defaultState);
    setLastAppliedFilter(null);
    onFilterChange?.(defaultState);
  }, [defaultFilters, onFilterChange]);

  // Clear recent searches
  const clearRecentSearches = useCallback(() => {
    setRecentSearches([]);
    localStorage.removeItem(`${localStorageKey}_recent_searches`);
  }, [localStorageKey]);

  // Save new filter
  const saveFilter = useCallback(async (name: string, filters: FilterState) => {
    const newFilter: SavedFilter = {
      id: Date.now().toString(),
      name,
      filters,
      isDefault: false,
      createdAt: new Date()
    };

    setSavedFilters(prev => {
      const updated = [...prev, newFilter];
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });

    return newFilter;
  }, [localStorageKey]);

  // פונקציה משופרת להחלפת מצב הסינון הנפרד
  const toggleSeparateFiltering = useCallback(() => {
    console.log("toggleSeparateFiltering called");
    
    setFilters(prev => {
      const newState = {
        ...prev,
        separateFiltering: !prev.separateFiltering
      };
      
      console.log(`Changing separateFiltering from ${prev.separateFiltering} to ${newState.separateFiltering}`);
      
      return newState;
    });
  }, []);

  // פונקציה משופרת לעדכון סינון גברים
  const updateMaleFilters = useCallback((maleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedMaleFilters = {
        ...prev.maleFilters,
        ...maleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לגברים
      if (maleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          maleFilters: updatedMaleFilters,
          maleSearchQuery: maleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        maleFilters: updatedMaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת לעדכון סינון נשים
  const updateFemaleFilters = useCallback((femaleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedFemaleFilters = {
        ...prev.femaleFilters,
        ...femaleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לנשים
      if (femaleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          femaleFilters: updatedFemaleFilters,
          femaleSearchQuery: femaleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        femaleFilters: updatedFemaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  const updateMaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        maleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לגברים אם פעיל סינון נפרד
      if (prev.separateFiltering) {
        updated.maleFilters = {
          ...prev.maleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);
  
  // פונקציה חדשה לעדכון חיפוש נפרד לנשים
  const updateFemaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        femaleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לנשים אם פעיל סינון נפרד
      if (prev.separateFiltering) {
        updated.femaleFilters = {
          ...prev.femaleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת להעתקת סינון מצד אחד לשני
  const copyFilters = useCallback((source: 'male' | 'female', target: 'male' | 'female') => {
    setFilters(prev => {
      const sourceFilters = source === 'male' ? prev.maleFilters : prev.femaleFilters;
      
      if (!sourceFilters) {
        return prev;
      }
      
      const updated = { ...prev };
      
      if (target === 'male') {
        updated.maleFilters = { ...sourceFilters };
      } else {
        updated.femaleFilters = { ...sourceFilters };
      }
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // Update existing filter
  const updateSavedFilter = useCallback((id: string, updates: Partial<SavedFilter>) => {
    setSavedFilters(prev => {
      const updated = prev.map(filter => 
        filter.id === id ? { ...filter, ...updates } : filter
      );
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Delete filter
  const deleteFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.filter(f => f.id !== id);
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      
      if (lastAppliedFilter === id) {
        setLastAppliedFilter(null);
      }
      
      return updated;
    });
  }, [localStorageKey, lastAppliedFilter]);

  // Set default filter
  const setDefaultFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.map(f => ({
        ...f,
        isDefault: f.id === id
      }));
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Load saved filter - תמיכה בסינון נפרד
  const loadSavedFilter = useCallback((id: string) => {
    const filter = savedFilters.find(f => f.id === id);
    if (filter) {
      // בדוק אם יש בפילטר השמור מידע לגבי סינון נפרד
      setFilters({ 
        ...filter.filters, 
        savedFilterId: id,
        // וודא שיש תמיד את המאפיינים האלה, גם אם אינם מוגדרים בפילטר המקורי
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {}
      });
      
      setLastAppliedFilter(id);
      onFilterChange?.({ 
        ...filter.filters, 
        savedFilterId: id,
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {} 
      });
    }
  }, [savedFilters, onFilterChange]);

  // Apply popular filter
  const applyPopularFilter = useCallback((filterConfig: Partial<FilterState>) => {
    const updatedFilters = {
      ...DEFAULT_FILTER_STATE,
      ...filterConfig
    };
    setFilters(updatedFilters);
    onFilterChange?.(updatedFilters);
  }, [onFilterChange]);

  // Check for active filters
  const hasActiveFilters = useMemo(() => {
    return (
      filters.searchQuery ||
      filters.gender !== undefined ||
      (filters.cities?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      (filters.occupations?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      filters.religiousLevel ||
      filters.educationLevel ||
      filters.maritalStatus ||
      filters.availabilityStatus ||
      filters.userStatus ||
      filters.isVerified ||
      filters.hasReferences ||
      filters.lastActiveDays ||
      filters.isProfileComplete ||
      (filters.ageRange && (
        filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min ||
        filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
      )) ||
      (filters.heightRange && (
        filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min ||
        filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
      )) ||
      // בדיקת פילטרים נפרדים פעילים
      filters.separateFiltering
    );
  }, [filters]);

  // Get active filters in formatted array
  const activeFilters = useMemo((): FilterOption[] => {
    const active: FilterOption[] = [];

    if (filters.searchQuery) {
      active.push({
        key: 'searchQuery',
        value: filters.searchQuery,
        label: `חיפוש: ${filters.searchQuery}`,
        category: 'חיפוש'
      });
    }

    if (filters.gender) {
      active.push({
        key: 'gender',
        value: filters.gender,
        label: `מגדר: ${filters.gender === 'MALE' ? 'זכר' : 'נקבה'}`,
        category: 'מידע בסיסי'
      });
    }

    if (filters.separateFiltering) {
      active.push({
        key: 'separateFiltering',
        value: true,
        label: 'סינון נפרד לפי מגדר',
        category: 'מידע בסיסי'
      });
    }

    // גיל
    if (filters.ageRange && (
      filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min || 
      filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
    )) {
      active.push({
        key: 'ageRange',
        value: filters.ageRange,
        label: `גיל: ${filters.ageRange.min}-${filters.ageRange.max}`,
        category: 'מידע בסיסי'
      });
    }

    // גובה
    if (filters.heightRange && (
      filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min || 
      filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
    )) {
      active.push({
        key: 'heightRange',
        value: filters.heightRange,
        label: `גובה: ${filters.heightRange.min}-${filters.heightRange.max} ס"מ`,
        category: 'מידע בסיסי'
      });
    }

    // ערים
    if (filters.cities?.length) {
      if (filters.cities.length === 1) {
        active.push({
          key: 'cities',
          value: filters.cities[0],
          label: `עיר: ${filters.cities[0]}`,
          category: 'מיקום'
        });
      } else {
        active.push({
          key: 'cities',
          value: filters.cities,
          label: `ערים: ${filters.cities.length} נבחרו`,
          category: 'מיקום'
        });
      }
    }

    // תחומי עיסוק
    if (filters.occupations?.length) {
      if (filters.occupations.length === 1) {
        active.push({
          key: 'occupations',
          value: filters.occupations[0],
          label: `תחום עיסוק: ${filters.occupations[0]}`,
          category: 'תעסוקה'
        });
      } else {
        active.push({
          key: 'occupations',
          value: filters.occupations,
          label: `תחומי עיסוק: ${filters.occupations.length} נבחרו`,
          category: 'תעסוקה'
        });
      }
    }

    // רמת דתיות
    if (filters.religiousLevel) {
      active.push({
        key: 'religiousLevel',
        value: filters.religiousLevel,
        label: `רמת דתיות: ${filters.religiousLevel}`,
        category: 'דת'
      });
    }

    // השכלה
    if (filters.educationLevel) {
      active.push({
        key: 'educationLevel',
        value: filters.educationLevel,
        label: `השכלה: ${filters.educationLevel}`,
        category: 'השכלה'
      });
    }

    // מצב משפחתי
    if (filters.maritalStatus) {
      active.push({
        key: 'maritalStatus',
        value: filters.maritalStatus,
        label: `מצב משפחתי: ${filters.maritalStatus}`,
        category: 'מידע אישי'
      });
    }

    // סטטוס זמינות
    if (filters.availabilityStatus) {
      const statusLabel = 
        filters.availabilityStatus === "AVAILABLE" ? "פנוי/ה" :
        filters.availabilityStatus === "DATING" ? "בתהליך הכרות" :
        filters.availabilityStatus === "UNAVAILABLE" ? "לא פנוי/ה" :
        filters.availabilityStatus;
      
      active.push({
        key: 'availabilityStatus',
        value: filters.availabilityStatus,
        label: `סטטוס זמינות: ${statusLabel}`,
        category: 'זמינות'
      });
    }

    // סטטוס משתמש
    if (filters.userStatus) {
      active.push({
        key: 'userStatus',
        value: filters.userStatus,
        label: `סטטוס משתמש: ${filters.userStatus}`,
        category: 'סטטוס'
      });
    }

    // משתמש מאומת
    if (filters.isVerified !== undefined) {
      active.push({
        key: 'isVerified',
        value: filters.isVerified,
        label: `משתמש מאומת: ${filters.isVerified ? 'כן' : 'לא'}`,
        category: 'אימות'
      });
    }

    // יש המלצות
    if (filters.hasReferences !== undefined) {
      active.push({
        key: 'hasReferences',
        value: filters.hasReferences,
        label: `יש המלצות: ${filters.hasReferences ? 'כן' : 'לא'}`,
        category: 'המלצות'
      });
    }

    // פעילות אחרונה
    if (filters.lastActiveDays !== undefined) {
      active.push({
        key: 'lastActiveDays',
        value: filters.lastActiveDays,
        label: `פעיל ב-${filters.lastActiveDays} הימים האחרונים`,
        category: 'פעילות'
      });
    }

    // פרופיל מלא
    if (filters.isProfileComplete !== undefined) {
      active.push({
        key: 'isProfileComplete',
        value: filters.isProfileComplete,
        label: `פרופיל מלא: ${filters.isProfileComplete ? 'כן' : 'לא'}`,
        category: 'שלמות פרופיל'
      });
    }

    return active;
  }, [filters]);

  // Remove single filter
  const removeFilter = useCallback((key: keyof FilterState, value?: string) => {
    setFilters(prev => {
      const updated = { ...prev };

      if (key === 'separateFiltering') {
        updated.separateFiltering = false;
      } else if (Array.isArray(updated[key]) && value !== undefined) {
        if (key === 'cities' || key === 'occupations') {
          updated[key] = (updated[key] as string[]).filter(v => v !== value);
        }
      } else {
        delete updated[key];
      }

      onFilterChange?.(updated);
      return updated;
    });
  }, [onFilterChange]);
  
  // Calculate popular filters based on search history
  const popularFilters = useMemo(() => {
    // Group searches by frequency
    const searchFrequency: Record<string, number> = {};
    searchHistory.forEach(item => {
      searchFrequency[item.query] = (searchFrequency[item.query] || 0) + 1;
    });
    
    // Sort by frequency
    return Object.entries(searchFrequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([query]) => query);
  }, [searchHistory]);

  return {
    // Current state
    filters,
    savedFilters,
    recentSearches,
    searchHistory,
    activeFilters,
    hasActiveFilters,
    popularFilters,
    lastAppliedFilter,
    
    // Separate filtering functions
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    
    // חיפוש נפרד פונקציות חדשות
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
    
    // Actions
    setFilters: updateFilters,
    removeFilter,
    resetFilters,
    clearRecentSearches,
    applyPopularFilter,

    // Saved filters management
    saveFilter,
    updateSavedFilter,
    deleteFilter,
    setDefaultFilter,
    loadSavedFilter,
};
};
export default useFilterLogic;
--- End of Content for useFilterLogic.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useStatistics.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useStatistics.ts

import { useMemo } from 'react';
import type { Candidate } from '../types/candidates';
import {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
} from '../../suggestions/utils/statisticsCalculator';

export interface Statistics {
  gender: {
    maleCount: number;
    femaleCount: number;
    ratio: number;
    total: number;
    percentages: {
      male: number;
      female: number;
    };
  };
  age: {
    ageGroups: Record<string, number>;
    averageAge: number;
    medianAge: number;
  };
  location: {
    cities: Record<string, number>;
    topCities: Array<{ city: string; count: number }>;
  };
  religious: {
    levels: Record<string, number>;
    percentages: Record<string, number>;
  };
  activity: {
    activeLastWeek: number;
    activeLastMonth: number;
    averageLoginFrequency: number;
    completedProfiles: number;
  };
  availability: {
    counts: Record<string, number>;
    percentages: Record<string, number>;
  };
  completion: {
    counts: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
    percentages: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
  };
}

export const useStatistics = (candidates: Candidate[]) => {
  const stats = useMemo<Statistics>(() => {
    return {
      gender: calculateGenderStats(candidates),
      age: calculateAgeDistribution(candidates),
      location: calculateLocationDistribution(candidates),
      religious: calculateReligiousDistribution(candidates),
      activity: calculateActivityStats(candidates),
      availability: calculateAvailabilityStats(candidates),
      completion: calculateCompletionStats(candidates)
    };
  }, [candidates]);

  // פונקציות עזר לשליפת נתונים ספציפיים
  const getGenderRatio = () => {
    return {
      ratio: stats.gender.ratio,
      formattedRatio: `${stats.gender.maleCount}:${stats.gender.femaleCount}`
    };
  };

  const getTopCities = (limit: number = 5) => {
    return stats.location.topCities.slice(0, limit);
  };

  const getActiveUsersPercent = () => {
    return Math.round((stats.activity.activeLastWeek / stats.gender.total) * 100);
  };

  const getCompletionRate = () => {
    return stats.completion.percentages.fullyCompleted;
  };

  const getAgeGroupDistribution = () => {
    return Object.entries(stats.age.ageGroups)
      .map(([range, count]) => ({
        range,
        count,
        percentage: Math.round((count / stats.gender.total) * 100)
      }))
      .sort((a, b) => {
        const [aMin] = a.range.split('-').map(Number);
        const [bMin] = b.range.split('-').map(Number);
        return aMin - bMin;
      });
  };

  const getReligiousDistribution = () => {
    return Object.entries(stats.religious.levels)
      .map(([level, count]) => ({
        level,
        count,
        percentage: stats.religious.percentages[level]
      }))
      .sort((a, b) => b.count - a.count);
  };

  const getActivityTrend = () => {
    return {
      weekly: stats.activity.activeLastWeek,
      monthly: stats.activity.activeLastMonth,
      average: stats.activity.averageLoginFrequency
    };
  };

  const getProfileCompletionStats = () => {
    return {
      completed: stats.completion.counts.fullyCompleted,
      partial: stats.gender.total - stats.completion.counts.fullyCompleted,
      percentage: stats.completion.percentages.fullyCompleted
    };
  };

  return {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getCompletionRate,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats
  };
};

export default useStatistics;
--- End of Content for useStatistics.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\LoadingStates.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { Loader2, AlertCircle } from "lucide-react";
import { cn } from "@/lib/utils";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";

interface LoadingContainerProps {
  children: React.ReactNode;
  className?: string;
}

interface LoadingSpinnerProps {
  size?: "sm" | "md" | "lg";
  className?: string;
}

interface LoadingCardProps {
  count?: number;
  layout?: "grid" | "list";
  className?: string;
}

interface LoadingTextProps {
  lines?: number;
  className?: string;
}

interface LoadingErrorProps {
  message: string;
  onRetry?: () => void;
  className?: string;
}

export const LoadingContainer: React.FC<LoadingContainerProps> = ({
  children,
  className,
}) => {
  return (
    <div className={cn("relative min-h-[200px]", className)}>
      <div className="absolute inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
      </div>
      <div className="opacity-50 pointer-events-none">{children}</div>
    </div>
  );
};

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = "md",
  className,
}) => {
  const sizeClasses = {
    sm: "w-4 h-4",
    md: "w-8 h-8",
    lg: "w-12 h-12",
  };

  return (
    <div className={cn("flex items-center justify-center", className)}>
      <Loader2
        className={cn("animate-spin text-blue-600", sizeClasses[size])}
      />
    </div>
  );
};

export const LoadingCard: React.FC<LoadingCardProps> = ({
  count = 1,
  layout = "grid",
  className,
}) => {
  return (
    <div
      className={cn(
        layout === "grid"
          ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
          : "space-y-4",
        className
      )}
    >
      {Array.from({ length: count }).map((_, index) => (
        <div
          key={index}
          className={cn(
            "bg-white rounded-lg overflow-hidden shadow-sm",
            layout === "list" ? "flex gap-4" : ""
          )}
        >
          <Skeleton
            className={cn(
              "bg-gray-200",
              layout === "list" ? "w-32 h-32" : "w-full h-48"
            )}
          />

          <div className="p-4 flex-1">
            <div className="flex items-center justify-between mb-4">
              <Skeleton className="h-6 w-1/3" />
              <Skeleton className="h-6 w-16" />
            </div>

            <div className="space-y-2">
              <Skeleton className="h-4 w-2/3" />
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-4 w-3/4" />
            </div>

            <div className="flex gap-2 mt-4">
              <Skeleton className="h-9 w-24" />
              <Skeleton className="h-9 w-24" />
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export const LoadingText: React.FC<LoadingTextProps> = ({
  lines = 3,
  className,
}) => {
  return (
    <div className={cn("space-y-2", className)}>
      {Array.from({ length: lines }).map((_, index) => (
        <Skeleton
          key={index}
          className={cn("h-4", index === lines - 1 ? "w-3/4" : "w-full")}
        />
      ))}
    </div>
  );
};

export const LoadingError: React.FC<LoadingErrorProps> = ({
  message,
  onRetry,
  className,
}) => {
  return (
    <Alert variant="destructive" className={cn("border-red-500", className)}>
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>שגיאה</AlertTitle>
      <AlertDescription className="flex items-center justify-between">
        <span>{message}</span>
        {onRetry && (
          <Button
            variant="outline"
            size="sm"
            onClick={onRetry}
            className="ml-4"
          >
            נסה שוב
          </Button>
        )}
      </AlertDescription>
    </Alert>
  );
};

export const LoadingStats: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("grid grid-cols-2 md:grid-cols-4 gap-4", className)}>
      {Array.from({ length: 4 }).map((_, index) => (
        <div key={index} className="bg-white p-4 rounded-lg shadow-sm">
          <Skeleton className="h-4 w-16 mb-2" />
          <Skeleton className="h-8 w-24" />
        </div>
      ))}
    </div>
  );
};

export const LoadingFilters: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("space-y-4", className)}>
      <Skeleton className="h-10 w-full" />
      <div className="flex flex-wrap gap-2">
        {Array.from({ length: 4 }).map((_, index) => (
          <Skeleton key={index} className="h-8 w-24" />
        ))}
      </div>
    </div>
  );
};

// Create a named object containing all loading components
const LoadingComponents = {
  LoadingContainer,
  LoadingSpinner,
  LoadingCard,
  LoadingText,
  LoadingError,
  LoadingStats,
  LoadingFilters,
};

// Export the named object as default
export default LoadingComponents;
--- End of Content for LoadingStates.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\Pagination.tsx
--------------------------------------------------------------------------------
Content:
// /shared/Pagination.tsx
"use client";


import React from 'react';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { 
  ChevronRight, 
  ChevronLeft,
  ChevronsLeft,
  ChevronsRight
} from 'lucide-react';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  pageSize: number;
  totalItems: number;
  onPageChange: (page: number) => void;
  onPageSizeChange: (size: number) => void;
  className?: string;
}

const pageSizeOptions = [10, 20, 50, 100];

const Pagination: React.FC<PaginationProps> = ({
  currentPage,
  totalPages,
  pageSize,
  totalItems,
  onPageChange,
  onPageSizeChange,
  className
}) => {
  // Helper to generate page numbers array
  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisiblePages = 5;
    
    if (totalPages <= maxVisiblePages) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    // Always show first page
    pages.push(1);

    // Calculate start and end of visible pages
    let start = Math.max(currentPage - 1, 2);
    let end = Math.min(currentPage + 1, totalPages - 1);

    // Adjust for edge cases
    if (currentPage <= 3) {
      end = Math.min(maxVisiblePages - 1, totalPages - 1);
    } else if (currentPage >= totalPages - 2) {
      start = Math.max(totalPages - maxVisiblePages + 2, 2);
    }

    // Add ellipsis and numbers
    if (start > 2) pages.push('...');
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    if (end < totalPages - 1) pages.push('...');

    // Always show last page
    if (totalPages > 1) pages.push(totalPages);

    return pages;
  };

  const startItem = (currentPage - 1) * pageSize + 1;
  const endItem = Math.min(currentPage * pageSize, totalItems);

  return (
    <div className={`flex flex-col sm:flex-row items-center justify-between gap-4 ${className}`}>
      {/* Page Size Selector */}
      <div className="flex items-center gap-2 text-sm text-gray-600">
        <span>הצג</span>
        <Select
          value={pageSize.toString()}
          onValueChange={(value) => onPageSizeChange(Number(value))}
        >
          <SelectTrigger className="w-[70px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {pageSizeOptions.map(size => (
              <SelectItem key={size} value={size.toString()}>
                {size}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <span>שורות</span>
      </div>

      {/* Results Count */}
      <div className="text-sm text-gray-600">
        מציג {startItem}-{endItem} מתוך {totalItems} תוצאות
      </div>

      {/* Page Navigation */}
      <div className="flex items-center gap-1">
        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(1)}
          disabled={currentPage === 1}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((page, index) => (
          typeof page === 'number' ? (
            <Button
              key={index}
              variant={currentPage === page ? "default" : "outline"}
              size="sm"
              onClick={() => onPageChange(page)}
              className="hidden sm:inline-flex min-w-[32px]"
            >
              {page}
            </Button>
          ) : (
            <span key={index} className="px-2">
              {page}
            </span>
          )
        ))}

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(totalPages)}
          disabled={currentPage === totalPages}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};

export default Pagination;
--- End of Content for Pagination.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\StatusBadge.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Badge } from "@/components/ui/badge";
import {
  Circle,
  CheckCircle,
  XCircle,
  Clock,
  AlertTriangle,
} from "lucide-react";
import { MatchSuggestionStatus, VerificationStatus } from "@prisma/client";

type StatusType = "suggestion" | "verification" | "profile";
type StatusSize = "sm" | "md" | "lg";

interface StatusConfig {
  label: string;
  color: "destructive" | "outline" | "secondary" | "success" | "warning";
  icon:
    | typeof Circle
    | typeof CheckCircle
    | typeof XCircle
    | typeof Clock
    | typeof AlertTriangle;
}

interface StatusBadgeProps {
  type: StatusType;
  status: string;
  size?: StatusSize;
}

const suggestionStatuses: Record<MatchSuggestionStatus, StatusConfig> = {
  DRAFT: {
    label: "טיוטה",
    color: "secondary",
    icon: Circle,
  },
  PENDING_FIRST_PARTY: {
    label: "ממתין לצד ראשון",
    color: "warning",
    icon: Clock,
  },
  FIRST_PARTY_APPROVED: {
    label: 'אושר ע"י צד ראשון',
    color: "success",
    icon: CheckCircle,
  },
  FIRST_PARTY_DECLINED: {
    label: 'נדחה ע"י צד ראשון',
    color: "destructive",
    icon: XCircle,
  },
  PENDING_SECOND_PARTY: {
    label: "ממתין לצד שני",
    color: "warning",
    icon: Clock,
  },
  SECOND_PARTY_APPROVED: {
    label: 'אושר ע"י צד שני',
    color: "success",
    icon: CheckCircle,
  },
  SECOND_PARTY_DECLINED: {
    label: 'נדחה ע"י צד שני',
    color: "destructive",
    icon: XCircle,
  },
  AWAITING_MATCHMAKER_APPROVAL: {
    label: "ממתין לאישור שדכן",
    color: "warning",
    icon: Clock,
  },
  CONTACT_DETAILS_SHARED: {
    label: "פרטי קשר שותפו",
    color: "success",
    icon: CheckCircle,
  },
  AWAITING_FIRST_DATE_FEEDBACK: {
    label: "ממתין למשוב פגישה ראשונה",
    color: "warning",
    icon: Clock,
  },
  THINKING_AFTER_DATE: {
    label: "בשיקול לאחר פגישה",
    color: "warning",
    icon: Clock,
  },
  PROCEEDING_TO_SECOND_DATE: {
    label: "ממשיכים לפגישה שנייה",
    color: "success",
    icon: CheckCircle,
  },
  ENDED_AFTER_FIRST_DATE: {
    label: "הסתיים לאחר פגישה ראשונה",
    color: "destructive",
    icon: XCircle,
  },
  MEETING_PENDING: {
    label: "פגישה בתכנון",
    color: "warning",
    icon: Clock,
  },
  MEETING_SCHEDULED: {
    label: "פגישה נקבעה",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_APPROVED: {
    label: "השידוך אושר",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_DECLINED: {
    label: "השידוך נדחה",
    color: "destructive",
    icon: XCircle,
  },
  DATING: {
    label: "בתהליך היכרות",
    color: "secondary",
    icon: Circle,
  },
  ENGAGED: {
    label: "מאורסים",
    color: "success",
    icon: CheckCircle,
  },
  MARRIED: {
    label: "נישאו",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  CLOSED: {
    label: "סגור",
    color: "destructive",
    icon: XCircle,
  },
  CANCELLED: {
    label: "בוטל",
    color: "destructive",
    icon: XCircle,
  },
};

const verificationStatuses: Record<VerificationStatus, StatusConfig> = {
  PENDING: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  COMPLETED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  FAILED: {
    label: "נכשל",
    color: "destructive",
    icon: XCircle,
  },
};

const profileStatuses: Record<string, StatusConfig> = {
  INCOMPLETE: {
    label: "לא הושלם",
    color: "warning",
    icon: AlertTriangle,
  },
  PENDING_VERIFICATION: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  VERIFIED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  BLOCKED: {
    label: "חסום",
    color: "destructive",
    icon: XCircle,
  },
};

const defaultStatus: StatusConfig = {
  label: "לא ידוע",
  color: "secondary",
  icon: Circle,
};

const getStatusConfig = (type: StatusType, status: string): StatusConfig => {
  switch (type) {
    case "suggestion":
      return (
        suggestionStatuses[status as MatchSuggestionStatus] || defaultStatus
      );
    case "verification":
      return (
        verificationStatuses[status as VerificationStatus] || defaultStatus
      );
    case "profile":
      return profileStatuses[status] || defaultStatus;
    default:
      return defaultStatus;
  }
};

const StatusBadge: React.FC<StatusBadgeProps> = ({
  type,
  status,
  size = "md",
}) => {
  const config = getStatusConfig(type, status);
  const Icon = config.icon;

  const sizeClasses = {
    sm: "text-xs px-2 py-0.5",
    md: "text-sm px-2.5 py-1",
    lg: "text-base px-3 py-1.5",
  };

  return (
    <Badge
      variant={config.color}
      className={`flex items-center gap-1.5 ${sizeClasses[size]}`}
    >
      <Icon className={size === "sm" ? "w-3 h-3" : "w-4 h-4"} />
      <span>{config.label}</span>
    </Badge>
  );
};

export default StatusBadge;
--- End of Content for StatusBadge.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types\candidates.ts
--------------------------------------------------------------------------------
Content:
// candidates.ts
import { Gender, AvailabilityStatus, UserStatus, UserSource  } from '@prisma/client';
import type { UserProfile, UserImage, QuestionnaireResponse} from '@/types/next-auth';

// Base API Response Type
export interface APIResponse<T> {
  success: boolean;
  clients: T[];
  count: number;
  error?: string;
}

// Base Types
export type CandidateImage = UserImage;

export type CandidateProfile = UserProfile;

export type MobileView = 'split' | 'single' | 'double';

export interface Candidate {
  id: string;
  email: string;
  firstName: string;
  createdAt: Date;
  lastName: string;
  status: UserStatus;
  isVerified: boolean;
  images: CandidateImage[];
  isProfileComplete: boolean;
  source: UserSource; // Add new field
  addedByMatchmakerId?: string | null; // Add new field
  profile: CandidateProfile; // Ensure this uses the updated CandidateProfile
    suggestionStatus?: {
    status: 'BLOCKED' | 'PENDING';
    suggestionId: string;
    withCandidateName: string;
  } | null;

}
export interface CandidatesFilter {
   source?: UserSource;
  gender?: Gender;
  ageRange?: {
    min: number;
    max: number;
  };
  heightRange?: {
    min: number;
    max: number;
  };
  cities?: string[];
  religiousLevel?: string;
  occupations?: string[];
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
  searchQuery?: string;
  savedFilterId?: string;
  separateFiltering?: boolean;
  
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  
  maleFilters?: Partial<CandidatesFilter>;
  femaleFilters?: Partial<CandidatesFilter>;
  userStatus?: UserStatus;
}

// ViewMode and Action Types - אלה נשארים כמו שהם
export type ViewMode = 'grid' | 'list';
export type CardSize = 'sm' | 'md' | 'lg';
export type CandidateAction = 'suggest' | 'invite' | 'contact' | 'favorite' | 'view' | 'edit';

// Profile Card Types
export interface ProfileCardData {
  profile: CandidateProfile;
  images: CandidateImage[];
  questionnaire?: QuestionnaireResponse;
}

/**
 * ממפה את אובייקט המועמד מהשרת למבנה הנדרש עבור ProfileCard
 */
export const mapCandidateToProfileCard = (candidate: Candidate): ProfileCardData => {
  return {
    profile: candidate.profile,
    images: candidate.images,
    questionnaire: undefined // יש להוסיף לוגיקה לטעינת השאלון בנפרד
  };
};

/**
 * מפריד מועמדים לפי מגדר
 */
export const separateCandidatesByGender = (candidates: Candidate[]) => {
  return {
    maleCandidates: candidates.filter(c => c.profile.gender === 'MALE'),
    femaleCandidates: candidates.filter(c => c.profile.gender === 'FEMALE')
  };
};

/**
 * בודק האם הפרופיל מלא
 */
export const isProfileComplete = (profile: CandidateProfile): boolean => {
  const requiredFields: Array<keyof CandidateProfile> = [
    'birthDate',
    'city',
    'religiousLevel',
    'about',
    'occupation',
    'education'
  ];

  return requiredFields.every(field => Boolean(profile[field]));
};

const candidateUtils = {
  mapCandidateToProfileCard,
  separateCandidatesByGender,
  isProfileComplete
};

export default candidateUtils;
--- End of Content for candidates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types\filters.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/types/filters.ts

import { Gender, AvailabilityStatus, UserStatus, UserSource  } from '@prisma/client';

// הגדרת טווח ערכים מספריים
export interface RangeFilter {
  min: number;
  max: number;
}

// הגדרת פילטר שמור
export interface SavedFilter {
  id: string;
  name: string;
  filters: FilterState;
  isDefault?: boolean;
  createdAt: Date;
}

export interface FilterState {
  // הוספת מצב תצוגה נפרדת
  separateFiltering: boolean;
    source?: UserSource | undefined;
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;

  // פילטרים נפרדים לגברים
  maleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;
  
  // פילטרים נפרדים לנשים
  femaleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;

  searchQuery?: string;
  savedFilterId?: string;
  gender?: Gender | undefined;
  ageRange?: RangeFilter;
  heightRange?: RangeFilter;
  cities?: string[];
  occupations?: string[];
  religiousLevel?: string;
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  userStatus?: UserStatus;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
}

// הגדרת אפשרות פילטר
export interface FilterOption {
  key: keyof (FilterState & { education: string });
  value: Gender | AvailabilityStatus | UserStatus | RangeFilter | string[] | string | number | boolean | undefined;
  label: string;
  category?: string;
}

// הגדרת קטגוריית פילטר
export interface FilterCategory {
  id: string;
  label: string;
  filters: Array<keyof (FilterState & { education: string })>;
}

// הגדרת פרופ לקומפוננטת הפילטרים
export interface FilterProps {
  filters: FilterState;
  onFiltersChange: (filters: FilterState) => void;
  onReset?: () => void;
  className?: string;
}

// הגדרת אפשרויות הפילטר
export interface FilterOptions {
  ages: RangeFilter;
  heights: RangeFilter;
  cities: string[];
  religiousLevels: string[];
  educationLevels: string[];
  occupations: string[];
  maritalStatuses: string[];
  availabilityStatuses: AvailabilityStatus[];
}

// הגדרת מצב הממשק של הפילטרים
export interface FilterUIState {
  isOpen: boolean;
  activeCategory?: string;
  showSaveDialog: boolean;
  presetName: string;
}

// הגדרה של אירועי שינוי בפילטרים
export type FilterChangeHandler = (filters: FilterState) => void;

// הגדרת אירועי שמירת פילטר
export interface SaveFilterHandler {
  (name: string, filters: FilterState): Promise<SavedFilter>;
}

// הגדרת אירועי טעינת פילטר
export interface LoadFilterHandler {
  (id: string): void;
}

// הגדרת הגדרות הפילטרים
export interface FilterSettings {
  localStorageKey?: string;
  defaultFilters?: Partial<FilterState>;
  onFilterChange?: FilterChangeHandler;
}

// הגדרת תוצאות הפילטר
export interface FilterResults {
  totalResults: number;
  filteredResults: number;
  categories: Record<string, number>;
}

// קונסטנטות של הפילטרים
export const DEFAULT_FILTER_STATE: FilterState = {
  separateFiltering: false,
  maleFilters: {},
  femaleFilters: {},
  maleSearchQuery: '',
  femaleSearchQuery: '',
  gender: undefined,
  ageRange: { min: 18, max: 99 },
  heightRange: { min: 140, max: 210 },
  cities: [],
  occupations: [],
  religiousLevel: undefined,
  educationLevel: undefined,
  maritalStatus: undefined,
  availabilityStatus: undefined,
    source: undefined,
  userStatus: undefined,
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined,
  isProfileComplete: undefined,
  searchQuery: '',
  savedFilterId: undefined
};

// קטגוריות פילטרים מוגדרות מראש
export const FILTER_CATEGORIES: FilterCategory[] = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'educationLevel', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availabilityStatus', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];

// טיפוסי מיון
export type SortDirection = 'asc' | 'desc';

export interface SortOption {
  field: keyof FilterState;
  direction: SortDirection;
  label: string;
}

// הגדרות קיבוץ
export interface GroupOption {
  field: keyof FilterState;
  label: string;
}

export const filterConstants = {
  DEFAULT_FILTER_STATE,
  FILTER_CATEGORIES
};

export default filterConstants;
--- End of Content for filters.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\EditSuggestionForm.tsx
--------------------------------------------------------------------------------
Content:
// קוד מתוקן ב-EditSuggestionForm.tsx עם פתרון לבעיית הטיפוסים

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { DatePicker } from "@/components/ui/date-picker";
import type { Suggestion } from "@/types/suggestions";

interface EditSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSave: (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      status?: MatchSuggestionStatus;
      statusNotes?: string;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => Promise<void>;
}

const EditSuggestionForm: React.FC<EditSuggestionFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSave,
}) => {
  const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
  // נשתמש בסוג נפרד לתיעוד אם נבחר סטטוס חדש או לא
  const [selectedStatus, setSelectedStatus] = useState<string | null>(null);
  // נשתמש במשתנה נפרד שיחזיק את הסטטוס האמיתי שיישלח לשרת
  const [statusToUpdate, setStatusToUpdate] =
    useState<MatchSuggestionStatus | null>(null);
  const [statusNotes, setStatusNotes] = useState("");
  const [matchingReason, setMatchingReason] = useState("");
  const [firstPartyNotes, setFirstPartyNotes] = useState("");
  const [secondPartyNotes, setSecondPartyNotes] = useState("");
  const [internalNotes, setInternalNotes] = useState("");
  const [decisionDeadline, setDecisionDeadline] = useState<Date | undefined>(
    undefined
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showStatusChange, setShowStatusChange] = useState(false);

  // עדכון הטופס כאשר נתוני ההצעה משתנים
  useEffect(() => {
    if (suggestion) {
      // עדכון כל השדות עם הנתונים הקיימים בהצעה
      setPriority(suggestion.priority as Priority);
      setSelectedStatus(null);
      setStatusToUpdate(null);
      setStatusNotes("");
      setMatchingReason(suggestion.matchingReason || "");
      setFirstPartyNotes(suggestion.firstPartyNotes || "");
      setSecondPartyNotes(suggestion.secondPartyNotes || "");
      setInternalNotes(suggestion.internalNotes || "");

      // טיפול נכון בתאריך
      if (suggestion.decisionDeadline) {
        // וידוא שמדובר בתאריך תקין
        const deadlineDate = new Date(suggestion.decisionDeadline);
        if (!isNaN(deadlineDate.getTime())) {
          setDecisionDeadline(deadlineDate);
        }
      } else {
        setDecisionDeadline(undefined);
      }
    }
  }, [suggestion]);

  const handleSubmit = async () => {
    if (!suggestion) return;

    try {
      setIsSubmitting(true);

      // מבנה העדכון עם אפשרות לסטטוס
      const updateData: {
        priority: Priority;
        status?: MatchSuggestionStatus;
        statusNotes?: string;
        matchingReason: string;
        firstPartyNotes: string;
        secondPartyNotes: string;
        internalNotes: string;
        decisionDeadline: string | null;
      } = {
        priority,
        matchingReason,
        firstPartyNotes,
        secondPartyNotes,
        internalNotes,
        decisionDeadline: decisionDeadline
          ? decisionDeadline.toISOString()
          : null,
      };

      // הוספת סטטוס רק אם נבחר סטטוס חדש לעדכון
      if (statusToUpdate) {
        updateData.status = statusToUpdate;
        updateData.statusNotes =
          statusNotes || `סטטוס שונה ל-${getStatusLabel(statusToUpdate)}`;
      }

      // עדכון הקומפוננטה ההורה
      await onSave({
        suggestionId: suggestion.id,
        updates: {
          priority,
          status: statusToUpdate || undefined,
          statusNotes: statusToUpdate ? statusNotes : undefined,
          matchingReason,
          firstPartyNotes,
          secondPartyNotes,
          internalNotes,
          decisionDeadline,
        },
      });

      toast.success("פרטי ההצעה עודכנו בהצלחה");
      onClose();
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    } finally {
      setIsSubmitting(false);
    }
  };

  // פונקציה להחזרת התווית המתאימה לסטטוס
  const getStatusLabel = (statusValue: string): string => {
    const statusLabels: Record<string, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
      FIRST_PARTY_APPROVED: "צד א׳ אישר",
      FIRST_PARTY_DECLINED: "צד א׳ דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
      SECOND_PARTY_APPROVED: "צד ב׳ אישר",
      SECOND_PARTY_DECLINED: "צד ב׳ דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
      PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
      ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
      MEETING_PENDING: "ממתין לקביעת פגישה",
      MEETING_SCHEDULED: "פגישה נקבעה",
      MATCH_APPROVED: "ההצעה אושרה",
      MATCH_DECLINED: "ההצעה נדחתה",
      DATING: "בתהליך היכרות",
      ENGAGED: "מאורסים",
      MARRIED: "נישאו",
      EXPIRED: "פג תוקף",
      CLOSED: "ההצעה נסגרה",
      CANCELLED: "ההצעה בוטלה",
    };

    return statusLabels[statusValue] || statusValue;
  };

  // הסטטוסים שניתן לשנות אליהם - יכול להשתנות לפי הסטטוס הנוכחי
  const getAvailableStatuses = (): MatchSuggestionStatus[] => {
    if (!suggestion) return [];

    // סטטוסים מרכזיים שתמיד זמינים
    const commonStatuses: MatchSuggestionStatus[] = [
      "PENDING_FIRST_PARTY",
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "PENDING_SECOND_PARTY",
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "CONTACT_DETAILS_SHARED",
      "DATING",
      "EXPIRED",
      "CLOSED",
      "CANCELLED",
    ];

    return commonStatuses;
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>עריכת הצעת שידוך</DialogTitle>
          <DialogDescription>
            עריכת הפרטים עבור ההצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Status and Priority Section */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Priority */}
            <div className="space-y-2">
              <Label>עדיפות ההצעה</Label>
              <Select
                value={priority}
                onValueChange={(value) => setPriority(value as Priority)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י עדיפות" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
                  <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                  <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                  <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Status */}
            <div className="space-y-2">
              <Label>שינוי סטטוס (אופציונלי)</Label>
              <Select
                value={selectedStatus || undefined}
                onValueChange={(value) => {
                  setSelectedStatus(value);

                  // אם נבחר "ללא שינוי" או ערך ריק
                  if (value === "NO_CHANGE" || !value) {
                    setStatusToUpdate(null);
                    setShowStatusChange(false);
                  } else {
                    // אחרת, מעדכנים את הסטטוס שיישלח לשרת
                    setStatusToUpdate(value as MatchSuggestionStatus);
                    setShowStatusChange(true);
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י סטטוס חדש (אופציונלי)" />
                </SelectTrigger>
                <SelectContent>
                  {/* משתמשים בערך חוקי מהמערכת */}
                  <SelectItem value="NO_CHANGE">ללא שינוי</SelectItem>
                  {getAvailableStatuses().map((availableStatus) => (
                    <SelectItem key={availableStatus} value={availableStatus}>
                      {getStatusLabel(availableStatus)}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Status Notes - מוצג רק אם נבחר סטטוס לעדכון */}
          {showStatusChange && statusToUpdate && (
            <div className="space-y-2 bg-slate-50 p-4 rounded-md border">
              <Label>הערות לשינוי הסטטוס</Label>
              <Textarea
                value={statusNotes}
                onChange={(e) => setStatusNotes(e.target.value)}
                placeholder="הערות אופציונליות לשינוי הסטטוס..."
                className="h-20"
              />
              <div className="text-xs text-gray-500 mt-1">
                הערות אלו יוצגו בהיסטוריית השינויים של ההצעה
              </div>
            </div>
          )}

          {/* Decision Deadline */}
          <div className="space-y-2">
            <Label>מועד החלטה אחרון</Label>
            <DatePicker
              value={{ from: decisionDeadline, to: undefined }}
              onChange={({ from }) => setDecisionDeadline(from)}
            />
          </div>

          {/* Matching Reason */}
          <div className="space-y-2">
            <Label>סיבת ההתאמה</Label>
            <Textarea
              value={matchingReason}
              onChange={(e) => setMatchingReason(e.target.value)}
              placeholder="פרט/י מדוע יש התאמה בין המועמדים..."
              className="h-24"
            />
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label>הערות לצד א׳ ({suggestion.firstParty.firstName})</Label>
              <Textarea
                value={firstPartyNotes}
                onChange={(e) => setFirstPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד א׳..."
                className="h-24"
              />
            </div>

            <div className="space-y-2">
              <Label>הערות לצד ב׳ ({suggestion.secondParty.firstName})</Label>
              <Textarea
                value={secondPartyNotes}
                onChange={(e) => setSecondPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד ב׳..."
                className="h-24"
              />
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-2">
            <Label>הערות פנימיות</Label>
            <Textarea
              value={internalNotes}
              onChange={(e) => setInternalNotes(e.target.value)}
              placeholder="הערות פנימיות לשימוש השדכנים בלבד..."
              className="h-24"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? "שומר..." : "שמור שינויים"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default EditSuggestionForm;
--- End of Content for EditSuggestionForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\MessageForm.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { MessageCircle, Send, AlertCircle } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";

interface MessageFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSend: (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => Promise<void>;
}

const MessageForm: React.FC<MessageFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSend,
}) => {
  const [partyType, setPartyType] = useState<"first" | "second" | "both">(
    "both"
  );
  const [messageType, setMessageType] = useState<
    "message" | "reminder" | "update"
  >("message");
  const [messageContent, setMessageContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async () => {
    if (!suggestion || !messageContent.trim()) return;

    try {
      setIsSubmitting(true);

      // Notify the parent component
      await onSend({
        suggestionId: suggestion.id,
        partyType,
        messageType,
        messageContent,
      });

      toast.success(
        `ההודעה נשלחה ${
          partyType === "first"
            ? `ל${suggestion.firstParty.firstName}`
            : partyType === "second"
            ? `ל${suggestion.secondParty.firstName}`
            : "לשני הצדדים"
        }`
      );
      onClose();
    } catch (error) {
      toast.error("שגיאה בשליחת ההודעה");
      console.error("Error sending message:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getMessagePlaceholder = () => {
    switch (messageType) {
      case "reminder":
        return "הודעת תזכורת למועמד/ת לגבי ההצעה...";
      case "update":
        return "עדכון לגבי סטטוס ההצעה או מידע חדש...";
      default:
        return "הודעה אישית למועמד/ת...";
    }
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>שליחת הודעה</DialogTitle>
          <DialogDescription>
            שליחת הודעה הקשורה להצעת השידוך בין{" "}
            {suggestion.firstParty.firstName} {suggestion.firstParty.lastName} ל
            {suggestion.secondParty.firstName} {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Recipient Selection */}
          <div className="space-y-2">
            <Label>שלח אל</Label>
            <Select
              value={partyType}
              onValueChange={(value) =>
                setPartyType(value as "first" | "second" | "both")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר נמען" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="first">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} (צד א׳)
                </SelectItem>
                <SelectItem value="second">
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName} (צד ב׳)
                </SelectItem>
                <SelectItem value="both">שני הצדדים</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Type */}
          <div className="space-y-2">
            <Label>סוג ההודעה</Label>
            <Select
              value={messageType}
              onValueChange={(value) =>
                setMessageType(value as "message" | "reminder" | "update")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר סוג הודעה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="message">
                  <div className="flex items-center">
                    <MessageCircle className="w-4 h-4 ml-2" />
                    הודעה רגילה
                  </div>
                </SelectItem>
                <SelectItem value="reminder">
                  <div className="flex items-center">
                    <AlertCircle className="w-4 h-4 ml-2" />
                    תזכורת
                  </div>
                </SelectItem>
                <SelectItem value="update">
                  <div className="flex items-center">
                    <Send className="w-4 h-4 ml-2" />
                    עדכון סטטוס
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Content */}
          <div className="space-y-2">
            <Label>תוכן ההודעה</Label>
            <Textarea
              value={messageContent}
              onChange={(e) => setMessageContent(e.target.value)}
              placeholder={getMessagePlaceholder()}
              className="h-36"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={isSubmitting || !messageContent.trim()}
            className="gap-2"
          >
            <Send className="w-4 h-4" />
            {isSubmitting ? "שולח..." : "שלח הודעה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default MessageForm;
--- End of Content for MessageForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions
# Generated on: 2025-06-22 22:37:50
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\EditSuggestionForm.tsx
--------------------------------------------------------------------------------
Content:
// קוד מתוקן ב-EditSuggestionForm.tsx עם פתרון לבעיית הטיפוסים

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { DatePicker } from "@/components/ui/date-picker";
import type { Suggestion } from "@/types/suggestions";

interface EditSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSave: (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      status?: MatchSuggestionStatus;
      statusNotes?: string;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => Promise<void>;
}

const EditSuggestionForm: React.FC<EditSuggestionFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSave,
}) => {
  const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
  // נשתמש בסוג נפרד לתיעוד אם נבחר סטטוס חדש או לא
  const [selectedStatus, setSelectedStatus] = useState<string | null>(null);
  // נשתמש במשתנה נפרד שיחזיק את הסטטוס האמיתי שיישלח לשרת
  const [statusToUpdate, setStatusToUpdate] =
    useState<MatchSuggestionStatus | null>(null);
  const [statusNotes, setStatusNotes] = useState("");
  const [matchingReason, setMatchingReason] = useState("");
  const [firstPartyNotes, setFirstPartyNotes] = useState("");
  const [secondPartyNotes, setSecondPartyNotes] = useState("");
  const [internalNotes, setInternalNotes] = useState("");
  const [decisionDeadline, setDecisionDeadline] = useState<Date | undefined>(
    undefined
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showStatusChange, setShowStatusChange] = useState(false);

  // עדכון הטופס כאשר נתוני ההצעה משתנים
  useEffect(() => {
    if (suggestion) {
      // עדכון כל השדות עם הנתונים הקיימים בהצעה
      setPriority(suggestion.priority as Priority);
      setSelectedStatus(null);
      setStatusToUpdate(null);
      setStatusNotes("");
      setMatchingReason(suggestion.matchingReason || "");
      setFirstPartyNotes(suggestion.firstPartyNotes || "");
      setSecondPartyNotes(suggestion.secondPartyNotes || "");
      setInternalNotes(suggestion.internalNotes || "");

      // טיפול נכון בתאריך
      if (suggestion.decisionDeadline) {
        // וידוא שמדובר בתאריך תקין
        const deadlineDate = new Date(suggestion.decisionDeadline);
        if (!isNaN(deadlineDate.getTime())) {
          setDecisionDeadline(deadlineDate);
        }
      } else {
        setDecisionDeadline(undefined);
      }
    }
  }, [suggestion]);

  const handleSubmit = async () => {
    if (!suggestion) return;

    try {
      setIsSubmitting(true);

      // מבנה העדכון עם אפשרות לסטטוס
      const updateData: {
        priority: Priority;
        status?: MatchSuggestionStatus;
        statusNotes?: string;
        matchingReason: string;
        firstPartyNotes: string;
        secondPartyNotes: string;
        internalNotes: string;
        decisionDeadline: string | null;
      } = {
        priority,
        matchingReason,
        firstPartyNotes,
        secondPartyNotes,
        internalNotes,
        decisionDeadline: decisionDeadline
          ? decisionDeadline.toISOString()
          : null,
      };

      // הוספת סטטוס רק אם נבחר סטטוס חדש לעדכון
      if (statusToUpdate) {
        updateData.status = statusToUpdate;
        updateData.statusNotes =
          statusNotes || `סטטוס שונה ל-${getStatusLabel(statusToUpdate)}`;
      }

      // עדכון הקומפוננטה ההורה
      await onSave({
        suggestionId: suggestion.id,
        updates: {
          priority,
          status: statusToUpdate || undefined,
          statusNotes: statusToUpdate ? statusNotes : undefined,
          matchingReason,
          firstPartyNotes,
          secondPartyNotes,
          internalNotes,
          decisionDeadline,
        },
      });

      toast.success("פרטי ההצעה עודכנו בהצלחה");
      onClose();
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    } finally {
      setIsSubmitting(false);
    }
  };

  // פונקציה להחזרת התווית המתאימה לסטטוס
  const getStatusLabel = (statusValue: string): string => {
    const statusLabels: Record<string, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
      FIRST_PARTY_APPROVED: "צד א׳ אישר",
      FIRST_PARTY_DECLINED: "צד א׳ דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
      SECOND_PARTY_APPROVED: "צד ב׳ אישר",
      SECOND_PARTY_DECLINED: "צד ב׳ דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
      PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
      ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
      MEETING_PENDING: "ממתין לקביעת פגישה",
      MEETING_SCHEDULED: "פגישה נקבעה",
      MATCH_APPROVED: "ההצעה אושרה",
      MATCH_DECLINED: "ההצעה נדחתה",
      DATING: "בתהליך היכרות",
      ENGAGED: "מאורסים",
      MARRIED: "נישאו",
      EXPIRED: "פג תוקף",
      CLOSED: "ההצעה נסגרה",
      CANCELLED: "ההצעה בוטלה",
    };

    return statusLabels[statusValue] || statusValue;
  };

  // הסטטוסים שניתן לשנות אליהם - יכול להשתנות לפי הסטטוס הנוכחי
  const getAvailableStatuses = (): MatchSuggestionStatus[] => {
    if (!suggestion) return [];

    // סטטוסים מרכזיים שתמיד זמינים
    const commonStatuses: MatchSuggestionStatus[] = [
      "PENDING_FIRST_PARTY",
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "PENDING_SECOND_PARTY",
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "CONTACT_DETAILS_SHARED",
      "DATING",
      "EXPIRED",
      "CLOSED",
      "CANCELLED",
    ];

    return commonStatuses;
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>עריכת הצעת שידוך</DialogTitle>
          <DialogDescription>
            עריכת הפרטים עבור ההצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Status and Priority Section */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Priority */}
            <div className="space-y-2">
              <Label>עדיפות ההצעה</Label>
              <Select
                value={priority}
                onValueChange={(value) => setPriority(value as Priority)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י עדיפות" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
                  <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                  <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                  <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Status */}
            <div className="space-y-2">
              <Label>שינוי סטטוס (אופציונלי)</Label>
              <Select
                value={selectedStatus || undefined}
                onValueChange={(value) => {
                  setSelectedStatus(value);

                  // אם נבחר "ללא שינוי" או ערך ריק
                  if (value === "NO_CHANGE" || !value) {
                    setStatusToUpdate(null);
                    setShowStatusChange(false);
                  } else {
                    // אחרת, מעדכנים את הסטטוס שיישלח לשרת
                    setStatusToUpdate(value as MatchSuggestionStatus);
                    setShowStatusChange(true);
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י סטטוס חדש (אופציונלי)" />
                </SelectTrigger>
                <SelectContent>
                  {/* משתמשים בערך חוקי מהמערכת */}
                  <SelectItem value="NO_CHANGE">ללא שינוי</SelectItem>
                  {getAvailableStatuses().map((availableStatus) => (
                    <SelectItem key={availableStatus} value={availableStatus}>
                      {getStatusLabel(availableStatus)}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Status Notes - מוצג רק אם נבחר סטטוס לעדכון */}
          {showStatusChange && statusToUpdate && (
            <div className="space-y-2 bg-slate-50 p-4 rounded-md border">
              <Label>הערות לשינוי הסטטוס</Label>
              <Textarea
                value={statusNotes}
                onChange={(e) => setStatusNotes(e.target.value)}
                placeholder="הערות אופציונליות לשינוי הסטטוס..."
                className="h-20"
              />
              <div className="text-xs text-gray-500 mt-1">
                הערות אלו יוצגו בהיסטוריית השינויים של ההצעה
              </div>
            </div>
          )}

          {/* Decision Deadline */}
          <div className="space-y-2">
            <Label>מועד החלטה אחרון</Label>
            <DatePicker
              value={{ from: decisionDeadline, to: undefined }}
              onChange={({ from }) => setDecisionDeadline(from)}
            />
          </div>

          {/* Matching Reason */}
          <div className="space-y-2">
            <Label>סיבת ההתאמה</Label>
            <Textarea
              value={matchingReason}
              onChange={(e) => setMatchingReason(e.target.value)}
              placeholder="פרט/י מדוע יש התאמה בין המועמדים..."
              className="h-24"
            />
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label>הערות לצד א׳ ({suggestion.firstParty.firstName})</Label>
              <Textarea
                value={firstPartyNotes}
                onChange={(e) => setFirstPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד א׳..."
                className="h-24"
              />
            </div>

            <div className="space-y-2">
              <Label>הערות לצד ב׳ ({suggestion.secondParty.firstName})</Label>
              <Textarea
                value={secondPartyNotes}
                onChange={(e) => setSecondPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד ב׳..."
                className="h-24"
              />
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-2">
            <Label>הערות פנימיות</Label>
            <Textarea
              value={internalNotes}
              onChange={(e) => setInternalNotes(e.target.value)}
              placeholder="הערות פנימיות לשימוש השדכנים בלבד..."
              className="h-24"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? "שומר..." : "שמור שינויים"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default EditSuggestionForm;
--- End of Content for EditSuggestionForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\MessageForm.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { MessageCircle, Send, AlertCircle } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";

interface MessageFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSend: (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => Promise<void>;
}

const MessageForm: React.FC<MessageFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSend,
}) => {
  const [partyType, setPartyType] = useState<"first" | "second" | "both">(
    "both"
  );
  const [messageType, setMessageType] = useState<
    "message" | "reminder" | "update"
  >("message");
  const [messageContent, setMessageContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async () => {
    if (!suggestion || !messageContent.trim()) return;

    try {
      setIsSubmitting(true);

      // Notify the parent component
      await onSend({
        suggestionId: suggestion.id,
        partyType,
        messageType,
        messageContent,
      });

      toast.success(
        `ההודעה נשלחה ${
          partyType === "first"
            ? `ל${suggestion.firstParty.firstName}`
            : partyType === "second"
            ? `ל${suggestion.secondParty.firstName}`
            : "לשני הצדדים"
        }`
      );
      onClose();
    } catch (error) {
      toast.error("שגיאה בשליחת ההודעה");
      console.error("Error sending message:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getMessagePlaceholder = () => {
    switch (messageType) {
      case "reminder":
        return "הודעת תזכורת למועמד/ת לגבי ההצעה...";
      case "update":
        return "עדכון לגבי סטטוס ההצעה או מידע חדש...";
      default:
        return "הודעה אישית למועמד/ת...";
    }
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>שליחת הודעה</DialogTitle>
          <DialogDescription>
            שליחת הודעה הקשורה להצעת השידוך בין{" "}
            {suggestion.firstParty.firstName} {suggestion.firstParty.lastName} ל
            {suggestion.secondParty.firstName} {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Recipient Selection */}
          <div className="space-y-2">
            <Label>שלח אל</Label>
            <Select
              value={partyType}
              onValueChange={(value) =>
                setPartyType(value as "first" | "second" | "both")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר נמען" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="first">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} (צד א׳)
                </SelectItem>
                <SelectItem value="second">
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName} (צד ב׳)
                </SelectItem>
                <SelectItem value="both">שני הצדדים</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Type */}
          <div className="space-y-2">
            <Label>סוג ההודעה</Label>
            <Select
              value={messageType}
              onValueChange={(value) =>
                setMessageType(value as "message" | "reminder" | "update")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר סוג הודעה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="message">
                  <div className="flex items-center">
                    <MessageCircle className="w-4 h-4 ml-2" />
                    הודעה רגילה
                  </div>
                </SelectItem>
                <SelectItem value="reminder">
                  <div className="flex items-center">
                    <AlertCircle className="w-4 h-4 ml-2" />
                    תזכורת
                  </div>
                </SelectItem>
                <SelectItem value="update">
                  <div className="flex items-center">
                    <Send className="w-4 h-4 ml-2" />
                    עדכון סטטוס
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Content */}
          <div className="space-y-2">
            <Label>תוכן ההודעה</Label>
            <Textarea
              value={messageContent}
              onChange={(e) => setMessageContent(e.target.value)}
              placeholder={getMessagePlaceholder()}
              className="h-36"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={isSubmitting || !messageContent.trim()}
            className="gap-2"
          >
            <Send className="w-4 h-4" />
            {isSubmitting ? "שולח..." : "שלח הודעה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default MessageForm;
--- End of Content for MessageForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\suggestions_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\CandidateSelector.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../../new/types/candidates";

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={(value) => {
                  setInputValue(value);
                  setActiveIndex(-1);
                }}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => (
                    <div
                      key={candidate.id}
                      onClick={() => handleSelect(candidate)}
                      className={`flex items-center gap-2 text-right p-2 hover:bg-accent/50 cursor-pointer ${
                        index === activeIndex ? "bg-accent" : ""
                      }`}
                      role="option"
                      id={`candidate-${candidate.id}`}
                      aria-selected={index === activeIndex}
                      onMouseEnter={() => setActiveIndex(index)}
                    >
                      <div className="flex-1">
                        <div className="font-medium">
                          {formatCandidateDisplay(candidate)}
                        </div>
                        <div className="text-sm text-gray-500">
                          {candidate.profile.religiousLevel} |
                          {candidate.profile.occupation &&
                            ` ${candidate.profile.occupation} |`}
                          {candidate.profile.education &&
                            ` ${candidate.profile.education}`}
                        </div>
                      </div>
                    </div>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => {
                /* Add view profile handler */
              }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;
--- End of Content for CandidateSelector.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\MatchPreview.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../../new/types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;
--- End of Content for MatchPreview.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\SuggestionDetails.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import React from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { calculateAge } from "@/lib/utils";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../../new/types/candidates";

interface SuggestionDetailsProps {
  className?: string;
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({
  firstParty,
  secondParty,
}) => {
  const {
    register,
    formState: { errors },
    setValue,
    getValues,
  } = useFormContext<NewSuggestionFormData>();

  // Format candidate display
  const formatCandidateInfo = (candidate: Candidate): string => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  };

  // Register all form fields
  React.useEffect(() => {
    // Set default values if not already set
    const currentValues = getValues();
    if (!currentValues.priority) {
      setValue("priority", Priority.MEDIUM);
    }
  }, [setValue, getValues]);

  return (
    <div className="space-y-6">
      {/* Selected Candidates Summary */}
      <Card className="bg-slate-50">
        <CardHeader className="pb-3">
          <h3 className="text-lg font-semibold">הצדדים המוצעים</h3>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד א׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(firstParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {firstParty.profile.religiousLevel} |
                {firstParty.profile.occupation &&
                  ` ${firstParty.profile.occupation} |`}
                {firstParty.profile.education &&
                  ` ${firstParty.profile.education}`}
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד ב׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(secondParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {secondParty.profile.religiousLevel} |
                {secondParty.profile.occupation &&
                  ` ${secondParty.profile.occupation} |`}
                {secondParty.profile.education &&
                  ` ${secondParty.profile.education}`}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Priority Selection with Visual Indicators */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <Label className="text-lg">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => {
                setValue("priority", value, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              value={getValues("priority") || Priority.MEDIUM}
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י עדיפות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="destructive"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    דחופה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.HIGH}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="warning"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    גבוהה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.MEDIUM}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="default"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    רגילה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.LOW}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="secondary"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    נמוכה
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && (
              <p className="text-sm text-red-500">{errors.priority.message}</p>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Matching Details */}
      <Card>
        <CardContent className="pt-6 space-y-6">
          {/* Matching Reason */}
          <div className="space-y-3">
            <Label className="text-lg">סיבת ההתאמה</Label>
            <div className="text-sm text-gray-500 mb-2">
              פרט/י מדוע לדעתך יש התאמה בין המועמדים. מידע זה יוצג לשני הצדדים.
            </div>
            <Textarea
              {...register("matchingReason")}
              placeholder="לדוגמה: שני הצדדים מחפשים בן/בת זוג עם השקפת עולם דומה, שאיפות דומות..."
              className="min-h-[120px] resize-none"
            />
            {errors.matchingReason && (
              <p className="text-sm text-red-500">
                {errors.matchingReason.message}
              </p>
            )}
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-3">
              <Label className="text-lg">הערות לצד א׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{firstParty.firstName}
              </div>
              <Textarea
                {...register("firstPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.firstPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.firstPartyNotes.message}
                </p>
              )}
            </div>

            <div className="space-y-3">
              <Label className="text-lg">הערות לצד ב׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{secondParty.firstName}
              </div>
              <Textarea
                {...register("secondPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.secondPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.secondPartyNotes.message}
                </p>
              )}
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-3">
            <Label className="text-lg">הערות פנימיות</Label>
            <div className="text-sm text-gray-500 mb-2">
              הערות אלו יהיו גלויות רק לצוות השדכנים
            </div>
            <Textarea
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשדכנים..."
              className="min-h-[100px] resize-none"
            />
            {errors.internalNotes && (
              <p className="text-sm text-red-500">
                {errors.internalNotes.message}
              </p>
            )}
          </div>

          {/* Decision Days */}
          <div className="space-y-3">
            <Label className="text-lg">זמן להחלטה</Label>
            <div className="text-sm text-gray-500 mb-2">
              תוך כמה ימים נדרשת החלטה סופית משני הצדדים
            </div>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              defaultValue="14"
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י מספר ימים" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="2">2 ימים</SelectItem>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="5">5 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && (
              <p className="text-sm text-red-500">
                {errors.decisionDeadline.message}
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;
--- End of Content for SuggestionDetails.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\index.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/toast/use-toast";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { CheckCircle, UserPlus } from "lucide-react";
import { Steps } from "@/components/ui/steps";
import type { Candidate } from "../../new/types/candidates";
import { newSuggestionSchema } from "./schema";
import type { NewSuggestionFormData } from "./schema";
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const STEPS = [
  {
    title: "בחירת מועמדים",
    description: "בחירת שני הצדדים להצעה",
    icon: UserPlus,
  },
  {
    title: "פרטי ההצעה",
    description: "הגדרת פרטי ההצעה ותזמונים",
    icon: CheckCircle,
  },
];

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({
  isOpen,
  onClose,
  candidates,
  selectedCandidate,
  onSubmit,
}) => {
  const [step, setStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(
    selectedCandidate || null
  );
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);

  const { toast } = useToast();

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      firstPartyId: selectedCandidate?.id || "",
      secondPartyId: "",
    },
  });

  // Debug logging for form state changes
  useEffect(() => {
    const subscription = form.watch((value, { name, type }) => {
      console.log("Form value changed:", {
        name,
        value,
        type,
        allValues: form.getValues(),
        formState: form.formState,
      });
    });

    return () => subscription.unsubscribe();
  }, [form]);

  // Handle candidate selection
  const handleCandidateSelect =
    (type: "first" | "second") => (candidate: Candidate | null) => {
      console.log(`${type} party selection:`, { candidate });

      if (type === "first") {
        setFirstParty(candidate);
        if (candidate) {
          form.setValue("firstPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("firstPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      } else {
        setSecondParty(candidate);
        if (candidate) {
          form.setValue("secondPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("secondPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      }

      // Log form state after update
      console.log("Form state after selection:", {
        values: form.getValues(),
        errors: form.formState.errors,
        isDirty: form.formState.isDirty,
        isValid: form.formState.isValid,
      });
    };

  const handleSubmit = async (data: NewSuggestionFormData) => {
    console.log("Submit attempt:", {
      formData: data,
      formState: form.formState,
      firstParty,
      secondParty,
    });

    if (!firstParty || !secondParty) {
      console.log("Missing parties:", { firstParty, secondParty });
      return;
    }

    try {
      setIsSubmitting(true);
      console.log("=== Before API call ===");
      await onSubmit(data);
      console.log("=== After successful API call ===");
      toast({
        title: "ההצעה נוצרה בהצלחה",
        description: "ההצעה נשמרה במערכת והועברה לטיפול",
      });
      onClose();
    } catch (error) {
      console.log("=== API call failed ===", error);
      console.error("Submission error:", error);
      toast({
        title: "שגיאה",
        description: "אירעה שגיאה בעת יצירת ההצעה",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle form validation before moving to next step
  const handleNextStep = () => {
    form.trigger(["firstPartyId", "secondPartyId"]).then((isValid) => {
      if (isValid) {
        setStep(2);
      } else {
        console.log("Validation failed:", form.formState.errors);
      }
    });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto p-0">
        <DialogHeader className="px-8 pt-6 pb-2">
          <DialogTitle className="text-2xl">יצירת הצעת שידוך חדשה</DialogTitle>
          <DialogDescription>
            יצירת הצעת שידוך בין שני מועמדים והגדרת פרטי ההצעה
          </DialogDescription>
        </DialogHeader>

        {/* Steps Indicator */}
        <div className="px-8 py-4">
          <Steps steps={STEPS} currentStep={step} />
        </div>

        <Separator />

        <FormProvider {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="p-8 pt-6">
            {/* Step 1: Candidate Selection */}
            <div className={step !== 1 ? "hidden" : "space-y-8"}>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <CandidateSelector
                  label="צד א׳"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={candidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />

                <CandidateSelector
                  label="צד ב׳"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={candidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

              {firstParty && secondParty && (
                <div className="rounded-lg border bg-card">
                  <div className="px-6 py-4 border-b">
                    <h3 className="text-lg font-semibold">
                      התאמה בין המועמדים
                    </h3>
                  </div>
                  <div className="p-6">
                    <MatchPreview
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  </div>
                </div>
              )}

              <div className="flex justify-end mt-8">
                <Button
                  type="button"
                  size="lg"
                  onClick={handleNextStep}
                  disabled={!firstParty || !secondParty}
                >
                  המשך להגדרת פרטי ההצעה
                </Button>
              </div>
            </div>

            {/* Step 2: Suggestion Details */}
            <div className={step !== 2 ? "hidden" : "space-y-8"}>
              <div className="rounded-lg border bg-card">
                <div className="px-6 py-4 border-b">
                  <h3 className="text-lg font-semibold">פרטי ההצעה</h3>
                </div>
                <div className="p-6">
                  {firstParty && secondParty ? (
                    <SuggestionDetails
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  ) : (
                    <div className="text-center py-4 text-gray-500">
                      יש לבחור את שני הצדדים בשלב הראשון
                    </div>
                  )}
                </div>
              </div>

              <div className="flex justify-between mt-8">
                <Button
                  type="button"
                  variant="outline"
                  size="lg"
                  onClick={() => setStep(1)}
                >
                  חזרה לבחירת מועמדים
                </Button>

                <Button
                  type="submit"
                  size="lg"
                  disabled={isSubmitting || !form.formState.isValid}
                >
                  {isSubmitting ? "שומר הצעה..." : "שמור הצעה"}
                </Button>
              </div>
            </div>
          </form>
        </FormProvider>
      </DialogContent>
    </Dialog>
  );
};

export default NewSuggestionForm;
--- End of Content for index.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\schema.ts
--------------------------------------------------------------------------------
Content:
import { z } from "zod";
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;
--- End of Content for schema.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards\SuggestionCard.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import Image from "next/image";
import {
  Clock,
  User,
  MessageCircle,
  Eye,
  AlertCircle,
  MoreHorizontal,
  Send,
  RefreshCw,
  Trash2,
  Edit,
  CheckCircle,
  XCircle,
  CalendarClock,
  Heart,
  MapPin,
  Calendar,
  Star,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestionStatus, Priority } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import { Progress } from "@/components/ui/progress";

interface SuggestionCardProps {
  suggestion: Suggestion;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const getStatusInfo = (status: MatchSuggestionStatus) => {
  switch (status) {
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לתשובת צד א׳",
        className: "bg-yellow-100 text-yellow-800 border-yellow-200",
        color: "text-yellow-600",
        bgColor: "bg-yellow-50",
        icon: Clock,
        progress: 25,
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לתשובת צד ב׳",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        color: "text-blue-600",
        bgColor: "bg-blue-50",
        icon: Clock,
        progress: 50,
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "צד א׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 40,
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "צד ב׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 60,
      };
    case "FIRST_PARTY_DECLINED":
      return {
        label: "צד א׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "SECOND_PARTY_DECLINED":
      return {
        label: "צד ב׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        className: "bg-purple-100 text-purple-800 border-purple-200",
        color: "text-purple-600",
        bgColor: "bg-purple-50",
        icon: Send,
        progress: 70,
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        className: "bg-pink-100 text-pink-800 border-pink-200",
        color: "text-pink-600",
        bgColor: "bg-pink-50",
        icon: Heart,
        progress: 80,
      };
    case "AWAITING_FIRST_DATE_FEEDBACK":
      return {
        label: "ממתין למשוב פגישה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        color: "text-orange-600",
        bgColor: "bg-orange-50",
        icon: AlertCircle,
        progress: 75,
      };
    case "EXPIRED":
      return {
        label: "פג תוקף",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: Clock,
        progress: 100,
      };
    default:
      return {
        label: "בטיפול",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: RefreshCw,
        progress: 30,
      };
  }
};

const getPriorityInfo = (priority: Priority) => {
  switch (priority) {
    case "URGENT":
      return {
        label: "דחוף",
        className: "bg-red-100 text-red-800 border-red-200",
        icon: AlertCircle,
        color: "text-red-600",
      };
    case "HIGH":
      return {
        label: "גבוה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        icon: Star,
        color: "text-orange-600",
      };
    case "MEDIUM":
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
    case "LOW":
      return {
        label: "נמוך",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: Star,
        color: "text-gray-600",
      };
    default:
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
  }
};

// Days left until deadline if applicable
const getDaysLeft = (decisionDeadline?: Date | string | null) => {
  if (!decisionDeadline) return null;

  const deadline = new Date(decisionDeadline);
  const today = new Date();
  const diffTime = deadline.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? diffDays : 0;
};

const SuggestionCard: React.FC<SuggestionCardProps> = ({
  suggestion,
  onAction,
  className,
}) => {
  const { firstParty, secondParty } = suggestion;
  const statusInfo = getStatusInfo(suggestion.status);
  const priorityInfo = getPriorityInfo(suggestion.priority);
  const StatusIcon = statusInfo.icon;
  const PriorityIcon = priorityInfo.icon;
  const daysLeft = getDaysLeft(suggestion.decisionDeadline);

  // Check if the suggestion is waiting for response
  const isWaitingForResponse =
    suggestion.status === "PENDING_FIRST_PARTY" ||
    suggestion.status === "PENDING_SECOND_PARTY";

  // Check if the suggestion has feedback requirement
  const needsFeedback = suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK";

  // Check if the suggestion can be resent
  const canBeResent =
    suggestion.status === "EXPIRED" ||
    suggestion.status === "FIRST_PARTY_DECLINED" ||
    suggestion.status === "SECOND_PARTY_DECLINED";

  const firstPartyAge = calculateAge(firstParty.profile.birthDate);
  const secondPartyAge = calculateAge(secondParty.profile.birthDate);

  const firstPartyMainImage = firstParty.images.find((img) => img.isMain);
  const secondPartyMainImage = secondParty.images.find((img) => img.isMain);

  return (
    <Card
      className={`${className} overflow-hidden hover:shadow-md transition-shadow`}
    >
      {/* Header with status and progress */}
      <div className={`p-4 ${statusInfo.bgColor} border-b relative`}>
        <div className="flex justify-between items-center mb-2">
          <div className="flex items-center gap-2">
            <StatusIcon className={`w-5 h-5 ${statusInfo.color}`} />
            <span className="font-medium text-gray-900">
              {statusInfo.label}
            </span>
          </div>
          <Badge className={priorityInfo.className}>
            <PriorityIcon className="w-3 h-3 ml-1" />
            {priorityInfo.label}
          </Badge>
        </div>

        <Progress value={statusInfo.progress} className="h-1.5" />

        {/* Deadline warning if needed */}
        {daysLeft !== null &&
          daysLeft <= 3 &&
          suggestion.status !== "EXPIRED" && (
            <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 bg-red-500 text-white text-xs font-bold py-0.5 px-2 rounded-full whitespace-nowrap z-10">
              <Clock className="w-3 h-3 inline-block ml-1" />
              {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים נותרו`}
            </div>
          )}
      </div>

      {/* Main content */}
      <div className="p-4">
        {/* Parties info */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          {/* First party */}
          <div className="space-y-2 border-l pl-4 order-1">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-blue-50">
                צד א׳
              </Badge>
              {suggestion.status === "FIRST_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "FIRST_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {firstPartyMainImage ? (
                  <Image
                    src={firstPartyMainImage.url}
                    alt={`${firstParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {firstParty.firstName} {firstParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{firstPartyAge} שנים</span>
                  </div>
                  {firstParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{firstParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Second party */}
          <div className="space-y-2 order-0">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-purple-50">
                צד ב׳
              </Badge>
              {suggestion.status === "SECOND_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "SECOND_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {secondPartyMainImage ? (
                  <Image
                    src={secondPartyMainImage.url}
                    alt={`${secondParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {secondParty.firstName} {secondParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{secondPartyAge} שנים</span>
                  </div>
                  {secondParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{secondParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Matching reason snippet */}
        {suggestion.matchingReason && (
          <div className="mb-4 p-3 bg-gray-50 rounded-lg border text-sm">
            <h5 className="text-xs font-semibold text-gray-600 mb-1">
              סיבת ההתאמה:
            </h5>
            <p className="text-gray-800 line-clamp-2">
              {suggestion.matchingReason.length > 120
                ? `${suggestion.matchingReason.substring(0, 120)}...`
                : suggestion.matchingReason}
            </p>
          </div>
        )}

        {/* Info and time */}
        <div className="flex justify-between text-xs text-gray-500 mb-4">
          <div className="flex items-center">
            <Clock className="w-3.5 h-3.5 ml-1" />
            {formatDistanceToNow(new Date(suggestion.createdAt), {
              addSuffix: true,
              locale: he,
            })}
          </div>

          {suggestion.decisionDeadline && (
            <div className="flex items-center">
              <CalendarClock className="w-3.5 h-3.5 ml-1" />
              {daysLeft !== null
                ? daysLeft === 0
                  ? "היום!"
                  : `${daysLeft} ימים להחלטה`
                : "אין מועד אחרון"}
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="flex items-center justify-between pt-2 border-t">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onAction("message", suggestion)}
            className="text-gray-600 hover:text-primary"
          >
            <MessageCircle className="w-4 h-4 ml-1" />
            הודעה
          </Button>

          {/* סקציית פעולות בקובץ SuggestionCard.tsx */}
          {isWaitingForResponse && (
            <Button
              variant="outline"
              size="sm"
              className="text-yellow-600"
              onClick={() =>
                onAction("reminder", suggestion, {
                  partyType:
                    suggestion.status === "PENDING_FIRST_PARTY"
                      ? "first"
                      : "second",
                })
              }
            >
              <Send className="w-4 h-4 ml-1" />
              {suggestion.status === "PENDING_FIRST_PARTY"
                ? "שלח תזכורת לצד ראשון"
                : suggestion.status === "PENDING_SECOND_PARTY"
                ? "שלח תזכורת לצד שני"
                : suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK"
                ? "שלח בקשת עדכון מפגש"
                : "שלח תזכורת"}
            </Button>
          )}

          {needsFeedback && (
            <Button
              variant="outline"
              size="sm"
              className="text-blue-600"
              onClick={() =>
                onAction("contact", suggestion, { type: "feedback" })
              }
            >
              <MessageCircle className="w-4 h-4 ml-1" />
              בקש משוב
            </Button>
          )}

          <div className="flex items-center gap-1">
            {canBeResent && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAction("resend", suggestion)}
                className="px-2"
              >
                <RefreshCw className="w-4 h-4" />
              </Button>
            )}

            <Button
              variant="outline"
              size="sm"
              onClick={() => onAction("edit", suggestion)}
              className="px-2"
            >
              <Edit className="w-4 h-4" />
            </Button>

            <Button
              variant="default"
              size="sm"
              onClick={() => onAction("view", suggestion)}
            >
              <Eye className="w-4 h-4 ml-1" />
              פרטים
            </Button>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button size="sm" variant="ghost" className="px-1">
                  <MoreHorizontal className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => onAction("edit", suggestion)}>
                  <Edit className="w-4 h-4 ml-2" />
                  <span>ערוך הצעה</span>
                </DropdownMenuItem>

                {canBeResent && (
                  <DropdownMenuItem
                    onClick={() => onAction("resend", suggestion)}
                  >
                    <RefreshCw className="w-4 h-4 ml-2" />
                    <span>שלח מחדש</span>
                  </DropdownMenuItem>
                )}

                <DropdownMenuItem
                  onClick={() => onAction("delete", suggestion)}
                  className="text-red-600"
                >
                  <Trash2 className="w-4 h-4 ml-2" />
                  <span>מחק הצעה</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </Card>
  );
};

export default SuggestionCard;
--- End of Content for SuggestionCard.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Plus, Download, RefreshCw, BarChart } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import type {
  Suggestion,
  SuggestionFilters,
  ActionAdditionalData,
} from "@/types/suggestions";
import type { NewSuggestionFormData } from "../../suggestions/NewSuggestionForm/schema";
import { MatchSuggestionStatus, Priority } from "@prisma/client";
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import SuggestionCard from "../cards/SuggestionCard";
import { toast } from "sonner";
import EditSuggestionForm from "../EditSuggestionForm";
import MessageForm from "../MessageForm";
import MonthlyTrendModal from "./MonthlyTrendModal";
type DialogActionData = {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyType?: "first" | "second" | "both";
  type?: string;
};
type ConfirmActionData = {
  suggestionId: string;
  partyType?: "first" | "second" | "both";
  type?: string;
};

export default function MatchmakerDashboard() {
  // State management
  const [activeTab, setActiveTab] = useState("pending"); // Changed default tab to "pending"
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<SuggestionFilters>({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmAction, setConfirmAction] = useState<{
    type: string;
    data: ConfirmActionData;
  } | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [showEditForm, setShowEditForm] = useState(false);
  const [showMessageForm, setShowMessageForm] = useState(false);
  const [, setMessageRecipient] = useState<"first" | "second" | "both">("both");
  const [showMonthlyTrendDialog, setShowMonthlyTrendDialog] = useState(false);

  // Calculate suggestion counts
  const activeCount = suggestions.filter((s) => s.category === "ACTIVE").length;
  const pendingCount = suggestions.filter(
    (s) => s.category === "PENDING"
  ).length;
  const historyCount = suggestions.filter(
    (s) => s.category === "HISTORY"
  ).length;

  // Fetch suggestions data
  const fetchSuggestions = async () => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/matchmaker/suggestions");
      if (!response.ok) {
        throw new Error("Failed to fetch suggestions");
      }

      const data = await response.json();
      setSuggestions(data);

      // Log suggestions data for debugging
      console.log("Fetched suggestions:", data);
      console.log("Total suggestions count:", data.length);

      // Log suggestions by status
      const activeCount = data.filter(
        (s: Suggestion) => s.category === "ACTIVE"
      ).length;
      const pendingCount = data.filter(
        (s: Suggestion) => s.category === "PENDING"
      ).length;
      const historyCount = data.filter(
        (s: Suggestion) => s.category === "HISTORY"
      ).length;
      console.log("Suggestions by status:", {
        active: activeCount,
        pending: pendingCount,
        history: historyCount,
      });
    } catch (error) {
      console.error("Error fetching suggestions:", error);
      toast.error("שגיאה בטעינת ההצעות");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (confirmAction?.type === "delete" && !showConfirmDialog) {
      // בדיקה אם דיאלוג האישור נסגר אחרי פעולת מחיקה - ריענון הנתונים
      fetchSuggestions();
    }
  }, [showConfirmDialog, confirmAction]);
  // Initial data fetch
  useEffect(() => {
    fetchSuggestions();
  }, []);

  // Handle refresh button
  const handleRefresh = async () => {
    setIsRefreshing(true);
    await fetchSuggestions();
    setIsRefreshing(false);
    toast.success("נתוני ההצעות עודכנו");
  };

  // Handle new suggestion creation
  const handleNewSuggestion = async (data: NewSuggestionFormData) => {
    try {
      const response = await fetch("/api/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      setShowNewSuggestion(false);
      toast.success("ההצעה נוצרה בהצלחה");
      await fetchSuggestions();
    } catch (error) {
      console.error("Error creating suggestion:", error);
      toast.error("שגיאה ביצירת ההצעה");
    }
  };

  // Handle suggestion deletion
  const handleSuggestionDeleted = useCallback(
    (deletedId: string) => {
      // הסרת ההצעה מהמצב המקומי
      setSuggestions((prevSuggestions) =>
        prevSuggestions.filter((suggestion) => suggestion.id !== deletedId)
      );

      // סגירת כל חלונות המודאל הפתוחים במידת הצורך
      if (selectedSuggestion?.id === deletedId) {
        setSelectedSuggestion(null);
      }
      if (showEditForm && selectedSuggestion?.id === deletedId) {
        setShowEditForm(false);
      }
      if (showMessageForm && selectedSuggestion?.id === deletedId) {
        setShowMessageForm(false);
      }

      // הוספת הודעת הצלחה (אופציונלי - כבר נוסף בhandleConfirmAction)
      // toast.success("ההצעה נמחקה בהצלחה");
    },
    [selectedSuggestion, showEditForm, showMessageForm]
  );

  // Export suggestions to CSV
  const handleExport = async () => {
    try {
      const response = await fetch("/api/suggestions/export", {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        throw new Error("Failed to export suggestions");
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `suggestions-export-${new Date().toISOString()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      toast.success("הקובץ הורד בהצלחה");
    } catch (error) {
      console.error("Error exporting suggestions:", error);
      toast.error("שגיאה בייצוא ההצעות");
    }
  };

  // Handle suggestion actions
  const handleSuggestionAction = (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => {
    console.log(
      `Action ${type} for suggestion ${suggestion.id}`,
      additionalData
    );

    switch (type) {
      case "view":
        setSelectedSuggestion(suggestion);
        break;
      case "delete":
        // הגדר את מידע הפעולה
        setConfirmAction({
          type: "delete",
          data: { suggestionId: suggestion.id },
        });

        // הצג את הדיאלוג
        setShowConfirmDialog(true);
        break;
      case "contact":
        // Show reminder sending confirmation
        setConfirmAction({
          type: "contact",
          data: {
            suggestionId: suggestion.id,
            partyType:
              suggestion.status === "PENDING_FIRST_PARTY" ? "first" : "second",
          },
        });
        setShowConfirmDialog(true);
        break;
      case "reminder":
        // Handle reminder action
        setConfirmAction({
          type: "contact", // או "reminder" אם יש טיפול שונה
          data: {
            suggestionId: suggestion.id,
            partyType: additionalData?.partyType || "both",
          },
        });
        setShowConfirmDialog(true);
        break;
      case "edit":
        // לפתיחת חלון עריכה
        setSelectedSuggestion(suggestion);
        setShowEditForm(true);
        break;
      case "message":
        // לפתיחת חלון הודעה
        setSelectedSuggestion(suggestion);
        setShowMessageForm(true);
        break;
      case "resend":
        // Show resend confirmation
        setConfirmAction({
          type: "resend",
          data: { suggestionId: suggestion.id },
        });
        setShowConfirmDialog(true);
        break;
      case "changeStatus":
        if (additionalData?.newStatus) {
          handleStatusChange(
            suggestion.id,
            additionalData.newStatus,
            additionalData?.notes
          );
        } else {
          console.error("Status change requested without providing new status");
          toast.error("שגיאה: סטטוס חדש לא סופק");
        }
        break;
    }
  };
  const getCategoryFromStatus = (
    status: MatchSuggestionStatus
  ): "ACTIVE" | "PENDING" | "HISTORY" => {
    switch (status) {
      case "DRAFT":
      case "AWAITING_MATCHMAKER_APPROVAL":
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return "PENDING";

      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
      case "MATCH_DECLINED":
      case "ENDED_AFTER_FIRST_DATE":
      case "ENGAGED":
      case "MARRIED":
      case "EXPIRED":
      case "CLOSED":
      case "CANCELLED":
        return "HISTORY";

      default:
        return "ACTIVE";
    }
  };
  // Handle status change
  const handleStatusChange = async (
    suggestionId: string,
    newStatus: MatchSuggestionStatus,
    notes?: string
  ) => {
    try {
      console.log(
        `Updating status for ${suggestionId} to ${newStatus}`,
        notes ? `with notes: ${notes}` : ""
      );

      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/status`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            status: newStatus,
            notes: notes || `סטטוס שונה מממשק ניהול הצעות`,
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Status update API error:", errorData);
        throw new Error(
          errorData.error ||
            `Failed to update status: ${response.status} ${response.statusText}`
        );
      }

      const data = await response.json();
      console.log("Status update success:", data);

      toast.success("סטטוס ההצעה עודכן בהצלחה");

      // עדכון רשימת ההצעות ללא צורך בטעינה מחדש
      setSuggestions((prevSuggestions) =>
        prevSuggestions.map((suggestion) =>
          suggestion.id === suggestionId
            ? {
                ...suggestion,
                status: newStatus,
                // עדכון קטגוריית ההצעה בהתאם לסטטוס החדש
                category: getCategoryFromStatus(newStatus),
                lastActivity: new Date().toISOString(),
                lastStatusChange: new Date().toISOString(),
                previousStatus: suggestion.status,
              }
            : suggestion
        )
      );
    } catch (error) {
      console.error("Error updating suggestion status:", error);
      toast.error(
        `שגיאה בעדכון סטטוס ההצעה: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Handle dialog actions
  const handleDialogAction = (action: string, data?: DialogActionData) => {
    console.log(`Dialog action: ${action}`, data);

    switch (action) {
      case "changeStatus":
        if (data?.suggestionId && data?.newStatus) {
          handleStatusChange(data.suggestionId, data.newStatus, data?.notes);
        }
        setSelectedSuggestion(null);
        break;
      case "delete":
        setConfirmAction({
          type: "delete",
          data: { suggestionId: data?.suggestionId as string },
        });
        setShowConfirmDialog(true);
        setSelectedSuggestion(null);
        break;
      case "message":
        // פתיחת טופס שליחת הודעה
        if (data?.suggestion) {
          setSelectedSuggestion(data.suggestion);
          setShowMessageForm(true);
          setMessageRecipient(data.partyType || "both");
        }
        break;
      case "edit":
        // פתיחת טופס עריכה
        if (data?.suggestion) {
          setSelectedSuggestion(data.suggestion);
          setShowEditForm(true);
        } else if (data?.suggestionId) {
          // מצב שבו יש רק מזהה הצעה
          const suggestion = suggestions.find(
            (s) => s.id === data.suggestionId
          );
          if (suggestion) {
            setSelectedSuggestion(suggestion);
            setShowEditForm(true);
          }
        }
        break;
      case "contact":
      case "reminder":
        if (data?.partyType && data?.suggestionId) {
          sendReminder(data.suggestionId, data.partyType);
        }
        break;
      case "sendReminder":
        if (data?.suggestionId && data?.type) {
          sendReminder(
            data.suggestionId,
            data.type as "first" | "second" | "both"
          );
        }
        break;
      case "resendToAll":
        if (data?.suggestionId) {
          resendSuggestion(data.suggestionId, "both");
        }
        break;
      case "export":
      case "exportHistory":
        toast.info("פונקציונליות ייצוא בפיתוח");
        break;
      case "scheduleMeeting":
        toast.info("פונקציונליות תיאום פגישה בפיתוח");
        break;
      case "shareContacts":
        if (data?.suggestionId) {
          setConfirmAction({
            type: "shareContacts",
            data: { suggestionId: data.suggestionId },
          });
          setShowConfirmDialog(true);
        }
        break;
    }
  };
  const handleUpdateSuggestion = async (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => {
    try {
      const response = await fetch(`/api/suggestions/${data.suggestionId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data.updates),
      });

      if (!response.ok) throw new Error("Failed to update suggestion");

      toast.success("פרטי ההצעה עודכנו בהצלחה");

      // Update suggestions list without refetching
      setSuggestions((prevSuggestions) =>
        prevSuggestions.map((s) =>
          s.id === data.suggestionId ? { ...s, ...data.updates } : s
        )
      );

      setShowEditForm(false);
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    }
  };

  // Handle sending message
  const handleSendMessage = async (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => {
    try {
      // שימוש בנתיב API הנכון
      const response = await fetch(
        `/api/matchmaker/suggestions/${data.suggestionId}/message`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            partyType: data.partyType,
            messageType: data.messageType,
            content: data.messageContent,
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send message");
      }

      toast.success("ההודעה נשלחה בהצלחה");
      setShowMessageForm(false);
      fetchSuggestions(); // רענון נתונים לאחר שליחת הודעה
    } catch (error) {
      console.error("Error sending message:", error);
      toast.error(
        `שגיאה בשליחת ההודעה: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Send reminder function
  const sendReminder = async (
    suggestionId: string,
    partyType: "first" | "second" | "both" = "both" // Default value
  ) => {
    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/remind`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ partyType }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send reminder");
      }

      toast.success(
        `תזכורת נשלחה ${
          partyType === "first"
            ? "לצד א'"
            : partyType === "second"
            ? "לצד ב'"
            : "לשני הצדדים"
        }`
      );
    } catch (error) {
      console.error("Error sending reminder:", error);
      toast.error(
        `שגיאה בשליחת התזכורת: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Resend suggestion function
  const resendSuggestion = async (
    suggestionId: string,
    partyType: "first" | "second" | "both"
  ) => {
    try {
      const response = await fetch(`/api/suggestions/${suggestionId}/resend`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ partyType }),
      });

      if (!response.ok) throw new Error("Failed to resend suggestion");

      toast.success(
        `ההצעה נשלחה מחדש ${
          partyType === "first"
            ? "לצד א'"
            : partyType === "second"
            ? "לצד ב'"
            : "לשני הצדדים"
        }`
      );
      fetchSuggestions();
    } catch (error) {
      console.error("Error resending suggestion:", error);
      toast.error("שגיאה בשליחת ההצעה מחדש");
    }
  };

  // Share contact details function
  /*   const shareContactDetails = async (suggestionId: string) => {
    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/share-contact`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to share contact details");
      }

      toast.success("פרטי הקשר שותפו בהצלחה בין שני הצדדים");
      fetchSuggestions(); // רענון הנתונים לאחר שיתוף פרטי קשר
    } catch (error) {
      console.error("Error sharing contact details:", error);
      toast.error(
        `שגיאה בשיתוף פרטי הקשר: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  }; */

  // Handle confirm dialog actions

  const handleConfirmAction = async () => {
    if (!confirmAction) return;

    try {
      switch (confirmAction.type) {
        case "delete":
          // קריאה לשרת
          const deleteResponse = await fetch(
            `/api/matchmaker/suggestions/${confirmAction.data.suggestionId}/delete`,
            {
              method: "DELETE",
            }
          );

          // בדיקת תשובה
          if (!deleteResponse.ok) {
            // טיפול בשגיאה
          }

          // עדכון UI
          handleSuggestionDeleted(confirmAction.data.suggestionId);
          toast.success("ההצעה נמחקה בהצלחה");
          break;
      }
    } catch (error) {
      // טיפול בשגיאות
      console.error("שגיאה בתהליך המחיקה:", error);
      toast.error("אירעה שגיאה בעת מחיקת ההצעה");
    } finally {
      setShowConfirmDialog(false);
      setConfirmAction(null);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6 rtl matchmaker-dashboard">
      <div className="container mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4 justify-end">
            <Badge variant="outline" className="text-sm">
              {suggestions.length} הצעות
            </Badge>
            <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
          </div>

          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={isRefreshing}
            >
              <RefreshCw
                className={`w-4 h-4 mr-2 ${isRefreshing ? "animate-spin" : ""}`}
              />
              {isRefreshing ? "מעדכן..." : "רענן נתונים"}
            </Button>

            <Button variant="outline" size="sm" onClick={handleExport}>
              <Download className="w-4 h-4 mr-2" />
              ייצוא
            </Button>

            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowMonthlyTrendDialog(true)}
            >
              <BarChart className="w-4 h-4 mr-2" />
              מגמה חודשית
            </Button>

            <Button onClick={() => setShowNewSuggestion(true)}>
              <Plus className="w-4 h-4 mr-2" />
              הצעה חדשה
            </Button>
          </div>
        </div>

        {/* Stats Overview */}
        <SuggestionsStats
          suggestions={suggestions}
          className="mb-6"
          onFilterChange={(filter) => {
            if (filter) {
              setFilters((currentFilters) => ({
                ...currentFilters,
                ...filter,
              }));
            }
          }}
        />

        {/* Main Content */}
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <div className="flex items-center justify-between mb-6">
            <TabsList dir="rtl" className="flex-row-reverse">
              <TabsTrigger value="pending">ממתין לאישור</TabsTrigger>
              <TabsTrigger value="active">הצעות פעילות</TabsTrigger>
              <TabsTrigger value="history">היסטוריה</TabsTrigger>
            </TabsList>
          </div>

          {/* Action Bar */}
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
            totalCount={suggestions.length}
            activeCount={activeCount}
            pendingCount={pendingCount}
            historyCount={historyCount}
          />

          {/* Loading State */}
          {isLoading ? (
            <div className="flex items-center justify-center h-64">
              <div className="text-gray-500">טוען...</div>
            </div>
          ) : (
            <>
              {/* Suggestions Lists */}
              <TabsContent value="pending">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "PENDING")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "PENDING").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות ממתינות</p>
                  </div>
                )}
              </TabsContent>

              <TabsContent value="active">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "ACTIVE")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "ACTIVE").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות פעילות</p>
                  </div>
                )}
              </TabsContent>

              <TabsContent value="history">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "HISTORY")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "HISTORY").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות בהיסטוריה</p>
                  </div>
                )}
              </TabsContent>
            </>
          )}
        </Tabs>
      </div>

      {/* New Suggestion Form */}
      <NewSuggestionForm
        isOpen={showNewSuggestion}
        onClose={() => setShowNewSuggestion(false)}
        candidates={[]}
        onSubmit={handleNewSuggestion}
      />

      {/* Suggestion Details Dialog */}
      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleDialogAction}
      />

      {/* Monthly Trend Dialog */}
      <Dialog
        open={showMonthlyTrendDialog}
        onOpenChange={setShowMonthlyTrendDialog}
      >
        <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>מגמה חודשית</DialogTitle>
            <DialogDescription>ניתוח מגמות הצעות לאורך זמן</DialogDescription>
          </DialogHeader>

          <div className="p-4">
            <MonthlyTrendModal suggestions={suggestions} />
          </div>

          <DialogFooter>
            <Button onClick={() => setShowMonthlyTrendDialog(false)}>
              סגור
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Confirm Action Dialog */}
      {confirmAction && (
        <AlertDialog
          open={showConfirmDialog}
          onOpenChange={setShowConfirmDialog}
        >
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
              <AlertDialogDescription>
                {confirmAction?.type === "delete" &&
                  "פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה."}
                {/* תנאים אחרים כאן */}
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel onClick={() => setShowConfirmDialog(false)}>
                ביטול
              </AlertDialogCancel>
              <AlertDialogAction
                onClick={handleConfirmAction}
                className={
                  confirmAction?.type === "delete"
                    ? "bg-red-600 hover:bg-red-700"
                    : ""
                }
              >
                {confirmAction?.type === "delete" ? "מחק" : "אשר"}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}

      {/* Edit Suggestion Form */}
      <EditSuggestionForm
        isOpen={showEditForm}
        onClose={() => setShowEditForm(false)}
        suggestion={selectedSuggestion}
        onSave={handleUpdateSuggestion}
      />

      {/* Message Form */}
      <MessageForm
        isOpen={showMessageForm}
        onClose={() => setShowMessageForm(false)}
        suggestion={selectedSuggestion}
        onSend={handleSendMessage}
      />
    </div>
  );
}
--- End of Content for MatchmakerDashboard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MonthlyTrendModal.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface MonthlyTrendModalProps {
  suggestions: Suggestion[];
}

interface MonthlyData {
  month: string;
  year: number;
  count: number;
  active: number;
  pending: number;
  success: number;
  declined: number;
}

const MonthlyTrendModal: React.FC<MonthlyTrendModalProps> = ({
  suggestions,
}) => {
  // Group suggestions by month to prepare data for chart
  const monthlyData = useMemo(() => {
    const data = suggestions.reduce((acc, s) => {
      const createdDate = new Date(s.createdAt);
      const month = createdDate.getMonth();
      const year = createdDate.getFullYear();
      const key = `${year}-${month + 1}`;

      if (!acc[key]) {
        acc[key] = {
          month: new Date(year, month).toLocaleString("he", {
            month: "short",
          }),
          year: year,
          count: 0,
          active: 0,
          pending: 0,
          success: 0,
          declined: 0,
        };
      }

      acc[key].count += 1;

      if (s.category === "ACTIVE") acc[key].active += 1;
      if (s.category === "PENDING") acc[key].pending += 1;
      if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
      if (
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
      ) {
        acc[key].declined += 1;
      }

      return acc;
    }, {} as Record<string, MonthlyData>);

    // Convert to array and sort by date
    return Object.values(data).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      const monthA = new Date(
        a.year,
        a.month === "ינו" ? 0 : new Date(`1 ${a.month} 2000`).getMonth()
      ).getMonth();
      const monthB = new Date(
        b.year,
        b.month === "ינו" ? 0 : new Date(`1 ${b.month} 2000`).getMonth()
      ).getMonth();
      return monthA - monthB;
    });
  }, [suggestions]);

  // Calculate trends
  const trends = useMemo(() => {
    if (monthlyData.length < 2)
      return { active: 0, pending: 0, success: 0, total: 0 };

    const current = monthlyData[monthlyData.length - 1];
    const previous = monthlyData[monthlyData.length - 2];

    const calculateTrend = (current: number, previous: number) => {
      if (previous === 0) return current > 0 ? 100 : 0;
      return Math.round(((current - previous) / previous) * 100);
    };

    return {
      active: calculateTrend(current.active, previous.active),
      pending: calculateTrend(current.pending, previous.pending),
      success: calculateTrend(current.success, previous.success),
      total: calculateTrend(current.count, previous.count),
    };
  }, [monthlyData]);

  if (monthlyData.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        <p>אין מספיק נתונים להצגת מגמה חודשית</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Summary stats */}
      <div className="grid grid-cols-4 gap-3">
        <Card className="p-3">
          <div className="text-sm text-gray-500"> סך כל ההצעות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].count}
            <span
              className={`text-xs ml-2 ${
                trends.total >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.total > 0 ? "+" : ""}
              {trends.total}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות פעילות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].active}
            <span
              className={`text-xs ml-2 ${
                trends.active >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.active > 0 ? "+" : ""}
              {trends.active}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">ממתינות לאישור</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].pending}
            <span
              className={`text-xs ml-2 ${
                trends.pending >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.pending > 0 ? "+" : ""}
              {trends.pending}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות מוצלחות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].success}
            <span
              className={`text-xs ml-2 ${
                trends.success >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.success > 0 ? "+" : ""}
              {trends.success}%
            </span>
          </div>
        </Card>
      </div>

      {/* Main chart */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={monthlyData}
              margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip
                formatter={(value) => [`${value} הצעות`, ""]}
                labelFormatter={(label) => `חודש ${label}`}
              />
              <Legend />
              <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
              <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
              <Bar dataKey="success" name="הצלחות" fill="#10B981" />
              <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* Monthly breakdown table */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">פירוט חודשי</h3>
        <div className="overflow-x-auto">
          <table className="w-full border-collapse">
            <thead>
              <tr className="bg-gray-50">
                <th className="p-2 border text-right">חודש</th>
                <th className="p-2 border text-center">סך הכל</th>
                <th className="p-2 border text-center">פעילות</th>
                <th className="p-2 border text-center">ממתינות</th>
                <th className="p-2 border text-center">הצלחות</th>
                <th className="p-2 border text-center">נדחו</th>
              </tr>
            </thead>
            <tbody>
              {monthlyData
                .slice()
                .reverse()
                .map((month, idx) => (
                  <tr
                    key={idx}
                    className={idx % 2 === 0 ? "bg-white" : "bg-gray-50"}
                  >
                    <td className="p-2 border font-medium">
                      {month.month} {month.year}
                    </td>
                    <td className="p-2 border text-center">{month.count}</td>
                    <td className="p-2 border text-center">{month.active}</td>
                    <td className="p-2 border text-center">{month.pending}</td>
                    <td className="p-2 border text-center">{month.success}</td>
                    <td className="p-2 border text-center">{month.declined}</td>
                  </tr>
                ))}
            </tbody>
          </table>
        </div>
      </Card>
    </div>
  );
};

export default MonthlyTrendModal;
--- End of Content for MonthlyTrendModal.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { DatePicker } from "@/components/ui/date-picker";
import {
  Search,
  Filter,
  X,
  Calendar,
  User,
  Clock,
  ChevronDown,
  AlertCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import type { SuggestionFilters, SortByOption } from "@/types/suggestions";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: SuggestionFilters;
  onFiltersChange: (filters: SuggestionFilters) => void;
  totalCount: number;
  activeCount: number;
  pendingCount: number;
  historyCount: number;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
  totalCount,
  activeCount,
  pendingCount,
  historyCount,
}) => {
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const activeFilters = Object.keys(filters).length;
  const [dateRange, setDateRange] = useState<{
    from: Date | undefined;
    to: Date | undefined;
  }>({
    from: filters.dateRange?.start,
    to: filters.dateRange?.end,
  });

  const handleRemoveFilter = (key: keyof SuggestionFilters) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  const handleDateRangeChange = (range: {
    from: Date | undefined;
    to: Date | undefined;
  }) => {
    setDateRange(range);
    if (range.from) {
      onFiltersChange({
        ...filters,
        dateRange: {
          start: range.from,
          end: range.to || new Date(),
        },
      });
    } else {
      const newFilters = { ...filters };
      delete newFilters.dateRange;
      onFiltersChange(newFilters);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return <Clock className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_APPROVED":
      case "SECOND_PARTY_APPROVED":
        return <CheckCircle className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
        return <XCircle className="h-4 w-4 ml-1" />;
      default:
        return <AlertCircle className="h-4 w-4 ml-1" />;
    }
  };

  return (
    <div className="space-y-4 mb-6">
      {/* Main filters and search */}
      <div className="flex items-center gap-4">
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות לפי שם, עיר או כל מידע אחר..."
            className="pl-10 text-right pr-10"
          />
        </div>

        <Select
          value={filters.priority?.[0] || "all"}
          onValueChange={(value) =>
            onFiltersChange({
              ...filters,
              priority: value === "all" ? undefined : [value as Priority],
            })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">כל העדיפויות</SelectItem>
            <SelectItem value={Priority.URGENT}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-red-500"></span>
                דחוף
              </div>
            </SelectItem>
            <SelectItem value={Priority.HIGH}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-orange-500"></span>
                גבוהה
              </div>
            </SelectItem>
            <SelectItem value={Priority.MEDIUM}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-blue-500"></span>
                רגילה
              </div>
            </SelectItem>
            <SelectItem value={Priority.LOW}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-gray-500"></span>
                נמוכה
              </div>
            </SelectItem>
          </SelectContent>
        </Select>

        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" className="flex items-center">
              <Calendar className="h-4 w-4 ml-2" />
              <span>טווח זמן</span>
              <ChevronDown className="h-4 w-4 mr-2" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-4" align="end">
            <div className="space-y-2">
              <h4 className="font-medium">בחר טווח תאריכים</h4>
              <DatePicker
                onChange={handleDateRangeChange}
                value={dateRange}
                isRange={true}
              />
              <div className="flex justify-end mt-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() =>
                    handleDateRangeChange({ from: undefined, to: undefined })
                  }
                >
                  נקה
                </Button>
              </div>
            </div>
          </PopoverContent>
        </Popover>

        <Button
          variant={showAdvancedFilters ? "default" : "outline"}
          onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
        >
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Stats Row */}
      <div className="flex justify-between bg-slate-50 rounded-md p-3">
        <div className="flex items-center gap-6">
          <div className="flex items-center">
            <Badge variant="outline" className="rounded-full px-2 py-0 mr-2">
              {totalCount}
            </Badge>
            <span className="text-sm font-medium">סה״כ הצעות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="default" className="rounded-full px-2 py-0 mr-2">
              {activeCount}
            </Badge>
            <span className="text-sm font-medium">פעילות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="warning" className="rounded-full px-2 py-0 mr-2">
              {pendingCount}
            </Badge>
            <span className="text-sm font-medium">ממתינות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="secondary" className="rounded-full px-2 py-0 mr-2">
              {historyCount}
            </Badge>
            <span className="text-sm font-medium">היסטוריה</span>
          </div>
        </div>

        {activeFilters > 0 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה את כל המסננים ({activeFilters})
          </Button>
        )}
      </div>

      {/* Advanced Filters */}
      {showAdvancedFilters && (
        <div className="bg-slate-50 p-4 rounded-md space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="font-medium">מסננים מתקדמים</h3>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 px-2"
              onClick={() => setShowAdvancedFilters(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Status Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">סטטוס</h4>
              <div className="space-y-2">
                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-first"
                    checked={filters.status?.includes("PENDING_FIRST_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_FIRST_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_FIRST_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-first"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-yellow-600" />
                    ממתין לתשובת צד א׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-second"
                    checked={filters.status?.includes("PENDING_SECOND_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_SECOND_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_SECOND_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-second"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-blue-600" />
                    ממתין לתשובת צד ב׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-approved"
                    checked={
                      filters.status?.includes("FIRST_PARTY_APPROVED") ||
                      filters.status?.includes("SECOND_PARTY_APPROVED")
                    }
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "FIRST_PARTY_APPROVED",
                          "SECOND_PARTY_APPROVED",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) =>
                              s !== "FIRST_PARTY_APPROVED" &&
                              s !== "SECOND_PARTY_APPROVED"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-approved"
                    className="text-sm mr-2 flex items-center"
                  >
                    <CheckCircle className="h-3 w-3 ml-1 text-green-600" />
                    אושר ע״י אחד הצדדים
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-dating"
                    checked={filters.status?.includes("DATING")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [...(filters.status || []), "DATING"];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "DATING"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-dating"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Calendar className="h-3 w-3 ml-1 text-pink-600" />
                    בתהליך היכרות
                  </label>
                </div>
              </div>
            </div>

            {/* User Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">משתתפים</h4>
              <Select
                value={filters.userId || "all"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    userId: value === "all" ? undefined : value,
                  })
                }
              >
                <SelectTrigger>
                  <User className="h-4 w-4 ml-1" />
                  <SelectValue placeholder="בחר משתתף" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">כל המשתתפים</SelectItem>
                  {/* Replace with dynamic user data */}
                  <SelectItem value="user1">ישראל ישראלי</SelectItem>
                  <SelectItem value="user2">שרה כהן</SelectItem>
                  <SelectItem value="user3">דוד לוי</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Sort By */}
            <div>
              <h4 className="text-sm font-medium mb-2">מיון לפי</h4>
              <Select
                value={filters.sortBy || "lastActivity"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    sortBy: value as SortByOption, // Cast to SortByOption
                  })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="מיון לפי" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="lastActivity">פעילות אחרונה</SelectItem>
                  <SelectItem value="createdAt">תאריך יצירה</SelectItem>
                  <SelectItem value="priority">עדיפות</SelectItem>
                  <SelectItem value="decisionDeadline">תאריך יעד</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      )}

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2 flex-wrap">
          {filters.priority && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                עדיפות:{" "}
                {filters.priority[0] === "URGENT"
                  ? "דחוף"
                  : filters.priority[0] === "HIGH"
                  ? "גבוהה"
                  : filters.priority[0] === "MEDIUM"
                  ? "רגילה"
                  : "נמוכה"}
              </span>
              <button
                onClick={() => handleRemoveFilter("priority")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.dateRange && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                תאריך:{" "}
                {new Date(filters.dateRange.start).toLocaleDateString("he-IL")}
                {filters.dateRange.end &&
                  ` - ${new Date(filters.dateRange.end).toLocaleDateString(
                    "he-IL"
                  )}`}
              </span>
              <button
                onClick={() => handleRemoveFilter("dateRange")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.status && filters.status.length > 0 && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                סטטוס:{" "}
                {filters.status.length === 1
                  ? ""
                  : `(${filters.status.length})`}
                {filters.status.length === 1 && (
                  <span className="flex items-center">
                    {getStatusIcon(filters.status[0])}
                    {filters.status[0] === "PENDING_FIRST_PARTY"
                      ? "ממתין לצד א׳"
                      : filters.status[0] === "PENDING_SECOND_PARTY"
                      ? "ממתין לצד ב׳"
                      : filters.status[0]}
                  </span>
                )}
              </span>
              <button
                onClick={() => handleRemoveFilter("status")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.userId && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>משתתף מסוים</span>
              <button
                onClick={() => handleRemoveFilter("userId")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;
--- End of Content for SuggestionActionBar.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  Users,
  CheckCircle,
  Clock,
  Calendar,
  AlertCircle,
  Ban,
  X,
} from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion, SuggestionFilters } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  onClick?: () => void;
  isClickable?: boolean;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
  onFilterChange?: (filter: Partial<SuggestionFilters>) => void;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
  onClick,
  isClickable = false,
}) => (
  <Card
    className={`p-4 ${className} ${
      isClickable ? "cursor-pointer hover:shadow-md transition-shadow" : ""
    }`}
    onClick={onClick}
  >
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value > 0 ? "+" : ""}
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
  onFilterChange,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter((s) => s.category === "ACTIVE").length;
    const pending = suggestions.filter((s) => s.category === "PENDING").length;
    const history = suggestions.filter((s) => s.category === "HISTORY").length;

    const approvedByFirst = suggestions.filter(
      (s) => s.status === "FIRST_PARTY_APPROVED"
    ).length;
    const approvedBySecond = suggestions.filter(
      (s) => s.status === "SECOND_PARTY_APPROVED"
    ).length;
    const declined = suggestions.filter(
      (s) =>
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
    ).length;
    const expired = suggestions.filter((s) => s.status === "EXPIRED").length;
    const dating = suggestions.filter((s) => s.status === "DATING").length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Group suggestions by month
    const monthlyData = suggestions.reduce(
      (acc, s) => {
        const month = new Date(s.createdAt).getMonth();
        const year = new Date(s.createdAt).getFullYear();
        const key = `${year}-${month + 1}`;

        if (!acc[key]) {
          acc[key] = {
            month: new Date(year, month).toLocaleString("he", {
              month: "short",
            }),
            year: year,
            count: 0,
            active: 0,
            pending: 0,
            success: 0,
            declined: 0,
          };
        }

        acc[key].count += 1;

        if (s.category === "ACTIVE") acc[key].active += 1;
        if (s.category === "PENDING") acc[key].pending += 1;
        if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
        if (
          s.status === "FIRST_PARTY_DECLINED" ||
          s.status === "SECOND_PARTY_DECLINED"
        ) {
          acc[key].declined += 1;
        }

        return acc;
      },
      {} as Record<
        string,
        {
          month: string;
          year: number;
          count: number;
          active: number;
          pending: number;
          success: number;
          declined: number;
        }
      >
    );

    // Convert to array and sort by date
    const monthlyArray = Object.values(monthlyData).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      return a.month.localeCompare(b.month);
    });

    // Calculate trends
    const calculateTrend = (currentValue: number, previousValue: number) => {
      if (previousValue === 0) return currentValue > 0 ? 100 : 0;
      return Math.round(((currentValue - previousValue) / previousValue) * 100);
    };

    // Calculate success rate
    const successRate = total > 0 ? Math.round((success / total) * 100) : 0;

    // Get current month stats vs previous month for trend
    let activeTrend = 0;
    let pendingTrend = 0;
    let successTrend = 0;

    if (monthlyArray.length >= 2) {
      const currentMonth = monthlyArray[monthlyArray.length - 1];
      const previousMonth = monthlyArray[monthlyArray.length - 2];

      activeTrend = calculateTrend(currentMonth.active, previousMonth.active);
      pendingTrend = calculateTrend(
        currentMonth.pending,
        previousMonth.pending
      );
      successTrend = calculateTrend(
        currentMonth.success,
        previousMonth.success
      );
    }

    return {
      total,
      active,
      pending,
      history,
      approvedByFirst,
      approvedBySecond,
      declined,
      expired,
      dating,
      success,
      successRate,
      byStatus,
      monthlyData: monthlyArray,
      trends: {
        active: activeTrend,
        pending: pendingTrend,
        success: successTrend,
      },
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() => onFilterChange && onFilterChange({})}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: [
                "DATING",
                "FIRST_PARTY_APPROVED",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            })
          }
        />
        <StatsCard
          icon={Clock}
          title="ממתינות לתגובה"
          value={stats.pending}
          trend={{
            value: stats.trends.pending,
            isPositive: stats.trends.pending >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY"],
            })
          }
        />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${stats.successRate}%`}
          trend={{
            value: stats.trends.success,
            isPositive: stats.trends.success >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING", "ENGAGED", "MARRIED"],
            })
          }
        />
      </div>

      {/* Action Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-3 mt-4">
        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-yellow-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-yellow-600" />
            <div className="text-xs">ממתין לצד א׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_FIRST_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-blue-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_SECOND_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-blue-600" />
            <div className="text-xs">ממתין לצד ב׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_SECOND_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-red-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <X className="w-4 h-4 text-red-600" />
            <div className="text-xs">הצעות שנדחו</div>
            <div className="font-bold ml-auto">{stats.declined}</div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-pink-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Calendar className="w-4 h-4 text-pink-600" />
            <div className="text-xs">בתהליך היכרות</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["DATING"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-gray-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["EXPIRED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Ban className="w-4 h-4 text-gray-600" />
            <div className="text-xs">פג תוקף</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["EXPIRED"] || 0}
            </div>
          </div>
        </Card>
      </div>

      {/* מגמה חודשית נשארת כאן אבל עכשיו היא מוצגת בדיאלוג מודלי */}
      <div className="hidden">
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={stats.monthlyData}
                margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip
                  formatter={(value) => [`${value} הצעות`, ""]}
                  labelFormatter={(label) => `חודש ${label}`}
                />
                <Legend />
                <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
                <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
                <Bar dataKey="success" name="הצלחות" fill="#10B981" />
                <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;
--- End of Content for SuggestionsStats.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx
--------------------------------------------------------------------------------
Content:
// SuggestionDetailsDialog.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ProfileCard } from "@/app/components/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  AlertCircle,
  CheckCircle,
  XCircle,
  MessageCircle,
  Send,
  RefreshCw,
  Edit,
  Calendar,
  Clock,
  Download,
  AlarmClock,
  Trash2,
  MapPin,
  Mail,
  Phone,
  User,
  ExternalLink,
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { MatchSuggestionStatus } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";
import Image from "next/image";

interface DialogActionData extends ActionAdditionalData {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyId?: string;
  type?: string;
  partyType?: "first" | "second" | "both";
}

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  onAction: (action: string, data?: DialogActionData) => void;
}

// Map status to its display info
const getStatusInfo = (status: MatchSuggestionStatus) => {
  const statusMap: Record<
    string,
    { label: string; icon: React.ElementType; color: string }
  > = {
    DRAFT: { label: "טיוטה", icon: Edit, color: "text-gray-600" },
    PENDING_FIRST_PARTY: {
      label: "ממתין לתשובת צד א׳",
      icon: Clock,
      color: "text-yellow-600",
    },
    FIRST_PARTY_APPROVED: {
      label: "צד א׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    FIRST_PARTY_DECLINED: {
      label: "צד א׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    PENDING_SECOND_PARTY: {
      label: "ממתין לתשובת צד ב׳",
      icon: Clock,
      color: "text-blue-600",
    },
    SECOND_PARTY_APPROVED: {
      label: "צד ב׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    SECOND_PARTY_DECLINED: {
      label: "צד ב׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    AWAITING_MATCHMAKER_APPROVAL: {
      label: "ממתין לאישור שדכן",
      icon: AlertCircle,
      color: "text-purple-600",
    },
    CONTACT_DETAILS_SHARED: {
      label: "פרטי קשר שותפו",
      icon: Send,
      color: "text-purple-600",
    },
    AWAITING_FIRST_DATE_FEEDBACK: {
      label: "ממתין למשוב פגישה",
      icon: MessageCircle,
      color: "text-orange-600",
    },
    DATING: {
      label: "בתהליך היכרות",
      icon: Calendar,
      color: "text-pink-600",
    },
    EXPIRED: { label: "פג תוקף", icon: AlarmClock, color: "text-gray-600" },
    CLOSED: { label: "סגור", icon: XCircle, color: "text-gray-600" },
  };
  return (
    statusMap[status] || {
      label: status as string,
      icon: AlertCircle as React.ElementType,
      color: "text-gray-600",
    }
  );
};

// Status groups for the progress indicator
const statusGroups = [
  ["DRAFT", "PENDING_FIRST_PARTY"],
  ["FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY"],
  ["SECOND_PARTY_APPROVED", "AWAITING_MATCHMAKER_APPROVAL"],
  ["CONTACT_DETAILS_SHARED", "AWAITING_FIRST_DATE_FEEDBACK"],
  ["DATING", "ENGAGED", "MARRIED"],
];
// הוספת מיפוי מלא של כל הסטטוסים האפשריים
const getAllStatusLabels = () => {
  // יצירת מיפוי של כל הסטטוסים האפשריים לפי הסכמה
  const statusLabels: Record<MatchSuggestionStatus, string> = {
    DRAFT: "טיוטה",
    PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
    FIRST_PARTY_APPROVED: "צד א׳ אישר",
    FIRST_PARTY_DECLINED: "צד א׳ דחה",
    PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
    SECOND_PARTY_APPROVED: "צד ב׳ אישר",
    SECOND_PARTY_DECLINED: "צד ב׳ דחה",
    AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
    CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
    AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
    THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
    PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
    ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
    MEETING_PENDING: "ממתין לקביעת פגישה",
    MEETING_SCHEDULED: "פגישה נקבעה",
    MATCH_APPROVED: "ההצעה אושרה",
    MATCH_DECLINED: "ההצעה נדחתה",
    DATING: "בתהליך היכרות",
    ENGAGED: "מאורסים",
    MARRIED: "נישאו",
    EXPIRED: "פג תוקף",
    CLOSED: "סגור",
    CANCELLED: "בוטל",
  };

  return statusLabels;
};
// Helper to determine if a status change is possible
const canChangeStatus = (
  currentStatus: MatchSuggestionStatus
): MatchSuggestionStatus[] => {
  // Status changes that are allowed directly by the matchmaker
  const allowedChanges: Partial<
    Record<MatchSuggestionStatus, MatchSuggestionStatus[]>
  > = {
    // סטטוסים קיימים
    DRAFT: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_FIRST_PARTY: [
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    FIRST_PARTY_APPROVED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    FIRST_PARTY_DECLINED: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_SECOND_PARTY: [
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    SECOND_PARTY_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    SECOND_PARTY_DECLINED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    CONTACT_DETAILS_SHARED: [
      "AWAITING_FIRST_DATE_FEEDBACK",
      "DATING",
      "CANCELLED",
      "CLOSED",
    ],
    AWAITING_FIRST_DATE_FEEDBACK: ["DATING", "CANCELLED", "CLOSED"],
    DATING: ["ENGAGED", "CLOSED"],
    ENGAGED: ["MARRIED", "CLOSED"],
    MARRIED: ["CLOSED"],
    EXPIRED: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY", "CLOSED"],
    CANCELLED: ["DRAFT"],
    CLOSED: [],

    // הוספת הסטטוסים החסרים
    AWAITING_MATCHMAKER_APPROVAL: [
      "CONTACT_DETAILS_SHARED",
      "CANCELLED",
      "CLOSED",
    ],
    THINKING_AFTER_DATE: [
      "PROCEEDING_TO_SECOND_DATE",
      "ENDED_AFTER_FIRST_DATE",
      "CLOSED",
    ],
    PROCEEDING_TO_SECOND_DATE: ["DATING", "CLOSED"],
    ENDED_AFTER_FIRST_DATE: ["CLOSED"],
    MEETING_PENDING: ["MEETING_SCHEDULED", "CANCELLED", "CLOSED"],
    MEETING_SCHEDULED: ["AWAITING_FIRST_DATE_FEEDBACK", "CANCELLED", "CLOSED"],
    MATCH_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    MATCH_DECLINED: ["CLOSED"],
  };

  return allowedChanges[currentStatus] || [];
};

const formatDateSafely = (
  dateInput: Date | string | null | undefined
): string => {
  if (!dateInput) return "לא נקבע";

  // Ensure we're working with a Date object
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;

  // Validate that the date is valid before formatting
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    return "תאריך לא תקין";
  }

  return new Intl.DateTimeFormat("he-IL", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(date);
};

const getDaysRemaining = (
  deadline: Date | string | null | undefined
): number | null => {
  if (!deadline) return null;

  // Convert string to Date if needed
  const deadlineDate =
    typeof deadline === "string" ? new Date(deadline) : deadline;

  // Validate date
  if (!(deadlineDate instanceof Date) || isNaN(deadlineDate.getTime())) {
    return null;
  }

  const today = new Date();
  const diffTime = deadlineDate.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
};

// Get the status group index for progress indicator
const getStatusGroupIndex = (status: MatchSuggestionStatus): number => {
  for (let i = 0; i < statusGroups.length; i++) {
    if (statusGroups[i].includes(status)) {
      return i;
    }
  }
  return -1;
};

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [statusChangeNote, setStatusChangeNote] = useState("");
  const [newStatus, setNewStatus] = useState<MatchSuggestionStatus | null>(
    null
  );
  const [showStatusChange, setShowStatusChange] = useState(false);

  // Calculate allowed status changes based on current status
  const allowedStatusChanges = suggestion
    ? canChangeStatus(suggestion.status as MatchSuggestionStatus)
    : [];

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  // Handle status change
  const handleStatusChange = async () => {
    if (!newStatus || !suggestion) return;

    setIsLoading(true);
    try {
      console.log(
        `שולח בקשה לשינוי סטטוס: ${newStatus} עם הערות: ${
          statusChangeNote || "ללא הערות"
        }`
      );
      // עדכון הקומפוננטה ההורה
      onAction("changeStatus", {
        suggestionId: suggestion.id,
        newStatus,
        notes: statusChangeNote,
      });

      // איפוס מצב הטופס
      setShowStatusChange(false);
      setStatusChangeNote("");
      setNewStatus(null);
    } catch (error) {
      console.error("Error changing status:", error);
      toast.error(
        `שגיאה בעדכון הסטטוס: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  };

  if (!suggestion) return null;

  // Get status display info
  const statusInfo = getStatusInfo(suggestion.status as MatchSuggestionStatus);
  const StatusIcon = statusInfo.icon;

  // Format suggestion dates
  const createdDate = suggestion.createdAt;
  const lastActivityDate = suggestion.lastActivity;
  const decisionDeadlineDate = suggestion.decisionDeadline
    ? suggestion.decisionDeadline
    : null;

  // Days remaining for decision if applicable
  const daysRemaining = decisionDeadlineDate
    ? getDaysRemaining(decisionDeadlineDate)
    : null;

  // Get status progress index for the progress indicator
  const statusGroupIndex = getStatusGroupIndex(
    suggestion.status as MatchSuggestionStatus
  );

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="max-w-6xl max-h-[90vh] flex flex-col p-0"
        style={{ direction: "rtl" }}
      >
        {/* Header with Progress Bar */}
        <div className="bg-gradient-to-r from-slate-50 to-white border-b flex-shrink-0">
          <DialogHeader className="p-6 pb-3">
            <div className="flex items-center justify-between">
              <div>
                <DialogTitle className="text-2xl font-bold">
                  הצעת שידוך #{suggestion.id.toString().split("-")[0]}
                </DialogTitle>
                <DialogDescription className="text-lg mt-1">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} ו
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName}
                </DialogDescription>
              </div>
              <div className="flex items-center gap-3">
                <Badge
                  className={`px-3 py-1.5 ${statusInfo.color} flex items-center gap-1 text-sm shadow-sm`}
                >
                  <StatusIcon className="w-4 h-4" />
                  {statusInfo.label}
                </Badge>
                <Badge
                  variant="outline"
                  className={`px-3 shadow-sm ${
                    suggestion.priority === "URGENT"
                      ? "bg-red-50 text-red-600 border-red-200"
                      : suggestion.priority === "HIGH"
                      ? "bg-orange-50 text-orange-600 border-orange-200"
                      : suggestion.priority === "MEDIUM"
                      ? "bg-blue-50 text-blue-600 border-blue-200"
                      : "bg-gray-50 text-gray-600 border-gray-200"
                  }`}
                >
                  {suggestion.priority === "URGENT"
                    ? "דחוף"
                    : suggestion.priority === "HIGH"
                    ? "עדיפות גבוהה"
                    : suggestion.priority === "MEDIUM"
                    ? "עדיפות רגילה"
                    : "עדיפות נמוכה"}
                </Badge>
              </div>
            </div>
          </DialogHeader>

          {/* Status Progress Indicator */}
          <div className="px-6 pb-4">
            <div className="relative flex items-center justify-between w-full h-3 bg-gray-100 rounded-full mt-4">
              {statusGroupIndex >= 0 && (
                <div
                  className="absolute h-3 bg-gradient-to-r from-blue-400 to-blue-600 rounded-full"
                  style={{
                    width: `${Math.min(
                      ((statusGroupIndex + 1) / statusGroups.length) * 100,
                      100
                    )}%`,
                  }}
                ></div>
              )}
              {statusGroups.map((_, index) => (
                <div
                  key={index}
                  className={`relative z-10 w-6 h-6 rounded-full flex items-center justify-center border-2 ${
                    index <= statusGroupIndex
                      ? "bg-blue-600 border-blue-700 text-white"
                      : "bg-white border-gray-300"
                  }`}
                >
                  {index + 1}
                </div>
              ))}
            </div>
            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
              <span>יצירת הצעה</span>
              <span>אישור ראשוני</span>
              <span>אישור סופי</span>
              <span>שיתוף פרטים</span>
              <span>בתהליך היכרות</span>
            </div>
          </div>
        </div>
        {/* Main Content Area */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex-1 flex flex-col overflow-hidden"
        >
          <TabsList className="px-6 pt-2 border-b justify-end gap-1 flex-shrink-0">
            <TabsTrigger
              value="overview"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              סקירה כללית
            </TabsTrigger>
            <TabsTrigger
              value="firstParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד ראשון
            </TabsTrigger>
            <TabsTrigger
              value="secondParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד שני
            </TabsTrigger>
            <TabsTrigger
              value="timeline"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              ציר זמן
            </TabsTrigger>
            <TabsTrigger
              value="communication"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              תקשורת
            </TabsTrigger>
            <TabsTrigger
              value="actions"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              פעולות
            </TabsTrigger>
          </TabsList>

          <div className="flex-1 overflow-y-auto">
            {/* Overview Tab */}

            <TabsContent
              value="overview"
              className="p-0 m-0 h-full overflow-auto"
            >
              <div className="p-6">
                {/* שינוי 1: שינוי המבנה כך שפרטי ההצעה יהיו בחלק העליון ושני הצדדים יהיו זה לצד זה */}
                <div className="space-y-3">
                  {/* פרטי הצעה - עיצוב מסודר וקומפקטי */}
                  <div className="bg-white rounded-xl shadow-sm border p-4 mb-3 hover:shadow-md transition-shadow">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="text-md font-semibold flex items-center">
                        <Calendar className="w-4 h-4 ml-1 text-blue-600" />
                        פרטי הצעה
                      </h3>
                      <Badge
                        className={`${statusInfo.color} px-2 py-0.5 text-xs`}
                      >
                        <StatusIcon className="w-3 h-3 ml-1" />
                        {statusInfo.label}
                      </Badge>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">תאריך יצירה:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(createdDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">עדכון אחרון:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(lastActivityDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">שדכן:</span>
                        <span className="font-medium mr-1">
                          {`${suggestion.matchmaker?.firstName} ${suggestion.matchmaker?.lastName}`}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">דחיפות:</span>
                        <span
                          className={`font-medium mr-1 ${
                            suggestion.priority === "URGENT"
                              ? "text-red-600"
                              : suggestion.priority === "HIGH"
                              ? "text-orange-600"
                              : suggestion.priority === "MEDIUM"
                              ? "text-blue-600"
                              : "text-gray-600"
                          }`}
                        >
                          {suggestion.priority === "URGENT"
                            ? "דחוף"
                            : suggestion.priority === "HIGH"
                            ? "עדיפות גבוהה"
                            : suggestion.priority === "MEDIUM"
                            ? "עדיפות רגילה"
                            : "עדיפות נמוכה"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד תגובה:</span>
                        <span className="font-medium mr-1">
                          {suggestion.responseDeadline
                            ? formatDateSafely(suggestion.responseDeadline)
                            : "לא נקבע"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד להחלטה:</span>
                        <span
                          className={
                            daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED"
                              ? "text-red-600 font-medium"
                              : "font-medium"
                          }
                        >
                          {decisionDeadlineDate
                            ? formatDateSafely(decisionDeadlineDate)
                            : "לא נקבע"}
                          {daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED" && (
                              <span className="mr-1 text-red-600 text-xs">
                                (
                                {daysRemaining === 0
                                  ? "היום!"
                                  : `נותרו ${daysRemaining} ימים`}
                                )
                              </span>
                            )}
                        </span>
                      </div>
                    </div>

                    <div className="flex justify-end mt-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowStatusChange(true)}
                        disabled={allowedStatusChanges.length === 0}
                        className="text-blue-600 border-blue-200 hover:bg-blue-50 text-xs py-1 h-7"
                      >
                        <RefreshCw className="w-3 h-3 ml-1" />
                        שנה סטטוס
                      </Button>
                    </div>
                  </div>

                  {/* שינוי 2: כרטיסי הצדדים מסודרים זה לצד זה בגריד עם 2 עמודות */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* First Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-blue-800">
                        <User className="w-5 h-5 ml-2 text-blue-600" />
                        צד א׳: {suggestion.firstParty.firstName}{" "}
                        {suggestion.firstParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.firstParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-blue-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.firstParty.firstName}{" "}
                            {suggestion.firstParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.firstPartySent
                              ? formatDateSafely(suggestion.firstPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "FIRST_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "FIRST_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_FIRST_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "FIRST_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "FIRST_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_FIRST_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.firstPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-blue-50 rounded-lg p-3 text-sm border border-blue-100">
                            {suggestion.firstPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-blue-200 hover:bg-blue-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_FIRST_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-yellow-500 hover:bg-yellow-600"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.firstParty.id,
                                partyType: "first",
                              })
                            }
                          >
                            <AlertCircle className="w-4 h-4 ml-2" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>

                    {/* Second Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-purple-800">
                        <User className="w-5 h-5 ml-2 text-purple-600" />
                        צד ב׳: {suggestion.secondParty.firstName}{" "}
                        {suggestion.secondParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.secondParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-purple-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.secondParty.firstName}{" "}
                            {suggestion.secondParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.secondPartySent
                              ? formatDateSafely(suggestion.secondPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "SECOND_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "SECOND_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_SECOND_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "SECOND_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "SECOND_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_SECOND_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.secondPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-purple-50 rounded-lg p-3 text-sm border border-purple-100">
                            {suggestion.secondPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-purple-200 hover:bg-purple-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_SECOND_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-purple-600 hover:bg-purple-700"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.secondParty.id,
                                partyType: "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* מידע נוסף */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
                    {/* Matching Reason Card */}
                    {suggestion.matchingReason && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <User className="w-5 h-5 ml-2 text-green-600" />
                          סיבת ההתאמה
                        </h3>
                        <div className="bg-green-50 rounded-lg border border-green-100 p-4 text-gray-700">
                          {suggestion.matchingReason}
                        </div>
                      </div>
                    )}

                    {/* Internal Notes */}
                    {suggestion.internalNotes && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <AlertCircle className="w-5 h-5 ml-2 text-amber-600" />
                          הערות פנימיות
                        </h3>
                        <div className="bg-amber-50 rounded-lg border border-amber-100 p-4 text-gray-700">
                          {suggestion.internalNotes}
                        </div>
                      </div>
                    )}

                    {/* Quick Actions */}
                    <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center">
                        <RefreshCw className="w-5 h-5 ml-2 text-gray-600" />
                        פעולות מהירות
                      </h3>

                      <div className="grid grid-cols-2 gap-2">
                        <Button
                          variant="outline"
                          className="justify-start"
                          onClick={() =>
                            onAction("edit", { suggestionId: suggestion.id })
                          }
                        >
                          <Edit className="w-4 h-4 ml-1" />
                          ערוך הצעה
                        </Button>

                        {(suggestion.status === "PENDING_FIRST_PARTY" ||
                          suggestion.status === "PENDING_SECOND_PARTY") && (
                          <Button
                            variant="outline"
                            className="justify-start"
                            onClick={() =>
                              onAction("sendReminder", {
                                suggestionId: suggestion.id,
                                type:
                                  suggestion.status === "PENDING_FIRST_PARTY"
                                    ? "first"
                                    : "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}

                        {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                          suggestion.status === "SECOND_PARTY_APPROVED") && (
                          <Button
                            variant="default"
                            className="justify-start bg-green-600 hover:bg-green-700"
                            onClick={() =>
                              onAction("shareContacts", {
                                suggestionId: suggestion.id,
                              })
                            }
                          >
                            <ExternalLink className="w-4 h-4 ml-1" />
                            שתף פרטי קשר
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* First Party Tab */}
            <TabsContent value="firstParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-blue-800">
                      {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-blue-100 text-blue-700 border-blue-200">
                      צד א׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.firstParty.images.find((img) => img.isMain)
                            ?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-blue-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty?.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.birthDate
                              ? new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-blue-200 hover:bg-blue-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.firstParty.id,
                          partyType: "first",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_FIRST_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד ראשון
                      </Button>
                    )}

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד שני
                      </Button>
                    )}

                    {suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyType: "both",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח בקשת עדכון מפגש
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.firstParty.profile}
                  images={suggestion.firstParty.images}
                  questionnaire={firstPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-blue-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.firstParty.firstName}
                  </h3>
                  {suggestion.firstPartyNotes ? (
                    <p>{suggestion.firstPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Second Party Tab */}
            <TabsContent value="secondParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-purple-800">
                      {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-purple-100 text-purple-700 border-purple-200">
                      צד ב׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.secondParty.images.find(
                            (img) => img.isMain
                          )?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-purple-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.birthDate
                              ? new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-purple-200 hover:bg-purple-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.secondParty.id,
                          partyType: "second",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="flex-1 bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-1" />
                        שלח תזכורת
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.secondParty.profile}
                  images={suggestion.secondParty.images}
                  questionnaire={secondPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-purple-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.secondParty.firstName}
                  </h3>
                  {suggestion.secondPartyNotes ? (
                    <p>{suggestion.secondPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Timeline Tab */}
            <TabsContent value="timeline" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 mb-4">
                  <h3 className="text-lg font-semibold flex items-center">
                    <Calendar className="w-5 h-5 ml-2 text-blue-600" />
                    התקדמות ההצעה
                  </h3>
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="p-2 rounded-full bg-blue-100 mr-2">
                        <Clock className="w-5 h-5 text-blue-600" />
                      </div>
                      <div>
                        <div className="font-medium">
                          נוצר: {formatDateSafely(suggestion.createdAt)}
                        </div>
                        <div className="text-sm text-gray-500">
                          פעילות אחרונה:{" "}
                          {formatDateSafely(suggestion.lastActivity)}
                        </div>
                      </div>
                    </div>
                    <Badge
                      className={`px-3 py-1.5 flex items-center gap-1 ${statusInfo.color}`}
                    >
                      <StatusIcon className="w-4 h-4" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border p-5">
                  <h3 className="text-lg font-semibold mb-4">
                    היסטוריית סטטוסים
                  </h3>

                  <ScrollArea className="h-[400px] pr-4">
                    {isLoading ? (
                      <div className="flex items-center justify-center h-32">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-700"></div>
                      </div>
                    ) : (
                      <Timeline
                        items={(suggestion?.statusHistory || []).map(
                          (history) => ({
                            title: getStatusInfo(
                              history.status as MatchSuggestionStatus
                            ).label,
                            description: history.notes || "אין הערות",
                            date:
                              typeof history.createdAt === "string"
                                ? new Date(history.createdAt)
                                : history.createdAt,
                            icon: history.status.includes("APPROVED")
                              ? CheckCircle
                              : history.status.includes("DECLINED")
                              ? XCircle
                              : history.status.includes("PENDING")
                              ? Clock
                              : AlertCircle,
                            iconColor: history.status.includes("APPROVED")
                              ? "text-green-600"
                              : history.status.includes("DECLINED")
                              ? "text-red-600"
                              : history.status.includes("PENDING")
                              ? "text-yellow-600"
                              : "text-blue-600",
                          })
                        )}
                      />
                    )}
                  </ScrollArea>

                  <div className="mt-4 flex justify-end">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() =>
                        onAction("exportHistory", {
                          suggestionId: suggestion.id,
                        })
                      }
                    >
                      <Download className="w-4 h-4 ml-1" />
                      ייצא היסטוריה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* Communication Tab */}
            <TabsContent value="communication" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-blue-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">תקשורת</h3>
                  <p className="text-gray-600">
                    ניהול התקשורת עם הצדדים השונים בהצעה. שליחת הודעות ותזכורות.
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* First Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-blue-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-blue-600" />
                      תקשורת עם {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full justify-start border-blue-200 hover:bg-blue-50"
                        onClick={() =>
                          onAction("message", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <MessageCircle className="w-4 h-4 ml-2" />
                        שלח הודעה
                      </Button>

                      {suggestion.status === "PENDING_FIRST_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>

                  {/* Second Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-purple-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-purple-600" />
                      תקשורת עם {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full"
                        onClick={() =>
                          onAction("edit", {
                            suggestionId: suggestion.id,
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <Edit className="w-4 h-4 ml-2" />
                        ערוך פרטי הצעה
                      </Button>

                      {suggestion.status === "PENDING_SECOND_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {/* Meeting Arrangement Section */}
                {(suggestion.status === "CONTACT_DETAILS_SHARED" ||
                  suggestion.status === "DATING") && (
                  <div className="mt-6 bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Calendar className="w-5 h-5 ml-2 text-pink-600" />
                      תיאום פגישה
                    </h4>
                    <div className="space-y-3">
                      <p className="text-gray-600">
                        סיוע בתיאום פגישה בין הצדדים ותיעוד מועדי הפגישות
                      </p>
                      <div className="flex gap-2">
                        <Button
                          className="flex-1 bg-pink-600 hover:bg-pink-700"
                          onClick={() =>
                            onAction("scheduleMeeting", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Calendar className="w-4 h-4 ml-2" />
                          תאם פגישה חדשה
                        </Button>
                        <Button
                          variant="outline"
                          className="flex-1"
                          onClick={() =>
                            onAction("viewMeetings", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Clock className="w-4 h-4 ml-2" />
                          צפה בפגישות קודמות
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </TabsContent>

            {/* Actions Tab */}
            <TabsContent value="actions" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-gray-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">פעולות נוספות</h3>
                  <p className="text-gray-600">
                    פעולות נוספות שניתן לבצע על הצעת השידוך
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {/* Status Change */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-blue-100 w-fit mb-3">
                      <RefreshCw className="w-6 h-6 text-blue-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">שינוי סטטוס</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עדכון סטטוס ההצעה בהתאם להתקדמות התהליך
                    </p>
                    <Button
                      className="w-full"
                      onClick={() => setShowStatusChange(true)}
                      disabled={allowedStatusChanges.length === 0}
                    >
                      <RefreshCw className="w-4 h-4 ml-2" />
                      שנה סטטוס
                    </Button>
                  </div>

                  {/* Edit Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-amber-100 w-fit mb-3">
                      <Edit className="w-6 h-6 text-amber-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">עריכת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עריכת פרטי ההצעה, סיבת ההתאמה והערות
                    </p>
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() =>
                        onAction("edit", { suggestionId: suggestion.id })
                      }
                    >
                      <Edit className="w-4 h-4 ml-2" />
                      ערוך פרטי הצעה
                    </Button>
                  </div>

                  {/* Delete Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-red-100 w-fit mb-3">
                      <Trash2 className="w-6 h-6 text-red-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">מחיקת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      מחיקת ההצעה לצמיתות מהמערכת
                    </p>
                    <Button
                      variant="outline"
                      className="border-red-200 hover:bg-red-50 text-red-600"
                      onClick={() =>
                        onAction("delete", { suggestionId: suggestion.id })
                      }
                    >
                      <Trash2 className="w-4 h-4 ml-1" />
                      מחק הצעה
                    </Button>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Resend to Both Parties */}
                  {canChangeStatus(
                    suggestion.status as MatchSuggestionStatus
                  ).includes("PENDING_FIRST_PARTY") && (
                    <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                      <h4 className="text-lg font-semibold mb-3 flex items-center">
                        <Send className="w-5 h-5 ml-2 text-purple-600" />
                        שליחה מחדש
                      </h4>
                      <p className="text-sm text-gray-600 mb-3">
                        שליחת ההצעה מחדש לשני הצדדים
                      </p>
                      <Button
                        className="w-full bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("resendToAll", {
                            suggestionId: suggestion.id,
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-2" />
                        שלח מחדש לשני הצדדים
                      </Button>
                    </div>
                  )}

                  {/* Export Suggestion Details */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Download className="w-5 h-5 ml-2 text-green-600" />
                      ייצוא פרטי הצעה
                    </h4>
                    <p className="text-sm text-gray-600 mb-3">
                      ייצוא כל פרטי ההצעה בפורמט PDF או CSV
                    </p>
                    <Button
                      variant="outline"
                      className="w-full border-green-200 hover:bg-green-50 text-green-700"
                      onClick={() =>
                        onAction("export", { suggestionId: suggestion.id })
                      }
                    >
                      <Download className="w-4 h-4 ml-2" />
                      ייצא פרטי הצעה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>
          </div>
        </Tabs>
        {/* Status Change Dialog */}
        {showStatusChange && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-xl max-w-md w-full shadow-lg">
              <h3 className="text-xl font-bold mb-4 flex items-center">
                <RefreshCw className="w-5 h-5 ml-2 text-blue-600" />
                שינוי סטטוס הצעה
              </h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס נוכחי
                  </label>
                  <div className="flex items-center p-2 bg-gray-50 rounded border">
                    <StatusIcon
                      className={`w-5 h-5 ml-2 ${statusInfo.color}`}
                    />
                    <span className="font-medium">{statusInfo.label}</span>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס חדש
                  </label>
                  <Select
                    value={newStatus || undefined}
                    onValueChange={(value) => {
                      console.log("Selected new status:", value);
                      setNewStatus(value as MatchSuggestionStatus);
                    }}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="בחר/י סטטוס חדש" />
                    </SelectTrigger>
                    <SelectContent className="max-h-80 overflow-y-auto">
                      {/* מציג את כל הסטטוסים האפשריים במערכת */}
                      {Object.entries(getAllStatusLabels()).map(
                        ([status, label]) => (
                          <SelectItem key={status} value={status}>
                            {label}
                          </SelectItem>
                        )
                      )}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    הערות לשינוי סטטוס
                  </label>
                  <Textarea
                    value={statusChangeNote}
                    onChange={(e) => setStatusChangeNote(e.target.value)}
                    placeholder="הערות אופציונליות לשינוי הסטטוס..."
                    className="min-h-[100px] resize-none"
                  />
                </div>

                <div className="flex justify-end gap-2 pt-2">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowStatusChange(false);
                      setNewStatus(null);
                      setStatusChangeNote("");
                    }}
                  >
                    ביטול
                  </Button>
                  <Button
                    onClick={handleStatusChange}
                    disabled={!newStatus || isLoading}
                    className="bg-blue-600 hover:bg-blue-700"
                  >
                    {isLoading ? (
                      <>
                        <div className="h-4 w-4 ml-2 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                        מעדכן...
                      </>
                    ) : (
                      "שמור שינוי"
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}
        <DialogFooter className="px-6 py-4 border-t bg-gray-50">
          <div className="flex justify-between w-full">
            <Button
              variant="outline"
              className="border-red-200 hover:bg-red-50 text-red-600"
              onClick={() =>
                onAction("delete", { suggestionId: suggestion.id })
              }
            >
              <Trash2 className="w-4 h-4 ml-1" />
              מחק הצעה
            </Button>

            <div className="flex gap-2">
              <Button variant="outline" onClick={onClose}>
                סגור
              </Button>
              <Button
                // תיקון: המקום השלישי בו צריך לוודא שהפונקציה מופעלת נכון
                onClick={() => setShowStatusChange(true)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <RefreshCw className="w-4 h-4 ml-1" />
                עדכן סטטוס
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;
--- End of Content for SuggestionDetailsDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks\useMatchmaking.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS } from '../../new/constants/matchingCriteria';
import type { User } from '@/types/next-auth';
// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: User[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: User;
  candidateB: User;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: User;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile?.gender === candidateB.profile?.gender ||
          candidateA.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA.profile, candidateB.profile);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;
--- End of Content for useMatchmaking.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Users } from "lucide-react";

import type { Suggestion, SuggestionFilters } from "@/types/suggestions";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: SuggestionFilters;
  searchQuery: string;
  type: "active" | "pending" | "history";
  onSuggestionDeleted?: (id: string) => void;
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
  onSuggestionDeleted,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [, setShowDeleteDialog] = useState(false);
  const [suggestionToDelete, setSuggestionToDelete] = useState<string | null>(
    null
  );

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Priority filter
      if (
        filters.priority?.length &&
        !filters.priority.includes(suggestion.priority)
      ) {
        return false;
      }

      // Date range filter
      if (filters.dateRange) {
        const createdAt = new Date(suggestion.createdAt);
        if (
          createdAt < filters.dateRange.start ||
          createdAt > filters.dateRange.end
        ) {
          return false;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const confirmDelete = async () => {
    if (!suggestionToDelete) return;

    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionToDelete}/delete`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to delete suggestion");
      }

      toast.success("ההצעה נמחקה בהצלחה");
      if (onSuggestionDeleted) {
        onSuggestionDeleted(suggestionToDelete);
      }
    } catch (error) {
      console.error("Error deleting suggestion:", error);
      toast.error("שגיאה במחיקת ההצעה");
    } finally {
      setShowDeleteDialog(false);
      setSuggestionToDelete(null);
    }
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                {/* Rest of the JSX remains the same */}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />

      <AlertDialog>
        {" "}
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
            <AlertDialogDescription>
              פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              מחיקה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default ManagerSuggestionsList;
--- End of Content for ManagerSuggestionsList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useMemo } from "react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Search, Filter, SortDesc } from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";
import SuggestionCard from "../cards/SuggestionCard";
import { LoadingContainer } from "../../new/shared/LoadingStates";
import type {
  Suggestion,
  ActionAdditionalData,
  SuggestionStatusHistory,
} from "@/types/suggestions";

interface PartyInfo {
  id: string;
  firstName: string;
  lastName: string;
  profile: UserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: SuggestionStatusHistory[]; // הוספת השדה החסר
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  isLoading?: boolean;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const SORT_OPTIONS = [
  { value: "latest", label: "החדשים ביותר" },
  { value: "oldest", label: "הישנים ביותר" },
  { value: "deadline", label: "לפי תאריך יעד" },
  { value: "priority", label: "לפי דחיפות" },
];

const STATUS_OPTIONS = [
  { value: "PENDING_FIRST_PARTY", label: "ממתין לצד א׳" },
  { value: "PENDING_SECOND_PARTY", label: "ממתין לצד ב׳" },
  { value: "FIRST_PARTY_APPROVED", label: "צד א׳ אישר" },
  { value: "SECOND_PARTY_APPROVED", label: "צד ב׳ אישר" },
  { value: "CONTACT_DETAILS_SHARED", label: "פרטי קשר שותפו" },
  { value: "DATING", label: "בתהליך היכרות" },
];

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions,
  isLoading = false,
  onAction,
  className,
}) => {
  // Filters state
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState("latest");
  const [statusFilter, setStatusFilter] = useState<string[]>([]);
  const [showFilters, setShowFilters] = useState(false);

  // Filter and sort suggestions
  const filteredSuggestions = useMemo(() => {
    let result = [...suggestions];

    // Apply status filter
    if (statusFilter.length > 0) {
      result = result.filter((s) => statusFilter.includes(s.status));
    }

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (s) =>
          s.firstParty.firstName.toLowerCase().includes(query) ||
          s.firstParty.lastName.toLowerCase().includes(query) ||
          s.secondParty.firstName.toLowerCase().includes(query) ||
          s.secondParty.lastName.toLowerCase().includes(query) ||
          s.firstParty.profile.city?.toLowerCase().includes(query) ||
          s.secondParty.profile.city?.toLowerCase().includes(query)
      );
    }

    // Apply sorting
    switch (sortBy) {
      case "latest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
        );
        break;
    }

    return result;
  }, [suggestions, searchQuery, sortBy, statusFilter]);

  return (
    <div className={className}>
      {/* Filters Bar */}
      <div className="mb-6 space-y-4">
        <div className="flex gap-4">
          <div className="relative flex-1">
            <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
            <Input
              placeholder="חיפוש לפי שם או עיר..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 text-right"
            />
          </div>

          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-48">
              <SortDesc className="w-4 h-4 ml-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {SORT_OPTIONS.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Button
            variant="outline"
            onClick={() => setShowFilters(!showFilters)}
          >
            <Filter className="w-4 h-4 ml-2" />
            סינון
          </Button>
        </div>

        {showFilters && (
          <div className="flex gap-4">
            {STATUS_OPTIONS.map((status) => (
              <Button
                key={status.value}
                variant={
                  statusFilter.includes(status.value) ? "default" : "outline"
                }
                onClick={() => {
                  setStatusFilter((prev) =>
                    prev.includes(status.value)
                      ? prev.filter((s) => s !== status.value)
                      : [...prev, status.value]
                  );
                }}
                className="text-sm"
              >
                {status.label}
              </Button>
            ))}
          </div>
        )}
      </div>

      {/* Suggestions Grid */}
      {isLoading ? (
        <LoadingContainer>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <div
                key={i}
                className="h-64 bg-gray-100 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </LoadingContainer>
      ) : (
        // בערך בשורה 196 - שנה את הגריד להצגה מימין לשמאל
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
          {filteredSuggestions.map((suggestion) => (
            <SuggestionCard
              key={suggestion.id}
              suggestion={suggestion as unknown as Suggestion}
              onAction={onAction}
              className="rtl" // הוסף מחלקה זו
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default SuggestionsList;
--- End of Content for SuggestionsList.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\NotificationService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/NotificationService.ts

import { MatchSuggestionStatus } from '@prisma/client';
import { SuggestionWithParties } from '../suggestions/StatusTransitionService';

export type RecipientInfo = {
  email: string;
  phone?: string; // Phone number with international prefix, e.g.: +972501234567
  name: string;
};

export type NotificationContent = {
  subject: string;
  body: string;
  htmlBody?: string; // HTML version for email
};

export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
  channels: NotificationChannel[];
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
  priority?: 'high' | 'normal' | 'low';
  attachments?: Array<{
    filename: string;
    content: Buffer | string;
    contentType: string;
  }>;
  customMessage?: string;
  metadata?: Record<string, unknown>;
};

export interface NotificationAdapter {
  canSendTo(recipient: RecipientInfo): boolean;
  send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean>;
  getChannelType(): NotificationChannel;
}

export class NotificationService {
  private static instance: NotificationService;
  private adapters: Map<NotificationChannel, NotificationAdapter> = new Map();

  private constructor() {}

  public static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  public registerAdapter(adapter: NotificationAdapter): void {
    this.adapters.set(adapter.getChannelType(), adapter);
    console.log(`Registered ${adapter.getChannelType()} adapter`);
  }

  public async sendNotification(
    recipient: RecipientInfo,
    content: NotificationContent,
    options: NotificationOptions
  ): Promise<Record<NotificationChannel, boolean>> {
    const results: Record<NotificationChannel, boolean> = {} as Record<NotificationChannel, boolean>;
    console.log(`Attempting to send notification to ${recipient.name} via channels:`, options.channels);

    for (const channel of options.channels) {
      const adapter = this.adapters.get(channel);
      if (!adapter) {
        console.warn(`No adapter registered for channel: ${channel}`);
        results[channel] = false;
        continue;
      }

      if (!adapter.canSendTo(recipient)) {
        console.warn(`Cannot send to recipient via ${channel}: missing required info`);
        results[channel] = false;
        continue;
      }

      try {
        console.log(`Sending ${channel} notification to ${recipient.name}`);
        results[channel] = await adapter.send(recipient, content);
        console.log(`${channel} notification sent successfully: ${results[channel]}`);
      } catch (error) {
        console.error(`Error sending notification via ${channel}:`, error);
        results[channel] = false;
      }
    }

    return results;
  }

  // Dedicated method for handling suggestion-related notifications
  public async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
    options: Partial<NotificationOptions> = {}
  ): Promise<void> {
    console.log(`Processing notifications for suggestion ${suggestion.id} with status ${suggestion.status}`);
    
    const templateContent = this.getSuggestionTemplate(suggestion, options.customMessage);
    if (!templateContent) {
      console.log(`No template found for status ${suggestion.status} - skipping notification`);
      return;
    }
  
    const recipientsWithChannels = this.getRecipientsForSuggestion(suggestion);
    console.log(`Found ${recipientsWithChannels.length} potential recipients`);
  
    for (const { recipient, preferredChannels } of recipientsWithChannels) {
      // Filter recipients based on notifyParties if provided
      if (options.notifyParties) {
        const recipientType = this.getRecipientType(recipient, suggestion);
        if (!recipientType || !options.notifyParties.includes(recipientType)) {
          console.log(`Skipping recipient ${recipient.name} (${recipientType}) - not in notifyParties`, options.notifyParties);
          continue;
        }
      }
      
      const channelsToUse = options.channels || preferredChannels || ['email'];
      console.log(`Sending notification to ${recipient.name} via channels:`, channelsToUse);
      
      await this.sendNotification(
        recipient,
        templateContent,
        { ...options, channels: channelsToUse }
      );
    }
    
    console.log(`Finished processing notifications for suggestion ${suggestion.id}`);
  }

  // Helper method to determine recipient type
  private getRecipientType(
    recipient: RecipientInfo, 
    suggestion: SuggestionWithParties
  ): 'first' | 'second' | 'matchmaker' | null {
    if (recipient.email === suggestion.firstParty.email) {
      return 'first';
    } else if (recipient.email === suggestion.secondParty.email) {
      return 'second';
    } else if (recipient.email === suggestion.matchmaker.email) {
      return 'matchmaker';
    }
    return null;
  }

  private getSuggestionTemplate(
    suggestion: SuggestionWithParties,
    customMessage?: string
  ): NotificationContent | null {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    // If there's a custom message, use it instead of the template
    if (customMessage) {
      const reviewUrl = `${baseUrl}/suggestions/${suggestion.id}/review`;
      return {
        subject: "עדכון בהצעת שידוך",
        body: `שלום,\n\n${customMessage}\n\nלצפייה בפרטי ההצעה: ${reviewUrl}\n\nבברכה,\nמערכת השידוכים`,
        htmlBody: `
          <div dir="rtl">
            <h2>שלום,</h2>
            <p>${customMessage}</p>
            <p>לצפייה בפרטי ההצעה: <a href="${reviewUrl}">לחץ כאן</a></p>
            <p>בברכה,<br>מערכת השידוכים</p>
          </div>
        `
      };
    }
    
    // Otherwise use the template based on status
    switch (suggestion.status) {
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.firstParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.firstParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בהצעה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.\n\nההצעה תועבר כעת באופן אוטומטי לצד השני.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.</p><p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.secondParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nהצד הראשון כבר אישר את ההצעה.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.secondParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>הצד הראשון כבר אישר את ההצעה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בפרטי ההצעה ומענה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.\n\nשני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.</p><p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
    
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Prepare contact details with multi-line support
        const firstPartyDetails = this.formatUserDetails(suggestion.firstParty);
        const secondPartyDetails = this.formatUserDetails(suggestion.secondParty);
        
        return {
          subject: 'פרטי קשר להצעת השידוך',
          body: `ברכות! שני הצדדים אישרו את הצעת השידוך.\n\nפרטי הקשר של הצד הראשון:\n${firstPartyDetails}\n\nפרטי הקשר של הצד השני:\n${secondPartyDetails}\n\nאנא צרו קשר בהקדם לתיאום פגישה ראשונה.\n\nבהצלחה!`,
          htmlBody: `<div dir="rtl"><h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2><p>פרטי הקשר של הצד הראשון:</p><pre>${firstPartyDetails}</pre><p>פרטי הקשר של הצד השני:</p><pre>${secondPartyDetails}</pre><p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p><p>בהצלחה!</p></div>`
        };
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return {
          subject: 'בקשה למשוב על הפגישה הראשונה',
          body: `שלום,\n\nנשמח לקבל את המשוב שלך על הפגישה הראשונה.\n\nלשליחת המשוב: ${baseUrl}/suggestions/${suggestion.id}/feedback\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום,</h2><p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/feedback">לשליחת המשוב</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
        return {
          subject: 'בקשת זמן למחשבה לאחר הפגישה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nאחד הצדדים ביקש זמן למחשבה לאחר הפגישה.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.DATING:
        return {
          subject: 'עדכון סטטוס - בתהליך היכרות',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהזוג נמצא בתהליך היכרות.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הזוג נמצא בתהליך היכרות.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.ENGAGED:
        return {
          subject: 'מזל טוב! - אירוסין',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.MARRIED:
        return {
          subject: 'מזל טוב! - חתונה',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.EXPIRED:
        return {
          subject: 'הצעת השידוך פגה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהצעת השידוך פגה עקב חוסר מענה במועד.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הצעת השידוך פגה עקב חוסר מענה במועד.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      default:
        // For other statuses, return null to skip notification
        console.log(`No template defined for status: ${suggestion.status}`);
        return null;
    }
  }

  private getRecipientsForSuggestion(suggestion: SuggestionWithParties): Array<{
    recipient: RecipientInfo;
    preferredChannels: NotificationChannel[];
  }> {
    const recipients: Array<{
      recipient: RecipientInfo;
      preferredChannels: NotificationChannel[];
    }> = [];
    
    // Logic to determine recipients based on suggestion status
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email'] // Email only for drafts
        });
        break;
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.firstParty.email,
            phone: suggestion.firstParty.phone || undefined,
            name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.secondParty.email,
            phone: suggestion.secondParty.phone || undefined,
            name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email']
          }
        );
        break;
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        // Send to both parties
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;
      
      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;

      default:
        // Default: send to matchmaker only
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email']
        });
        break;
    }

    return recipients;
  }

  // Helper function to format contact details
  private formatUserDetails(user: { 
    firstName: string; 
    lastName: string; 
    email: string; 
    phone?: string | null 
  }): string {
    const details = [
      `שם: ${user.firstName} ${user.lastName}`,
      `אימייל: ${user.email}`,
    ];

    if (user.phone) {
      details.push(`טלפון: ${user.phone}`);
    }

    return details.join('\n');
  }
}

export const notificationService = NotificationService.getInstance();
--- End of Content for NotificationService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\initNotifications.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/initNotifications.ts

import { notificationService } from './NotificationService';
import { emailAdapter } from './adapters/EmailAdapter';
import { whatsAppAdapter } from './adapters/WhatsAppAdapter';

// Define notification channel type
export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
    channels: NotificationChannel[];
    notifyParties?: ('first' | 'second' | 'matchmaker')[];
    customMessage?: string;
  };

/**
 * Initializes the notification service by registering all available adapters
 * @returns The initialized notification service
 */
export function initNotificationService() {
  // Register adapters
  notificationService.registerAdapter(emailAdapter);
  notificationService.registerAdapter(whatsAppAdapter);
  
  console.log('Notification service initialized with email and WhatsApp adapters');
  
  return notificationService;
}
--- End of Content for initNotifications.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\EmailAdapter.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/adapters/EmailAdapter.ts

import { NotificationAdapter, NotificationChannel, RecipientInfo, NotificationContent } from '../NotificationService';
import nodemailer from 'nodemailer';

export class EmailAdapter implements NotificationAdapter {
  private static instance: EmailAdapter;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure the transporter exactly like in EmailService
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER || '',
        pass: process.env.GMAIL_APP_PASSWORD || '',
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on initialization
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig(): Promise<void> {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw, to allow the system to continue even if verification fails
    }
  }

  public static getInstance(): EmailAdapter {
    if (!EmailAdapter.instance) {
      EmailAdapter.instance = new EmailAdapter();
    }
    return EmailAdapter.instance;
  }

  public getChannelType(): NotificationChannel {
    return 'email';
  }

  public canSendTo(recipient: RecipientInfo): boolean {
    return !!recipient.email;
  }

  public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
    try {
      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME || 'מערכת השידוכים'} <${process.env.GMAIL_USER || ''}>`,
        to: recipient.email,
        subject: content.subject,
        text: content.body,
        html: content.htmlBody || content.body.replace(/\n/g, '<br>'),
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
        to: recipient.email,
        subject: content.subject
      });

      return true;
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        recipient: recipient.email,
        subject: content.subject
      });
      return false;
    }
  }
}

export const emailAdapter = EmailAdapter.getInstance();
--- End of Content for EmailAdapter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\WhatsAppAdapter.ts
--------------------------------------------------------------------------------
Content:
// lib/WhatsAppAdapter.ts
import {
  NotificationAdapter,
  NotificationChannel,
  RecipientInfo,
  NotificationContent as BaseNotificationContent
} from '../NotificationService'; // Assuming NotificationService.ts exists in the same directory
import twilio from 'twilio';
// Import the specific type for message creation options if available
import { MessageListInstanceCreateOptions } from 'twilio/lib/rest/api/v2010/account/message';

// --- Define an extended NotificationContent interface ---
// This adds the optional adapter-specific data structure
interface NotificationContent extends BaseNotificationContent {
  _adapterSpecificData?: {
      contentSid?: string;
      contentVariables?: string; // Should be a JSON string
      // Add other potential adapter-specific fields here
  };
}
// --- End Interface Extension ---

// --- Type Guard for Twilio-like Errors ---
interface PotentialTwilioError {
  code?: number | string;
  message?: string;
  // Add other potential properties like 'status', 'moreInfo', etc. if needed
}

/**
* Type guard to check if an unknown error object might be a Twilio API error
* by checking for the presence of 'code' or 'message' properties.
* @param error The unknown value caught in a catch block.
* @returns True if the error object has properties common to Twilio errors, false otherwise.
*/
function isPotentialTwilioError(error: unknown): error is PotentialTwilioError {
  // Check if it's a non-null object and has either 'code' or 'message' property
  return typeof error === 'object' && error !== null && ('code' in error || 'message' in error);
}
// --- End Type Guard ---

// --- Helper: Logger (optional but recommended) ---
// Using Record<string, unknown> or object instead of any
const logger = {
info: (message: string, meta?: Record<string, unknown> | object) => {
  console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
warn: (message: string, meta?: Record<string, unknown> | object) => {
  console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
error: (message: string, meta?: Record<string, unknown> | object) => {
  let logMeta = meta || {};
  // If the meta object itself is an Error, extract relevant info
  if (meta instanceof Error) {
      logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
  } else if (isPotentialTwilioError(meta)) {
      // If it's potentially a Twilio error passed directly
      logMeta = { code: meta.code, message: meta.message, ...meta };
  }
  console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', service: 'WhatsAppAdapter', message, ...logMeta }));
},
};
// --- End Logger ---


export class WhatsAppAdapter implements NotificationAdapter {
// Singleton instance
private static instance: WhatsAppAdapter;
// Twilio client instance (typed)
private client: twilio.Twilio | null = null;
// Configured Twilio WhatsApp sender number
private fromNumber: string = '';

/**
 * Private constructor to enforce singleton pattern.
 * Initializes the Twilio client using environment variables.
 */
private constructor() {
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  this.fromNumber = process.env.TWILIO_WHATSAPP_NUMBER || ''; // Get number from env

  // Validate configuration
  if (!accountSid || !authToken || !this.fromNumber) {
    logger.error('Missing Twilio configuration details', {
        hasSid: !!accountSid,
        hasToken: !!authToken,
        hasWhatsAppNumber: !!this.fromNumber,
        detail: "WhatsApp notifications will be unavailable."
    });
    // Do not throw, allow graceful degradation if possible
  } else {
    try {
      // Initialize Twilio client
      this.client = twilio(accountSid, authToken);
      logger.info('Twilio client initialized successfully', { fromWhatsAppNumber: this.fromNumber });
    } catch (error: unknown) { // Catch as unknown
      logger.error('Failed to initialize Twilio client during constructor', { error });
      this.client = null; // Ensure client is null on initialization failure
    }
  }
}

/**
 * Gets the singleton instance of the WhatsAppAdapter.
 * @returns The WhatsAppAdapter instance.
 */
public static getInstance(): WhatsAppAdapter {
  if (!WhatsAppAdapter.instance) {
    WhatsAppAdapter.instance = new WhatsAppAdapter();
  }
  return WhatsAppAdapter.instance;
}

/**
 * Returns the channel type handled by this adapter.
 * @returns The notification channel type ('whatsapp').
 */
public getChannelType(): NotificationChannel {
  return 'whatsapp';
}

/**
 * Checks if this adapter is capable of sending a notification to the given recipient.
 * Requires a valid phone number, an initialized Twilio client, and a configured 'from' number.
 * @param recipient Information about the recipient.
 * @returns True if the adapter can send, false otherwise.
 */
public canSendTo(recipient: RecipientInfo): boolean {
  const hasValidPhone = !!recipient.phone && recipient.phone.length > 8; // Basic validation
  const isClientReady = this.client !== null;
  const hasFromNumber = this.fromNumber !== '';
  const canSend = hasValidPhone && isClientReady && hasFromNumber;

  if (!canSend) {
      let reason = 'Unknown';
      if (!hasValidPhone) reason = 'Invalid or missing phone number';
      else if (!isClientReady) reason = 'Twilio client not initialized';
      else if (!hasFromNumber) reason = 'Twilio "from" number not configured';
      logger.warn('Cannot send WhatsApp message due to configuration or recipient data', {
          reason: reason,
          recipientPhone: recipient.phone // Log phone for debugging
      });
  }
  return canSend;
}

/**
 * Formats a phone number into E.164 standard without the leading '+'.
 * Required for Twilio's `to` parameter when prefixed with `whatsapp:`.
 * Handles Israeli numbers starting with '0'.
 * Example: 0501234567 -> 972501234567
 * @param phone The phone number string to format.
 * @returns The formatted phone number string.
 */
private formatPhoneNumber(phone: string): string {
  // Remove all non-digit characters
  let cleaned = phone.replace(/\D/g, '');
  // Prepend country code for Israeli numbers if '0' prefix exists
  if (cleaned.startsWith('0')) {
    cleaned = '972' + cleaned.substring(1);
  }
  // Remove leading '+' if present (it's added later in the `whatsapp:` prefix)
  if (cleaned.startsWith('+')) {
    cleaned = cleaned.substring(1);
  }
  return cleaned;
}

/**
 * Sends a notification via WhatsApp using the Twilio API.
 * Prefers using template messages if configured via `_adapterSpecificData`.
 * Falls back to raw text messages otherwise (less reliable for business-initiated messages).
 * @param recipient Information about the recipient.
 * @param content The notification content, potentially including adapter-specific data.
 * @returns A promise that resolves to true if the message was successfully queued by Twilio, false otherwise.
 */
public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
  logger.info('Attempting to send WhatsApp message', {
    recipientPhone: recipient.phone,
    fromNumber: this.fromNumber,
    hasClient: !!this.client,
    contentSid: content._adapterSpecificData?.contentSid,
    hasContentVariables: !!content._adapterSpecificData?.contentVariables,
  });

  // --- Pre-send Checks ---
  if (!this.client) {
    logger.error('Twilio client not initialized. Cannot send WhatsApp message.');
    return false;
  }
  if (!recipient.phone) {
    logger.error('Recipient phone number is missing. Cannot send WhatsApp message.');
    return false;
  }
  if (!this.fromNumber) {
      logger.error('Twilio "from" WhatsApp number is not configured. Cannot send message.');
      return false;
  }
  // --- End Pre-send Checks ---


  try {
    // --- Format Numbers ---
    const toNumberE164 = this.formatPhoneNumber(recipient.phone);
    // Ensure 'from' number has '+' prefix for the whatsapp: schema
    const fromWhatsAppFormatted = `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`;
    // Ensure 'to' number has '+' prefix for the whatsapp: schema
    const toWhatsAppFormatted = `whatsapp:+${toNumberE164}`;

    logger.info(`Formatted numbers for sending via Twilio`, { from: fromWhatsAppFormatted, to: toWhatsAppFormatted });
    // --- End Format Numbers ---


    // --- Prepare Message Payload ---
    let messagePayload: MessageListInstanceCreateOptions;
    const adapterData = content._adapterSpecificData;

    if (adapterData?.contentSid && adapterData?.contentVariables) {
       // **Use Template Messaging**
       logger.info(`Preparing WhatsApp template message`, { contentSid: adapterData.contentSid });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          contentSid: adapterData.contentSid, // The approved template SID
          contentVariables: adapterData.contentVariables, // JSON string of variables {"1": "value1", "2": "value2"}
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    } else {
       // **Use Raw Text Messaging (Fallback)**
       // Note: This might fail if outside the 24-hour customer service window
       // or if WhatsApp/Twilio policies require templates for this type of message.
       const bodyText = content.body || content.subject || 'הודעה ממערכת השידוכים'; // Determine fallback content
       logger.warn(`Preparing raw text WhatsApp message (using fallback, might fail)`, { bodyLength: bodyText.length });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          body: bodyText, // The actual text message content
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    }
    // --- End Prepare Message Payload ---


    // --- Send Message via Twilio API ---
    logger.info("Sending message payload to Twilio API", { payload: messagePayload }); // Be cautious logging full payload in production if sensitive
    const message = await this.client.messages.create(messagePayload);
    // --- End Send Message ---


    // --- Log Success ---
    // The message status here is typically 'queued' or 'sending'. Delivery confirmation is asynchronous.
    logger.info('WhatsApp message request processed successfully by Twilio', {
      messageSid: message.sid,
      status: message.status,
      to: toWhatsAppFormatted,
      from: fromWhatsAppFormatted,
      price: message.price, // Log cost if available
      priceUnit: message.priceUnit,
      errorCode: message.errorCode, // Log if Twilio detected an error immediately
      errorMessage: message.errorMessage,
    });
    // We return true because Twilio accepted the request. Delivery is not guaranteed at this point.
    return true;
    // --- End Log Success ---

  } catch (error: unknown) { // Catch error as unknown
    // --- Handle Errors ---
    let errorMessage = 'Unknown error occurred while sending WhatsApp message.';
    let errorCode: number | string | undefined;

    // Use the type guard to safely access potential error properties
    if (isPotentialTwilioError(error)) {
        errorCode = error.code;
        errorMessage = error.message || errorMessage;
    } else if (error instanceof Error) {
        // Standard JavaScript Error
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        // Simple string error
        errorMessage = error;
    }

    // Log detailed error information
    logger.error('Failed to send WhatsApp message via Twilio', {
      errorCode,
      errorMessage,
      recipient: `whatsapp:+${this.formatPhoneNumber(recipient.phone)}`, // Log formatted number for debugging
      from: `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`,
      // Pass the original error object for full details in structured logs
      errorDetails: error
    });

    // Specific handling/logging for common, informative errors
    if (errorCode === 63018 || errorCode === 21614) { // Common codes for non-WhatsApp/incapable numbers
         logger.error(`Recipient number appears invalid or not registered on WhatsApp.`, { phone: recipient.phone, errorCode });
         // Consider adding logic here: maybe mark the user's number as invalid? Notify admin?
    } else if (errorCode === 63016) { // Common code for failing outside the 24-hour window without a template
          logger.warn(`Failed to send non-template message outside 24-hour window.`, { phone: recipient.phone, errorCode });
    }

    return false; // Indicate that sending failed
    // --- End Handle Errors ---
  }
}
}

// Export the singleton instance for use in other parts of the application
export const whatsAppAdapter = WhatsAppAdapter.getInstance();
--- End of Content for WhatsAppAdapter.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\StatusTransitionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService.ts

import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { notificationService } from "../notification/NotificationService";


type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type TransitionOptions = {
  sendNotifications?: boolean;
  customMessage?: string;
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string,
    options: TransitionOptions = {}
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;
    const mergedOptions = {
      sendNotifications: true,
      notifyParties: ['first', 'second', 'matchmaker'],
      ...options
    };

    // Validate the transition
    this.validateStatusTransition(previousStatus, newStatus);

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Only send notifications if option is enabled
    if (mergedOptions.sendNotifications) {
      try {
        // Utilize the notification service for all channels (email, WhatsApp, etc.)
        await notificationService.handleSuggestionStatusChange(
          
          updatedSuggestion, 
          {
            channels: ['email', 'whatsapp'],
            notifyParties: mergedOptions.notifyParties as ('first' | 'second' | 'matchmaker')[],
            customMessage: mergedOptions.customMessage
          }
        );
        
        console.log(`Notifications sent for suggestion ${updatedSuggestion.id} status change to ${newStatus}`);
      } catch (error) {
        // Log error but don't fail the transition
        console.error('Error sending status transition notifications:', error);
      }
    }

    return updatedSuggestion;
  }

  private validateStatusTransition(
    currentStatus: MatchSuggestionStatus, 
    newStatus: MatchSuggestionStatus
  ): void {
    const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
      DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
      PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
      ],
      AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      ENDED_AFTER_FIRST_DATE: [
        MatchSuggestionStatus.CLOSED
      ],
      MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
      ],
      MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
      ],
      ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
      ],
      MARRIED: [],
      EXPIRED: [],
      CLOSED: [],
      CANCELLED: []
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new Error(
        `Invalid status transition from ${currentStatus} to ${newStatus}. ` +
        `Valid transitions are: ${validTransitions[currentStatus]?.join(', ') || 'none'}`
      );
    }
  }
  
  getStatusLabel(status: MatchSuggestionStatus): string {
    const statusLabels: Record<MatchSuggestionStatus, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת הצד הראשון",
      FIRST_PARTY_APPROVED: "הצד הראשון אישר",
      FIRST_PARTY_DECLINED: "הצד הראשון דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת הצד השני",
      SECOND_PARTY_APPROVED: "הצד השני אישר",
      SECOND_PARTY_DECLINED: "הצד השני דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור השדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בחשיבה לאחר הפגישה",
      PROCEEDING_TO_SECOND_DATE: "התקדמות לפגישה שנייה",
      ENDED_AFTER_FIRST_DATE: "הסתיים לאחר פגישה ראשונה",
      MEETING_PENDING: "פגישה בהמתנה",
      MEETING_SCHEDULED: "פגישה קבועה",
      MATCH_APPROVED: "השידוך אושר",
      MATCH_DECLINED: "השידוך נדחה",
      DATING: "בתהליך היכרות",
      ENGAGED: "אירוסין",
      MARRIED: "נישואין",
      CANCELLED: "בוטל",
      CLOSED: "נסגר",
      EXPIRED: "פג תוקף"
    };
    
    return statusLabels[status] || status;
  }
  
  // Get available actions for current status based on user role
  getAvailableActions(
    suggestion: SuggestionWithParties, 
    userId: string
  ): { id: string; label: string; nextStatus: MatchSuggestionStatus }[] {
    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;
    const isMatchmaker = suggestion.matchmakerId === userId;
    
    const actions: Record<MatchSuggestionStatus, { 
      firstParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      secondParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      matchmaker?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
    }> = {
      DRAFT: {
        matchmaker: [
          { id: "send-to-first", label: "שליחה לצד הראשון", nextStatus: MatchSuggestionStatus.PENDING_FIRST_PARTY }
        ]
      },
      PENDING_FIRST_PARTY: {
        firstParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_APPROVED: {
        matchmaker: [
          { id: "send-to-second", label: "שליחה לצד השני", nextStatus: MatchSuggestionStatus.PENDING_SECOND_PARTY },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      PENDING_SECOND_PARTY: {
        secondParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_APPROVED: {
        matchmaker: [
          { id: "share-contacts", label: "שיתוף פרטי קשר", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      AWAITING_MATCHMAKER_APPROVAL: {
        matchmaker: [
          { id: "approve-share", label: "אישור שיתוף פרטים", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      CONTACT_DETAILS_SHARED: {
        firstParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        secondParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        matchmaker: [
          { id: "request-feedback", label: "בקש משוב", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      AWAITING_FIRST_DATE_FEEDBACK: {
         matchmaker: [
            { id: "mark-thinking", label: "סמן כ'בחשיבה'", nextStatus: MatchSuggestionStatus.THINKING_AFTER_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      THINKING_AFTER_DATE: {
         matchmaker: [
            { id: "proceed-second", label: "המשך לפגישה שניה", nextStatus: MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      PROCEEDING_TO_SECOND_DATE: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      ENDED_AFTER_FIRST_DATE: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      MEETING_PENDING: {
         matchmaker: [
            { id: "schedule-meeting", label: "קביעת פגישה", nextStatus: MatchSuggestionStatus.MEETING_SCHEDULED },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MEETING_SCHEDULED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_APPROVED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      DATING: {
        matchmaker: [
          { id: "mark-engaged", label: "עדכון אירוסין", nextStatus: MatchSuggestionStatus.ENGAGED },
          { id: "close", label: "סגירת תהליך", nextStatus: MatchSuggestionStatus.CLOSED },
          { id: "cancel", label: "ביטול השידוך", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      ENGAGED: {
        matchmaker: [
          { id: "mark-married", label: "עדכון נישואין", nextStatus: MatchSuggestionStatus.MARRIED },
          { id: "cancel", label: "ביטול אירוסין", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      MARRIED: {},
      EXPIRED: {},
      CLOSED: {},
      CANCELLED: {}
    };
    
    if (isFirstParty && actions[suggestion.status]?.firstParty) {
      return actions[suggestion.status].firstParty || [];
    }
    
    if (isSecondParty && actions[suggestion.status]?.secondParty) {
      return actions[suggestion.status].secondParty || [];
    }
    
    if (isMatchmaker && actions[suggestion.status]?.matchmaker) {
      return actions[suggestion.status].matchmaker || [];
    }
    
    return [];
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();
--- End of Content for StatusTransitionService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\SuggestionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/SuggestionService.ts

import { MatchSuggestionStatus, Priority, UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { initNotificationService } from "../notification/initNotifications";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
} from "@/types/suggestions";

// Initialize notification service
const notificationService = initNotificationService();

export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    if (!matchmaker || matchmaker.role !== UserRole.MATCHMAKER) {
      throw new Error("Unauthorized - User is not a matchmaker");
    }

    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
      console.log('Decision deadline type:', typeof data.decisionDeadline);
      
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות באמצעות מערכת ההתראות המאוחדת
    try {
      console.log('Sending notifications for new suggestion...');
      await notificationService.handleSuggestionStatusChange(
        suggestion,
        {
          channels: ['email', 'whatsapp'],
          notifyParties: ['first'] // רק לצד הראשון בשלב זה
        }
      );
    } catch (error) {
      console.error('Error sending initial suggestion notifications:', error);
      // לא לעצור את התהליך - רק לדווח על השגיאה
    }

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: SuggestionWithParties,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<SuggestionWithParties | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }
}
export const suggestionService = SuggestionService.getInstance();
--- End of Content for SuggestionService.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\matchingAlgorithm.ts
--------------------------------------------------------------------------------
Content:
import { AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

const matchingAlgorithm = {
  calculateMatchScore,
  findBestMatches
};

export default matchingAlgorithm;
--- End of Content for matchingAlgorithm.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\statisticsCalculator.ts
--------------------------------------------------------------------------------
Content:
// /utils/statisticsCalculator.ts
import type { Candidate } from '../../new/types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const  stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

const statisticsCalculator = {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

export default statisticsCalculator;
--- End of Content for statisticsCalculator.ts ---

--- End of Content for suggestions_contents.txt ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\CandidateSelector.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/CandidateSelector.tsx

import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search, AlertTriangle, Clock } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../../new/types/candidates";
import { toast } from "sonner"; // Make sure to import toast

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      // Check if the candidate is blocked by an active suggestion
      if (candidate.suggestionStatus?.status === 'BLOCKED') {
        toast.error("לא ניתן לבחור מועמד זה", {
          description: `${candidate.firstName} ${candidate.lastName} כבר נמצא/ת בהצעה פעילה עם ${candidate.suggestionStatus.withCandidateName}.`,
        });
        return; // Prevent selection
      }
      
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={setInputValue}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => {
                    const isBlocked = candidate.suggestionStatus?.status === 'BLOCKED';
                    return (
                      <div
                        key={candidate.id}
                        onClick={() => handleSelect(candidate)}
                        className={`flex items-start gap-3 p-2 text-right ${
                          isBlocked 
                            ? 'cursor-not-allowed opacity-60' 
                            : 'cursor-pointer hover:bg-accent/50'
                        } ${index === activeIndex ? "bg-accent" : ""}`}
                        role="option"
                        id={`candidate-${candidate.id}`}
                        aria-selected={index === activeIndex}
                        onMouseEnter={() => setActiveIndex(index)}
                      >
                        <div className="flex-1">
                          <div className="font-medium">
                            {formatCandidateDisplay(candidate)}
                          </div>
                          <div className="text-sm text-gray-500">
                            {candidate.profile.religiousLevel} | {candidate.profile.occupation}
                          </div>
                          {candidate.suggestionStatus?.status === 'BLOCKED' && (
                            <Badge variant="destructive" className="mt-2 font-normal">
                              <AlertTriangle className="w-3.5 h-3.5 ml-1.5" />
                              בהצעה פעילה עם: {candidate.suggestionStatus.withCandidateName}
                            </Badge>
                          )}
                          {candidate.suggestionStatus?.status === 'PENDING' && (
                            <Badge variant="outline" className="mt-2 font-normal text-amber-800 bg-amber-50 border-amber-200">
                              <Clock className="w-3.5 h-3.5 ml-1.5" />
                              הצעה ממתינה עם: {candidate.suggestionStatus.withCandidateName}
                            </Badge>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => { /* Implement view profile handler */ }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;
--- End of Content for CandidateSelector.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\MatchPreview.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../../new/types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;
--- End of Content for MatchPreview.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\SuggestionDetails.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/SuggestionDetails.tsx

"use client";
import React, { useState } from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2, Sparkles, AlertTriangle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../../new/types/candidates";

interface SuggestionDetailsProps {
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({ firstParty, secondParty }) => {
  const { register, formState: { errors }, setValue, watch } = useFormContext<NewSuggestionFormData>();
  const [isGeneratingRationale, setIsGeneratingRationale] = useState(false);

  const priority = watch("priority", Priority.MEDIUM);

  const handleGenerateRationale = async () => {
    setIsGeneratingRationale(true);
    toast.info("ה-AI מנסח את חבילת הנימוקים...");
    try {
      const response = await fetch('/api/ai/generate-suggestion-rationale', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId1: firstParty.id, userId2: secondParty.id }),
      });

      const data = await response.json();

      if (!response.ok || !data.success || !data.rationales) {
        throw new Error(data.error || "שגיאה בייצור הנימוקים");
      }

      // --- START OF CHANGE: Populate all three fields ---
      const { generalRationale, rationaleForParty1, rationaleForParty2 } = data.rationales;

      setValue('matchingReason', generalRationale, { shouldValidate: true, shouldDirty: true });
      setValue('firstPartyNotes', rationaleForParty1, { shouldValidate: true, shouldDirty: true });
      setValue('secondPartyNotes', rationaleForParty2, { shouldValidate: true, shouldDirty: true });
      // --- END OF CHANGE ---

      toast.success("הנימוקים נוצרו בהצלחה והוזנו בשדות המתאימים.");

    } catch (error) {
      console.error("Failed to generate rationales:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה לא צפויה");
    } finally {
      setIsGeneratingRationale(false);
    }
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardContent className="pt-6 space-y-6">
          <div className="space-y-2">
            <Label htmlFor="priority">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => setValue("priority", value, { shouldValidate: true })}
              defaultValue={priority}
              name="priority"
            >
              <SelectTrigger id="priority"><SelectValue placeholder="בחר/י עדיפות" /></SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>דחופה</SelectItem>
                <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && <p className="text-sm text-red-500 mt-1">{errors.priority.message}</p>}
          </div>

          <div className="space-y-2">
            <div className="flex justify-between items-center">
              <Label htmlFor="matchingReason">סיבת התאמה (כללי, יוצג לצדדים)</Label>
              <Button type="button" variant="ghost" size="sm" onClick={handleGenerateRationale} disabled={isGeneratingRationale}>
                {isGeneratingRationale ? (
                  <Loader2 className="w-4 h-4 ml-2 animate-spin" />
                ) : (
                  <Sparkles className="w-4 h-4 ml-2 text-purple-500" />
                )}
                {isGeneratingRationale ? 'מנסח...' : 'צור נימוקים (AI)'}
              </Button>
            </div>
            <Textarea
              id="matchingReason"
              {...register("matchingReason")}
              placeholder="נימוק כללי המסביר מדוע יש התאמה בין הצדדים..."
              className="min-h-[120px]"
            />
            {errors.matchingReason && <p className="text-sm text-red-500 mt-1">{errors.matchingReason.message}</p>}
             <Alert variant="default" className="mt-2 text-xs p-3 bg-blue-50 border-blue-200">
                <AlertTriangle className="h-4 w-4 text-blue-500" />
                <AlertDescription>
                  לחיצה על כפתור ה-AI תמלא אוטומטית את שדה זה וגם את שדות ההערות האישיות לכל צד.
                </AlertDescription>
            </Alert>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label htmlFor="firstPartyNotes">הערות אישיות לצד א׳ ({firstParty.firstName})</Label>
              <Textarea
                id="firstPartyNotes"
                {...register("firstPartyNotes")}
                placeholder="טקסט אישי המדגיש את היתרונות של צד ב' עבור צד א'..."
                className="min-h-[140px]"
              />
              {errors.firstPartyNotes && <p className="text-sm text-red-500 mt-1">{errors.firstPartyNotes.message}</p>}
            </div>
            <div className="space-y-2">
              <Label htmlFor="secondPartyNotes">הערות אישיות לצד ב׳ ({secondParty.firstName})</Label>
              <Textarea
                id="secondPartyNotes"
                {...register("secondPartyNotes")}
                placeholder="טקסט אישי המדגיש את היתרונות של צד א' עבור צד ב'..."
                className="min-h-[140px]"
              />
              {errors.secondPartyNotes && <p className="text-sm text-red-500 mt-1">{errors.secondPartyNotes.message}</p>}
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="internalNotes">הערות פנימיות (לצוות השדכנים)</Label>
            <Textarea
              id="internalNotes"
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשימוש פנימי בלבד..."
              className="min-h-[100px]"
            />
            {errors.internalNotes && <p className="text-sm text-red-500 mt-1">{errors.internalNotes.message}</p>}
          </div>
          
          <div className="space-y-2">
            <Label>תאריך יעד להחלטה</Label>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value, 10);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, { shouldValidate: true });
              }}
              defaultValue="14"
            >
              <SelectTrigger><SelectValue /></SelectTrigger>
              <SelectContent>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
                <SelectItem value="14">14 ימים</SelectItem>
                <SelectItem value="30">30 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && <p className="text-sm text-red-500 mt-1">{errors.decisionDeadline.message}</p>}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;
--- End of Content for SuggestionDetails.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\index.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/NewSuggestionForm/index.tsx

"use client";
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { UserPlus, Sparkles, Loader2, BarChart2, CheckCircle, Users } from "lucide-react";

// Types
import type { Candidate } from "../../new/types/candidates";
import { newSuggestionSchema, type NewSuggestionFormData } from "./schema";

// Components
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";
import { AiMatchAnalysisDialog } from "../../new/dialogs/AiMatchAnalysisDialog";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({ isOpen, onClose, candidates, selectedCandidate, onSubmit }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(null);
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);
  const [showAnalysisDialog, setShowAnalysisDialog] = useState(false);

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      decisionDeadline: new Date(new Date().setDate(new Date().getDate() + 14)), // Default to 2 weeks
    },
  });

  // Reset form and state when dialog opens or selectedCandidate changes
  useEffect(() => {
    if (isOpen) {
      form.reset({
        priority: Priority.MEDIUM,
        status: MatchSuggestionStatus.DRAFT,
        decisionDeadline: new Date(new Date().setDate(new Date().getDate() + 14)),
        firstPartyId: selectedCandidate?.id || "",
        secondPartyId: "",
      });
      setFirstParty(selectedCandidate || null);
      setSecondParty(null);
    }
  }, [isOpen, selectedCandidate, form]);

  const handleCandidateSelect = (type: "first" | "second") => (candidate: Candidate | null) => {
    const setter = type === 'first' ? setFirstParty : setSecondParty;
    const fieldName = type === 'first' ? 'firstPartyId' : 'secondPartyId';
    setter(candidate);
    form.setValue(fieldName, candidate?.id || "", { shouldValidate: true, shouldDirty: true });
  };

  const handleSubmit = form.handleSubmit(async (data) => {
    if (!firstParty || !secondParty) {
      toast.error("יש לבחור את שני הצדדים להצעה.");
      return;
    }

    setIsSubmitting(true);
    try {
      await onSubmit(data);
      toast.success("ההצעה נוצרה בהצלחה!");
      onClose();
    } catch (error) {
      toast.error("שגיאה ביצירת ההצעה: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"));
    } finally {
      setIsSubmitting(false);
    }
  });

  const maleCandidates = candidates.filter(c => c.profile.gender === 'MALE');
  const femaleCandidates = candidates.filter(c => c.profile.gender === 'FEMALE');

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-7xl w-full h-[95vh] flex flex-col p-0" dir="rtl">
          <DialogHeader className="px-6 py-4 border-b flex-shrink-0">
            <DialogTitle className="text-2xl flex items-center gap-3">
              <UserPlus className="text-primary"/>
              יצירת הצעת שידוך חדשה
            </DialogTitle>
            <DialogDescription>
              בחר שני מועמדים, נתח את ההתאמה ביניהם והגדר את פרטי ההצעה.
            </DialogDescription>
          </DialogHeader>

          <FormProvider {...form}>
            <form onSubmit={handleSubmit} className="flex-1 grid grid-cols-1 md:grid-cols-12 gap-6 p-6 overflow-hidden">
              
              {/* Left Panel: Male Selector */}
              <div className="md:col-span-3 flex flex-col gap-4">
                <CandidateSelector
                  label="צד א' (גבר)"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={maleCandidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />
              </div>
              
              {/* Center Panel: Details and Actions */}
              <div className="md:col-span-6 flex flex-col gap-4 overflow-y-auto pr-2 pb-4">
                {firstParty && secondParty ? (
                  <>
                    <MatchPreview firstParty={firstParty} secondParty={secondParty} />
                     <div className="flex gap-2 justify-center">
                      <Button type="button" variant="outline" onClick={() => setShowAnalysisDialog(true)}>
                        <BarChart2 className="w-4 h-4 ml-2"/>
                        נתח התאמה מלא (AI)
                      </Button>
                     </div>
                    <SuggestionDetails firstParty={firstParty} secondParty={secondParty} />
                  </>
                ) : (
                  <div className="flex items-center justify-center h-full bg-gray-50 rounded-lg border-2 border-dashed">
                    <div className="text-center text-gray-500">
                        <Users className="mx-auto h-12 w-12 text-gray-300" />
                        <h3 className="mt-2 text-sm font-medium">בחר מועמדים</h3>
                        <p className="mt-1 text-sm text-gray-500">
                            יש לבחור מועמד ומועמדת מהעמודות בצדדים.
                        </p>
                    </div>
                  </div>
                )}
              </div>

              {/* Right Panel: Female Selector */}
              <div className="md:col-span-3 flex flex-col gap-4">
                <CandidateSelector
                  label="צד ב' (אישה)"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={femaleCandidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

            </form>
          </FormProvider>

          <DialogFooter className="p-4 border-t flex-shrink-0">
            <div className="flex justify-between w-full items-center">
                <span className="text-xs text-gray-500">לאחר יצירת ההצעה, היא תופיע בסטטוס טיוטה.</span>
                <div className="flex gap-2">
                    <DialogClose asChild><Button variant="outline">ביטול</Button></DialogClose>
                    <Button
                        type="submit"
                        onClick={handleSubmit}
                        disabled={isSubmitting || !firstParty || !secondParty}
                    >
                        {isSubmitting ? <Loader2 className="w-4 h-4 animate-spin ml-2"/> : <CheckCircle className="w-4 h-4 ml-2"/>}
                        {isSubmitting ? "יוצר הצעה..." : "צור הצעה"}
                    </Button>
                </div>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {firstParty && secondParty && (
        <AiMatchAnalysisDialog
          isOpen={showAnalysisDialog}
          onClose={() => setShowAnalysisDialog(false)}
          targetCandidate={firstParty}
          comparisonCandidates={[secondParty]}
        />
      )}
    </>
  );
};

export default NewSuggestionForm;
--- End of Content for index.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\schema.ts
--------------------------------------------------------------------------------
Content:
import { z } from "zod";
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;
--- End of Content for schema.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards\SuggestionCard.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import Image from "next/image";
import {
  Clock,
  User,
  MessageCircle,
  Eye,
  AlertCircle,
  MoreHorizontal,
  Send,
  RefreshCw,
  Trash2,
  Edit,
  CheckCircle,
  XCircle,
  CalendarClock,
  Heart,
  MapPin,
  Calendar,
  Star,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestionStatus, Priority } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import { Progress } from "@/components/ui/progress";

interface SuggestionCardProps {
  suggestion: Suggestion;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const getStatusInfo = (status: MatchSuggestionStatus) => {
  switch (status) {
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לתשובת צד א׳",
        className: "bg-yellow-100 text-yellow-800 border-yellow-200",
        color: "text-yellow-600",
        bgColor: "bg-yellow-50",
        icon: Clock,
        progress: 25,
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לתשובת צד ב׳",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        color: "text-blue-600",
        bgColor: "bg-blue-50",
        icon: Clock,
        progress: 50,
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "צד א׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 40,
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "צד ב׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 60,
      };
    case "FIRST_PARTY_DECLINED":
      return {
        label: "צד א׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "SECOND_PARTY_DECLINED":
      return {
        label: "צד ב׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        className: "bg-purple-100 text-purple-800 border-purple-200",
        color: "text-purple-600",
        bgColor: "bg-purple-50",
        icon: Send,
        progress: 70,
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        className: "bg-pink-100 text-pink-800 border-pink-200",
        color: "text-pink-600",
        bgColor: "bg-pink-50",
        icon: Heart,
        progress: 80,
      };
    case "AWAITING_FIRST_DATE_FEEDBACK":
      return {
        label: "ממתין למשוב פגישה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        color: "text-orange-600",
        bgColor: "bg-orange-50",
        icon: AlertCircle,
        progress: 75,
      };
    case "EXPIRED":
      return {
        label: "פג תוקף",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: Clock,
        progress: 100,
      };
    default:
      return {
        label: "בטיפול",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: RefreshCw,
        progress: 30,
      };
  }
};

const getPriorityInfo = (priority: Priority) => {
  switch (priority) {
    case "URGENT":
      return {
        label: "דחוף",
        className: "bg-red-100 text-red-800 border-red-200",
        icon: AlertCircle,
        color: "text-red-600",
      };
    case "HIGH":
      return {
        label: "גבוה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        icon: Star,
        color: "text-orange-600",
      };
    case "MEDIUM":
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
    case "LOW":
      return {
        label: "נמוך",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: Star,
        color: "text-gray-600",
      };
    default:
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
  }
};

// Days left until deadline if applicable
const getDaysLeft = (decisionDeadline?: Date | string | null) => {
  if (!decisionDeadline) return null;

  const deadline = new Date(decisionDeadline);
  const today = new Date();
  const diffTime = deadline.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? diffDays : 0;
};

const SuggestionCard: React.FC<SuggestionCardProps> = ({
  suggestion,
  onAction,
  className,
}) => {
  const { firstParty, secondParty } = suggestion;
  const statusInfo = getStatusInfo(suggestion.status);
  const priorityInfo = getPriorityInfo(suggestion.priority);
  const StatusIcon = statusInfo.icon;
  const PriorityIcon = priorityInfo.icon;
  const daysLeft = getDaysLeft(suggestion.decisionDeadline);

  // Check if the suggestion is waiting for response
  const isWaitingForResponse =
    suggestion.status === "PENDING_FIRST_PARTY" ||
    suggestion.status === "PENDING_SECOND_PARTY";

  // Check if the suggestion has feedback requirement
  const needsFeedback = suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK";

  // Check if the suggestion can be resent
  const canBeResent =
    suggestion.status === "EXPIRED" ||
    suggestion.status === "FIRST_PARTY_DECLINED" ||
    suggestion.status === "SECOND_PARTY_DECLINED";

  const firstPartyAge = calculateAge(firstParty.profile.birthDate);
  const secondPartyAge = calculateAge(secondParty.profile.birthDate);

  const firstPartyMainImage = firstParty.images.find((img) => img.isMain);
  const secondPartyMainImage = secondParty.images.find((img) => img.isMain);

  return (
    <Card
      className={`${className} overflow-hidden hover:shadow-md transition-shadow`}
    >
      {/* Header with status and progress */}
      <div className={`p-4 ${statusInfo.bgColor} border-b relative`}>
        <div className="flex justify-between items-center mb-2">
          <div className="flex items-center gap-2">
            <StatusIcon className={`w-5 h-5 ${statusInfo.color}`} />
            <span className="font-medium text-gray-900">
              {statusInfo.label}
            </span>
          </div>
          <Badge className={priorityInfo.className}>
            <PriorityIcon className="w-3 h-3 ml-1" />
            {priorityInfo.label}
          </Badge>
        </div>

        <Progress value={statusInfo.progress} className="h-1.5" />

        {/* Deadline warning if needed */}
        {daysLeft !== null &&
          daysLeft <= 3 &&
          suggestion.status !== "EXPIRED" && (
            <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 bg-red-500 text-white text-xs font-bold py-0.5 px-2 rounded-full whitespace-nowrap z-10">
              <Clock className="w-3 h-3 inline-block ml-1" />
              {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים נותרו`}
            </div>
          )}
      </div>

      {/* Main content */}
      <div className="p-4">
        {/* Parties info */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          {/* First party */}
          <div className="space-y-2 border-l pl-4 order-1">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-blue-50">
                צד א׳
              </Badge>
              {suggestion.status === "FIRST_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "FIRST_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {firstPartyMainImage ? (
                  <Image
                    src={firstPartyMainImage.url}
                    alt={`${firstParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {firstParty.firstName} {firstParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{firstPartyAge} שנים</span>
                  </div>
                  {firstParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{firstParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Second party */}
          <div className="space-y-2 order-0">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-purple-50">
                צד ב׳
              </Badge>
              {suggestion.status === "SECOND_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "SECOND_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {secondPartyMainImage ? (
                  <Image
                    src={secondPartyMainImage.url}
                    alt={`${secondParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {secondParty.firstName} {secondParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{secondPartyAge} שנים</span>
                  </div>
                  {secondParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{secondParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Matching reason snippet */}
        {suggestion.matchingReason && (
          <div className="mb-4 p-3 bg-gray-50 rounded-lg border text-sm">
            <h5 className="text-xs font-semibold text-gray-600 mb-1">
              סיבת ההתאמה:
            </h5>
            <p className="text-gray-800 line-clamp-2">
              {suggestion.matchingReason.length > 120
                ? `${suggestion.matchingReason.substring(0, 120)}...`
                : suggestion.matchingReason}
            </p>
          </div>
        )}

        {/* Info and time */}
        <div className="flex justify-between text-xs text-gray-500 mb-4">
          <div className="flex items-center">
            <Clock className="w-3.5 h-3.5 ml-1" />
            {formatDistanceToNow(new Date(suggestion.createdAt), {
              addSuffix: true,
              locale: he,
            })}
          </div>

          {suggestion.decisionDeadline && (
            <div className="flex items-center">
              <CalendarClock className="w-3.5 h-3.5 ml-1" />
              {daysLeft !== null
                ? daysLeft === 0
                  ? "היום!"
                  : `${daysLeft} ימים להחלטה`
                : "אין מועד אחרון"}
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="flex items-center justify-between pt-2 border-t">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onAction("message", suggestion)}
            className="text-gray-600 hover:text-primary"
          >
            <MessageCircle className="w-4 h-4 ml-1" />
            הודעה
          </Button>

          {/* סקציית פעולות בקובץ SuggestionCard.tsx */}
          {isWaitingForResponse && (
            <Button
              variant="outline"
              size="sm"
              className="text-yellow-600"
              onClick={() =>
                onAction("reminder", suggestion, {
                  partyType:
                    suggestion.status === "PENDING_FIRST_PARTY"
                      ? "first"
                      : "second",
                })
              }
            >
              <Send className="w-4 h-4 ml-1" />
              {suggestion.status === "PENDING_FIRST_PARTY"
                ? "שלח תזכורת לצד ראשון"
                : suggestion.status === "PENDING_SECOND_PARTY"
                ? "שלח תזכורת לצד שני"
                : suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK"
                ? "שלח בקשת עדכון מפגש"
                : "שלח תזכורת"}
            </Button>
          )}

          {needsFeedback && (
            <Button
              variant="outline"
              size="sm"
              className="text-blue-600"
              onClick={() =>
                onAction("contact", suggestion, { type: "feedback" })
              }
            >
              <MessageCircle className="w-4 h-4 ml-1" />
              בקש משוב
            </Button>
          )}

          <div className="flex items-center gap-1">
            {canBeResent && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAction("resend", suggestion)}
                className="px-2"
              >
                <RefreshCw className="w-4 h-4" />
              </Button>
            )}

            <Button
              variant="outline"
              size="sm"
              onClick={() => onAction("edit", suggestion)}
              className="px-2"
            >
              <Edit className="w-4 h-4" />
            </Button>

            <Button
              variant="default"
              size="sm"
              onClick={() => onAction("view", suggestion)}
            >
              <Eye className="w-4 h-4 ml-1" />
              פרטים
            </Button>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button size="sm" variant="ghost" className="px-1">
                  <MoreHorizontal className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => onAction("edit", suggestion)}>
                  <Edit className="w-4 h-4 ml-2" />
                  <span>ערוך הצעה</span>
                </DropdownMenuItem>

                {canBeResent && (
                  <DropdownMenuItem
                    onClick={() => onAction("resend", suggestion)}
                  >
                    <RefreshCw className="w-4 h-4 ml-2" />
                    <span>שלח מחדש</span>
                  </DropdownMenuItem>
                )}

                <DropdownMenuItem
                  onClick={() => onAction("delete", suggestion)}
                  className="text-red-600"
                >
                  <Trash2 className="w-4 h-4 ml-2" />
                  <span>מחק הצעה</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </Card>
  );
};

export default SuggestionCard;
--- End of Content for SuggestionCard.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback, useEffect, useMemo } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Plus, Download, RefreshCw, BarChart, Loader2 } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { toast } from "sonner";
import { MatchSuggestionStatus, Priority } from "@prisma/client";

// --- START: Type Imports and Definitions ---
import type {
  Suggestion,
  SuggestionFilters,
  ActionAdditionalData,
} from "@/types/suggestions";
import type { NewSuggestionFormData } from "../../suggestions/NewSuggestionForm/schema";
import type { Candidate } from "../../new/types/candidates";

// Hooks
import { useCandidates } from "../../new/hooks/useCandidates";

// Components
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import SuggestionCard from "../cards/SuggestionCard";
import EditSuggestionForm from "../EditSuggestionForm";
import MessageForm from "../MessageForm";
import MonthlyTrendModal from "./MonthlyTrendModal";

// --- Defining specific payload types to replace 'any' ---
interface SuggestionUpdatePayload {
  priority?: Priority;
  status?: MatchSuggestionStatus;
  statusNotes?: string;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: Date;
}

interface SendMessagePayload {
  suggestionId: string;
  partyType: "first" | "second" | "both";
  messageType: "message" | "reminder" | "update";
  messageContent: string;
}

type DialogActionData = {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyType?: "first" | "second" | "both";
  type?: string;
};

type ConfirmActionData = {
  suggestionId: string;
  partyType?: "first" | "second" | "both";
  type?: string;
};
// --- END: Type Imports and Definitions ---

export default function MatchmakerDashboard() {
  // State management
  const [activeTab, setActiveTab] = useState("pending");
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<SuggestionFilters>({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  // Dialogs and selected items state
  const [selectedSuggestion, setSelectedSuggestion] = useState<Suggestion | null>(null);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmAction, setConfirmAction] = useState<{ type: string; data: ConfirmActionData; } | null>(null);
  const [showEditForm, setShowEditForm] = useState(false);
  const [showMessageForm, setShowMessageForm] = useState(false);
  const [showMonthlyTrendDialog, setShowMonthlyTrendDialog] = useState(false);

  // Fetch candidates list to pass to the form
  const { candidates: allCandidates } = useCandidates();

  const fetchSuggestions = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/matchmaker/suggestions");
      if (!response.ok) throw new Error("Failed to fetch suggestions");
      const data = await response.json();
      
      // =================  LOGGING START  =================
      console.log("[MatchmakerDashboard] Fetched suggestions data:", data);
      const createdSuggestion = data.find((s: Suggestion) => s.status === 'PENDING_FIRST_PARTY');
      if (createdSuggestion) {
        console.log("[MatchmakerDashboard] Found a newly created suggestion:", createdSuggestion);
      }
      // =================   LOGGING END   =================

      setSuggestions(data);
    } catch (error: unknown) {
      console.error("Error fetching suggestions:", error);
      toast.error("שגיאה בטעינת ההצעות");
    } finally {
      setIsLoading(false);
    }
  }, []);


  useEffect(() => {
    fetchSuggestions();
  }, [fetchSuggestions]);
  
  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((s) => {
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const match =
          (s.firstParty.firstName + " " + s.firstParty.lastName).toLowerCase().includes(query) ||
          (s.secondParty.firstName + " " + s.secondParty.lastName).toLowerCase().includes(query) ||
          (s.firstParty.profile?.city && s.firstParty.profile.city.toLowerCase().includes(query)) ||
          (s.secondParty.profile?.city && s.secondParty.profile.city.toLowerCase().includes(query));
        if (!match) return false;
      }
      if (filters.priority?.length && !filters.priority.includes(s.priority)) return false;
      if (filters.status?.length && !filters.status.includes(s.status)) return false;
      if (filters.dateRange) {
        const createdAt = new Date(s.createdAt);
        if (createdAt < filters.dateRange.start || (filters.dateRange.end && createdAt > filters.dateRange.end)) return false;
      }
      return true;
    });
  }, [suggestions, searchQuery, filters]);
  
  const pendingSuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'PENDING'), [filteredSuggestions]);
  const activeSuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'ACTIVE'), [filteredSuggestions]);
  const historySuggestions = useMemo(() => filteredSuggestions.filter(s => s.category === 'HISTORY'), [filteredSuggestions]);

  const pendingCount = pendingSuggestions.length;
  const activeCount = activeSuggestions.length;
  const historyCount = historySuggestions.length;

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await fetchSuggestions();
    setIsRefreshing(false);
    toast.success("נתוני ההצעות עודכנו");
  };

  const handleNewSuggestion = async (data: NewSuggestionFormData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error((await response.json()).error || "Failed to create suggestion");
      setShowNewSuggestion(false);
      toast.success("ההצעה נוצרה בהצלחה");
      await fetchSuggestions();
    } catch (error: unknown) {
      console.error("Error creating suggestion:", error);
      toast.error("שגיאה ביצירת ההצעה: " + (error instanceof Error ? error.message : ""));
    }
  };

  const handleSuggestionDeleted = useCallback((deletedId: string) => {
    setSuggestions((prev) => prev.filter((s) => s.id !== deletedId));
    if (selectedSuggestion?.id === deletedId) setSelectedSuggestion(null);
  }, [selectedSuggestion]);

  const handleConfirmAction = async () => {
    if (!confirmAction) return;
    try {
      if (confirmAction.type === "delete") {
        const response = await fetch(`/api/matchmaker/suggestions/${confirmAction.data.suggestionId}/delete`, { method: "DELETE" });
        if (!response.ok) throw new Error("Failed to delete suggestion");
        handleSuggestionDeleted(confirmAction.data.suggestionId);
        toast.success("ההצעה נמחקה בהצלחה");
      }
    } catch (error: unknown) {
      toast.error("אירעה שגיאה בביצוע הפעולה");
    } finally {
      setShowConfirmDialog(false);
      setConfirmAction(null);
    }
  };
  
  const handleStatusChange = async (suggestionId: string, newStatus: MatchSuggestionStatus, notes?: string) => {
    try {
      const response = await fetch(`/api/matchmaker/suggestions/${suggestionId}/status`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: newStatus, notes: notes || `סטטוס שונה מממשק ניהול` }),
      });
      if (!response.ok) throw new Error((await response.json()).error || "Failed to update status");
      toast.success("סטטוס ההצעה עודכן בהצלחה");
      fetchSuggestions();
    } catch (error: unknown) {
      console.error("Error updating suggestion status:", error);
      toast.error("שגיאה בעדכון סטטוס ההצעה: " + (error instanceof Error ? error.message : ""));
    }
  };

  // --- START OF FIX: Replaced 'any' with specific type ---
  const handleUpdateSuggestion = async (data: {
    suggestionId: string;
    updates: SuggestionUpdatePayload;
  }) => {
  // --- END OF FIX ---
    try {
        const response = await fetch(`/api/matchmaker/suggestions/${data.suggestionId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data.updates),
        });
        if (!response.ok) throw new Error('Failed to update suggestion');
        toast.success("פרטי ההצעה עודכנו בהצלחה");
        setShowEditForm(false);
        fetchSuggestions();
    } catch (error: unknown) {
        console.error("Error updating suggestion:", error);
        toast.error("שגיאה בעדכון פרטי ההצעה");
    }
  };

  // --- START OF FIX: Replaced 'any' with specific type ---
  const handleSendMessage = async (data: SendMessagePayload) => {
  // --- END OF FIX ---
    try {
      const response = await fetch(`/api/matchmaker/suggestions/${data.suggestionId}/message`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            partyType: data.partyType,
            messageType: data.messageType,
            content: data.messageContent
        }),
      });
      if (!response.ok) throw new Error((await response.json()).error || 'Failed to send message');
      toast.success("ההודעה נשלחה בהצלחה");
      setShowMessageForm(false);
    } catch (error: unknown) {
      toast.error("שגיאה בשליחת ההודעה: " + (error instanceof Error ? error.message : ""));
    }
  };
  
  const handleDialogAction = (action: string, data?: DialogActionData) => {
    if (action === 'delete' && data?.suggestionId) {
      setConfirmAction({ type: 'delete', data: { suggestionId: data.suggestionId } });
      setShowConfirmDialog(true);
      setSelectedSuggestion(null);
    } else if (action === 'edit' && data?.suggestion) {
      setSelectedSuggestion(data.suggestion);
      setShowEditForm(true);
    } else if (action === 'message' && data?.suggestion) {
      setSelectedSuggestion(data.suggestion);
      setShowMessageForm(true);
    } else if (action === 'changeStatus' && data?.suggestionId && data.newStatus) {
        handleStatusChange(data.suggestionId, data.newStatus, data.notes);
    }
  };
  
  const handleSuggestionAction = (type: string, suggestion: Suggestion, additionalData?: ActionAdditionalData) => {
    handleDialogAction(type, { ...additionalData, suggestionId: suggestion.id, suggestion });
  };


  return (
    <div className="min-h-screen bg-gray-50 p-6 rtl matchmaker-dashboard">
      <div className="container mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm" onClick={handleRefresh} disabled={isRefreshing}>
              <RefreshCw className={`w-4 h-4 mr-2 ${isRefreshing ? "animate-spin" : ""}`} />
              {isRefreshing ? "מעדכן..." : "רענן"}
            </Button>
            <Button variant="outline" size="sm" onClick={() => setShowMonthlyTrendDialog(true)}>
              <BarChart className="w-4 h-4 mr-2" />
              מגמה חודשית
            </Button>
            <Button onClick={() => setShowNewSuggestion(true)}>
              <Plus className="w-4 h-4 mr-2" />
              הצעה חדשה
            </Button>
          </div>
        </div>

        <SuggestionsStats
          suggestions={suggestions}
          className="mb-6"
          onFilterChange={(filter) => setFilters(prev => ({...prev, ...filter}))}
        />

        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <div className="flex items-center justify-between mb-6">
                   <TabsList dir="rtl">
              {/* --- START OF CHANGE --- */}
              <TabsTrigger value="pending">
                ממתין לאישור <Badge className="mr-2">{pendingCount}</Badge>
              </TabsTrigger>
              <TabsTrigger value="active">
                פעילות <Badge className="mr-2">{activeCount}</Badge>
              </TabsTrigger>
              <TabsTrigger value="history">
                היסטוריה <Badge className="mr-2">{historyCount}</Badge>
              </TabsTrigger>
              {/* --- END OF CHANGE --- */}
            </TabsList>

          </div>
          
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
            totalCount={suggestions.length}
            activeCount={activeCount}
            pendingCount={pendingCount}
            historyCount={historyCount}
          />
          
          {isLoading ? (
            <div className="flex items-center justify-center h-64"><Loader2 className="w-8 h-8 animate-spin text-primary"/></div>
          ) : (
            <>
              <TabsContent value="pending">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {pendingSuggestions.map((suggestion) => (
                    <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} />
                  ))}
                </div>
                {pendingSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות ממתינות לאישור.</div>}
              </TabsContent>
              <TabsContent value="active">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {activeSuggestions.map((suggestion) => (
                    <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} />
                  ))}
                </div>
                {activeSuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות פעילות.</div>}
              </TabsContent>
              <TabsContent value="history">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {historySuggestions.map((suggestion) => (
                    <SuggestionCard key={suggestion.id} suggestion={suggestion} onAction={handleSuggestionAction} />
                  ))}
                </div>
                {historySuggestions.length === 0 && <div className="text-center p-10 text-gray-500">אין הצעות בהיסטוריה.</div>}
              </TabsContent>
            </>
          )}
        </Tabs>
      </div>

      <NewSuggestionForm
        isOpen={showNewSuggestion}
        onClose={() => setShowNewSuggestion(false)}
        candidates={allCandidates}
        onSubmit={handleNewSuggestion}
      />
      
      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleDialogAction}
      />
      
      <Dialog open={showMonthlyTrendDialog} onOpenChange={setShowMonthlyTrendDialog}>
        <DialogContent className="max-w-4xl">
          <DialogHeader><DialogTitle>מגמה חודשית</DialogTitle></DialogHeader>
          <MonthlyTrendModal suggestions={suggestions} />
        </DialogContent>
      </Dialog>
      
      <EditSuggestionForm
        isOpen={showEditForm}
        onClose={() => setShowEditForm(false)}
        suggestion={selectedSuggestion}
        onSave={handleUpdateSuggestion}
      />
      
      <MessageForm
        isOpen={showMessageForm}
        onClose={() => setShowMessageForm(false)}
        suggestion={selectedSuggestion}
        onSend={handleSendMessage}
      />

      {confirmAction && (
        <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
              <AlertDialogDescription>
                {confirmAction.type === "delete" && "פעולה זו תמחק את ההצעה לצמיתות."}
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>ביטול</AlertDialogCancel>
              <AlertDialogAction onClick={handleConfirmAction}>אישור</AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}
    </div>
  );
}
--- End of Content for MatchmakerDashboard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MonthlyTrendModal.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface MonthlyTrendModalProps {
  suggestions: Suggestion[];
}

interface MonthlyData {
  month: string;
  year: number;
  count: number;
  active: number;
  pending: number;
  success: number;
  declined: number;
}

const MonthlyTrendModal: React.FC<MonthlyTrendModalProps> = ({
  suggestions,
}) => {
  // Group suggestions by month to prepare data for chart
  const monthlyData = useMemo(() => {
    const data = suggestions.reduce((acc, s) => {
      const createdDate = new Date(s.createdAt);
      const month = createdDate.getMonth();
      const year = createdDate.getFullYear();
      const key = `${year}-${month + 1}`;

      if (!acc[key]) {
        acc[key] = {
          month: new Date(year, month).toLocaleString("he", {
            month: "short",
          }),
          year: year,
          count: 0,
          active: 0,
          pending: 0,
          success: 0,
          declined: 0,
        };
      }

      acc[key].count += 1;

      if (s.category === "ACTIVE") acc[key].active += 1;
      if (s.category === "PENDING") acc[key].pending += 1;
      if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
      if (
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
      ) {
        acc[key].declined += 1;
      }

      return acc;
    }, {} as Record<string, MonthlyData>);

    // Convert to array and sort by date
    return Object.values(data).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      const monthA = new Date(
        a.year,
        a.month === "ינו" ? 0 : new Date(`1 ${a.month} 2000`).getMonth()
      ).getMonth();
      const monthB = new Date(
        b.year,
        b.month === "ינו" ? 0 : new Date(`1 ${b.month} 2000`).getMonth()
      ).getMonth();
      return monthA - monthB;
    });
  }, [suggestions]);

  // Calculate trends
  const trends = useMemo(() => {
    if (monthlyData.length < 2)
      return { active: 0, pending: 0, success: 0, total: 0 };

    const current = monthlyData[monthlyData.length - 1];
    const previous = monthlyData[monthlyData.length - 2];

    const calculateTrend = (current: number, previous: number) => {
      if (previous === 0) return current > 0 ? 100 : 0;
      return Math.round(((current - previous) / previous) * 100);
    };

    return {
      active: calculateTrend(current.active, previous.active),
      pending: calculateTrend(current.pending, previous.pending),
      success: calculateTrend(current.success, previous.success),
      total: calculateTrend(current.count, previous.count),
    };
  }, [monthlyData]);

  if (monthlyData.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        <p>אין מספיק נתונים להצגת מגמה חודשית</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Summary stats */}
      <div className="grid grid-cols-4 gap-3">
        <Card className="p-3">
          <div className="text-sm text-gray-500"> סך כל ההצעות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].count}
            <span
              className={`text-xs ml-2 ${
                trends.total >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.total > 0 ? "+" : ""}
              {trends.total}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות פעילות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].active}
            <span
              className={`text-xs ml-2 ${
                trends.active >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.active > 0 ? "+" : ""}
              {trends.active}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">ממתינות לאישור</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].pending}
            <span
              className={`text-xs ml-2 ${
                trends.pending >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.pending > 0 ? "+" : ""}
              {trends.pending}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות מוצלחות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].success}
            <span
              className={`text-xs ml-2 ${
                trends.success >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.success > 0 ? "+" : ""}
              {trends.success}%
            </span>
          </div>
        </Card>
      </div>

      {/* Main chart */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={monthlyData}
              margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip
                formatter={(value) => [`${value} הצעות`, ""]}
                labelFormatter={(label) => `חודש ${label}`}
              />
              <Legend />
              <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
              <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
              <Bar dataKey="success" name="הצלחות" fill="#10B981" />
              <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* Monthly breakdown table */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">פירוט חודשי</h3>
        <div className="overflow-x-auto">
          <table className="w-full border-collapse">
            <thead>
              <tr className="bg-gray-50">
                <th className="p-2 border text-right">חודש</th>
                <th className="p-2 border text-center">סך הכל</th>
                <th className="p-2 border text-center">פעילות</th>
                <th className="p-2 border text-center">ממתינות</th>
                <th className="p-2 border text-center">הצלחות</th>
                <th className="p-2 border text-center">נדחו</th>
              </tr>
            </thead>
            <tbody>
              {monthlyData
                .slice()
                .reverse()
                .map((month, idx) => (
                  <tr
                    key={idx}
                    className={idx % 2 === 0 ? "bg-white" : "bg-gray-50"}
                  >
                    <td className="p-2 border font-medium">
                      {month.month} {month.year}
                    </td>
                    <td className="p-2 border text-center">{month.count}</td>
                    <td className="p-2 border text-center">{month.active}</td>
                    <td className="p-2 border text-center">{month.pending}</td>
                    <td className="p-2 border text-center">{month.success}</td>
                    <td className="p-2 border text-center">{month.declined}</td>
                  </tr>
                ))}
            </tbody>
          </table>
        </div>
      </Card>
    </div>
  );
};

export default MonthlyTrendModal;
--- End of Content for MonthlyTrendModal.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { DatePicker } from "@/components/ui/date-picker";
import {
  Search,
  Filter,
  X,
  Calendar,
  User,
  Clock,
  ChevronDown,
  AlertCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import type { SuggestionFilters, SortByOption } from "@/types/suggestions";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: SuggestionFilters;
  onFiltersChange: (filters: SuggestionFilters) => void;
  totalCount: number;
  activeCount: number;
  pendingCount: number;
  historyCount: number;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
  totalCount,
  activeCount,
  pendingCount,
  historyCount,
}) => {
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const activeFilters = Object.keys(filters).length;
  const [dateRange, setDateRange] = useState<{
    from: Date | undefined;
    to: Date | undefined;
  }>({
    from: filters.dateRange?.start,
    to: filters.dateRange?.end,
  });

  const handleRemoveFilter = (key: keyof SuggestionFilters) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  const handleDateRangeChange = (range: {
    from: Date | undefined;
    to: Date | undefined;
  }) => {
    setDateRange(range);
    if (range.from) {
      onFiltersChange({
        ...filters,
        dateRange: {
          start: range.from,
          end: range.to || new Date(),
        },
      });
    } else {
      const newFilters = { ...filters };
      delete newFilters.dateRange;
      onFiltersChange(newFilters);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return <Clock className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_APPROVED":
      case "SECOND_PARTY_APPROVED":
        return <CheckCircle className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
        return <XCircle className="h-4 w-4 ml-1" />;
      default:
        return <AlertCircle className="h-4 w-4 ml-1" />;
    }
  };

  return (
    <div className="space-y-4 mb-6">
      {/* Main filters and search */}
      <div className="flex items-center gap-4">
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות לפי שם, עיר או כל מידע אחר..."
            className="pl-10 text-right pr-10"
          />
        </div>

        <Select
          value={filters.priority?.[0] || "all"}
          onValueChange={(value) =>
            onFiltersChange({
              ...filters,
              priority: value === "all" ? undefined : [value as Priority],
            })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">כל העדיפויות</SelectItem>
            <SelectItem value={Priority.URGENT}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-red-500"></span>
                דחוף
              </div>
            </SelectItem>
            <SelectItem value={Priority.HIGH}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-orange-500"></span>
                גבוהה
              </div>
            </SelectItem>
            <SelectItem value={Priority.MEDIUM}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-blue-500"></span>
                רגילה
              </div>
            </SelectItem>
            <SelectItem value={Priority.LOW}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-gray-500"></span>
                נמוכה
              </div>
            </SelectItem>
          </SelectContent>
        </Select>

        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" className="flex items-center">
              <Calendar className="h-4 w-4 ml-2" />
              <span>טווח זמן</span>
              <ChevronDown className="h-4 w-4 mr-2" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-4" align="end">
            <div className="space-y-2">
              <h4 className="font-medium">בחר טווח תאריכים</h4>
              <DatePicker
                onChange={handleDateRangeChange}
                value={dateRange}
                isRange={true}
              />
              <div className="flex justify-end mt-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() =>
                    handleDateRangeChange({ from: undefined, to: undefined })
                  }
                >
                  נקה
                </Button>
              </div>
            </div>
          </PopoverContent>
        </Popover>

        <Button
          variant={showAdvancedFilters ? "default" : "outline"}
          onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
        >
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Stats Row */}
      <div className="flex justify-between bg-slate-50 rounded-md p-3">
        <div className="flex items-center gap-6">
          <div className="flex items-center">
            <Badge variant="outline" className="rounded-full px-2 py-0 mr-2">
              {totalCount}
            </Badge>
            <span className="text-sm font-medium">סה״כ הצעות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="default" className="rounded-full px-2 py-0 mr-2">
              {activeCount}
            </Badge>
            <span className="text-sm font-medium">פעילות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="warning" className="rounded-full px-2 py-0 mr-2">
              {pendingCount}
            </Badge>
            <span className="text-sm font-medium">ממתינות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="secondary" className="rounded-full px-2 py-0 mr-2">
              {historyCount}
            </Badge>
            <span className="text-sm font-medium">היסטוריה</span>
          </div>
        </div>

        {activeFilters > 0 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה את כל המסננים ({activeFilters})
          </Button>
        )}
      </div>

      {/* Advanced Filters */}
      {showAdvancedFilters && (
        <div className="bg-slate-50 p-4 rounded-md space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="font-medium">מסננים מתקדמים</h3>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 px-2"
              onClick={() => setShowAdvancedFilters(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Status Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">סטטוס</h4>
              <div className="space-y-2">
                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-first"
                    checked={filters.status?.includes("PENDING_FIRST_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_FIRST_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_FIRST_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-first"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-yellow-600" />
                    ממתין לתשובת צד א׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-second"
                    checked={filters.status?.includes("PENDING_SECOND_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_SECOND_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_SECOND_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-second"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-blue-600" />
                    ממתין לתשובת צד ב׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-approved"
                    checked={
                      filters.status?.includes("FIRST_PARTY_APPROVED") ||
                      filters.status?.includes("SECOND_PARTY_APPROVED")
                    }
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "FIRST_PARTY_APPROVED",
                          "SECOND_PARTY_APPROVED",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) =>
                              s !== "FIRST_PARTY_APPROVED" &&
                              s !== "SECOND_PARTY_APPROVED"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-approved"
                    className="text-sm mr-2 flex items-center"
                  >
                    <CheckCircle className="h-3 w-3 ml-1 text-green-600" />
                    אושר ע״י אחד הצדדים
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-dating"
                    checked={filters.status?.includes("DATING")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [...(filters.status || []), "DATING"];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "DATING"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-dating"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Calendar className="h-3 w-3 ml-1 text-pink-600" />
                    בתהליך היכרות
                  </label>
                </div>
              </div>
            </div>

            {/* User Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">משתתפים</h4>
              <Select
                value={filters.userId || "all"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    userId: value === "all" ? undefined : value,
                  })
                }
              >
                <SelectTrigger>
                  <User className="h-4 w-4 ml-1" />
                  <SelectValue placeholder="בחר משתתף" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">כל המשתתפים</SelectItem>
                  {/* Replace with dynamic user data */}
                  <SelectItem value="user1">ישראל ישראלי</SelectItem>
                  <SelectItem value="user2">שרה כהן</SelectItem>
                  <SelectItem value="user3">דוד לוי</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Sort By */}
            <div>
              <h4 className="text-sm font-medium mb-2">מיון לפי</h4>
              <Select
                value={filters.sortBy || "lastActivity"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    sortBy: value as SortByOption, // Cast to SortByOption
                  })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="מיון לפי" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="lastActivity">פעילות אחרונה</SelectItem>
                  <SelectItem value="createdAt">תאריך יצירה</SelectItem>
                  <SelectItem value="priority">עדיפות</SelectItem>
                  <SelectItem value="decisionDeadline">תאריך יעד</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      )}

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2 flex-wrap">
          {filters.priority && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                עדיפות:{" "}
                {filters.priority[0] === "URGENT"
                  ? "דחוף"
                  : filters.priority[0] === "HIGH"
                  ? "גבוהה"
                  : filters.priority[0] === "MEDIUM"
                  ? "רגילה"
                  : "נמוכה"}
              </span>
              <button
                onClick={() => handleRemoveFilter("priority")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.dateRange && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                תאריך:{" "}
                {new Date(filters.dateRange.start).toLocaleDateString("he-IL")}
                {filters.dateRange.end &&
                  ` - ${new Date(filters.dateRange.end).toLocaleDateString(
                    "he-IL"
                  )}`}
              </span>
              <button
                onClick={() => handleRemoveFilter("dateRange")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.status && filters.status.length > 0 && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                סטטוס:{" "}
                {filters.status.length === 1
                  ? ""
                  : `(${filters.status.length})`}
                {filters.status.length === 1 && (
                  <span className="flex items-center">
                    {getStatusIcon(filters.status[0])}
                    {filters.status[0] === "PENDING_FIRST_PARTY"
                      ? "ממתין לצד א׳"
                      : filters.status[0] === "PENDING_SECOND_PARTY"
                      ? "ממתין לצד ב׳"
                      : filters.status[0]}
                  </span>
                )}
              </span>
              <button
                onClick={() => handleRemoveFilter("status")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.userId && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>משתתף מסוים</span>
              <button
                onClick={() => handleRemoveFilter("userId")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;
--- End of Content for SuggestionActionBar.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  Users,
  CheckCircle,
  Clock,
  Calendar,
  AlertCircle,
  Ban,
  X,
} from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion, SuggestionFilters } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  onClick?: () => void;
  isClickable?: boolean;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
  onFilterChange?: (filter: Partial<SuggestionFilters>) => void;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
  onClick,
  isClickable = false,
}) => (
  <Card
    className={`p-4 ${className} ${
      isClickable ? "cursor-pointer hover:shadow-md transition-shadow" : ""
    }`}
    onClick={onClick}
  >
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value > 0 ? "+" : ""}
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
  onFilterChange,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter((s) => s.category === "ACTIVE").length;
    const pending = suggestions.filter((s) => s.category === "PENDING").length;
    const history = suggestions.filter((s) => s.category === "HISTORY").length;

    const approvedByFirst = suggestions.filter(
      (s) => s.status === "FIRST_PARTY_APPROVED"
    ).length;
    const approvedBySecond = suggestions.filter(
      (s) => s.status === "SECOND_PARTY_APPROVED"
    ).length;
    const declined = suggestions.filter(
      (s) =>
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
    ).length;
    const expired = suggestions.filter((s) => s.status === "EXPIRED").length;
    const dating = suggestions.filter((s) => s.status === "DATING").length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Group suggestions by month
    const monthlyData = suggestions.reduce(
      (acc, s) => {
        const month = new Date(s.createdAt).getMonth();
        const year = new Date(s.createdAt).getFullYear();
        const key = `${year}-${month + 1}`;

        if (!acc[key]) {
          acc[key] = {
            month: new Date(year, month).toLocaleString("he", {
              month: "short",
            }),
            year: year,
            count: 0,
            active: 0,
            pending: 0,
            success: 0,
            declined: 0,
          };
        }

        acc[key].count += 1;

        if (s.category === "ACTIVE") acc[key].active += 1;
        if (s.category === "PENDING") acc[key].pending += 1;
        if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
        if (
          s.status === "FIRST_PARTY_DECLINED" ||
          s.status === "SECOND_PARTY_DECLINED"
        ) {
          acc[key].declined += 1;
        }

        return acc;
      },
      {} as Record<
        string,
        {
          month: string;
          year: number;
          count: number;
          active: number;
          pending: number;
          success: number;
          declined: number;
        }
      >
    );

    // Convert to array and sort by date
    const monthlyArray = Object.values(monthlyData).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      return a.month.localeCompare(b.month);
    });

    // Calculate trends
    const calculateTrend = (currentValue: number, previousValue: number) => {
      if (previousValue === 0) return currentValue > 0 ? 100 : 0;
      return Math.round(((currentValue - previousValue) / previousValue) * 100);
    };

    // Calculate success rate
    const successRate = total > 0 ? Math.round((success / total) * 100) : 0;

    // Get current month stats vs previous month for trend
    let activeTrend = 0;
    let pendingTrend = 0;
    let successTrend = 0;

    if (monthlyArray.length >= 2) {
      const currentMonth = monthlyArray[monthlyArray.length - 1];
      const previousMonth = monthlyArray[monthlyArray.length - 2];

      activeTrend = calculateTrend(currentMonth.active, previousMonth.active);
      pendingTrend = calculateTrend(
        currentMonth.pending,
        previousMonth.pending
      );
      successTrend = calculateTrend(
        currentMonth.success,
        previousMonth.success
      );
    }

    return {
      total,
      active,
      pending,
      history,
      approvedByFirst,
      approvedBySecond,
      declined,
      expired,
      dating,
      success,
      successRate,
      byStatus,
      monthlyData: monthlyArray,
      trends: {
        active: activeTrend,
        pending: pendingTrend,
        success: successTrend,
      },
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() => onFilterChange && onFilterChange({})}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: [
                "DATING",
                "FIRST_PARTY_APPROVED",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            })
          }
        />
        <StatsCard
          icon={Clock}
          title="ממתינות לתגובה"
          value={stats.pending}
          trend={{
            value: stats.trends.pending,
            isPositive: stats.trends.pending >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY"],
            })
          }
        />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${stats.successRate}%`}
          trend={{
            value: stats.trends.success,
            isPositive: stats.trends.success >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING", "ENGAGED", "MARRIED"],
            })
          }
        />
      </div>

      {/* Action Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-3 mt-4">
        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-yellow-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-yellow-600" />
            <div className="text-xs">ממתין לצד א׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_FIRST_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-blue-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_SECOND_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-blue-600" />
            <div className="text-xs">ממתין לצד ב׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_SECOND_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-red-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <X className="w-4 h-4 text-red-600" />
            <div className="text-xs">הצעות שנדחו</div>
            <div className="font-bold ml-auto">{stats.declined}</div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-pink-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Calendar className="w-4 h-4 text-pink-600" />
            <div className="text-xs">בתהליך היכרות</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["DATING"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-gray-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["EXPIRED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Ban className="w-4 h-4 text-gray-600" />
            <div className="text-xs">פג תוקף</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["EXPIRED"] || 0}
            </div>
          </div>
        </Card>
      </div>

      {/* מגמה חודשית נשארת כאן אבל עכשיו היא מוצגת בדיאלוג מודלי */}
      <div className="hidden">
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={stats.monthlyData}
                margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip
                  formatter={(value) => [`${value} הצעות`, ""]}
                  labelFormatter={(label) => `חודש ${label}`}
                />
                <Legend />
                <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
                <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
                <Bar dataKey="success" name="הצלחות" fill="#10B981" />
                <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;
--- End of Content for SuggestionsStats.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx
--------------------------------------------------------------------------------
Content:
// SuggestionDetailsDialog.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ProfileCard } from "@/app/components/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  AlertCircle,
  CheckCircle,
  XCircle,
  MessageCircle,
  Send,
  RefreshCw,
  Edit,
  Calendar,
  Clock,
  Download,
  AlarmClock,
  Trash2,
  MapPin,
  Mail,
  Phone,
  User,
  ExternalLink,
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { MatchSuggestionStatus } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";
import Image from "next/image";

interface DialogActionData extends ActionAdditionalData {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyId?: string;
  type?: string;
  partyType?: "first" | "second" | "both";
}

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  onAction: (action: string, data?: DialogActionData) => void;
}

// Map status to its display info
const getStatusInfo = (status: MatchSuggestionStatus) => {
  const statusMap: Record<
    string,
    { label: string; icon: React.ElementType; color: string }
  > = {
    DRAFT: { label: "טיוטה", icon: Edit, color: "text-gray-600" },
    PENDING_FIRST_PARTY: {
      label: "ממתין לתשובת צד א׳",
      icon: Clock,
      color: "text-yellow-600",
    },
    FIRST_PARTY_APPROVED: {
      label: "צד א׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    FIRST_PARTY_DECLINED: {
      label: "צד א׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    PENDING_SECOND_PARTY: {
      label: "ממתין לתשובת צד ב׳",
      icon: Clock,
      color: "text-blue-600",
    },
    SECOND_PARTY_APPROVED: {
      label: "צד ב׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    SECOND_PARTY_DECLINED: {
      label: "צד ב׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    AWAITING_MATCHMAKER_APPROVAL: {
      label: "ממתין לאישור שדכן",
      icon: AlertCircle,
      color: "text-purple-600",
    },
    CONTACT_DETAILS_SHARED: {
      label: "פרטי קשר שותפו",
      icon: Send,
      color: "text-purple-600",
    },
    AWAITING_FIRST_DATE_FEEDBACK: {
      label: "ממתין למשוב פגישה",
      icon: MessageCircle,
      color: "text-orange-600",
    },
    DATING: {
      label: "בתהליך היכרות",
      icon: Calendar,
      color: "text-pink-600",
    },
    EXPIRED: { label: "פג תוקף", icon: AlarmClock, color: "text-gray-600" },
    CLOSED: { label: "סגור", icon: XCircle, color: "text-gray-600" },
  };
  return (
    statusMap[status] || {
      label: status as string,
      icon: AlertCircle as React.ElementType,
      color: "text-gray-600",
    }
  );
};

// Status groups for the progress indicator
const statusGroups = [
  ["DRAFT", "PENDING_FIRST_PARTY"],
  ["FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY"],
  ["SECOND_PARTY_APPROVED", "AWAITING_MATCHMAKER_APPROVAL"],
  ["CONTACT_DETAILS_SHARED", "AWAITING_FIRST_DATE_FEEDBACK"],
  ["DATING", "ENGAGED", "MARRIED"],
];
// הוספת מיפוי מלא של כל הסטטוסים האפשריים
const getAllStatusLabels = () => {
  // יצירת מיפוי של כל הסטטוסים האפשריים לפי הסכמה
  const statusLabels: Record<MatchSuggestionStatus, string> = {
    DRAFT: "טיוטה",
    PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
    FIRST_PARTY_APPROVED: "צד א׳ אישר",
    FIRST_PARTY_DECLINED: "צד א׳ דחה",
    PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
    SECOND_PARTY_APPROVED: "צד ב׳ אישר",
    SECOND_PARTY_DECLINED: "צד ב׳ דחה",
    AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
    CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
    AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
    THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
    PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
    ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
    MEETING_PENDING: "ממתין לקביעת פגישה",
    MEETING_SCHEDULED: "פגישה נקבעה",
    MATCH_APPROVED: "ההצעה אושרה",
    MATCH_DECLINED: "ההצעה נדחתה",
    DATING: "בתהליך היכרות",
    ENGAGED: "מאורסים",
    MARRIED: "נישאו",
    EXPIRED: "פג תוקף",
    CLOSED: "סגור",
    CANCELLED: "בוטל",
  };

  return statusLabels;
};
// Helper to determine if a status change is possible
const canChangeStatus = (
  currentStatus: MatchSuggestionStatus
): MatchSuggestionStatus[] => {
  // Status changes that are allowed directly by the matchmaker
  const allowedChanges: Partial<
    Record<MatchSuggestionStatus, MatchSuggestionStatus[]>
  > = {
    // סטטוסים קיימים
    DRAFT: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_FIRST_PARTY: [
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    FIRST_PARTY_APPROVED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    FIRST_PARTY_DECLINED: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_SECOND_PARTY: [
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    SECOND_PARTY_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    SECOND_PARTY_DECLINED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    CONTACT_DETAILS_SHARED: [
      "AWAITING_FIRST_DATE_FEEDBACK",
      "DATING",
      "CANCELLED",
      "CLOSED",
    ],
    AWAITING_FIRST_DATE_FEEDBACK: ["DATING", "CANCELLED", "CLOSED"],
    DATING: ["ENGAGED", "CLOSED"],
    ENGAGED: ["MARRIED", "CLOSED"],
    MARRIED: ["CLOSED"],
    EXPIRED: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY", "CLOSED"],
    CANCELLED: ["DRAFT"],
    CLOSED: [],

    // הוספת הסטטוסים החסרים
    AWAITING_MATCHMAKER_APPROVAL: [
      "CONTACT_DETAILS_SHARED",
      "CANCELLED",
      "CLOSED",
    ],
    THINKING_AFTER_DATE: [
      "PROCEEDING_TO_SECOND_DATE",
      "ENDED_AFTER_FIRST_DATE",
      "CLOSED",
    ],
    PROCEEDING_TO_SECOND_DATE: ["DATING", "CLOSED"],
    ENDED_AFTER_FIRST_DATE: ["CLOSED"],
    MEETING_PENDING: ["MEETING_SCHEDULED", "CANCELLED", "CLOSED"],
    MEETING_SCHEDULED: ["AWAITING_FIRST_DATE_FEEDBACK", "CANCELLED", "CLOSED"],
    MATCH_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    MATCH_DECLINED: ["CLOSED"],
  };

  return allowedChanges[currentStatus] || [];
};

const formatDateSafely = (
  dateInput: Date | string | null | undefined
): string => {
  if (!dateInput) return "לא נקבע";

  // Ensure we're working with a Date object
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;

  // Validate that the date is valid before formatting
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    return "תאריך לא תקין";
  }

  return new Intl.DateTimeFormat("he-IL", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(date);
};

const getDaysRemaining = (
  deadline: Date | string | null | undefined
): number | null => {
  if (!deadline) return null;

  // Convert string to Date if needed
  const deadlineDate =
    typeof deadline === "string" ? new Date(deadline) : deadline;

  // Validate date
  if (!(deadlineDate instanceof Date) || isNaN(deadlineDate.getTime())) {
    return null;
  }

  const today = new Date();
  const diffTime = deadlineDate.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
};

// Get the status group index for progress indicator
const getStatusGroupIndex = (status: MatchSuggestionStatus): number => {
  for (let i = 0; i < statusGroups.length; i++) {
    if (statusGroups[i].includes(status)) {
      return i;
    }
  }
  return -1;
};

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [statusChangeNote, setStatusChangeNote] = useState("");
  const [newStatus, setNewStatus] = useState<MatchSuggestionStatus | null>(
    null
  );
  const [showStatusChange, setShowStatusChange] = useState(false);

  // Calculate allowed status changes based on current status
  const allowedStatusChanges = suggestion
    ? canChangeStatus(suggestion.status as MatchSuggestionStatus)
    : [];

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  // Handle status change
  const handleStatusChange = async () => {
    if (!newStatus || !suggestion) return;

    setIsLoading(true);
    try {
      console.log(
        `שולח בקשה לשינוי סטטוס: ${newStatus} עם הערות: ${
          statusChangeNote || "ללא הערות"
        }`
      );
      // עדכון הקומפוננטה ההורה
      onAction("changeStatus", {
        suggestionId: suggestion.id,
        newStatus,
        notes: statusChangeNote,
      });

      // איפוס מצב הטופס
      setShowStatusChange(false);
      setStatusChangeNote("");
      setNewStatus(null);
    } catch (error) {
      console.error("Error changing status:", error);
      toast.error(
        `שגיאה בעדכון הסטטוס: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  };

  if (!suggestion) return null;

  // Get status display info
  const statusInfo = getStatusInfo(suggestion.status as MatchSuggestionStatus);
  const StatusIcon = statusInfo.icon;

  // Format suggestion dates
  const createdDate = suggestion.createdAt;
  const lastActivityDate = suggestion.lastActivity;
  const decisionDeadlineDate = suggestion.decisionDeadline
    ? suggestion.decisionDeadline
    : null;

  // Days remaining for decision if applicable
  const daysRemaining = decisionDeadlineDate
    ? getDaysRemaining(decisionDeadlineDate)
    : null;

  // Get status progress index for the progress indicator
  const statusGroupIndex = getStatusGroupIndex(
    suggestion.status as MatchSuggestionStatus
  );

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="max-w-6xl max-h-[90vh] flex flex-col p-0"
        style={{ direction: "rtl" }}
      >
        {/* Header with Progress Bar */}
        <div className="bg-gradient-to-r from-slate-50 to-white border-b flex-shrink-0">
          <DialogHeader className="p-6 pb-3">
            <div className="flex items-center justify-between">
              <div>
                <DialogTitle className="text-2xl font-bold">
                  הצעת שידוך #{suggestion.id.toString().split("-")[0]}
                </DialogTitle>
                <DialogDescription className="text-lg mt-1">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} ו
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName}
                </DialogDescription>
              </div>
              <div className="flex items-center gap-3">
                <Badge
                  className={`px-3 py-1.5 ${statusInfo.color} flex items-center gap-1 text-sm shadow-sm`}
                >
                  <StatusIcon className="w-4 h-4" />
                  {statusInfo.label}
                </Badge>
                <Badge
                  variant="outline"
                  className={`px-3 shadow-sm ${
                    suggestion.priority === "URGENT"
                      ? "bg-red-50 text-red-600 border-red-200"
                      : suggestion.priority === "HIGH"
                      ? "bg-orange-50 text-orange-600 border-orange-200"
                      : suggestion.priority === "MEDIUM"
                      ? "bg-blue-50 text-blue-600 border-blue-200"
                      : "bg-gray-50 text-gray-600 border-gray-200"
                  }`}
                >
                  {suggestion.priority === "URGENT"
                    ? "דחוף"
                    : suggestion.priority === "HIGH"
                    ? "עדיפות גבוהה"
                    : suggestion.priority === "MEDIUM"
                    ? "עדיפות רגילה"
                    : "עדיפות נמוכה"}
                </Badge>
              </div>
            </div>
          </DialogHeader>

          {/* Status Progress Indicator */}
          <div className="px-6 pb-4">
            <div className="relative flex items-center justify-between w-full h-3 bg-gray-100 rounded-full mt-4">
              {statusGroupIndex >= 0 && (
                <div
                  className="absolute h-3 bg-gradient-to-r from-blue-400 to-blue-600 rounded-full"
                  style={{
                    width: `${Math.min(
                      ((statusGroupIndex + 1) / statusGroups.length) * 100,
                      100
                    )}%`,
                  }}
                ></div>
              )}
              {statusGroups.map((_, index) => (
                <div
                  key={index}
                  className={`relative z-10 w-6 h-6 rounded-full flex items-center justify-center border-2 ${
                    index <= statusGroupIndex
                      ? "bg-blue-600 border-blue-700 text-white"
                      : "bg-white border-gray-300"
                  }`}
                >
                  {index + 1}
                </div>
              ))}
            </div>
            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
              <span>יצירת הצעה</span>
              <span>אישור ראשוני</span>
              <span>אישור סופי</span>
              <span>שיתוף פרטים</span>
              <span>בתהליך היכרות</span>
            </div>
          </div>
        </div>
        {/* Main Content Area */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex-1 flex flex-col overflow-hidden"
        >
          <TabsList className="px-6 pt-2 border-b justify-end gap-1 flex-shrink-0">
            <TabsTrigger
              value="overview"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              סקירה כללית
            </TabsTrigger>
            <TabsTrigger
              value="firstParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד ראשון
            </TabsTrigger>
            <TabsTrigger
              value="secondParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד שני
            </TabsTrigger>
            <TabsTrigger
              value="timeline"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              ציר זמן
            </TabsTrigger>
            <TabsTrigger
              value="communication"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              תקשורת
            </TabsTrigger>
            <TabsTrigger
              value="actions"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              פעולות
            </TabsTrigger>
          </TabsList>

          <div className="flex-1 overflow-y-auto">
            {/* Overview Tab */}

            <TabsContent
              value="overview"
              className="p-0 m-0 h-full overflow-auto"
            >
              <div className="p-6">
                {/* שינוי 1: שינוי המבנה כך שפרטי ההצעה יהיו בחלק העליון ושני הצדדים יהיו זה לצד זה */}
                <div className="space-y-3">
                  {/* פרטי הצעה - עיצוב מסודר וקומפקטי */}
                  <div className="bg-white rounded-xl shadow-sm border p-4 mb-3 hover:shadow-md transition-shadow">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="text-md font-semibold flex items-center">
                        <Calendar className="w-4 h-4 ml-1 text-blue-600" />
                        פרטי הצעה
                      </h3>
                      <Badge
                        className={`${statusInfo.color} px-2 py-0.5 text-xs`}
                      >
                        <StatusIcon className="w-3 h-3 ml-1" />
                        {statusInfo.label}
                      </Badge>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">תאריך יצירה:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(createdDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">עדכון אחרון:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(lastActivityDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">שדכן:</span>
                        <span className="font-medium mr-1">
                          {`${suggestion.matchmaker?.firstName} ${suggestion.matchmaker?.lastName}`}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">דחיפות:</span>
                        <span
                          className={`font-medium mr-1 ${
                            suggestion.priority === "URGENT"
                              ? "text-red-600"
                              : suggestion.priority === "HIGH"
                              ? "text-orange-600"
                              : suggestion.priority === "MEDIUM"
                              ? "text-blue-600"
                              : "text-gray-600"
                          }`}
                        >
                          {suggestion.priority === "URGENT"
                            ? "דחוף"
                            : suggestion.priority === "HIGH"
                            ? "עדיפות גבוהה"
                            : suggestion.priority === "MEDIUM"
                            ? "עדיפות רגילה"
                            : "עדיפות נמוכה"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד תגובה:</span>
                        <span className="font-medium mr-1">
                          {suggestion.responseDeadline
                            ? formatDateSafely(suggestion.responseDeadline)
                            : "לא נקבע"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד להחלטה:</span>
                        <span
                          className={
                            daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED"
                              ? "text-red-600 font-medium"
                              : "font-medium"
                          }
                        >
                          {decisionDeadlineDate
                            ? formatDateSafely(decisionDeadlineDate)
                            : "לא נקבע"}
                          {daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED" && (
                              <span className="mr-1 text-red-600 text-xs">
                                (
                                {daysRemaining === 0
                                  ? "היום!"
                                  : `נותרו ${daysRemaining} ימים`}
                                )
                              </span>
                            )}
                        </span>
                      </div>
                    </div>

                    <div className="flex justify-end mt-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowStatusChange(true)}
                        disabled={allowedStatusChanges.length === 0}
                        className="text-blue-600 border-blue-200 hover:bg-blue-50 text-xs py-1 h-7"
                      >
                        <RefreshCw className="w-3 h-3 ml-1" />
                        שנה סטטוס
                      </Button>
                    </div>
                  </div>

                  {/* שינוי 2: כרטיסי הצדדים מסודרים זה לצד זה בגריד עם 2 עמודות */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* First Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-blue-800">
                        <User className="w-5 h-5 ml-2 text-blue-600" />
                        צד א׳: {suggestion.firstParty.firstName}{" "}
                        {suggestion.firstParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.firstParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-blue-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.firstParty.firstName}{" "}
                            {suggestion.firstParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.firstPartySent
                              ? formatDateSafely(suggestion.firstPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "FIRST_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "FIRST_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_FIRST_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "FIRST_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "FIRST_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_FIRST_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.firstPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-blue-50 rounded-lg p-3 text-sm border border-blue-100">
                            {suggestion.firstPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-blue-200 hover:bg-blue-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_FIRST_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-yellow-500 hover:bg-yellow-600"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.firstParty.id,
                                partyType: "first",
                              })
                            }
                          >
                            <AlertCircle className="w-4 h-4 ml-2" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>

                    {/* Second Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-purple-800">
                        <User className="w-5 h-5 ml-2 text-purple-600" />
                        צד ב׳: {suggestion.secondParty.firstName}{" "}
                        {suggestion.secondParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.secondParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-purple-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.secondParty.firstName}{" "}
                            {suggestion.secondParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.secondPartySent
                              ? formatDateSafely(suggestion.secondPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "SECOND_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "SECOND_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_SECOND_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "SECOND_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "SECOND_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_SECOND_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.secondPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-purple-50 rounded-lg p-3 text-sm border border-purple-100">
                            {suggestion.secondPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-purple-200 hover:bg-purple-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_SECOND_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-purple-600 hover:bg-purple-700"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.secondParty.id,
                                partyType: "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* מידע נוסף */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
                    {/* Matching Reason Card */}
                    {suggestion.matchingReason && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <User className="w-5 h-5 ml-2 text-green-600" />
                          סיבת ההתאמה
                        </h3>
                        <div className="bg-green-50 rounded-lg border border-green-100 p-4 text-gray-700">
                          {suggestion.matchingReason}
                        </div>
                      </div>
                    )}

                    {/* Internal Notes */}
                    {suggestion.internalNotes && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <AlertCircle className="w-5 h-5 ml-2 text-amber-600" />
                          הערות פנימיות
                        </h3>
                        <div className="bg-amber-50 rounded-lg border border-amber-100 p-4 text-gray-700">
                          {suggestion.internalNotes}
                        </div>
                      </div>
                    )}

                    {/* Quick Actions */}
                    <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center">
                        <RefreshCw className="w-5 h-5 ml-2 text-gray-600" />
                        פעולות מהירות
                      </h3>

                      <div className="grid grid-cols-2 gap-2">
                        <Button
                          variant="outline"
                          className="justify-start"
                          onClick={() =>
                            onAction("edit", { suggestionId: suggestion.id })
                          }
                        >
                          <Edit className="w-4 h-4 ml-1" />
                          ערוך הצעה
                        </Button>

                        {(suggestion.status === "PENDING_FIRST_PARTY" ||
                          suggestion.status === "PENDING_SECOND_PARTY") && (
                          <Button
                            variant="outline"
                            className="justify-start"
                            onClick={() =>
                              onAction("sendReminder", {
                                suggestionId: suggestion.id,
                                type:
                                  suggestion.status === "PENDING_FIRST_PARTY"
                                    ? "first"
                                    : "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}

                        {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                          suggestion.status === "SECOND_PARTY_APPROVED") && (
                          <Button
                            variant="default"
                            className="justify-start bg-green-600 hover:bg-green-700"
                            onClick={() =>
                              onAction("shareContacts", {
                                suggestionId: suggestion.id,
                              })
                            }
                          >
                            <ExternalLink className="w-4 h-4 ml-1" />
                            שתף פרטי קשר
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* First Party Tab */}
            <TabsContent value="firstParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-blue-800">
                      {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-blue-100 text-blue-700 border-blue-200">
                      צד א׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.firstParty.images.find((img) => img.isMain)
                            ?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-blue-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty?.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.birthDate
                              ? new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-blue-200 hover:bg-blue-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.firstParty.id,
                          partyType: "first",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_FIRST_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד ראשון
                      </Button>
                    )}

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד שני
                      </Button>
                    )}

                    {suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyType: "both",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח בקשת עדכון מפגש
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.firstParty.profile}
                  images={suggestion.firstParty.images}
                  questionnaire={firstPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-blue-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.firstParty.firstName}
                  </h3>
                  {suggestion.firstPartyNotes ? (
                    <p>{suggestion.firstPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Second Party Tab */}
            <TabsContent value="secondParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-purple-800">
                      {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-purple-100 text-purple-700 border-purple-200">
                      צד ב׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.secondParty.images.find(
                            (img) => img.isMain
                          )?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-purple-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.birthDate
                              ? new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-purple-200 hover:bg-purple-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.secondParty.id,
                          partyType: "second",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="flex-1 bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-1" />
                        שלח תזכורת
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.secondParty.profile}
                  images={suggestion.secondParty.images}
                  questionnaire={secondPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-purple-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.secondParty.firstName}
                  </h3>
                  {suggestion.secondPartyNotes ? (
                    <p>{suggestion.secondPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Timeline Tab */}
            <TabsContent value="timeline" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 mb-4">
                  <h3 className="text-lg font-semibold flex items-center">
                    <Calendar className="w-5 h-5 ml-2 text-blue-600" />
                    התקדמות ההצעה
                  </h3>
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="p-2 rounded-full bg-blue-100 mr-2">
                        <Clock className="w-5 h-5 text-blue-600" />
                      </div>
                      <div>
                        <div className="font-medium">
                          נוצר: {formatDateSafely(suggestion.createdAt)}
                        </div>
                        <div className="text-sm text-gray-500">
                          פעילות אחרונה:{" "}
                          {formatDateSafely(suggestion.lastActivity)}
                        </div>
                      </div>
                    </div>
                    <Badge
                      className={`px-3 py-1.5 flex items-center gap-1 ${statusInfo.color}`}
                    >
                      <StatusIcon className="w-4 h-4" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border p-5">
                  <h3 className="text-lg font-semibold mb-4">
                    היסטוריית סטטוסים
                  </h3>

                  <ScrollArea className="h-[400px] pr-4">
                    {isLoading ? (
                      <div className="flex items-center justify-center h-32">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-700"></div>
                      </div>
                    ) : (
                      <Timeline
                        items={(suggestion?.statusHistory || []).map(
                          (history) => ({
                            title: getStatusInfo(
                              history.status as MatchSuggestionStatus
                            ).label,
                            description: history.notes || "אין הערות",
                            date:
                              typeof history.createdAt === "string"
                                ? new Date(history.createdAt)
                                : history.createdAt,
                            icon: history.status.includes("APPROVED")
                              ? CheckCircle
                              : history.status.includes("DECLINED")
                              ? XCircle
                              : history.status.includes("PENDING")
                              ? Clock
                              : AlertCircle,
                            iconColor: history.status.includes("APPROVED")
                              ? "text-green-600"
                              : history.status.includes("DECLINED")
                              ? "text-red-600"
                              : history.status.includes("PENDING")
                              ? "text-yellow-600"
                              : "text-blue-600",
                          })
                        )}
                      />
                    )}
                  </ScrollArea>

                  <div className="mt-4 flex justify-end">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() =>
                        onAction("exportHistory", {
                          suggestionId: suggestion.id,
                        })
                      }
                    >
                      <Download className="w-4 h-4 ml-1" />
                      ייצא היסטוריה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* Communication Tab */}
            <TabsContent value="communication" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-blue-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">תקשורת</h3>
                  <p className="text-gray-600">
                    ניהול התקשורת עם הצדדים השונים בהצעה. שליחת הודעות ותזכורות.
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* First Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-blue-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-blue-600" />
                      תקשורת עם {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full justify-start border-blue-200 hover:bg-blue-50"
                        onClick={() =>
                          onAction("message", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <MessageCircle className="w-4 h-4 ml-2" />
                        שלח הודעה
                      </Button>

                      {suggestion.status === "PENDING_FIRST_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>

                  {/* Second Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-purple-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-purple-600" />
                      תקשורת עם {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full"
                        onClick={() =>
                          onAction("edit", {
                            suggestionId: suggestion.id,
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <Edit className="w-4 h-4 ml-2" />
                        ערוך פרטי הצעה
                      </Button>

                      {suggestion.status === "PENDING_SECOND_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {/* Meeting Arrangement Section */}
                {(suggestion.status === "CONTACT_DETAILS_SHARED" ||
                  suggestion.status === "DATING") && (
                  <div className="mt-6 bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Calendar className="w-5 h-5 ml-2 text-pink-600" />
                      תיאום פגישה
                    </h4>
                    <div className="space-y-3">
                      <p className="text-gray-600">
                        סיוע בתיאום פגישה בין הצדדים ותיעוד מועדי הפגישות
                      </p>
                      <div className="flex gap-2">
                        <Button
                          className="flex-1 bg-pink-600 hover:bg-pink-700"
                          onClick={() =>
                            onAction("scheduleMeeting", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Calendar className="w-4 h-4 ml-2" />
                          תאם פגישה חדשה
                        </Button>
                        <Button
                          variant="outline"
                          className="flex-1"
                          onClick={() =>
                            onAction("viewMeetings", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Clock className="w-4 h-4 ml-2" />
                          צפה בפגישות קודמות
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </TabsContent>

            {/* Actions Tab */}
            <TabsContent value="actions" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-gray-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">פעולות נוספות</h3>
                  <p className="text-gray-600">
                    פעולות נוספות שניתן לבצע על הצעת השידוך
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {/* Status Change */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-blue-100 w-fit mb-3">
                      <RefreshCw className="w-6 h-6 text-blue-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">שינוי סטטוס</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עדכון סטטוס ההצעה בהתאם להתקדמות התהליך
                    </p>
                    <Button
                      className="w-full"
                      onClick={() => setShowStatusChange(true)}
                      disabled={allowedStatusChanges.length === 0}
                    >
                      <RefreshCw className="w-4 h-4 ml-2" />
                      שנה סטטוס
                    </Button>
                  </div>

                  {/* Edit Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-amber-100 w-fit mb-3">
                      <Edit className="w-6 h-6 text-amber-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">עריכת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עריכת פרטי ההצעה, סיבת ההתאמה והערות
                    </p>
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() =>
                        onAction("edit", { suggestionId: suggestion.id })
                      }
                    >
                      <Edit className="w-4 h-4 ml-2" />
                      ערוך פרטי הצעה
                    </Button>
                  </div>

                  {/* Delete Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-red-100 w-fit mb-3">
                      <Trash2 className="w-6 h-6 text-red-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">מחיקת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      מחיקת ההצעה לצמיתות מהמערכת
                    </p>
                    <Button
                      variant="outline"
                      className="border-red-200 hover:bg-red-50 text-red-600"
                      onClick={() =>
                        onAction("delete", { suggestionId: suggestion.id })
                      }
                    >
                      <Trash2 className="w-4 h-4 ml-1" />
                      מחק הצעה
                    </Button>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Resend to Both Parties */}
                  {canChangeStatus(
                    suggestion.status as MatchSuggestionStatus
                  ).includes("PENDING_FIRST_PARTY") && (
                    <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                      <h4 className="text-lg font-semibold mb-3 flex items-center">
                        <Send className="w-5 h-5 ml-2 text-purple-600" />
                        שליחה מחדש
                      </h4>
                      <p className="text-sm text-gray-600 mb-3">
                        שליחת ההצעה מחדש לשני הצדדים
                      </p>
                      <Button
                        className="w-full bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("resendToAll", {
                            suggestionId: suggestion.id,
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-2" />
                        שלח מחדש לשני הצדדים
                      </Button>
                    </div>
                  )}

                  {/* Export Suggestion Details */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Download className="w-5 h-5 ml-2 text-green-600" />
                      ייצוא פרטי הצעה
                    </h4>
                    <p className="text-sm text-gray-600 mb-3">
                      ייצוא כל פרטי ההצעה בפורמט PDF או CSV
                    </p>
                    <Button
                      variant="outline"
                      className="w-full border-green-200 hover:bg-green-50 text-green-700"
                      onClick={() =>
                        onAction("export", { suggestionId: suggestion.id })
                      }
                    >
                      <Download className="w-4 h-4 ml-2" />
                      ייצא פרטי הצעה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>
          </div>
        </Tabs>
        {/* Status Change Dialog */}
        {showStatusChange && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-xl max-w-md w-full shadow-lg">
              <h3 className="text-xl font-bold mb-4 flex items-center">
                <RefreshCw className="w-5 h-5 ml-2 text-blue-600" />
                שינוי סטטוס הצעה
              </h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס נוכחי
                  </label>
                  <div className="flex items-center p-2 bg-gray-50 rounded border">
                    <StatusIcon
                      className={`w-5 h-5 ml-2 ${statusInfo.color}`}
                    />
                    <span className="font-medium">{statusInfo.label}</span>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס חדש
                  </label>
                  <Select
                    value={newStatus || undefined}
                    onValueChange={(value) => {
                      console.log("Selected new status:", value);
                      setNewStatus(value as MatchSuggestionStatus);
                    }}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="בחר/י סטטוס חדש" />
                    </SelectTrigger>
                    <SelectContent className="max-h-80 overflow-y-auto">
                      {/* מציג את כל הסטטוסים האפשריים במערכת */}
                      {Object.entries(getAllStatusLabels()).map(
                        ([status, label]) => (
                          <SelectItem key={status} value={status}>
                            {label}
                          </SelectItem>
                        )
                      )}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    הערות לשינוי סטטוס
                  </label>
                  <Textarea
                    value={statusChangeNote}
                    onChange={(e) => setStatusChangeNote(e.target.value)}
                    placeholder="הערות אופציונליות לשינוי הסטטוס..."
                    className="min-h-[100px] resize-none"
                  />
                </div>

                <div className="flex justify-end gap-2 pt-2">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowStatusChange(false);
                      setNewStatus(null);
                      setStatusChangeNote("");
                    }}
                  >
                    ביטול
                  </Button>
                  <Button
                    onClick={handleStatusChange}
                    disabled={!newStatus || isLoading}
                    className="bg-blue-600 hover:bg-blue-700"
                  >
                    {isLoading ? (
                      <>
                        <div className="h-4 w-4 ml-2 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                        מעדכן...
                      </>
                    ) : (
                      "שמור שינוי"
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}
        <DialogFooter className="px-6 py-4 border-t bg-gray-50">
          <div className="flex justify-between w-full">
            <Button
              variant="outline"
              className="border-red-200 hover:bg-red-50 text-red-600"
              onClick={() =>
                onAction("delete", { suggestionId: suggestion.id })
              }
            >
              <Trash2 className="w-4 h-4 ml-1" />
              מחק הצעה
            </Button>

            <div className="flex gap-2">
              <Button variant="outline" onClick={onClose}>
                סגור
              </Button>
              <Button
                // תיקון: המקום השלישי בו צריך לוודא שהפונקציה מופעלת נכון
                onClick={() => setShowStatusChange(true)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <RefreshCw className="w-4 h-4 ml-1" />
                עדכן סטטוס
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;
--- End of Content for SuggestionDetailsDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks\useMatchmaking.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS } from '../../new/constants/matchingCriteria';
import type { User } from '@/types/next-auth';
// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: User[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: User;
  candidateB: User;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: User;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile?.gender === candidateB.profile?.gender ||
          candidateA.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA.profile, candidateB.profile);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;
--- End of Content for useMatchmaking.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Users } from "lucide-react";

import type { Suggestion, SuggestionFilters } from "@/types/suggestions";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: SuggestionFilters;
  searchQuery: string;
  type: "active" | "pending" | "history";
  onSuggestionDeleted?: (id: string) => void;
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
  onSuggestionDeleted,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [, setShowDeleteDialog] = useState(false);
  const [suggestionToDelete, setSuggestionToDelete] = useState<string | null>(
    null
  );

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Priority filter
      if (
        filters.priority?.length &&
        !filters.priority.includes(suggestion.priority)
      ) {
        return false;
      }

      // Date range filter
      if (filters.dateRange) {
        const createdAt = new Date(suggestion.createdAt);
        if (
          createdAt < filters.dateRange.start ||
          createdAt > filters.dateRange.end
        ) {
          return false;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const confirmDelete = async () => {
    if (!suggestionToDelete) return;

    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionToDelete}/delete`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to delete suggestion");
      }

      toast.success("ההצעה נמחקה בהצלחה");
      if (onSuggestionDeleted) {
        onSuggestionDeleted(suggestionToDelete);
      }
    } catch (error) {
      console.error("Error deleting suggestion:", error);
      toast.error("שגיאה במחיקת ההצעה");
    } finally {
      setShowDeleteDialog(false);
      setSuggestionToDelete(null);
    }
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                {/* Rest of the JSX remains the same */}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />

      <AlertDialog>
        {" "}
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
            <AlertDialogDescription>
              פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              מחיקה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default ManagerSuggestionsList;
--- End of Content for ManagerSuggestionsList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useMemo } from "react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Search, Filter, SortDesc } from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";
import SuggestionCard from "../cards/SuggestionCard";
import { LoadingContainer } from "../../new/shared/LoadingStates";
import type {
  Suggestion,
  ActionAdditionalData,
  SuggestionStatusHistory,
} from "@/types/suggestions";

interface PartyInfo {
  id: string;
  firstName: string;
  lastName: string;
  profile: UserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: SuggestionStatusHistory[]; // הוספת השדה החסר
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  isLoading?: boolean;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const SORT_OPTIONS = [
  { value: "latest", label: "החדשים ביותר" },
  { value: "oldest", label: "הישנים ביותר" },
  { value: "deadline", label: "לפי תאריך יעד" },
  { value: "priority", label: "לפי דחיפות" },
];

const STATUS_OPTIONS = [
  { value: "PENDING_FIRST_PARTY", label: "ממתין לצד א׳" },
  { value: "PENDING_SECOND_PARTY", label: "ממתין לצד ב׳" },
  { value: "FIRST_PARTY_APPROVED", label: "צד א׳ אישר" },
  { value: "SECOND_PARTY_APPROVED", label: "צד ב׳ אישר" },
  { value: "CONTACT_DETAILS_SHARED", label: "פרטי קשר שותפו" },
  { value: "DATING", label: "בתהליך היכרות" },
];

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions,
  isLoading = false,
  onAction,
  className,
}) => {
  // Filters state
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState("latest");
  const [statusFilter, setStatusFilter] = useState<string[]>([]);
  const [showFilters, setShowFilters] = useState(false);

  // Filter and sort suggestions
  const filteredSuggestions = useMemo(() => {
    let result = [...suggestions];

    // Apply status filter
    if (statusFilter.length > 0) {
      result = result.filter((s) => statusFilter.includes(s.status));
    }

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (s) =>
          s.firstParty.firstName.toLowerCase().includes(query) ||
          s.firstParty.lastName.toLowerCase().includes(query) ||
          s.secondParty.firstName.toLowerCase().includes(query) ||
          s.secondParty.lastName.toLowerCase().includes(query) ||
          s.firstParty.profile.city?.toLowerCase().includes(query) ||
          s.secondParty.profile.city?.toLowerCase().includes(query)
      );
    }

    // Apply sorting
    switch (sortBy) {
      case "latest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
        );
        break;
    }

    return result;
  }, [suggestions, searchQuery, sortBy, statusFilter]);

  return (
    <div className={className}>
      {/* Filters Bar */}
      <div className="mb-6 space-y-4">
        <div className="flex gap-4">
          <div className="relative flex-1">
            <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
            <Input
              placeholder="חיפוש לפי שם או עיר..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 text-right"
            />
          </div>

          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-48">
              <SortDesc className="w-4 h-4 ml-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {SORT_OPTIONS.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Button
            variant="outline"
            onClick={() => setShowFilters(!showFilters)}
          >
            <Filter className="w-4 h-4 ml-2" />
            סינון
          </Button>
        </div>

        {showFilters && (
          <div className="flex gap-4">
            {STATUS_OPTIONS.map((status) => (
              <Button
                key={status.value}
                variant={
                  statusFilter.includes(status.value) ? "default" : "outline"
                }
                onClick={() => {
                  setStatusFilter((prev) =>
                    prev.includes(status.value)
                      ? prev.filter((s) => s !== status.value)
                      : [...prev, status.value]
                  );
                }}
                className="text-sm"
              >
                {status.label}
              </Button>
            ))}
          </div>
        )}
      </div>

      {/* Suggestions Grid */}
      {isLoading ? (
        <LoadingContainer>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <div
                key={i}
                className="h-64 bg-gray-100 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </LoadingContainer>
      ) : (
        // בערך בשורה 196 - שנה את הגריד להצגה מימין לשמאל
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
          {filteredSuggestions.map((suggestion) => (
            <SuggestionCard
              key={suggestion.id}
              suggestion={suggestion as unknown as Suggestion}
              onAction={onAction}
              className="rtl" // הוסף מחלקה זו
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default SuggestionsList;
--- End of Content for SuggestionsList.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\NotificationService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/NotificationService.ts

import { MatchSuggestionStatus } from '@prisma/client';
import { SuggestionWithParties } from '../suggestions/StatusTransitionService';

export type RecipientInfo = {
  email: string;
  phone?: string; // Phone number with international prefix, e.g.: +972501234567
  name: string;
};

export type NotificationContent = {
  subject: string;
  body: string;
  htmlBody?: string; // HTML version for email
};

export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
  channels: NotificationChannel[];
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
  priority?: 'high' | 'normal' | 'low';
  attachments?: Array<{
    filename: string;
    content: Buffer | string;
    contentType: string;
  }>;
  customMessage?: string;
  metadata?: Record<string, unknown>;
};

export interface NotificationAdapter {
  canSendTo(recipient: RecipientInfo): boolean;
  send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean>;
  getChannelType(): NotificationChannel;
}

export class NotificationService {
  private static instance: NotificationService;
  private adapters: Map<NotificationChannel, NotificationAdapter> = new Map();

  private constructor() {}

  public static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  public registerAdapter(adapter: NotificationAdapter): void {
    this.adapters.set(adapter.getChannelType(), adapter);
    console.log(`Registered ${adapter.getChannelType()} adapter`);
  }

  public async sendNotification(
    recipient: RecipientInfo,
    content: NotificationContent,
    options: NotificationOptions
  ): Promise<Record<NotificationChannel, boolean>> {
    const results: Record<NotificationChannel, boolean> = {} as Record<NotificationChannel, boolean>;
    console.log(`Attempting to send notification to ${recipient.name} via channels:`, options.channels);

    for (const channel of options.channels) {
      const adapter = this.adapters.get(channel);
      if (!adapter) {
        console.warn(`No adapter registered for channel: ${channel}`);
        results[channel] = false;
        continue;
      }

      if (!adapter.canSendTo(recipient)) {
        console.warn(`Cannot send to recipient via ${channel}: missing required info`);
        results[channel] = false;
        continue;
      }

      try {
        console.log(`Sending ${channel} notification to ${recipient.name}`);
        results[channel] = await adapter.send(recipient, content);
        console.log(`${channel} notification sent successfully: ${results[channel]}`);
      } catch (error) {
        console.error(`Error sending notification via ${channel}:`, error);
        results[channel] = false;
      }
    }

    return results;
  }

  // Dedicated method for handling suggestion-related notifications
  public async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
    options: Partial<NotificationOptions> = {}
  ): Promise<void> {
    console.log(`Processing notifications for suggestion ${suggestion.id} with status ${suggestion.status}`);
    
    const templateContent = this.getSuggestionTemplate(suggestion, options.customMessage);
    if (!templateContent) {
      console.log(`No template found for status ${suggestion.status} - skipping notification`);
      return;
    }
  
    const recipientsWithChannels = this.getRecipientsForSuggestion(suggestion);
    console.log(`Found ${recipientsWithChannels.length} potential recipients`);
  
    for (const { recipient, preferredChannels } of recipientsWithChannels) {
      // Filter recipients based on notifyParties if provided
      if (options.notifyParties) {
        const recipientType = this.getRecipientType(recipient, suggestion);
        if (!recipientType || !options.notifyParties.includes(recipientType)) {
          console.log(`Skipping recipient ${recipient.name} (${recipientType}) - not in notifyParties`, options.notifyParties);
          continue;
        }
      }
      
      const channelsToUse = options.channels || preferredChannels || ['email'];
      console.log(`Sending notification to ${recipient.name} via channels:`, channelsToUse);
      
      await this.sendNotification(
        recipient,
        templateContent,
        { ...options, channels: channelsToUse }
      );
    }
    
    console.log(`Finished processing notifications for suggestion ${suggestion.id}`);
  }

  // Helper method to determine recipient type
  private getRecipientType(
    recipient: RecipientInfo, 
    suggestion: SuggestionWithParties
  ): 'first' | 'second' | 'matchmaker' | null {
    if (recipient.email === suggestion.firstParty.email) {
      return 'first';
    } else if (recipient.email === suggestion.secondParty.email) {
      return 'second';
    } else if (recipient.email === suggestion.matchmaker.email) {
      return 'matchmaker';
    }
    return null;
  }

  private getSuggestionTemplate(
    suggestion: SuggestionWithParties,
    customMessage?: string
  ): NotificationContent | null {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    // If there's a custom message, use it instead of the template
    if (customMessage) {
      const reviewUrl = `${baseUrl}/suggestions/${suggestion.id}/review`;
      return {
        subject: "עדכון בהצעת שידוך",
        body: `שלום,\n\n${customMessage}\n\nלצפייה בפרטי ההצעה: ${reviewUrl}\n\nבברכה,\nמערכת השידוכים`,
        htmlBody: `
          <div dir="rtl">
            <h2>שלום,</h2>
            <p>${customMessage}</p>
            <p>לצפייה בפרטי ההצעה: <a href="${reviewUrl}">לחץ כאן</a></p>
            <p>בברכה,<br>מערכת השידוכים</p>
          </div>
        `
      };
    }
    
    // Otherwise use the template based on status
    switch (suggestion.status) {
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.firstParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.firstParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בהצעה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.\n\nההצעה תועבר כעת באופן אוטומטי לצד השני.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.</p><p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.secondParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nהצד הראשון כבר אישר את ההצעה.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.secondParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>הצד הראשון כבר אישר את ההצעה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בפרטי ההצעה ומענה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.\n\nשני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.</p><p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
    
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Prepare contact details with multi-line support
        const firstPartyDetails = this.formatUserDetails(suggestion.firstParty);
        const secondPartyDetails = this.formatUserDetails(suggestion.secondParty);
        
        return {
          subject: 'פרטי קשר להצעת השידוך',
          body: `ברכות! שני הצדדים אישרו את הצעת השידוך.\n\nפרטי הקשר של הצד הראשון:\n${firstPartyDetails}\n\nפרטי הקשר של הצד השני:\n${secondPartyDetails}\n\nאנא צרו קשר בהקדם לתיאום פגישה ראשונה.\n\nבהצלחה!`,
          htmlBody: `<div dir="rtl"><h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2><p>פרטי הקשר של הצד הראשון:</p><pre>${firstPartyDetails}</pre><p>פרטי הקשר של הצד השני:</p><pre>${secondPartyDetails}</pre><p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p><p>בהצלחה!</p></div>`
        };
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return {
          subject: 'בקשה למשוב על הפגישה הראשונה',
          body: `שלום,\n\nנשמח לקבל את המשוב שלך על הפגישה הראשונה.\n\nלשליחת המשוב: ${baseUrl}/suggestions/${suggestion.id}/feedback\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום,</h2><p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/feedback">לשליחת המשוב</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
        return {
          subject: 'בקשת זמן למחשבה לאחר הפגישה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nאחד הצדדים ביקש זמן למחשבה לאחר הפגישה.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.DATING:
        return {
          subject: 'עדכון סטטוס - בתהליך היכרות',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהזוג נמצא בתהליך היכרות.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הזוג נמצא בתהליך היכרות.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.ENGAGED:
        return {
          subject: 'מזל טוב! - אירוסין',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.MARRIED:
        return {
          subject: 'מזל טוב! - חתונה',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.EXPIRED:
        return {
          subject: 'הצעת השידוך פגה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהצעת השידוך פגה עקב חוסר מענה במועד.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הצעת השידוך פגה עקב חוסר מענה במועד.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      default:
        // For other statuses, return null to skip notification
        console.log(`No template defined for status: ${suggestion.status}`);
        return null;
    }
  }

  private getRecipientsForSuggestion(suggestion: SuggestionWithParties): Array<{
    recipient: RecipientInfo;
    preferredChannels: NotificationChannel[];
  }> {
    const recipients: Array<{
      recipient: RecipientInfo;
      preferredChannels: NotificationChannel[];
    }> = [];
    
    // Logic to determine recipients based on suggestion status
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email'] // Email only for drafts
        });
        break;
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.firstParty.email,
            phone: suggestion.firstParty.phone || undefined,
            name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.secondParty.email,
            phone: suggestion.secondParty.phone || undefined,
            name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email']
          }
        );
        break;
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        // Send to both parties
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;
      
      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;

      default:
        // Default: send to matchmaker only
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email']
        });
        break;
    }

    return recipients;
  }

  // Helper function to format contact details
  private formatUserDetails(user: { 
    firstName: string; 
    lastName: string; 
    email: string; 
    phone?: string | null 
  }): string {
    const details = [
      `שם: ${user.firstName} ${user.lastName}`,
      `אימייל: ${user.email}`,
    ];

    if (user.phone) {
      details.push(`טלפון: ${user.phone}`);
    }

    return details.join('\n');
  }
}

export const notificationService = NotificationService.getInstance();
--- End of Content for NotificationService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\initNotifications.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/initNotifications.ts

import { notificationService } from './NotificationService';
import { emailAdapter } from './adapters/EmailAdapter';
import { whatsAppAdapter } from './adapters/WhatsAppAdapter';

// Define notification channel type
export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
    channels: NotificationChannel[];
    notifyParties?: ('first' | 'second' | 'matchmaker')[];
    customMessage?: string;
  };

/**
 * Initializes the notification service by registering all available adapters
 * @returns The initialized notification service
 */
export function initNotificationService() {
  // Register adapters
  notificationService.registerAdapter(emailAdapter);
  notificationService.registerAdapter(whatsAppAdapter);
  
  console.log('Notification service initialized with email and WhatsApp adapters');
  
  return notificationService;
}
--- End of Content for initNotifications.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\EmailAdapter.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/adapters/EmailAdapter.ts

import { NotificationAdapter, NotificationChannel, RecipientInfo, NotificationContent } from '../NotificationService';
import nodemailer from 'nodemailer';

export class EmailAdapter implements NotificationAdapter {
  private static instance: EmailAdapter;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure the transporter exactly like in EmailService
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER || '',
        pass: process.env.GMAIL_APP_PASSWORD || '',
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on initialization
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig(): Promise<void> {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw, to allow the system to continue even if verification fails
    }
  }

  public static getInstance(): EmailAdapter {
    if (!EmailAdapter.instance) {
      EmailAdapter.instance = new EmailAdapter();
    }
    return EmailAdapter.instance;
  }

  public getChannelType(): NotificationChannel {
    return 'email';
  }

  public canSendTo(recipient: RecipientInfo): boolean {
    return !!recipient.email;
  }

  public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
    try {
      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME || 'מערכת השידוכים'} <${process.env.GMAIL_USER || ''}>`,
        to: recipient.email,
        subject: content.subject,
        text: content.body,
        html: content.htmlBody || content.body.replace(/\n/g, '<br>'),
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
        to: recipient.email,
        subject: content.subject
      });

      return true;
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        recipient: recipient.email,
        subject: content.subject
      });
      return false;
    }
  }
}

export const emailAdapter = EmailAdapter.getInstance();
--- End of Content for EmailAdapter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\WhatsAppAdapter.ts
--------------------------------------------------------------------------------
Content:
// lib/WhatsAppAdapter.ts
import {
  NotificationAdapter,
  NotificationChannel,
  RecipientInfo,
  NotificationContent as BaseNotificationContent
} from '../NotificationService'; // Assuming NotificationService.ts exists in the same directory
import twilio from 'twilio';
// Import the specific type for message creation options if available
import { MessageListInstanceCreateOptions } from 'twilio/lib/rest/api/v2010/account/message';

// --- Define an extended NotificationContent interface ---
// This adds the optional adapter-specific data structure
interface NotificationContent extends BaseNotificationContent {
  _adapterSpecificData?: {
      contentSid?: string;
      contentVariables?: string; // Should be a JSON string
      // Add other potential adapter-specific fields here
  };
}
// --- End Interface Extension ---

// --- Type Guard for Twilio-like Errors ---
interface PotentialTwilioError {
  code?: number | string;
  message?: string;
  // Add other potential properties like 'status', 'moreInfo', etc. if needed
}

/**
* Type guard to check if an unknown error object might be a Twilio API error
* by checking for the presence of 'code' or 'message' properties.
* @param error The unknown value caught in a catch block.
* @returns True if the error object has properties common to Twilio errors, false otherwise.
*/
function isPotentialTwilioError(error: unknown): error is PotentialTwilioError {
  // Check if it's a non-null object and has either 'code' or 'message' property
  return typeof error === 'object' && error !== null && ('code' in error || 'message' in error);
}
// --- End Type Guard ---

// --- Helper: Logger (optional but recommended) ---
// Using Record<string, unknown> or object instead of any
const logger = {
info: (message: string, meta?: Record<string, unknown> | object) => {
  console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
warn: (message: string, meta?: Record<string, unknown> | object) => {
  console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
error: (message: string, meta?: Record<string, unknown> | object) => {
  let logMeta = meta || {};
  // If the meta object itself is an Error, extract relevant info
  if (meta instanceof Error) {
      logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
  } else if (isPotentialTwilioError(meta)) {
      // If it's potentially a Twilio error passed directly
      logMeta = { code: meta.code, message: meta.message, ...meta };
  }
  console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', service: 'WhatsAppAdapter', message, ...logMeta }));
},
};
// --- End Logger ---


export class WhatsAppAdapter implements NotificationAdapter {
// Singleton instance
private static instance: WhatsAppAdapter;
// Twilio client instance (typed)
private client: twilio.Twilio | null = null;
// Configured Twilio WhatsApp sender number
private fromNumber: string = '';

/**
 * Private constructor to enforce singleton pattern.
 * Initializes the Twilio client using environment variables.
 */
private constructor() {
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  this.fromNumber = process.env.TWILIO_WHATSAPP_NUMBER || ''; // Get number from env

  // Validate configuration
  if (!accountSid || !authToken || !this.fromNumber) {
    logger.error('Missing Twilio configuration details', {
        hasSid: !!accountSid,
        hasToken: !!authToken,
        hasWhatsAppNumber: !!this.fromNumber,
        detail: "WhatsApp notifications will be unavailable."
    });
    // Do not throw, allow graceful degradation if possible
  } else {
    try {
      // Initialize Twilio client
      this.client = twilio(accountSid, authToken);
      logger.info('Twilio client initialized successfully', { fromWhatsAppNumber: this.fromNumber });
    } catch (error: unknown) { // Catch as unknown
      logger.error('Failed to initialize Twilio client during constructor', { error });
      this.client = null; // Ensure client is null on initialization failure
    }
  }
}

/**
 * Gets the singleton instance of the WhatsAppAdapter.
 * @returns The WhatsAppAdapter instance.
 */
public static getInstance(): WhatsAppAdapter {
  if (!WhatsAppAdapter.instance) {
    WhatsAppAdapter.instance = new WhatsAppAdapter();
  }
  return WhatsAppAdapter.instance;
}

/**
 * Returns the channel type handled by this adapter.
 * @returns The notification channel type ('whatsapp').
 */
public getChannelType(): NotificationChannel {
  return 'whatsapp';
}

/**
 * Checks if this adapter is capable of sending a notification to the given recipient.
 * Requires a valid phone number, an initialized Twilio client, and a configured 'from' number.
 * @param recipient Information about the recipient.
 * @returns True if the adapter can send, false otherwise.
 */
public canSendTo(recipient: RecipientInfo): boolean {
  const hasValidPhone = !!recipient.phone && recipient.phone.length > 8; // Basic validation
  const isClientReady = this.client !== null;
  const hasFromNumber = this.fromNumber !== '';
  const canSend = hasValidPhone && isClientReady && hasFromNumber;

  if (!canSend) {
      let reason = 'Unknown';
      if (!hasValidPhone) reason = 'Invalid or missing phone number';
      else if (!isClientReady) reason = 'Twilio client not initialized';
      else if (!hasFromNumber) reason = 'Twilio "from" number not configured';
      logger.warn('Cannot send WhatsApp message due to configuration or recipient data', {
          reason: reason,
          recipientPhone: recipient.phone // Log phone for debugging
      });
  }
  return canSend;
}

/**
 * Formats a phone number into E.164 standard without the leading '+'.
 * Required for Twilio's `to` parameter when prefixed with `whatsapp:`.
 * Handles Israeli numbers starting with '0'.
 * Example: 0501234567 -> 972501234567
 * @param phone The phone number string to format.
 * @returns The formatted phone number string.
 */
private formatPhoneNumber(phone: string): string {
  // Remove all non-digit characters
  let cleaned = phone.replace(/\D/g, '');
  // Prepend country code for Israeli numbers if '0' prefix exists
  if (cleaned.startsWith('0')) {
    cleaned = '972' + cleaned.substring(1);
  }
  // Remove leading '+' if present (it's added later in the `whatsapp:` prefix)
  if (cleaned.startsWith('+')) {
    cleaned = cleaned.substring(1);
  }
  return cleaned;
}

/**
 * Sends a notification via WhatsApp using the Twilio API.
 * Prefers using template messages if configured via `_adapterSpecificData`.
 * Falls back to raw text messages otherwise (less reliable for business-initiated messages).
 * @param recipient Information about the recipient.
 * @param content The notification content, potentially including adapter-specific data.
 * @returns A promise that resolves to true if the message was successfully queued by Twilio, false otherwise.
 */
public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
  logger.info('Attempting to send WhatsApp message', {
    recipientPhone: recipient.phone,
    fromNumber: this.fromNumber,
    hasClient: !!this.client,
    contentSid: content._adapterSpecificData?.contentSid,
    hasContentVariables: !!content._adapterSpecificData?.contentVariables,
  });

  // --- Pre-send Checks ---
  if (!this.client) {
    logger.error('Twilio client not initialized. Cannot send WhatsApp message.');
    return false;
  }
  if (!recipient.phone) {
    logger.error('Recipient phone number is missing. Cannot send WhatsApp message.');
    return false;
  }
  if (!this.fromNumber) {
      logger.error('Twilio "from" WhatsApp number is not configured. Cannot send message.');
      return false;
  }
  // --- End Pre-send Checks ---


  try {
    // --- Format Numbers ---
    const toNumberE164 = this.formatPhoneNumber(recipient.phone);
    // Ensure 'from' number has '+' prefix for the whatsapp: schema
    const fromWhatsAppFormatted = `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`;
    // Ensure 'to' number has '+' prefix for the whatsapp: schema
    const toWhatsAppFormatted = `whatsapp:+${toNumberE164}`;

    logger.info(`Formatted numbers for sending via Twilio`, { from: fromWhatsAppFormatted, to: toWhatsAppFormatted });
    // --- End Format Numbers ---


    // --- Prepare Message Payload ---
    let messagePayload: MessageListInstanceCreateOptions;
    const adapterData = content._adapterSpecificData;

    if (adapterData?.contentSid && adapterData?.contentVariables) {
       // **Use Template Messaging**
       logger.info(`Preparing WhatsApp template message`, { contentSid: adapterData.contentSid });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          contentSid: adapterData.contentSid, // The approved template SID
          contentVariables: adapterData.contentVariables, // JSON string of variables {"1": "value1", "2": "value2"}
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    } else {
       // **Use Raw Text Messaging (Fallback)**
       // Note: This might fail if outside the 24-hour customer service window
       // or if WhatsApp/Twilio policies require templates for this type of message.
       const bodyText = content.body || content.subject || 'הודעה ממערכת השידוכים'; // Determine fallback content
       logger.warn(`Preparing raw text WhatsApp message (using fallback, might fail)`, { bodyLength: bodyText.length });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          body: bodyText, // The actual text message content
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    }
    // --- End Prepare Message Payload ---


    // --- Send Message via Twilio API ---
    logger.info("Sending message payload to Twilio API", { payload: messagePayload }); // Be cautious logging full payload in production if sensitive
    const message = await this.client.messages.create(messagePayload);
    // --- End Send Message ---


    // --- Log Success ---
    // The message status here is typically 'queued' or 'sending'. Delivery confirmation is asynchronous.
    logger.info('WhatsApp message request processed successfully by Twilio', {
      messageSid: message.sid,
      status: message.status,
      to: toWhatsAppFormatted,
      from: fromWhatsAppFormatted,
      price: message.price, // Log cost if available
      priceUnit: message.priceUnit,
      errorCode: message.errorCode, // Log if Twilio detected an error immediately
      errorMessage: message.errorMessage,
    });
    // We return true because Twilio accepted the request. Delivery is not guaranteed at this point.
    return true;
    // --- End Log Success ---

  } catch (error: unknown) { // Catch error as unknown
    // --- Handle Errors ---
    let errorMessage = 'Unknown error occurred while sending WhatsApp message.';
    let errorCode: number | string | undefined;

    // Use the type guard to safely access potential error properties
    if (isPotentialTwilioError(error)) {
        errorCode = error.code;
        errorMessage = error.message || errorMessage;
    } else if (error instanceof Error) {
        // Standard JavaScript Error
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        // Simple string error
        errorMessage = error;
    }

    // Log detailed error information
    logger.error('Failed to send WhatsApp message via Twilio', {
      errorCode,
      errorMessage,
      recipient: `whatsapp:+${this.formatPhoneNumber(recipient.phone)}`, // Log formatted number for debugging
      from: `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`,
      // Pass the original error object for full details in structured logs
      errorDetails: error
    });

    // Specific handling/logging for common, informative errors
    if (errorCode === 63018 || errorCode === 21614) { // Common codes for non-WhatsApp/incapable numbers
         logger.error(`Recipient number appears invalid or not registered on WhatsApp.`, { phone: recipient.phone, errorCode });
         // Consider adding logic here: maybe mark the user's number as invalid? Notify admin?
    } else if (errorCode === 63016) { // Common code for failing outside the 24-hour window without a template
          logger.warn(`Failed to send non-template message outside 24-hour window.`, { phone: recipient.phone, errorCode });
    }

    return false; // Indicate that sending failed
    // --- End Handle Errors ---
  }
}
}

// Export the singleton instance for use in other parts of the application
export const whatsAppAdapter = WhatsAppAdapter.getInstance();
--- End of Content for WhatsAppAdapter.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\StatusTransitionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService.ts

import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { notificationService } from "../notification/NotificationService";


type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type TransitionOptions = {
  sendNotifications?: boolean;
  customMessage?: string;
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string,
    options: TransitionOptions = {}
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;
    const mergedOptions = {
      sendNotifications: true,
      notifyParties: ['first', 'second', 'matchmaker'],
      ...options
    };

    // Validate the transition
    this.validateStatusTransition(previousStatus, newStatus);

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Only send notifications if option is enabled
    if (mergedOptions.sendNotifications) {
      try {
        // Utilize the notification service for all channels (email, WhatsApp, etc.)
        await notificationService.handleSuggestionStatusChange(
          
          updatedSuggestion, 
          {
            channels: ['email', 'whatsapp'],
            notifyParties: mergedOptions.notifyParties as ('first' | 'second' | 'matchmaker')[],
            customMessage: mergedOptions.customMessage
          }
        );
        
        console.log(`Notifications sent for suggestion ${updatedSuggestion.id} status change to ${newStatus}`);
      } catch (error) {
        // Log error but don't fail the transition
        console.error('Error sending status transition notifications:', error);
      }
    }

    return updatedSuggestion;
  }

  private validateStatusTransition(
    currentStatus: MatchSuggestionStatus, 
    newStatus: MatchSuggestionStatus
  ): void {
    const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
      DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
      PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
      ],
      AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      ENDED_AFTER_FIRST_DATE: [
        MatchSuggestionStatus.CLOSED
      ],
      MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
      ],
      MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
      ],
      ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
      ],
      MARRIED: [],
      EXPIRED: [],
      CLOSED: [],
      CANCELLED: []
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new Error(
        `Invalid status transition from ${currentStatus} to ${newStatus}. ` +
        `Valid transitions are: ${validTransitions[currentStatus]?.join(', ') || 'none'}`
      );
    }
  }
  
  getStatusLabel(status: MatchSuggestionStatus): string {
    const statusLabels: Record<MatchSuggestionStatus, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת הצד הראשון",
      FIRST_PARTY_APPROVED: "הצד הראשון אישר",
      FIRST_PARTY_DECLINED: "הצד הראשון דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת הצד השני",
      SECOND_PARTY_APPROVED: "הצד השני אישר",
      SECOND_PARTY_DECLINED: "הצד השני דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור השדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בחשיבה לאחר הפגישה",
      PROCEEDING_TO_SECOND_DATE: "התקדמות לפגישה שנייה",
      ENDED_AFTER_FIRST_DATE: "הסתיים לאחר פגישה ראשונה",
      MEETING_PENDING: "פגישה בהמתנה",
      MEETING_SCHEDULED: "פגישה קבועה",
      MATCH_APPROVED: "השידוך אושר",
      MATCH_DECLINED: "השידוך נדחה",
      DATING: "בתהליך היכרות",
      ENGAGED: "אירוסין",
      MARRIED: "נישואין",
      CANCELLED: "בוטל",
      CLOSED: "נסגר",
      EXPIRED: "פג תוקף"
    };
    
    return statusLabels[status] || status;
  }
  
  // Get available actions for current status based on user role
  getAvailableActions(
    suggestion: SuggestionWithParties, 
    userId: string
  ): { id: string; label: string; nextStatus: MatchSuggestionStatus }[] {
    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;
    const isMatchmaker = suggestion.matchmakerId === userId;
    
    const actions: Record<MatchSuggestionStatus, { 
      firstParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      secondParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      matchmaker?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
    }> = {
      DRAFT: {
        matchmaker: [
          { id: "send-to-first", label: "שליחה לצד הראשון", nextStatus: MatchSuggestionStatus.PENDING_FIRST_PARTY }
        ]
      },
      PENDING_FIRST_PARTY: {
        firstParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_APPROVED: {
        matchmaker: [
          { id: "send-to-second", label: "שליחה לצד השני", nextStatus: MatchSuggestionStatus.PENDING_SECOND_PARTY },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      PENDING_SECOND_PARTY: {
        secondParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_APPROVED: {
        matchmaker: [
          { id: "share-contacts", label: "שיתוף פרטי קשר", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      AWAITING_MATCHMAKER_APPROVAL: {
        matchmaker: [
          { id: "approve-share", label: "אישור שיתוף פרטים", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      CONTACT_DETAILS_SHARED: {
        firstParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        secondParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        matchmaker: [
          { id: "request-feedback", label: "בקש משוב", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      AWAITING_FIRST_DATE_FEEDBACK: {
         matchmaker: [
            { id: "mark-thinking", label: "סמן כ'בחשיבה'", nextStatus: MatchSuggestionStatus.THINKING_AFTER_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      THINKING_AFTER_DATE: {
         matchmaker: [
            { id: "proceed-second", label: "המשך לפגישה שניה", nextStatus: MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      PROCEEDING_TO_SECOND_DATE: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      ENDED_AFTER_FIRST_DATE: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      MEETING_PENDING: {
         matchmaker: [
            { id: "schedule-meeting", label: "קביעת פגישה", nextStatus: MatchSuggestionStatus.MEETING_SCHEDULED },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MEETING_SCHEDULED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_APPROVED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      DATING: {
        matchmaker: [
          { id: "mark-engaged", label: "עדכון אירוסין", nextStatus: MatchSuggestionStatus.ENGAGED },
          { id: "close", label: "סגירת תהליך", nextStatus: MatchSuggestionStatus.CLOSED },
          { id: "cancel", label: "ביטול השידוך", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      ENGAGED: {
        matchmaker: [
          { id: "mark-married", label: "עדכון נישואין", nextStatus: MatchSuggestionStatus.MARRIED },
          { id: "cancel", label: "ביטול אירוסין", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      MARRIED: {},
      EXPIRED: {},
      CLOSED: {},
      CANCELLED: {}
    };
    
    if (isFirstParty && actions[suggestion.status]?.firstParty) {
      return actions[suggestion.status].firstParty || [];
    }
    
    if (isSecondParty && actions[suggestion.status]?.secondParty) {
      return actions[suggestion.status].secondParty || [];
    }
    
    if (isMatchmaker && actions[suggestion.status]?.matchmaker) {
      return actions[suggestion.status].matchmaker || [];
    }
    
    return [];
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();
--- End of Content for StatusTransitionService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\SuggestionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/SuggestionService.ts

import { MatchSuggestionStatus, Priority, UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { initNotificationService } from "../notification/initNotifications";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
} from "@/types/suggestions";

// Initialize notification service
const notificationService = initNotificationService();
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];
export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    // קוד חדש ומתוקן
const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
if (!matchmaker || !allowedRoles.includes(matchmaker.role)) {
  throw new Error("Unauthorized - User must be a Matchmaker or Admin");
}
  // --- START: NEW VALIDATION LOGIC ---
    // Fetch both parties to get their names for error messages
    const [firstParty, secondParty] = await Promise.all([
        prisma.user.findUnique({ where: { id: data.firstPartyId } }),
        prisma.user.findUnique({ where: { id: data.secondPartyId } })
    ]);

    if (!firstParty || !secondParty) {
        throw new Error("One or both candidates not found.");
    }
    
    // Check for BLOCKING suggestions for either party
    const blockingSuggestion = await prisma.matchSuggestion.findFirst({
        where: {
            OR: [
                { firstPartyId: data.firstPartyId },
                { secondPartyId: data.firstPartyId },
                { firstPartyId: data.secondPartyId },
                { secondPartyId: data.secondPartyId },
            ],
            status: {
                in: BLOCKING_SUGGESTION_STATUSES,
            },
        },
    });

    if (blockingSuggestion) {
        const hasBlockingSuggestion = (id: string) => 
            blockingSuggestion.firstPartyId === id || blockingSuggestion.secondPartyId === id;
            
        if (hasBlockingSuggestion(data.firstPartyId)) {
            throw new Error(`לא ניתן ליצור הצעה חדשה. ל${firstParty.firstName} ${firstParty.lastName} יש כבר הצעה פעילה.`);
        }
        if (hasBlockingSuggestion(data.secondPartyId)) {
            throw new Error(`לא ניתן ליצור הצעה חדשה. ל${secondParty.firstName} ${secondParty.lastName} יש כבר הצעה פעילה.`);
        }
    }

    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
      console.log('Decision deadline type:', typeof data.decisionDeadline);
      
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות באמצעות מערכת ההתראות המאוחדת
    try {
      console.log('Sending notifications for new suggestion...');
      await notificationService.handleSuggestionStatusChange(
        suggestion,
        {
          channels: ['email', 'whatsapp'],
          notifyParties: ['first'] // רק לצד הראשון בשלב זה
        }
      );
    } catch (error) {
      console.error('Error sending initial suggestion notifications:', error);
      // לא לעצור את התהליך - רק לדווח על השגיאה
    }

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: SuggestionWithParties,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<SuggestionWithParties | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }
}
export const suggestionService = SuggestionService.getInstance();
--- End of Content for SuggestionService.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\matchingAlgorithm.ts
--------------------------------------------------------------------------------
Content:
import { AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

const matchingAlgorithm = {
  calculateMatchScore,
  findBestMatches
};

export default matchingAlgorithm;
--- End of Content for matchingAlgorithm.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\statisticsCalculator.ts
--------------------------------------------------------------------------------
Content:
// /utils/statisticsCalculator.ts
import type { Candidate } from '../../new/types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const  stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

const statisticsCalculator = {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

export default statisticsCalculator;
--- End of Content for statisticsCalculator.ts ---

