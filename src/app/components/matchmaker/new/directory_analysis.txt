מבנה התיקייה:
new
  CandidateCard
    Actions.tsx
    MinimalCard.tsx
    QuickView.tsx
  CandidatesManager
    CandidatesList.tsx
    CandidatesStats.tsx
    SplitView.tsx
    StatsCard.tsx
    index.tsx
  Filters
    ActiveFilters.tsx
    FilterPanel.tsx
    SavedFilters.tsx
    SearchBar.tsx
  MatchmakerEditProfile.tsx
  NewSuggestionForm
    CandidateSelector.tsx
    MatchPreview.tsx
    SuggestionDetails.tsx
    index.tsx
    schema.ts
  constants
    filterOptions.ts
    matchingCriteria.ts
  dialogs
    ActionDialogs.tsx
  hooks
    filterUtils
    useCandidates.ts
    useFilterLogic.ts
    useMatchmaking.ts
    useStatistics.ts
  services
    email
      EmailService.ts
    suggestions
      StatusTransitionService.ts
      SuggestionService.ts
  shared
    LoadingStates.tsx
    Pagination.tsx
    StatusBadge.tsx
  types
    candidates.ts
    filters.ts
  utils
    matchingAlgorithm.ts
    statisticsCalculator.ts

תוכן הקבצים:

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\MatchmakerEditProfile.tsx:
==================================================
import React, { useState, useEffect, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { ProfileSection } from "@/app/components/shared/shared/profile";
import { PhotosSection } from "@/app/components/shared/shared/profile";
import { PreferencesSection } from "@/app/components/shared/shared/profile";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Loader2, X, UserCog, Image as ImageIcon, Sliders } from "lucide-react";
import type { UserProfile, UserImage } from "@/types/next-auth";
import type { Candidate } from "./types/candidates";
import { motion } from "framer-motion";

interface MatchmakerEditProfileProps {
  isOpen: boolean;
  onClose: () => void;
  candidate: Candidate | null;
}

const MatchmakerEditProfile: React.FC<MatchmakerEditProfileProps> = ({
  isOpen,
  onClose,
  candidate,
}) => {
  const [activeTab, setActiveTab] = useState("profile");
  const [isEditing, setIsEditing] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [images, setImages] = useState<UserImage[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchProfileData = useCallback(async () => {
    if (!candidate) return;

    try {
      // Fetch complete profile data
      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}`
      );

      if (!response.ok) {
        throw new Error("Failed to fetch candidate profile");
      }

      const data = await response.json();

      if (data.success) {
        setProfile(data.profile);
        setImages(data.images || []);
      } else {
        throw new Error(data.error || "Failed to load profile data");
      }
    } catch (error) {
      console.error("Error fetching profile:", error);
      toast.error("שגיאה בטעינת נתוני המועמד");
    }
  }, [candidate]);
  // Fetch full profile data when component opens
  useEffect(() => {
    if (isOpen && candidate) {
      setIsLoading(true);
      fetchProfileData().finally(() => {
        setIsLoading(false);
      });
    }
  }, [isOpen, candidate, fetchProfileData]);

  const handleProfileUpdate = async (updatedProfile: Partial<UserProfile>) => {
    if (!candidate) return;

    try {
      setIsSaving(true);

      // Clean up empty enum fields to prevent validation errors
      const cleanedProfile = { ...updatedProfile };

      // Convert undefined values to undefined for enum fields (not null)
      // TypeScript is enforcing that gender can only be Gender enum or undefined
      if (cleanedProfile.gender === undefined) {
        // Keep it as undefined, don't set to null
      }
      if (cleanedProfile.preferredMatchmakerGender === undefined) {
        // Keep it as undefined, don't set to null
      }
      console.log("Sending profile update:", cleanedProfile);

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}`,
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(cleanedProfile),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to update profile");
      }

      const data = await response.json();

      if (data.success) {
        setProfile(
          (prevProfile) =>
            ({
              ...prevProfile,
              ...cleanedProfile,
            } as UserProfile)
        );

        toast.success("פרופיל המועמד עודכן בהצלחה", {
          position: "top-center",
          duration: 3000,
        });
      } else {
        throw new Error(data.error || "Failed to update profile");
      }
    } catch (error) {
      console.error("Error updating profile:", error);
      toast.error(
        "שגיאה בעדכון פרופיל המועמד: " +
          (error instanceof Error ? error.message : "שגיאה לא ידועה"),
        {
          duration: 5000,
        }
      );
    } finally {
      setIsSaving(false);
    }
  };

  const handleImageUpload = async (file: File) => {
    if (!candidate) return;

    try {
      setIsUploading(true);

      const formData = new FormData();
      formData.append("image", file);
      formData.append("userId", candidate.id);

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images`,
        {
          method: "POST",
          body: formData,
        }
      );

      if (!response.ok) {
        throw new Error("Failed to upload image");
      }

      const data = await response.json();

      if (data.success) {
        setImages((prev) => [...prev, data.image]);
        toast.success("התמונה הועלתה בהצלחה");
      } else {
        throw new Error(data.error || "Failed to upload image");
      }
    } catch (error) {
      console.error("Error uploading image:", error);
      toast.error("שגיאה בהעלאת התמונה");
    } finally {
      setIsUploading(false);
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    if (!candidate) return;

    try {
      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}/main`,
        {
          method: "PATCH",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to set main image");
      }

      const data = await response.json();

      if (data.success) {
        // Update local state - set the selected image as main and others as not main
        setImages((prev) =>
          prev.map((img) => ({
            ...img,
            isMain: img.id === imageId,
          }))
        );

        toast.success("התמונה הראשית עודכנה בהצלחה");
      } else {
        throw new Error(data.error || "Failed to set main image");
      }
    } catch (error) {
      console.error("Error setting main image:", error);
      toast.error("שגיאה בעדכון התמונה הראשית");
    }
  };

  const handleDeleteImage = async (imageId: string) => {
    if (!candidate) return;

    try {
      setIsUploading(true);

      console.log(`Deleting image ${imageId} for candidate ${candidate.id}`);

      // Check if this is the main image
      const isMainImage = images.find((img) => img.id === imageId)?.isMain;

      // Find another image that could become the main one if this is the main image
      let nextMainImage: UserImage | undefined;
      if (isMainImage) {
        nextMainImage = images.find((img) => img.id !== imageId);
        console.log("Next main image candidate:", nextMainImage);
      }

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        console.error("Delete image response:", response.status, errorText);
        throw new Error(`שגיאה במחיקת התמונה: ${response.status} ${errorText}`);
      }

      try {
        const data = await response.json();

        if (data.success) {
          setImages((prev) => prev.filter((img) => img.id !== imageId));

          // If this was the main image and there's another image, make it the main one
          if (isMainImage && nextMainImage) {
            await handleSetMainImage(nextMainImage.id);
          }

          toast.success("התמונה נמחקה בהצלחה", {
            position: "top-center",
          });
        } else {
          throw new Error(data.error || "Failed to delete image");
        }
      } catch (jsonError) {
        console.error("Error parsing JSON response:", jsonError);
        // If response was successful but JSON parsing failed, still consider it a success
        setImages((prev) => prev.filter((img) => img.id !== imageId));
        toast.success("התמונה נמחקה בהצלחה", {
          position: "top-center",
        });
      }
    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error(
        error instanceof Error ? error.message : "שגיאה במחיקת התמונה"
      );
    } finally {
      setIsUploading(false);
    }
  };

  if (!candidate) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-5xl max-h-[90vh] p-0 overflow-hidden">
        {isLoading ? (
          <div className="flex items-center justify-center p-12">
            <Loader2 className="w-10 h-10 animate-spin text-primary" />
          </div>
        ) : (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3 }}
            className="flex flex-col h-full max-h-[90vh]"
          >
            <DialogHeader className="p-6 border-b">
              <div className="flex items-center justify-between">
                <div>
                  <DialogTitle className="text-2xl font-bold text-primary/90">
                    עריכת פרופיל - {candidate.firstName} {candidate.lastName}
                  </DialogTitle>
                  <DialogDescription className="text-gray-500 mt-1">
                    עריכת פרטי המועמד והעדפותיו במערכת
                  </DialogDescription>
                </div>
                {isSaving && (
                  <div className="flex items-center bg-blue-50 text-blue-700 py-1 px-2 rounded-full text-sm">
                    <Loader2 className="w-3 h-3 animate-spin mr-1" />
                    שומר שינויים...
                  </div>
                )}
              </div>
            </DialogHeader>

            <Tabs
              value={activeTab}
              onValueChange={setActiveTab}
              className="flex-1 flex flex-col min-h-0"
            >
              <div className="px-6 pt-4">
                <TabsList className="w-full bg-muted/30 p-1 rounded-xl shadow-sm">
                  <TabsTrigger
                    value="profile"
                    className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2"
                  >
                    <UserCog className="w-4 h-4" />
                    פרטים אישיים
                  </TabsTrigger>
                  <TabsTrigger
                    value="photos"
                    className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2"
                  >
                    <ImageIcon className="w-4 h-4" />
                    תמונות
                  </TabsTrigger>
                  <TabsTrigger
                    value="preferences"
                    className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2"
                  >
                    <Sliders className="w-4 h-4" />
                    העדפות
                  </TabsTrigger>
                </TabsList>
              </div>

              <div className="flex-1 overflow-hidden flex flex-col min-h-0">
                <TabsContent
                  value="profile"
                  className="flex-1 overflow-auto p-4 m-0 pb-16"
                >
                  {profile ? (
                    <div className="bg-white rounded-xl shadow-sm border">
                      <ProfileSection
                        profile={profile}
                        isEditing={isEditing}
                        setIsEditing={setIsEditing}
                        onSave={handleProfileUpdate}
                      />
                    </div>
                  ) : (
                    <div className="flex items-center justify-center h-full">
                      <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
                    </div>
                  )}
                </TabsContent>

                <TabsContent
                  value="photos"
                  className="flex-1 overflow-auto p-4 m-0 pb-16"
                >
                  <div className="bg-white rounded-xl shadow-sm border">
                    <PhotosSection
                      images={images}
                      isUploading={isUploading}
                      disabled={false}
                      onUpload={handleImageUpload}
                      onSetMain={handleSetMainImage}
                      onDelete={handleDeleteImage}
                      maxImages={10}
                    />
                  </div>
                </TabsContent>

                <TabsContent
                  value="preferences"
                  className="flex-1 overflow-auto p-4 m-0 pb-16"
                >
                  {profile ? (
                    <div className="bg-white rounded-xl shadow-sm border">
                      <PreferencesSection
                        profile={profile}
                        isEditing={isEditing}
                        setIsEditing={setIsEditing}
                        onChange={handleProfileUpdate}
                      />
                    </div>
                  ) : (
                    <div className="flex items-center justify-center h-full">
                      <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
                    </div>
                  )}
                </TabsContent>
              </div>
            </Tabs>

            <div className="p-4 border-t flex justify-between mt-auto bg-white/80 backdrop-blur-sm sticky bottom-0">
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground">
                  {activeTab === "profile"
                    ? "עריכת פרטים אישיים"
                    : activeTab === "photos"
                    ? "ניהול תמונות"
                    : "עריכת העדפות"}
                </span>
              </div>
              <Button
                variant="outline"
                onClick={onClose}
                disabled={isSaving}
                className="bg-white hover:bg-gray-100 transition-colors shadow-sm"
              >
                <X className="w-4 h-4 ml-2" />
                סגור
              </Button>
            </div>
          </motion.div>
        )}
      </DialogContent>
    </Dialog>
  );
};

export default MatchmakerEditProfile;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidateCard\Actions.tsx:
==================================================
// /components/matchmaker/CandidateCard/Actions.tsx

"use client";

import React from "react";

import { Button } from "@/components/ui/button";
import { Heart, Mail, FileText, Eye, Clock } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface ActionsProps {
  candidate: Candidate;
  onInvite: (candidate: Candidate) => void;
  onSuggest: (candidate: Candidate) => void;
  onCheckAvailability: (candidate: Candidate) => void;
  onViewProfile: (candidate: Candidate) => void;
  className?: string;
}

const Actions: React.FC<ActionsProps> = ({
  candidate,
  onInvite,
  onSuggest,
  onCheckAvailability,
  onViewProfile,
  className,
}) => {
  // מונע התפשטות הקליק לכרטיס המינימלי
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  return (
    <div className={`flex flex-wrap gap-2 ${className}`} onClick={handleClick}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onViewProfile(candidate)}
      >
        <Eye className="w-4 h-4 ml-2" />
        צפייה בפרופיל
      </Button>

      <Button variant="outline" size="sm" onClick={() => onInvite(candidate)}>
        <Mail className="w-4 h-4 ml-2" />
        שליחת הזמנה
      </Button>

      <Button variant="outline" size="sm" onClick={() => onSuggest(candidate)}>
        <FileText className="w-4 h-4 ml-2" />
        הצעת שידוך
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => onCheckAvailability(candidate)}
      >
        <Clock className="w-4 h-4 ml-2" />
        בדיקת זמינות
      </Button>

      <Button
        variant="ghost"
        size="sm"
        className="text-red-600 hover:text-red-700 hover:bg-red-50"
      >
        <Heart className="w-4 h-4" />
      </Button>
    </div>
  );
};

export default Actions;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidateCard\MinimalCard.tsx:
==================================================
// MinimalCard.tsx - עם תמיכה בהדגשת מונח חיפוש
"use client";

import React, { useEffect, useState, useRef } from "react";
import Image from "next/image";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  User,
  MapPin,
  Briefcase,
  Calendar,
  Clock,
  CheckCircle,
  Star,
} from "lucide-react";
import type { Candidate } from "../types/candidates";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import { motion } from "framer-motion";
import { Skeleton } from "@/components/ui/skeleton";

interface MinimalCandidateCardProps {
  candidate: Candidate;
  onClick: (candidate: Candidate) => void;
  onEdit?: (candidate: Candidate) => void;
  isHighlighted?: boolean;
  highlightTerm?: string;
  className?: string;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const MinimalCandidateCard: React.FC<MinimalCandidateCardProps> = ({
  candidate,
  onClick,
  onEdit,
  isHighlighted = false,
  highlightTerm = "",
  className,
}) => {
  const mainImage = candidate.images.find((img) => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);
  const [isMobile, setIsMobile] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);
  const cardRef = useRef<HTMLDivElement>(null);

  // Check if we're on mobile
  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    return () => {
      window.removeEventListener("resize", checkScreenSize);
    };
  }, []);

  // Highlight text if search term is provided
  const highlightText = (text: string): React.ReactNode => {
    if (!highlightTerm || !text) return text;

    const parts = text.split(new RegExp(`(${highlightTerm})`, "gi"));
    return (
      <>
        {parts.map((part, i) =>
          part.toLowerCase() === highlightTerm.toLowerCase() ? (
            <mark key={i} className="bg-yellow-200 px-0.5 rounded-sm">
              {part}
            </mark>
          ) : (
            part
          )
        )}
      </>
    );
  };

  // Format availability status
  const getAvailabilityBadge = () => {
    switch (candidate.profile.availabilityStatus) {
      case "AVAILABLE":
        return {
          label: "פנוי/ה",
          className: "bg-emerald-100 text-emerald-800 border-emerald-200",
        };
      case "DATING":
        return {
          label: "בתהליך הכרות",
          className: "bg-amber-100 text-amber-800 border-amber-200",
        };
      case "UNAVAILABLE":
        return {
          label: "לא פנוי/ה",
          className: "bg-red-100 text-red-800 border-red-200",
        };
      default:
        return {
          label: "לא ידוע",
          className: "bg-gray-100 text-gray-800 border-gray-200",
        };
    }
  };

  const availabilityBadge = getAvailabilityBadge();

  return (
    <motion.div
      whileHover={{ y: -4 }}
      transition={{ type: "spring", stiffness: 300, damping: 15 }}
    >
      <Card
        ref={cardRef}
        className={`relative overflow-hidden cursor-pointer transition-all hover:shadow-md duration-300 ${
          isHighlighted ? "ring-2 ring-blue-400 shadow-lg" : ""
        } ${className || ""}`}
        onClick={() => onClick(candidate)}
      >
        {/* Status Badge - relocated to top left for better visibility */}
        <div className="absolute top-2 left-2 z-10">
          <Badge
            variant="outline"
            className={`px-2 py-0.5 text-xs font-medium shadow-sm ${availabilityBadge.className}`}
          >
            {availabilityBadge.label}
          </Badge>
        </div>

        {/* Background Image or Avatar with improved gradient overlay */}
        <div
          className={`relative ${
            isMobile ? "h-32" : "h-48 sm:h-56"
          } bg-gradient-to-b from-blue-50 to-blue-100`}
        >
          {mainImage && !imageError ? (
            <>
              {!imageLoaded && (
                <div className="absolute inset-0 flex items-center justify-center bg-gray-100">
                  <Skeleton className="h-full w-full" />
                </div>
              )}
              <Image
                src={mainImage.url}
                alt={`${candidate.firstName} ${candidate.lastName}`}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                priority={false}
                className={`object-cover transition-opacity duration-300 ${
                  imageLoaded ? "opacity-100" : "opacity-0"
                }`}
                onLoad={() => setImageLoaded(true)}
                onError={() => setImageError(true)}
              />
              {/* Gradient overlay for better text readability */}
              <div className="absolute inset-0 bg-gradient-to-t from-gray-900/80 via-gray-900/40 to-transparent" />
            </>
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-blue-50">
              <User className="w-20 h-20 text-gray-400" />
            </div>
          )}

          {/* Name and basic info overlay at bottom of image for better visual hierarchy */}
          <div className={`absolute bottom-0 w-full p-3 text-right`}>
            <h3
              className={`${
                isMobile ? "text-base" : "text-lg"
              } font-bold mb-0.5 text-white drop-shadow-md`}
            >
              {highlightText(`${candidate.firstName} ${candidate.lastName}`)}
            </h3>

            <div className="flex items-center justify-end gap-2 text-white/90 text-sm">
              <span>{age}</span>
              <Calendar className="w-3 h-3" />
            </div>
          </div>
        </div>

        {/* Content section with improved spacing and organization */}
        <div className={`p-3 ${isMobile ? "py-2" : "p-4"}`}>
          <div
            className={`space-y-1 text-gray-700 ${
              isMobile ? "text-xs" : "text-sm"
            }`}
          >
            {candidate.profile.city && (
              <div className="flex items-center justify-end gap-1">
                <span className="font-medium">
                  {highlightText(candidate.profile.city)}
                </span>
                <MapPin
                  className={`${
                    isMobile ? "w-3 h-3" : "w-4 h-4"
                  } text-blue-600`}
                />
              </div>
            )}

            {candidate.profile.occupation && (
              <div className="flex items-center justify-end gap-1">
                <span>{highlightText(candidate.profile.occupation)}</span>
                <Briefcase
                  className={`${
                    isMobile ? "w-3 h-3" : "w-4 h-4"
                  } text-blue-600`}
                />
              </div>
            )}

            {/* Religious level display */}
            {candidate.profile.religiousLevel && (
              <div className="mt-1">
                <Badge
                  variant="outline"
                  className={`w-full justify-center ${
                    isMobile ? "text-xs py-0" : ""
                  } bg-amber-50`}
                >
                  {highlightText(candidate.profile.religiousLevel)}
                </Badge>
              </div>
            )}

            {/* Last Active - subtler design */}
            {candidate.profile.lastActive && !isMobile && (
              <div className="flex items-center justify-end gap-1 mt-2 text-xs text-gray-400">
                <span>
                  {`פעיל/ה ${formatDistanceToNow(
                    new Date(candidate.profile.lastActive),
                    {
                      addSuffix: true,
                      locale: he,
                    }
                  )}`}
                </span>
                <Clock className="w-3 h-3" />
              </div>
            )}
          </div>
        </div>

        {/* Special indicators */}
        <div className="absolute top-2 right-2 z-10 flex flex-col gap-1.5">
          {/* Verified indicator */}
          {candidate.isVerified && (
            <Badge
              variant="secondary"
              className={`bg-blue-100 text-blue-800 border-blue-200 ${
                isMobile ? "text-xs px-1.5 py-0.5" : ""
              }`}
            >
              <CheckCircle
                className={`${isMobile ? "w-2 h-2 mr-0.5" : "w-3 h-3 mr-1"}`}
              />
              מאומת
            </Badge>
          )}

          {/* References indicator */}
          {(candidate.profile.referenceName1 ||
            candidate.profile.referenceName2) && (
            <Badge
              variant="secondary"
              className={`bg-green-100 text-green-800 border-green-200 ${
                isMobile ? "text-xs px-1.5 py-0.5" : ""
              }`}
            >
              <Star
                className={`${isMobile ? "w-2 h-2 mr-0.5" : "w-3 h-3 mr-1"}`}
              />
              המלצות
            </Badge>
          )}
        </div>

        {/* Edit button - only shown if onEdit provided */}
        {onEdit && (
          <div
            className="absolute bottom-2 left-2 opacity-0 group-hover:opacity-100 transition-opacity z-10"
            onClick={(e) => {
              e.stopPropagation();
              onEdit(candidate);
            }}
          >
            <button
              className="p-1.5 bg-white rounded-full shadow-md hover:bg-gray-50 transition-colors"
              aria-label="ערוך פרופיל"
            >
              <svg
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="text-blue-600"
              >
                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path>
                <path d="m15 5 4 4"></path>
              </svg>
            </button>
          </div>
        )}
      </Card>
    </motion.div>
  );
};

export default MinimalCandidateCard;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidateCard\QuickView.tsx:
==================================================
"use client";
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  Mail,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  User,
  FileText,
  CalendarClock,
  Edit,
} from "lucide-react";

// פונקציה לחישוב גיל
const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";

interface QuickViewProps {
  candidate: Candidate;
  onAction: (
    action: "view" | "invite" | "suggest" | "contact" | "favorite" | "edit"
  ) => void;
}

const QuickView: React.FC<QuickViewProps> = ({ candidate, onAction }) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = candidate.profile;

  return (
    <div
      className="bg-white shadow-xl flex flex-col border border-gray-200 overflow-hidden max-w-md sm:max-w-lg w-full rounded-lg"
      onClick={handleClick}
    >
      {/* Header with name and avatar */}
      <div className="px-6 py-4 bg-gradient-to-r from-blue-500 to-blue-600 border-b text-white">
        <div className="flex items-center justify-between">
          <Badge className="bg-white text-blue-700 border-0 font-medium shadow-sm px-3 py-1">
            {profile.availabilityStatus === "AVAILABLE" ? "פנוי/ה" : "בתהליך"}
          </Badge>
          <h3 className="text-lg font-bold">
            {candidate.firstName} {candidate.lastName}
          </h3>
        </div>
      </div>

      {/* Main content container */}
      <div className="flex-1 p-6 space-y-6 text-right overflow-y-auto max-h-[calc(80vh-200px)] sm:max-h-96 bg-white">
        {/* Key information section */}
        <div className="grid grid-cols-2 gap-y-4 gap-x-6">
          {profile.birthDate && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">
                {calculateAge(new Date(profile.birthDate))} שנים
              </span>
              <CalendarClock className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.height && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.height} ס״מ</span>
              <User className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.maritalStatus}</span>
              <Heart className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.religiousLevel}</span>
              <Scroll className="w-5 h-5 text-blue-500" />
            </div>
          )}
        </div>

        <Separator className="my-4 bg-gray-200" />

        {/* Education & Occupation */}
        <div className="space-y-4">
          <h4 className="text-sm font-bold text-gray-600 mb-3">מידע נוסף</h4>
          {profile.education && (
            <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md">
              <span className="font-medium">{profile.education}</span>
              <GraduationCap className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.occupation && (
            <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
              <span className="font-medium">{profile.occupation}</span>
              <Briefcase className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.city && (
            <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
              <span className="font-medium">{profile.city}</span>
              <MapPin className="w-5 h-5 text-blue-500" />
            </div>
          )}
        </div>

        {/* About section with improved styling */}
        {profile.about && (
          <>
            <Separator className="my-4 bg-gray-200" />
            <div className="space-y-3">
              <h4 className="text-sm font-bold text-gray-600">אודות</h4>
              <p className="text-sm leading-relaxed py-3 px-4 bg-gray-50 rounded-md border border-gray-200 shadow-sm">
                {profile.about}
              </p>
            </div>
          </>
        )}
      </div>

      {/* Action Buttons with improved layout */}
      <div className="p-4 bg-gray-50 border-t border-gray-200">
        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
          <Button
            variant="default"
            className="w-full bg-blue-500 hover:bg-blue-600 transition-colors shadow-sm"
            onClick={() => onAction("view")}
          >
            <Eye className="w-4 h-4 ml-1.5" />
            <span className="text-sm">צפייה בפרופיל</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("suggest")}
          >
            <FileText className="w-4 h-4 ml-1.5" />
            <span className="text-sm">הצעת שידוך</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("invite")}
          >
            <Mail className="w-4 h-4 ml-1.5" />
            <span className="text-sm">שליחת הזמנה</span>
          </Button>

          <Button
            variant="outline"
            className="w-full sm:col-span-2 border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("contact")}
          >
            <Clock className="w-4 h-4 ml-1.5" />
            <span className="text-sm">בדיקת זמינות</span>
          </Button>

          <Button
            variant="ghost"
            className="w-full hover:bg-blue-50 transition-colors bg-blue-50/50"
            onClick={() => onAction("edit")}
          >
            <Edit className="w-4 h-4 ml-1.5" />
            <span className="text-sm">עריכת פרופיל</span>
          </Button>
        </div>
      </div>
    </div>
  );
};

export default QuickView;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesList.tsx:
==================================================
import React, { useState, useCallback, useEffect, useRef } from "react";
import { UserX, Edit } from "lucide-react";
import MinimalCard from "../CandidateCard/MinimalCard";
import QuickView from "../CandidateCard/QuickView";
import { ProfileCard } from "@/app/components/shared/shared/profile";
import type { Candidate, CandidateAction } from "../types/candidates";
import type { QuestionnaireResponse } from "@/types/next-auth";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { ActionDialogs } from "../dialogs/ActionDialogs";
import NewSuggestionForm from "../NewSuggestionForm";
import MatchmakerEditProfile from "../MatchmakerEditProfile";

interface CreateSuggestionData {
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  firstPartyId: string;
  secondPartyId: string;
  status:
    | "DRAFT"
    | "PENDING_FIRST_PARTY"
    | "FIRST_PARTY_APPROVED"
    | "FIRST_PARTY_DECLINED"
    | string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
}

interface CandidatesListProps {
  candidates: Candidate[];
  allCandidates: Candidate[];
  onCandidateClick?: (candidate: Candidate) => void;
  onCandidateAction?: (type: CandidateAction, candidate: Candidate) => void;
  viewMode: "grid" | "list";
  isLoading?: boolean;
  className?: string;
  // הוסף את ה-prop החדש
  highlightTerm?: string;
}

const CandidatesList: React.FC<CandidatesListProps> = ({
  candidates,
  allCandidates,
  onCandidateClick,
  onCandidateAction,
  viewMode,
  isLoading = false,
  className,
  highlightTerm,
}) => {
  // Base states
  const [selectedCandidate, setSelectedCandidate] = useState<Candidate | null>(
    null
  );
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [isMatchmaker, setIsMatchmaker] = useState(false);
  const [hoveredCandidate, setHoveredCandidate] = useState<Candidate | null>(
    null
  );
  const [hoverPosition, setHoverPosition] = useState({ top: 0, left: 0 });
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const quickViewRef = useRef<HTMLDivElement>(null);

  // Dialog states
  const [showInviteDialog, setShowInviteDialog] = useState(false);
  const [showAvailabilityDialog, setShowAvailabilityDialog] = useState(false);
  const [showSuggestDialog, setShowSuggestDialog] = useState(false);
  const [showEditProfileDialog, setShowEditProfileDialog] = useState(false);
  const [dialogCandidate, setDialogCandidate] = useState<Candidate | null>(
    null
  );

  // State for mobile detection
  const [isMobile, setIsMobile] = useState(false);

  // Check screen size on mount and resize
  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    return () => {
      window.removeEventListener("resize", checkScreenSize);
    };
  }, []);

  // Close QuickView when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        hoveredCandidate &&
        quickViewRef.current &&
        !quickViewRef.current.contains(event.target as Node)
      ) {
        setHoveredCandidate(null);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [hoveredCandidate]);

  // Clean up timeout on unmount
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Load questionnaire when candidate is selected
  useEffect(() => {
    const loadQuestionnaire = async () => {
      if (!selectedCandidate) {
        setQuestionnaireResponse(null);
        return;
      }

      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${selectedCandidate.id}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          const formattedQuestionnaire = {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
          setQuestionnaireResponse(formattedQuestionnaire);
        }
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
      }
    };

    loadQuestionnaire();
  }, [selectedCandidate]);

  // Action handlers
  const handleInvite = async (candidate: Candidate, email: string) => {
    try {
      const response = await fetch("/api/matchmaker/candidates/invite", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          candidateId: candidate.id,
          email,
        }),
      });

      if (!response.ok) throw new Error("Failed to send invitation");

      toast.success("ההזמנה נשלחה בהצלחה");
      onCandidateAction?.("invite", candidate);
    } catch (error) {
      console.error("Error sending invite:", error);
      throw error;
    }
  };

  const handleAvailabilityCheck = async (candidate: Candidate) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clientId: candidate.id }),
      });

      if (!response.ok) throw new Error("Failed to check availability");

      toast.success("בדיקת הזמינות נשלחה");
      onCandidateAction?.("contact", candidate);
    } catch (error) {
      console.error("Error checking availability:", error);
      throw error;
    }
  };

  const handleCreateSuggestion = async (data: CreateSuggestionData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      toast.success("ההצעה נוצרה בהצלחה");
      onCandidateAction?.("suggest", dialogCandidate!);
    } catch (error) {
      console.error("Error creating suggestion:", error);
      throw error;
    }
  };

  const handleEditProfile = (candidate: Candidate) => {
    setDialogCandidate(candidate);
    setShowEditProfileDialog(true);
  };

  const handleMouseEnter = (candidate: Candidate, e?: React.MouseEvent) => {
    // On mobile, disable hover behavior to prevent issues with scrolling
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }

    // שמירת מידע על המיקום מחוץ ל-setTimeout
    let top = window.scrollY + window.innerHeight / 3;
    let left = window.innerWidth / 2;

    if (e) {
      const element = e.currentTarget as HTMLElement;
      if (element) {
        const rect = element.getBoundingClientRect();
        const isMobile = window.innerWidth < 768;

        // חישוב מיקום לפי גודל המסך
        top = isMobile
          ? rect.bottom + window.scrollY
          : rect.top + window.scrollY;
        left = isMobile ? rect.left : rect.right + 10;
      }
    }

    hoverTimeoutRef.current = setTimeout(() => {
      setHoverPosition({ top, left });
      setHoveredCandidate(candidate);
    }, 300); // השהייה קטנה למניעת הבהוב בתנועות עכבר מהירות
  };

  const handleMouseLeave = () => {
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
      hoverTimeoutRef.current = null;
    }

    // Small delay before hiding to allow moving to the QuickView
    setTimeout(() => {
      if (!quickViewRef.current?.matches(":hover")) {
        setHoveredCandidate(null);
      }
    }, 100);
  };

  const handleAction = useCallback(
    (action: CandidateAction, candidate: Candidate) => {
      setDialogCandidate(candidate);
      setHoveredCandidate(null); // Close hover card

      switch (action) {
        case "invite":
          setShowInviteDialog(true);
          break;
        case "contact":
          setShowAvailabilityDialog(true);
          break;
        case "suggest":
          setShowSuggestDialog(true);
          break;
        case "view":
          setSelectedCandidate(candidate);
          onCandidateClick?.(candidate);
          break;
        case "edit":
          handleEditProfile(candidate);
          break;
        default:
          onCandidateAction?.(action, candidate);
      }
    },
    [onCandidateAction, onCandidateClick]
  );

  // Loading states render
  if (isLoading) {
    return (
      <div
        className={`${
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            : "space-y-4"
        } ${className || ""}`}
      >
        {Array.from({ length: 6 }).map((_, i) => (
          <div key={i} className="relative">
            <Skeleton
              className={
                viewMode === "list" ? "h-32 w-full" : "h-[350px] w-full"
              }
            />
            <div className="absolute top-3 right-3">
              <Skeleton className="h-6 w-16 rounded-full" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  // Empty state render with improved UI
  if (candidates.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-32 bg-gray-50 rounded-lg border border-dashed border-gray-300 p-4 text-center">
        <UserX className="w-8 h-8 mb-2 text-gray-400" />
        <p className="text-sm font-medium text-gray-500 mb-1">
          לא נמצאו מועמדים
        </p>
        <p className="text-xs text-gray-400">
          נסו להרחיב את החיפוש או להסיר חלק מהמסננים.
        </p>
      </div>
    );
  }

  // Adjust the grid columns for mobile view to make cards smaller
  const gridColumnsClass = isMobile
    ? "grid-cols-1"
    : viewMode === "grid"
    ? "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-3 gap-y-4"
    : "space-y-4";

  return (
    <>
      {/* Candidates List with improved grid/list implementations */}
      <div className={`${gridColumnsClass} ${className || ""}`}>
        {candidates.map((candidate) => (
          <div
            key={candidate.id}
            className="group relative"
            onMouseEnter={(e) => handleMouseEnter(candidate, e)}
            onMouseLeave={handleMouseLeave}
            onClick={() => handleAction("view", candidate)} // Direct click handler for mobile
          >
            <MinimalCard
              candidate={candidate}
              onClick={() => handleAction("view", candidate)}
              className={`
    ${viewMode === "list" ? "flex flex-row-reverse gap-4 h-32" : ""}
    ${isMobile ? "transform scale-95" : ""}
  `}
              // העבר את מונח החיפוש לכרטיסיה
              highlightTerm={highlightTerm}
            />
            {/* Edit button - visible when hovering */}
            <button
              className="absolute top-2 left-2 bg-primary text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity z-10"
              onClick={(e) => {
                e.stopPropagation();
                handleAction("edit", candidate);
              }}
              aria-label="ערוך פרופיל"
              title="ערוך פרופיל"
            >
              <Edit className="w-4 h-4" />
            </button>
          </div>
        ))}
      </div>

      {/* Quick View Popup - Only shown on non-mobile */}
      {hoveredCandidate && !isMobile && (
        <div
          ref={quickViewRef}
          className="fixed z-50 md:absolute transform -translate-x-1/2 sm:translate-x-0"
          style={{
            top: `${hoverPosition.top}px`,
            left: `${hoverPosition.left}px`,
            maxWidth: window.innerWidth < 768 ? "calc(100vw - 32px)" : "420px",
            ...(window.innerWidth < 768
              ? {
                  left: "50%",
                  transform: "translateX(-50%)",
                  maxHeight: "85vh",
                }
              : {}),
          }}
        >
          <div className="drop-shadow-2xl">
            <QuickView
              candidate={hoveredCandidate}
              onAction={(action) => handleAction(action, hoveredCandidate)}
            />
          </div>
        </div>
      )}

      {/* Profile Dialog */}
      <Dialog
        open={!!selectedCandidate}
        onOpenChange={(open) => {
          if (!open) {
            setSelectedCandidate(null);
            setQuestionnaireResponse(null);
          }
        }}
      >
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <div className="flex items-center justify-between">
              <DialogTitle>פרופיל מועמד</DialogTitle>
              <Button
                variant="outline"
                onClick={() => handleAction("edit", selectedCandidate!)}
                className="flex items-center gap-2"
              >
                <Edit className="w-4 h-4" />
                עריכת פרופיל
              </Button>
            </div>
            <DialogDescription>צפייה בפרטי המועמד</DialogDescription>
            <Select
              value={isMatchmaker ? "matchmaker" : "candidate"}
              onValueChange={(value) => setIsMatchmaker(value === "matchmaker")}
            >
              <SelectTrigger className="w-full sm:w-48">
                <SelectValue placeholder="בחר תצוגה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="candidate">תצוגת מועמד</SelectItem>
                <SelectItem value="matchmaker">תצוגת שדכן</SelectItem>
              </SelectContent>
            </Select>
          </DialogHeader>

          {selectedCandidate && (
            <div className="space-y-6">
              <ProfileCard
                profile={selectedCandidate.profile}
                images={selectedCandidate.images}
                questionnaire={questionnaireResponse}
                viewMode={isMatchmaker ? "matchmaker" : "candidate"}
              />
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* Action Dialogs */}
      <ActionDialogs
        suggestDialog={{
          isOpen: showSuggestDialog,
          onClose: () => setShowSuggestDialog(false),
          onSubmit: handleCreateSuggestion,
          selectedCandidate: dialogCandidate,
        }}
        availabilityDialog={{
          isOpen: showAvailabilityDialog,
          onClose: () => setShowAvailabilityDialog(false),
          onCheck: handleAvailabilityCheck,
          selectedCandidate: dialogCandidate,
        }}
        inviteDialog={{
          isOpen: showInviteDialog,
          onClose: () => setShowInviteDialog(false),
          onInvite: handleInvite,
          selectedCandidate: dialogCandidate,
        }}
      />

      {/* New Suggestion Form */}
      <NewSuggestionForm
        isOpen={showSuggestDialog}
        onClose={() => setShowSuggestDialog(false)}
        candidates={allCandidates}
        selectedCandidate={selectedCandidate}
        onSubmit={handleCreateSuggestion}
      />

      {/* Edit Profile Dialog */}
      <MatchmakerEditProfile
        isOpen={showEditProfileDialog}
        onClose={() => setShowEditProfileDialog(false)}
        candidate={dialogCandidate}
      />
    </>
  );
};

export default CandidatesList;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesStats.tsx:
==================================================
// /CandidatesManager/CandidatesStats.tsx

"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Users,
  UserSquare2,
  Clock,
  MapPin,
  CheckCircle,
  Image as ImageIcon,
} from "lucide-react";
import { useStatistics } from "../hooks/useStatistics";
import type { Candidate } from "../types/candidates";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from "recharts";

interface StatCardProps {
  title: string;
  value: string | number;
  description?: string;
  icon: React.ReactNode;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

interface CandidatesStatsProps {
  candidates: Candidate[];
  className?: string;
}

const CHART_COLORS = [
  "#3B82F6", // כחול
  "#EF4444", // אדום
  "#10B981", // ירוק
  "#F59E0B", // כתום
  "#6366F1", // סגול
  "#EC4899", // ורוד
];

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  icon,
  trend,
  className,
}) => (
  <Card className={`p-6 ${className}`}>
    <div className="flex items-start justify-between">
      <div className="space-y-2">
        <p className="text-sm text-gray-500">{title}</p>
        <p className="text-2xl font-semibold">{value}</p>
        {description && <p className="text-xs text-gray-400">{description}</p>}
        {trend && (
          <div
            className={`text-xs flex items-center gap-1 ${
              trend.isPositive ? "text-green-600" : "text-red-600"
            }`}
          >
            <span>{trend.isPositive ? "↑" : "↓"}</span>
            <span>{Math.abs(trend.value)}%</span>
            <span>מהחודש שעבר</span>
          </div>
        )}
      </div>
      <div className="bg-blue-50 p-3 rounded-lg">{icon}</div>
    </div>
  </Card>
);

const CandidatesStats: React.FC<CandidatesStatsProps> = ({
  candidates,
  className,
}) => {
  const {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats,
  } = useStatistics(candidates);

  const genderRatio = getGenderRatio();
  const activeUsers = getActiveUsersPercent();
  const completionStats = getProfileCompletionStats();
  const ageDistribution = getAgeGroupDistribution();
  const religiousDistribution = getReligiousDistribution();
  const activityTrend = getActivityTrend();
  const topCities = getTopCities(5);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* סטטיסטיקות עיקריות */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          title="סה״כ מועמדים"
          value={stats.gender.total}
          icon={<Users className="w-6 h-6 text-blue-600" />}
          description="סה״כ מועמדים פעילים במערכת"
        />
        <StatCard
          title="יחס מועמדים/ות"
          value={genderRatio.formattedRatio}
          icon={<UserSquare2 className="w-6 h-6 text-blue-600" />}
          description="גברים/נשים"
        />
        <StatCard
          title="פעילות בשבוע האחרון"
          value={`${activeUsers}%`}
          icon={<Clock className="w-6 h-6 text-blue-600" />}
          trend={{
            value: 5,
            isPositive: true,
          }}
        />
        <StatCard
          title="פרופילים מלאים"
          value={`${completionStats.percentage}%`}
          icon={<CheckCircle className="w-6 h-6 text-blue-600" />}
          description={`${completionStats.completed} מתוך ${stats.gender.total}`}
        />
      </div>

      {/* טאבים לניתוחים מתקדמים */}
      <Tabs defaultValue="demographics" className="w-full">
        <TabsList className="w-full justify-start">
          <TabsTrigger value="demographics">דמוגרפיה</TabsTrigger>
          <TabsTrigger value="activity">פעילות</TabsTrigger>
          <TabsTrigger value="completion">שלמות פרופילים</TabsTrigger>
        </TabsList>

        {/* דמוגרפיה */}
        <TabsContent value="demographics">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* התפלגות גילאים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות גילאים</h3>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={ageDistribution}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="range" />
                  <YAxis />
                  <Tooltip />
                  <Bar dataKey="count" fill="#3B82F6" />
                </BarChart>
              </ResponsiveContainer>
            </Card>

            {/* התפלגות דתית */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות רמת דתיות</h3>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={religiousDistribution}
                    dataKey="count"
                    nameKey="level"
                    cx="50%"
                    cy="50%"
                    outerRadius={100}
                    label
                  >
                    {religiousDistribution.map((_, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={CHART_COLORS[index % CHART_COLORS.length]}
                      />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </Card>

            {/* מיקומים מובילים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">ערים מובילות</h3>
              <div className="space-y-4">
                {topCities.map((city) => (
                  <div
                    key={city.city}
                    className="flex items-center justify-between"
                  >
                    <div className="flex items-center gap-2">
                      <MapPin className="w-4 h-4 text-blue-600" />
                      <span>{city.city}</span>
                    </div>
                    <span className="font-medium">{city.count}</span>
                  </div>
                ))}
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* פעילות */}
        <TabsContent value="activity">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* פעילות לאורך זמן */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">פעילות משתמשים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <span>פעילים בשבוע האחרון</span>
                  <span className="font-medium">{activityTrend.weekly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>פעילים בחודש האחרון</span>
                  <span className="font-medium">{activityTrend.monthly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>ממוצע ימים בין התחברויות</span>
                  <span className="font-medium">
                    {activityTrend.average} ימים
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* שלמות פרופילים */}
        <TabsContent value="completion">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">שלמות פרופילים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <ImageIcon className="w-4 h-4 text-blue-600" />
                    <span>תמונות פרופיל</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasPhotos}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <CheckCircle className="w-4 h-4 text-blue-600" />
                    <span>פרופיל מאומת</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.isVerified}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Users className="w-4 h-4 text-blue-600" />
                    <span>המלצות</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasReferences}%
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default CandidatesStats;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\index.tsx:
==================================================
"use client";

import React, { useState, useCallback, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Filter,
  LayoutGrid,
  List,
  ArrowUpDown,
  RefreshCw,
  Info,
  SlidersHorizontal,
} from "lucide-react";
import { toast } from "sonner";

// Custom Hooks
import { useCandidates } from "../hooks/useCandidates";
import { useFilterLogic } from "../hooks/useFilterLogic";

// Components
import SplitView from "./SplitView";
import FilterPanel from "../Filters/FilterPanel";
import ActiveFilters from "../Filters/ActiveFilters";
import SearchBar from "../Filters/SearchBar";
import CandidatesStats from "./CandidatesStats";
import { LoadingContainer } from "../shared/LoadingStates";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuLabel,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
  SheetTrigger,
} from "@/components/ui/sheet";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

// Types
import type {
  Candidate,
  ViewMode,
  CandidatesFilter,
  CandidateAction,
} from "../types/candidates";

// Constants
import { SORT_OPTIONS, VIEW_OPTIONS } from "../constants/filterOptions";

const CandidatesManager: React.FC = () => {
  // Local State
  const [viewMode, setViewMode] = useState<ViewMode>("grid");
  const [showFilters, setShowFilters] = useState(false);
  const showStats = false; // קבוע במקום state
  const [localFilters, setLocalFilters] = useState<CandidatesFilter>({});
  const [isProcessing, setIsProcessing] = useState(false);
  const [, setIsMobileView] = useState(false);
  const [showSearchResults, setShowSearchResults] = useState(false);
  const [showFiltersMobile, setShowFiltersMobile] = useState(false);
  const [showExportConfirm, setShowExportConfirm] = useState(false);

  // Custom Hooks
  const {
    loading,
    candidates,
    maleCandidates,
    femaleCandidates,
    filteredCandidates,
    exportCandidates,
    searchResults,
    sorting,
    setSorting,
    setFilters,
  } = useCandidates();

  const {
    filters,
    savedFilters,
    recentSearches,
    popularFilters,
    activeFilters,
    saveFilter,
    resetFilters,
    clearRecentSearches,
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    // פונקציות חדשות לחיפוש נפרד
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
  } = useFilterLogic({
    onFilterChange: (newFilters) => {
      setLocalFilters(newFilters);
      // עדכון הפילטרים ב-useCandidates
      setFilters(newFilters);
    },
  });

  // Check for mobile view
  useEffect(() => {
    const checkMobile = () => {
      setIsMobileView(window.innerWidth < 768);
    };

    checkMobile();
    window.addEventListener("resize", checkMobile);

    return () => {
      window.removeEventListener("resize", checkMobile);
    };
  }, []);

  // Initialize local filters
  useEffect(() => {
    setLocalFilters(filters);
  }, [filters]);

  // Search handlers
  const handleSearch = useCallback(
    (value: string) => {
      // עדכון חיפוש - אם במצב סינון נפרד, החיפוש משפיע רק על שדה החיפוש הכללי
      if (!filters.separateFiltering) {
        // Update local UI state
        setLocalFilters((prev) => ({
          ...prev,
          searchQuery: value,
        }));

        // Update filter state in useCandidates hook
        setFilters((prev) => ({
          ...prev,
          searchQuery: value,
        }));

        setShowSearchResults(!!value);
      }
    },
    [setFilters, filters.separateFiltering]
  );
  const handleMaleSearch = useCallback(
    (value: string) => {
      if (filters.separateFiltering) {
        updateMaleSearchQuery(value);
        setShowSearchResults(!!value);
      }
    },
    [filters.separateFiltering, updateMaleSearchQuery]
  );

  // חיפוש נפרד לנשים
  const handleFemaleSearch = useCallback(
    (value: string) => {
      if (filters.separateFiltering) {
        updateFemaleSearchQuery(value);
        setShowSearchResults(!!value);
      }
    },
    [filters.separateFiltering, updateFemaleSearchQuery]
  );

  const handleRemoveFilter = useCallback(
    (key: keyof CandidatesFilter, value?: string) => {
      setLocalFilters((prev) => {
        const newFilters = { ...prev };

        if (key === "cities" && value) {
          return {
            ...newFilters,
            cities: prev.cities?.filter((city) => city !== value),
          };
        }

        if (key === "occupations" && value) {
          return {
            ...newFilters,
            occupations: prev.occupations?.filter((occ) => occ !== value),
          };
        }

        if (key === "separateFiltering") {
          return {
            ...newFilters,
            separateFiltering: false,
          };
        }

        // טיפול בשדות החיפוש הנפרדים
        if (key === "maleSearchQuery") {
          return {
            ...newFilters,
            maleSearchQuery: "",
            maleFilters: {
              ...newFilters.maleFilters,
              searchQuery: "",
            },
          };
        }

        if (key === "femaleSearchQuery") {
          return {
            ...newFilters,
            femaleSearchQuery: "",
            femaleFilters: {
              ...newFilters.femaleFilters,
              searchQuery: "",
            },
          };
        }

        delete newFilters[key];
        setFilters(newFilters); // עדכון גם ב-useCandidates
        return newFilters;
      });
    },
    [setFilters]
  );

  const handleCandidateAction = useCallback(
    async (type: CandidateAction, candidate: Candidate) => {
      if (isProcessing) return;

      setIsProcessing(true);
      try {
        switch (type) {
          case "suggest":
            // Handled by NewSuggestionForm
            toast.success("הצעת השידוך נוצרה בהצלחה", {
              description: `נוצרה הצעת שידוך עבור ${candidate.firstName} ${candidate.lastName}`,
            });
            break;

          case "invite":
            await fetch("/api/matchmaker/invitations", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ candidateId: candidate.id }),
            });
            toast.success("ההזמנה נשלחה בהצלחה", {
              description: `ההזמנה נשלחה ל${candidate.firstName} ${candidate.lastName}`,
            });
            break;

          case "contact":
            toast.success("בקשת יצירת הקשר נשלחה", {
              description: `בקשה ליצירת קשר נשלחה ל${candidate.firstName} ${candidate.lastName}`,
            });
            break;

          case "favorite":
            await fetch("/api/matchmaker/favorites", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ candidateId: candidate.id }),
            });
            toast.success("המועמד/ת נוספ/ה למועדפים", {
              description: `${candidate.firstName} ${candidate.lastName} נוספ/ה למועדפים שלך`,
            });
            break;

          case "edit":
            // Handled by specific component
            break;
        }
      } catch (error) {
        toast.error("אירעה שגיאה בביצוע הפעולה", {
          description:
            error instanceof Error ? error.message : "שגיאה לא ידועה",
        });
      } finally {
        setIsProcessing(false);
      }
    },
    [isProcessing]
  );

  const handleFilterSave = useCallback(
    async (name: string) => {
      try {
        await saveFilter(name, {
          ...localFilters,
          separateFiltering: filters.separateFiltering,
        });
        toast.success("הפילטר נשמר בהצלחה", {
          description: `הפילטר "${name}" נשמר ויהיה זמין לשימוש עתידי`,
        });
      } catch {
        toast.error("שגיאה בשמירת הפילטר");
      }
    },
    [localFilters, saveFilter, filters.separateFiltering]
  );

  const handleExport = useCallback(async () => {
    if (isProcessing) return;

    setIsProcessing(true);
    try {
      await exportCandidates(filteredCandidates, localFilters);
      toast.success("הנתונים יוצאו בהצלחה", {
        description: `קובץ CSV עם ${filteredCandidates.length} מועמדים הורד למחשב שלך`,
      });
      setShowExportConfirm(false);
    } catch (error) {
      toast.error("שגיאה בייצוא הנתונים", {
        description: "אירעה שגיאה בעת ייצוא הנתונים, אנא נסה שוב מאוחר יותר.",
      });
      console.error("Failed to export candidates:", error);
    } finally {
      setIsProcessing(false);
    }
  }, [filteredCandidates, localFilters, exportCandidates, isProcessing]);

  const renderSearchSummary = () => {
    // עדכון - תצוגת סיכום חיפוש תלויה במצב הסינון
    if (!searchResults) return null;

    // אם במצב סינון נפרד, הסיכום יוצג בצורה שונה
    if (filters.separateFiltering) {
      return null; // במצב סינון נפרד, כל צד מציג את הסיכום שלו בנפרד
    }

    return (
      <div className="bg-blue-50/50 p-3 border rounded-lg mb-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Info className="w-4 h-4 text-blue-500" />
            <h3 className="font-medium">תוצאות חיפוש: {searchResults.term}</h3>
          </div>
          <div className="flex items-center gap-2">
            <Badge variant="outline" className="bg-white">
              {searchResults.count} תוצאות
            </Badge>
            <Button
              variant="ghost"
              size="sm"
              className="h-7 text-xs text-gray-600"
              onClick={() => handleRemoveFilter("searchQuery")}
            >
              <RefreshCw className="w-3 h-3 ml-1" />
              נקה חיפוש
            </Button>
          </div>
        </div>
        <div className="text-sm text-gray-600 mt-1 flex gap-3">
          <span>גברים: {searchResults.male}</span>
          <span>נשים: {searchResults.female}</span>
        </div>
      </div>
    );
  };

  // חישוב ספירת הפילטרים הפעילים
  const countActiveFilters = () => {
    return activeFilters.length;
  };

  // הצגת באנר הסבר על מצב סינון נפרד
  const renderSeparateFilteringInfo = () => {
    if (!filters.separateFiltering) return null;

    return (
      <div className="bg-blue-50 border border-blue-200 p-3 rounded-lg mb-4 flex justify-between items-center">
        <div className="flex items-center gap-2">
          <SlidersHorizontal className="w-4 h-4 text-blue-500" />
          <span className="font-medium text-blue-700">
            מצב סינון וחיפוש נפרד פעיל
          </span>
          <span className="text-sm text-blue-600">
            - סינון וחיפוש שונה מוחל על מועמדים ומועמדות
          </span>
        </div>
        <Button
          variant="outline"
          size="sm"
          onClick={toggleSeparateFiltering}
          className="bg-white text-blue-700 border-blue-200 hover:bg-blue-100 hover:text-blue-800 transition-colors"
        >
          <RefreshCw className="w-3.5 h-3.5 mr-1.5" />
          חזור לסינון רגיל
        </Button>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="sticky top-0 z-10 bg-white border-b shadow-sm">
        <div className="container mx-auto py-4">
          {/* Search and Filters Bar */}
          <div className="mt-4 flex flex-col sm:flex-row gap-4">
            <div className="flex-1">
              {/* שדה חיפוש ראשי - נראה רק אם לא במצב סינון נפרד */}
              {!filters.separateFiltering && (
                <SearchBar
                  value={localFilters.searchQuery || ""}
                  onChange={handleSearch}
                  onSelect={() => {
                    /* Handle candidate selection */
                  }}
                  recentSearches={recentSearches}
                  onSaveSearch={(term) => handleSearch(term)}
                  onClearRecentSearches={clearRecentSearches}
                  placeholder="חיפוש לפי שם, עיר, תחום עיסוק ועוד..."
                  autoFocus={false}
                  genderTarget="all"
                  separateMode={false}
                />
              )}
            </div>

            <div className="flex gap-2">
              {/* Sort Dropdown */}
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" disabled={isProcessing}>
                    <ArrowUpDown className="w-4 h-4 ml-2" />
                    מיון
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-56">
                  <DropdownMenuLabel>מיון לפי</DropdownMenuLabel>
                  <DropdownMenuSeparator />
                  {SORT_OPTIONS.map((option) => (
                    <DropdownMenuItem
                      key={option.value}
                      onClick={() =>
                        setSorting(
                          option.value,
                          option.defaultOrder as "asc" | "desc"
                        )
                      }
                      className={
                        sorting.field === option.value
                          ? "bg-blue-50 text-blue-700 font-medium"
                          : ""
                      }
                    >
                      <div className="flex items-center justify-between w-full">
                        <span>{option.label}</span>
                        {sorting.field === option.value && (
                          <Badge variant="outline" className="text-xs">
                            {sorting.direction === "asc" ? "עולה" : "יורד"}
                          </Badge>
                        )}
                      </div>
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>

              {/* Filter Button - desktop */}
              <Button
                variant="outline"
                onClick={() => setShowFilters((prev) => !prev)}
                disabled={isProcessing}
                className={`hidden md:flex ${
                  showFilters ? "bg-blue-50 text-blue-700 border-blue-200" : ""
                }`}
              >
                <Filter className="w-4 h-4 ml-2" />
                {showFilters ? "הסתר סינון" : "הצג סינון"}
              </Button>

              {/* Filter Button - mobile sheet */}
              <Sheet
                open={showFiltersMobile}
                onOpenChange={setShowFiltersMobile}
              >
                <SheetTrigger asChild>
                  <Button
                    variant="outline"
                    className="md:hidden relative"
                    disabled={isProcessing}
                  >
                    <Filter className="w-4 h-4 ml-2" />
                    סינון
                    {countActiveFilters() > 0 && (
                      <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center">
                        {countActiveFilters()}
                      </Badge>
                    )}
                  </Button>
                </SheetTrigger>
                <SheetContent side="right" className="w-full sm:max-w-lg p-0">
                  <SheetHeader className="p-4 border-b">
                    <SheetTitle>סינון מועמדים</SheetTitle>
                    <SheetDescription>
                      הגדר את הפילטרים לסינון המועמדים
                    </SheetDescription>
                  </SheetHeader>
                  <div className="p-1">
                    <FilterPanel
                      filters={localFilters}
                      onFiltersChange={(newFilters) => {
                        // עדכון הפילטרים המקומיים והגלובליים
                        setLocalFilters(newFilters);
                        setFilters(newFilters);
                      }}
                      onSavePreset={handleFilterSave}
                      onReset={resetFilters}
                      savedFilters={savedFilters.map((f) => ({
                        id: f.id,
                        name: f.name,
                        isDefault: f.isDefault,
                      }))}
                      popularFilters={popularFilters}
                      separateFiltering={filters.separateFiltering}
                      onToggleSeparateFiltering={toggleSeparateFiltering}
                      onMaleFiltersChange={updateMaleFilters}
                      onFemaleFiltersChange={updateFemaleFilters}
                      onCopyFilters={copyFilters}
                    />
                  </div>
                </SheetContent>
              </Sheet>

              <div className="flex gap-2">
                {VIEW_OPTIONS.map((option) => (
                  <Button
                    key={option.value}
                    variant={viewMode === option.value ? "default" : "outline"}
                    size="icon"
                    onClick={() => setViewMode(option.value as ViewMode)}
                    title={option.label}
                    disabled={isProcessing}
                  >
                    {option.value === "grid" ? (
                      <LayoutGrid className="w-4 h-4" />
                    ) : (
                      <List className="w-4 h-4" />
                    )}
                  </Button>
                ))}
              </div>
            </div>
          </div>

          {/* Active Filters */}
          <div className="mt-4">
            <ActiveFilters
              filters={localFilters}
              onRemoveFilter={handleRemoveFilter}
              onResetAll={resetFilters}
              onSuggestFilter={() => {
                /* Intelligent filter suggestion logic */
                toast.info("מציע פילטרים חכמים...");
              }}
            />
          </div>
        </div>
      </div>

      <div className="container mx-auto py-6">
        {/* Search Results Summary */}
        {showSearchResults && renderSearchSummary()}

        {/* Separate Filtering Banner */}
        {renderSeparateFilteringInfo()}

        {/* Statistics Overview */}
        {showStats && (
          <CandidatesStats candidates={filteredCandidates} className="mb-6" />
        )}

        <div className="flex gap-6">
          {/* Filters Panel - Desktop */}
          {showFilters && (
            <div className="hidden md:block w-80">
              <FilterPanel
                filters={localFilters}
                onFiltersChange={(newFilters) => {
                  // עדכון הפילטרים המקומיים והגלובליים
                  setLocalFilters(newFilters);
                  setFilters(newFilters);
                }}
                onSavePreset={handleFilterSave}
                onReset={resetFilters}
                savedFilters={savedFilters.map((f) => ({
                  id: f.id,
                  name: f.name,
                  isDefault: f.isDefault,
                }))}
                popularFilters={popularFilters}
                separateFiltering={filters.separateFiltering}
                onToggleSeparateFiltering={toggleSeparateFiltering}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
              />
            </div>
          )}
          {/* Main Content */}
          <div className="flex-1">
            {loading ? (
              <LoadingContainer>
                <SplitView
                  maleCandidates={[]}
                  femaleCandidates={[]}
                  onCandidateAction={() => {}}
                  viewMode={viewMode}
                  isLoading
                  separateFiltering={filters.separateFiltering}
                  maleFilters={filters.maleFilters}
                  femaleFilters={filters.femaleFilters}
                  onMaleFiltersChange={updateMaleFilters}
                  onFemaleFiltersChange={updateFemaleFilters}
                  onCopyFilters={copyFilters}
                />
              </LoadingContainer>
            ) : (
              <SplitView
                maleCandidates={maleCandidates}
                femaleCandidates={femaleCandidates}
                allCandidates={candidates}
                onCandidateAction={handleCandidateAction}
                viewMode={viewMode}
                separateFiltering={filters.separateFiltering}
                maleFilters={filters.maleFilters}
                femaleFilters={filters.femaleFilters}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
                // העברת נתוני החיפוש הנפרד
                maleSearchQuery={filters.maleSearchQuery}
                femaleSearchQuery={filters.femaleSearchQuery}
                onMaleSearchChange={handleMaleSearch}
                onFemaleSearchChange={handleFemaleSearch}
              />
            )}
          </div>
        </div>
      </div>

      {/* Export Confirmation Dialog */}
      {showExportConfirm && (
        <AlertDialog>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>
                האם לייצא את התוצאות הנוכחיות?
              </AlertDialogTitle>
              <AlertDialogDescription>
                אתה עומד לייצא {filteredCandidates.length} מועמדים לקובץ CSV.
                האם להמשיך?
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel onClick={() => setShowExportConfirm(false)}>
                ביטול
              </AlertDialogCancel>
              <AlertDialogAction onClick={handleExport} disabled={isProcessing}>
                {isProcessing ? "מייצא..." : "אישור ייצוא"}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}
    </div>
  );
};

export default CandidatesManager;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\SplitView.tsx:
==================================================
"use client";

import React, {
  useState,
  useCallback,
  useMemo,
  useEffect,
  useRef,
} from "react";
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";
import CandidatesList from "./CandidatesList";
import StatsCard from "./StatsCard";
import { Badge } from "@/components/ui/badge";
import {
  Users,
  UserCheck,
  Clock,
  Calendar,
  ChevronDown,
  Filter,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import type { Candidate, CandidateAction } from "../types/candidates";
import type { FilterState } from "../types/filters";
import { calculateAge } from "@/lib/utils";
import SearchBar from "../Filters/SearchBar";
interface SplitViewProps {
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  allCandidates?: Candidate[];
  onCandidateClick?: (candidate: Candidate) => void;
  onCandidateAction: (type: CandidateAction, candidate: Candidate) => void;
  viewMode: "grid" | "list";
  isLoading?: boolean;
  className?: string;
  highlightTerm?: string;

  // פרמטרים לסינון נפרד
  separateFiltering: boolean;
  maleFilters?: Partial<FilterState>;
  femaleFilters?: Partial<FilterState>;
  onMaleFiltersChange: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange: (filters: Partial<FilterState>) => void;
  onCopyFilters: (source: "male" | "female", target: "male" | "female") => void;

  // הוספת פרמטרים לחיפוש נפרד
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  onMaleSearchChange?: (query: string) => void;
  onFemaleSearchChange?: (query: string) => void;
}

interface Stats {
  activeCount: number;
  verifiedCount: number;
  availableCount: number;
}

const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;

const SplitView: React.FC<SplitViewProps> = ({
  maleCandidates,
  femaleCandidates,
  allCandidates = [],
  onCandidateClick,
  onCandidateAction,
  viewMode,
  isLoading = false,
  className,
  separateFiltering,
  maleFilters = {},
  femaleFilters = {},
  // פרמטרים חדשים לחיפוש נפרד
  maleSearchQuery = "",
  femaleSearchQuery = "",
  onMaleSearchChange,
  onFemaleSearchChange,
}) => {
  // Panel configuration state
  const [panels] = useState({
    male: {
      id: "male-panel",
      minSize: 30,
      defaultSize: 50,
    },
    female: {
      id: "female-panel",
      minSize: 30,
      defaultSize: 50,
    },
  });

  // State for mobile view
  const [isMobile, setIsMobile] = useState(false);
  const maleScrollRef = useRef<HTMLDivElement>(null);
  const femaleScrollRef = useRef<HTMLDivElement>(null);
  const [showMaleFilters, setShowMaleFilters] = useState(false);
  const [showFemaleFilters, setShowFemaleFilters] = useState(false);

  // Check screen size on mount and resize
  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    return () => {
      window.removeEventListener("resize", checkScreenSize);
    };
  }, []);

  // Wrapper function for handling all action types
  const handleAction = useCallback(
    (type: CandidateAction, candidate: Candidate) => {
      if (type === "view" && onCandidateClick) {
        onCandidateClick(candidate);
        return;
      }
      onCandidateAction(type, candidate);
    },
    [onCandidateAction, onCandidateClick]
  );
  const renderSearchField = (gender: "male" | "female") => {
    console.log(
      `Trying to render search field for ${gender}, separateFiltering: ${separateFiltering}`
    );

    if (!separateFiltering) {
      console.log(
        `Not rendering search for ${gender} - separateFiltering is off`
      );
      return null;
    }

    const isMale = gender === "male";
    const searchValue = isMale ? maleSearchQuery : femaleSearchQuery;
    const handleChange = isMale ? onMaleSearchChange : onFemaleSearchChange;

    console.log(
      `For ${gender}: searchValue=${searchValue}, handleChange exists: ${!!handleChange}`
    );

    if (!handleChange) {
      console.log(`Not rendering search for ${gender} - no handler`);
      return null;
    }

    return (
      <div className="mb-4">
        <SearchBar
          value={searchValue || ""}
          onChange={handleChange}
          placeholder={isMale ? "חיפוש מועמדים..." : "חיפוש מועמדות..."}
          className="w-full"
          genderTarget={gender}
          separateMode={true}
        />
      </div>
    );
  };
  // Memoized stats calculations
  const calculateStats = useCallback((candidates: Candidate[]): Stats => {
    const now = Date.now();

    return {
      activeCount: candidates.filter(
        (c) =>
          c.profile.lastActive &&
          new Date(c.profile.lastActive).getTime() > now - ONE_WEEK
      ).length,

      verifiedCount: candidates.filter((c) => c.isVerified).length,

      availableCount: candidates.filter(
        (c) => c.profile.availabilityStatus === "AVAILABLE"
      ).length,
    };
  }, []);

  const maleStats = useMemo(
    () => calculateStats(maleCandidates),
    [maleCandidates, calculateStats]
  );

  const femaleStats = useMemo(
    () => calculateStats(femaleCandidates),
    [femaleCandidates, calculateStats]
  );

  // פונקציית עזר לסינון מועמדים לפי פילטרים
  const applyFiltersToCandidate = useCallback(
    (candidate: Candidate, filters: Partial<FilterState>): boolean => {
      if (!filters) return true;

      // בדיקת גיל
      if (filters.ageRange) {
        const age = calculateAge(new Date(candidate.profile.birthDate));
        if (age < filters.ageRange.min || age > filters.ageRange.max) {
          return false;
        }
      }

      // בדיקת גובה
      if (filters.heightRange && candidate.profile.height) {
        if (
          candidate.profile.height < filters.heightRange.min ||
          candidate.profile.height > filters.heightRange.max
        ) {
          return false;
        }
      }

      // בדיקת רמת דתיות
      if (
        filters.religiousLevel &&
        candidate.profile.religiousLevel !== filters.religiousLevel
      ) {
        return false;
      }

      // בדיקת ערים
      if (filters.cities?.length && candidate.profile.city) {
        if (!filters.cities.includes(candidate.profile.city)) {
          return false;
        }
      }

      // בדיקת עיסוקים
      if (filters.occupations?.length && candidate.profile.occupation) {
        if (!filters.occupations.includes(candidate.profile.occupation)) {
          return false;
        }
      }

      // בדיקת השכלה
      if (
        filters.educationLevel &&
        candidate.profile.education !== filters.educationLevel
      ) {
        return false;
      }

      // בדיקת מצב משפחתי
      if (
        filters.maritalStatus &&
        candidate.profile.maritalStatus !== filters.maritalStatus
      ) {
        return false;
      }

      // בדיקת זמינות
      if (
        filters.availabilityStatus &&
        candidate.profile.availabilityStatus !== filters.availabilityStatus
      ) {
        return false;
      }
      // בדיקת אימות
      if (
        filters.isVerified !== undefined &&
        candidate.isVerified !== filters.isVerified
      ) {
        return false;
      }
      if (
        filters.userStatus !== undefined &&
        candidate.status !== filters.userStatus
      ) {
        return false;
      }
      // בדיקת המלצות
      if (
        filters.hasReferences &&
        !candidate.profile.referenceName1 &&
        !candidate.profile.referenceName2
      ) {
        return false;
      }

      // בדיקת פעילות אחרונה
      if (filters.lastActiveDays && candidate.profile.lastActive) {
        const lastActive = new Date(candidate.profile.lastActive);
        const daysDiff =
          (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
        if (daysDiff > filters.lastActiveDays) {
          return false;
        }
      }

      // בדיקת שלמות פרופיל
      if (
        filters.isProfileComplete !== undefined &&
        candidate.isProfileComplete !== filters.isProfileComplete
      ) {
        return false;
      }

      // בדיקת מונח חיפוש
      if (filters.searchQuery) {
        const searchTerm = filters.searchQuery.toLowerCase().trim();
        if (searchTerm) {
          const fullName =
            `${candidate.firstName} ${candidate.lastName}`.toLowerCase();
          const city = (candidate.profile.city || "").toLowerCase();
          const occupation = (candidate.profile.occupation || "").toLowerCase();
          const religiousLevel = (
            candidate.profile.religiousLevel || ""
          ).toLowerCase();

          if (
            !fullName.includes(searchTerm) &&
            !city.includes(searchTerm) &&
            !occupation.includes(searchTerm) &&
            !religiousLevel.includes(searchTerm)
          ) {
            return false;
          }
        }
      }

      return true;
    },
    []
  );

  const filteredMaleCandidates = useMemo(() => {
    // Always apply gender-specific filters when separateFiltering is enabled
    if (separateFiltering && maleFilters) {
      return maleCandidates.filter((candidate) =>
        applyFiltersToCandidate(candidate, maleFilters)
      );
    }

    // Fall back to the original candidates list if not using separate filtering
    return maleCandidates;
  }, [maleCandidates, maleFilters, separateFiltering, applyFiltersToCandidate]);

  const filteredFemaleCandidates = useMemo(() => {
    // Always apply gender-specific filters when separateFiltering is enabled
    if (separateFiltering && femaleFilters) {
      return femaleCandidates.filter((candidate) =>
        applyFiltersToCandidate(candidate, femaleFilters)
      );
    }

    // Fall back to the original candidates list if not using separate filtering
    return femaleCandidates;
  }, [
    femaleCandidates,
    femaleFilters,
    separateFiltering,
    applyFiltersToCandidate,
  ]);

  // בדיקת פילטרים פעילים עבור כל מגדר
  const getActiveFilterCount = (
    filters: Partial<FilterState> | undefined
  ): number => {
    if (!filters) return 0;

    let count = 0;
    if (filters.ageRange) count++;
    if (filters.heightRange) count++;
    if (filters.religiousLevel) count++;
    if (filters.cities?.length) count++;
    if (filters.occupations?.length) count++;
    if (filters.educationLevel) count++;
    if (filters.maritalStatus) count++;
    if (filters.availabilityStatus) count++;
    if (filters.isVerified !== undefined) count++;
    if (filters.hasReferences !== undefined) count++;
    if (filters.isProfileComplete !== undefined) count++;
    if (filters.lastActiveDays) count++;

    return count;
  };

  const maleFilterCount = getActiveFilterCount(maleFilters);
  const femaleFilterCount = getActiveFilterCount(femaleFilters);

  const renderStats = (
    stats: Stats,
    total: number,
    gender: "male" | "female"
  ) => (
    <div className="grid grid-cols-2 sm:grid-cols-4 gap-2 mb-2">
      <StatsCard
        icon={Users}
        title="סה״כ"
        value={total}
        variant="default"
        bgGradient={
          gender === "male"
            ? "from-blue-50 to-blue-100"
            : "from-purple-50 to-purple-100"
        }
        iconColor={gender === "male" ? "text-blue-600" : "text-purple-600"}
      />
      <StatsCard
        icon={Clock}
        title="פעילים"
        value={stats.activeCount}
        variant="success"
        bgGradient={
          gender === "male"
            ? "from-blue-50 to-blue-100"
            : "from-purple-50 to-purple-100"
        }
        iconColor={gender === "male" ? "text-blue-600" : "text-purple-600"}
        trend={{
          value: Math.round((stats.activeCount / total) * 100),
          label: "מכלל המועמדים",
          isPositive: true,
        }}
      />
      <StatsCard
        icon={UserCheck}
        title="מאומתים"
        value={stats.verifiedCount}
        variant="success"
        bgGradient={
          gender === "male"
            ? "from-blue-50 to-blue-100"
            : "from-purple-50 to-purple-100"
        }
        iconColor={gender === "male" ? "text-blue-600" : "text-purple-600"}
        trend={{
          value: Math.round((stats.verifiedCount / total) * 100),
          label: "מכלל המועמדים",
          isPositive: true,
        }}
      />
      <StatsCard
        icon={Calendar}
        title="פנויים"
        value={stats.availableCount}
        variant="warning"
        bgGradient={
          gender === "male"
            ? "from-blue-50 to-blue-100"
            : "from-purple-50 to-purple-100"
        }
        iconColor={gender === "male" ? "text-blue-600" : "text-purple-600"}
        trend={{
          value: Math.round((stats.availableCount / total) * 100),
          label: "מכלל המועמדים",
          isPositive: true,
        }}
      />
    </div>
  );

  // הרכיב של בחירת הפילטרים למגדר ספציפי
  // בקובץ SplitView.tsx - הקוד המתוקן

  const renderGenderFilterControls = (gender: "male" | "female") => {
    const isMaleGender = gender === "male";
    const toggleFilters = isMaleGender
      ? () => setShowMaleFilters(!showMaleFilters)
      : () => setShowFemaleFilters(!showFemaleFilters);
    const filterCount = isMaleGender ? maleFilterCount : femaleFilterCount;

    return (
      <div
        className={`flex items-center gap-2 mb-2 px-2 py-1.5 rounded-md ${
          isMaleGender ? "bg-blue-50" : "bg-purple-50"
        }`}
      >
        <Button
          variant="ghost"
          size="sm"
          onClick={toggleFilters}
          className={`flex items-center gap-1.5 text-xs px-2 py-1 h-7 relative ${
            isMaleGender
              ? "text-blue-700 hover:bg-blue-100"
              : "text-purple-700 hover:bg-purple-100"
          }`}
        >
          <Filter className="w-3.5 h-3.5" />
          <span>סינון</span>
          {filterCount > 0 && (
            <Badge
              className={`h-5 w-5 p-0 flex items-center justify-center absolute -top-2 -right-1 ${
                isMaleGender ? "bg-blue-600" : "bg-purple-600"
              }`}
            >
              {filterCount}
            </Badge>
          )}
        </Button>
      </div>
    );
  };

  // Mobile view with side-by-side scrollable columns
  if (isMobile) {
    return (
      <div
        className={`${
          className || ""
        } bg-white rounded-lg shadow-sm border overflow-hidden`}
      >
        <div className="flex flex-row h-[calc(100vh-200px)]">
          {/* Male candidates column */}
          <div className="w-1/2 flex flex-col border-l">
            <div className="p-2 text-center bg-blue-50 border-b">
              <div className="font-semibold">מועמדים</div>
              <Badge className="bg-blue-100 text-blue-800 border-0">
                {filteredMaleCandidates.length}
              </Badge>
            </div>

            {/* פקדי הסינון הנפרד */}
            {separateFiltering && (
              <>
                {renderGenderFilterControls("male")}
                {renderSearchField("male")}
              </>
            )}

            <div
              ref={maleScrollRef}
              className="flex-1 overflow-y-auto p-2 relative"
            >
              {renderStats(maleStats, filteredMaleCandidates.length, "male")}

              <div className="absolute left-0 top-1/2 transform -translate-y-1/2 bg-blue-200 text-blue-800 p-1 rounded-r-md opacity-80">
                <ChevronDown className="h-4 w-4 animate-bounce" />
              </div>
              <CandidatesList
                candidates={filteredMaleCandidates}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={handleAction}
                viewMode={viewMode}
                isLoading={isLoading}
                className="min-h-[300px] pt-1"
              />
            </div>
          </div>
          {/* Female candidates column */}
          <div className="w-1/2 flex flex-col">
            <div className="p-2 text-center bg-purple-50 border-b">
              <div className="font-semibold">מועמדות</div>
              <Badge className="bg-purple-100 text-purple-800 border-0">
                {filteredFemaleCandidates.length}
              </Badge>
            </div>

            {/* פקדי הסינון הנפרד */}
            {separateFiltering && (
              <>
                {renderGenderFilterControls("female")}
                {renderSearchField("female")}
              </>
            )}

            <div
              ref={femaleScrollRef}
              className="flex-1 overflow-y-auto p-2 relative"
            >
              {renderStats(
                femaleStats,
                filteredFemaleCandidates.length,
                "female"
              )}

              <div className="absolute right-0 top-1/2 transform -translate-y-1/2 bg-purple-200 text-purple-800 p-1 rounded-l-md opacity-80">
                <ChevronDown className="h-4 w-4 animate-bounce" />
              </div>
              <CandidatesList
                candidates={filteredFemaleCandidates}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={handleAction}
                viewMode={viewMode}
                isLoading={isLoading}
                className="min-h-[300px] pt-1"
              />
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Desktop view with resizable panels
  return (
    <div className={`${className || ""}`}>
      <ResizablePanelGroup
        direction="horizontal"
        className="min-h-[800px] rounded-lg bg-white shadow-sm border"
      >
        {/* צד ימין - מועמדים */}
        <ResizablePanel
          id={panels.male.id}
          defaultSize={panels.male.defaultSize}
          minSize={panels.male.minSize}
          className="transition-all duration-200"
        >
          <div className="p-3">
            <div className="mb-2">
              <div className="flex justify-between items-center mb-2">
                <Badge className="bg-blue-100 text-blue-800 text-sm px-2.5 py-1 border-0">
                  {filteredMaleCandidates.length} מועמדים
                </Badge>
                <h2 className="text-lg font-bold text-blue-900">מועמדים</h2>
              </div>

              {/* פקדי הסינון הנפרד */}
              {separateFiltering && (
                <>
                  {renderGenderFilterControls("male")}
                  {renderSearchField("male")}
                </>
              )}

              {/* סטטיסטיקות */}
              {renderStats(maleStats, filteredMaleCandidates.length, "male")}
            </div>

            {/* רשימת המועמדים המסוננים */}
            <CandidatesList
              candidates={filteredMaleCandidates}
              allCandidates={allCandidates}
              onCandidateClick={onCandidateClick}
              onCandidateAction={handleAction}
              viewMode={viewMode}
              isLoading={isLoading}
              className="min-h-[600px]"
              // העבר את מונח החיפוש לצורך הדגשה
              highlightTerm={separateFiltering ? maleSearchQuery : undefined}
            />
          </div>
        </ResizablePanel>

        <ResizableHandle className="w-2 bg-gray-100 hover:bg-gray-200 transition-colors" />

        {/* צד שמאל - מועמדות */}
        <ResizablePanel
          id={panels.female.id}
          defaultSize={panels.female.defaultSize}
          minSize={panels.female.minSize}
          className="transition-all duration-200"
        >
          <div className="p-3">
            <div className="mb-2">
              <div className="flex justify-between items-center mb-2">
                <Badge className="bg-purple-100 text-purple-800 text-sm px-2.5 py-1 border-0">
                  {filteredFemaleCandidates.length} מועמדות
                </Badge>
                <h2 className="text-lg font-bold text-purple-900">מועמדות</h2>
              </div>

              {/* פקדי הסינון הנפרד */}
              {separateFiltering && (
                <>
                  {renderGenderFilterControls("female")}
                  {renderSearchField("female")}
                </>
              )}

              {/* סטטיסטיקות */}
              {renderStats(
                femaleStats,
                filteredFemaleCandidates.length,
                "female"
              )}
            </div>

            {/* רשימת המועמדות המסוננות */}
            <CandidatesList
              candidates={filteredFemaleCandidates}
              allCandidates={allCandidates}
              onCandidateClick={onCandidateClick}
              onCandidateAction={handleAction}
              viewMode={viewMode}
              isLoading={isLoading}
              className="min-h-[600px]"
              // העבר את מונח החיפוש לצורך הדגשה
              highlightTerm={separateFiltering ? femaleSearchQuery : undefined}
            />
          </div>
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  );
};

export default SplitView;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\StatsCard.tsx:
==================================================
"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };
  variant?: "default" | "success" | "warning" | "destructive";
  bgGradient?: string;
  iconColor?: string;
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  variant = "default",
  bgGradient,
  iconColor = "text-primary",
  className,
}) => {
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "border-emerald-200";
      case "warning":
        return "border-amber-200";
      case "destructive":
        return "border-red-200";
      default:
        return "border-gray-200";
    }
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-all duration-300 p-4 overflow-hidden",
        bgGradient ? `bg-gradient-to-br ${bgGradient}` : "bg-card",
        getVariantStyles(),
        className
      )}
    >
      <div className="flex items-start justify-between">
        <div className="mr-4 flex-shrink-0">
          <div className={`p-2.5 rounded-full bg-white/60 backdrop-blur-sm shadow-sm`}>
            <Icon className={`w-4 h-4 ${iconColor}`} />
          </div>
        </div>

        <div className="flex-1 text-right">
          <p className="text-xs text-muted-foreground mb-1">{title}</p>
          <h3 className="text-xl font-bold">{value}</h3>

          {trend && (
            <div className="flex items-center justify-end gap-1 mt-1">
              <span
                className={cn(
                  "text-sm font-medium flex items-center gap-0.5",
                  trend.isPositive ? "text-emerald-600" : "text-red-600"
                )}
              >
                {trend.isPositive ? "+" : "-"}{trend.value}%
                <span className={`${trend.isPositive ? "rotate-0" : "rotate-180"} transition-transform`}>
                  ↑
                </span>
              </span>
              <span className="text-[11px] text-muted-foreground">
                {trend.label}
              </span>
            </div>
          )}
        </div>
      </div>

      {/* Animated background pattern for more visual appeal */}
      <div className="absolute right-0 bottom-0 opacity-10 pointer-events-none">
        <svg width="80" height="80" viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="60" cy="60" r="40" fill="currentColor" />
        </svg>
      </div>
    </Card>
  );
};

export default StatsCard;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\constants\filterOptions.ts:
==================================================
// /constants/filterOptions.ts
import { AvailabilityStatus } from '@prisma/client';

export const AGE_RANGE = {
  min: 18,
  max: 99,
  default: {
    min: 20,
    max: 35
  }
};

export const HEIGHT_RANGE = {
  min: 140,
  max: 210,
  default: {
    min: 150,
    max: 190
  }
};

export const RELIGIOUS_LEVELS = [
  { value: 'חרדי', label: 'חרדי' },
  { value: 'דתי לאומי', label: 'דתי לאומי' },
  { value: 'דתי', label: 'דתי' },
  { value: 'מסורתי', label: 'מסורתי' }
];

export const EDUCATION_LEVELS = [
  { value: 'תיכונית', label: 'השכלה תיכונית' },
  { value: 'ישיבה', label: 'ישיבה' },
  { value: 'סמינר', label: 'סמינר' },
  { value: 'תואר ראשון', label: 'תואר ראשון' },
  { value: 'תואר שני', label: 'תואר שני' },
  { value: 'דוקטורט', label: 'דוקטורט' }
];

export const MARITAL_STATUS = [
  { value: 'רווק/ה', label: 'רווק/ה' },
  { value: 'גרוש/ה', label: 'גרוש/ה' },
  { value: 'אלמן/ה', label: 'אלמן/ה' }
];

export const OCCUPATION_CATEGORIES = [
  { value: 'חינוך', label: 'חינוך והוראה' },
  { value: 'הייטק', label: 'הייטק ותוכנה' },
  { value: 'רפואה', label: 'רפואה ובריאות' },
  { value: 'משפטים', label: 'משפטים' },
  { value: 'עסקים', label: 'עסקים וכלכלה' },
  { value: 'שירותים', label: 'שירותים' },
  { value: 'אחר', label: 'אחר' }
];

export const REGIONS = [
  { value: 'ירושלים', label: 'ירושלים והסביבה' },
  { value: 'תל אביב', label: 'תל אביב והמרכז' },
  { value: 'חיפה', label: 'חיפה והצפון' },
  { value: 'באר שבע', label: 'באר שבע והדרום' },
  { value: 'יהודה ושומרון', label: 'יהודה ושומרון' }
];

export const POPULAR_CITIES = [
  'ירושלים',
  'תל אביב',
  'חיפה',
  'בני ברק',
  'פתח תקווה',
  'אשדוד',
  'נתניה',
  'באר שבע',
  'חולון',
  'רמת גן',
  'בית שמש',
  'מודיעין עילית',
  'אלעד',
  'ביתר עילית'
];

export const AVAILABILITY_STATUS_OPTIONS = [
  { 
    value: AvailabilityStatus.AVAILABLE, 
    label: 'פנוי/ה',
    description: 'מועמד/ת פנוי/ה להצעות'
  },
  { 
    value: AvailabilityStatus.DATING, 
    label: 'בתהליך הכרות',
    description: 'נמצא/ת בתהליך הכרות'
  },
  { 
    value: AvailabilityStatus.UNAVAILABLE, 
    label: 'לא פנוי/ה',
    description: 'לא פנוי/ה להצעות כרגע'
  }
];

export const SORT_OPTIONS = [
  { 
    value: 'lastActive',
    label: 'פעילות אחרונה',
    defaultOrder: 'desc'
  },
  { 
    value: 'age',
    label: 'גיל',
    defaultOrder: 'asc'
  },
  { 
    value: 'name',
    label: 'שם',
    defaultOrder: 'asc'
  },
  { 
    value: 'city',
    label: 'עיר',
    defaultOrder: 'asc'
  },
  { 
    value: 'religiousLevel',
    label: 'רמת דתיות',
    defaultOrder: 'asc'
  },
  { 
    value: 'height',
    label: 'גובה',
    defaultOrder: 'desc'
  },
  { 
    value: 'registrationDate',
    label: 'תאריך הרשמה',
    defaultOrder: 'desc'
  }
];

export const VIEW_OPTIONS = [
  {
    value: 'grid',
    label: 'תצוגת גריד',
    icon: 'LayoutGrid'
  },
  {
    value: 'list',
    label: 'תצוגת רשימה',
    icon: 'List'
  }
];

export const CARD_SIZES = [
  {
    value: 'sm',
    label: 'קטן',
    dimensions: {
      grid: 'h-64',
      list: 'h-24'
    }
  },
  {
    value: 'md',
    label: 'בינוני',
    dimensions: {
      grid: 'h-80',
      list: 'h-32'
    }
  },
  {
    value: 'lg',
    label: 'גדול',
    dimensions: {
      grid: 'h-96',
      list: 'h-40'
    }
  }
];

export const GROUP_BY_OPTIONS = [
  {
    value: 'none',
    label: 'ללא קיבוץ'
  },
  {
    value: 'city',
    label: 'עיר'
  },
  {
    value: 'religiousLevel',
    label: 'רמת דתיות'
  },
  {
    value: 'ageGroup',
    label: 'קבוצת גיל'
  },
  {
    value: 'availability',
    label: 'סטטוס זמינות'
  }
];

export const DEFAULT_FILTERS = {
  gender: undefined,
  ageRange: AGE_RANGE.default,
  heightRange: HEIGHT_RANGE.default,
  cities: [],
  religiousLevel: undefined,
  occupations: [],
  availability: undefined,
  searchQuery: '',
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined
};

export const FILTER_CATEGORIES = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'education', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availability', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\constants\matchingCriteria.ts:
==================================================
// /constants/matchingCriteria.ts

export const CRITERIA_WEIGHTS = {
    // קריטריונים בסיסיים
    age: {
      weight: 15,
      description: 'התאמת גיל',
      thresholds: {
        perfect: 2,  // הפרש של עד שנתיים
        good: 5,     // הפרש של עד 5 שנים
        fair: 8      // הפרש של עד 8 שנים
      }
    },
    
    religiousLevel: {
      weight: 20,
      description: 'התאמה דתית',
      bonusPoints: {
        exactMatch: 1.0,        // התאמה מדויקת
        adjacentLevel: 0.8,     // רמה דתית סמוכה
        twoLevelsApart: 0.4     // הפרש של שתי רמות
      }
    },
  
    location: {
      weight: 10,
      description: 'מיקום גיאוגרפי',
      bonusPoints: {
        sameCity: 1.0,          // אותה עיר
        sameRegion: 0.8,        // אותו אזור
        preferredCity: 0.7,     // עיר מועדפת
        differentRegion: 0.4    // אזור אחר
      }
    },
  
    // קריטריונים מקצועיים והשכלתיים
    education: {
      weight: 8,
      description: 'רמת השכלה',
      bonusPoints: {
        sameLevel: 1.0,         // רמת השכלה זהה
        adjacentLevel: 0.8,     // רמת השכלה סמוכה
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    occupation: {
      weight: 7,
      description: 'תחום עיסוק',
      bonusPoints: {
        sameField: 1.0,         // אותו תחום
        relatedField: 0.8,      // תחום קרוב
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    // קריטריונים אישיים
    familyBackground: {
      weight: 12,
      description: 'רקע משפחתי',
      factors: {
        origin: 0.4,            // מוצא
        parentStatus: 0.3,      // מצב הורים
        familyType: 0.3         // סוג משפחה
      }
    },
  
    personalityMatch: {
      weight: 15,
      description: 'התאמה אישיותית',
      factors: {
        hobbies: 0.3,           // תחביבים משותפים
        lifestyle: 0.4,         // סגנון חיים
        values: 0.3             // ערכים משותפים
      }
    },
  
    // גורמים נוספים
    preferences: {
      weight: 8,
      description: 'העדפות אישיות',
      factors: {
        agePreference: 0.3,     // העדפות גיל
        locationPreference: 0.3, // העדפות מיקום
        otherPreferences: 0.4   // העדפות נוספות
      }
    },
  
    compatibility: {
      weight: 5,
      description: 'תאימות כללית',
      factors: {
        language: 0.3,          // שפה משותפת
        culture: 0.4,           // תרבות
        lifestyle: 0.3          // סגנון חיים
      }
    }
  };
  
  // סף ציון להתאמה טובה
  export const MATCH_THRESHOLDS = {
    EXCELLENT: 85,  // התאמה מצוינת
    GOOD: 75,       // התאמה טובה
    FAIR: 65,       // התאמה סבירה
    POOR: 50        // התאמה חלשה
  };
  
  // משקלים יחסיים לפי סוג התאמה
  export const MATCH_TYPE_WEIGHTS = {
    PRECISE: {     // התאמה מדויקת
      exact: 1.0,
      similar: 0.8,
      partial: 0.5
    },
    FLEXIBLE: {    // התאמה גמישה
      exact: 0.8,
      similar: 1.0,
      partial: 0.7
    },
    OPEN: {        // התאמה פתוחה
      exact: 0.7,
      similar: 0.9,
      partial: 1.0
    }
  };
  
  // הגדרת קטגוריות להתאמה
  export const MATCH_CATEGORIES = {
    IMMEDIATE: {
      minScore: 90,
      label: 'התאמה מיידית',
      description: 'התאמה גבוהה מאוד, מומלץ ליצור קשר בהקדם'
    },
    HIGH: {
      minScore: 80,
      label: 'התאמה גבוהה',
      description: 'התאמה טובה מאוד, שווה לבדוק'
    },
    GOOD: {
      minScore: 70,
      label: 'התאמה טובה',
      description: 'יש פוטנציאל טוב להתאמה'
    },
    MODERATE: {
      minScore: 60,
      label: 'התאמה בינונית',
      description: 'יש נקודות משותפות, אבל גם הבדלים'
    },
    LOW: {
      minScore: 50,
      label: 'התאמה נמוכה',
      description: 'יש פערים משמעותיים בין המועמדים'
    }
  };

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\dialogs\ActionDialogs.tsx:
==================================================
"use client";

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Clock, Mail, Loader2 } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface NewSuggestionFormData {
  firstPartyId: string;
  secondPartyId: string;
  priority: Priority;
  status: MatchSuggestionStatus;
}
interface ActionDialogsProps {
  suggestDialog: {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: NewSuggestionFormData) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  availabilityDialog: {
    isOpen: boolean;
    onClose: () => void;
    onCheck: (candidate: Candidate) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  inviteDialog: {
    isOpen: boolean;
    onClose: () => void;
    onInvite: (candidate: Candidate, email: string) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
}

export const ActionDialogs: React.FC<ActionDialogsProps> = ({
  suggestDialog,
  availabilityDialog,
  inviteDialog,
}) => {
  // State for invite dialog
  const [inviteEmail, setInviteEmail] = useState("");
  const [isInviting, setIsInviting] = useState(false);
  const [inviteError, setInviteError] = useState<string | null>(null);

  // State for availability dialog
  const [isChecking, setIsChecking] = useState(false);
  const [availabilityError, setAvailabilityError] = useState<string | null>(
    null
  );

  // Handler for invite submission
  const handleInviteSubmit = async () => {
    if (!inviteDialog.selectedCandidate || !inviteEmail) return;

    try {
      setIsInviting(true);
      setInviteError(null);
      await inviteDialog.onInvite(inviteDialog.selectedCandidate, inviteEmail);
      setInviteEmail("");
      inviteDialog.onClose();
    } catch (error) {
      setInviteError(
        error instanceof Error ? error.message : "Failed to send invitation"
      );
    } finally {
      setIsInviting(false);
    }
  };

  // Handler for availability check
  const handleAvailabilityCheck = async () => {
    if (!availabilityDialog.selectedCandidate) return;

    try {
      setIsChecking(true);
      setAvailabilityError(null);
      await availabilityDialog.onCheck(availabilityDialog.selectedCandidate);
      availabilityDialog.onClose();
    } catch (error) {
      setAvailabilityError(
        error instanceof Error ? error.message : "Failed to check availability"
      );
    } finally {
      setIsChecking(false);
    }
  };

  return (
    <>
      {/* Invite Dialog */}
      <Dialog open={inviteDialog.isOpen} onOpenChange={inviteDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>שליחת הזמנה למועמד</DialogTitle>
            <DialogDescription>
              {inviteDialog.selectedCandidate && (
                <span>
                  שליחת הזמנה ל: {inviteDialog.selectedCandidate.firstName}{" "}
                  {inviteDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            <div>
              <Label>כתובת אימייל</Label>
              <Input
                type="email"
                value={inviteEmail}
                onChange={(e) => setInviteEmail(e.target.value)}
                placeholder="הזן כתובת אימייל"
                className="mt-2"
              />
            </div>

            {inviteError && (
              <Alert variant="destructive">
                <AlertDescription>{inviteError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={inviteDialog.onClose}
              disabled={isInviting}
            >
              ביטול
            </Button>
            <Button
              onClick={handleInviteSubmit}
              disabled={isInviting || !inviteEmail}
            >
              {isInviting ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Mail className="ml-2 h-4 w-4" />
              )}
              {isInviting ? "שולח..." : "שלח הזמנה"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Availability Check Dialog */}
      <Dialog
        open={availabilityDialog.isOpen}
        onOpenChange={availabilityDialog.onClose}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>בדיקת זמינות</DialogTitle>
            <DialogDescription>
              {availabilityDialog.selectedCandidate && (
                <span>
                  בדיקת זמינות עבור:{" "}
                  {availabilityDialog.selectedCandidate.firstName}{" "}
                  {availabilityDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            {availabilityError && (
              <Alert variant="destructive">
                <AlertDescription>{availabilityError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={availabilityDialog.onClose}
              disabled={isChecking}
            >
              ביטול
            </Button>
            <Button onClick={handleAvailabilityCheck} disabled={isChecking}>
              {isChecking ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Clock className="ml-2 h-4 w-4" />
              )}
              {isChecking ? "בודק..." : "בדוק זמינות"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Suggest Match Dialog */}
      <Dialog open={suggestDialog.isOpen} onOpenChange={suggestDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>הצעת שידוך חדשה</DialogTitle>
            <DialogDescription>
              {suggestDialog.selectedCandidate && (
                <span>
                  יצירת הצעת שידוך עבור:{" "}
                  {suggestDialog.selectedCandidate.firstName}{" "}
                  {suggestDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>
          {/* תוכן הדיאלוג יועבר מהקומפוננטה NewSuggestionForm */}
        </DialogContent>
      </Dialog>
    </>
  );
};

export default ActionDialogs;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\ActiveFilters.tsx:
==================================================
"use client";

import React from "react";
import { X, RefreshCw, Sparkles } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import type { CandidatesFilter } from "../types/candidates";
import { motion, AnimatePresence } from "framer-motion";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ActiveFiltersProps {
  filters: CandidatesFilter;
  onRemoveFilter: (key: keyof CandidatesFilter, value?: string) => void;
  onResetAll: () => void;
  onSuggestFilter?: () => void;
  className?: string;
}

interface ActiveFilter {
  key: keyof CandidatesFilter;
  label: string;
  value?: string;
  color?: string;
}

const ActiveFilters: React.FC<ActiveFiltersProps> = ({
  filters,
  onRemoveFilter,
  onResetAll,
  onSuggestFilter,
  className,
}) => {
  const getActiveFilters = (): ActiveFilter[] => {
    const activeFilters: ActiveFilter[] = [];

    // חיפוש כללי (מופיע רק אם אין סינון נפרד)
    if (!filters.separateFiltering && filters.searchQuery) {
      activeFilters.push({
        key: "searchQuery",
        label: `חיפוש: ${filters.searchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לגברים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.maleSearchQuery) {
      activeFilters.push({
        key: "maleSearchQuery",
        label: `חיפוש מועמדים: ${filters.maleSearchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לנשים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.femaleSearchQuery) {
      activeFilters.push({
        key: "femaleSearchQuery",
        label: `חיפוש מועמדות: ${filters.femaleSearchQuery}`,
        color: "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // מצב סינון נפרד
    if (filters.separateFiltering) {
      activeFilters.push({
        key: "separateFiltering",
        label: `סינון וחיפוש נפרד`,
        color: "bg-indigo-100 text-indigo-800 border-indigo-200",
      });
    }

    // Gender
    if (filters.gender) {
      activeFilters.push({
        key: "gender",
        label: `מגדר: ${filters.gender === "MALE" ? "גברים" : "נשים"}`,
        color:
          filters.gender === "MALE"
            ? "bg-blue-100 text-blue-800 border-blue-200"
            : "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // Age Range
    if (filters.ageRange) {
      const isDefaultMin = filters.ageRange.min === 18;
      const isDefaultMax = filters.ageRange.max === 99;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גיל: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.ageRange.min}-${filters.ageRange.max}`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.ageRange.min}`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.ageRange.max}`;
        }

        activeFilters.push({
          key: "ageRange",
          label,
        });
      }
    }

    // Height Range
    if (filters.heightRange) {
      const isDefaultMin = filters.heightRange.min === 140;
      const isDefaultMax = filters.heightRange.max === 210;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גובה: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.heightRange.min}-${filters.heightRange.max} ס"מ`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.heightRange.min} ס"מ`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.heightRange.max} ס"מ`;
        }

        activeFilters.push({
          key: "heightRange",
          label,
        });
      }
    }

    // Religious Level
    if (filters.religiousLevel) {
      activeFilters.push({
        key: "religiousLevel",
        label: `רמת דתיות: ${filters.religiousLevel}`,
        color: "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Education Level
    if (filters.educationLevel) {
      activeFilters.push({
        key: "educationLevel",
        label: `השכלה: ${filters.educationLevel}`,
      });
    }

    // Cities
    filters.cities?.forEach((city) => {
      activeFilters.push({
        key: "cities",
        value: city,
        label: `עיר: ${city}`,
        color: "bg-green-100 text-green-800 border-green-200",
      });
    });

    // Occupations
    filters.occupations?.forEach((occupation) => {
      activeFilters.push({
        key: "occupations",
        value: occupation,
        label: `תחום עיסוק: ${occupation}`,
      });
    });

    // Availability Status
    if (filters.availabilityStatus) {
      const statusLabel =
        filters.availabilityStatus === "AVAILABLE"
          ? "פנוי/ה"
          : filters.availabilityStatus === "DATING"
          ? "בתהליך הכרות"
          : filters.availabilityStatus === "UNAVAILABLE"
          ? "לא פנוי/ה"
          : filters.availabilityStatus;

      activeFilters.push({
        key: "availabilityStatus",
        label: `סטטוס: ${statusLabel}`,
        color:
          filters.availabilityStatus === "AVAILABLE"
            ? "bg-emerald-100 text-emerald-800 border-emerald-200"
            : "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Marital Status
    if (filters.maritalStatus) {
      activeFilters.push({
        key: "maritalStatus",
        label: `מצב משפחתי: ${filters.maritalStatus}`,
      });
    }

    // Verified Filter
    if (filters.isVerified !== undefined) {
      activeFilters.push({
        key: "isVerified",
        label: `מאומתים בלבד`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // References Filter
    if (filters.hasReferences !== undefined) {
      activeFilters.push({
        key: "hasReferences",
        label: `עם המלצות`,
      });
    }

    // Profile Completeness
    if (filters.isProfileComplete !== undefined) {
      activeFilters.push({
        key: "isProfileComplete",
        label: `פרופיל מלא`,
      });
    }

    // Last Activity
    if (filters.lastActiveDays !== undefined) {
      let label: string;

      switch (filters.lastActiveDays) {
        case 1:
          label = "פעילים היום";
          break;
        case 3:
          label = "פעילים ב-3 ימים אחרונים";
          break;
        case 7:
          label = "פעילים בשבוע האחרון";
          break;
        case 30:
          label = "פעילים בחודש האחרון";
          break;
        default:
          label = `פעילים ב-${filters.lastActiveDays} ימים אחרונים`;
      }

      activeFilters.push({
        key: "lastActiveDays",
        label,
        color: "bg-cyan-100 text-cyan-800 border-cyan-200",
      });
    }

    return activeFilters;
  };

  const activeFilters = getActiveFilters();

  if (activeFilters.length === 0) {
    return null;
  }

  return (
    <div className={`${className || ""}`}>
      <div className="bg-white border rounded-lg p-3">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-sm font-medium text-gray-700 flex items-center gap-1.5">
            <span>סינון פעיל</span>
            <Badge variant="outline" className="bg-blue-50 text-xs">
              {activeFilters.length}
            </Badge>
          </h3>

          <div className="flex items-center gap-2">
            {onSuggestFilter && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={onSuggestFilter}
                      className="h-7 text-xs text-blue-600 hover:text-blue-700 hover:bg-blue-50"
                    >
                      <Sparkles className="w-3 h-3 mr-1" />
                      הצע פילטרים נוספים
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>הצעת פילטרים נוספים המתאימים לתוצאות הנוכחיות</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}

            <Button
              variant="ghost"
              size="sm"
              onClick={onResetAll}
              className="h-7 text-xs text-gray-600 hover:text-gray-700"
            >
              <RefreshCw className="w-3 h-3 mr-1" />
              נקה הכל
            </Button>
          </div>
        </div>

        <div className="flex flex-wrap gap-2">
          <AnimatePresence>
            {activeFilters.map((filter, index) => (
              <motion.div
                key={`${filter.key}-${filter.value || index}`}
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                transition={{ duration: 0.15 }}
              >
                <Badge
                  variant="secondary"
                  className={`px-2 py-0.5 whitespace-nowrap border ${
                    filter.color || "bg-gray-100 text-gray-800 border-gray-200"
                  }`}
                >
                  <span className="max-w-[200px] truncate">{filter.label}</span>
                  <button
                    className="ml-1.5 hover:bg-gray-200/40 rounded-full p-0.5 transition-colors"
                    onClick={() => onRemoveFilter(filter.key, filter.value)}
                    aria-label={`הסר פילטר ${filter.label}`}
                  >
                    <X className="w-3 h-3" />
                  </button>
                </Badge>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
};

export default ActiveFilters;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\FilterPanel.tsx:
==================================================
// /Filters/FilterPanel.tsx - גרסה משופרת
import React, { useState } from "react";
import { Card } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Save,
  User,
  GraduationCap,
  MapPin,
  Scroll,
  Calendar,
  ChevronDown,
  ChevronUp,
  Clock,
  Ruler,
  Heart,
  Briefcase,
  Star,
  RefreshCw,
  Bookmark,
  Check,
  Filter as FilterIcon,
  Copy,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type { FilterState } from "../types/filters";
import type { CandidatesFilter } from "../types/candidates";
import SavedFilters from "./SavedFilters";
import {
  AGE_RANGE,
  HEIGHT_RANGE,
  RELIGIOUS_LEVELS,
  EDUCATION_LEVELS,
  OCCUPATION_CATEGORIES,
  POPULAR_CITIES,
  AVAILABILITY_STATUS_OPTIONS,
  MARITAL_STATUS,
} from "../constants/filterOptions";

interface PopularFilterOption {
  id: string;
  label: string;
  icon: React.ReactNode;
  filter: Partial<CandidatesFilter>;
}

interface FilterPanelProps {
  filters: CandidatesFilter;
  onFiltersChange: (filters: CandidatesFilter) => void;
  onSavePreset?: (name: string) => void;
  onReset: () => void;
  onApplySavedFilter?: (id: string) => void;
  savedFilters?: Array<{
    id: string;
    name: string;
    isDefault?: boolean;
  }>;
  popularFilters?: string[];
  className?: string;
  compactMode?: boolean;

  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering?: boolean;
  onToggleSeparateFiltering?: () => void;
  onMaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}

interface FilterSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
  defaultOpen?: boolean;
  badge?: number;
}

const POPULAR_FILTERS: PopularFilterOption[] = [
  {
    id: "active-recently",
    label: "פעילים לאחרונה",
    icon: <Clock className="w-4 h-4 text-blue-600" />,
    filter: {
      lastActiveDays: 7,
    },
  },
  {
    id: "verified-only",
    label: "מאומתים בלבד",
    icon: <Check className="w-4 h-4 text-blue-600" />,
    filter: {
      isVerified: true,
    },
  },
  {
    id: "has-recommendations",
    label: "עם המלצות",
    icon: <Star className="w-4 h-4 text-blue-600" />,
    filter: {
      hasReferences: true,
    },
  },
  {
    id: "available-only",
    label: "פנויים בלבד",
    icon: <Heart className="w-4 h-4 text-blue-600" />,
    filter: {
      availabilityStatus: "AVAILABLE",
    },
  },
  {
    id: "complete-profiles",
    label: "פרופילים מלאים",
    icon: <User className="w-4 h-4 text-blue-600" />,
    filter: {
      isProfileComplete: true,
    },
  },
];

const FilterSection: React.FC<FilterSectionProps> = ({
  title,
  icon,
  children,
  defaultOpen = false,
  badge,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <Collapsible
      open={isOpen}
      onOpenChange={setIsOpen}
      className="border rounded-lg mb-3 overflow-hidden bg-white"
    >
      <CollapsibleTrigger asChild>
        <div className="flex items-center justify-between p-4 cursor-pointer hover:bg-blue-50/30 transition-colors">
          <div className="flex items-center gap-2">
            <div className="bg-blue-50 p-2 rounded-md text-blue-600">
              {icon}
            </div>
            <span className="font-medium">{title}</span>
            {badge !== undefined && (
              <Badge
                variant="secondary"
                className="bg-blue-100 text-blue-800 text-xs mr-2"
              >
                {badge}
              </Badge>
            )}
          </div>
          {isOpen ? (
            <ChevronUp size={16} className="text-gray-500" />
          ) : (
            <ChevronDown size={16} className="text-gray-500" />
          )}
        </div>
      </CollapsibleTrigger>
      <CollapsibleContent className="px-4 pb-4 pt-1 border-t">
        {children}
      </CollapsibleContent>
    </Collapsible>
  );
};

// קומפוננט חדש לסינון מגדרי
const GenderFilterPanel = ({
  gender,
  filters,
  onFiltersChange,
  className,
  copyTarget,
  onCopyFilters,
}: {
  gender: "male" | "female";
  filters: Partial<FilterState>;
  onFiltersChange: (filters: Partial<FilterState>) => void;
  className?: string;
  copyTarget: "male" | "female";
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}) => {
  const genderColors = {
    male: {
      bg: "bg-blue-50/50",
      border: "border-blue-200",
      text: "text-blue-800",
      icon: <User className="w-4 h-4 text-blue-600" />,
      title: "סינון מועמדים",
    },
    female: {
      bg: "bg-purple-50/50",
      border: "border-purple-200",
      text: "text-purple-800",
      icon: <User className="w-4 h-4 text-purple-600" />,
      title: "סינון מועמדות",
    },
  };

  const colorConfig = genderColors[gender];

  return (
    <div className={`${className} mb-4 border rounded-lg overflow-hidden`}>
      {/* כותרת עם צבע תואם מגדר */}
      <div
        className={`flex justify-between items-center px-4 py-2 ${colorConfig.bg} ${colorConfig.border} border-b`}
      >
        <div className="flex items-center gap-2">
          {colorConfig.icon}
          <h3 className={`text-sm font-medium ${colorConfig.text}`}>
            {colorConfig.title}
          </h3>
        </div>
        {onCopyFilters && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onCopyFilters(gender, copyTarget)}
            className="text-xs h-7 py-0 px-2 flex items-center gap-1"
            title={`העתק הגדרות ל${
              copyTarget === "male" ? "מועמדים" : "מועמדות"
            }`}
          >
            <Copy className="w-3 h-3" />
            <span>העתק ל{copyTarget === "male" ? "מועמדים" : "מועמדות"}</span>
          </Button>
        )}
      </div>

      {/* תוכן הפאנל */}
      <div className="p-3 space-y-4">
        {/* סינון גיל - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">גיל</Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.min || AGE_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= AGE_RANGE.min &&
                      newMin <= AGE_RANGE.max
                    ) {
                      const currentMax =
                        filters?.ageRange?.max || AGE_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.max || AGE_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= AGE_RANGE.min &&
                      newMax <= AGE_RANGE.max
                    ) {
                      const currentMin =
                        filters?.ageRange?.min || AGE_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                value={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                min={AGE_RANGE.min}
                max={AGE_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    ageRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{AGE_RANGE.min}</span>
              <span className="text-xs text-gray-400">{AGE_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* סינון גובה - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">
            גובה (סמ)
          </Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.min || HEIGHT_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= HEIGHT_RANGE.min &&
                      newMin <= HEIGHT_RANGE.max
                    ) {
                      const currentMax =
                        filters?.heightRange?.max || HEIGHT_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.max || HEIGHT_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= HEIGHT_RANGE.min &&
                      newMax <= HEIGHT_RANGE.max
                    ) {
                      const currentMin =
                        filters?.heightRange?.min || HEIGHT_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                value={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                min={HEIGHT_RANGE.min}
                max={HEIGHT_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    heightRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.min}</span>
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* רמת דתיות */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">רמת דתיות</Label>
          <div className="px-2">
            <Select
              value={filters?.religiousLevel || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  religiousLevel: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר רמת דתיות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {RELIGIOUS_LEVELS.map((level) => (
                  <SelectItem key={level.value} value={level.value}>
                    {level.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* מצב משפחתי */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">מצב משפחתי</Label>
          <div className="px-2">
            <Select
              value={filters?.maritalStatus || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  maritalStatus: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר מצב משפחתי" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {MARITAL_STATUS.map((status) => (
                  <SelectItem key={status.value} value={status.value}>
                    {status.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* ערים */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">ערים מבוקשות</Label>
          <div className="px-2">
            <Select
              value={filters.cities?.[0] || ""}
              onValueChange={(value) => {
                if (value === "all") {
                  onFiltersChange({ cities: [] });
                } else {
                  onFiltersChange({ cities: [value] });
                }
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר עיר" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">כל הערים</SelectItem>
                {POPULAR_CITIES.map((city) => (
                  <SelectItem key={city} value={city}>
                    {city}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* סטטוס אימות ותוספות */}
        <div className="space-y-2 pt-2 border-t border-gray-100">
          <div className="flex items-center justify-between px-2">
            <span className="text-xs font-medium">מאומתים בלבד</span>
            <Switch
              checked={filters?.isVerified || false}
              onCheckedChange={(checked) => {
                onFiltersChange({
                  isVerified: checked || undefined,
                });
              }}
            />
          </div>
        </div>

        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">עם המלצות</span>
          <Switch
            checked={filters?.hasReferences || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                hasReferences: checked || undefined,
              });
            }}
          />
        </div>

        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">פרופיל מלא</span>
          <Switch
            checked={filters?.isProfileComplete || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                isProfileComplete: checked || undefined,
              });
            }}
          />
        </div>
      </div>
    </div>
  );
};

const FilterPanel: React.FC<FilterPanelProps> = ({
  filters,
  onFiltersChange,
  onSavePreset,
  onReset,
  onApplySavedFilter,
  savedFilters = [],
  popularFilters = [],
  className,
  compactMode = false,
  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering = false,
  onToggleSeparateFiltering,
  onMaleFiltersChange,
  onFemaleFiltersChange,
  onCopyFilters,
}) => {
  const [showSavePreset, setShowSavePreset] = useState(false);
  const [presetName, setPresetName] = useState("");
  const [activeTab, setActiveTab] = useState<string>("basic");
  const [activeGenderFilter, setActiveGenderFilter] = useState<
    "male" | "female"
  >("male");

  const handleSavePreset = () => {
    if (presetName && onSavePreset) {
      onSavePreset(presetName);
      setPresetName("");
      setShowSavePreset(false);
    }
  };
  const layoutClasses = compactMode
    ? "p-1 space-y-1 text-xs" // הרבה יותר קומפקטי
    : "p-4 space-y-4"; // תצוגה רגילה

  const handleAgeRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      ageRange: { min: value[0], max: value[1] },
    });
  };

  const handleHeightRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      heightRange: { min: value[0], max: value[1] },
    });
  };
  const handleApplyPopularFilter = (filter: Partial<CandidatesFilter>) => {
    onFiltersChange({
      ...filters,
      ...filter,
    });
  };

  const countActiveFilters = (category: string): number => {
    let count = 0;

    switch (category) {
      case "basic":
        // Count basic filters
        if (filters.gender) count++;
        if (
          filters.ageRange &&
          (filters.ageRange.min !== AGE_RANGE.default.min ||
            filters.ageRange.max !== AGE_RANGE.default.max)
        )
          count++;
        if (filters.cities?.length) count++;
        if (filters.religiousLevel) count++;
        break;
      case "advanced":
        // Count advanced filters
        if (
          filters.heightRange &&
          (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
            filters.heightRange.max !== HEIGHT_RANGE.default.max)
        )
          count++;
        if (filters.occupations?.length) count++;
        if (filters.educationLevel) count++;
        if (filters.maritalStatus) count++;
        break;
      case "status":
        // Count status filters
        if (filters.availabilityStatus) count++;
        if (filters.isVerified !== undefined) count++;
        if (filters.hasReferences !== undefined) count++;
        if (filters.lastActiveDays !== undefined) count++;
        if (filters.isProfileComplete !== undefined) count++;
        break;
      case "saved":
        // Count of saved filters is just the length
        return savedFilters.length;
    }

    return count;
  };

  return (
    <Card
      className={`${layoutClasses} border border-slate-200 bg-white/90 shadow-sm ${className}`}
    >
      {/* Header */}
      {!compactMode && (
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <FilterIcon className="w-5 h-5 text-blue-600" />
            <h3 className="font-semibold text-lg">סינון מועמדים</h3>
          </div>
          <div className="flex gap-2">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={onReset}
                    className="h-8 w-8 p-0"
                  >
                    <RefreshCw className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>איפוס כל הפילטרים</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>

            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowSavePreset(!showSavePreset)}
                    className="h-8 w-8 p-0"
                  >
                    <Bookmark className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>שמירת הפילטר הנוכחי</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </div>
      )}

      {/* Popular Filters */}
      {!compactMode && (
        <div className="mb-4">
          <div className="flex flex-wrap gap-2">
            {POPULAR_FILTERS.map((option) => (
              <Button
                key={option.id}
                variant="outline"
                size="sm"
                onClick={() => handleApplyPopularFilter(option.filter)}
                className="bg-white flex items-center gap-1.5 transition-all hover:bg-blue-50 hover:text-blue-700 hover:border-blue-200"
              >
                {option.icon}
                <span>{option.label}</span>
              </Button>
            ))}
          </div>
        </div>
      )}

      {/* Save Preset Form */}
      {showSavePreset && !compactMode && (
        <div className="p-4 border rounded-lg bg-blue-50/50 mb-4">
          <Label>שם לשמירת הפילטר</Label>
          <div className="flex gap-2 mt-2">
            <Input
              value={presetName}
              onChange={(e) => setPresetName(e.target.value)}
              placeholder="פילטר מותאם אישית"
              className="h-9"
            />
            <Button size="sm" onClick={handleSavePreset}>
              <Save className="w-4 h-4 ml-1.5" />
              שמור
            </Button>
          </div>
        </div>
      )}

      {/* Separate Filtering Toggle */}
      <div className="mb-4 border rounded-lg p-4 bg-blue-50/10">
        <div className="flex items-center justify-between">
          <div className="space-y-1">
            <div className="font-medium">סינון וחיפוש נפרד לפי מגדר</div>
            <p className="text-sm text-gray-500">
              סנן מועמדים ומועמדות עם קריטריונים שונים
            </p>
          </div>
          <div className="flex items-center gap-2">
            <Switch
              checked={separateFiltering}
              onCheckedChange={onToggleSeparateFiltering}
            />
            {separateFiltering && (
              <Button
                variant="outline"
                size="sm"
                onClick={onToggleSeparateFiltering}
                className="text-sm"
              >
                <RefreshCw className="w-3.5 h-3.5 mr-1.5" />
                בטל סינון נפרד
              </Button>
            )}
          </div>
        </div>
      </div>

      {/* Separate Filtering UI */}
      {separateFiltering ? (
        <div className="space-y-4">
          {/* Gender Filter Switcher */}
          <div className="flex border rounded-lg overflow-hidden mb-2">
            <Button
              type="button"
              variant={activeGenderFilter === "male" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("male")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "male" ? "bg-blue-600" : ""
              }`}
            >
              סינון מועמדים
              <User className="w-4 h-4 mr-2" />
            </Button>
            <Button
              type="button"
              variant={activeGenderFilter === "female" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("female")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "female" ? "bg-purple-600" : ""
              }`}
            >
              סינון מועמדות
              <User className="w-4 h-4 mr-2" />
            </Button>
          </div>

          {/* Conditionally render based on active gender filter */}
          {activeGenderFilter === "male" ? (
            <GenderFilterPanel
              gender="male"
              filters={filters.maleFilters || {}}
              onFiltersChange={onMaleFiltersChange || (() => {})}
              copyTarget="female"
              onCopyFilters={onCopyFilters}
            />
          ) : (
            <GenderFilterPanel
              gender="female"
              filters={filters.femaleFilters || {}}
              onFiltersChange={onFemaleFiltersChange || (() => {})}
              copyTarget="male"
              onCopyFilters={onCopyFilters}
            />
          )}
        </div>
      ) : (
        // Standard Filtering Tabs
        <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
          <TabsList
            className={`grid grid-cols-4 w-full bg-muted/30 p-1 rounded-xl shadow-sm ${
              compactMode ? "text-xs" : ""
            }`}
          >
            <TabsTrigger
              value="basic"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                בסיסי
                {countActiveFilters("basic") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("basic")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="advanced"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                מתקדם
                {countActiveFilters("advanced") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("advanced")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="status"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                סטטוס
                {countActiveFilters("status") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("status")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="saved"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                שמורים
                {countActiveFilters("saved") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("saved")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
          </TabsList>

          <div className={compactMode ? "mt-2" : "mt-4"}>
            {/* Basic Filters Tab */}
            <TabsContent value="basic" className="space-y-4">
              {/* Gender Filter */}
              <FilterSection
                title="מגדר"
                icon={<User className="w-4 h-4" />}
                defaultOpen={true}
              >
                <div className="grid grid-cols-2 gap-2 pt-2">
                  <Button
                    type="button"
                    variant={filters.gender === "MALE" ? "default" : "outline"}
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "MALE" })
                    }
                    className={
                      filters.gender === "MALE" ? "bg-blue-600" : "bg-white"
                    }
                  >
                    גברים
                  </Button>
                  <Button
                    type="button"
                    variant={
                      filters.gender === "FEMALE" ? "default" : "outline"
                    }
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "FEMALE" })
                    }
                    className={
                      filters.gender === "FEMALE" ? "bg-purple-600" : "bg-white"
                    }
                  >
                    נשים
                  </Button>
                </div>
                {filters.gender && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: undefined })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                )}
              </FilterSection>
              {/* Age Range - משופר ומתוקן */}
              <FilterSection
                title="גיל"
                icon={<Calendar className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  filters.ageRange &&
                  (filters.ageRange.min !== AGE_RANGE.default.min ||
                    filters.ageRange.max !== AGE_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.max || AGE_RANGE.default.max}
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= AGE_RANGE.min &&
                            newMax <= AGE_RANGE.max
                          ) {
                            const currentMin =
                              filters.ageRange?.min || AGE_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.min || AGE_RANGE.default.min}
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= AGE_RANGE.min &&
                            newMin <= AGE_RANGE.max
                          ) {
                            const currentMax =
                              filters.ageRange?.max || AGE_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          AGE_RANGE.default.min,
                          AGE_RANGE.default.max,
                        ]}
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        step={1}
                        value={[
                          filters.ageRange?.min || AGE_RANGE.default.min,
                          filters.ageRange?.max || AGE_RANGE.default.max,
                        ]}
                        onValueChange={handleAgeRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.max}
                      </span>
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.min}
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Cities Filter */}
              <FilterSection
                title="ערים"
                icon={<MapPin className="w-4 h-4" />}
                badge={filters.cities?.length}
              >
                <ScrollArea className="h-48 mt-2 rounded-md border overflow-hidden bg-white pr-4">
                  <div className="p-2">
                    {POPULAR_CITIES.map((city) => (
                      <div
                        key={city}
                        className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                      >
                        <span className="text-sm">{city}</span>
                        <Switch
                          checked={filters.cities?.includes(city) || false}
                          onCheckedChange={(checked) => {
                            const newCities = checked
                              ? [...(filters.cities || []), city]
                              : filters.cities?.filter((c) => c !== city);
                            onFiltersChange({ ...filters, cities: newCities });
                          }}
                        />
                      </div>
                    ))}
                  </div>
                </ScrollArea>
                {filters.cities?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => onFiltersChange({ ...filters, cities: [] })}
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Religious Level */}
              <FilterSection
                title="רמת דתיות"
                icon={<Scroll className="w-4 h-4" />}
                badge={filters.religiousLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.religiousLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        religiousLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="בחר רמת דתיות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {RELIGIOUS_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Advanced Filters Tab */}
            <TabsContent value="advanced" className="space-y-4">
              {/* Height Range - משופר ומתוקן */}
              <FilterSection
                title="גובה (ס״מ)"
                icon={<Ruler className="w-4 h-4" />}
                badge={
                  filters.heightRange &&
                  (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
                    filters.heightRange.max !== HEIGHT_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.max || HEIGHT_RANGE.default.max
                        }
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= HEIGHT_RANGE.min &&
                            newMax <= HEIGHT_RANGE.max
                          ) {
                            const currentMin =
                              filters.heightRange?.min ||
                              HEIGHT_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.min || HEIGHT_RANGE.default.min
                        }
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= HEIGHT_RANGE.min &&
                            newMin <= HEIGHT_RANGE.max
                          ) {
                            const currentMax =
                              filters.heightRange?.max ||
                              HEIGHT_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          HEIGHT_RANGE.default.min,
                          HEIGHT_RANGE.default.max,
                        ]}
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        step={1}
                        value={[
                          filters.heightRange?.min || HEIGHT_RANGE.default.min,
                          filters.heightRange?.max || HEIGHT_RANGE.default.max,
                        ]}
                        onValueChange={handleHeightRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.min} ס״מ
                      </span>
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.max} ס״מ
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Occupation */}
              <FilterSection
                title="תחום עיסוק"
                icon={<Briefcase className="w-4 h-4" />}
                badge={filters.occupations?.length}
              >
                <ScrollArea className="h-48 rounded-md mt-2 border p-2 bg-white pr-4">
                  {OCCUPATION_CATEGORIES.map((occupation) => (
                    <div
                      key={occupation.value}
                      className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                    >
                      <span className="text-sm">{occupation.label}</span>
                      <Switch
                        checked={
                          filters.occupations?.includes(occupation.value) ||
                          false
                        }
                        onCheckedChange={(checked) => {
                          const newOccupations = checked
                            ? [...(filters.occupations || []), occupation.value]
                            : filters.occupations?.filter(
                                (o) => o !== occupation.value
                              );
                          onFiltersChange({
                            ...filters,
                            occupations: newOccupations,
                          });
                        }}
                      />
                    </div>
                  ))}
                </ScrollArea>
                {filters.occupations?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, occupations: [] })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Education Level */}
              <FilterSection
                title="השכלה"
                icon={<GraduationCap className="w-4 h-4" />}
                badge={filters.educationLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.educationLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        educationLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="רמת השכלה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {EDUCATION_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>

              {/* Marital Status */}
              <FilterSection
                title="מצב משפחתי"
                icon={<Heart className="w-4 h-4" />}
                badge={filters.maritalStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.maritalStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        maritalStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="מצב משפחתי" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {MARITAL_STATUS.map((status) => (
                        <SelectItem key={status.value} value={status.value}>
                          {status.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Status & Availability Filters Tab */}
            <TabsContent value="status" className="space-y-4">
              {/* Availability Status */}
              <FilterSection
                title="סטטוס זמינות"
                icon={<Clock className="w-4 h-4" />}
                defaultOpen={true}
                badge={filters.availabilityStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.availabilityStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        availabilityStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="סטטוס זמינות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {AVAILABILITY_STATUS_OPTIONS.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          <div className="flex items-center gap-2">
                            <div
                              className={`w-2 h-2 rounded-full ${
                                option.value === "AVAILABLE"
                                  ? "bg-emerald-500"
                                  : option.value === "DATING"
                                  ? "bg-amber-500"
                                  : "bg-red-500"
                              }`}
                            />
                            {option.label}
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {filters.availabilityStatus && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          availabilityStatus: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>

              {/* Verification Switches */}
              <FilterSection
                title="אימות ואיכות פרופיל"
                icon={<Check className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  (filters.isVerified !== undefined ? 1 : 0) +
                  (filters.hasReferences !== undefined ? 1 : 0) +
                  (filters.isProfileComplete !== undefined ? 1 : 0)
                }
              >
                <div className="space-y-3 pt-2">
                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">מועמדים מאומתים בלבד</span>
                    <Switch
                      checked={filters.isVerified || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isVerified: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">עם המלצות בלבד</span>
                    <Switch
                      checked={filters.hasReferences || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          hasReferences: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">פרופילים מלאים בלבד</span>
                    <Switch
                      checked={filters.isProfileComplete || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isProfileComplete: checked || undefined,
                        })
                      }
                    />
                  </div>
                </div>
              </FilterSection>

              {/* Activity Filter */}
              <FilterSection
                title="פעילות אחרונה"
                icon={<Clock className="w-4 h-4" />}
                badge={filters.lastActiveDays ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.lastActiveDays?.toString() || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        lastActiveDays: value ? parseInt(value) : undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="פעילות אחרונה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="1">היום</SelectItem>
                      <SelectItem value="3">3 ימים אחרונים</SelectItem>
                      <SelectItem value="7">שבוע אחרון</SelectItem>
                      <SelectItem value="30">חודש אחרון</SelectItem>
                    </SelectContent>
                  </Select>
                  {filters.lastActiveDays && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          lastActiveDays: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>
            </TabsContent>

            {/* Saved Filters Tab */}
            <TabsContent value="saved" className="space-y-4">
              {savedFilters.length === 0 ? (
                <div className="text-center py-8 text-gray-500 bg-white rounded-lg border p-4">
                  <Bookmark className="w-8 h-8 mx-auto mb-2 text-gray-400" />
                  <h3 className="mb-1 font-medium">אין פילטרים שמורים</h3>
                  <p className="text-sm">
                    שמור את הפילטר הנוכחי ע״י לחיצה על כפתור השמירה
                  </p>
                </div>
              ) : (
                <SavedFilters
                  filters={savedFilters.map((filter) => ({
                    id: filter.id,
                    name: filter.name,
                    filter: {},
                    isDefault: filter.isDefault,
                    createdAt: new Date(),
                  }))}
                  activeFilterId={filters.savedFilterId}
                  onSelect={(filter) => onApplySavedFilter?.(filter.id)}
                  onDelete={() => {}}
                  onEdit={() => {}}
                  onSetDefault={() => {}}
                />
              )}

              {popularFilters.length > 0 && (
                <div className="mt-4">
                  <h4 className="font-medium text-sm mb-2">
                    חיפושים פופולריים
                  </h4>
                  <div className="flex flex-wrap gap-2">
                    {popularFilters.map((term, index) => (
                      <Badge
                        key={index}
                        variant="outline"
                        className="cursor-pointer bg-blue-50 border-blue-200 hover:bg-blue-100 transition-colors"
                        onClick={() =>
                          onFiltersChange({
                            ...filters,
                            searchQuery: term,
                          })
                        }
                      >
                        {term}
                      </Badge>
                    ))}
                  </div>
                </div>
              )}
            </TabsContent>
          </div>
        </Tabs>
      )}

      {/* Action buttons */}
      <div
        className={`${
          compactMode ? "pt-2 mt-2" : "pt-4 mt-4"
        } border-t flex justify-end gap-2`}
      >
        <Button
          variant="outline"
          size={compactMode ? "sm" : "default"}
          onClick={onReset}
          className="bg-white"
        >
          איפוס
        </Button>
        {!compactMode && (
          <Button onClick={() => setShowSavePreset(true)} size="sm">
            <Save className="w-4 h-4 ml-1.5" />
            שמירת פילטר
          </Button>
        )}
      </div>
    </Card>
  );
};

export default FilterPanel;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\SavedFilters.tsx:
==================================================
// /components/matchmaker/Filters/SavedFilters.tsx
"use client";
import React from "react";
import { Star, MoreVertical, Edit, Trash } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import type { CandidatesFilter } from "../types/candidates";

interface SavedFilter {
  id: string;
  name: string;
  filter: CandidatesFilter;
  isDefault?: boolean;
  createdAt: Date;
}

interface SavedFiltersProps {
  filters: SavedFilter[];
  activeFilterId?: string;
  onSelect: (filter: SavedFilter) => void;
  onDelete: (filterId: string) => void;
  onEdit: (filter: SavedFilter) => void;
  onSetDefault: (filterId: string) => void;
  className?: string;
}

const SavedFilters: React.FC<SavedFiltersProps> = ({
  filters,
  activeFilterId,
  onSelect,
  onDelete,
  onEdit,
  onSetDefault,
  className,
}) => {
  return (
    <div className={`space-y-2 ${className}`}>
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-gray-700">פילטרים שמורים</h3>
        <Badge variant="secondary" className="text-xs">
          {filters.length}
        </Badge>
      </div>

      <ScrollArea className="h-[300px]">
        <div className="space-y-2">
          {filters.map((filter) => (
            <div
              key={filter.id}
              className={`
                flex items-center justify-between p-2 rounded-lg
                ${
                  activeFilterId === filter.id
                    ? "bg-blue-50 border border-blue-200"
                    : "bg-white hover:bg-gray-50"
                }
                transition-colors cursor-pointer
              `}
              onClick={() => onSelect(filter)}
            >
              <div className="flex items-center gap-2">
                {filter.isDefault && (
                  <Star className="w-4 h-4 text-yellow-400" />
                )}
                <div>
                  <p className="font-medium text-sm">{filter.name}</p>
                  <p className="text-xs text-gray-500">
                    {formatFilterSummary(filter.filter)}
                  </p>
                </div>
              </div>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8 w-8 p-0"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <MoreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onEdit(filter)}>
                    <Edit className="ml-2 h-4 w-4" />
                    עריכה
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => onSetDefault(filter.id)}
                    disabled={filter.isDefault}
                  >
                    <Star className="ml-2 h-4 w-4" />
                    הגדר כברירת מחדל
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onDelete(filter.id)}>
                    <Trash className="ml-2 h-4 w-4" />
                    מחיקה
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
};

// פונקציית עזר להצגת סיכום הפילטר
const formatFilterSummary = (filter: CandidatesFilter): string => {
  const parts: string[] = [];

  if (filter.ageRange) {
    parts.push(`גיל: ${filter.ageRange.min}-${filter.ageRange.max}`);
  }

  if (filter.cities?.length) {
    parts.push(`ערים: ${filter.cities.length}`);
  }

  if (filter.religiousLevel) {
    parts.push(`רמה דתית: ${filter.religiousLevel}`);
  }

  if (filter.occupations?.length) {
    parts.push(`תחומי עיסוק: ${filter.occupations.length}`);
  }

  return parts.join(" | ") || "פילטר ריק";
};

export default SavedFilters;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\Filters\SearchBar.tsx:
==================================================
// /Filters/SearchBar.tsx - גרסה עם לוגים לדיבאג
"use client";

import React, { useState, useEffect, useRef } from "react";
import { Search, X, History } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSelect?: (candidate: Candidate) => void;
  recentSearches?: string[];
  onSaveSearch?: (value: string) => void;
  onClearRecentSearches?: () => void;
  suggestions?: Candidate[];
  loading?: boolean;
  className?: string;
  placeholder?: string;
  autoFocus?: boolean;
  // הוספת שדה לציון לאיזה מגדר החיפוש מכוון
  genderTarget?: "male" | "female" | "all";
  // הוספת שדה לציון האם החיפוש מופעל במצב נפרד
  separateMode?: boolean;
}

const SEARCH_CATEGORIES = [
  { id: "name", label: "שם", placeholder: "חיפוש לפי שם..." },
  { id: "city", label: "עיר", placeholder: "חיפוש לפי עיר..." },
  {
    id: "occupation",
    label: "תחום עיסוק",
    placeholder: "חיפוש לפי תחום עיסוק...",
  },
  { id: "all", label: "הכל", placeholder: "חיפוש בכל השדות..." },
];

const SearchBar: React.FC<SearchBarProps> = ({
  value,
  onChange,
  onSelect,
  recentSearches = [],
  onSaveSearch,
  onClearRecentSearches,
  suggestions = [],
  loading = false,
  className = "",
  placeholder = "חיפוש מועמדים...",
  autoFocus = false,
  genderTarget = "all",
  separateMode = false,
}) => {
  const [open, setOpen] = useState(false);
  const [searchCategory, setSearchCategory] = useState<string>("all");
  const [inputValue, setInputValue] = useState(value);
  const [showClearButton, setShowClearButton] = useState(Boolean(value));
  const inputRef = useRef<HTMLInputElement>(null);
  const searchContainerRef = useRef<HTMLDivElement>(null);

  // לוג מצב התחלתי
  console.log("SearchBar mounted/updated. Props:", {
    initialValue: value,
    suggestionsCount: suggestions.length,
    recentSearchesCount: recentSearches.length,
  });

  // Sync input value with prop value
  useEffect(() => {
    console.log("Value prop changed:", value);
    setInputValue(value);
    setShowClearButton(Boolean(value));
  }, [value]);

  // Handle search when user presses Enter or selects a suggestion
  const handleSearch = (searchValue: string) => {
    console.log(
      `handleSearch called with: ${searchValue}, gender: ${genderTarget}, separate: ${separateMode}`
    );

    if (searchValue.trim()) {
      onChange(searchValue.trim());

      if (onSaveSearch) {
        // שמירת החיפוש בהיסטוריה
        // אפשר גם לשמור את המגדר אם יש צורך
        onSaveSearch(searchValue.trim());
      }
    }
  };
  // כשמשתמשים בחיפוש נפרד, נעדכן את הפלייסהולדר בהתאם
  const getSearchPlaceholder = () => {
    if (separateMode) {
      // מצא את ה-placeholder של הקטגוריה "all" או השתמש בברירת מחדל
      const allCategoryPlaceholder =
        SEARCH_CATEGORIES.find((cat) => cat.id === "all")?.placeholder ||
        "חיפוש בכל השדות...";

      if (genderTarget === "male") {
        return `חיפוש מועמדים - ${allCategoryPlaceholder}`;
      }
      if (genderTarget === "female") {
        return `חיפוש מועמדות - ${allCategoryPlaceholder}`;
      }
    }

    // אם לא במצב סינון נפרד, השתמש בקטגוריה הנוכחית שנבחרה
    const category = SEARCH_CATEGORIES.find((cat) => cat.id === searchCategory);
    return category?.placeholder || placeholder;
  };
  // Handle input change
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    console.log("handleInputChange:", { oldValue: inputValue, newValue });

    setInputValue(newValue);
    setShowClearButton(Boolean(newValue));

    // CRITICAL: הפעלת onChange בכל הקלדה כדי שהחיפוש יקרה בזמן אמת
    console.log(
      "Calling onChange directly from handleInputChange with:",
      newValue
    );
    onChange(newValue);
  };

  // Handle keyboard events
  const handleKeyDown = (e: React.KeyboardEvent) => {
    console.log("handleKeyDown:", e.key);

    if (e.key === "Enter" && inputValue.trim()) {
      console.log("Enter pressed with value:", inputValue);
      handleSearch(inputValue);
      setOpen(false);
    } else if (e.key === "Escape") {
      console.log("Escape pressed, closing dropdown");
      setOpen(false);
    }
  };

  // Clear search input
  const handleClear = () => {
    console.log("handleClear called");
    setInputValue("");
    console.log("Calling onChange with empty string from handleClear");
    onChange("");
    setShowClearButton(false);
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        searchContainerRef.current &&
        !searchContainerRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  // Handle suggestion selection
  const handleSuggestionSelect = (candidate: Candidate) => {
    console.log(
      "handleSuggestionSelect called with candidate:",
      `${candidate.firstName} ${candidate.lastName}`
    );

    if (onSelect) {
      console.log("Calling onSelect for the candidate");
      onSelect(candidate);
    } else {
      // אם אין פונקציית בחירה, התייחס לכך כחיפוש טקסט
      const searchText = `${candidate.firstName} ${candidate.lastName}`;
      console.log("No onSelect provided, using as text search:", searchText);
      setInputValue(searchText);
      console.log("Calling onChange with:", searchText);
      onChange(searchText);
    }
    setOpen(false);
  };

   return (
    <div className={`relative ${className}`} ref={searchContainerRef}>
      {/* Search Input Field */}
      <div className="relative flex items-center rounded-lg border border-input bg-background shadow-sm transition-colors focus-within:ring-1 focus-within:ring-blue-200">
        <Search className="absolute right-3 h-4 w-4 text-muted-foreground" />

        {/* הכנסת שדה הקלט */}
        <Input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onClick={() => {
            console.log("Search input clicked, opening dropdown");
            setOpen(true);
          }}
          placeholder={getSearchPlaceholder()}
          className={`border-0 pr-10 focus-visible:ring-0 focus-visible:ring-offset-0 ${
            separateMode ? "pl-16" : ""
          }`}
          autoFocus={autoFocus}
        />

        {/* תווית המגדר כתווית קבועה שלא חופפת את יתר האלמנטים */}
        {separateMode && (
          <div className="absolute left-4 top-1/2 -translate-y-1/2 z-10">
            <Badge
              variant="outline"
              className={
                genderTarget === "male"
                  ? "bg-blue-100 text-blue-800 border-blue-200"
                  : genderTarget === "female"
                  ? "bg-purple-100 text-purple-800 border-purple-200"
                  : ""
              }
            >
              {genderTarget === "male"
                ? "מועמדים"
                : genderTarget === "female"
                ? "מועמדות"
                : "הכל"}
            </Badge>
          </div>
        )}

        {/* כפתור ניקוי עם מיקום משופר */}
        {showClearButton && (
          <Button
            type="button"
            variant="ghost"
            size="icon"
            onClick={handleClear}
            className={`absolute ${
              separateMode ? "left-16" : "left-3 md:left-40"
            } top-1/2 -translate-y-1/2 h-7 w-7 z-10`}
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>

      {/* Suggestions Dropdown - Custom Styled */}
      {open && (
        <div
          className="absolute z-50 mt-1 w-full rounded-md border bg-white shadow-lg"
          style={{ maxHeight: "400px", overflowY: "auto" }}
        >
          {/* Search Input for Filtering */}
          <div className="p-2 border-b">
            <div className="relative">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-muted-foreground opacity-70" />
              <input
                type="text"
                value={inputValue}
                onChange={(e) => {
                  const newValue = e.target.value;
                  console.log("Dropdown filter input changed:", {
                    oldValue: inputValue,
                    newValue,
                  });
                  setInputValue(newValue);

                  // CRITICAL: וודא שהערך מועבר להורה בזמן הקלדה
                  console.log(
                    "Calling onChange from dropdown filter with:",
                    newValue
                  );
                  onChange(newValue);
                }}
                className="w-full border rounded-md px-3 pr-9 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-blue-300"
                placeholder="סנן תוצאות..."
                autoFocus
              />
            </div>
          </div>

          {/* No Results */}
          {suggestions.length === 0 && recentSearches.length === 0 && (
            <div className="p-4 text-center text-sm text-gray-500">
              {loading ? "טוען..." : "לא נמצאו תוצאות"}
            </div>
          )}

          {/* Recent Searches Section */}
          {recentSearches.length > 0 && (
            <div className="border-b">
              <div className="px-2 py-1.5 text-xs text-gray-500 flex justify-between">
                <span className="font-medium">חיפושים אחרונים</span>
                {onClearRecentSearches && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-5 text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      console.log("Clear recent searches clicked");
                      onClearRecentSearches();
                    }}
                  >
                    נקה היסטוריה
                  </Button>
                )}
              </div>
              <div className="p-1">
                {recentSearches.slice(0, 5).map((search, index) => (
                  <div
                    key={`recent-${index}`}
                    className="flex items-center gap-2 text-right px-3 py-1.5 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log("Recent search clicked:", search);
                      handleSearch(search);
                      setOpen(false);
                    }}
                  >
                    <History className="h-4 w-4 text-blue-400" />
                    <span className="text-sm">{search}</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Suggestions Section */}
          {suggestions.length > 0 && (
            <div>
              <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
                תוצאות
              </div>
              <div className="p-1">
                {suggestions.map((candidate) => (
                  <div
                    key={candidate.id}
                    className="flex items-center gap-2 text-right px-3 py-2 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log(
                        "Suggestion clicked:",
                        `${candidate.firstName} ${candidate.lastName}`
                      );
                      handleSuggestionSelect(candidate);
                    }}
                  >
                    <div className="flex-1">
                      <div className="font-medium text-sm">
                        {`${candidate.firstName} ${candidate.lastName}`}
                      </div>
                      <div className="text-xs text-gray-500 truncate">
                        {[
                          candidate.profile.city,
                          candidate.profile.occupation,
                          candidate.profile.religiousLevel,
                        ]
                          .filter(Boolean)
                          .join(" | ")}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}



          {/* Search Categories on Mobile */}
          <div className="md:hidden border-t">
            <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
              חפש לפי
            </div>
            <div className="flex flex-wrap gap-1 p-2">
              {SEARCH_CATEGORIES.map((category) => (
                <Badge
                  key={category.id}
                  variant={
                    searchCategory === category.id ? "default" : "outline"
                  }
                  className={`cursor-pointer ${
                    searchCategory === category.id
                      ? "bg-blue-500 text-white"
                      : "bg-transparent hover:bg-blue-50"
                  }`}
                  onClick={() => {
                    console.log("Mobile category changed to:", category.id);
                    setSearchCategory(category.id);
                  }}
                >
                  {category.label}
                </Badge>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SearchBar;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\filterUtils:
==================================================


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useCandidates.ts:
==================================================
import { useState, useEffect, useMemo, useCallback } from 'react';
import Papa from 'papaparse';
import type { Candidate, CandidatesFilter } from '../types/candidates';
import type { CandidateProfile } from '../types/candidates';
import { Dispatch, SetStateAction } from 'react';

export interface UseCandidatesReturn {
  loading: boolean;
  error: string | null;
  candidates: Candidate[];
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  filteredCandidates: Candidate[];
  filters: CandidatesFilter;
  setFilters: Dispatch<SetStateAction<CandidatesFilter>>;
  refresh: () => Promise<void>;
  totalCount: number;
  filteredCount: number;
  maleCount: number;
  femaleCount: number;
  searchResults: {
    term: string;
    count: number;
    male: number;
    female: number;
  } | null;
  exportCandidates: (candidates: Candidate[], filters: CandidatesFilter) => Promise<void>;
  updateCandidate: (id: string, updates: Partial<CandidateProfile>) => Promise<void>;
  sorting: {
    field: string;
    direction: 'asc' | 'desc';
  };
  setSorting: (field: string, direction: 'asc' | 'desc') => void;
  searchSuggestions: (term: string) => Promise<Candidate[]>;
}

export const useCandidates = (initialFilters: CandidatesFilter = {}): UseCandidatesReturn => {
  // Base states
  const [candidates, setCandidates] = useState<Candidate[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<CandidatesFilter>(initialFilters);
  const [searchResults, setSearchResults] = useState<{
    term: string;
    count: number;
    male: number;
    female: number;
  } | null>(null);
  const [sorting, setSortingState] = useState<{
    field: string;
    direction: 'asc' | 'desc';
  }>({
    field: 'lastActive',
    direction: 'desc',
  });

  // Helper function to calculate age
  const calculateAge = useCallback((birthDate: Date): number => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    return age;
  }, []);

  // Fetch candidates data
  const fetchCandidates = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/matchmaker/clients');
      if (!response.ok) {
        throw new Error(await response.text());
      }
      
      const data = await response.json();
     
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load candidates');
      }
  
      setCandidates(data.clients);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
      console.error('Error fetching candidates:', err);
    } finally {
      setLoading(false);
    }
  };

  // Set sorting field and direction
  const setSorting = useCallback((field: string, direction: 'asc' | 'desc') => {
    setSortingState({ field, direction });
  }, []);

  // Search suggestions based on a term
  const searchSuggestions = useCallback(async (term: string): Promise<Candidate[]> => {
    if (!term || term.length < 2) return [];
    
    // Local search implementation for quick response
    const searchTerm = term.toLowerCase();
    return candidates.filter(candidate => {
      const searchableText = `
        ${candidate.firstName} 
        ${candidate.lastName} 
        ${candidate.profile.occupation || ''} 
        ${candidate.profile.city || ''}
        ${candidate.profile.religiousLevel || ''}
      `.toLowerCase();
      
      return searchableText.includes(searchTerm);
    }).slice(0, 10);
    
    // Alternatively, you can implement an API call for server-side search
    // if the dataset is very large
  }, [candidates]);

  const sortCandidates = useCallback((candidatesList: Candidate[], field: string, direction: 'asc' | 'desc') => {
    return [...candidatesList].sort((a, b) => {
      let valueA, valueB;
      
      switch (field) {
        case 'name':
          valueA = `${a.firstName} ${a.lastName}`.toLowerCase();
          valueB = `${b.firstName} ${b.lastName}`.toLowerCase();
          break;
        case 'age':
          valueA = calculateAge(a.profile.birthDate);
          valueB = calculateAge(b.profile.birthDate);
          break;
        case 'city':
          valueA = (a.profile.city || '').toLowerCase();
          valueB = (b.profile.city || '').toLowerCase();
          break;
        case 'religiousLevel':
          valueA = (a.profile.religiousLevel || '').toLowerCase();
          valueB = (b.profile.religiousLevel || '').toLowerCase();
          break;
        case 'lastActive':
          valueA = a.profile.lastActive ? new Date(a.profile.lastActive).getTime() : 0;
          valueB = b.profile.lastActive ? new Date(b.profile.lastActive).getTime() : 0;
          break;
        case 'registrationDate':
          valueA = new Date(a.createdAt).getTime();
          valueB = new Date(b.createdAt).getTime();
          break;
        case 'height':
          valueA = a.profile.height || 0;
          valueB = b.profile.height || 0;
          break;
        default:
          valueA = 0;
          valueB = 0;
      }
      
      if (valueA < valueB) return direction === 'asc' ? -1 : 1;
      if (valueA > valueB) return direction === 'asc' ? 1 : -1;
      return 0;
    });
  }, [calculateAge]);
  
  // פונקציה לבדיקה אם מועמד עומד בקריטריוני חיפוש
  const checkSearchMatch = useCallback((candidate: Candidate, searchTerm: string): boolean => {
    if (!searchTerm) return true;
    
    // נרמול החיפוש
    const normalizedTerm = searchTerm.toLowerCase().trim();
    if (!normalizedTerm) return true;
    
    // בדיקת התאמה בשדות השונים
    const fullName = `${candidate.firstName} ${candidate.lastName}`.toLowerCase();
    const city = (candidate.profile.city || '').toLowerCase();
    const occupation = (candidate.profile.occupation || '').toLowerCase();
    const religiousLevel = (candidate.profile.religiousLevel || '').toLowerCase();
    
    return (
      fullName.includes(normalizedTerm) || 
      city.includes(normalizedTerm) || 
      occupation.includes(normalizedTerm) || 
      religiousLevel.includes(normalizedTerm)
    );
  }, []);

  // בקובץ useCandidates.ts - לעדכן את החלק של filteredCandidates
  const filteredCandidates = useMemo(() => {
    console.log("Filtering candidates with filters:", filters);
    
    // אם הסינון הנפרד מופעל, נשתמש בפילטרים הכלליים בלבד ללא מגדר
    const currentFilters = filters.separateFiltering 
      ? { ...filters, gender: undefined }
      : filters;

    let results = candidates.filter(candidate => {
      // סינון לפי מגדר רק אם הסינון הנפרד כבוי
      if (!filters.separateFiltering && currentFilters.gender && candidate.profile.gender !== currentFilters.gender) {
        return false;
      }
      
      // בדיקת גיל מותאמת
      if (currentFilters.ageRange) {
        try {
          const age = calculateAge(candidate.profile.birthDate);
          if (age < currentFilters.ageRange.min || age > currentFilters.ageRange.max) {
            return false;
          }
        } catch (err) {
          console.error("Error calculating age for candidate:", candidate.id, err);
        }
      }
      
      // סינון סטטוס משתמש
      if (filters.userStatus && candidate.status !== filters.userStatus) {
        return false;
      }

      // סינון סטטוס זמינות - ודא המרה נכונה של הטיפוס
      if (filters.availabilityStatus && 
          candidate.profile.availabilityStatus !== filters.availabilityStatus) {
        return false;
      }
      
      // בדיקת גובה
      if (filters.heightRange && candidate.profile.height) {
        if (
          candidate.profile.height < filters.heightRange.min || 
          candidate.profile.height > filters.heightRange.max
        ) {
          return false;
        }
      }

      // בדיקת רמת דתיות
      if (filters.religiousLevel && candidate.profile.religiousLevel !== filters.religiousLevel) {
        return false;
      }

      // בדיקת ערים
      if (filters.cities?.length && candidate.profile.city) {
        if (!filters.cities.includes(candidate.profile.city)) {
          return false;
        }
      }

      // בדיקת תחומי עיסוק
      if (filters.occupations?.length && candidate.profile.occupation) {
        if (!filters.occupations.includes(candidate.profile.occupation)) {
          return false;
        }
      }

      // בדיקת השכלה
      if (filters.educationLevel && candidate.profile.education !== filters.educationLevel) {
        return false;
      }

      // בדיקת מצב משפחתי
      if (filters.maritalStatus && candidate.profile.maritalStatus !== filters.maritalStatus) {
        return false;
      }

      // בדיקת אימות
      if (filters.isVerified !== undefined && candidate.isVerified !== filters.isVerified) {
        return false;
      }

      // בדיקת המלצות
      if (filters.hasReferences && 
          !candidate.profile.referenceName1 && 
          !candidate.profile.referenceName2) {
        return false;
      }

      // בדיקת פעילות אחרונה
      if (filters.lastActiveDays && candidate.profile.lastActive) {
        const lastActive = new Date(candidate.profile.lastActive);
        const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
        if (daysDiff > filters.lastActiveDays) {
          return false;
        }
      }

      // בדיקת שלמות פרופיל
      if (filters.isProfileComplete !== undefined && 
          candidate.isProfileComplete !== filters.isProfileComplete) {
        return false;
      }

      // בדיקת חיפוש כללי - רק אם אין סינון נפרד
      if (!filters.separateFiltering && currentFilters.searchQuery) {
        return checkSearchMatch(candidate, currentFilters.searchQuery);
      }

      return true;
    });

    // מיון התוצאות
    if (sorting.field && sorting.direction) {
      results = sortCandidates(results, sorting.field, sorting.direction);
    }

    return results;
  }, [candidates, filters, calculateAge, sorting.field, sorting.direction, sortCandidates, checkSearchMatch]);

  // חלוקה למועמדים ומועמדות עם תמיכה בחיפוש נפרד
  const maleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לגברים
    if (filters.separateFiltering) {
      return filteredCandidates
        .filter(c => c.profile.gender === 'MALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לגברים
          if (filters.maleFilters) {
            // בדיקת גיל
            if (filters.maleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.maleFilters.ageRange.min || age > filters.maleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.maleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.maleFilters.heightRange.min || 
                candidate.profile.height > filters.maleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.maleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.maleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.maleFilters.cities?.length && candidate.profile.city) {
              if (!filters.maleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.maleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.maleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.maleFilters.educationLevel && candidate.profile.education !== filters.maleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.maleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.maleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.maleFilters.isVerified !== undefined && candidate.isVerified !== filters.maleFilters.isVerified) {
              return false;
            }

            // בדיקת המלצות
            if (filters.maleFilters.hasReferences && 
                !candidate.profile.referenceName1 && 
                !candidate.profile.referenceName2) {
              return false;
            }

            // בדיקת פעילות אחרונה
            if (filters.maleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.maleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.maleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.maleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הגברים
            if (filters.maleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.maleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לגברים
          if (filters.maleSearchQuery) {
            return checkSearchMatch(candidate, filters.maleSearchQuery);
          }
          
          return true;
        });
    }
    
    // ללא סינון נפרד, נחזיר את כל הגברים מהרשימה המסוננת
    return filteredCandidates.filter(c => c.profile.gender === 'MALE');
  }, [filteredCandidates, filters.separateFiltering, filters.maleFilters, filters.maleSearchQuery, calculateAge, checkSearchMatch]);

  const femaleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לנשים
    if (filters.separateFiltering) {
      return filteredCandidates
        .filter(c => c.profile.gender === 'FEMALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לנשים
          if (filters.femaleFilters) {
            // בדיקת גיל
            if (filters.femaleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.femaleFilters.ageRange.min || age > filters.femaleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.femaleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.femaleFilters.heightRange.min || 
                candidate.profile.height > filters.femaleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.femaleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.femaleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.femaleFilters.cities?.length && candidate.profile.city) {
              if (!filters.femaleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.femaleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.femaleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.femaleFilters.educationLevel && candidate.profile.education !== filters.femaleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.femaleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.femaleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.femaleFilters.isVerified !== undefined && candidate.isVerified !== filters.femaleFilters.isVerified) {
              return false;
            }

            // בדיקת המלצות
            if (filters.femaleFilters.hasReferences && 
                !candidate.profile.referenceName1 && 
                !candidate.profile.referenceName2) {
              return false;
            }

            // בדיקת פעילות אחרונה
            if (filters.femaleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.femaleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.femaleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.femaleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הנשים
            if (filters.femaleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.femaleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לנשים
          if (filters.femaleSearchQuery) {
            return checkSearchMatch(candidate, filters.femaleSearchQuery);
          }
          
          return true;
        });
    }
    
    // ללא סינון נפרד, נחזיר את כל הנשים מהרשימה המסוננת
    return filteredCandidates.filter(c => c.profile.gender === 'FEMALE');
  }, [filteredCandidates, filters.separateFiltering, filters.femaleFilters, filters.femaleSearchQuery, calculateAge, checkSearchMatch]);

  // עדכון תוצאות החיפוש
  useEffect(() => {
    if (!filters.separateFiltering && filters.searchQuery) {
      // מצב חיפוש רגיל
      setSearchResults({
        term: filters.searchQuery,
        count: filteredCandidates.length,
        male: maleCandidates.length,
        female: femaleCandidates.length
      });
    } else if (filters.separateFiltering) {
      // במצב חיפוש נפרד, לא מציגים תוצאות חיפוש מאוחדות
      setSearchResults(null);
    } else {
      setSearchResults(null);
    }
  }, [filteredCandidates, maleCandidates, femaleCandidates, filters.searchQuery, filters.separateFiltering]);

  // Export candidates to CSV
  const exportCandidates = async (
    candidates: Candidate[], 
    filters: CandidatesFilter
  ): Promise<void> => {
    try {
      // Prepare data for export
      const exportData = candidates.map(candidate => ({
        'שם פרטי': candidate.firstName,
        'שם משפחה': candidate.lastName,
        'גיל': calculateAge(candidate.profile.birthDate),
        'מגדר': candidate.profile.gender === 'MALE' ? 'זכר' : 'נקבה',
        'עיר': candidate.profile.city || '',
        'גובה': candidate.profile.height || '',
        'רמת דתיות': candidate.profile.religiousLevel || '',
        'תעסוקה': candidate.profile.occupation || '',
        'השכלה': candidate.profile.education || '',
        'מצב משפחתי': candidate.profile.maritalStatus || '',
        'סטטוס זמינות': candidate.profile.availabilityStatus || '',
        'מאומת': candidate.isVerified ? 'כן' : 'לא',
        'פעילות אחרונה': candidate.profile.lastActive 
          ? new Date(candidate.profile.lastActive).toLocaleDateString('he-IL')
          : ''
      }));

      // Add filter info to filename
      const filenameSegments = ['candidates'];
      
      if (filters.gender) {
        filenameSegments.push(filters.gender === 'MALE' ? 'male' : 'female');
      }
      
      if (filters.religiousLevel) {
        filenameSegments.push(filters.religiousLevel.replace(/ /g, '-'));
      }
      
      if (filters.cities?.length === 1) {
        filenameSegments.push(filters.cities[0].replace(/ /g, '-'));
      }
      
      // Convert to CSV
      const csv = Papa.unparse(exportData);
      
      // Create and download file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      const timestamp = new Date().toISOString().split('T')[0];
      
      link.setAttribute('href', url);
      link.setAttribute('download', `${filenameSegments.join('_')}_${timestamp}.csv`);
      document.body.appendChild(link);
      
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Error exporting candidates:', error);
      throw new Error('Failed to export candidates');
    }
  };

  // Update candidate
  const updateCandidate = async (
    id: string, 
    updates: Partial<CandidateProfile>
  ): Promise<void> => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error('Failed to update candidate');
      }
      
      // Refresh candidates list after update
      await fetchCandidates();
    } catch (error) {
      console.error('Error updating candidate:', error);
      throw error;
    }
  };

  // Load candidates on mount
  useEffect(() => {
    fetchCandidates();
  }, []);

  // Return interface
  return {
    loading,
    error,
    candidates,
    filteredCandidates,
    maleCandidates,
    femaleCandidates,
    filters,
    setFilters,
    refresh: fetchCandidates,
    totalCount: candidates.length,
    filteredCount: filteredCandidates.length,
    maleCount: maleCandidates.length,
    femaleCount: femaleCandidates.length,
    searchResults,
    exportCandidates,
    updateCandidate,
    sorting,
    setSorting,
    searchSuggestions
  };
};

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useFilterLogic.ts:
==================================================
// src/app/components/matchmaker/new/hooks/useFilterLogic.ts - גרסה משופרת

import { useState, useEffect, useMemo, useCallback } from 'react';
import type {
  FilterState,
  SavedFilter,
  FilterOption,
  FilterChangeHandler,  
} from '../types/filters';
import { DEFAULT_FILTER_STATE } from '../types/filters'; 

type SavedFilterFromStorage = Omit<SavedFilter, 'createdAt'> & {
  createdAt: string;
};

interface SearchHistoryItemFromStorage {
  query: string;
  timestamp: string;
}
interface UseFilterLogicProps {
  onFilterChange?: FilterChangeHandler;
  defaultFilters?: Partial<FilterState>;
  localStorageKey?: string;
}

export const useFilterLogic = ({
  onFilterChange,
  defaultFilters = {},
  localStorageKey = 'candidateFilters'
}: UseFilterLogicProps = {}) => {
  // States
  const [filters, setFilters] = useState<FilterState>({
    ...DEFAULT_FILTER_STATE,
    ...defaultFilters
  });
  
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [searchHistory, setSearchHistory] = useState<{query: string, timestamp: Date}[]>([]);
  const [lastAppliedFilter, setLastAppliedFilter] = useState<string | null>(null);

  // Load saved filters and history from localStorage
  useEffect(() => {
    try {
      // Load saved filters
      const savedPrefs = localStorage.getItem(localStorageKey);
      if (savedPrefs) {
        const parsed = JSON.parse(savedPrefs);
        setSavedFilters(parsed.map((filter: SavedFilterFromStorage) => ({
          ...filter,
          createdAt: new Date(filter.createdAt)
        })));
      }

      // Load recent searches
      const searches = localStorage.getItem(`${localStorageKey}_recent_searches`);
      if (searches) {
        setRecentSearches(JSON.parse(searches));
      }

      // Load search history
      const history = localStorage.getItem(`${localStorageKey}_search_history`);
      if (history) {
        setSearchHistory(JSON.parse(history).map((item: SearchHistoryItemFromStorage) => ({
          ...item,
          timestamp: new Date(item.timestamp)
        })));
      }
    } catch (error) {
      console.error('Error loading saved filters:', error);
    }
  }, [localStorageKey]);

  // עדכון פילטרים כללי
  const updateFilters = useCallback((newFilters: Partial<FilterState>) => {
    console.log("updateFilters called with:", newFilters);
    
    setFilters(prev => {
      const updated = { ...prev, ...newFilters };
      console.log("Updated filters:", updated);
      
      // אם יש מחרוזת חיפוש חדשה, עדכן את היסטורית החיפוש
      if (newFilters.searchQuery && newFilters.searchQuery !== prev.searchQuery) {
        const newQuery = newFilters.searchQuery;
        console.log("New search query detected:", newQuery);
        
        // עדכון היסטוריית החיפוש
        const updatedHistory = [
          { query: newQuery, timestamp: new Date() },
          ...searchHistory.filter(item => item.query !== newQuery).slice(0, 9)
        ];
        
        setSearchHistory(updatedHistory);
        setRecentSearches(updatedHistory.map(item => item.query));
        
        // שמירה ב-localStorage
        try {
          localStorage.setItem(
            `${localStorageKey}_recent_searches`, 
            JSON.stringify(updatedHistory.map(item => item.query))
          );
          localStorage.setItem(
            `${localStorageKey}_search_history`,
            JSON.stringify(updatedHistory.map(item => ({
              query: item.query,
              timestamp: item.timestamp.toISOString()
            })))
          );
        } catch (e) {
          console.error("Error saving search history:", e);
        }
      }
      
      // טיפול בחיפוש נפרד לגברים
      if (newFilters.maleSearchQuery && newFilters.maleSearchQuery !== prev.maleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי גברים או לשמור בהיסטוריה הכללית
        console.log("New male search query:", newFilters.maleSearchQuery);
      }
      
      // טיפול בחיפוש נפרד לנשים
      if (newFilters.femaleSearchQuery && newFilters.femaleSearchQuery !== prev.femaleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי נשים או לשמור בהיסטוריה הכללית
        console.log("New female search query:", newFilters.femaleSearchQuery);
      }

      // קריאה לפונקציית callback
      if (onFilterChange) {
        console.log("Calling onFilterChange with updated filters");
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange, searchHistory, localStorageKey, setRecentSearches, setSearchHistory]);

  // Reset filters
  const resetFilters = useCallback(() => {
    const defaultState: FilterState = {
      ...DEFAULT_FILTER_STATE,
      ...defaultFilters
    };

    setFilters(defaultState);
    setLastAppliedFilter(null);
    onFilterChange?.(defaultState);
  }, [defaultFilters, onFilterChange]);

  // Clear recent searches
  const clearRecentSearches = useCallback(() => {
    setRecentSearches([]);
    localStorage.removeItem(`${localStorageKey}_recent_searches`);
  }, [localStorageKey]);

  // Save new filter
  const saveFilter = useCallback(async (name: string, filters: FilterState) => {
    const newFilter: SavedFilter = {
      id: Date.now().toString(),
      name,
      filters,
      isDefault: false,
      createdAt: new Date()
    };

    setSavedFilters(prev => {
      const updated = [...prev, newFilter];
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });

    return newFilter;
  }, [localStorageKey]);

  // פונקציה משופרת להחלפת מצב הסינון הנפרד
  const toggleSeparateFiltering = useCallback(() => {
    console.log("toggleSeparateFiltering called");
    
    setFilters(prev => {
      const newState = {
        ...prev,
        separateFiltering: !prev.separateFiltering
      };
      
      console.log(`Changing separateFiltering from ${prev.separateFiltering} to ${newState.separateFiltering}`);
      
      return newState;
    });
  }, []);

  // פונקציה משופרת לעדכון סינון גברים
  const updateMaleFilters = useCallback((maleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedMaleFilters = {
        ...prev.maleFilters,
        ...maleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לגברים
      if (maleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          maleFilters: updatedMaleFilters,
          maleSearchQuery: maleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        maleFilters: updatedMaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת לעדכון סינון נשים
  const updateFemaleFilters = useCallback((femaleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedFemaleFilters = {
        ...prev.femaleFilters,
        ...femaleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לנשים
      if (femaleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          femaleFilters: updatedFemaleFilters,
          femaleSearchQuery: femaleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        femaleFilters: updatedFemaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  const updateMaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        maleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לגברים
      if (prev.separateFiltering) {
        updated.maleFilters = {
          ...prev.maleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);
  
  // פונקציה חדשה לעדכון חיפוש נפרד לנשים
  const updateFemaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        femaleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לנשים
      if (prev.separateFiltering) {
        updated.femaleFilters = {
          ...prev.femaleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת להעתקת סינון מצד אחד לשני
  const copyFilters = useCallback((source: 'male' | 'female', target: 'male' | 'female') => {
    setFilters(prev => {
      const sourceFilters = source === 'male' ? prev.maleFilters : prev.femaleFilters;
      
      if (!sourceFilters) {
        return prev;
      }
      
      const updated = { ...prev };
      
      if (target === 'male') {
        updated.maleFilters = { ...sourceFilters };
      } else {
        updated.femaleFilters = { ...sourceFilters };
      }
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // Update existing filter
  const updateSavedFilter = useCallback((id: string, updates: Partial<SavedFilter>) => {
    setSavedFilters(prev => {
      const updated = prev.map(filter => 
        filter.id === id ? { ...filter, ...updates } : filter
      );
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Delete filter
  const deleteFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.filter(f => f.id !== id);
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      
      if (lastAppliedFilter === id) {
        setLastAppliedFilter(null);
      }
      
      return updated;
    });
  }, [localStorageKey, lastAppliedFilter]);

  // Set default filter
  const setDefaultFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.map(f => ({
        ...f,
        isDefault: f.id === id
      }));
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Load saved filter - תמיכה בסינון נפרד
  const loadSavedFilter = useCallback((id: string) => {
    const filter = savedFilters.find(f => f.id === id);
    if (filter) {
      // בדוק אם יש בפילטר השמור מידע לגבי סינון נפרד
      setFilters({ 
        ...filter.filters, 
        savedFilterId: id,
        // וודא שיש תמיד את המאפיינים האלה, גם אם אינם מוגדרים בפילטר המקורי
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {}
      });
      
      setLastAppliedFilter(id);
      onFilterChange?.({ 
        ...filter.filters, 
        savedFilterId: id,
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {} 
      });
    }
  }, [savedFilters, onFilterChange]);

  // Apply popular filter
  const applyPopularFilter = useCallback((filterConfig: Partial<FilterState>) => {
    const updatedFilters = {
      ...DEFAULT_FILTER_STATE,
      ...filterConfig
    };
    setFilters(updatedFilters);
    onFilterChange?.(updatedFilters);
  }, [onFilterChange]);

  // Check for active filters
  const hasActiveFilters = useMemo(() => {
    return (
      filters.searchQuery ||
      filters.gender !== undefined ||
      (filters.cities?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      (filters.occupations?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      filters.religiousLevel ||
      filters.educationLevel ||
      filters.maritalStatus ||
      filters.availabilityStatus ||
      filters.userStatus ||
      filters.isVerified ||
      filters.hasReferences ||
      filters.lastActiveDays ||
      filters.isProfileComplete ||
      (filters.ageRange && (
        filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min ||
        filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
      )) ||
      (filters.heightRange && (
        filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min ||
        filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
      )) ||
      // בדיקת פילטרים נפרדים פעילים
      filters.separateFiltering
    );
  }, [filters]);

  // Get active filters in formatted array
  const activeFilters = useMemo((): FilterOption[] => {
    const active: FilterOption[] = [];

    if (filters.searchQuery) {
      active.push({
        key: 'searchQuery',
        value: filters.searchQuery,
        label: `חיפוש: ${filters.searchQuery}`,
        category: 'חיפוש'
      });
    }

    if (filters.gender) {
      active.push({
        key: 'gender',
        value: filters.gender,
        label: `מגדר: ${filters.gender === 'MALE' ? 'זכר' : 'נקבה'}`,
        category: 'מידע בסיסי'
      });
    }

    if (filters.separateFiltering) {
      active.push({
        key: 'separateFiltering',
        value: true,
        label: 'סינון נפרד לפי מגדר',
        category: 'מידע בסיסי'
      });
    }

    // גיל
    if (filters.ageRange && (
      filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min || 
      filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
    )) {
      active.push({
        key: 'ageRange',
        value: filters.ageRange,
        label: `גיל: ${filters.ageRange.min}-${filters.ageRange.max}`,
        category: 'מידע בסיסי'
      });
    }

    // גובה
    if (filters.heightRange && (
      filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min || 
      filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
    )) {
      active.push({
        key: 'heightRange',
        value: filters.heightRange,
        label: `גובה: ${filters.heightRange.min}-${filters.heightRange.max} ס"מ`,
        category: 'מידע בסיסי'
      });
    }

    // ערים
    if (filters.cities?.length) {
      if (filters.cities.length === 1) {
        active.push({
          key: 'cities',
          value: filters.cities[0],
          label: `עיר: ${filters.cities[0]}`,
          category: 'מיקום'
        });
      } else {
        active.push({
          key: 'cities',
          value: filters.cities,
          label: `ערים: ${filters.cities.length} נבחרו`,
          category: 'מיקום'
        });
      }
    }

    // תחומי עיסוק
    if (filters.occupations?.length) {
      if (filters.occupations.length === 1) {
        active.push({
          key: 'occupations',
          value: filters.occupations[0],
          label: `תחום עיסוק: ${filters.occupations[0]}`,
          category: 'תעסוקה'
        });
      } else {
        active.push({
          key: 'occupations',
          value: filters.occupations,
          label: `תחומי עיסוק: ${filters.occupations.length} נבחרו`,
          category: 'תעסוקה'
        });
      }
    }

    // רמת דתיות
    if (filters.religiousLevel) {
      active.push({
        key: 'religiousLevel',
        value: filters.religiousLevel,
        label: `רמת דתיות: ${filters.religiousLevel}`,
        category: 'דת'
      });
    }

    // השכלה
    if (filters.educationLevel) {
      active.push({
        key: 'educationLevel',
        value: filters.educationLevel,
        label: `השכלה: ${filters.educationLevel}`,
        category: 'השכלה'
      });
    }

    // מצב משפחתי
    if (filters.maritalStatus) {
      active.push({
        key: 'maritalStatus',
        value: filters.maritalStatus,
        label: `מצב משפחתי: ${filters.maritalStatus}`,
        category: 'מידע אישי'
      });
    }

    // סטטוס זמינות
    if (filters.availabilityStatus) {
      const statusLabel = 
        filters.availabilityStatus === "AVAILABLE" ? "פנוי/ה" :
        filters.availabilityStatus === "DATING" ? "בתהליך הכרות" :
        filters.availabilityStatus === "UNAVAILABLE" ? "לא פנוי/ה" :
        filters.availabilityStatus;
      
      active.push({
        key: 'availabilityStatus',
        value: filters.availabilityStatus,
        label: `סטטוס זמינות: ${statusLabel}`,
        category: 'זמינות'
      });
    }

    // סטטוס משתמש
    if (filters.userStatus) {
      active.push({
        key: 'userStatus',
        value: filters.userStatus,
        label: `סטטוס משתמש: ${filters.userStatus}`,
        category: 'סטטוס'
      });
    }

    // משתמש מאומת
    if (filters.isVerified !== undefined) {
      active.push({
        key: 'isVerified',
        value: filters.isVerified,
        label: `משתמש מאומת: ${filters.isVerified ? 'כן' : 'לא'}`,
        category: 'אימות'
      });
    }

    // יש המלצות
    if (filters.hasReferences !== undefined) {
      active.push({
        key: 'hasReferences',
        value: filters.hasReferences,
        label: `יש המלצות: ${filters.hasReferences ? 'כן' : 'לא'}`,
        category: 'המלצות'
      });
    }

    // פעילות אחרונה
    if (filters.lastActiveDays !== undefined) {
      active.push({
        key: 'lastActiveDays',
        value: filters.lastActiveDays,
        label: `פעיל ב-${filters.lastActiveDays} הימים האחרונים`,
        category: 'פעילות'
      });
    }

    // פרופיל מלא
    if (filters.isProfileComplete !== undefined) {
      active.push({
        key: 'isProfileComplete',
        value: filters.isProfileComplete,
        label: `פרופיל מלא: ${filters.isProfileComplete ? 'כן' : 'לא'}`,
        category: 'שלמות פרופיל'
      });
    }

    return active;
  }, [filters]);

  // Remove single filter
  const removeFilter = useCallback((key: keyof FilterState, value?: string) => {
    setFilters(prev => {
      const updated = { ...prev };

      if (key === 'separateFiltering') {
        updated.separateFiltering = false;
      } else if (Array.isArray(updated[key]) && value !== undefined) {
        if (key === 'cities' || key === 'occupations') {
          updated[key] = (updated[key] as string[]).filter(v => v !== value);
        }
      } else {
        delete updated[key];
      }

      onFilterChange?.(updated);
      return updated;
    });
  }, [onFilterChange]);
  
  // Calculate popular filters based on search history
  const popularFilters = useMemo(() => {
    // Group searches by frequency
    const searchFrequency: Record<string, number> = {};
    searchHistory.forEach(item => {
      searchFrequency[item.query] = (searchFrequency[item.query] || 0) + 1;
    });
    
    // Sort by frequency
    return Object.entries(searchFrequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([query]) => query);
  }, [searchHistory]);

  return {
    // Current state
    filters,
    savedFilters,
    recentSearches,
    searchHistory,
    activeFilters,
    hasActiveFilters,
    popularFilters,
    lastAppliedFilter,
    
    // Separate filtering functions
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    
    // חיפוש נפרד פונקציות חדשות
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
    
    // Actions
    setFilters: updateFilters,
    removeFilter,
    resetFilters,
    clearRecentSearches,
    applyPopularFilter,

    // Saved filters management
    saveFilter,
    updateSavedFilter,
    deleteFilter,
    setDefaultFilter,
    loadSavedFilter,
};
};
export default useFilterLogic;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useMatchmaking.ts:
==================================================
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS } from '../constants/matchingCriteria';
import type { User } from '@/types/next-auth';
// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: User[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: User;
  candidateB: User;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: User;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile?.gender === candidateB.profile?.gender ||
          candidateA.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA.profile, candidateB.profile);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\hooks\useStatistics.ts:
==================================================
// /hooks/useStatistics.ts

import { useMemo } from 'react';
import type { Candidate } from '../types/candidates';
import {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
} from '../utils/statisticsCalculator';

export interface Statistics {
  gender: {
    maleCount: number;
    femaleCount: number;
    ratio: number;
    total: number;
    percentages: {
      male: number;
      female: number;
    };
  };
  age: {
    ageGroups: Record<string, number>;
    averageAge: number;
    medianAge: number;
  };
  location: {
    cities: Record<string, number>;
    topCities: Array<{ city: string; count: number }>;
  };
  religious: {
    levels: Record<string, number>;
    percentages: Record<string, number>;
  };
  activity: {
    activeLastWeek: number;
    activeLastMonth: number;
    averageLoginFrequency: number;
    completedProfiles: number;
  };
  availability: {
    counts: Record<string, number>;
    percentages: Record<string, number>;
  };
  completion: {
    counts: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
    percentages: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
  };
}

export const useStatistics = (candidates: Candidate[]) => {
  const stats = useMemo<Statistics>(() => {
    return {
      gender: calculateGenderStats(candidates),
      age: calculateAgeDistribution(candidates),
      location: calculateLocationDistribution(candidates),
      religious: calculateReligiousDistribution(candidates),
      activity: calculateActivityStats(candidates),
      availability: calculateAvailabilityStats(candidates),
      completion: calculateCompletionStats(candidates)
    };
  }, [candidates]);

  // פונקציות עזר לשליפת נתונים ספציפיים
  const getGenderRatio = () => {
    return {
      ratio: stats.gender.ratio,
      formattedRatio: `${stats.gender.maleCount}:${stats.gender.femaleCount}`
    };
  };

  const getTopCities = (limit: number = 5) => {
    return stats.location.topCities.slice(0, limit);
  };

  const getActiveUsersPercent = () => {
    return Math.round((stats.activity.activeLastWeek / stats.gender.total) * 100);
  };

  const getCompletionRate = () => {
    return stats.completion.percentages.fullyCompleted;
  };

  const getAgeGroupDistribution = () => {
    return Object.entries(stats.age.ageGroups)
      .map(([range, count]) => ({
        range,
        count,
        percentage: Math.round((count / stats.gender.total) * 100)
      }))
      .sort((a, b) => {
        const [aMin] = a.range.split('-').map(Number);
        const [bMin] = b.range.split('-').map(Number);
        return aMin - bMin;
      });
  };

  const getReligiousDistribution = () => {
    return Object.entries(stats.religious.levels)
      .map(([level, count]) => ({
        level,
        count,
        percentage: stats.religious.percentages[level]
      }))
      .sort((a, b) => b.count - a.count);
  };

  const getActivityTrend = () => {
    return {
      weekly: stats.activity.activeLastWeek,
      monthly: stats.activity.activeLastMonth,
      average: stats.activity.averageLoginFrequency
    };
  };

  const getProfileCompletionStats = () => {
    return {
      completed: stats.completion.counts.fullyCompleted,
      partial: stats.gender.total - stats.completion.counts.fullyCompleted,
      percentage: stats.completion.percentages.fullyCompleted
    };
  };

  return {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getCompletionRate,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats
  };
};

export default useStatistics;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\CandidateSelector.tsx:
==================================================
import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../types/candidates";

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={(value) => {
                  setInputValue(value);
                  setActiveIndex(-1);
                }}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => (
                    <div
                      key={candidate.id}
                      onClick={() => handleSelect(candidate)}
                      className={`flex items-center gap-2 text-right p-2 hover:bg-accent/50 cursor-pointer ${
                        index === activeIndex ? "bg-accent" : ""
                      }`}
                      role="option"
                      id={`candidate-${candidate.id}`}
                      aria-selected={index === activeIndex}
                      onMouseEnter={() => setActiveIndex(index)}
                    >
                      <div className="flex-1">
                        <div className="font-medium">
                          {formatCandidateDisplay(candidate)}
                        </div>
                        <div className="text-sm text-gray-500">
                          {candidate.profile.religiousLevel} |
                          {candidate.profile.occupation &&
                            ` ${candidate.profile.occupation} |`}
                          {candidate.profile.education &&
                            ` ${candidate.profile.education}`}
                        </div>
                      </div>
                    </div>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => {
                /* Add view profile handler */
              }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\index.tsx:
==================================================
"use client";
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/toast/use-toast";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { CheckCircle, UserPlus } from "lucide-react";
import { Steps } from "@/components/ui/steps";
import type { Candidate } from "../types/candidates";
import { newSuggestionSchema } from "./schema";
import type { NewSuggestionFormData } from "./schema";
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const STEPS = [
  {
    title: "בחירת מועמדים",
    description: "בחירת שני הצדדים להצעה",
    icon: UserPlus,
  },
  {
    title: "פרטי ההצעה",
    description: "הגדרת פרטי ההצעה ותזמונים",
    icon: CheckCircle,
  },
];

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({
  isOpen,
  onClose,
  candidates,
  selectedCandidate,
  onSubmit,
}) => {
  const [step, setStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(
    selectedCandidate || null
  );
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);

  const { toast } = useToast();

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      firstPartyId: selectedCandidate?.id || "",
      secondPartyId: "",
    },
  });

  // Debug logging for form state changes
  useEffect(() => {
    const subscription = form.watch((value, { name, type }) => {
      console.log("Form value changed:", {
        name,
        value,
        type,
        allValues: form.getValues(),
        formState: form.formState,
      });
    });

    return () => subscription.unsubscribe();
  }, [form]);

  // Handle candidate selection
  const handleCandidateSelect =
    (type: "first" | "second") => (candidate: Candidate | null) => {
      console.log(`${type} party selection:`, { candidate });

      if (type === "first") {
        setFirstParty(candidate);
        if (candidate) {
          form.setValue("firstPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("firstPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      } else {
        setSecondParty(candidate);
        if (candidate) {
          form.setValue("secondPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("secondPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      }

      // Log form state after update
      console.log("Form state after selection:", {
        values: form.getValues(),
        errors: form.formState.errors,
        isDirty: form.formState.isDirty,
        isValid: form.formState.isValid,
      });
    };

  const handleSubmit = async (data: NewSuggestionFormData) => {
    console.log("Submit attempt:", {
      formData: data,
      formState: form.formState,
      firstParty,
      secondParty,
    });

    if (!firstParty || !secondParty) {
      console.log("Missing parties:", { firstParty, secondParty });
      return;
    }

    try {
      setIsSubmitting(true);
      console.log("=== Before API call ===");
      await onSubmit(data);
      console.log("=== After successful API call ===");
      toast({
        title: "ההצעה נוצרה בהצלחה",
        description: "ההצעה נשמרה במערכת והועברה לטיפול",
      });
      onClose();
    } catch (error) {
      console.log("=== API call failed ===", error);
      console.error("Submission error:", error);
      toast({
        title: "שגיאה",
        description: "אירעה שגיאה בעת יצירת ההצעה",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle form validation before moving to next step
  const handleNextStep = () => {
    form.trigger(["firstPartyId", "secondPartyId"]).then((isValid) => {
      if (isValid) {
        setStep(2);
      } else {
        console.log("Validation failed:", form.formState.errors);
      }
    });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto p-0">
        <DialogHeader className="px-8 pt-6 pb-2">
          <DialogTitle className="text-2xl">יצירת הצעת שידוך חדשה</DialogTitle>
          <DialogDescription>
            יצירת הצעת שידוך בין שני מועמדים והגדרת פרטי ההצעה
          </DialogDescription>
        </DialogHeader>

        {/* Steps Indicator */}
        <div className="px-8 py-4">
          <Steps steps={STEPS} currentStep={step} />
        </div>

        <Separator />

        <FormProvider {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="p-8 pt-6">
            {/* Step 1: Candidate Selection */}
            <div className={step !== 1 ? "hidden" : "space-y-8"}>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <CandidateSelector
                  label="צד א׳"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={candidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />

                <CandidateSelector
                  label="צד ב׳"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={candidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

              {firstParty && secondParty && (
                <div className="rounded-lg border bg-card">
                  <div className="px-6 py-4 border-b">
                    <h3 className="text-lg font-semibold">
                      התאמה בין המועמדים
                    </h3>
                  </div>
                  <div className="p-6">
                    <MatchPreview
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  </div>
                </div>
              )}

              <div className="flex justify-end mt-8">
                <Button
                  type="button"
                  size="lg"
                  onClick={handleNextStep}
                  disabled={!firstParty || !secondParty}
                >
                  המשך להגדרת פרטי ההצעה
                </Button>
              </div>
            </div>

            {/* Step 2: Suggestion Details */}
            <div className={step !== 2 ? "hidden" : "space-y-8"}>
              <div className="rounded-lg border bg-card">
                <div className="px-6 py-4 border-b">
                  <h3 className="text-lg font-semibold">פרטי ההצעה</h3>
                </div>
                <div className="p-6">
                  {firstParty && secondParty ? (
                    <SuggestionDetails
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  ) : (
                    <div className="text-center py-4 text-gray-500">
                      יש לבחור את שני הצדדים בשלב הראשון
                    </div>
                  )}
                </div>
              </div>

              <div className="flex justify-between mt-8">
                <Button
                  type="button"
                  variant="outline"
                  size="lg"
                  onClick={() => setStep(1)}
                >
                  חזרה לבחירת מועמדים
                </Button>

                <Button
                  type="submit"
                  size="lg"
                  disabled={isSubmitting || !form.formState.isValid}
                >
                  {isSubmitting ? "שומר הצעה..." : "שמור הצעה"}
                </Button>
              </div>
            </div>
          </form>
        </FormProvider>
      </DialogContent>
    </Dialog>
  );
};

export default NewSuggestionForm;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\MatchPreview.tsx:
==================================================
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\schema.ts:
==================================================
import { z } from "zod";
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\NewSuggestionForm\SuggestionDetails.tsx:
==================================================
"use client";
import React from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { calculateAge } from "@/lib/utils";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../types/candidates";

interface SuggestionDetailsProps {
  className?: string;
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({
  firstParty,
  secondParty,
}) => {
  const {
    register,
    formState: { errors },
    setValue,
    getValues,
  } = useFormContext<NewSuggestionFormData>();

  // Format candidate display
  const formatCandidateInfo = (candidate: Candidate): string => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  };

  // Register all form fields
  React.useEffect(() => {
    // Set default values if not already set
    const currentValues = getValues();
    if (!currentValues.priority) {
      setValue("priority", Priority.MEDIUM);
    }
  }, [setValue, getValues]);

  return (
    <div className="space-y-6">
      {/* Selected Candidates Summary */}
      <Card className="bg-slate-50">
        <CardHeader className="pb-3">
          <h3 className="text-lg font-semibold">הצדדים המוצעים</h3>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד א׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(firstParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {firstParty.profile.religiousLevel} |
                {firstParty.profile.occupation &&
                  ` ${firstParty.profile.occupation} |`}
                {firstParty.profile.education &&
                  ` ${firstParty.profile.education}`}
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד ב׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(secondParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {secondParty.profile.religiousLevel} |
                {secondParty.profile.occupation &&
                  ` ${secondParty.profile.occupation} |`}
                {secondParty.profile.education &&
                  ` ${secondParty.profile.education}`}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Priority Selection with Visual Indicators */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <Label className="text-lg">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => {
                setValue("priority", value, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              value={getValues("priority") || Priority.MEDIUM}
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י עדיפות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="destructive"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    דחופה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.HIGH}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="warning"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    גבוהה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.MEDIUM}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="default"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    רגילה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.LOW}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="secondary"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    נמוכה
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && (
              <p className="text-sm text-red-500">{errors.priority.message}</p>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Matching Details */}
      <Card>
        <CardContent className="pt-6 space-y-6">
          {/* Matching Reason */}
          <div className="space-y-3">
            <Label className="text-lg">סיבת ההתאמה</Label>
            <div className="text-sm text-gray-500 mb-2">
              פרט/י מדוע לדעתך יש התאמה בין המועמדים. מידע זה יוצג לשני הצדדים.
            </div>
            <Textarea
              {...register("matchingReason")}
              placeholder="לדוגמה: שני הצדדים מחפשים בן/בת זוג עם השקפת עולם דומה, שאיפות דומות..."
              className="min-h-[120px] resize-none"
            />
            {errors.matchingReason && (
              <p className="text-sm text-red-500">
                {errors.matchingReason.message}
              </p>
            )}
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-3">
              <Label className="text-lg">הערות לצד א׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{firstParty.firstName}
              </div>
              <Textarea
                {...register("firstPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.firstPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.firstPartyNotes.message}
                </p>
              )}
            </div>

            <div className="space-y-3">
              <Label className="text-lg">הערות לצד ב׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{secondParty.firstName}
              </div>
              <Textarea
                {...register("secondPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.secondPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.secondPartyNotes.message}
                </p>
              )}
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-3">
            <Label className="text-lg">הערות פנימיות</Label>
            <div className="text-sm text-gray-500 mb-2">
              הערות אלו יהיו גלויות רק לצוות השדכנים
            </div>
            <Textarea
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשדכנים..."
              className="min-h-[100px] resize-none"
            />
            {errors.internalNotes && (
              <p className="text-sm text-red-500">
                {errors.internalNotes.message}
              </p>
            )}
          </div>

          {/* Decision Days */}
          <div className="space-y-3">
            <Label className="text-lg">זמן להחלטה</Label>
            <div className="text-sm text-gray-500 mb-2">
              תוך כמה ימים נדרשת החלטה סופית משני הצדדים
            </div>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              defaultValue="14"
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י מספר ימים" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="2">2 ימים</SelectItem>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="5">5 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && (
              <p className="text-sm text-red-500">
                {errors.decisionDeadline.message}
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\services\email\EmailService.ts:
==================================================
import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import nodemailer from 'nodemailer';

type UserWithProfile = User & {
  profile: Profile | null;
};

type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type EmailTemplate = {
  subject: string;
  body: (data: SuggestionWithParties) => string;
};

// Helper function to format user details with proper RTL support
const formatUserDetails = (user: UserWithProfile) => {
  const details = [
    `שם: ${user.firstName} ${user.lastName}`,
    `אימייל: ${user.email}`,
  ];

  if (user?.phone) {
    details.push(`טלפון: ${user?.phone}`);
  }

  return details.join('\n');
};

// Base HTML template with RTL support
const createHtmlTemplate = (content: string) => `
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            direction: rtl;
            text-align: right;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }
    </style>
</head>
<body>
    ${content}
</body>
</html>
`;

// Email templates for different statuses
const emailTemplates: Record<MatchSuggestionStatus, EmailTemplate | null> = {
  DRAFT: {
    subject: 'טיוטת הצעת שידוך נשמרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>טיוטת הצעת השידוך נשמרה בהצלחה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטי ההצעה</a></p>
      </div>
    `)
  },
  
  PENDING_FIRST_PARTY: {
    subject: 'הצעת שידוך חדשה עבורך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.firstParty.firstName},</h2>
        <p>${data.matchmaker.firstName} ${data.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p>
        <p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/review">לצפייה בהצעה</a></p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  FIRST_PARTY_APPROVED: {
    subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.firstParty.firstName} ${data.firstParty.lastName} אישר/ה את הצעת השידוך.</p>
        <p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  FIRST_PARTY_DECLINED: {
    subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.firstParty.firstName} ${data.firstParty.lastName} דחה/תה את הצעת השידוך.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  PENDING_SECOND_PARTY: {
    subject: 'הצעת שידוך חדשה עבורך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.secondParty.firstName},</h2>
        <p>${data.matchmaker.firstName} ${data.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p>
        <p>הצד הראשון כבר אישר את ההצעה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/review">לצפייה בפרטי ההצעה ומענה</a></p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  SECOND_PARTY_APPROVED: {
    subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.secondParty.firstName} ${data.secondParty.lastName} אישר/ה את הצעת השידוך.</p>
        <p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  SECOND_PARTY_DECLINED: {
    subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>${data.secondParty.firstName} ${data.secondParty.lastName} דחה/תה את הצעת השידוך.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  AWAITING_MATCHMAKER_APPROVAL: {
    subject: 'נדרש אישור שדכן להצעה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>נדרש אישורך להצעת השידוך בין ${data.firstParty.firstName} ל${data.secondParty.firstName}.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים ואישור</a></p>
      </div>
    `)
  },

  CONTACT_DETAILS_SHARED: {
    subject: 'פרטי קשר להצעת השידוך',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2>
        <p>פרטי הקשר של הצד הראשון:</p>
        <pre>${formatUserDetails(data.firstParty)}</pre>
        <p>פרטי הקשר של הצד השני:</p>
        <pre>${formatUserDetails(data.secondParty)}</pre>
        <p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p>
        <p>בהצלחה!</p>
      </div>
    `)
  },

  AWAITING_FIRST_DATE_FEEDBACK: {
    subject: 'בקשה למשוב על הפגישה הראשונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/feedback">לשליחת המשוב</a></p>
      </div>
    `)
  },

  THINKING_AFTER_DATE: {
    subject: 'בקשת זמן למחשבה לאחר הפגישה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים נוספים</a></p>
      </div>
    `)
  },

  PROCEEDING_TO_SECOND_DATE: {
    subject: 'עדכון סטטוס - ממשיכים לפגישה שנייה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>שני הצדדים הסכימו להמשיך לפגישה שנייה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  ENDED_AFTER_FIRST_DATE: {
    subject: 'עדכון סטטוס - סיום לאחר פגישה ראשונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה הסתיימה לאחר הפגישה הראשונה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים והמשוב</a></p>
      </div>
    `)
  },

  MEETING_PENDING: {
    subject: 'הצעה לקביעת פגישה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>התקבלה הצעה לקביעת פגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/meetings">לצפייה בפרטי ההצעה</a></p>
      </div>
    `)
  },

  MEETING_SCHEDULED: {
    subject: 'פגישה נקבעה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום,</h2>
        <p>אנו שמחים לעדכן שנקבעה פגישה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/suggestions/${data.id}/meetings">לצפייה בפרטי הפגישה</a></p>
      </div>
    `)
  },

  MATCH_APPROVED: {
    subject: 'ההצעה אושרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה אושרה על ידי שני הצדדים.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  MATCH_DECLINED: {
    subject: 'ההצעה נדחתה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>ההצעה נדחתה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  DATING: {
    subject: 'עדכון סטטוס - בתהליך היכרות',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הזוג נמצא בתהליך היכרות.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  ENGAGED: {
    subject: 'מזל טוב! - אירוסין',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>מזל טוב ${data.firstParty.firstName} ו${data.secondParty.firstName}!</h2>
        <p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  MARRIED: {
    subject: 'מזל טוב! - חתונה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>מזל טוב ${data.firstParty.firstName} ו${data.secondParty.firstName}!</h2>
        <p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p>
        <p>בברכה,<br>צוות המערכת</p>
      </div>
    `)
  },

  EXPIRED: {
    subject: 'הצעת השידוך פגה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך פגה עקב חוסר מענה במועד.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  CLOSED: {
    subject: 'הצעת השידוך נסגרה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך נסגרה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },

  CANCELLED: {
    subject: 'הצעת השידוך בוטלה',
    body: (data) => createHtmlTemplate(`
      <div>
        <h2>שלום ${data.matchmaker.firstName},</h2>
        <p>הצעת השידוך בוטלה.</p>
        <p><a href="${process.env.NEXT_PUBLIC_BASE_URL}/dashboard/suggestions/${data.id}">לצפייה בפרטים</a></p>
      </div>
    `)
  },
};

export class EmailService {
  private static instance: EmailService;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure nodemailer for Gmail
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD,
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on startup
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig() {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw - allow the service to continue running even if email verification fails
    }
  }

  public static getInstance(): EmailService {
    if (!EmailService.instance) {
      EmailService.instance = new EmailService();
    }
    return EmailService.instance;
  }

  async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
  
  ): Promise<void> {
    try {
      console.log('email222:------------');
      const template = emailTemplates[suggestion.status];
      if (!template) {
        console.log(`No email template for status: ${suggestion.status}`);
        return;
      }

      const recipients = this.getRecipientsByStatus(suggestion);
      
      console.log(`Preparing to send emails for suggestion ${suggestion.id}`, {
        status: suggestion.status,
        recipientCount: recipients.length
      });

      await Promise.all(
        recipients.map(async (recipient) => {
          await this.sendEmail({
            to: recipient,
            subject: template.subject,
            html: template.body(suggestion),
          });
        })
      );

      console.log(`Successfully sent ${recipients.length} emails for suggestion ${suggestion.id}`);
    } catch (error) {
      console.error('Error sending suggestion emails:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        suggestionId: suggestion.id,
        status: suggestion.status
      });
      throw new Error('Failed to send suggestion emails');
    }
  }

  private getRecipientsByStatus(suggestion: SuggestionWithParties): string[] {
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return [suggestion.firstParty.email];
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return [suggestion.secondParty.email];
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        return [suggestion.matchmaker.email];
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
          suggestion.matchmaker.email,
        ];
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
        ];

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
      case MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE:
      case MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE:
        return [suggestion.matchmaker.email];

      case MatchSuggestionStatus.MEETING_PENDING:
      case MatchSuggestionStatus.MEETING_SCHEDULED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
        ];

      case MatchSuggestionStatus.MATCH_APPROVED:
      case MatchSuggestionStatus.MATCH_DECLINED:
      case MatchSuggestionStatus.DATING:
        return [suggestion.matchmaker.email];

      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        return [
          suggestion.firstParty.email,
          suggestion.secondParty.email,
          suggestion.matchmaker.email,
        ];
      
      case MatchSuggestionStatus.EXPIRED:
      case MatchSuggestionStatus.CLOSED:
      case MatchSuggestionStatus.CANCELLED:
        return [suggestion.matchmaker.email];
      
      default:
        return [];
    }
  }

  async sendEmail({
    to,
    subject,
    html,
  }: {
    to: string;
    subject: string;
    html: string;
  }): Promise<void> {
    try {
      console.log('Attempting to send email:', {
        to,
        subject,
        fromEmail: process.env.GMAIL_USER,
        fromName: process.env.EMAIL_FROM_NAME,
      });

      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME} <${process.env.GMAIL_USER}>`,
        to,
        subject,
        html,
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
      });
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        emailConfig: {
          to,
          subject,
          fromEmail: process.env.GMAIL_USER,
          fromName: process.env.EMAIL_FROM_NAME,
        }
      });
      throw error;
    }
  }
}

// Export singleton instance
export const emailService = EmailService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\services\suggestions\StatusTransitionService.ts:
==================================================
import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { EmailService } from "../email/EmailService";

type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Send email notifications using EmailService
    try {
      await EmailService.getInstance().handleSuggestionStatusChange(
        updatedSuggestion,
      );
    } catch (error) {
      // Log error but don't fail the transition
      console.error('Error sending status transition emails:', error);
    }

    return updatedSuggestion;
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\services\suggestions\SuggestionService.ts:
==================================================
import { MatchSuggestionStatus, Priority, UserRole, MatchSuggestion } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { emailService } from "../email/EmailService";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
} from "@/types/suggestions";

export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    if (!matchmaker || matchmaker.role !== UserRole.MATCHMAKER) {
      throw new Error("Unauthorized - User is not a matchmaker");
    }

  /*   // 2. בדיקת זמינות המועמדים
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: data.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: data.secondPartyId },
        include: { profile: true },
      }),
    ]); 

    if (!firstParty || !secondParty) {
      throw new Error("One or both parties not found");
    }

    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      throw new Error("One or both parties are not available for matching");
    } 
 */
  /*   // 3. בדיקת הצעות קיימות
    const existingSuggestion = await this.checkExistingSuggestion(
      data.firstPartyId,
      data.secondPartyId
    );

    if (existingSuggestion) {
      throw new Error("Active suggestion already exists between these parties");
    }
 */
    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
console.log('Decision deadline type:', typeof data.decisionDeadline);
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות מייל
    console.log('email:------------');
    await emailService.handleSuggestionStatusChange(
      suggestion,
    );

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: MatchSuggestion,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;
    const isSecondParty = userId === suggestion.secondPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        if (!isSecondParty) throw new Error("Only second party can approve/decline at this stage");
        break;

      case MatchSuggestionStatus.CANCELLED:
        if (!isMatchmaker && !isFirstParty && !isSecondParty) {
          throw new Error("Only involved parties can cancel the suggestion");
        }
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<MatchSuggestion | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
    });
  }
}

export const suggestionService = SuggestionService.getInstance();

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\shared\LoadingStates.tsx:
==================================================
"use client";

import React from "react";
import { Loader2, AlertCircle } from "lucide-react";
import { cn } from "@/lib/utils";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";

interface LoadingContainerProps {
  children: React.ReactNode;
  className?: string;
}

interface LoadingSpinnerProps {
  size?: "sm" | "md" | "lg";
  className?: string;
}

interface LoadingCardProps {
  count?: number;
  layout?: "grid" | "list";
  className?: string;
}

interface LoadingTextProps {
  lines?: number;
  className?: string;
}

interface LoadingErrorProps {
  message: string;
  onRetry?: () => void;
  className?: string;
}

export const LoadingContainer: React.FC<LoadingContainerProps> = ({
  children,
  className,
}) => {
  return (
    <div className={cn("relative min-h-[200px]", className)}>
      <div className="absolute inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
      </div>
      <div className="opacity-50 pointer-events-none">{children}</div>
    </div>
  );
};

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = "md",
  className,
}) => {
  const sizeClasses = {
    sm: "w-4 h-4",
    md: "w-8 h-8",
    lg: "w-12 h-12",
  };

  return (
    <div className={cn("flex items-center justify-center", className)}>
      <Loader2
        className={cn("animate-spin text-blue-600", sizeClasses[size])}
      />
    </div>
  );
};

export const LoadingCard: React.FC<LoadingCardProps> = ({
  count = 1,
  layout = "grid",
  className,
}) => {
  return (
    <div
      className={cn(
        layout === "grid"
          ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
          : "space-y-4",
        className
      )}
    >
      {Array.from({ length: count }).map((_, index) => (
        <div
          key={index}
          className={cn(
            "bg-white rounded-lg overflow-hidden shadow-sm",
            layout === "list" ? "flex gap-4" : ""
          )}
        >
          <Skeleton
            className={cn(
              "bg-gray-200",
              layout === "list" ? "w-32 h-32" : "w-full h-48"
            )}
          />

          <div className="p-4 flex-1">
            <div className="flex items-center justify-between mb-4">
              <Skeleton className="h-6 w-1/3" />
              <Skeleton className="h-6 w-16" />
            </div>

            <div className="space-y-2">
              <Skeleton className="h-4 w-2/3" />
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-4 w-3/4" />
            </div>

            <div className="flex gap-2 mt-4">
              <Skeleton className="h-9 w-24" />
              <Skeleton className="h-9 w-24" />
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export const LoadingText: React.FC<LoadingTextProps> = ({
  lines = 3,
  className,
}) => {
  return (
    <div className={cn("space-y-2", className)}>
      {Array.from({ length: lines }).map((_, index) => (
        <Skeleton
          key={index}
          className={cn("h-4", index === lines - 1 ? "w-3/4" : "w-full")}
        />
      ))}
    </div>
  );
};

export const LoadingError: React.FC<LoadingErrorProps> = ({
  message,
  onRetry,
  className,
}) => {
  return (
    <Alert variant="destructive" className={cn("border-red-500", className)}>
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>שגיאה</AlertTitle>
      <AlertDescription className="flex items-center justify-between">
        <span>{message}</span>
        {onRetry && (
          <Button
            variant="outline"
            size="sm"
            onClick={onRetry}
            className="ml-4"
          >
            נסה שוב
          </Button>
        )}
      </AlertDescription>
    </Alert>
  );
};

export const LoadingStats: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("grid grid-cols-2 md:grid-cols-4 gap-4", className)}>
      {Array.from({ length: 4 }).map((_, index) => (
        <div key={index} className="bg-white p-4 rounded-lg shadow-sm">
          <Skeleton className="h-4 w-16 mb-2" />
          <Skeleton className="h-8 w-24" />
        </div>
      ))}
    </div>
  );
};

export const LoadingFilters: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("space-y-4", className)}>
      <Skeleton className="h-10 w-full" />
      <div className="flex flex-wrap gap-2">
        {Array.from({ length: 4 }).map((_, index) => (
          <Skeleton key={index} className="h-8 w-24" />
        ))}
      </div>
    </div>
  );
};

// Create a named object containing all loading components
const LoadingComponents = {
  LoadingContainer,
  LoadingSpinner,
  LoadingCard,
  LoadingText,
  LoadingError,
  LoadingStats,
  LoadingFilters,
};

// Export the named object as default
export default LoadingComponents;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\shared\Pagination.tsx:
==================================================
// /shared/Pagination.tsx
"use client";


import React from 'react';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { 
  ChevronRight, 
  ChevronLeft,
  ChevronsLeft,
  ChevronsRight
} from 'lucide-react';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  pageSize: number;
  totalItems: number;
  onPageChange: (page: number) => void;
  onPageSizeChange: (size: number) => void;
  className?: string;
}

const pageSizeOptions = [10, 20, 50, 100];

const Pagination: React.FC<PaginationProps> = ({
  currentPage,
  totalPages,
  pageSize,
  totalItems,
  onPageChange,
  onPageSizeChange,
  className
}) => {
  // Helper to generate page numbers array
  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisiblePages = 5;
    
    if (totalPages <= maxVisiblePages) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    // Always show first page
    pages.push(1);

    // Calculate start and end of visible pages
    let start = Math.max(currentPage - 1, 2);
    let end = Math.min(currentPage + 1, totalPages - 1);

    // Adjust for edge cases
    if (currentPage <= 3) {
      end = Math.min(maxVisiblePages - 1, totalPages - 1);
    } else if (currentPage >= totalPages - 2) {
      start = Math.max(totalPages - maxVisiblePages + 2, 2);
    }

    // Add ellipsis and numbers
    if (start > 2) pages.push('...');
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    if (end < totalPages - 1) pages.push('...');

    // Always show last page
    if (totalPages > 1) pages.push(totalPages);

    return pages;
  };

  const startItem = (currentPage - 1) * pageSize + 1;
  const endItem = Math.min(currentPage * pageSize, totalItems);

  return (
    <div className={`flex flex-col sm:flex-row items-center justify-between gap-4 ${className}`}>
      {/* Page Size Selector */}
      <div className="flex items-center gap-2 text-sm text-gray-600">
        <span>הצג</span>
        <Select
          value={pageSize.toString()}
          onValueChange={(value) => onPageSizeChange(Number(value))}
        >
          <SelectTrigger className="w-[70px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {pageSizeOptions.map(size => (
              <SelectItem key={size} value={size.toString()}>
                {size}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <span>שורות</span>
      </div>

      {/* Results Count */}
      <div className="text-sm text-gray-600">
        מציג {startItem}-{endItem} מתוך {totalItems} תוצאות
      </div>

      {/* Page Navigation */}
      <div className="flex items-center gap-1">
        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(1)}
          disabled={currentPage === 1}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((page, index) => (
          typeof page === 'number' ? (
            <Button
              key={index}
              variant={currentPage === page ? "default" : "outline"}
              size="sm"
              onClick={() => onPageChange(page)}
              className="hidden sm:inline-flex min-w-[32px]"
            >
              {page}
            </Button>
          ) : (
            <span key={index} className="px-2">
              {page}
            </span>
          )
        ))}

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(totalPages)}
          disabled={currentPage === totalPages}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};

export default Pagination;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\shared\StatusBadge.tsx:
==================================================
import React from "react";
import { Badge } from "@/components/ui/badge";
import {
  Circle,
  CheckCircle,
  XCircle,
  Clock,
  AlertTriangle,
} from "lucide-react";
import { MatchSuggestionStatus, VerificationStatus } from "@prisma/client";

type StatusType = "suggestion" | "verification" | "profile";
type StatusSize = "sm" | "md" | "lg";

interface StatusConfig {
  label: string;
  color: "destructive" | "outline" | "secondary" | "success" | "warning";
  icon:
    | typeof Circle
    | typeof CheckCircle
    | typeof XCircle
    | typeof Clock
    | typeof AlertTriangle;
}

interface StatusBadgeProps {
  type: StatusType;
  status: string;
  size?: StatusSize;
}

const suggestionStatuses: Record<MatchSuggestionStatus, StatusConfig> = {
  DRAFT: {
    label: "טיוטה",
    color: "secondary",
    icon: Circle,
  },
  PENDING_FIRST_PARTY: {
    label: "ממתין לצד ראשון",
    color: "warning",
    icon: Clock,
  },
  FIRST_PARTY_APPROVED: {
    label: 'אושר ע"י צד ראשון',
    color: "success",
    icon: CheckCircle,
  },
  FIRST_PARTY_DECLINED: {
    label: 'נדחה ע"י צד ראשון',
    color: "destructive",
    icon: XCircle,
  },
  PENDING_SECOND_PARTY: {
    label: "ממתין לצד שני",
    color: "warning",
    icon: Clock,
  },
  SECOND_PARTY_APPROVED: {
    label: 'אושר ע"י צד שני',
    color: "success",
    icon: CheckCircle,
  },
  SECOND_PARTY_DECLINED: {
    label: 'נדחה ע"י צד שני',
    color: "destructive",
    icon: XCircle,
  },
  AWAITING_MATCHMAKER_APPROVAL: {
    label: "ממתין לאישור שדכן",
    color: "warning",
    icon: Clock,
  },
  CONTACT_DETAILS_SHARED: {
    label: "פרטי קשר שותפו",
    color: "success",
    icon: CheckCircle,
  },
  AWAITING_FIRST_DATE_FEEDBACK: {
    label: "ממתין למשוב פגישה ראשונה",
    color: "warning",
    icon: Clock,
  },
  THINKING_AFTER_DATE: {
    label: "בשיקול לאחר פגישה",
    color: "warning",
    icon: Clock,
  },
  PROCEEDING_TO_SECOND_DATE: {
    label: "ממשיכים לפגישה שנייה",
    color: "success",
    icon: CheckCircle,
  },
  ENDED_AFTER_FIRST_DATE: {
    label: "הסתיים לאחר פגישה ראשונה",
    color: "destructive",
    icon: XCircle,
  },
  MEETING_PENDING: {
    label: "פגישה בתכנון",
    color: "warning",
    icon: Clock,
  },
  MEETING_SCHEDULED: {
    label: "פגישה נקבעה",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_APPROVED: {
    label: "השידוך אושר",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_DECLINED: {
    label: "השידוך נדחה",
    color: "destructive",
    icon: XCircle,
  },
  DATING: {
    label: "בתהליך היכרות",
    color: "secondary",
    icon: Circle,
  },
  ENGAGED: {
    label: "מאורסים",
    color: "success",
    icon: CheckCircle,
  },
  MARRIED: {
    label: "נישאו",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  CLOSED: {
    label: "סגור",
    color: "destructive",
    icon: XCircle,
  },
  CANCELLED: {
    label: "בוטל",
    color: "destructive",
    icon: XCircle,
  },
};

const verificationStatuses: Record<VerificationStatus, StatusConfig> = {
  PENDING: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  COMPLETED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  FAILED: {
    label: "נכשל",
    color: "destructive",
    icon: XCircle,
  },
};

const profileStatuses: Record<string, StatusConfig> = {
  INCOMPLETE: {
    label: "לא הושלם",
    color: "warning",
    icon: AlertTriangle,
  },
  PENDING_VERIFICATION: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  VERIFIED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  BLOCKED: {
    label: "חסום",
    color: "destructive",
    icon: XCircle,
  },
};

const defaultStatus: StatusConfig = {
  label: "לא ידוע",
  color: "secondary",
  icon: Circle,
};

const getStatusConfig = (type: StatusType, status: string): StatusConfig => {
  switch (type) {
    case "suggestion":
      return (
        suggestionStatuses[status as MatchSuggestionStatus] || defaultStatus
      );
    case "verification":
      return (
        verificationStatuses[status as VerificationStatus] || defaultStatus
      );
    case "profile":
      return profileStatuses[status] || defaultStatus;
    default:
      return defaultStatus;
  }
};

const StatusBadge: React.FC<StatusBadgeProps> = ({
  type,
  status,
  size = "md",
}) => {
  const config = getStatusConfig(type, status);
  const Icon = config.icon;

  const sizeClasses = {
    sm: "text-xs px-2 py-0.5",
    md: "text-sm px-2.5 py-1",
    lg: "text-base px-3 py-1.5",
  };

  return (
    <Badge
      variant={config.color}
      className={`flex items-center gap-1.5 ${sizeClasses[size]}`}
    >
      <Icon className={size === "sm" ? "w-3 h-3" : "w-4 h-4"} />
      <span>{config.label}</span>
    </Badge>
  );
};

export default StatusBadge;


==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\types\candidates.ts:
==================================================
// candidates.ts
import { Gender, AvailabilityStatus, UserStatus } from '@prisma/client';
import type { UserProfile, UserImage, QuestionnaireResponse} from '@/types/next-auth';

// Base API Response Type
export interface APIResponse<T> {
  success: boolean;
  clients: T[];
  count: number;
  error?: string;
}

// Base Types
export type CandidateImage = UserImage;

export type CandidateProfile = UserProfile;

export interface Candidate {
  id: string;
  email: string;
  firstName: string;
  createdAt: Date;
  lastName: string;
  status: UserStatus;
  isVerified: boolean;
  images: CandidateImage[];
  isProfileComplete: boolean;
  profile: CandidateProfile;
}
export interface CandidatesFilter {
  gender?: Gender;
  ageRange?: {
    min: number;
    max: number;
  };
  heightRange?: {
    min: number;
    max: number;
  };
  cities?: string[];
  religiousLevel?: string;
  occupations?: string[];
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
  searchQuery?: string;
  savedFilterId?: string;
  separateFiltering?: boolean;
  
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  
  maleFilters?: Partial<CandidatesFilter>;
  femaleFilters?: Partial<CandidatesFilter>;
  userStatus?: UserStatus;
}

// ViewMode and Action Types - אלה נשארים כמו שהם
export type ViewMode = 'grid' | 'list';
export type CardSize = 'sm' | 'md' | 'lg';
export type CandidateAction = 'suggest' | 'invite' | 'contact' | 'favorite' | 'view' | 'edit';

// Profile Card Types
export interface ProfileCardData {
  profile: CandidateProfile;
  images: CandidateImage[];
  questionnaire?: QuestionnaireResponse;
}

/**
 * ממפה את אובייקט המועמד מהשרת למבנה הנדרש עבור ProfileCard
 */
export const mapCandidateToProfileCard = (candidate: Candidate): ProfileCardData => {
  return {
    profile: candidate.profile,
    images: candidate.images,
    questionnaire: undefined // יש להוסיף לוגיקה לטעינת השאלון בנפרד
  };
};

/**
 * מפריד מועמדים לפי מגדר
 */
export const separateCandidatesByGender = (candidates: Candidate[]) => {
  return {
    maleCandidates: candidates.filter(c => c.profile.gender === 'MALE'),
    femaleCandidates: candidates.filter(c => c.profile.gender === 'FEMALE')
  };
};

/**
 * בודק האם הפרופיל מלא
 */
export const isProfileComplete = (profile: CandidateProfile): boolean => {
  const requiredFields: Array<keyof CandidateProfile> = [
    'birthDate',
    'city',
    'religiousLevel',
    'about',
    'occupation',
    'education'
  ];

  return requiredFields.every(field => Boolean(profile[field]));
};

const candidateUtils = {
  mapCandidateToProfileCard,
  separateCandidatesByGender,
  isProfileComplete
};

export default candidateUtils;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\types\filters.ts:
==================================================
// src/app/components/matchmaker/new/types/filters.ts

import { Gender, AvailabilityStatus, UserStatus } from '@prisma/client';

// הגדרת טווח ערכים מספריים
export interface RangeFilter {
  min: number;
  max: number;
}

// הגדרת פילטר שמור
export interface SavedFilter {
  id: string;
  name: string;
  filters: FilterState;
  isDefault?: boolean;
  createdAt: Date;
}

export interface FilterState {
  // הוספת מצב תצוגה נפרדת
  separateFiltering: boolean;
  
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;

  // פילטרים נפרדים לגברים
  maleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;
  
  // פילטרים נפרדים לנשים
  femaleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;

  searchQuery?: string;
  savedFilterId?: string;
  gender?: Gender | undefined;
  ageRange?: RangeFilter;
  heightRange?: RangeFilter;
  cities?: string[];
  occupations?: string[];
  religiousLevel?: string;
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  userStatus?: UserStatus;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
}

// הגדרת אפשרות פילטר
export interface FilterOption {
  key: keyof (FilterState & { education: string });
  value: Gender | AvailabilityStatus | UserStatus | RangeFilter | string[] | string | number | boolean | undefined;
  label: string;
  category?: string;
}

// הגדרת קטגוריית פילטר
export interface FilterCategory {
  id: string;
  label: string;
  filters: Array<keyof (FilterState & { education: string })>;
}

// הגדרת פרופ לקומפוננטת הפילטרים
export interface FilterProps {
  filters: FilterState;
  onFiltersChange: (filters: FilterState) => void;
  onReset?: () => void;
  className?: string;
}

// הגדרת אפשרויות הפילטר
export interface FilterOptions {
  ages: RangeFilter;
  heights: RangeFilter;
  cities: string[];
  religiousLevels: string[];
  educationLevels: string[];
  occupations: string[];
  maritalStatuses: string[];
  availabilityStatuses: AvailabilityStatus[];
}

// הגדרת מצב הממשק של הפילטרים
export interface FilterUIState {
  isOpen: boolean;
  activeCategory?: string;
  showSaveDialog: boolean;
  presetName: string;
}

// הגדרה של אירועי שינוי בפילטרים
export type FilterChangeHandler = (filters: FilterState) => void;

// הגדרת אירועי שמירת פילטר
export interface SaveFilterHandler {
  (name: string, filters: FilterState): Promise<SavedFilter>;
}

// הגדרת אירועי טעינת פילטר
export interface LoadFilterHandler {
  (id: string): void;
}

// הגדרת הגדרות הפילטרים
export interface FilterSettings {
  localStorageKey?: string;
  defaultFilters?: Partial<FilterState>;
  onFilterChange?: FilterChangeHandler;
}

// הגדרת תוצאות הפילטר
export interface FilterResults {
  totalResults: number;
  filteredResults: number;
  categories: Record<string, number>;
}

// קונסטנטות של הפילטרים
export const DEFAULT_FILTER_STATE: FilterState = {
  separateFiltering: false,
  maleFilters: {},
  femaleFilters: {},
  maleSearchQuery: '',
  femaleSearchQuery: '',
  gender: undefined,
  ageRange: { min: 18, max: 99 },
  heightRange: { min: 140, max: 210 },
  cities: [],
  occupations: [],
  religiousLevel: undefined,
  educationLevel: undefined,
  maritalStatus: undefined,
  availabilityStatus: undefined,
  userStatus: undefined,
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined,
  isProfileComplete: undefined,
  searchQuery: '',
  savedFilterId: undefined
};

// קטגוריות פילטרים מוגדרות מראש
export const FILTER_CATEGORIES: FilterCategory[] = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'educationLevel', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availabilityStatus', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];

// טיפוסי מיון
export type SortDirection = 'asc' | 'desc';

export interface SortOption {
  field: keyof FilterState;
  direction: SortDirection;
  label: string;
}

// הגדרות קיבוץ
export interface GroupOption {
  field: keyof FilterState;
  label: string;
}

export const filterConstants = {
  DEFAULT_FILTER_STATE,
  FILTER_CATEGORIES
};

export default filterConstants;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\utils\matchingAlgorithm.ts:
==================================================
import { AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

const matchingAlgorithm = {
  calculateMatchScore,
  findBestMatches
};

export default matchingAlgorithm;

==================================================
Contents of C:\Users\eytan\Desktop\שידוכים\shidduch-system\src\app\components\matchmaker\new\utils\statisticsCalculator.ts:
==================================================
// /utils/statisticsCalculator.ts
import type { Candidate } from '../types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const  stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.referenceName1 || candidate.profile.referenceName2) stats.hasReferences++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      (candidate.profile.referenceName1 || candidate.profile.referenceName2) &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

const statisticsCalculator = {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

export default statisticsCalculator;
