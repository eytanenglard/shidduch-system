################################################################################
# Directory Content Map For: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components
# Generated on: 2025-06-18 18:37:27
################################################################################

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\components_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ConsentCheckbox.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/ConsentCheckbox.tsx
"use client";

import React from "react";
import Link from "next/link";

interface ConsentCheckboxProps {
  checked: boolean;
  onChange: (isChecked: boolean) => void;
  error?: string | null;
}

const ConsentCheckbox: React.FC<ConsentCheckboxProps> = ({
  checked,
  onChange,
  error,
}) => {
  return (
    <div className="space-y-2">
      <div className="flex items-start space-x-2 rtl:space-x-reverse">
        <input
          type="checkbox"
          id="termsConsent"
          checked={checked}
          onChange={(e) => onChange(e.target.checked)}
          className={`mt-1 h-4 w-4 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500 ${
            error ? "border-red-500" : ""
          }`}
        />
        <label htmlFor="termsConsent" className="text-sm text-gray-700">
          קראתי ואני מאשר/ת את{" "}
          <Link
            href="/legal/terms-of-service"
            target="_blank"
            className="font-medium text-cyan-600 hover:text-cyan-700 underline"
          >
            תנאי השימוש
          </Link>{" "}
          ואת{" "}
          <Link
            href="/legal/privacy-policy"
            target="_blank"
            className="font-medium text-cyan-600 hover:text-cyan-700 underline"
          >
            מדיניות הפרטיות
          </Link>{" "}
          של Matchpoint, ומסכים/ה לאיסוף, עיבוד ושמירת המידע האישי שלי, לרבות
          מידע רגיש, בהתאם למפורט בהם, ולהעברת המידע שלי לשרתים שעשויים להיות
          ממוקמים מחוץ לגבולות ישראל.
        </label>
      </div>
      {error && <p className="text-xs text-red-500">{error}</p>}
    </div>
  );
};

export default ConsentCheckbox;
--- End of Content for ConsentCheckbox.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ForgotPasswordForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/ForgotPasswordForm.tsx
"use client";

import { useState, FormEvent } from "react";
import { useRouter } from "next/navigation"; // <--- 1. Import useRouter
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Mail, Loader2, AlertCircle } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import Link from "next/link";

export default function ForgotPasswordForm() {
  const router = useRouter(); // <--- 2. Initialize router
  const [email, setEmail] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // The success message might not be seen if we redirect immediately.
  // Consider removing it or using a toast notification system for a brief message before redirect.
  // const [successMessage, setSuccessMessage] = useState<string | null>(null);

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    // setSuccessMessage(null); // If redirecting, this isn't needed

    if (!email) {
      setError("אנא הזן את כתובת המייל שלך.");
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch("/api/auth/request-password-reset", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email }),
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || "אירעה שגיאה בבקשת איפוס הסיסמה.");
      }

      // 3. Redirect to the reset password page on success
      // The API's success message (data.message) is generic for security and won't be shown here.
      // The ResetPasswordForm will guide the user.
      router.push(`/auth/reset-password?email=${encodeURIComponent(email)}`);
      
      // setEmail(""); // Clearing email is not strictly necessary as we are navigating away

    } catch (err) {
      setError(err instanceof Error ? err.message : "אירעה שגיאה לא צפויה.");
      setIsLoading(false); // Ensure isLoading is set to false in case of an error before navigation
    }
    // setIsLoading(false); // If navigation occurs, this line might not be reached or necessary.
                         // It's important that isLoading is false if an error occurs and we don't navigate.
  };

  return (
    <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
      <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>
      <div className="p-6 sm:p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold text-gray-800 mb-2">
            שכחת סיסמה?
          </h1>
          <p className="text-gray-600 text-sm">
            אין בעיה! הזן את כתובת המייל שלך למטה, ואם היא קיימת במערכת, נשלח לך קוד לאיפוס הסיסמה.
          </p>
        </div>

        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Success message is removed because we are redirecting. 
            If you want to show a message on the next page, 
            you could pass a query param like ?request_sent=true
        */}
        {/*
        {successMessage && (
          <Alert variant="default" className="mb-4 bg-green-50 border-green-200 text-green-700">
            <CheckCircle className="h-4 w-4 text-green-600" />
            <AlertTitle>הבקשה נשלחה</AlertTitle>
            <AlertDescription>{successMessage}</AlertDescription>
          </Alert>
        )}
        */}
        
        {/* Form is always shown unless you conditionally hide it during loading/after success,
            but since we redirect, this logic can be simpler.
        */}
        {/* {!successMessage && ( // This condition can be removed if successMessage state is removed */}
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-1">
              <label htmlFor="email-forgot" className="block text-sm font-medium text-gray-700">
                כתובת מייל
              </label>
              <div className="relative">
                <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type="email"
                  id="email-forgot"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="you@example.com"
                  required
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  disabled={isLoading}
                />
              </div>
            </div>

            <Button
              type="submit"
              disabled={isLoading}
              className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2"
            >
              {isLoading ? (
                <>
                  <Loader2 className="h-5 w-5 animate-spin mr-2" />
                  <span>שולח...</span>
                </>
              ) : (
                "שלח בקשה לאיפוס סיסמה" // Changed text slightly
              )}
            </Button>
          </form>
        {/* )} */}

        <div className="mt-6 text-center">
          <Link
            href="/auth/signin"
            className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline"
          >
            חזרה להתחברות
          </Link>
        </div>
      </div>
    </div>
  );
}
--- End of Content for ForgotPasswordForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ProgressBar.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { motion } from "framer-motion";

interface ProgressBarProps {
  currentStep: number;
  totalSteps: number;
}

const ProgressBar: React.FC<ProgressBarProps> = ({
  currentStep,
  totalSteps,
}) => {
  // Calculate percentage
  const percentage = (currentStep / totalSteps) * 100;

  // Generate step markers
  const steps = Array.from({ length: totalSteps }, (_, i) => i + 1);

  return (
    <div className="w-full relative">
      {/* Step labels */}
      <div className="flex justify-between mb-2">
        {steps.map((step) => (
          <div
            key={step}
            className={`text-xs font-medium transition-colors duration-300 ${
              step <= currentStep ? "text-gray-800" : "text-gray-400"
            }`}
          >
            שלב {step}
          </div>
        ))}
      </div>

      {/* Progress bar track */}
      <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
        {/* Animated progress fill */}
        <motion.div
          className="h-full bg-gradient-to-r from-cyan-500 to-pink-500"
          initial={{ width: `${((currentStep - 1) / totalSteps) * 100}%` }}
          animate={{ width: `${percentage}%` }}
          transition={{ duration: 0.5, ease: "easeInOut" }}
        />
      </div>

      {/* Step markers */}
      <div className="relative flex justify-between mt-1">
        {steps.map((step) => (
          <motion.div
            key={step}
            className={`w-6 h-6 rounded-full flex items-center justify-center -mt-4 z-10 transition-all duration-300
              ${
                step <= currentStep
                  ? "bg-gradient-to-r from-cyan-500 to-pink-500 shadow-md text-white"
                  : "bg-white border-2 border-gray-300 text-gray-500"
              }`}
            initial={{ scale: step === currentStep ? 0.8 : 1 }}
            animate={{ scale: step === currentStep ? 1.1 : 1 }}
            transition={{ duration: 0.3 }}
          >
            <span className="text-xs font-semibold">{step}</span>
          </motion.div>
        ))}
      </div>
    </div>
  );
};

export default ProgressBar;
--- End of Content for ProgressBar.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\RegisterForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/RegisterForm.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Gender } from "@prisma/client";
import { signIn } from "next-auth/react";
import ConsentCheckbox from "./ConsentCheckbox"; // <-- ייבוא הקומפוננטה
import { Button } from "@/components/ui/button"; // אם אתה משתמש בכפתור משותף
import { Loader2 } from "lucide-react"; // לאייקון טעינה

interface RegistrationFormData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  phone: string;
  gender: Gender;
  birthDate: string;
  maritalStatus?: string;
  height?: number;
  occupation?: string;
  education?: string;
}

export default function RegisterForm() {
  const router = useRouter();
  const [error, setError] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);
  const [password, setPassword] = useState("");
  const [passwordError, setPasswordError] = useState("");

  // --- הוספת State עבור תיבת ההסכמה ---
  const [consentChecked, setConsentChecked] = useState(false);
  const [consentError, setConsentError] = useState<string | null>(null);

  const validatePassword = (value: string) => {
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(value)) {
      setPasswordError(
        "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר"
      );
      return false;
    }
    setPasswordError("");
    return true;
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");
    setConsentError(null); // איפוס שגיאת הסכמה

    if (!consentChecked) {
      setConsentError("חובה לאשר את תנאי השימוש ומדיניות הפרטיות.");
      setIsLoading(false);
      return;
    }

    if (!validatePassword(password)) {
      setIsLoading(false);
      return;
    }

    const formData = new FormData(e.currentTarget);
    const data: RegistrationFormData = {
      email: formData.get("email") as string,
      password: password,
      firstName: formData.get("firstName") as string,
      lastName: formData.get("lastName") as string,
      phone: formData.get("phone") as string,
      gender: formData.get("gender") as Gender,
      birthDate: formData.get("birthDate") as string,
      maritalStatus: formData.get("maritalStatus") as string,
      height: formData.get("height")
        ? Number(formData.get("height"))
        : undefined,
      occupation: formData.get("occupation") as string,
      education: formData.get("education") as string,
    };

    try {
      // כאן, ה-API /api/auth/register אמור לשמור את termsAndPrivacyAcceptedAt: new Date()
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "אירעה שגיאה בהרשמה");
      }

      router.push(`/auth/verify-email?email=${encodeURIComponent(data.email)}`);
    } catch (error) {
      setError(error instanceof Error ? error.message : "אירעה שגיאה בהרשמה");
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    // ההנחה היא שאם המשתמש נרשם עם גוגל דרך הטופס הזה,
    // הוא יועבר לתהליך RegisterSteps, שם יתבקש לאשר תנאים אם נדרש.
    try {
      setIsGoogleLoading(true);
      setError("");
      await signIn("google"); // NextAuth יטפל בהפניה
    } catch (error) {
      console.error("Google sign-in error:", error);
      setError("אירעה שגיאה בהתחברות עם גוגל");
      setIsGoogleLoading(false);
    }
  };

  const isSubmitDisabled = isLoading || !!passwordError || !consentChecked;


  return (
    <div className="space-y-6 max-w-sm mx-auto p-6 bg-white shadow-lg rounded-lg">
      <h2 className="text-2xl font-semibold text-center text-gray-800">הרשמה</h2>
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* ... כל שדות הטופס הקיימים ... */}
        {/* שם פרטי */}
        <div>
          <label htmlFor="firstNameRegForm" className="block text-sm font-medium text-gray-700">שם פרטי</label>
          <input type="text" name="firstName" id="firstNameRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* שם משפחה */}
        <div>
          <label htmlFor="lastNameRegForm" className="block text-sm font-medium text-gray-700">שם משפחה</label>
          <input type="text" name="lastName" id="lastNameRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* אימייל */}
        <div>
          <label htmlFor="emailRegForm" className="block text-sm font-medium text-gray-700">אימייל</label>
          <input type="email" name="email" id="emailRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* טלפון */}
        <div>
          <label htmlFor="phoneRegForm" className="block text-sm font-medium text-gray-700">טלפון נייד</label>
          <input type="tel" name="phone" id="phoneRegForm" required pattern="[0-9]{10}" placeholder="" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* סיסמה */}
        <div>
          <label htmlFor="passwordRegForm" className="block text-sm font-medium text-gray-700">סיסמה</label>
          <input
            type="password"
            name="password" // חשוב שה-name יהיה "password" כדי ש-validatePassword יעבוד עם הערך מה-state. או שנה את validatePassword לקבל את הערך ישירות.
            id="passwordRegForm"
            required
            value={password}
            onChange={(e) => {
              setPassword(e.target.value);
              validatePassword(e.target.value);
            }}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2"
          />
          <p className="mt-1 text-sm text-gray-500">
            הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה באנגלית, אות קטנה באנגלית ומספר.
          </p>
          {passwordError && (
            <div className="text-red-500 text-sm mt-1">{passwordError}</div>
          )}
        </div>
        {/* מגדר */}
        <div>
          <label htmlFor="genderRegForm" className="block text-sm font-medium text-gray-700">מגדר</label>
          <select name="gender" id="genderRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
            <option value="">בחר מגדר</option>
            <option value="MALE">זכר</option>
            <option value="FEMALE">נקבה</option>
          </select>
        </div>
        {/* תאריך לידה */}
        <div>
          <label htmlFor="birthDateRegForm" className="block text-sm font-medium text-gray-700">תאריך לידה</label>
          <input type="date" name="birthDate" id="birthDateRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* מצב משפחתי */}
        <div>
          <label htmlFor="maritalStatusRegForm" className="block text-sm font-medium text-gray-700">מצב משפחתי</label>
          <select name="maritalStatus" id="maritalStatusRegForm" required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
            <option value="">בחר מצב משפחתי</option>
            <option value="רווק/ה">רווק/ה</option>
            <option value="גרוש/ה">גרוש/ה</option>
            <option value="אלמן/ה">אלמן/ה</option>
          </select>
        </div>
        {/* גובה */}
        <div>
          <label htmlFor="heightRegForm" className="block text-sm font-medium text-gray-700">גובה (בסמ)</label>
          <input type="number" name="height" id="heightRegForm" min="120" max="220" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* עיסוק */}
        <div>
          <label htmlFor="occupationRegForm" className="block text-sm font-medium text-gray-700">עיסוק</label>
          <input type="text" name="occupation" id="occupationRegForm" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>
        {/* השכלה */}
        <div>
          <label htmlFor="educationRegForm" className="block text-sm font-medium text-gray-700">השכלה</label>
          <input type="text" name="education" id="educationRegForm" className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2" />
        </div>


        {/* --- הוספת תיבת ההסכמה --- */}
        <div className="pt-4">
          <ConsentCheckbox
            checked={consentChecked}
            onChange={(isChecked) => {
              setConsentChecked(isChecked);
              if (isChecked) setConsentError(null);
            }}
            error={consentError}
          />
        </div>

        {error && <div className="text-red-500 text-sm mt-2">{error}</div>}

        <Button
          type="submit"
          disabled={isSubmitDisabled}
          className="w-full flex justify-center py-2.5 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gradient-to-r from-cyan-600 to-pink-600 hover:from-cyan-700 hover:to-pink-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
        >
          {isLoading ? (
            <div className="flex items-center">
              <Loader2 className="animate-spin h-5 w-5 mr-2" />
              נרשם...
            </div>
          ) : (
            "הרשמה"
          )}
        </Button>
      </form>

      <div className="relative my-6">
        <div className="absolute inset-0 flex items-center">
          <div className="w-full border-t border-gray-300" />
        </div>
        <div className="relative flex justify-center text-sm">
          <span className="px-2 bg-white text-gray-500">או</span>
        </div>
      </div>

      <Button
        type="button"
        onClick={handleGoogleSignIn}
        disabled={isGoogleLoading}
        variant="outline"
        className="w-full flex justify-center items-center py-2.5 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
      >
        {isGoogleLoading ? (
          <div className="flex items-center">
            <Loader2 className="animate-spin h-5 w-5 mr-2" />
            <span>מתחבר...</span>
          </div>
        ) : (
          <>
            <svg className="h-5 w-5 mr-2" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
              <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
              <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
              <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
            </svg>
            הרשמה עם גוגל
          </>
        )}
      </Button>
    </div>
  );
}
--- End of Content for RegisterForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\RegisterSteps.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/RegisterSteps.tsx
"use client";

import React, { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useSession } from "next-auth/react";
import { RegistrationProvider, useRegistration } from "./RegistrationContext"; // ודא ש-RegistrationData מיובא
import WelcomeStep from "./steps/WelcomeStep";
import BasicInfoStep from "./steps/BasicInfoStep";
import EmailVerificationCodeStep from "./steps/EmailVerificationCodeStep";
import PersonalDetailsStep from "./steps/PersonalDetailsStep";
import OptionalInfoStep from "./steps/OptionalInfoStep";
import CompleteStep from "./steps/CompleteStep";
import ProgressBar from "./ProgressBar";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { ArrowRight, Info, Loader2 } from "lucide-react";
import type { User as SessionUserType } from "@/types/next-auth";

const RegisterStepsContent: React.FC = () => {
  const {
    data: registrationContextData,
    initializeFromSession,
    resetForm,
    goToStep,
  } = useRegistration();
  const router = useRouter();
  const { data: session, status: sessionStatus } = useSession();
  const searchParams = useSearchParams();

  const [showIncompleteProfileMessage, setShowIncompleteProfileMessage] = useState(false);
  const [initializationAttempted, setInitializationAttempted] = useState(false);

  // הדפסה ראשונית של מצב הקומפוננטה בעת טעינה/עדכון
  console.log(
    "[RegisterStepsContent RENDER] Initial State Check:",
    {
      sessionStatus,
      sessionUserExists: !!session?.user,
      registrationContextData_step: registrationContextData.step,
      registrationContextData_isCompletingProfile: registrationContextData.isCompletingProfile,
      registrationContextData_isVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
      initializationAttempted,
      searchParams: searchParams.toString(),
    }
  );


  useEffect(() => {
    const reasonParam = searchParams.get("reason");
    if (reasonParam === "complete_profile" && !registrationContextData.isCompletingProfile) {
      setShowIncompleteProfileMessage(true);
    } else if (reasonParam === "verify_phone" && !registrationContextData.isCompletingProfile) {
      setShowIncompleteProfileMessage(true);
    } else {
      setShowIncompleteProfileMessage(false);
    }
  }, [searchParams, registrationContextData.isCompletingProfile]);

  useEffect(() => {
    console.log(
      "[RegisterStepsContent useEffect Trigger] Current State:", {
        sessionStatus,
        sessionUserExists: !!session?.user,
        contextStep: registrationContextData.step,
        contextIsCompletingProfile: registrationContextData.isCompletingProfile,
        contextIsVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
        initializationAttempted,
      }
    );

    if (sessionStatus === "loading") {
      console.log("[RegisterStepsContent useEffect] Session loading, returning.");
      return;
    }

    if (sessionStatus === "authenticated" && session?.user) {
      const user = session.user as SessionUserType;
      console.log("[RegisterStepsContent useEffect] AUTHENTICATED. User data from session:", user);

      if (user.isProfileComplete && user.isPhoneVerified && user.termsAndPrivacyAcceptedAt) {
        console.log("[RegisterStepsContent useEffect] User fully set up. Redirecting to /profile.");
        if (typeof window !== 'undefined' && window.location.pathname !== "/profile") {
             router.push("/profile");
        }
        return;
      }

      const needsSetup = !user.termsAndPrivacyAcceptedAt || !user.isProfileComplete || !user.isPhoneVerified;
      console.log("[RegisterStepsContent useEffect] User needsSetup:", needsSetup);

      if (needsSetup) {
        if (!initializationAttempted || (registrationContextData.step === 0 && !registrationContextData.isVerifyingEmailCode)) {
          console.log("[RegisterStepsContent useEffect] AUTHENTICATED & needs setup. Initializing context from session.");
          initializeFromSession(user);
          setInitializationAttempted(true);
          // הפונקציה initializeFromSession תגרום לעדכון הקונטקסט, מה שיפעיל מחדש את ה-useEffect.
          // הלוגיקה תמשיך משם עם הקונטקסט המעודכן.
          return;
        } else {
          console.log("[RegisterStepsContent useEffect] AUTHENTICATED & needs setup, but initialization already attempted or context not in initial state. Context should be guiding the flow now.");
        }
      } else {
        console.warn("[RegisterStepsContent useEffect] AUTHENTICATED & fully setup, but somehow not redirected yet. Forcing redirect to /profile.");
        if (typeof window !== 'undefined' && window.location.pathname !== "/profile") {
            router.push("/profile");
        }
        return;
      }

    } else if (sessionStatus === "unauthenticated") {
      console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED. Context state:", {
        step: registrationContextData.step,
        isCompletingProfile: registrationContextData.isCompletingProfile,
        isVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
      });
      setInitializationAttempted(false); // אפס ניסיון אתחול עבור התחברות עתידית
      let shouldReset = false;
      let resetReason = "";

      // קריטי: בדוק אם אנחנו במצב שבו אנו *מצפים* שהאימות יתרחש בקרוב.
      // זה נכון אם הרגע סיימנו אימות מייל והקונטקסט משקף זאת.
      const justFinishedEmailVerificationAndContextIsReadyForProfileCompletion =
        registrationContextData.isCompletingProfile && // הקונטקסט עבר למצב השלמת פרופיל
        registrationContextData.step === 2 &&         // השלב הבא הוא פרטים אישיים
        !registrationContextData.isVerifyingEmailCode; // לא בתהליך אימות קוד מייל

      if (justFinishedEmailVerificationAndContextIsReadyForProfileCompletion) {
        console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED, but context suggests email verification just completed and set for profile completion. Holding off on reset, expecting session to become 'authenticated' soon.");
        shouldReset = false; // אל תאפס, חכה שהסשן יתעדכן
      } else if (registrationContextData.isCompletingProfile) {
        // אם נמצאים בתהליך השלמת פרופיל (לא מיד אחרי אימות מייל) והסשן אבד.
        shouldReset = true;
        resetReason = "Unauthenticated while in 'isCompletingProfile' mode (not immediately after email verification).";
      } else if (registrationContextData.isVerifyingEmailCode) {
        // זהו מצב תקין למשתמש חדש שאינו מאומת ונמצא בתהליך אימות קוד מייל.
        shouldReset = false;
        console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED, but actively verifying email code. No reset needed.");
      } else if (registrationContextData.step > 1) {
        // בתהליך הרשמה חדש (לא isCompletingProfile), עבר את שלב BasicInfo (שלב 1), לא מאמת קוד מייל, והפך ללא מאומת.
        shouldReset = true;
        resetReason = "Unauthenticated in new registration flow, past BasicInfo (step > 1), and not verifying email code.";
      } else if (registrationContextData.step <= 1 && registrationContextData.step >= 0) {
        // ב-Welcome (שלב 0) או BasicInfo (שלב 1) עבור הרשמה חדשה, ומצב לא מאומת הוא צפוי.
        shouldReset = false;
        console.log("[RegisterStepsContent useEffect] UNAUTHENTICATED, on Welcome/BasicInfo step for new registration. This is normal, no reset needed.");
      }


      if (shouldReset) {
        console.warn(`[RegisterStepsContent useEffect] UNAUTHENTICATED. Resetting form. Reason: ${resetReason}`);
        resetForm();
      }
    }
  }, [
    sessionStatus,
    session, // תלות בסשן עצמו (לא רק בסטטוס)
    router,
    registrationContextData,
    initializeFromSession,
    resetForm,
    goToStep,
    initializationAttempted,
    searchParams, // הוספנו כתלות כי הוא משפיע על הודעת הפרופיל הלא שלם
  ]);

  const renderStep = (): React.ReactNode => {
    console.log("[RegisterStepsContent renderStep] Determining step. Context:", {
        step: registrationContextData.step,
        isCompletingProfile: registrationContextData.isCompletingProfile,
        isVerifyingEmailCode: registrationContextData.isVerifyingEmailCode,
        emailForVerification: registrationContextData.emailForVerification,
      },
      "Session Status:", sessionStatus
    );

    if (sessionStatus === "loading") {
      console.log("[RegisterStepsContent renderStep] Session loading, showing loader.");
      return <div className="flex justify-center p-10"><Loader2 className="h-8 w-8 animate-spin text-cyan-600" /></div>;
    }

    const userFromSession = session?.user as SessionUserType | undefined;
    if (
      sessionStatus === "authenticated" && userFromSession && !initializationAttempted &&
      (!userFromSession.termsAndPrivacyAcceptedAt || !userFromSession.isProfileComplete || !userFromSession.isPhoneVerified) &&
      registrationContextData.step === 0 &&
      !registrationContextData.isVerifyingEmailCode
    ) {
        console.log("[RegisterStepsContent renderStep] Authenticated but initialization not attempted and context is at step 0. Showing 'preparing' loader.");
        return <div className="flex justify-center p-10"><Loader2 className="h-8 w-8 animate-spin text-cyan-600" /><p className="ml-2">מכין תהליך הרשמה...</p></div>;
    }


    // אימות מייל למשתמשים חדשים עם אימייל/סיסמה
    if (registrationContextData.isVerifyingEmailCode && !registrationContextData.isCompletingProfile) {
      console.log("[RegisterStepsContent renderStep] Rendering EmailVerificationCodeStep.");
      return <EmailVerificationCodeStep />;
    }

    // תהליך השלמת פרופיל (isCompletingProfile הוא true)
    // זה כולל משתמשי גוגל שצריכים השלמה, משתמשי אימייל/סיסמה אחרי אימות מייל,
    // או משתמשים שחזרו להשלים פרופיל/טלפון.
    // ההסכמה מטופלת כעת בתוך PersonalDetailsStep אם נדרש.
    if (registrationContextData.isCompletingProfile) {
      console.log("[RegisterStepsContent renderStep] In 'isCompletingProfile' mode. Current step:", registrationContextData.step);
      switch (registrationContextData.step) {
        case 2:
          console.log("[RegisterStepsContent renderStep] Rendering PersonalDetailsStep for profile completion.");
          return <PersonalDetailsStep />;
        case 3:
          console.log("[RegisterStepsContent renderStep] Rendering OptionalInfoStep for profile completion.");
          return <OptionalInfoStep />;
        case 4:
          console.log("[RegisterStepsContent renderStep] Rendering CompleteStep for profile completion.");
          return <CompleteStep />;
        default:
          console.warn(`[RegisterStepsContent renderStep] (Profile Completion Flow) Unexpected step ${registrationContextData.step}. Session:`, session?.user);
          // ניסיון התאוששות אם המצב לא תקין
          if (session?.user) { // רק אם יש סשן, אחרת זה עלול לגרום ללולאה עם הלוגיקה ב-useEffect
            if (!initializationAttempted) {
                console.log("[RegisterStepsContent renderStep] (Profile Completion Flow) Default case - user exists, re-initializing from session.");
                initializeFromSession(session.user as SessionUserType);
                setInitializationAttempted(true); // סמן שניסית לאתחל
                return <Loader2 className="h-8 w-8 animate-spin text-cyan-600 mx-auto my-10" />;
            } else if (registrationContextData.step < 2 || registrationContextData.step > 4) {
                // אם כבר ניסינו אתחול, והשלב עדיין לא תקין (לא 2,3,4), נסה לנתב לשלב ההתחלה של השלמת פרופיל
                console.log(`[RegisterStepsContent renderStep] (Profile Completion Flow) Default case - user exists, init attempted, step ${registrationContextData.step} invalid. Going to step 2.`);
                if(goToStep) goToStep(2); // ודא ש-goToStep מוגדר לפני הקריאה
                return <Loader2 className="h-8 w-8 animate-spin text-cyan-600 mx-auto my-10" />;
            }
          }
          // אם אין סשן או שההתאוששות לא עבדה, אולי כדאי לאפס
          console.log("[RegisterStepsContent renderStep] (Profile Completion Flow) Default case - cannot recover, resetting form and showing WelcomeStep.");
          resetForm();
          return <WelcomeStep />;
      }
    }

    // תהליך הרשמה חדש רגיל
    console.log("[RegisterStepsContent renderStep] In new registration flow. Current step:", registrationContextData.step);
    switch (registrationContextData.step) {
      case 0:
        console.log("[RegisterStepsContent renderStep] Rendering WelcomeStep.");
        return <WelcomeStep />;
      case 1:
        console.log("[RegisterStepsContent renderStep] Rendering BasicInfoStep.");
        return <BasicInfoStep />;
      // שלבים 2,3,4 עבור הרשמה חדשה קורים אחרי אימות מייל,
      // שם isCompletingProfile הופך ל-true והלוגיקה למעלה תופסת.
      default:
        console.warn(`[RegisterStepsContent renderStep] (New Registration Flow) Unexpected step ${registrationContextData.step}.`);
        // אם יש סשן והוא לא מוגדר במלואו, נסה לאתחל
        if (session?.user && (!session.user.isProfileComplete || !session.user.isPhoneVerified || !session.user.termsAndPrivacyAcceptedAt)) {
          if (!initializationAttempted) {
            console.log("[RegisterStepsContent renderStep] (New Registration Flow) Default case - user exists and needs setup, re-initializing from session.");
            initializeFromSession(session.user as SessionUserType);
            setInitializationAttempted(true);
            return <Loader2 className="h-8 w-8 animate-spin text-cyan-600 mx-auto my-10" />;
          }
        }
        // אם אין סשן או שהאתחול לא נדרש/עזר, אפס והצג את שלב הפתיחה
        console.log("[RegisterStepsContent renderStep] (New Registration Flow) Default case - resetting form and showing WelcomeStep.");
        resetForm();
        return <WelcomeStep />;
    }
  };

  const stepContent = renderStep();

  // --- לוגיקת כותרות וסרגל התקדמות (נשארה כפי שהייתה, אך מומלץ לבדוק אותה היטב בהקשר לשינויים) ---
  let pageTitle = "הרשמה למערכת";
  let stepDescription = "ברוכים הבאים! בואו נתחיל.";
  let currentProgressBarStep = 0;
  let totalProgressBarSteps = 3;
  let showProgressBar = false;

  if (registrationContextData.isVerifyingEmailCode && !registrationContextData.isCompletingProfile) {
    pageTitle = "אימות כתובת מייל";
    stepDescription = `הזן את הקוד שנשלח ל: ${registrationContextData.emailForVerification || registrationContextData.email}.`;
    showProgressBar = true;
    currentProgressBarStep = 1;
  } else if (registrationContextData.isCompletingProfile) {
    pageTitle = "השלמת פרטים";
    totalProgressBarSteps = 2; // פרטים אישיים (1), אופציונלי (2)
    if (registrationContextData.step === 2) { // PersonalDetails
      stepDescription = session?.user?.termsAndPrivacyAcceptedAt
        ? "שלב 1 מתוך 2: פרטים אישיים."
        : "שלב 1: אישור תנאים ופרטים אישיים.";
      currentProgressBarStep = 1;
      showProgressBar = true;
    } else if (registrationContextData.step === 3) { // OptionalInfo
      stepDescription = "שלב 2 מתוך 2: מידע נוסף (מומלץ).";
      currentProgressBarStep = 2;
      showProgressBar = true;
    } else if (registrationContextData.step === 4) { // CompleteStep
      stepDescription = session?.user?.isPhoneVerified
        ? "הפרופיל שלך מוכן!"
        : "הפרטים הושלמו! השלב הבא: אימות טלפון.";
      showProgressBar = false; // בדרך כלל אין סרגל התקדמות במסך הסיום
    } else {
      // למקרה שהשלב הוא לא 2, 3, או 4 במצב השלמת פרופיל (למשל, אם נתקע על 0 או 1)
      stepDescription = "טוען שלב השלמת פרופיל...";
      showProgressBar = registrationContextData.step > 1 && registrationContextData.step < 4; // הצג רק אם בשלבי מילוי פעילים
    }
  } else { // הרשמה חדשה (לא מאמתים מייל על המסך, לא משלימים פרופיל עדיין)
    if (registrationContextData.step === 0) { // Welcome
      pageTitle = "ברוכים הבאים";
      stepDescription = "בואו נתחיל את המסע יחד.";
      showProgressBar = false;
    } else if (registrationContextData.step === 1) { // BasicInfo
      pageTitle = "יצירת חשבון";
      stepDescription = "שלב 1 מתוך 3: אישור תנאים ופרטי התחברות.";
      currentProgressBarStep = 1;
      totalProgressBarSteps = 3; // בסיסי (כולל הסכמה), אישי, אופציונלי (אחרי אימות מייל)
      showProgressBar = true;
    }
  }
  // --- סוף לוגיקת כותרות וסרגל התקדמות ---

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-cyan-50 via-white to-pink-50 p-4 sm:p-8">
      <button
        onClick={() => router.push("/")}
        className="absolute top-4 left-4 rtl:right-4 rtl:left-auto text-gray-600 hover:text-gray-800 transition-colors flex items-center gap-1 text-sm z-20"
      >
        <ArrowRight className="h-4 w-4" />
        חזרה לדף הבית
      </button>

      <div className="mb-6 text-center">
        <h1 className="text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-pink-500 text-3xl font-bold mb-2">
          {pageTitle}
        </h1>
        <p className="text-gray-600 max-w-md mx-auto">{stepDescription}</p>
      </div>

      {showIncompleteProfileMessage && (
         <Alert className="mb-6 w-full max-w-md bg-yellow-50 border-yellow-200 text-yellow-800 shadow-md">
           <Info className="h-5 w-5 text-yellow-600 flex-shrink-0 mt-1" />
           <div className="ml-3 rtl:mr-3 rtl:ml-0">
             <AlertTitle className="font-semibold mb-1">
               נדרשת פעולה להשלמת החשבון
             </AlertTitle>
             <AlertDescription className="text-sm">
               {searchParams.get("reason") === "verify_phone"
                 ? "הפרופיל שלך כמעט מוכן! נדרש אימות טלפון כדי להמשיך."
                 : "כדי לגשת לאזור האישי ולשאר חלקי האתר, יש להשלים תחילה את פרטי הפרופיל ואימותים נדרשים."}
             </AlertDescription>
           </div>
         </Alert>
       )}

      {showProgressBar && (
        <div className="w-full max-w-md mb-6">
          <ProgressBar
            currentStep={currentProgressBarStep}
            totalSteps={totalProgressBarSteps}
          />
        </div>
      )}

      <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
        {!(
          (registrationContextData.step === 0 && !registrationContextData.isCompletingProfile) || // WelcomeStep
          registrationContextData.step === 4 // CompleteStep
        ) && (
          <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>
        )}
        <div className="p-6 sm:p-8">{stepContent}</div>
      </div>

      <div className="mt-8 text-center text-sm text-gray-500">
        יש לך שאלות?{" "}
        <a href="/contact" className="text-cyan-600 hover:underline">
          צור קשר
        </a>
      </div>
    </div>
  );
};

export default function RegisterSteps() {
  return (
    <RegistrationProvider>
      <RegisterStepsContent />
    </RegistrationProvider>
  );
}
--- End of Content for RegisterSteps.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\RegistrationContext.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/RegistrationContext.tsx
"use client";

import React, {
  createContext,
  useContext,
  useState,
  ReactNode,
  useCallback,
} from "react";
import { Gender, UserStatus, UserSource } from "@prisma/client";
import type { User as SessionUserType } from "@/types/next-auth";

export interface RegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  phone: string;
  gender: Gender | ""; // "" for unselected, or actual Gender enum value
  birthDate: string;
  maritalStatus: string;
  height?: number;
  occupation?: string;
  education?: string;
  step: number;
  isGoogleSignup: boolean;
  isCompletingProfile: boolean;
  isVerifyingEmailCode: boolean;
  emailForVerification: string | null;
}

const initialRegistrationData: RegistrationData = {
  email: "",
  password: "",
  firstName: "",
  lastName: "",
  phone: "",
  gender: "", // Initialized as empty string
  birthDate: "",
  maritalStatus: "",
  height: undefined,
  occupation: "",
  education: "",
  step: 0,
  isGoogleSignup: false,
  isCompletingProfile: false,
  isVerifyingEmailCode: false,
  emailForVerification: null,
};

interface RegistrationContextType {
  data: RegistrationData;
  setData: React.Dispatch<React.SetStateAction<RegistrationData>>;
  updateField: <K extends keyof RegistrationData>(
    field: K,
    value: RegistrationData[K]
  ) => void;
  nextStep: () => void;
  prevStep: () => void;
  goToStep: (step: number) => void;
  resetForm: () => void;
  setGoogleSignup: (googleUserData: {
    email: string;
    firstName?: string;
    lastName?: string;
  }) => void;
  initializeFromSession: (sessionUser: SessionUserType) => void;
  proceedToEmailVerification: (email: string) => void;
  completeEmailVerification: () => void;
  exitEmailVerification: () => void;
}

const RegistrationContext = createContext<RegistrationContextType>({
  data: initialRegistrationData,
  setData: () => console.warn("RegistrationProvider not found"),
  updateField: () => console.warn("RegistrationProvider not found"),
  nextStep: () => console.warn("RegistrationProvider not found"),
  prevStep: () => console.warn("RegistrationProvider not found"),
  goToStep: () => console.warn("RegistrationProvider not found"),
  resetForm: () => console.warn("RegistrationProvider not found"),
  setGoogleSignup: () => console.warn("RegistrationProvider not found"),
  initializeFromSession: () => console.warn("RegistrationProvider not found"),
  proceedToEmailVerification: () => console.warn("RegistrationProvider not found"),
  completeEmailVerification: () => console.warn("RegistrationProvider not found"),
  exitEmailVerification: () => console.warn("RegistrationProvider not found"),
});

export const RegistrationProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [data, setData] = useState<RegistrationData>(initialRegistrationData);

  const updateField = useCallback(
    <K extends keyof RegistrationData>(
      field: K,
      value: RegistrationData[K]
    ) => {
      setData((prev) => ({ ...prev, [field]: value }));
    },
    []
  );

  const nextStep = useCallback(() => {
    setData((prev) => {
      if (prev.isVerifyingEmailCode) return prev;
      const currentMaxStep = 3;
      if (prev.step === 1 && !prev.isCompletingProfile && !prev.isGoogleSignup) return prev;
      if (prev.step < currentMaxStep) return { ...prev, step: prev.step + 1 };
      if (prev.step === currentMaxStep) return { ...prev, step: 4 };
      return prev;
    });
  }, []);

  const prevStep = useCallback(() => {
    setData((prev) => {
      if (prev.isVerifyingEmailCode) {
        return { ...prev, isVerifyingEmailCode: false, emailForVerification: null, step: 1 };
      }
      if (prev.step > 0) {
        if (prev.step === 4) return { ...prev, step: 3 };
        return { ...prev, step: prev.step - 1 };
      }
      return prev;
    });
  }, []);

  const goToStep = useCallback((stepNum: number) => {
    setData((prev) => ({
      ...prev,
      step: stepNum,
      isVerifyingEmailCode: false,
      emailForVerification: null,
    }));
  }, []);

  const resetForm = useCallback(() => {
    setData(initialRegistrationData);
  }, []);

  const setGoogleSignup = useCallback(
    (googleUserData: { email: string; firstName?: string; lastName?: string }) => {
      setData({
        ...initialRegistrationData,
        email: googleUserData.email,
        isGoogleSignup: true,
      });
    },
    []
  );

  const initializeFromSession = useCallback(
    (sessionUser: SessionUserType) => {
      setData((): RegistrationData => {
        const isGoogleAcc = !!(
          sessionUser.source === UserSource.REGISTRATION &&
          sessionUser.accounts?.some(acc => acc.provider === 'google')
        );

        // Explicitly define the type for gender from session
        const sessionGender: Gender | "" = sessionUser.profile?.gender || "";

        const baseStateFromSession = {
          email: sessionUser.email || "",
          firstName: sessionUser.firstName || "",
          lastName: sessionUser.lastName || "",
          phone: sessionUser.phone || "",
          gender: sessionGender, // Use the correctly typed sessionGender
          birthDate: sessionUser.profile?.birthDate
            ? new Date(sessionUser.profile.birthDate).toISOString().split("T")[0]
            : "",
          maritalStatus: sessionUser.profile?.maritalStatus || "",
          height: sessionUser.profile?.height ?? undefined,
          occupation: sessionUser.profile?.occupation || "",
          education: sessionUser.profile?.education || "",
        };

        if (
          sessionUser.status === UserStatus.PENDING_EMAIL_VERIFICATION &&
          !isGoogleAcc &&
          !sessionUser.isVerified
        ) {
          return {
            ...initialRegistrationData,
            ...baseStateFromSession,
            isVerifyingEmailCode: true,
            emailForVerification: sessionUser.email,
            step: 1,
            isCompletingProfile: false,
            isGoogleSignup: false,
          };
        }

        if (!sessionUser.isProfileComplete) {
          return {
            ...initialRegistrationData,
            ...baseStateFromSession,
            isCompletingProfile: true,
            isGoogleSignup: isGoogleAcc,
            step: 2,
            isVerifyingEmailCode: false,
          };
        }

        if (sessionUser.isProfileComplete && !sessionUser.isPhoneVerified) {
          return {
            ...initialRegistrationData,
            ...baseStateFromSession,
            isCompletingProfile: true,
            isGoogleSignup: isGoogleAcc,
            step: 4,
            isVerifyingEmailCode: false,
          };
        }
        
        return { 
            ...initialRegistrationData, 
            email: sessionUser.email || "",
            // Ensure all fields from RegistrationData are present
            firstName: sessionUser.firstName || initialRegistrationData.firstName,
            lastName: sessionUser.lastName || initialRegistrationData.lastName,
            phone: sessionUser.phone || initialRegistrationData.phone,
            gender: sessionGender, // Use typed gender
            birthDate: baseStateFromSession.birthDate || initialRegistrationData.birthDate,
            maritalStatus: baseStateFromSession.maritalStatus || initialRegistrationData.maritalStatus,
            height: baseStateFromSession.height ?? initialRegistrationData.height,
            occupation: baseStateFromSession.occupation || initialRegistrationData.occupation,
            education: baseStateFromSession.education || initialRegistrationData.education,
            isGoogleSignup: isGoogleAcc,
        };
      });
    },
    []
  );

  const proceedToEmailVerification = useCallback((emailToVerify: string) => {
    setData((prev) => ({
      ...prev,
      isVerifyingEmailCode: true,
      emailForVerification: emailToVerify,
    }));
  }, []);

  const completeEmailVerification = useCallback(() => {
    setData((prev) => ({
      ...prev,
      isVerifyingEmailCode: false,
      emailForVerification: null,
      isCompletingProfile: true,
      step: 2,
    }));
  }, []);

  const exitEmailVerification = useCallback(() => {
    setData((prev) => ({
      ...prev,
      isVerifyingEmailCode: false,
      emailForVerification: null,
      step: 1,
    }));
  }, []);

  const value: RegistrationContextType = {
    data,
    setData,
    updateField,
    nextStep,
    prevStep,
    goToStep,
    resetForm,
    setGoogleSignup,
    initializeFromSession,
    proceedToEmailVerification,
    completeEmailVerification,
    exitEmailVerification,
  };

  return (
    <RegistrationContext.Provider value={value}>
      {children}
    </RegistrationContext.Provider>
  );
};

export const useRegistration = (): RegistrationContextType => {
  const context = useContext(RegistrationContext);
  if (context === undefined || Object.keys(context).every(
      (key) =>
        typeof context[key as keyof RegistrationContextType] === "function" &&
        context[key as keyof RegistrationContextType]
          .toString()
          .includes("RegistrationProvider not found")
    )
  ) {
    throw new Error(
      "useRegistration must be used within a RegistrationProvider"
    );
  }
  return context;
};
--- End of Content for RegistrationContext.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\ResetPasswordForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/ResetPasswordForm.tsx
"use client";

import { useState, FormEvent, useEffect }
from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Lock, KeySquare, Loader2, AlertCircle, CheckCircle, Eye, EyeOff, Mail } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import Link from "next/link";

// Password validation function (similar to your RegisterForm)
const validatePassword = (value: string): string | null => {
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
  if (!passwordRegex.test(value)) {
    return "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר.";
  }
  return null;
};


export default function ResetPasswordForm() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [email, setEmail] = useState(""); // To prefill if passed, or keep empty
  const [otp, setOtp] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [passwordError, setPasswordError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);

  useEffect(() => {
    const emailFromQuery = searchParams.get("email");
    const tokenFromQuery = searchParams.get("token"); // If you decide to also prefill OTP via token

    if (emailFromQuery) {
      setEmail(emailFromQuery);
    }
    if (tokenFromQuery) { // This 'token' from query is the OTP
      setOtp(tokenFromQuery);
    }
  }, [searchParams]);


  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setPasswordError(null);
    setSuccessMessage(null);

    if (!email) {
        setError("כתובת המייל חסרה. אנא חזור להתחלה ונסה שנית.");
        setIsLoading(false);
        return;
    }
    if (!otp || otp.length !== 6 || !/^\d+$/.test(otp)) {
      setError("קוד האימות (OTP) חייב להיות בן 6 ספרות.");
      setIsLoading(false);
      return;
    }
    const passValidationError = validatePassword(newPassword);
    if (passValidationError) {
      setPasswordError(passValidationError);
      setIsLoading(false);
      return;
    }
    if (newPassword !== confirmPassword) {
      setError("הסיסמאות אינן תואמות.");
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch("/api/auth/reset-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, otp, newPassword }),
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || "אירעה שגיאה באיפוס הסיסמה.");
      }

      setSuccessMessage(data.message || "הסיסמה אופסה בהצלחה! כעת תוכל להתחבר עם הסיסמה החדשה.");
      // Clear fields on success
      setOtp("");
      setNewPassword("");
      setConfirmPassword("");
      // Optionally redirect after a delay or with a button
      setTimeout(() => {
        router.push("/auth/signin?reset=success");
      }, 3000);

    } catch (err) {
      setError(err instanceof Error ? err.message : "אירעה שגיאה לא צפויה.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
      <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>
      <div className="p-6 sm:p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold text-gray-800 mb-2">
            איפוס סיסמה
          </h1>
          <p className="text-gray-600 text-sm">
            הזן את קוד האימות (OTP) שקיבלת במייל ואת הסיסמה החדשה שלך.
          </p>
        </div>

        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
         {passwordError && !error && ( // Show passwordError only if general error is not present
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאת סיסמה</AlertTitle>
            <AlertDescription>{passwordError}</AlertDescription>
          </Alert>
        )}

        {successMessage && (
          <Alert variant="default" className="mb-4 bg-green-50 border-green-200 text-green-700">
            <CheckCircle className="h-4 w-4 text-green-600" />
            <AlertTitle>הצלחה!</AlertTitle>
            <AlertDescription>{successMessage} אתה מועבר לדף ההתחברות...</AlertDescription>
          </Alert>
        )}

        {!successMessage && ( // Only show form if no success message
          <form onSubmit={handleSubmit} className="space-y-5">
             <div className="space-y-1">
              <label htmlFor="email-reset" className="block text-sm font-medium text-gray-700">
                כתובת מייל (לאימות) <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type="email"
                  id="email-reset"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="you@example.com"
                  required
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  disabled={isLoading || !!searchParams.get("email")} // Disable if email came from query
                />
              </div>
            </div>
            <div className="space-y-1">
              <label htmlFor="otp-reset" className="block text-sm font-medium text-gray-700">
                קוד אימות (OTP) <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <KeySquare className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type="text"
                  id="otp-reset"
                  value={otp}
                  onChange={(e) => setOtp(e.target.value.replace(/[^0-9]/g, '').slice(0, 6))}
                  placeholder="xxxxxx"
                  maxLength={6}
                  required
                  className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none tracking-widest text-center"
                  disabled={isLoading}
                  inputMode="numeric"
                />
              </div>
            </div>

            <div className="space-y-1">
              <label htmlFor="new-password-reset" className="block text-sm font-medium text-gray-700">
                סיסמה חדשה <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type={showPassword ? "text" : "password"}
                  id="new-password-reset"
                  value={newPassword}
                  onChange={(e) => {
                    setNewPassword(e.target.value);
                    const validationErr = validatePassword(e.target.value);
                    if (e.target.value && validationErr) setPasswordError(validationErr);
                    else setPasswordError(null);
                  }}
                  placeholder="לפחות 8 תווים, אות גדולה, קטנה ומספר"
                  required
                  className={`w-full pr-10 pl-10 py-3 border rounded-lg focus:ring-2 focus:outline-none ${
                    passwordError ? 'border-red-500 focus:ring-red-200' : 'border-gray-300 focus:ring-cyan-200 focus:border-cyan-500'
                  }`}
                  disabled={isLoading}
                />
                 <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700"
                    aria-label={showPassword ? "הסתר סיסמה" : "הצג סיסמה"}
                >
                    {showPassword ? <EyeOff className="h-5 w-5" /> : <Eye className="h-5 w-5" />}
                </button>
              </div>
              {!passwordError && <p className="mt-1 text-xs text-gray-500">חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר.</p>}
            </div>

            <div className="space-y-1">
              <label htmlFor="confirm-password-reset" className="block text-sm font-medium text-gray-700">
                אימות סיסמה חדשה <span className="text-red-500">*</span>
              </label>
              <div className="relative">
                <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
                <Input
                  type={showConfirmPassword ? "text" : "password"}
                  id="confirm-password-reset"
                  value={confirmPassword}
                  onChange={(e) => setConfirmPassword(e.target.value)}
                  placeholder="הזן את הסיסמה החדשה שוב"
                  required
                  className="w-full pr-10 pl-10 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                  disabled={isLoading}
                />
                <button
                    type="button"
                    onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                    className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700"
                    aria-label={showConfirmPassword ? "הסתר סיסמה" : "הצג סיסמה"}
                >
                    {showConfirmPassword ? <EyeOff className="h-5 w-5" /> : <Eye className="h-5 w-5" />}
                </button>
              </div>
            </div>

            <Button
              type="submit"
              disabled={isLoading || !!passwordError || !otp || !newPassword || !confirmPassword || newPassword !== confirmPassword}
              className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2"
            >
              {isLoading ? (
                <>
                  <Loader2 className="h-5 w-5 animate-spin mr-2" />
                  <span>מאפס סיסמה...</span>
                </>
              ) : (
                "אפס סיסמה"
              )}
            </Button>
          </form>
        )}

        <div className="mt-6 text-center">
          <Link
            href="/auth/signin"
            className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline"
          >
            חזרה להתחברות
          </Link>
        </div>
      </div>
    </div>
  );
}
--- End of Content for ResetPasswordForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\SignInForm.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/SignInForm.tsx
"use client";

import { useState, useEffect, FormEvent } from "react";
import { useSearchParams, useRouter } from "next/navigation"; // Added useRouter
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Mail, Lock, AlertCircle, Loader2 } from "lucide-react"; // Added Loader2
import Link from "next/link";

export default function SignInForm() {
  const router = useRouter(); // Initialize useRouter
  const searchParams = useSearchParams();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);

  // Check for error from URL (e.g., after failed NextAuth sign-in attempt)
  useEffect(() => {
    const errorMessage = searchParams.get("error");
    const resetSuccess = searchParams.get("reset"); // Check for password reset success

    if (resetSuccess === "success") {
        // Optionally show a success message, e.g., using a toast or a temporary state
        // For now, we just clear any previous errors.
        setError(""); // Clear any auth errors if coming from successful reset
    }

    if (errorMessage) {
      switch (errorMessage) {
        case "CredentialsSignin":
          setError("אימייל או סיסמה אינם נכונים. אנא נסה שנית.");
          break;
        case "OAuthAccountNotLinked":
          setError(
            "חשבון זה כבר מקושר באמצעות ספק אחר. אנא התחבר באמצעות הספק המקורי."
          );
          break;
        // Add more specific error messages as needed from NextAuth errors
        default:
          setError(`אירעה שגיאה בהתחברות (${errorMessage}). נסה שנית.`);
      }
    }
  }, [searchParams]);

  // Pre-fill email if provided in URL (e.g., after registration or password reset notice)
  useEffect(() => {
    const emailParam = searchParams.get("email");
    if (emailParam) {
      setEmail(emailParam);
    }
  }, [searchParams]);

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError(""); // Clear previous errors
    setIsLoading(true);

    if (!email || !password) {
      setError("אנא הזן אימייל וסיסמה.");
      setIsLoading(false);
      return;
    }

    try {
      localStorage.setItem("last_user_email", email); // Store email for potential reuse

      const result = await signIn("credentials", {
        email: email.toLowerCase(), // Send normalized email
        password,
        redirect: false, // Handle redirect manually based on result
      });

      if (result?.error) {
        console.error("Sign-in error from NextAuth:", result.error);
        if (result.error === "CredentialsSignin") {
          setError("אימייל או סיסמה אינם נכונים.");
        } else if (result.error === "OAuthAccountNotLinked") {
          setError("חשבון זה מקושר לספק אחר (למשל Google). אנא התחבר באמצעותו.");
        }
        else {
          setError(result.error || "אירעה שגיאה בהתחברות, נסה שנית.");
        }
      } else if (result?.ok && result?.url) {
        // Successful sign-in, NextAuth would typically redirect if redirect:true
        // Since redirect:false, we can manually push or let NextAuth's redirect callback handle it.
        // The redirect callback in authOptions will determine the final destination.
        // If it reaches here, it means NextAuth didn't auto-redirect.
        router.push(result.url); // Or a default like '/profile'
        console.log("Sign-in successful, NextAuth redirecting to:", result.url);
      } else if (result && !result.ok && !result.error) {
        console.warn("Sign-in attempt did not result in an error or a redirect URL:", result);
        setError("תהליך ההתחברות לא הושלם כראוי. נסה שנית.");
      } else {
        // If signIn was successful but no specific URL (might happen with redirect: false if callback doesn't provide one)
        // This usually means the redirect callback in authOptions should handle it.
        // For safety, you might redirect to a default page or check session.
        router.push('/profile'); // Default redirect
      }
    } catch (err) {
      console.error("Unexpected sign-in error in handleSubmit:", err);
      setError("אירעה שגיאה לא צפויה בהתחברות, נסה שנית.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    setIsGoogleLoading(true);
    setError("");
    localStorage.setItem("google_auth_in_progress", "true");
    localStorage.setItem("auth_method", "google");

    try {
      // NextAuth handles the redirect. The callbackUrl is where Google sends the user back to your app.
      // Then, NextAuth's main redirect callback in auth.ts determines the final destination.
      await signIn("google", { callbackUrl: "/auth/google-callback" });
      // If signIn is successful, browser redirects, code below this await might not run if redirection happens.
    } catch (error) {
      console.error("Google sign-in error:", error);
      setError("אירעה שגיאה בהתחברות עם גוגל. נסה שנית.");
      setIsGoogleLoading(false); // Important if error occurs before redirection
    }
    // setIsGoogleLoading(false); // Typically not reached if redirect occurs
  };

  return (
    <div className="w-full max-w-md bg-white rounded-xl shadow-xl overflow-hidden relative">
      <div className="absolute top-0 left-0 right-0 h-2 bg-gradient-to-r from-cyan-500 to-pink-500"></div>

      <div className="p-6 sm:p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold text-gray-800 mb-2">
            התחברות למערכת
          </h1>
          <p className="text-gray-600">
            ברוכים השבים! המשיכו למצוא את השידוך המושלם.
          </p>
        </div>

        {error && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0" />
            <p className="text-red-600 text-sm">{error}</p>
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4 mb-6">
          <div className="space-y-1">
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              אימייל
            </label>
            <div className="relative">
              <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
              <input
                type="email"
                id="email"
                name="email"
                autoComplete="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                placeholder="you@example.com"
                required
                disabled={isLoading || isGoogleLoading}
              />
            </div>
          </div>

          <div className="space-y-1">
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700"
            >
              סיסמה
            </label>
            <div className="relative">
              <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
              <input
                type="password"
                id="password"
                name="password"
                autoComplete="current-password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="w-full pr-10 pl-3 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none"
                placeholder="הסיסמה שלך"
                required
                disabled={isLoading || isGoogleLoading}
              />
            </div>
            <div className="flex justify-end">
              <Link
                href="/auth/forgot-password" // Link to the new forgot password page
                className="text-sm text-cyan-600 hover:text-cyan-700 hover:underline mt-1"
              >
                שכחת סיסמה?
              </Link>
            </div>
          </div>

          <Button
            type="submit"
            disabled={isLoading || isGoogleLoading}
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-2 relative overflow-hidden group"
          >
            {isLoading ? (
              <>
                <Loader2 className="h-5 w-5 animate-spin mr-1" /> {/* Using Loader2 */}
                <span>מתחבר...</span>
              </>
            ) : (
              <>
                <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
                <span>התחברות</span>
              </>
            )}
          </Button>
        </form>

        <div className="relative mb-6">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">או</span>
          </div>
        </div>

        <Button
          type="button"
          onClick={handleGoogleSignIn}
          disabled={isLoading || isGoogleLoading}
          variant="outline"
          size="lg"
          className="w-full relative border-2 border-gray-300 hover:border-gray-400 py-3 rounded-xl flex items-center justify-center gap-3 group"
        >
          {isGoogleLoading ? (
            <>
              <Loader2 className="animate-spin h-5 w-5 mr-1" /> {/* Using Loader2 */}
              <span>מתחבר עם Google...</span>
            </>
          ) : (
            <>
              <svg className="h-5 w-5" viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  fill="#4285F4"
                />
                <path
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  fill="#34A853"
                />
                <path
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  fill="#FBBC05"
                />
                <path
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  fill="#EA4335"
                />
              </svg>
              <span className="text-gray-700 font-medium">
                התחברות עם Google
              </span>
            </>
          )}
        </Button>

        <div className="mt-6 text-center">
          <p className="text-gray-600 text-sm">
            אין לך חשבון עדיין?{" "}
            <Link
              href="/auth/register"
              className="text-cyan-600 font-medium hover:text-cyan-700 hover:underline"
            >
              הרשמה עכשיו
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
--- End of Content for SignInForm.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\BasicInfoStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/BasicInfoStep.tsx
"use client";

import { useState, useEffect } from "react";
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import {
  ArrowLeft,
  ArrowRight,
  User,
  Mail,
  Lock,
  AlertCircle,
  Loader2,
} from "lucide-react";
import { motion } from "framer-motion";
import ConsentCheckbox from "../ConsentCheckbox"; // <-- ייבוא הקומפוננטה החדשה

const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
  return email.trim() !== "" && emailRegex.test(email);
};
const isValidPassword = (password: string): boolean => {
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
  return passwordRegex.test(password);
};

const BasicInfoStep: React.FC = () => {
  const { data, updateField, prevStep, proceedToEmailVerification } =
    useRegistration();
  const [passwordVisible, setPasswordVisible] = useState(false);
  const [passwordError, setPasswordError] = useState("");
  const [emailError, setEmailError] = useState("");
  const [isFormValid, setIsFormValid] = useState(false);

  const [isLoading, setIsLoading] = useState(false);
  const [apiError, setApiError] = useState<string | null>(null);

  // --- הוספת State עבור תיבת ההסכמה ---
  const [consentChecked, setConsentChecked] = useState(false);
  const [consentError, setConsentError] = useState<string | null>(null);

  useEffect(() => {
    const isEmailValid = isValidEmail(data.email);
    const isPasswordValid = isValidPassword(data.password);
    const isNameValid =
      data.firstName.trim().length > 0 && data.lastName.trim().length > 0;

    setEmailError(
      data.email.trim() !== "" && !isEmailValid ? "כתובת אימייל לא תקינה" : ""
    );
    setPasswordError(
      data.password.trim() !== "" && !isPasswordValid
        ? "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר"
        : ""
    );

    // --- עדכון תנאי תקינות הטופס ---
    setIsFormValid(
      isEmailValid &&
        isPasswordValid &&
        isNameValid &&
        consentChecked && // <-- הוספת בדיקת הסכמה
        !isLoading
    );
  }, [
    data.email,
    data.password,
    data.firstName,
    data.lastName,
    consentChecked, // <-- הוספת תלות
    isLoading,
  ]);

  const handleEmailBlur = () => {
    if (data.email.trim() === "") {
      setEmailError("");
    } else if (!isValidEmail(data.email)) {
      setEmailError("כתובת אימייל לא תקינה");
    } else {
      setEmailError("");
    }
  };
  const handlePasswordBlur = () => {
    if (data.password.trim() === "") {
      setPasswordError("");
    } else if (!isValidPassword(data.password)) {
      setPasswordError(
        "הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר"
      );
    } else {
      setPasswordError("");
    }
  };

  const handleRegisterSubmit = async () => {
    setConsentError(null); // איפוס שגיאת הסכמה
    if (!consentChecked) {
      setConsentError("חובה לאשר את תנאי השימוש ומדיניות הפרטיות.");
      setIsFormValid(false); // ודא שהטופס לא יישלח
      return;
    }

    const isEmailValid = isValidEmail(data.email);
    const isPasswordValid = isValidPassword(data.password);
    const isFirstNameValid = data.firstName.trim().length > 0;
    const isLastNameValid = data.lastName.trim().length > 0;

    if (
      !isEmailValid ||
      !isPasswordValid ||
      !isFirstNameValid ||
      !isLastNameValid
    ) {
      setApiError("אנא מלא את כל השדות הנדרשים בצורה תקינה.");
      if (!isEmailValid && data.email.trim() !== "") handleEmailBlur();
      else if (data.email.trim() === "") setEmailError("שדה אימייל הוא חובה");
      if (!isPasswordValid && data.password.trim() !== "") handlePasswordBlur();
      else if (data.password.trim() === "")
        setPasswordError("שדה סיסמה הוא חובה");
      return;
    }
    if (emailError || passwordError) {
      setApiError("אנא תקן את השגיאות המסומנות.");
      return;
    }

    setIsLoading(true);
    setApiError(null);

    try {
      // כאן, ה-API /api/auth/register אמור לשמור את termsAndPrivacyAcceptedAt: new Date()
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          email: data.email,
          password: data.password,
          firstName: data.firstName,
          lastName: data.lastName,
          // אין צורך לשלוח את סטטוס ההסכמה, עצם השליחה מפה (לאחר שהכפתור הופעל) מעידה על הסכמה.
          // ה-API בצד השרת יקבע את חתימת הזמן.
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(
          result.error || `שגיאה ${response.status}: ${response.statusText}`
        );
      }

      if (result.success && result.email) {
        proceedToEmailVerification(result.email);
      } else {
        console.error(
          "Registration API success but no email returned or success false:",
          result
        );
        setApiError(
          result.error || "אירעה שגיאה במעבר לשלב אימות המייל. אנא נסה שנית."
        );
      }
    } catch (error) {
      console.error("Registration API error:", error);
      setApiError(
        error instanceof Error ? error.message : "אירעה שגיאה בלתי צפויה בהרשמה"
      );
    } finally {
      setIsLoading(false);
    }
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.1 } },
  };
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.5 } },
  };

  return (
    <motion.div
      className="space-y-5"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      {apiError && (
        <motion.div variants={itemVariants}>
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה בהרשמה</AlertTitle>
            <AlertDescription>{apiError}</AlertDescription>
          </Alert>
        </motion.div>
      )}

      <motion.h2
        className="text-xl font-bold text-gray-800 mb-4"
        variants={itemVariants}
      >
        פרטי חשבון
      </motion.h2>

      <motion.div variants={itemVariants} className="space-y-4">
        {/* Email Field */}
        <div className="space-y-1">
          <label
            htmlFor="emailBasic"
            className="block text-sm font-medium text-gray-700"
          >
            אימייל <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type="email"
              id="emailBasic"
              value={data.email}
              onChange={(e) => updateField("email", e.target.value)}
              onBlur={handleEmailBlur}
              placeholder="you@example.com"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } ${
                emailError
                  ? "border-red-500 focus:ring-red-200"
                  : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
            />
            {emailError && !isLoading && (
              <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                <AlertCircle className="h-5 w-5 text-red-500" />
              </div>
            )}
          </div>
          {emailError && (
            <p className="text-red-500 text-xs mt-1">{emailError}</p>
          )}
        </div>

        {/* Password Field */}
        <motion.div variants={itemVariants} className="space-y-1">
          <label
            htmlFor="passwordBasic"
            className="block text-sm font-medium text-gray-700"
          >
            סיסמה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type={passwordVisible ? "text" : "password"}
              id="passwordBasic"
              value={data.password}
              onChange={(e) => updateField("password", e.target.value)}
              onBlur={handlePasswordBlur}
              placeholder="לפחות 8 תווים"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-10 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } ${
                passwordError
                  ? "border-red-300 focus:ring-red-200"
                  : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
            />
            <button
              type="button"
              onClick={() => setPasswordVisible(!passwordVisible)}
              className="absolute inset-y-0 left-0 flex items-center pl-3 focus:outline-none"
              aria-label={passwordVisible ? "הסתר סיסמה" : "הצג סיסמה"}
            >
              <span className="text-gray-500">
                {passwordVisible ? "🙈" : "👁️"}
              </span>
            </button>
            {passwordError && !isLoading && (
              <div className="absolute inset-y-0 left-10 flex items-center pl-3 pointer-events-none">
                <AlertCircle className="h-5 w-5 text-red-500" />
              </div>
            )}
          </div>
          {passwordError && (
            <p className="text-red-500 text-xs mt-1">{passwordError}</p>
          )}
          {!passwordError && (
            <p className="text-gray-500 text-xs mt-1">
              הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה באנגלית, אות קטנה
              באנגלית ומספר.
            </p>
          )}
        </motion.div>

        {/* First Name Field */}
        <motion.div variants={itemVariants} className="space-y-1">
          <label
            htmlFor="firstNameBasic"
            className="block text-sm font-medium text-gray-700"
          >
            שם פרטי <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <User className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type="text"
              id="firstNameBasic"
              value={data.firstName}
              onChange={(e) => updateField("firstName", e.target.value)}
              placeholder="ישראל"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } border-gray-300 focus:ring-cyan-200 focus:border-cyan-500`}
            />
          </div>
        </motion.div>

        {/* Last Name Field */}
        <motion.div variants={itemVariants} className="space-y-1">
          <label
            htmlFor="lastNameBasic"
            className="block text-sm font-medium text-gray-700"
          >
            שם משפחה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <User className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type="text"
              id="lastNameBasic"
              value={data.lastName}
              onChange={(e) => updateField("lastName", e.target.value)}
              placeholder="ישראלי"
              disabled={isLoading}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                isLoading ? "bg-gray-100" : ""
              } border-gray-300 focus:ring-cyan-200 focus:border-cyan-500`}
            />
          </div>
        </motion.div>
      </motion.div>

      {/* --- הוספת תיבת ההסכמה --- */}
      <motion.div variants={itemVariants} className="mt-6">
        <ConsentCheckbox
          checked={consentChecked}
          onChange={(isChecked) => {
            setConsentChecked(isChecked);
            if (isChecked) setConsentError(null);
          }}
          error={consentError}
        />
      </motion.div>

      <motion.div
        variants={itemVariants}
        className="flex justify-between pt-4 mt-6 border-t border-gray-200"
      >
        <Button
          type="button"
          onClick={prevStep}
          variant="outline"
          className="flex items-center gap-2 border-gray-300"
          disabled={isLoading}
        >
          <ArrowRight className="h-4 w-4" /> חזרה
        </Button>

        <Button
          type="button"
          onClick={handleRegisterSubmit}
          disabled={!isFormValid || isLoading}
          className={`flex items-center gap-2 min-w-[200px] justify-center text-white font-medium px-4 py-2.5 rounded-lg transition-opacity
            ${
              isFormValid && !isLoading
                ? "bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-md hover:shadow-lg"
                : "bg-gray-300 cursor-not-allowed"
            }`}
        >
          {isLoading ? (
            <>
              <Loader2 className="h-5 w-5 animate-spin mr-2" />
              <span>יוצר חשבון...</span>
            </>
          ) : (
            <>
              <span>צור חשבון והמשך לאימות</span>
              <ArrowLeft className="h-4 w-4" />
            </>
          )}
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default BasicInfoStep;
--- End of Content for BasicInfoStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\CompleteStep.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  ArrowLeft,
  CheckCircle,
  Mail,
  User,
  Phone,
  ShieldQuestion,
} from "lucide-react";
import { motion } from "framer-motion";
import Link from "next/link";
import { useSession } from "next-auth/react";
// ודא שהנתיב לייבוא נכון. יכול להיות שזה ישירות מ-@prisma/client אם ייצאת אותו משם
import { UserStatus } from "@prisma/client"; // אם זה הנתיב שבו UserStatus מוגדר
import type { User as SessionUserType } from "@/types/next-auth"; // ... (variants נשארים אותו דבר) ...
const containerVariants = {
  /* ... */
};
const itemVariants = {
  /* ... */
};
const circleVariants = {
  /* ... */
};

const CompleteStep: React.FC = () => {
  const router = useRouter();
  const { data: session, status: sessionStatus } = useSession();

  const navigateToProfile = () => router.push("/profile/me");
  const navigateToQuestionnaire = () => router.push("/questionnaire");
  const navigateToVerifyPhone = () => router.push("/auth/verify-phone");
  const navigateToCompleteProfile = () => router.push("/auth/complete-profile");

  if (sessionStatus === "loading") {
    return (
      <div className="flex justify-center items-center h-40">
        <p className="text-lg text-gray-600">טוען נתונים...</p>
      </div>
    );
  }

  if (!session?.user) {
    router.push("/auth/signin");
    return null;
  }

  const user = session.user as SessionUserType; // ודא ש-SessionUserType מיובא נכון

  // תרחיש 1: צריך לאמת אימייל (ורק אם ההרשמה היא עם אימייל/סיסמה)
  // נניח ש-user.accounts הוא מערך של PrismaAccount
  const isCredentialsUser = user.accounts?.every(
    (acc) => acc.provider === "credentials"
  );

  // *******************************************************************
  // כאן השינוי: השתמש בערכים מה-enum UserStatus שלך
  // *******************************************************************
  if (
    !user.isVerified &&
    isCredentialsUser &&
    user.status === UserStatus.PENDING_EMAIL_VERIFICATION
  ) {
    return (
      <motion.div
        className="space-y-6 text-center"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* ... תוכן לאימות מייל ... */}
        <motion.div
          className="flex justify-center mb-6"
          variants={circleVariants}
        >
          <div className="relative w-28 h-28 rounded-full bg-gradient-to-r from-cyan-500 to-pink-500 flex items-center justify-center">
            <motion.div
              className="absolute inset-1 bg-white rounded-full flex items-center justify-center"
              animate={{ scale: [0.6, 1] }}
              transition={{ duration: 0.5, delay: 0.5 }}
            >
              <Mail className="h-14 w-14 text-cyan-500" />
            </motion.div>
          </div>
        </motion.div>
        <motion.h2
          className="text-2xl font-bold text-gray-800"
          variants={itemVariants}
        >
          אימות כתובת המייל
        </motion.h2>
        <motion.div variants={itemVariants}>
          <div className="p-4 bg-cyan-50 rounded-lg mb-5">
            <div className="flex items-center gap-2 text-cyan-700 mb-2 justify-center">
              <Mail className="h-5 w-5" />
              <h3 className="font-medium">אנא אמת את כתובת המייל שלך</h3>
            </div>
            <p className="text-sm text-cyan-600">
              שלחנו לך מייל לכתובת{" "}
              <span className="font-bold">{user.email}</span>.
              <br />
              אנא לחץ על הקישור במייל כדי להשלים את תהליך האימות.
            </p>
          </div>
        </motion.div>
      </motion.div>
    );
  }

  // תרחיש 2: צריך להשלים פרופיל
  if (user.isVerified && !user.isProfileComplete) {
    return (
      <motion.div
        className="space-y-6 text-center"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* ... תוכן להשלמת פרופיל ... */}
        <motion.div
          className="flex justify-center mb-6"
          variants={circleVariants}
        >
          <div className="relative w-28 h-28 rounded-full bg-gradient-to-r from-cyan-500 to-pink-500 flex items-center justify-center">
            <motion.div
              className="absolute inset-1 bg-white rounded-full flex items-center justify-center"
              animate={{ scale: [0.6, 1] }}
              transition={{ duration: 0.5, delay: 0.5 }}
            >
              <User className="h-14 w-14 text-cyan-500" />
            </motion.div>
          </div>
        </motion.div>
        <motion.h2
          className="text-2xl font-bold text-gray-800"
          variants={itemVariants}
        >
          השלמת פרטי פרופיל
        </motion.h2>
        <motion.p className="text-gray-600 mb-6" variants={itemVariants}>
          כדי שנוכל להתאים לך את השידוכים הטובים ביותר, אנא השלם את פרטי הפרופיל
          שלך.
        </motion.p>
        <motion.div variants={itemVariants} className="flex flex-col gap-4">
          <Button
            onClick={navigateToCompleteProfile}
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 rounded-lg shadow-lg flex items-center justify-center gap-2"
          >
            <User className="h-5 w-5 text-white" />
            <span className="text-white">להשלמת הפרופיל</span>
          </Button>
        </motion.div>
      </motion.div>
    );
  }

  // תרחיש 3: צריך לאמת טלפון
  // *******************************************************************
  // כאן השינוי: השתמש בערכים מה-enum UserStatus שלך
  // יכול להיות שגם תרצה לבדוק user.status === UserStatus.PENDING_PHONE_VERIFICATION
  // *******************************************************************
  if (
    user.isVerified &&
    user.isProfileComplete &&
    !user.isPhoneVerified &&
    user.status === UserStatus.PENDING_PHONE_VERIFICATION
  ) {
    return (
      <motion.div /* ... */>
        {/* ... הצגת אייקון, כותרת, וטקסט ... */}
        <motion.div variants={itemVariants} className="flex flex-col gap-4">
          <Button
            onClick={navigateToVerifyPhone} // הפונקציה הזו עושה router.push('/auth/verify-phone')
            className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 rounded-lg shadow-lg flex items-center justify-center gap-2"
          >
            <Phone className="h-5 w-5 text-white" />
            <span className="text-white">לאימות מספר הטלפון</span>
          </Button>
        </motion.div>
      </motion.div>
    );
  }

  // תרחיש 4: הכל הושלם! (או user.status === UserStatus.ACTIVE)
  return (
    <motion.div
      className="space-y-6 text-center"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      {/* ... תוכן להכל הושלם ... */}
      <motion.div
        className="flex justify-center mb-6"
        variants={circleVariants}
      >
        <div className="relative w-28 h-28 rounded-full bg-gradient-to-r from-cyan-500 to-pink-500 flex items-center justify-center">
          <motion.div
            className="absolute inset-1 bg-white rounded-full flex items-center justify-center"
            animate={{ scale: [0.6, 1] }}
            transition={{ duration: 0.5, delay: 0.5 }}
          >
            <CheckCircle className="h-14 w-14 text-green-500" />
          </motion.div>
        </div>
      </motion.div>
      <motion.h2
        className="text-2xl font-bold text-gray-800"
        variants={itemVariants}
      >
        ההרשמה והפרופיל הושלמו בהצלחה!
      </motion.h2>
      <motion.div variants={itemVariants}>
        <p className="text-gray-600 mb-6">
          מעולה! כל הפרטים שלך מאומתים ומוכנים.
          <br />
          עכשיו תוכל להתחיל בתהליך מציאת השידוך.
        </p>
      </motion.div>
      <motion.div variants={itemVariants} className="flex flex-col gap-4">
        <Button
          onClick={navigateToProfile}
          className="w-full py-3 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 rounded-lg shadow-lg flex items-center justify-center gap-2 group relative overflow-hidden"
        >
          <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
          <User className="h-5 w-5 text-white" />
          <span className="text-white">לפרופיל שלי</span>
          <ArrowLeft className="h-4 w-4 text-white opacity-0 group-hover:opacity-100 transform translate-x-2 group-hover:translate-x-0 transition-all duration-300" />
        </Button>
        <Button
          onClick={navigateToQuestionnaire}
          variant="outline"
          className="w-full py-3 border-2 border-cyan-200 text-cyan-600 hover:bg-cyan-50 hover:border-cyan-300 flex items-center justify-center gap-2"
        >
          <ShieldQuestion className="h-5 w-5" />
          <span>למילוי שאלון התאמה</span>
          <ArrowLeft className="h-4 w-4" />
        </Button>
        <Link
          href="/"
          className="text-sm text-gray-500 hover:text-gray-700 hover:underline mt-2"
        >
          חזרה לדף הבית
        </Link>
      </motion.div>
    </motion.div>
  );
};

export default CompleteStep;
--- End of Content for CompleteStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\EmailVerificationCodeStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/EmailVerificationCodeStep.tsx
"use client";

import { useState, useRef, KeyboardEvent, useEffect, FormEvent } from "react";
import { useRouter } from "next/navigation";
import { signIn } from "next-auth/react"; // נשאר רק signIn, useSession לא בשימוש ישיר כאן
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, AlertCircle, MailCheck, ArrowRight } from "lucide-react";
import { motion } from "framer-motion";
import { Input } from "@/components/ui/input";

const OTP_LENGTH = 6;

const EmailVerificationCodeStep: React.FC = () => {
  const {
    data: registrationData,
    exitEmailVerification: goBackToBasicInfo,
    completeEmailVerification, // הוספת הפונקציה מהקונטקסט
  } = useRegistration();

  const router = useRouter();

  const [otp, setOtp] = useState<string[]>(new Array(OTP_LENGTH).fill(""));
  const [isLoading, setIsLoading] = useState(false);
  const [isResending, setIsResending] = useState(false);
  const [apiError, setApiError] = useState<string | null>(null);
  const [resendMessage, setResendMessage] = useState<string | null>(null);
  const inputRefs = useRef<(HTMLInputElement | null)[]>([]);

  useEffect(() => {
    if (inputRefs.current[0]) {
      inputRefs.current[0]?.focus();
    }
  }, []);

  const handleChange = (element: HTMLInputElement, index: number) => {
    const value = element.value.replace(/[^0-9]/g, "");

    if (value.length > 1 && index < OTP_LENGTH) {
      const chars = value.split("");
      let currentIdx = index;
      const newOtp = [...otp];

      for (
        let i = 0;
        i < chars.length && currentIdx < OTP_LENGTH;
        i++, currentIdx++
      ) {
        newOtp[currentIdx] = chars[i];
      }
      setOtp(newOtp);
      const nextFocusIndex = Math.min(index + chars.length, OTP_LENGTH - 1);
      if (inputRefs.current[nextFocusIndex] && chars.length > 0) {
        setTimeout(() => inputRefs.current[nextFocusIndex]?.focus(), 0);
      }
      return;
    }

    const newOtp = [...otp];
    newOtp[index] = value;
    setOtp(newOtp);

    if (value && index < OTP_LENGTH - 1) {
      if (inputRefs.current[index + 1]) {
        inputRefs.current[index + 1]?.focus();
      }
    }
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>, index: number) => {
    if (e.key === "Backspace") {
      e.preventDefault();
      const newOtp = [...otp];
      if (newOtp[index]) {
        newOtp[index] = "";
        setOtp(newOtp);
      } else if (index > 0) {
        if (inputRefs.current[index - 1]) {
          inputRefs.current[index - 1]?.focus();
        }
      }
    } else if (e.key === "ArrowLeft" && index > 0) {
      e.preventDefault();
      if (inputRefs.current[index - 1]) {
        inputRefs.current[index - 1]?.focus();
      }
    } else if (e.key === "ArrowRight" && index < OTP_LENGTH - 1) {
      e.preventDefault();
      if (inputRefs.current[index + 1]) {
        inputRefs.current[index + 1]?.focus();
      }
    }
  };

  const handleFormSubmit = async (e: FormEvent) => {
    e.preventDefault();
    const enteredCode = otp.join("");
    if (enteredCode.length !== OTP_LENGTH) {
      setApiError(`הקוד חייב להכיל ${OTP_LENGTH} ספרות.`);
      return;
    }

    setIsLoading(true);
    setApiError(null);
    setResendMessage(null);

    try {
      // 1. Verify the code with the backend
      console.log(
        "CLIENT LOG: Submitting OTP to API. Email:",
        registrationData.emailForVerification
      );
      const response = await fetch("/api/auth/verify-email-code", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          email: registrationData.emailForVerification,
          code: enteredCode,
        }),
      });

      const result = await response.json();
      console.log("CLIENT LOG: API response for /verify-email-code:", result);

      if (!response.ok || !result.success || !result.authToken) {
        throw new Error(
          result.error || "שגיאה באימות הקוד מה-API או שלא הוחזר טוקן התחברות."
        );
      }

      const authToken = result.authToken;
      console.log(
        "CLIENT LOG: Email code verified with API. AuthToken received. Attempting auto-signin..."
      );

      // 2. Attempt auto-signin with the received authToken
      const signInResult = await signIn("email-verified-autologin", {
        authToken: authToken,
        redirect: false, // חשוב! אנחנו נטפל בהפניה ידנית
      });

      console.log("CLIENT LOG: Auto-signin attempt result:", signInResult);

      if (signInResult?.ok) {
        // ההתחברות האוטומטית הצליחה, והסשן נוצר/עודכן
        console.log(
          "CLIENT LOG: Auto-signin successful. Calling completeEmailVerification and navigating to /auth/register."
        );
        completeEmailVerification(); // <-- קריאה לפונקציה מהקונטקסט
        router.push("/auth/register");
        // אין צורך לקרוא ל-setIsLoading(false) כאן כי הקומפוננטה תעשה unmount
      } else {
        // ההתחברות האוטומטית נכשלה
        console.error("CLIENT LOG: Auto-signin failed.", signInResult?.error);
        setApiError(
          `אימות המייל הצליח, אך נתקלנו בבעיה בהתחברות האוטומטית: ${
            signInResult?.error || "שגיאה לא ידועה"
          }. אנא נסה להתחבר ידנית.`
        );
        setIsLoading(false); // אפשר למשתמש לנסות שוב או לנקוט פעולה אחרת
      }
    } catch (error) {
      console.error(
        "CLIENT LOG: Error during email verification process or auto-signin:",
        error
      );
      setApiError(
        error instanceof Error
          ? error.message
          : "אירעה שגיאה בלתי צפויה בתהליך האימות"
      );
      setOtp(new Array(OTP_LENGTH).fill(""));
      if (inputRefs.current[0]) {
        inputRefs.current[0]?.focus();
      }
      setIsLoading(false);
    }
  };

  const handleResendCode = async () => {
    setIsResending(true);
    setApiError(null);
    setResendMessage(null);

    try {
      console.log(
        "CLIENT LOG: Requesting to resend verification code for email:",
        registrationData.emailForVerification
      );
      const response = await fetch("/api/auth/resend-verification-code", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: registrationData.emailForVerification }),
      });
      const result = await response.json();
      console.log(
        "CLIENT LOG: API response for /resend-verification-code:",
        result
      );

      if (!response.ok || !result.success) {
        throw new Error(result.error || "שגיאה בשליחה חוזרת של הקוד");
      }
      setResendMessage(result.message || "קוד חדש נשלח בהצלחה.");
      setOtp(new Array(OTP_LENGTH).fill(""));
      if (inputRefs.current[0]) {
        inputRefs.current[0]?.focus();
      }
    } catch (error) {
      console.error("CLIENT LOG: Error during resend code:", error);
      setApiError(
        error instanceof Error ? error.message : "אירעה שגיאה בשליחה חוזרת"
      );
    } finally {
      setIsResending(false);
    }
  };

  const handlePaste = (e: React.ClipboardEvent<HTMLDivElement>) => {
    const pasteData = e.clipboardData
      .getData("text")
      .replace(/[^0-9]/g, "")
      .slice(0, OTP_LENGTH);

    if (pasteData.length > 0) {
      e.preventDefault();
      const newOtp = new Array(OTP_LENGTH).fill("");
      for (let i = 0; i < pasteData.length; i++) {
        newOtp[i] = pasteData[i];
      }
      setOtp(newOtp);
      const focusIndex = Math.min(pasteData.length, OTP_LENGTH - 1);
      if (inputRefs.current[focusIndex]) {
        setTimeout(() => inputRefs.current[focusIndex]?.focus(), 0);
      }
    }
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.1 } },
  };
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.5 } },
  };

  return (
    <motion.div
      className="space-y-6 text-center p-4 sm:p-6"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.div variants={itemVariants}>
        <MailCheck className="h-12 w-12 text-cyan-500 mx-auto mb-3" />
        <h2 className="text-xl sm:text-2xl font-bold text-gray-800">
          אימות כתובת מייל
        </h2>
        <p className="text-gray-600 mt-2 text-sm sm:text-base">
          שלחנו קוד אימות בן {OTP_LENGTH} ספרות לכתובת{" "}
          <strong className="font-semibold text-gray-700">
            {registrationData.emailForVerification || "האימייל שלך"}
          </strong>
          .
          <br />
          אנא הזן את הקוד שקיבלת.
        </p>
      </motion.div>

      {apiError && (
        <motion.div variants={itemVariants}>
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{apiError}</AlertDescription>
          </Alert>
        </motion.div>
      )}
      {resendMessage && !apiError && (
        <motion.div variants={itemVariants}>
          <Alert
            variant="default"
            className="bg-green-50 border-green-300 text-green-700"
          >
            <MailCheck className="h-4 w-4 text-green-600" />
            <AlertTitle>הודעה</AlertTitle>
            <AlertDescription>{resendMessage}</AlertDescription>
          </Alert>
        </motion.div>
      )}

      <form onSubmit={handleFormSubmit}>
        <motion.div
          variants={itemVariants}
          className="flex justify-center space-x-2 sm:space-x-3 rtl:space-x-reverse"
          dir="ltr"
          onPaste={handlePaste}
        >
          {otp.map((digit, index) => (
            <Input
              key={index}
              type="text"
              maxLength={1}
              value={digit}
              onChange={(e) =>
                handleChange(e.target as HTMLInputElement, index)
              }
              onKeyDown={(e) =>
                handleKeyDown(e as KeyboardEvent<HTMLInputElement>, index)
              }
              ref={(el) => {
                inputRefs.current[index] = el;
              }}
              className="w-10 h-12 sm:w-12 sm:h-14 text-center text-lg sm:text-xl font-semibold border-2 border-gray-300 rounded-md focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500 outline-none transition-colors disabled:bg-gray-100 appearance-none"
              disabled={isLoading || isResending}
              aria-label={`OTP digit ${index + 1}`}
              autoComplete="one-time-code"
              inputMode="numeric"
            />
          ))}
        </motion.div>

        <motion.div variants={itemVariants} className="space-y-4 mt-6">
          <Button
            type="submit"
            disabled={
              isLoading || isResending || otp.join("").length !== OTP_LENGTH
            }
            className="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600"
          >
            {isLoading ? (
              <>
                <Loader2 className="h-5 w-5 animate-spin" />
                <span>מאמת ומתחבר...</span>
              </>
            ) : (
              "אמת קוד והמשך להשלמת פרופיל"
            )}
          </Button>
        </motion.div>
      </form>

      <motion.div
        variants={itemVariants}
        className="text-sm text-gray-500 mt-2"
      >
        לא קיבלת קוד?{" "}
        <Button
          type="button"
          variant="link"
          onClick={handleResendCode}
          disabled={isLoading || isResending}
          className="p-0 h-auto text-cyan-600 hover:text-cyan-700 disabled:text-gray-400"
        >
          {isResending ? (
            <>
              <Loader2 className="h-4 w-4 animate-spin ml-1 rtl:mr-1 rtl:ml-0" />
              <span>שולח קוד חדש...</span>
            </>
          ) : (
            "שלח קוד חדש"
          )}
        </Button>
      </motion.div>

      <motion.div variants={itemVariants} className="mt-6">
        <Button
          type="button"
          onClick={goBackToBasicInfo}
          variant="outline"
          className="flex items-center gap-2 border-gray-300 text-sm"
          disabled={isLoading || isResending}
        >
          <ArrowRight className="h-4 w-4" /> חזור למילוי פרטים
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default EmailVerificationCodeStep;
--- End of Content for EmailVerificationCodeStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\OptionalInfoStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/OptionalInfoStep.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Input } from "@/components/ui/input";
import {
  ArrowLeft,
  ArrowRight,
  Ruler,
  Briefcase,
  GraduationCap,
  Loader2,
  AlertCircle,
} from "lucide-react";
import { motion } from "framer-motion";

type SubmissionStatus = "idle" | "savingProfile" | "updatingSession" | "sendingCode" | "error";

const OptionalInfoStep: React.FC = () => {
  const { data, updateField, prevStep } = useRegistration();
  const router = useRouter();
  const { update: updateSessionHook, status: sessionStatus } = useSession();

  const [submissionStatus, setSubmissionStatus] =
    useState<SubmissionStatus>("idle");
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async () => {
    console.log(`[OptionalInfoStep] handleSubmit triggered. Current session status: ${sessionStatus}, RegistrationContext data:`, JSON.stringify(data, null, 2));
    setSubmissionStatus("savingProfile");
    setError(null);

    try {
      const profileData = {
        // חשוב לוודא ששולחים את כל השדות שה-API מצפה להם, במיוחד firstName ו-lastName
        firstName: data.firstName,
        lastName: data.lastName,
        phone: data.phone, // ודא ש-data.phone מכיל ערך תקין מהשלב הקודם
        gender: data.gender, // ודא ש-data.gender מכיל ערך תקין
        birthDate: data.birthDate, // ודא ש-data.birthDate מכיל ערך תקין
        maritalStatus: data.maritalStatus, // ודא ש-data.maritalStatus מכיל ערך תקין
        height: data.height,
        occupation: data.occupation,
        education: data.education,
      };

      // בדיקה נוספת של הנתונים לפני השליחה
      if (!profileData.firstName || !profileData.lastName || !profileData.phone || !profileData.gender || !profileData.birthDate || !profileData.maritalStatus) {
        console.error("[OptionalInfoStep] ERROR: Missing required profile data before sending to API. Data:", JSON.stringify(profileData, null, 2));
        setError("חסרים נתונים חיוניים להשלמת הפרופיל. אנא חזור לשלב הקודם ובדוק את הפרטים.");
        setSubmissionStatus("error");
        return;
      }


      console.log("[OptionalInfoStep] Submitting profile data to /api/auth/complete-profile:", JSON.stringify(profileData, null, 2));

      const profileResponse = await fetch("/api/auth/complete-profile", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(profileData),
        credentials: "include", // חשוב אם ה-API שלך מסתמך על עוגיות סשן
      });

      const profileResultText = await profileResponse.text();
      console.log(`[OptionalInfoStep] Raw response from /api/auth/complete-profile (Status: ${profileResponse.status}):`, profileResultText);

      if (!profileResponse.ok) {
        let errorMessage = `שגיאה ${profileResponse.status}`;
        try {
          const errorData = JSON.parse(profileResultText);
          errorMessage =
            errorData.error || errorData.message || // נסה גם message
            `שגיאה ${profileResponse.status}: נתונים לא תקינים או בעיית שרת.`;
          console.error(
            "[OptionalInfoStep] API Error (complete-profile):",
            errorData
          );
        } catch (parseError) {
          errorMessage = `שגיאה ${profileResponse.status}: ${profileResponse.statusText}. Response: ${profileResultText}`;
          console.error("[OptionalInfoStep] Failed to parse error JSON from /api/auth/complete-profile:", parseError);
        }
        throw new Error(errorMessage);
      }

      let profileResult;
      try {
        profileResult = JSON.parse(profileResultText);
      } catch (e) {
        console.error("[OptionalInfoStep] Failed to parse success JSON from /api/auth/complete-profile. Text was:", profileResultText, "Error:", e);
        throw new Error("תגובה לא תקינה מהשרת לאחר שמירת פרופיל (לא JSON).");
      }

      console.log(
        "[OptionalInfoStep] Profile data saved successfully via API. API Response:",
        JSON.stringify(profileResult, null, 2)
      );

      if (profileResult?.user?.isProfileComplete !== true) {
          console.warn("[OptionalInfoStep] WARNING: API /api/auth/complete-profile did NOT return user.isProfileComplete as true in its response. User object from API:", JSON.stringify(profileResult?.user, null, 2));
          // זה לא בהכרח אומר שה-DB לא התעדכן, אבל זה מצביע על חוסר עקביות בתגובת ה-API או שה-API לא עדכן את הדגל.
      }

      console.log("[OptionalInfoStep] Setting status to 'updatingSession' and calling updateSessionHook()...");
      setSubmissionStatus("updatingSession");
      await updateSessionHook(); // גורם ל-NextAuth לרענן את הטוקן/סשן. ה-JWT callback בשרת יקרא מה-DB.
      console.log("[OptionalInfoStep] updateSessionHook() presumably completed. The session and token should now be refreshed based on DB state.");


      console.log("[OptionalInfoStep] Setting status to 'sendingCode' and attempting to send phone verification code...");
      setSubmissionStatus("sendingCode");

      const sendCodeResponse = await fetch("/api/auth/send-phone-code", {
        method: "POST",
        headers: { "Content-Type": "application/json" }, // גם אם אין body, header זה עדיין טוב
        // body: JSON.stringify({}), // אם ה-API דורש גוף כלשהו, אפשר לשלוח אובייקט ריק
        credentials: "include",
      });
      const sendCodeResultText = await sendCodeResponse.text();
      console.log(`[OptionalInfoStep] Raw response from /api/auth/send-phone-code (Status: ${sendCodeResponse.status}):`, sendCodeResultText);


      if (!sendCodeResponse.ok) {
        let errorMessage = `שגיאה ${sendCodeResponse.status}`;
         try {
          const errorData = JSON.parse(sendCodeResultText);
          errorMessage = errorData.error || errorData.message || `שגיאה ${sendCodeResponse.status} בשליחת קוד אימות.`;
         } catch(e){
            errorMessage = `שגיאה ${sendCodeResponse.status}: ${sendCodeResponse.statusText}. Response: ${sendCodeResultText}`;
            console.error("[OptionalInfoStep] Failed to parse error JSON from /api/auth/send-phone-code:", e);
         }
        throw new Error(errorMessage);
      }

      let sendCodeResult;
      try {
        sendCodeResult = JSON.parse(sendCodeResultText);
      } catch (e) {
         console.error("[OptionalInfoStep] Failed to parse success JSON from /api/auth/send-phone-code. Text was:", sendCodeResultText, "Error:", e);
         throw new Error("תגובה לא תקינה מהשרת לאחר שליחת קוד טלפון (לא JSON).");
      }

      console.log(
        "[OptionalInfoStep] Verification code sent successfully via API. API Response:",
        JSON.stringify(sendCodeResult, null, 2)
      );

      console.log("[OptionalInfoStep] Successfully sent phone code. Navigating to /auth/verify-phone...");
      // בשלב זה, הטוקן בעוגיה אמור להיות מעודכן עם isProfileComplete: true (לאחר ה-updateSessionHook).
      // ה-Middleware שיפעל עם הניווט יראה את הטוקן המעודכן.
      router.push("/auth/verify-phone");
    } catch (err) {
      console.error(
        "[OptionalInfoStep] Error during handleSubmit:",
        err instanceof Error ? err.stack : err // הדפס את ה-stack trace המלא אם זמין
      );
      setError(err instanceof Error ? err.message : "אירעה שגיאה לא צפויה");
      setSubmissionStatus("error");
    }
    // אין צורך ב-finally להחזיר סטטוס ל-idle אם יש ניווט,
    // כי הקומפוננטה תעשה unmount.
    // אם נשארים בדף עקב שגיאה, הכפתור צריך להיות פעיל שוב (הסטטוס 'error' יאפשר זאת).
  };

  const getButtonText = (): string => {
    switch (submissionStatus) {
      case "savingProfile": return "שומר פרטים...";
      case "updatingSession": return "מעדכן סשן...";
      case "sendingCode": return "שולח קוד אימות...";
      case "error": // במקרה של שגיאה, חזור לטקסט המקורי כדי לאפשר ניסיון חוזר
      case "idle":
      default:
        // הטקסט הדינמי המקורי היה: data.isCompletingProfile ? "סיום והמשך לאימות" : "סיום והרשמה";
        // מכיוון שאנחנו ב-OptionalInfoStep, סביר להניח ש-isCompletingProfile יהיה true מהקונטקסט.
        return "סיום והמשך לאימות";
    }
  };

  const isSubmitting =
    submissionStatus === "savingProfile" ||
    submissionStatus === "updatingSession" ||
    submissionStatus === "sendingCode";

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: { staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.5 },
    },
  };

  return (
    <motion.div
      className="space-y-5"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.h2
        className="text-xl font-bold text-gray-800 mb-1"
        variants={itemVariants}
      >
        מידע נוסף (אופציונלי)
      </motion.h2>
      <motion.p className="text-gray-600 text-sm mb-4" variants={itemVariants}>
        מידע זה יעזור לנו להתאים לך שידוכים מדויקים יותר. כל השדות הבאים הם
        אופציונליים אך מומלצים.
      </motion.p>

      {error && submissionStatus === "error" && (
          <motion.div variants={itemVariants}>
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>שגיאה</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          </motion.div>
        )}

      <motion.div variants={itemVariants} className="space-y-4">
        {/* Height Field */}
        <div className="space-y-1">
          <label
            htmlFor="heightOptional"
            className="block text-sm font-medium text-gray-700 flex items-center gap-1"
          >
            <Ruler className="h-4 w-4 text-gray-400" />
            גובה (בסמ)
          </label>
          <Input
            type="number"
            id="heightOptional"
            min="120"
            max="220"
            value={data.height ?? ""} // השתמש ב- ?? "" כדי למנוע uncontrolled input אם הערך הוא undefined
            onChange={(e) =>
              updateField(
                "height",
                e.target.value === "" // אם השדה ריק, שלח undefined
                  ? undefined
                  : parseInt(e.target.value, 10) || undefined // אם לא ניתן להמיר למספר, שלח undefined
              )
            }
            placeholder="לדוגמה: 175"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none disabled:bg-gray-100"
            disabled={isSubmitting}
          />
        </div>

        {/* Occupation Field */}
        <div className="space-y-1">
          <label
            htmlFor="occupationOptional"
            className="block text-sm font-medium text-gray-700 flex items-center gap-1"
          >
            <Briefcase className="h-4 w-4 text-gray-400" />
            עיסוק
          </label>
          <Input
            type="text"
            id="occupationOptional"
            value={data.occupation ?? ""}
            onChange={(e) => updateField("occupation", e.target.value || undefined)} // אם ריק, שלח undefined
            placeholder="לדוגמה: מהנדס תוכנה, מורה, סטודנט/ית"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none disabled:bg-gray-100"
            disabled={isSubmitting}
          />
        </div>

        {/* Education Field */}
        <div className="space-y-1">
          <label
            htmlFor="educationOptional"
            className="block text-sm font-medium text-gray-700 flex items-center gap-1"
          >
            <GraduationCap className="h-4 w-4 text-gray-400" />
            השכלה
          </label>
          <Input
            type="text"
            id="educationOptional"
            value={data.education ?? ""}
            onChange={(e) => updateField("education", e.target.value || undefined)} // אם ריק, שלח undefined
            placeholder="לדוגמה: תואר ראשון במדעי המחשב"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-200 focus:border-cyan-500 focus:outline-none disabled:bg-gray-100"
            disabled={isSubmitting}
          />
        </div>
      </motion.div>

      <motion.div
        variants={itemVariants}
        className="flex justify-between pt-4 mt-6"
      >
        <Button
          type="button"
          onClick={prevStep}
          variant="outline"
          className="flex items-center gap-2 border-gray-300"
          disabled={isSubmitting}
        >
          <ArrowRight className="h-4 w-4" />
          חזרה
        </Button>

        <Button
          type="button"
          onClick={handleSubmit}
          disabled={isSubmitting}
          className="bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 flex items-center gap-2 min-w-[200px] justify-center px-4 py-2.5 disabled:opacity-70" // שיניתי קצת את העיצוב שיתאים לכפתורים אחרים
        >
          {isSubmitting ? (
            <>
              <Loader2 className="h-5 w-5 animate-spin mr-2" /> {/* התאמתי גודל אייקון */}
              <span>{getButtonText()}</span>
            </>
          ) : (
            <>
              <span>{getButtonText()}</span>
              <ArrowLeft className="h-4 w-4 ml-2" />
            </>
          )}
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default OptionalInfoStep;
--- End of Content for OptionalInfoStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\PersonalDetailsStep.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/auth/steps/PersonalDetailsStep.tsx
"use client";

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react"; // הוספת update
import { useRegistration } from "../RegistrationContext";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  ArrowLeft,
  ArrowRight,
  Phone,
  Calendar,
  Users,
  Edit3,
  Loader2, // הוספת אייקון טעינה
  AlertCircle, // הוספת אייקון לשגיאות
} from "lucide-react";
import { Gender } from "@prisma/client";
import { motion } from "framer-motion";
import ConsentCheckbox from "../ConsentCheckbox"; // ייבוא קומפוננטת ההסכמה
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"; // ייבוא רכיבי Alert

const PersonalDetailsStep: React.FC = () => {
  const { data: registrationState, updateField, nextStep, prevStep } = useRegistration();
  const { data: session, update: updateSessionHook } = useSession(); // שימוש ב-update מה-hook

  const [firstNameError, setFirstNameError] = useState("");
  const [lastNameError, setLastNameError] = useState("");
  const [phoneError, setPhoneError] = useState("");
  const [ageError, setAgeError] = useState("");
  const [isFormValid, setIsFormValid] = useState(false);

  // State עבור הסכמה
  const [consentChecked, setConsentChecked] = useState(
    !!session?.user?.termsAndPrivacyAcceptedAt // אתחול לפי הסשן
  );
  const [consentError, setConsentError] = useState<string | null>(null);
  const [isSubmittingConsent, setIsSubmittingConsent] = useState(false);
  const [generalApiError, setGeneralApiError] = useState<string | null>(null);

  const userHasAlreadyConsented = !!session?.user?.termsAndPrivacyAcceptedAt;

  // פונקציות ולידציה (נשארות זהות)
  const validateFirstName = (name: string): boolean => {
    const isValid = name.trim() !== "";
    setFirstNameError(isValid ? "" : "שם פרטי הוא שדה חובה");
    return isValid;
  };
  const validateLastName = (name: string): boolean => {
    const isValid = name.trim() !== "";
    setLastNameError(isValid ? "" : "שם משפחה הוא שדה חובה");
    return isValid;
  };
  const validatePhone = (phone: string): boolean => {
    const phoneRegex = /^0\d{9}$/;
    const isValid = phoneRegex.test(phone);
    setPhoneError(
      isValid
        ? ""
        : phone.trim() === ""
        ? "מספר טלפון הוא שדה חובה"
        : "מספר טלפון לא תקין (10 ספרות, מתחיל ב-0)"
    );
    return isValid;
  };
  const validateAge = (birthDate: string): boolean => {
    if (!birthDate) {
      setAgeError("תאריך לידה הוא שדה חובה");
      return false;
    }
    const birthDateObj = new Date(birthDate);
    const today = new Date();
    let age = today.getFullYear() - birthDateObj.getFullYear();
    const monthDifference = today.getMonth() - birthDateObj.getMonth();
    if (
      monthDifference < 0 ||
      (monthDifference === 0 && today.getDate() < birthDateObj.getDate())
    ) {
      age--;
    }
    if (age < 18) {
      setAgeError("גיל מינימלי להרשמה הוא 18");
      return false;
    } else if (age > 120) {
      setAgeError("תאריך לידה לא תקין");
      return false;
    }
    setAgeError("");
    return true;
  };

  useEffect(() => {
    // אם המשתמש כבר אישר בעבר, נסמן את התיבה
    if (userHasAlreadyConsented) {
        setConsentChecked(true);
    }
  }, [userHasAlreadyConsented]);


  useEffect(() => {
    const isFirstNameValid = registrationState.firstName.trim() !== "" && !firstNameError;
    const isLastNameValid = registrationState.lastName.trim() !== "" && !lastNameError;
    const isPhoneValid =
      registrationState.phone.trim() !== "" &&
      /^0\d{9}$/.test(registrationState.phone) &&
      !phoneError;
    const isBirthDateValid = registrationState.birthDate !== "" && !ageError;
    const isGenderValid = registrationState.gender !== "";
    const isMaritalStatusValid = registrationState.maritalStatus !== "";

    // תקינות הטופס תלויה גם באישור התנאים (אם טרם אושרו)
    const consentRequirementMet = userHasAlreadyConsented || consentChecked;

    setIsFormValid(
      isFirstNameValid &&
        isLastNameValid &&
        isPhoneValid &&
        isBirthDateValid &&
        isGenderValid &&
        isMaritalStatusValid &&
        consentRequirementMet // הוספת דרישת הסכמה
    );
  }, [
    registrationState.firstName,
    registrationState.lastName,
    registrationState.phone,
    registrationState.birthDate,
    registrationState.gender,
    registrationState.maritalStatus,
    firstNameError,
    lastNameError,
    phoneError,
    ageError,
    consentChecked, // הוספת תלות
    userHasAlreadyConsented,
  ]);

  const handleContinue = async () => {
    setGeneralApiError(null); // איפוס שגיאה כללית
    setConsentError(null); // איפוס שגיאת הסכמה

    // ולידציות שדות
    const fnValid = validateFirstName(registrationState.firstName);
    const lnValid = validateLastName(registrationState.lastName);
    const pValid = validatePhone(registrationState.phone);
    const ageValid = validateAge(registrationState.birthDate);
    const genderValid = registrationState.gender !== "";
    const maritalValid = registrationState.maritalStatus !== "";

    if (!fnValid || !lnValid || !pValid || !ageValid || !genderValid || !maritalValid) {
      return; // עצור אם יש שגיאות בשדות
    }

    // בדיקה וטיפול בהסכמה אם נדרש
    if (!userHasAlreadyConsented) {
      if (!consentChecked) {
        setConsentError("חובה לאשר את תנאי השימוש ומדיניות הפרטיות.");
        return;
      }
      setIsSubmittingConsent(true);
      try {
        const consentResponse = await fetch("/api/user/accept-terms", {
          method: "POST",
        });
        const consentResult = await consentResponse.json();
        if (!consentResponse.ok || !consentResult.success) {
          throw new Error(consentResult.error || "שגיאה באישור התנאים.");
        }
        // לאחר אישור מוצלח, עדכן את הסשן (אם צריך)
        await updateSessionHook(); // קריאה לפונקציית העדכון מה-hook
        console.log("Terms accepted via API, session should be updated.");
      } catch (error) {
        setGeneralApiError(
          error instanceof Error ? error.message : "אירעה שגיאה באישור התנאים."
        );
        setIsSubmittingConsent(false);
        return;
      } finally {
        setIsSubmittingConsent(false);
      }
    }

    // אם הגענו לכאן, כל הולידציות עברו וההסכמה (אם נדרשה) טופלה
    nextStep(); // עבור לשלב הבא (OptionalInfoStep)
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.07 } },
  };
  const itemVariants = {
    hidden: { opacity: 0, y: 15 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.4 } },
  };

  return (
    <motion.div
      className="space-y-5"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.h2
        className="text-xl font-semibold text-gray-800 mb-4"
        variants={itemVariants}
      >
        פרטים אישיים חיוניים
      </motion.h2>
      <motion.p className="text-sm text-gray-500 mb-5" variants={itemVariants}>
        אנו צריכים פרטים אלו כדי להמשיך בתהליך ההרשמה שלך.
      </motion.p>

      {generalApiError && (
        <motion.div variants={itemVariants}>
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>שגיאה</AlertTitle>
            <AlertDescription>{generalApiError}</AlertDescription>
          </Alert>
        </motion.div>
      )}

      <motion.div variants={itemVariants} className="space-y-4">
        {/* First Name Field */}
        <div className="space-y-1">
          <label htmlFor="firstNamePersonal" className="block text-sm font-medium text-gray-700">
            שם פרטי <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Edit3 className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="text"
              id="firstNamePersonal"
              value={registrationState.firstName}
              onChange={(e) => updateField("firstName", e.target.value)}
              onBlur={() => validateFirstName(registrationState.firstName)}
              placeholder="לדוגמה: ישראל"
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                firstNameError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {firstNameError && <p className="text-red-500 text-xs mt-1">{firstNameError}</p>}
        </div>

        {/* Last Name Field */}
        <div className="space-y-1">
          <label htmlFor="lastNamePersonal" className="block text-sm font-medium text-gray-700">
            שם משפחה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Edit3 className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="text"
              id="lastNamePersonal"
              value={registrationState.lastName}
              onChange={(e) => updateField("lastName", e.target.value)}
              onBlur={() => validateLastName(registrationState.lastName)}
              placeholder="לדוגמה: ישראלי"
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                lastNameError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {lastNameError && <p className="text-red-500 text-xs mt-1">{lastNameError}</p>}
        </div>

        {/* Phone Field */}
        <div className="space-y-1">
          <label htmlFor="phonePersonal" className="block text-sm font-medium text-gray-700">
            טלפון נייד <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Phone className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="tel"
              id="phonePersonal"
              value={registrationState.phone}
              onChange={(e) => updateField("phone", e.target.value)}
              onBlur={() => validatePhone(registrationState.phone)}
              placeholder=""
              required
              maxLength={10}
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                phoneError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {phoneError && <p className="text-red-500 text-xs mt-1">{phoneError}</p>}
        </div>

        {/* Gender Field */}
        <div className="space-y-1">
          <label className="block text-sm font-medium text-gray-700">
            מגדר <span className="text-red-500">*</span>
          </label>
          <div className="grid grid-cols-2 gap-3 mt-1">
            {([
              { value: Gender.MALE, label: "זכר", icon: "👨" },
              { value: Gender.FEMALE, label: "נקבה", icon: "👩" },
            ] as const).map((genderOption) => (
              <button
                key={genderOption.value}
                type="button"
                onClick={() => updateField("gender", genderOption.value)}
                disabled={isSubmittingConsent}
                className={`flex items-center justify-center gap-2 py-3 rounded-lg border-2 transition-all duration-200 ease-in-out transform hover:scale-105 disabled:opacity-70 disabled:cursor-not-allowed ${
                  registrationState.gender === genderOption.value
                    ? genderOption.value === Gender.MALE
                      ? "border-cyan-500 bg-cyan-50 text-cyan-700 shadow-md"
                      : "border-pink-500 bg-pink-50 text-pink-700 shadow-md"
                    : "border-gray-200 hover:border-gray-300 text-gray-700 bg-white"
                }`}
              >
                <span className="text-xl">{genderOption.icon}</span>
                <span className="font-medium">{genderOption.label}</span>
              </button>
            ))}
          </div>
          {registrationState.gender === "" && <p className="text-red-500 text-xs mt-1">יש לבחור מגדר</p>}
        </div>

        {/* Birth Date Field */}
        <div className="space-y-1">
          <label htmlFor="birthDatePersonal" className="block text-sm font-medium text-gray-700">
            תאריך לידה <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Calendar className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="date"
              id="birthDatePersonal"
              value={registrationState.birthDate}
              onChange={(e) => {
                updateField("birthDate", e.target.value);
                validateAge(e.target.value);
              }}
              onBlur={() => validateAge(registrationState.birthDate)}
              max={new Date(new Date().setFullYear(new Date().getFullYear() - 18)).toISOString().split("T")[0]}
              required
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none transition-colors ${
                ageError ? "border-red-400 focus:ring-red-200" : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
              disabled={isSubmittingConsent}
            />
          </div>
          {ageError && <p className="text-red-500 text-xs mt-1">{ageError}</p>}
        </div>

        {/* Marital Status Field */}
        <div className="space-y-1">
          <label htmlFor="maritalStatusPersonal" className="block text-sm font-medium text-gray-700">
            מצב משפחתי <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <Users className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <select
              id="maritalStatusPersonal"
              value={registrationState.maritalStatus}
              onChange={(e) => updateField("maritalStatus", e.target.value)}
              required
              disabled={isSubmittingConsent}
              className={`w-full pr-10 pl-3 py-3 border rounded-lg focus:ring-2 focus:outline-none appearance-none bg-white transition-colors disabled:opacity-70 disabled:cursor-not-allowed ${
                registrationState.maritalStatus === "" && false // Not a real error condition for select, just placeholder
                  ? "border-red-400 focus:ring-red-200"
                  : "border-gray-300 focus:ring-cyan-200 focus:border-cyan-500"
              }`}
            >
              <option value="" disabled>בחר/י מצב משפחתי...</option>
              <option value="רווק/ה">רווק/ה</option>
              <option value="גרוש/ה">גרוש/ה</option>
              <option value="אלמן/ה">אלמן/ה</option>
            </select>
            <div className="absolute left-3 top-1/2 transform -translate-y-1/2 pointer-events-none">
              <svg className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7" />
              </svg>
            </div>
          </div>
          {registrationState.maritalStatus === "" && <p className="text-red-500 text-xs mt-1">יש לבחור מצב משפחתי</p>}
        </div>
      </motion.div>

      {/* Consent Checkbox - מוצג רק אם המשתמש טרם אישר */}
      {!userHasAlreadyConsented && (
        <motion.div variants={itemVariants} className="mt-6 pt-4 border-t border-gray-100">
          <ConsentCheckbox
            checked={consentChecked}
            onChange={(isChecked) => {
              setConsentChecked(isChecked);
              if (isChecked) setConsentError(null);
            }}
            error={consentError}
          />
        </motion.div>
      )}

      <motion.div
        variants={itemVariants}
        className="flex justify-between items-center pt-5 mt-6 border-t border-gray-200"
      >
        <Button
          onClick={prevStep}
          variant="outline"
          className="flex items-center gap-2 border-gray-300 text-gray-700 hover:bg-gray-50"
          disabled={isSubmittingConsent || (registrationState.step === 0 && !registrationState.isCompletingProfile)}
        >
          <ArrowRight className="h-4 w-4" />
          חזרה
        </Button>

        <Button
          onClick={handleContinue}
          disabled={!isFormValid || isSubmittingConsent}
          className={`flex items-center gap-2 px-6 py-3 rounded-lg font-semibold text-white transition-all duration-300
            ${
              isFormValid && !isSubmittingConsent
                ? "bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg hover:shadow-xl transform hover:scale-105"
                : "bg-gray-300 cursor-not-allowed"
            }`}
        >
          {isSubmittingConsent ? (
            <>
              <Loader2 className="h-5 w-5 animate-spin mr-2" />
              <span>מאשר תנאים...</span>
            </>
          ) : (
            <>
              <span>המשך לשלב הבא</span>
              <ArrowLeft className="h-4 w-4" />
            </>
          )}
        </Button>
      </motion.div>
    </motion.div>
  );
};

export default PersonalDetailsStep;
--- End of Content for PersonalDetailsStep.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\auth\steps\WelcomeStep.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import { useState } from "react";
import { useRegistration } from "../RegistrationContext";
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Heart, ArrowLeft, Mail } from "lucide-react";
import Link from "next/link";

const WelcomeStep: React.FC = () => {
  const { nextStep,  } = useRegistration();
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);

  const handleGoogleSignIn = async () => {
    try {
      setIsGoogleLoading(true);

      // Store this information for potential fallback
      localStorage.setItem("registration_started", "true");

      // Use NextAuth to handle Google sign-in
      // The redirect/callback will be handled by NextAuth
      await signIn("google", { callbackUrl: "/auth/google-callback" });
    } catch (error) {
      console.error("Google sign-in error:", error);
      setIsGoogleLoading(false);
    }
  };

  const handleEmailSignUp = () => {
    nextStep();
  };

  return (
    <div className="space-y-6 text-center">
      {/* Welcome animation */}
      <div className="flex justify-center mb-4">
        <div className="relative">
          <div className="w-20 h-20 rounded-full bg-pink-100 flex items-center justify-center animate-pulse">
            <Heart className="h-10 w-10 text-pink-500 fill-pink-500" />
          </div>
          <div className="absolute -top-2 -right-2 w-8 h-8 rounded-full bg-cyan-500 flex items-center justify-center text-white font-bold animate-bounce">
            <span className="text-sm">👋</span>
          </div>
        </div>
      </div>

      <h2 className="text-2xl font-bold text-gray-800">ברוכים הבאים!</h2>

      <p className="text-gray-600 max-w-sm mx-auto">
        אנחנו שמחים שבחרת להצטרף אלינו. בואו נתחיל בתהליך הרשמה קצר ופשוט שיאפשר
        לנו להכיר אותך טוב יותר.
      </p>

      {/* Buttons */}
      <div className="space-y-4 mt-8">
        <Button
          onClick={handleGoogleSignIn}
          disabled={isGoogleLoading}
          variant="outline"
          size="lg"
          className="w-full relative border-2 border-gray-300 hover:border-gray-400 py-6 rounded-xl flex items-center justify-center gap-3 group"
        >
          {isGoogleLoading ? (
            <div className="animate-spin h-5 w-5 border-2 border-gray-500 rounded-full border-t-transparent" />
          ) : (
            <>
              <svg className="h-5 w-5" viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  fill="#4285F4"
                />
                <path
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  fill="#34A853"
                />
                <path
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  fill="#FBBC05"
                />
                <path
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  fill="#EA4335"
                />
              </svg>
              <span className="text-gray-700 font-medium">המשך עם Google</span>
            </>
          )}
        </Button>

        <Button
          onClick={handleEmailSignUp}
          size="lg"
          className="w-full py-6 rounded-xl bg-gradient-to-r from-cyan-500 to-pink-500 hover:from-cyan-600 hover:to-pink-600 shadow-lg flex items-center justify-center gap-3 group relative overflow-hidden"
        >
          {/* Button background shimmer effect */}
          <span className="absolute inset-0 w-full h-full bg-gradient-to-r from-white/0 via-white/30 to-white/0 transform -translate-x-full group-hover:animate-shimmer"></span>
          <Mail className="h-5 w-5 text-white" />
          <span className="text-white font-medium">המשך עם אימייל</span>
          <ArrowLeft className="h-5 w-5 text-white opacity-0 group-hover:opacity-100 transition-opacity" />
        </Button>
      </div>

      {/* Already have an account link */}
      <div className="mt-8 pt-4 border-t border-gray-200">
        <p className="text-gray-600 text-sm">
          כבר יש לך חשבון?{" "}
          <Link
            href="/auth/signin"
            className="text-cyan-600 font-medium hover:text-cyan-700 hover:underline"
          >
            התחברות
          </Link>
        </p>
      </div>
    </div>
  );
};

export default WelcomeStep;
--- End of Content for WelcomeStep.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\MatchmakerEditProfile.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/MatchmakerEditProfile.tsx

import React, { useState, useEffect, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { toast } from "sonner";
import { ProfileSection } from "@/app/components/profile";
import { PhotosSection } from "@/app/components/profile";
import { PreferencesSection } from "@/app/components/profile";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Loader2, X, UserCog, Image as ImageIcon, Sliders, Trash2, AlertCircle, Send } from "lucide-react";
import type { UserProfile, UserImage } from "@/types/next-auth";
import type { Candidate } from "./types/candidates";
import { motion } from "framer-motion";
import { useSession } from "next-auth/react";

interface MatchmakerEditProfileProps {
  isOpen: boolean;
  onClose: () => void;
  candidate: Candidate | null;
  onCandidateDeleted?: (candidateId: string) => void; 
}

const DELETE_CANDIDATE_CONFIRMATION_PHRASE = "אני מאשר מחיקה";

const MatchmakerEditProfile: React.FC<MatchmakerEditProfileProps> = ({
  isOpen,
  onClose,
  candidate,
  onCandidateDeleted,
}) => {
  const { data: session } = useSession();
  const isAdmin = session?.user?.role === "ADMIN";

  const [activeTab, setActiveTab] = useState("profile");
  const [isEditing, setIsEditing] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [images, setImages] = useState<UserImage[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // States for delete candidate confirmation
  const [isDeleteCandidateDialogOpen, setIsDeleteCandidateDialogOpen] = useState(false);
  const [deleteCandidateConfirmText, setDeleteCandidateConfirmText] = useState("");
  const [isDeletingCandidate, setIsDeletingCandidate] = useState(false);

  // --- NEW: States for Account Setup Invite ---
  const [isSetupInviteOpen, setIsSetupInviteOpen] = useState(false);
  const [inviteEmail, setInviteEmail] = useState("");
  const [isSendingInvite, setIsSendingInvite] = useState(false);
  // --- END NEW ---

  const fetchProfileData = useCallback(async () => {
    if (!candidate) return;
    setIsLoading(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}`);
      if (!response.ok) throw new Error("Failed to fetch candidate profile");
      const data = await response.json();
      if (data.success) {
        setProfile(data.profile);
        setImages(data.images || []);
        // --- NEW: Populate email for invite dialog ---
        // Check if the email is a real one, not a placeholder
        if (candidate.email && !candidate.email.endsWith('@shidduch.placeholder.com')) {
          setInviteEmail(candidate.email);
        } else {
          setInviteEmail(""); // Clear if it's a placeholder
        }
        // --- END NEW ---
      } else {
        throw new Error(data.error || "Failed to load profile data");
      }
    } catch (error) {
      console.error("Error fetching profile:", error);
      toast.error("שגיאה בטעינת נתוני המועמד");
    } finally {
      setIsLoading(false);
    }
  }, [candidate]);

  useEffect(() => {
    if (isOpen && candidate) {
      fetchProfileData();
    } else if (!isOpen) {
      setProfile(null);
      setImages([]);
      setActiveTab("profile");
      setIsLoading(true);
      setDeleteCandidateConfirmText("");
      setIsDeleteCandidateDialogOpen(false);
      // --- NEW: Reset invite state on close ---
      setIsSetupInviteOpen(false);
      setInviteEmail("");
      setIsSendingInvite(false);
      // --- END NEW ---
    }
  }, [isOpen, candidate, fetchProfileData]);

  const handleProfileUpdate = async (updatedProfile: Partial<UserProfile>) => {
    if (!candidate || !profile) return;
    setIsSaving(true);
    try {
      const cleanedProfile = { ...updatedProfile };
      if (cleanedProfile.gender === undefined) { /* Keep undefined */ }
      if (cleanedProfile.preferredMatchmakerGender === undefined) { /* Keep undefined */ }

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(cleanedProfile),
        }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to update profile");
      }
      setProfile(prevProfile => ({ ...prevProfile, ...cleanedProfile } as UserProfile));
      toast.success("פרופיל המועמד עודכן בהצלחה", { position: "top-center", duration: 3000 });
    } catch (error) {
      console.error("Error updating profile:", error);
      toast.error(
        "שגיאה בעדכון פרופיל המועמד: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"),
        { duration: 5000 }
      );
    } finally {
      setIsSaving(false);
    }
  };

  const handleImageUpload = async (file: File) => {
    if (!candidate) return;
    setIsUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      formData.append("userId", candidate.id);

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images`,
        { method: "POST", body: formData }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to upload image");
      }
      setImages((prev) => [...prev, data.image]);
      toast.success("התמונה הועלתה בהצלחה");
    } catch (error) {
      console.error("Error uploading image:", error);
      toast.error("שגיאה בהעלאת התמונה");
    } finally {
      setIsUploading(false);
    }
  };

  const handleSetMainImage = async (imageId: string) => {
    if (!candidate) return;
    try {
      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}/main`,
        { method: "PATCH" }
      );
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to set main image");
      }
      setImages((prev) => prev.map((img) => ({ ...img, isMain: img.id === imageId })));
      toast.success("התמונה הראשית עודכנה בהצלחה");
    } catch (error) {
      console.error("Error setting main image:", error);
      toast.error("שגיאה בעדכון התמונה הראשית");
    }
  };

  const handleDeleteImage = async (imageId: string) => {
    if (!candidate) return;
    setIsUploading(true);
    try {
      const isMainImage = images.find((img) => img.id === imageId)?.isMain;
      let nextMainImageId: string | undefined;
      if (isMainImage) {
        nextMainImageId = images.find((img) => img.id !== imageId)?.id;
      }

      const response = await fetch(
        `/api/matchmaker/candidates/${candidate.id}/images/${imageId}`,
        { method: "DELETE" }
      );

      if (response.status === 204) {
         setImages((prev) => prev.filter((img) => img.id !== imageId));
         if (isMainImage && nextMainImageId) {
           await handleSetMainImage(nextMainImageId);
         }
         toast.success("התמונה נמחקה בהצלחה", { position: "top-center" });
         return;
      }

      const data = await response.json();
      if (!response.ok || !data.success) {
        const errorText = data.error || await response.text();
        throw new Error(`שגיאה במחיקת התמונה: ${errorText}`);
      }
      
      setImages((prev) => prev.filter((img) => img.id !== imageId));
      if (isMainImage && nextMainImageId) {
        await handleSetMainImage(nextMainImageId);
      }
      toast.success("התמונה נמחקה בהצלחה", { position: "top-center" });

    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה במחיקת התמונה");
    } finally {
      setIsUploading(false);
    }
  };

  const handleDeleteCandidateRequest = async () => {
    if (!candidate) return;
    if (deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE) {
      toast.error("אישור לא תקין", { description: `נא להקליד "${DELETE_CANDIDATE_CONFIRMATION_PHRASE}" בדיוק כדי לאשר מחיקה.` });
      return;
    }
    setIsDeletingCandidate(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}`, { method: "DELETE" });
      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || "Failed to delete candidate profile");
      }

      toast.success("המועמד נמחק בהצלחה", { position: "top-center", duration: 3000 });
      if (onCandidateDeleted) {
        onCandidateDeleted(candidate.id);
      }
      setIsDeleteCandidateDialogOpen(false);
      onClose();
    } catch (error) {
      console.error("Error deleting candidate:", error);
      toast.error("שגיאה במחיקת המועמד: " + (error instanceof Error ? error.message : "שגיאה לא ידועה"), { duration: 5000 });
    } finally {
      setIsDeletingCandidate(false);
    }
  };
  
  // --- NEW: Handler for sending setup invite ---
  const handleSendSetupInvite = async () => {
    if (!candidate || !inviteEmail) {
      toast.error("נא להזין כתובת אימייל תקינה.");
      return;
    }
    setIsSendingInvite(true);
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}/invite-setup`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: inviteEmail }),
      });
      const result = await response.json();
      if (!response.ok || !result.success) {
        throw new Error(result.error || 'שגיאה בשליחת ההזמנה.');
      }
      toast.success("הזמנה להגדרת חשבון נשלחה בהצלחה!");
      setIsSetupInviteOpen(false);
    } catch (error) {
      console.error("Error sending setup invite:", error);
      toast.error(error instanceof Error ? error.message : "שגיאה בשליחת ההזמנה.");
    } finally {
      setIsSendingInvite(false);
    }
  };
  // --- END NEW ---

  if (!candidate && isOpen) return null;
  if (!candidate) return null;

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-5xl max-h-[90vh] p-0 overflow-hidden">
          {isLoading && !profile ? (
            <div className="flex items-center justify-center h-64"><Loader2 className="w-10 h-10 animate-spin text-primary" /></div>
          ) : (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }} className="flex flex-col h-full max-h-[90vh]">
              <DialogHeader className="p-6 border-b">
                <div className="flex items-center justify-between">
                  <div>
                    <DialogTitle className="text-2xl font-bold text-primary/90">עריכת פרופיל - {candidate.firstName} {candidate.lastName}</DialogTitle>
                    <DialogDescription className="text-gray-500 mt-1">עריכת פרטי המועמד והעדפותיו במערכת</DialogDescription>
                  </div>
                  {isSaving && <div className="flex items-center bg-blue-50 text-blue-700 py-1 px-2 rounded-full text-sm"><Loader2 className="w-3 h-3 animate-spin mr-1" />שומר שינויים...</div>}
                </div>
              </DialogHeader>

              <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col min-h-0">
                <div className="px-6 pt-4">
                  <TabsList className="w-full bg-muted/30 p-1 rounded-xl shadow-sm">
                    <TabsTrigger value="profile" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <UserCog className="w-4 h-4" />פרטים אישיים
                    </TabsTrigger>
                    <TabsTrigger value="photos" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <ImageIcon className="w-4 h-4" />תמונות
                    </TabsTrigger>
                    <TabsTrigger value="preferences" className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white flex items-center gap-2">
                      <Sliders className="w-4 h-4" />העדפות
                    </TabsTrigger>
                  </TabsList>
                </div>

                <div className="flex-1 overflow-hidden flex flex-col min-h-0">
                  <TabsContent value="profile" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    {profile ? <div className="bg-white rounded-xl shadow-sm border"><ProfileSection profile={profile} isEditing={isEditing} setIsEditing={setIsEditing} onSave={handleProfileUpdate} /></div> : <div className="flex items-center justify-center h-full"><Loader2 className="w-8 h-8 animate-spin text-muted-foreground" /></div>}
                  </TabsContent>
                  <TabsContent value="photos" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    <div className="bg-white rounded-xl shadow-sm border"><PhotosSection images={images} isUploading={isUploading} disabled={isSaving || isDeletingCandidate} onUpload={handleImageUpload} onSetMain={handleSetMainImage} onDelete={handleDeleteImage} maxImages={10} /></div>
                  </TabsContent>
                  <TabsContent value="preferences" className="flex-1 overflow-auto p-4 m-0 pb-16">
                    {profile ? <div className="bg-white rounded-xl shadow-sm border"><PreferencesSection profile={profile} isEditing={isEditing} setIsEditing={setIsEditing} onChange={handleProfileUpdate} /></div> : <div className="flex items-center justify-center h-full"><Loader2 className="w-8 h-8 animate-spin text-muted-foreground" /></div>}
                  </TabsContent>
                </div>
              </Tabs>

              <div className="p-4 border-t flex justify-between items-center mt-auto bg-white/80 backdrop-blur-sm sticky bottom-0">
                <div>
                  <span className="text-sm text-muted-foreground">{activeTab === "profile" ? "עריכת פרטים אישיים" : activeTab === "photos" ? "ניהול תמונות" : "עריכת העדפות"}</span>
                </div>
                <div className="flex items-center gap-3">
                  <Button variant="outline" onClick={() => setIsSetupInviteOpen(true)} disabled={isSaving || isDeletingCandidate || isSendingInvite}>
                    <Send className="w-4 h-4 ml-2" />
                    שלח הזמנה לניהול החשבון
                  </Button>
                  {isAdmin && <Button variant="destructive" onClick={() => setIsDeleteCandidateDialogOpen(true)} disabled={isSaving || isUploading || isDeletingCandidate} size="sm"><Trash2 className="w-4 h-4 mr-2" />מחק מועמד</Button>}
                  <Button variant="outline" onClick={onClose} disabled={isSaving || isDeletingCandidate} className="bg-white hover:bg-gray-100 transition-colors shadow-sm" size="sm"><X className="w-4 h-4 mr-2" />סגור</Button>
                </div>
              </div>
            </motion.div>
          )}
        </DialogContent>
      </Dialog>
      
      {/* --- NEW: Invite Setup Dialog --- */}
      {candidate && (
        <Dialog open={isSetupInviteOpen} onOpenChange={setIsSetupInviteOpen}>
            <DialogContent className="sm:max-w-md">
                <DialogHeader>
                    <DialogTitle>הזמנת מועמד לניהול החשבון</DialogTitle>
                    <DialogDescription>
                        שלח הזמנה ל<strong>{candidate.firstName} {candidate.lastName}</strong> להגדיר סיסמה ולקחת שליטה על הפרופיל.
                    </DialogDescription>
                </DialogHeader>
                <div className="grid gap-4 py-4">
                    <Label htmlFor="inviteEmail" className="text-right">
                        כתובת אימייל
                    </Label>
                    <Input
                        id="inviteEmail"
                        type="email"
                        value={inviteEmail}
                        onChange={(e) => setInviteEmail(e.target.value)}
                        placeholder="user@example.com"
                        className="col-span-3"
                        dir="ltr"
                    />
                </div>
                <DialogFooter>
                    <DialogClose asChild>
                        <Button type="button" variant="secondary" disabled={isSendingInvite}>ביטול</Button>
                    </DialogClose>
                    <Button type="button" onClick={handleSendSetupInvite} disabled={isSendingInvite || !inviteEmail}>
                        {isSendingInvite ? <Loader2 className="ml-2 h-4 w-4 animate-spin" /> : <Send className="ml-2 h-4 w-4" />}
                        {isSendingInvite ? "שולח..." : "שלח הזמנה"}
                    </Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
      )}
      {/* --- END NEW --- */}

      {/* Delete Candidate Confirmation Dialog */}
      {candidate && (
        <Dialog open={isDeleteCandidateDialogOpen} onOpenChange={(open) => !isDeletingCandidate && setIsDeleteCandidateDialogOpen(open)}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle className="text-xl flex items-center gap-2 text-red-600"><AlertCircle className="h-5 w-5" />אישור מחיקת מועמד</DialogTitle>
              <DialogDescription>האם אתה בטוח שברצונך למחוק את המועמד <strong>{candidate.firstName} {candidate.lastName}</strong>? פעולה זו הינה בלתי הפיכה ותסיר את כל נתוני המועמד מהמערכת.</DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
              <Label htmlFor="deleteCandidateConfirm" className="text-gray-700">לאישור המחיקה, אנא הקלד: <strong className="text-red-700">{DELETE_CANDIDATE_CONFIRMATION_PHRASE}</strong></Label>
              <Input id="deleteCandidateConfirm" value={deleteCandidateConfirmText} onChange={(e) => setDeleteCandidateConfirmText(e.target.value)} disabled={isDeletingCandidate} className="border-gray-300 focus:border-red-500" placeholder={DELETE_CANDIDATE_CONFIRMATION_PHRASE} dir="rtl" />
              {deleteCandidateConfirmText && deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE && (<p className="text-xs text-red-600">הטקסט שהוקלד אינו תואם.</p>)}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => { setIsDeleteCandidateDialogOpen(false); setDeleteCandidateConfirmText(""); }} disabled={isDeletingCandidate} className="border-gray-300">ביטול</Button>
              <Button variant="destructive" onClick={handleDeleteCandidateRequest} disabled={isDeletingCandidate || deleteCandidateConfirmText !== DELETE_CANDIDATE_CONFIRMATION_PHRASE}>
                {isDeletingCandidate ? (<span className="flex items-center gap-2"><Loader2 className="w-4 h-4 animate-spin" />מוחק...</span>) : (<><Trash2 className="w-4 h-4 mr-2" />מחק מועמד לצמיתות</>)}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </>
  );
};

export default MatchmakerEditProfile;
--- End of Content for MatchmakerEditProfile.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\Actions.tsx
--------------------------------------------------------------------------------
Content:
// /components/matchmaker/CandidateCard/Actions.tsx

"use client";

import React from "react";

import { Button } from "@/components/ui/button";
import { Heart, Mail, FileText, Eye, Clock } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface ActionsProps {
  candidate: Candidate;
  onInvite: (candidate: Candidate) => void;
  onSuggest: (candidate: Candidate) => void;
  onCheckAvailability: (candidate: Candidate) => void;
  onViewProfile: (candidate: Candidate) => void;
  className?: string;
}

const Actions: React.FC<ActionsProps> = ({
  candidate,
  onInvite,
  onSuggest,
  onCheckAvailability,
  onViewProfile,
  className,
}) => {
  // מונע התפשטות הקליק לכרטיס המינימלי
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  return (
    <div className={`flex flex-wrap gap-2 ${className}`} onClick={handleClick}>
      <Button
        variant="outline"
        size="sm"
        onClick={() => onViewProfile(candidate)}
      >
        <Eye className="w-4 h-4 ml-2" />
        צפייה בפרופיל
      </Button>

      <Button variant="outline" size="sm" onClick={() => onInvite(candidate)}>
        <Mail className="w-4 h-4 ml-2" />
        שליחת הזמנה
      </Button>

      <Button variant="outline" size="sm" onClick={() => onSuggest(candidate)}>
        <FileText className="w-4 h-4 ml-2" />
        הצעת שידוך
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => onCheckAvailability(candidate)}
      >
        <Clock className="w-4 h-4 ml-2" />
        בדיקת זמינות
      </Button>

      <Button
        variant="ghost"
        size="sm"
        className="text-red-600 hover:text-red-700 hover:bg-red-50"
      >
        <Heart className="w-4 h-4" />
      </Button>
    </div>
  );
};

export default Actions;
--- End of Content for Actions.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\MinimalCard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/CandidateCard/MinimalCard.tsx

"use client";

import React, { useState } from "react";
import Image from "next/image";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { User, MapPin, Briefcase, Calendar, Edit2, Sparkles, Star } from "lucide-react";
import type { Candidate } from "../types/candidates";
import { UserSource } from "@prisma/client";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import { motion } from "framer-motion";
import { Skeleton } from "@/components/ui/skeleton";
import { cn } from "@/lib/utils";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";


interface MinimalCandidateCardProps {
  candidate: Candidate;
  onClick: (candidate: Candidate) => void;
  onEdit?: (candidate: Candidate, e: React.MouseEvent) => void;
  isHighlighted?: boolean;
  highlightTerm?: string;
  className?: string;
  
  // --- AI-Related Props ---
  aiScore?: number;
  isAiTarget?: boolean;
  onSetAiTarget?: (candidate: Candidate, e: React.MouseEvent) => void;
  isSelectableForComparison?: boolean;
  isSelectedForComparison?: boolean;
  onToggleComparison?: (candidate: Candidate, e: React.MouseEvent) => void;
}

const calculateAge = (birthDate: Date | string): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const MinimalCandidateCard: React.FC<MinimalCandidateCardProps> = ({
  candidate,
  onClick,
  onEdit,
  isHighlighted = false,
  highlightTerm = "",
  className,
  aiScore,
  isAiTarget = false,
  onSetAiTarget,
  isSelectableForComparison = false,
  isSelectedForComparison = false,
  onToggleComparison,
}) => {
  const mainImage = candidate.images.find((img) => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);

  const highlightText = (text: string | undefined | null): React.ReactNode => {
    if (!highlightTerm || !text) return text;
    const parts = text.split(new RegExp(`(${highlightTerm})`, "gi"));
    return (
      <>
        {parts.map((part, i) =>
          part.toLowerCase() === highlightTerm.toLowerCase() ? (
            <mark key={i} className="bg-yellow-200 px-0.5 rounded-sm">
              {part}
            </mark>
          ) : (
            part
          )
        )}
      </>
    );
  };

  const getAvailabilityBadge = () => {
    switch (candidate.profile.availabilityStatus) {
      case "AVAILABLE": return { label: "פנוי/ה", className: "bg-emerald-100 text-emerald-800 border-emerald-200" };
      case "DATING": return { label: "בתהליך הכרות", className: "bg-amber-100 text-amber-800 border-amber-200" };
      case "UNAVAILABLE": return { label: "לא פנוי/ה", className: "bg-red-100 text-red-800 border-red-200" };
      default: return { label: "לא ידוע", className: "bg-gray-100 text-gray-800 border-gray-200" };
    }
  };

  const availabilityBadge = getAvailabilityBadge();
  const isManualEntry = candidate.source === UserSource.MANUAL_ENTRY;

  return (
    <motion.div
      whileHover={{ y: -4 }}
      transition={{ type: "spring", stiffness: 300, damping: 15 }}
    >
      <Card
        className={cn(
          "relative overflow-hidden cursor-pointer transition-all hover:shadow-lg duration-300 group border-2",
          isAiTarget ? "border-green-500 shadow-lg" : 
          isSelectedForComparison ? "border-blue-500 shadow-md" :
          typeof aiScore === 'number' ? "border-teal-400/50" :
          isHighlighted ? "border-yellow-400" :
          "border-gray-200",
          className || ""
        )}
        onClick={() => onClick(candidate)}
      >
        {/* --- Top-left Badges Area --- */}
        <div className="absolute top-2 left-2 z-20 flex flex-col items-start gap-1.5">
          {typeof aiScore === 'number' && (
            <Badge className="bg-gradient-to-r from-teal-400 to-cyan-500 text-white border-0 shadow-lg px-2.5 py-1 text-xs font-bold flex items-center gap-1.5 animate-pulse-slow">
              <Sparkles className="w-3.5 h-3.5" />
              {aiScore}% התאמה
            </Badge>
          )}
        </div>

        {/* --- Top-right Badges Area --- */}
        <div className="absolute top-2 right-2 z-10 flex flex-col gap-1 items-end">
          <Badge variant="outline" className={`px-2 py-0.5 text-xs font-medium shadow-sm ${availabilityBadge.className}`}>
            {availabilityBadge.label}
          </Badge>
          {isManualEntry && (
            <Badge variant="outline" className="px-2 py-0.5 text-xs font-medium shadow-sm bg-purple-100 text-purple-800 border-purple-200 flex items-center gap-1">
              <Edit2 className="w-2.5 h-2.5" /> מועמד ידני
            </Badge>
          )}
        </div>

        <div className="relative h-48 sm:h-56 bg-gradient-to-b from-blue-50 to-blue-100">
          {mainImage && !imageError ? (
            <>
              {!imageLoaded && <Skeleton className="absolute inset-0 h-full w-full" />}
              <Image
                src={mainImage.url}
                alt={`${candidate.firstName} ${candidate.lastName}`}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                priority={false}
                className={`object-cover transition-opacity duration-300 ${imageLoaded ? "opacity-100" : "opacity-0"}`}
                onLoad={() => setImageLoaded(true)}
                onError={() => setImageError(true)}
              />
              <div className="absolute inset-0 bg-gradient-to-t from-gray-900/80 via-gray-900/40 to-transparent" />
            </>
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-blue-50">
              <User className="w-20 h-20 text-gray-400" />
            </div>
          )}

          <div className="absolute bottom-0 w-full p-3 text-right">
            <h3 className="font-bold mb-0.5 text-white drop-shadow-md text-lg">
              {highlightText(`${candidate.firstName} ${candidate.lastName}`)}
            </h3>
            <div className="flex items-center justify-end gap-2 text-white/90 text-sm">
              <span>{age}</span>
              <Calendar className="w-3 h-3" />
            </div>
          </div>
        </div>

        <div className="p-4">
          <div className="space-y-1.5 text-gray-700 text-sm">
            {isManualEntry && candidate.profile.manualEntryText ? (
              <p className="line-clamp-3 text-gray-600 text-sm leading-relaxed">
                {highlightText(candidate.profile.manualEntryText)}
              </p>
            ) : (
              <>
                {candidate.profile.city && (
                  <div className="flex items-center justify-end gap-1">
                    <span className="font-medium">{highlightText(candidate.profile.city)}</span>
                    <MapPin className="w-4 h-4 text-blue-600" />
                  </div>
                )}
                {candidate.profile.occupation && (
                  <div className="flex items-center justify-end gap-1">
                    <span>{highlightText(candidate.profile.occupation)}</span>
                    <Briefcase className="w-4 h-4 text-blue-600" />
                  </div>
                )}
              </>
            )}
            {candidate.profile.lastActive && (
              <div className="flex items-center justify-end gap-1 mt-2 text-xs text-gray-400">
                <span>{`פעיל/ה ${formatDistanceToNow(new Date(candidate.profile.lastActive), { addSuffix: true, locale: he })}`}</span>
                <Edit2 className="w-3 h-3" />
              </div>
            )}
          </div>
        </div>

        {/* --- Bottom Action Buttons --- */}
        <div className="absolute bottom-2 left-2 z-10 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
          {onEdit && (
            <Button variant="outline" size="icon" className="h-8 w-8 bg-white/80 backdrop-blur-sm shadow-md" onClick={(e) => onEdit(candidate, e)} title="ערוך פרופיל">
              <Edit2 className="h-4 w-4 text-blue-600" />
            </Button>
          )}
          {onSetAiTarget && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                   <Button variant="outline" size="icon" className={cn("h-8 w-8 bg-white/80 backdrop-blur-sm shadow-md", isAiTarget && "bg-green-200")} onClick={(e) => onSetAiTarget(candidate, e)}>
                      <Star className={cn("h-4 w-4", isAiTarget ? "text-green-600 fill-current" : "text-gray-500")} />
                   </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{isAiTarget ? "בטל בחירת מטרה" : "בחר כמטרה לחיפוש AI"}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}
        </div>
        
      {/* --- Comparison Checkbox --- */}
      {isSelectableForComparison && onToggleComparison && (
          <div 
              className="absolute bottom-2 right-2 z-10 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity"
              onClick={(e) => {
                  e.stopPropagation(); // מונע את הקליק על הכרטיס
                  onToggleComparison(candidate, e); // מפעיל את הפונקציה הנכונה
              }}
          >
              <div 
                  className="flex items-center space-x-2 bg-white/80 backdrop-blur-sm p-1.5 rounded-md shadow-md cursor-pointer"
              >
                  <Checkbox
                      id={`compare-${candidate.id}`}
                      checked={isSelectedForComparison}
                      // --- START OF FIX ---
                      // הסרת readOnly והוספת pointer-events-none
                      // זה הופך את ה-Checkbox לויזואלי בלבד, והקליק מטופל ב-div החיצוני
                      className="pointer-events-none"
                      // --- END OF FIX ---
                  />
                  <label
                      htmlFor={`compare-${candidate.id}`}
                      className="text-xs font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 text-gray-700 cursor-pointer"
                  >
                      השווה
                  </label>
              </div>
          </div>
      )}
      </Card>
    </motion.div>
  );
};

export default MinimalCandidateCard;
--- End of Content for MinimalCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidateCard\QuickView.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidateCard/QuickView.tsx

"use client";
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  Mail,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  User,
  FileText,
  CalendarClock,
  Edit,
  Info,
  Star, // הוספת ייבוא לכוכב
} from "lucide-react";

import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";
import { UserSource } from "@prisma/client";
import { cn } from "@/lib/utils"; // הוספת ייבוא עבור cn

// פונקציה לחישוב גיל
const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

interface QuickViewProps {
  candidate: Candidate;
  onAction: (
    action: "view" | "invite" | "suggest" | "contact" | "favorite" | "edit"
  ) => void;
  // --- Props חדשים עבור AI ---
  onSetAiTarget?: (candidate: Candidate, e: React.MouseEvent) => void;
  isAiTarget?: boolean;
}

const QuickView: React.FC<QuickViewProps> = ({ 
  candidate, 
  onAction,
  onSetAiTarget,
  isAiTarget = false 
}) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = candidate.profile;
  const isManualEntry = candidate.source === UserSource.MANUAL_ENTRY;

  return (
    <div
      className="bg-white shadow-xl flex flex-col border border-gray-200 overflow-hidden max-w-md sm:max-w-lg w-full rounded-lg"
      onClick={handleClick}
    >
      {/* Header with name and avatar */}
      <div className="px-6 py-4 bg-gradient-to-r from-blue-500 to-blue-600 border-b text-white">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Badge className="bg-white text-blue-700 border-0 font-medium shadow-sm px-3 py-1">
              {profile.availabilityStatus === "AVAILABLE"
                ? "פנוי/ה"
                : profile.availabilityStatus === "DATING"
                ? "בתהליך הכרות"
                : profile.availabilityStatus === "UNAVAILABLE"
                ? "לא פנוי/ה"
                : "לא ידוע"}
            </Badge>
            {isManualEntry && (
              <Badge className="bg-purple-200 text-purple-800 border-0 font-medium shadow-sm px-3 py-1">
                מועמד ידני
              </Badge>
            )}
          </div>
          
          <div className="flex items-center gap-2">
            {onSetAiTarget && (
              <Button
                size="icon"
                variant="ghost"
                className="h-8 w-8 text-white hover:bg-white/20"
                onClick={(e) => onSetAiTarget(candidate, e)}
                title={isAiTarget ? "בטל בחירת מטרה" : "בחר כמטרה לחיפוש AI"}
              >
                <Star className={cn("h-5 w-5", isAiTarget ? "fill-current text-yellow-300" : "text-white/80")} />
              </Button>
            )}
            <h3 className="text-lg font-bold">
              {candidate.firstName} {candidate.lastName}
            </h3>
          </div>
        </div>
      </div>

      {/* Main content container */}
      <div className="flex-1 p-6 space-y-6 text-right overflow-y-auto max-h-[calc(80vh-200px)] sm:max-h-96 bg-white">
        {/* Key information section */}
        <div className="grid grid-cols-2 gap-y-4 gap-x-6">
          {profile.birthDate && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">
                {calculateAge(new Date(profile.birthDate))} שנים
              </span>
              <CalendarClock className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.height && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.height} ס״מ</span>
              <User className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.maritalStatus}</span>
              <Heart className="w-5 h-5 text-blue-500" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-3 text-sm">
              <span className="font-medium">{profile.religiousLevel}</span>
              <Scroll className="w-5 h-5 text-blue-500" />
            </div>
          )}
        </div>

        <Separator className="my-4 bg-gray-200" />

        {/* Manual Entry Text (if applicable) */}
        {isManualEntry && profile.manualEntryText && (
          <div className="space-y-3">
            <div className="flex items-center justify-end gap-2">
              <h4 className="text-sm font-bold text-gray-600">
                תיאור ידני מהשדכן
              </h4>
              <Info className="w-5 h-5 text-purple-500" />
            </div>
            <p className="text-sm leading-relaxed py-3 px-4 bg-purple-50 rounded-md border border-purple-200 shadow-sm whitespace-pre-wrap">
              {profile.manualEntryText}
            </p>
          </div>
        )}

        {/* Education & Occupation (if not manual entry, or if manual entry but these fields are filled) */}
        {(!isManualEntry ||
          (isManualEntry &&
            (profile.education || profile.occupation || profile.city))) && (
          <div className="space-y-4">
            <h4 className="text-sm font-bold text-gray-600 mb-3">מידע נוסף</h4>
            {profile.education && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md">
                <span className="font-medium">{profile.education}</span>
                <GraduationCap className="w-5 h-5 text-blue-500" />
              </div>
            )}

            {profile.occupation && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
                <span className="font-medium">{profile.occupation}</span>
                <Briefcase className="w-5 h-5 text-blue-500" />
              </div>
            )}

            {profile.city && (
              <div className="flex items-center justify-end gap-3 text-sm bg-blue-50 p-3 rounded-md mt-2">
                <span className="font-medium">{profile.city}</span>
                <MapPin className="w-5 h-5 text-blue-500" />
              </div>
            )}
          </div>
        )}

        {/* About section (if not manual entry with text, or if manual entry but 'about' is also filled) */}
        {(!isManualEntry || !profile.manualEntryText) && profile.about && (
          <>
            <Separator className="my-4 bg-gray-200" />
            <div className="space-y-3">
              <h4 className="text-sm font-bold text-gray-600">אודות</h4>
              <p className="text-sm leading-relaxed py-3 px-4 bg-gray-50 rounded-md border border-gray-200 shadow-sm whitespace-pre-wrap">
                {profile.about}
              </p>
            </div>
          </>
        )}
      </div>

      {/* Action Buttons with improved layout */}
      <div className="p-4 bg-gray-50 border-t border-gray-200">
        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
          <Button
            variant="default"
            className="w-full bg-blue-500 hover:bg-blue-600 transition-colors shadow-sm"
            onClick={() => onAction("view")}
          >
            <Eye className="w-4 h-4 ml-1.5" />
            <span className="text-sm">צפייה בפרופיל</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("suggest")}
          >
            <FileText className="w-4 h-4 ml-1.5" />
            <span className="text-sm">הצעת שידוך</span>
          </Button>

          <Button
            variant="outline"
            className="w-full border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("invite")}
          >
            <Mail className="w-4 h-4 ml-1.5" />
            <span className="text-sm">שליחת הזמנה</span>
          </Button>

          <Button
            variant="outline"
            className="w-full sm:col-span-2 border-blue-200 hover:bg-blue-50 transition-colors shadow-sm"
            onClick={() => onAction("contact")}
          >
            <Clock className="w-4 h-4 ml-1.5" />
            <span className="text-sm">בדיקת זמינות</span>
          </Button>

          <Button
            variant="ghost"
            className="w-full hover:bg-blue-50 transition-colors bg-blue-50/50"
            onClick={() => onAction("edit")}
          >
            <Edit className="w-4 h-4 ml-1.5" />
            <span className="text-sm">עריכת פרופיל</span>
          </Button>
        </div>
      </div>
    </div>
  );
};

export default QuickView;
--- End of Content for QuickView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesList.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/CandidatesList.tsx

import React, { useState, useCallback, useEffect, useRef, useMemo } from "react";
import { UserX, Edit } from "lucide-react";
import MinimalCard from "../CandidateCard/MinimalCard";
import QuickView from "../CandidateCard/QuickView";
import { ProfileCard } from "@/app/components/profile";
import type { Candidate, CandidateAction, MobileView } from "../types/candidates";
import type { QuestionnaireResponse } from "@/types/next-auth";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { ActionDialogs } from "../dialogs/ActionDialogs";
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import MatchmakerEditProfile from "../MatchmakerEditProfile";
import { cn } from "@/lib/utils";

interface CreateSuggestionData {
  priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
  firstPartyId: string;
  secondPartyId: string;
  status:
    | "DRAFT"
    | "PENDING_FIRST_PARTY"
    | "FIRST_PARTY_APPROVED"
    | "FIRST_PARTY_DECLINED"
    | string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
}

interface CandidatesListProps {
  candidates: (Candidate & { aiScore?: number })[];
  allCandidates: Candidate[];
  onCandidateClick?: (candidate: Candidate) => void;
  onCandidateAction?: (type: CandidateAction, candidate: Candidate) => void;
  viewMode: "grid" | "list";
  mobileView: MobileView;
  isLoading?: boolean;
  className?: string;
  highlightTerm?: string;
  
  // --- AI-RELATED PROPS ---
  aiTargetCandidate: Candidate | null;
  onSetAiTarget: (candidate: Candidate, e: React.MouseEvent) => void;
  comparisonSelection: Record<string, Candidate>;
  onToggleComparison: (candidate: Candidate, e: React.MouseEvent) => void;
}

const CandidatesList: React.FC<CandidatesListProps> = ({
  candidates,
  allCandidates,
  onCandidateClick,
  onCandidateAction,
  viewMode,
  mobileView,
  isLoading = false,
  className,
  highlightTerm,
  aiTargetCandidate,
  onSetAiTarget,
  comparisonSelection,
  onToggleComparison,
}) => {
  // Base states
  const [selectedCandidate, setSelectedCandidate] = useState<Candidate | null>(
    null
  );
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [isMatchmaker, setIsMatchmaker] = useState(false);
  const [hoveredCandidate, setHoveredCandidate] = useState<Candidate | null>(
    null
  );
  const [hoverPosition, setHoverPosition] = useState({ top: 0, left: 0 });
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const quickViewRef = useRef<HTMLDivElement>(null);

  // Dialog states
  const [showInviteDialog, setShowInviteDialog] = useState(false);
  const [showAvailabilityDialog, setShowAvailabilityDialog] = useState(false);
  const [showSuggestDialog, setShowSuggestDialog] = useState(false);
  const [showEditProfileDialog, setShowEditProfileDialog] = useState(false);
  const [dialogCandidate, setDialogCandidate] = useState<Candidate | null>(
    null
  );

  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    return () => {
      window.removeEventListener("resize", checkScreenSize);
    };
  }, []);

  // Close QuickView when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        hoveredCandidate &&
        quickViewRef.current &&
        !quickViewRef.current.contains(event.target as Node)
      ) {
        setHoveredCandidate(null);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [hoveredCandidate]);

  // Clean up timeout on unmount
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);

  // Load questionnaire when candidate is selected
  useEffect(() => {
    const loadQuestionnaire = async () => {
      if (!selectedCandidate) {
        setQuestionnaireResponse(null);
        return;
      }

      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${selectedCandidate.id}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          const formattedQuestionnaire = {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
          setQuestionnaireResponse(formattedQuestionnaire);
        }
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
      }
    };

    loadQuestionnaire();
  }, [selectedCandidate]);

  // Action handlers
  const handleInvite = async (candidate: Candidate, email: string) => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${candidate.id}/invite-setup`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          candidateId: candidate.id,
          email,
        }),
      });

      if (!response.ok) throw new Error("Failed to send invitation");

      toast.success("ההזמנה נשלחה בהצלחה");
      onCandidateAction?.("invite", candidate);
    } catch (error) {
      console.error("Error sending invite:", error);
      throw error;
    }
  };

  const handleAvailabilityCheck = async (candidate: Candidate) => {
    try {
      const response = await fetch("/api/availability/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ clientId: candidate.id }),
      });

      if (!response.ok) throw new Error("Failed to check availability");

      toast.success("בדיקת הזמינות נשלחה");
      onCandidateAction?.("contact", candidate);
    } catch (error) {
      console.error("Error checking availability:", error);
      throw error;
    }
  };

  const handleCreateSuggestion = async (data: CreateSuggestionData) => {
    try {
      const response = await fetch("/api/matchmaker/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      toast.success("ההצעה נוצרה בהצלחה");
      onCandidateAction?.("suggest", dialogCandidate!);
    } catch (error) {
      console.error("Error creating suggestion:", error);
      throw error;
    }
  };

  const handleEditProfile = (candidate: Candidate) => {
    setDialogCandidate(candidate);
    setShowEditProfileDialog(true);
  };

  const handleMouseEnter = (candidate: Candidate, e?: React.MouseEvent) => {
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }

    let top = window.scrollY + window.innerHeight / 3;
    let left = window.innerWidth / 2;

    if (e) {
      const element = e.currentTarget as HTMLElement;
      if (element) {
        const rect = element.getBoundingClientRect();
        const screenMiddle = window.innerWidth / 2;
        const isRightPanel = rect.left < screenMiddle;

        top = rect.top + window.scrollY;

        if (isRightPanel) {
          left = Math.min(rect.right + 10, window.innerWidth - 430);
        } else {
          left = Math.max(rect.left - 430, 10);
        }
      }
    }

    hoverTimeoutRef.current = setTimeout(() => {
      setHoverPosition({ top, left });
      setHoveredCandidate(candidate);
    }, 300);
  };

  const handleMouseLeave = () => {
    if (isMobile) return;

    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
      hoverTimeoutRef.current = null;
    }

    setTimeout(() => {
      if (!quickViewRef.current?.matches(":hover")) {
        setHoveredCandidate(null);
      }
    }, 100);
  };

  const handleAction = useCallback(
    (action: CandidateAction, candidate: Candidate) => {
      setDialogCandidate(candidate);
      setHoveredCandidate(null);

      switch (action) {
        case "invite":
          setShowInviteDialog(true);
          break;
        case "contact":
          setShowAvailabilityDialog(true);
          break;
        case "suggest":
          setShowSuggestDialog(true);
          break;
        case "view":
          setSelectedCandidate(candidate);
          onCandidateClick?.(candidate);
          break;
        case "edit":
          handleEditProfile(candidate);
          break;
        default:
          onCandidateAction?.(action, candidate);
      }
    },
    [onCandidateAction, onCandidateClick]
  );
  
  const gridLayoutClass = useMemo(() => {
    if (isMobile) {
      // Mobile view logic
      return mobileView === 'double'
        ? 'grid grid-cols-2 gap-2' // Two columns for mobile
        : 'grid grid-cols-1 gap-3'; // Single column for mobile
    }
    // Desktop view logic
    return viewMode === 'grid'
      ? 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-3 gap-y-4'
      : 'space-y-4';
  }, [isMobile, mobileView, viewMode]);

  // Loading states render
  if (isLoading) {
    return (
      <div
        className={`${
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            : "space-y-4"
        } ${className || ""}`}
      >
        {Array.from({ length: 6 }).map((_, i) => (
          <div key={i} className="relative">
            <Skeleton
              className={
                viewMode === "list" ? "h-32 w-full" : "h-[350px] w-full"
              }
            />
            <div className="absolute top-3 right-3">
              <Skeleton className="h-6 w-16 rounded-full" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  // Empty state render with improved UI
  if (candidates.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-32 bg-gray-50 rounded-lg border border-dashed border-gray-300 p-4 text-center">
        <UserX className="w-8 h-8 mb-2 text-gray-400" />
        <p className="text-sm font-medium text-gray-500 mb-1">
          לא נמצאו מועמדים
        </p>
        <p className="text-xs text-gray-400">
          נסו להרחיב את החיפוש או להסיר חלק מהמסננים.
        </p>
      </div>
    );
  }

  return (
    <>
      <div className={cn(gridLayoutClass, className || "")}>
        {candidates.map((candidate) => (
          <div
            key={candidate.id}
            className="group relative"
            onMouseEnter={(e) => handleMouseEnter(candidate, e)}
            onMouseLeave={handleMouseLeave}
            onClick={() => handleAction("view", candidate)}
          >
            <MinimalCard
              candidate={candidate}
              onClick={() => handleAction("view", candidate)}
              onEdit={(c, e) => {
                e.stopPropagation();
                handleAction("edit", c);
              }}
              className={cn(
                viewMode === "list" && !isMobile ? "flex flex-row-reverse gap-4 h-32" : "",
                isMobile && mobileView === 'double' ? 'transform scale-90' : '',
                isMobile && mobileView === 'single' ? 'transform scale-95' : ''
              )}
              highlightTerm={highlightTerm}
              aiScore={candidate.aiScore}
              onSetAiTarget={onSetAiTarget}
              isAiTarget={aiTargetCandidate?.id === candidate.id}
              isSelectableForComparison={
                !!aiTargetCandidate &&
                aiTargetCandidate.profile.gender !== candidate.profile.gender &&
                aiTargetCandidate.id !== candidate.id
              }
              isSelectedForComparison={!!comparisonSelection[candidate.id]}
              onToggleComparison={onToggleComparison}
            />
            <button
              className="absolute top-2 left-2 bg-primary text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity z-10"
              onClick={(e) => {
                e.stopPropagation();
                handleAction("edit", candidate);
              }}
              aria-label="ערוך פרופיל"
              title="ערוך פרופיל"
            >
              <Edit className="w-4 h-4" />
            </button>
          </div>
        ))}
      </div>

      {hoveredCandidate && !isMobile && (
        <div
          ref={quickViewRef}
          className="fixed z-50 md:absolute transform -translate-x-1/2 sm:translate-x-0"
          style={{
            top: `${hoverPosition.top}px`,
            left: `${hoverPosition.left}px`,
            maxWidth: window.innerWidth < 768 ? "calc(100vw - 32px)" : "420px",
            ...(window.innerWidth < 768
              ? {
                  left: "50%",
                  transform: "translateX(-50%)",
                  maxHeight: "85vh",
                }
              : {}),
          }}
        >
          <div className="drop-shadow-2xl">
            <QuickView
              candidate={hoveredCandidate}
              onAction={(action) => handleAction(action, hoveredCandidate)}
              onSetAiTarget={(c, e) => onSetAiTarget(c, e)}
              isAiTarget={aiTargetCandidate?.id === hoveredCandidate.id}
            />
          </div>
        </div>
      )}

      <Dialog
        open={!!selectedCandidate}
        onOpenChange={(open) => {
          if (!open) {
            setSelectedCandidate(null);
            setQuestionnaireResponse(null);
          }
        }}
      >
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <div className="flex items-center justify-between">
              <DialogTitle>פרופיל מועמד</DialogTitle>
              <Button
                variant="outline"
                onClick={() => handleAction("edit", selectedCandidate!)}
                className="flex items-center gap-2"
              >
                <Edit className="w-4 h-4" />
                עריכת פרופיל
              </Button>
            </div>
            <DialogDescription>צפייה בפרטי המועמד</DialogDescription>
            <Select
              value={isMatchmaker ? "matchmaker" : "candidate"}
              onValueChange={(value) => setIsMatchmaker(value === "matchmaker")}
            >
              <SelectTrigger className="w-full sm:w-48">
                <SelectValue placeholder="בחר תצוגה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="candidate">תצוגת מועמד</SelectItem>
                <SelectItem value="matchmaker">תצוגת שדכן</SelectItem>
              </SelectContent>
            </Select>
          </DialogHeader>

          {selectedCandidate && (
            <div className="space-y-6">
              <ProfileCard
                profile={selectedCandidate.profile}
                images={selectedCandidate.images}
                questionnaire={questionnaireResponse}
                viewMode={isMatchmaker ? "matchmaker" : "candidate"}
              />
            </div>
          )}
        </DialogContent>
      </Dialog>

      <ActionDialogs
        suggestDialog={{
          isOpen: showSuggestDialog,
          onClose: () => setShowSuggestDialog(false),
          onSubmit: handleCreateSuggestion,
          selectedCandidate: dialogCandidate,
        }}
        availabilityDialog={{
          isOpen: showAvailabilityDialog,
          onClose: () => setShowAvailabilityDialog(false),
          onCheck: handleAvailabilityCheck,
          selectedCandidate: dialogCandidate,
        }}
        inviteDialog={{
          isOpen: showInviteDialog,
          onClose: () => setShowInviteDialog(false),
          onInvite: handleInvite,
          selectedCandidate: dialogCandidate,
        }}
      />

      <NewSuggestionForm
        isOpen={showSuggestDialog}
        onClose={() => setShowSuggestDialog(false)}
        candidates={allCandidates}
        selectedCandidate={selectedCandidate}
        onSubmit={handleCreateSuggestion}
      />

      <MatchmakerEditProfile
        isOpen={showEditProfileDialog}
        onClose={() => setShowEditProfileDialog(false)}
        candidate={dialogCandidate}
      />
    </>
  );
};

export default CandidatesList;
--- End of Content for CandidatesList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\CandidatesStats.tsx
--------------------------------------------------------------------------------
Content:
// /CandidatesManager/CandidatesStats.tsx

"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Users,
  UserSquare2,
  Clock,
  MapPin,
  CheckCircle,
  Image as ImageIcon,
} from "lucide-react";
import { useStatistics } from "../hooks/useStatistics";
import type { Candidate } from "../types/candidates";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from "recharts";

interface StatCardProps {
  title: string;
  value: string | number;
  description?: string;
  icon: React.ReactNode;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
}

interface CandidatesStatsProps {
  candidates: Candidate[];
  className?: string;
}

const CHART_COLORS = [
  "#3B82F6", // כחול
  "#EF4444", // אדום
  "#10B981", // ירוק
  "#F59E0B", // כתום
  "#6366F1", // סגול
  "#EC4899", // ורוד
];

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  description,
  icon,
  trend,
  className,
}) => (
  <Card className={`p-6 ${className}`}>
    <div className="flex items-start justify-between">
      <div className="space-y-2">
        <p className="text-sm text-gray-500">{title}</p>
        <p className="text-2xl font-semibold">{value}</p>
        {description && <p className="text-xs text-gray-400">{description}</p>}
        {trend && (
          <div
            className={`text-xs flex items-center gap-1 ${
              trend.isPositive ? "text-green-600" : "text-red-600"
            }`}
          >
            <span>{trend.isPositive ? "↑" : "↓"}</span>
            <span>{Math.abs(trend.value)}%</span>
            <span>מהחודש שעבר</span>
          </div>
        )}
      </div>
      <div className="bg-blue-50 p-3 rounded-lg">{icon}</div>
    </div>
  </Card>
);

const CandidatesStats: React.FC<CandidatesStatsProps> = ({
  candidates,
  className,
}) => {
  const {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats,
  } = useStatistics(candidates);

  const genderRatio = getGenderRatio();
  const activeUsers = getActiveUsersPercent();
  const completionStats = getProfileCompletionStats();
  const ageDistribution = getAgeGroupDistribution();
  const religiousDistribution = getReligiousDistribution();
  const activityTrend = getActivityTrend();
  const topCities = getTopCities(5);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* סטטיסטיקות עיקריות */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          title="סה״כ מועמדים"
          value={stats.gender.total}
          icon={<Users className="w-6 h-6 text-blue-600" />}
          description="סה״כ מועמדים פעילים במערכת"
        />
        <StatCard
          title="יחס מועמדים/ות"
          value={genderRatio.formattedRatio}
          icon={<UserSquare2 className="w-6 h-6 text-blue-600" />}
          description="גברים/נשים"
        />
        <StatCard
          title="פעילות בשבוע האחרון"
          value={`${activeUsers}%`}
          icon={<Clock className="w-6 h-6 text-blue-600" />}
          trend={{
            value: 5,
            isPositive: true,
          }}
        />
        <StatCard
          title="פרופילים מלאים"
          value={`${completionStats.percentage}%`}
          icon={<CheckCircle className="w-6 h-6 text-blue-600" />}
          description={`${completionStats.completed} מתוך ${stats.gender.total}`}
        />
      </div>

      {/* טאבים לניתוחים מתקדמים */}
      <Tabs defaultValue="demographics" className="w-full">
        <TabsList className="w-full justify-start">
          <TabsTrigger value="demographics">דמוגרפיה</TabsTrigger>
          <TabsTrigger value="activity">פעילות</TabsTrigger>
          <TabsTrigger value="completion">שלמות פרופילים</TabsTrigger>
        </TabsList>

        {/* דמוגרפיה */}
        <TabsContent value="demographics">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* התפלגות גילאים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות גילאים</h3>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={ageDistribution}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="range" />
                  <YAxis />
                  <Tooltip />
                  <Bar dataKey="count" fill="#3B82F6" />
                </BarChart>
              </ResponsiveContainer>
            </Card>

            {/* התפלגות דתית */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">התפלגות רמת דתיות</h3>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={religiousDistribution}
                    dataKey="count"
                    nameKey="level"
                    cx="50%"
                    cy="50%"
                    outerRadius={100}
                    label
                  >
                    {religiousDistribution.map((_, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={CHART_COLORS[index % CHART_COLORS.length]}
                      />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </Card>

            {/* מיקומים מובילים */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">ערים מובילות</h3>
              <div className="space-y-4">
                {topCities.map((city) => (
                  <div
                    key={city.city}
                    className="flex items-center justify-between"
                  >
                    <div className="flex items-center gap-2">
                      <MapPin className="w-4 h-4 text-blue-600" />
                      <span>{city.city}</span>
                    </div>
                    <span className="font-medium">{city.count}</span>
                  </div>
                ))}
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* פעילות */}
        <TabsContent value="activity">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* פעילות לאורך זמן */}
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">פעילות משתמשים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <span>פעילים בשבוע האחרון</span>
                  <span className="font-medium">{activityTrend.weekly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>פעילים בחודש האחרון</span>
                  <span className="font-medium">{activityTrend.monthly}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>ממוצע ימים בין התחברויות</span>
                  <span className="font-medium">
                    {activityTrend.average} ימים
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>

        {/* שלמות פרופילים */}
        <TabsContent value="completion">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card className="p-6">
              <h3 className="text-lg font-medium mb-4">שלמות פרופילים</h3>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <ImageIcon className="w-4 h-4 text-blue-600" />
                    <span>תמונות פרופיל</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasPhotos}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <CheckCircle className="w-4 h-4 text-blue-600" />
                    <span>פרופיל מאומת</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.isVerified}%
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Users className="w-4 h-4 text-blue-600" />
                    <span>המלצות</span>
                  </div>
                  <span className="font-medium">
                    {stats.completion.percentages.hasReferences}%
                  </span>
                </div>
              </div>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default CandidatesStats;
--- End of Content for CandidatesStats.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\SplitView.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/SplitView.tsx

"use client";

import React, { useMemo, useEffect, useState } from "react";
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import CandidatesList from "./CandidatesList";
import { Badge } from "@/components/ui/badge";
import { Sparkles, XCircle, Users, User } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import type { Candidate, CandidateAction, MobileView } from "../types/candidates";
import type { FilterState } from "../types/filters";
import SearchBar from "../Filters/SearchBar";
import { toast } from "sonner";
import { cn } from "@/lib/utils";
import { Gender } from "@prisma/client";

interface AiMatch {
  userId: string;
  score: number;
}

interface SplitViewProps {
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  allCandidates: Candidate[];
  onCandidateAction: (type: CandidateAction, candidate: Candidate) => void;
  onCandidateClick: (candidate: Candidate) => void;
  viewMode: "grid" | "list";
  mobileView: MobileView;
  isLoading?: boolean;
  className?: string;
  
  // --- AI State and Handlers (Received from Parent) ---
  aiTargetCandidate: Candidate | null;
  aiMatches: AiMatch[];
  isAiLoading: boolean;
  onSetAiTarget: (candidate: Candidate, e: React.MouseEvent) => void;
  onClearAiTarget: (e: React.MouseEvent) => void;
  setAiMatches: React.Dispatch<React.SetStateAction<AiMatch[]>>;
  setIsAiLoading: React.Dispatch<React.SetStateAction<boolean>>;
  comparisonSelection: Record<string, Candidate>;
  onToggleComparison: (candidate: Candidate, e: React.MouseEvent) => void;

  // --- Filter Props ---
  separateFiltering: boolean;
  maleFilters?: Partial<FilterState>;
  femaleFilters?: Partial<FilterState>;
  onMaleFiltersChange: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange: (filters: Partial<FilterState>) => void;
  onCopyFilters: (source: "male" | "female", target: "male" | "female") => void;
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  onMaleSearchChange?: (query: string) => void;
  onFemaleSearchChange?: (query: string) => void;
}

const SplitView: React.FC<SplitViewProps> = (props) => {
  const {
    maleCandidates,
    femaleCandidates,
    allCandidates,
    onCandidateAction,
    onCandidateClick,
    viewMode,
    mobileView,
    isLoading = false,
    className,
    maleSearchQuery = "",
    femaleSearchQuery = "",
    onMaleSearchChange,
    onFemaleSearchChange,
    // --- Destructure AI props ---
    aiTargetCandidate,
    aiMatches,
    isAiLoading,
    onSetAiTarget,
    onClearAiTarget,
    setAiMatches,
    setIsAiLoading,
    comparisonSelection,
    onToggleComparison,
  } = props;

  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreenSize = () => setIsMobile(window.innerWidth < 768);
    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);
    return () => window.removeEventListener("resize", checkScreenSize);
  }, []);

  const handleFindAiMatches = async (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!aiTargetCandidate) return;

    setIsAiLoading(true);
    setAiMatches([]);

    const targetGender = aiTargetCandidate.profile.gender;
    const candidatePool = targetGender === Gender.MALE ? femaleCandidates : maleCandidates;
    const candidatePoolIds = candidatePool.map(c => c.id);

    if (candidatePoolIds.length === 0) {
      toast.error("אין מועמדים במאגר לחיפוש התאמות.", { position: "top-center" });
      setIsAiLoading(false);
      return;
    }
    
    try {
      const response = await fetch('/api/ai/find-matches', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ targetUserId: aiTargetCandidate.id, candidatePoolIds }),
      });

      const data = await response.json();
      if (!response.ok || !data.success) throw new Error(data.error || 'Failed to fetch AI matches');
      
      setAiMatches(data.matches);
      toast.success(`נמצאו ${data.matches.length} התאמות AI פוטנציאליות.`, {
         position: "top-center",
         description: "המועמדים המומלצים מסומנים ומוינו לראש הרשימה."
      });
    } catch (error) {
      console.error("Error finding AI matches:", error);
      toast.error("שגיאה במציאת התאמות AI.", {
          description: error instanceof Error ? error.message : "נסה שוב מאוחר יותר.",
      });
    } finally {
      setIsAiLoading(false);
    }
  };
  
  // --- START OF FIX ---
  // The logic is now directly inside useMemo, which is cleaner and satisfies the ESLint rule.
  const maleCandidatesWithScores = useMemo(() => {
    if (aiMatches.length === 0) return maleCandidates;
    const scoreMap = new Map(aiMatches.map(m => [m.userId, m.score]));
    return maleCandidates
      .map(c => ({ ...c, aiScore: scoreMap.get(c.id) }))
      .sort((a, b) => (b.aiScore ?? -1) - (a.aiScore ?? -1));
  }, [maleCandidates, aiMatches]);

  const femaleCandidatesWithScores = useMemo(() => {
    if (aiMatches.length === 0) return femaleCandidates;
    const scoreMap = new Map(aiMatches.map(m => [m.userId, m.score]));
    return femaleCandidates
      .map(c => ({ ...c, aiScore: scoreMap.get(c.id) }))
      .sort((a, b) => (b.aiScore ?? -1) - (a.aiScore ?? -1));
  }, [femaleCandidates, aiMatches]);
  // --- END OF FIX ---

  const renderPanelHeader = (gender: 'male' | 'female', isMobileView: boolean = false) => {
      const panelGenderEnum = gender === 'male' ? Gender.MALE : Gender.FEMALE;
      const isTargetPanel = aiTargetCandidate?.profile.gender === panelGenderEnum;
      const isSearchPanel = aiTargetCandidate && aiTargetCandidate.profile.gender !== panelGenderEnum;
      const count = gender === 'male' ? maleCandidates.length : femaleCandidates.length;

      return (
        <div className={cn("flex justify-between items-center mb-2 p-2 rounded-t-lg", !isMobileView && "bg-gray-50 border-b")}>
          <h2 className={cn("text-lg font-bold", gender === 'male' ? "text-blue-800" : "text-purple-800")}>
            {gender === 'male' ? `מועמדים (${count})` : `מועמדות (${count})`}
          </h2>
          <div className="flex-grow" />
          <div className="flex items-center gap-2">
              {isTargetPanel && aiTargetCandidate && (
                <div className="flex items-center gap-2 bg-green-100 p-1.5 rounded-full shadow-sm animate-fade-in">
                  <span className="text-xs font-medium text-green-800 px-2">מטרה: {aiTargetCandidate.firstName}</span>
                  <Button size="icon" variant="ghost" className="h-6 w-6 text-green-700 hover:bg-green-200 rounded-full" onClick={onClearAiTarget}>
                    <XCircle className="h-4 w-4"/>
                  </Button>
                </div>
              )}
              {isSearchPanel && (
                <Button size="sm" onClick={handleFindAiMatches} disabled={isAiLoading}>
                  <Sparkles className={`ml-2 h-4 w-4 ${isAiLoading ? 'animate-spin' : ''}`}/>
                  {isAiLoading ? 'מחפש...' : 'מצא התאמות AI'}
                </Button>
              )}
          </div>
        </div>
      );
  };

  // --- Mobile View using Tabs ---
  if (isMobile) {
    return (
        <div className={cn("w-full", className)}>
            <Tabs defaultValue="male" className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                    <TabsTrigger value="male" className="flex items-center gap-2">
                        <User className="h-4 w-4"/> מועמדים <Badge variant="secondary">{maleCandidates.length}</Badge>
                    </TabsTrigger>
                    <TabsTrigger value="female" className="flex items-center gap-2">
                        <User className="h-4 w-4"/> מועמדות <Badge variant="secondary">{femaleCandidates.length}</Badge>
                    </TabsTrigger>
                </TabsList>
                <TabsContent value="male" className="mt-4">
                    <div className="p-1 flex flex-col h-full">
                        {renderPanelHeader('male', true)}
                        {onMaleSearchChange && <SearchBar value={maleSearchQuery} onChange={onMaleSearchChange} placeholder="חיפוש מועמדים..." genderTarget="male" separateMode={true} />}
                        <div className="flex-grow min-h-0 overflow-y-auto">
                            <CandidatesList
                                candidates={maleCandidatesWithScores}
                                allCandidates={allCandidates}
                                onCandidateClick={onCandidateClick}
                                onCandidateAction={onCandidateAction}
                                viewMode={viewMode}
                                mobileView={mobileView}
                                isLoading={isLoading}
                                highlightTerm={maleSearchQuery}
                                aiTargetCandidate={aiTargetCandidate}
                                onSetAiTarget={onSetAiTarget}
                                comparisonSelection={comparisonSelection}
                                onToggleComparison={onToggleComparison}
                            />
                        </div>
                    </div>
                </TabsContent>
                <TabsContent value="female" className="mt-4">
                    <div className="p-1 flex flex-col h-full">
                        {renderPanelHeader('female', true)}
                        {onFemaleSearchChange && <SearchBar value={femaleSearchQuery} onChange={onFemaleSearchChange} placeholder="חיפוש מועמדות..." genderTarget="female" separateMode={true} />}
                        <div className="flex-grow min-h-0 overflow-y-auto">
                            <CandidatesList
                                candidates={femaleCandidatesWithScores}
                                allCandidates={allCandidates}
                                onCandidateClick={onCandidateClick}
                                onCandidateAction={onCandidateAction}
                                viewMode={viewMode}
                                mobileView={mobileView}
                                isLoading={isLoading}
                                highlightTerm={femaleSearchQuery}
                                aiTargetCandidate={aiTargetCandidate}
                                onSetAiTarget={onSetAiTarget}
                                comparisonSelection={comparisonSelection}
                                onToggleComparison={onToggleComparison}
                            />
                        </div>
                    </div>
                </TabsContent>
            </Tabs>
        </div>
    );
  }

  // --- Desktop View using Resizable Panels ---
  return (
    <div className={cn("h-full", className)}>
      <ResizablePanelGroup direction="horizontal" className="min-h-[800px] rounded-lg bg-white shadow-sm border">
        <ResizablePanel defaultSize={50} minSize={30}>
          <div className="p-3 flex flex-col h-full">
            {renderPanelHeader('male')}
            {onMaleSearchChange && <SearchBar value={maleSearchQuery} onChange={onMaleSearchChange} placeholder="חיפוש מועמדים..." genderTarget="male" separateMode={true} />}
            <div className="flex-grow min-h-0 overflow-y-auto">
              <CandidatesList
                candidates={maleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={isLoading}
                highlightTerm={maleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </ResizablePanel>
        <ResizableHandle withHandle />
        <ResizablePanel defaultSize={50} minSize={30}>
          <div className="p-3 flex flex-col h-full">
            {renderPanelHeader('female')}
            {onFemaleSearchChange && <SearchBar value={femaleSearchQuery} onChange={onFemaleSearchChange} placeholder="חיפוש מועמדות..." genderTarget="female" separateMode={true} />}
            <div className="flex-grow min-h-0 overflow-y-auto">
               <CandidatesList
                candidates={femaleCandidatesWithScores}
                allCandidates={allCandidates}
                onCandidateClick={onCandidateClick}
                onCandidateAction={onCandidateAction}
                viewMode={viewMode}
                mobileView={mobileView}
                isLoading={isLoading}
                highlightTerm={femaleSearchQuery}
                aiTargetCandidate={aiTargetCandidate}
                onSetAiTarget={onSetAiTarget}
                comparisonSelection={comparisonSelection}
                onToggleComparison={onToggleComparison}
              />
            </div>
          </div>
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  );
};

export default SplitView;
--- End of Content for SplitView.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\StatsCard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";

import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };
  variant?: "default" | "success" | "warning" | "destructive";
  bgGradient?: string;
  iconColor?: string;
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  variant = "default",
  bgGradient,
  iconColor = "text-primary",
  className,
}) => {
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "border-emerald-200";
      case "warning":
        return "border-amber-200";
      case "destructive":
        return "border-red-200";
      default:
        return "border-gray-200";
    }
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-all duration-300 p-4 overflow-hidden",
        bgGradient ? `bg-gradient-to-br ${bgGradient}` : "bg-card",
        getVariantStyles(),
        className
      )}
    >
      <div className="flex items-start justify-between">
        <div className="mr-4 flex-shrink-0">
          <div className={`p-2.5 rounded-full bg-white/60 backdrop-blur-sm shadow-sm`}>
            <Icon className={`w-4 h-4 ${iconColor}`} />
          </div>
        </div>

        <div className="flex-1 text-right">
          <p className="text-xs text-muted-foreground mb-1">{title}</p>
          <h3 className="text-xl font-bold">{value}</h3>

          {trend && (
            <div className="flex items-center justify-end gap-1 mt-1">
              <span
                className={cn(
                  "text-sm font-medium flex items-center gap-0.5",
                  trend.isPositive ? "text-emerald-600" : "text-red-600"
                )}
              >
                {trend.isPositive ? "+" : "-"}{trend.value}%
                <span className={`${trend.isPositive ? "rotate-0" : "rotate-180"} transition-transform`}>
                  ↑
                </span>
              </span>
              <span className="text-[11px] text-muted-foreground">
                {trend.label}
              </span>
            </div>
          )}
        </div>
      </div>

      {/* Animated background pattern for more visual appeal */}
      <div className="absolute right-0 bottom-0 opacity-10 pointer-events-none">
        <svg width="80" height="80" viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="60" cy="60" r="40" fill="currentColor" />
        </svg>
      </div>
    </Card>
  );
};

export default StatsCard;
--- End of Content for StatsCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\CandidatesManager\index.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/CandidatesManager/index.tsx

"use client";

import React, { useState, useCallback, useEffect, useMemo } from "react";
import { Button } from "@/components/ui/button";
// --- START OF CHANGE 1 ---
import { UserPlus, Filter, LayoutGrid, List, ArrowUpDown, RotateCw, BarChart2, Bot, Loader2, Columns, View } from "lucide-react"; // Added Columns, View
// --- END OF CHANGE 1 ---
import { toast } from "sonner";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuLabel, DropdownMenuSeparator } from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useSession } from "next-auth/react";

// Custom Hooks
import { useCandidates } from "../hooks/useCandidates";
import { useFilterLogic } from "../hooks/useFilterLogic";

// Components
import SplitView from "./SplitView";
import FilterPanel from "../Filters/FilterPanel";
import ActiveFilters from "../Filters/ActiveFilters";
import SearchBar from "../Filters/SearchBar";
import { LoadingContainer } from "../shared/LoadingStates";
import { AddManualCandidateDialog } from "../dialogs/AddManualCandidateDialog";
import { AiMatchAnalysisDialog } from "../dialogs/AiMatchAnalysisDialog";

// Types
import type { Candidate, ViewMode, CandidatesFilter, CandidateAction, MobileView } from "../types/candidates"; // --- CHANGE: Added MobileView ---

// Constants
import { SORT_OPTIONS, VIEW_OPTIONS } from "../constants/filterOptions";

interface AiMatch {
  userId: string;
  score: number;
}

const CandidatesManager: React.FC = () => {
  // --- UI and General State ---
  const [viewMode, setViewMode] = useState<ViewMode>("grid");
  // --- START OF CHANGE 2 ---
  const [mobileView, setMobileView] = useState<MobileView>('single'); // 'single' or 'double' column
  const [isMobile, setIsMobile] = useState(false);
  // --- END OF CHANGE 2 ---
  const [showFiltersPanel, setShowFiltersPanel] = useState(false);
  const [showFiltersMobile, setShowFiltersMobile] = useState(false);
  const [showManualAddDialog, setShowManualAddDialog] = useState(false);
  
  // --- AI State Management ---
  const [aiTargetCandidate, setAiTargetCandidate] = useState<Candidate | null>(null);
  const [comparisonSelection, setComparisonSelection] = useState<Record<string, Candidate>>({});
  const [aiMatches, setAiMatches] = useState<AiMatch[]>([]);
  const [isAiLoading, setIsAiLoading] = useState(false);
  const [isAnalysisDialogOpen, setIsAnalysisDialogOpen] = useState(false);
  const [isBulkUpdating, setIsBulkUpdating] = useState(false); 

  // --- Session and Permissions ---
  const { data: session } = useSession();
  const isAdmin = session?.user?.role === 'ADMIN';

  // Custom Hooks
  const {
    loading,
    candidates,
    maleCandidates,
    femaleCandidates,
    setSorting,
    setFilters,
    refresh,
  } = useCandidates();

  const {
    filters,
    savedFilters,
    recentSearches,
    popularFilters,
    activeFilters,
    saveFilter,
    resetFilters,
    clearRecentSearches,
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
  } = useFilterLogic({
    onFilterChange: setFilters,
  });

  // --- Handlers (unchanged) ---
  const handleCandidateAdded = useCallback(() => { refresh(); toast.success("מועמד חדש נוסף בהצלחה!"); }, [refresh]);
  const handleSearch = useCallback((value: string) => { if (!filters.separateFiltering) { setFilters(prev => ({ ...prev, searchQuery: value })); } }, [setFilters, filters.separateFiltering]);
  const handleRemoveFilter = useCallback((key: keyof CandidatesFilter, value?: string) => { setFilters(prev => { const newFilters = { ...prev }; if (key === "cities" && value) newFilters.cities = newFilters.cities?.filter(city => city !== value); else if (key === "occupations" && value) newFilters.occupations = newFilters.occupations?.filter(occ => occ !== value); else delete newFilters[key]; return newFilters; }); }, [setFilters]);
  const handleCandidateAction = useCallback(async (type: CandidateAction, candidate: Candidate) => { console.log(`Action '${type}' triggered for candidate: ${candidate.firstName}`); }, []);
  const handleFilterSave = useCallback(async (name: string) => { try { await saveFilter(name, filters); toast.success("הפילטר נשמר בהצלחה"); } catch { toast.error("שגיאה בשמירת הפילטר"); } }, [filters, saveFilter]);
  const handleSetAiTarget = useCallback((candidate: Candidate, e: React.MouseEvent) => { e.stopPropagation(); if (aiTargetCandidate?.id === candidate.id) { handleClearAiTarget(e); return; } setAiTargetCandidate(candidate); setAiMatches([]); setComparisonSelection({}); toast.info(`מועמד מטרה נבחר: ${candidate.firstName}. כעת ניתן לחפש התאמות בפאנל הנגדי.`, { position: "bottom-center" }); }, [aiTargetCandidate]);
  const handleClearAiTarget = (e: React.MouseEvent) => { e.stopPropagation(); setAiTargetCandidate(null); setAiMatches([]); setComparisonSelection({}); toast.info("בחירת מועמד מטרה בוטלה.", { position: "bottom-center" }); };
  const handleToggleComparison = useCallback((candidate: Candidate, e: React.MouseEvent) => { e.stopPropagation(); setComparisonSelection(prev => { const newSelection = {...prev}; if (newSelection[candidate.id]) { delete newSelection[candidate.id]; } else { newSelection[candidate.id] = candidate; } return newSelection; }); }, []);
  const handleUpdateAllProfiles = async () => { setIsBulkUpdating(true); toast.info("מתחיל תהליך עדכון פרופילי AI...", { description: "התהליך ירוץ ברקע. אין צורך להישאר בעמוד זה.", }); try { const response = await fetch('/api/ai/update-all-profiles', { method: 'POST', }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'שגיאה בהפעלת העדכון הכללי.'); toast.success("העדכון הכללי הופעל בהצלחה!", { description: data.message, duration: 8000, }); } catch (error) { console.error("Failed to initiate bulk AI profile update:", error); toast.error("שגיאה בהפעלת העדכון", { description: error instanceof Error ? error.message : 'אנא נסה שוב מאוחר יותר.', }); } finally { setIsBulkUpdating(false); } };
  
  // --- START OF CHANGE 3 ---
  useEffect(() => {
    const checkScreen = () => {
      const isDesktop = window.innerWidth >= 1024;
      const isMob = window.innerWidth < 768;
      setShowFiltersPanel(isDesktop);
      setIsMobile(isMob);
    };
    checkScreen();
    window.addEventListener('resize', checkScreen);
    return () => window.removeEventListener('resize', checkScreen);
  }, []);
  // --- END OF CHANGE 3 ---

  const activeFilterCount = useMemo(() => activeFilters.length, [activeFilters]);

  return (
    <div className="min-h-screen bg-gray-50/50">
      <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-sm border-b shadow-sm">
        <div className="container mx-auto py-3 px-4">
          <div className="flex justify-between items-center mb-4">
            <h1 className="text-2xl font-bold text-primary/90">ניהול מועמדים</h1>
            <div className="flex items-center gap-2">
              <Button onClick={() => setShowManualAddDialog(true)} size="sm">
                <UserPlus className="w-4 h-4 ml-2" />
                הוסף מועמד ידנית
              </Button>
               {Object.keys(comparisonSelection).length > 0 && aiTargetCandidate && (
                <Button onClick={() => setIsAnalysisDialogOpen(true)} size="sm" variant="secondary">
                    <BarChart2 className="w-4 h-4 ml-2"/>
                    נתח התאמה ({Object.keys(comparisonSelection).length})
                </Button>
              )}
              
              {isAdmin && (
                <AlertDialog>
                    <AlertDialogTrigger asChild>
                        <Button variant="destructive" size="sm" disabled={isBulkUpdating || loading}>
                            {isBulkUpdating ? <Loader2 className="w-4 h-4 ml-2 animate-spin" /> : <Bot className="w-4 h-4 ml-2" />}
                            עדכון כללי AI
                        </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent dir="rtl">
                        <AlertDialogHeader>
                            <AlertDialogTitle>אישור עדכון AI כללי</AlertDialogTitle>
                            <AlertDialogDescription>
                                פעולה זו תפעיל תהליך עדכון וקטורים עבור **כל** המשתמשים הפעילים. 
                                התהליך ירוץ ברקע ועשוי לקחת מספר דקות. 
                                האם אתה בטוח שברצונך להמשיך?
                            </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                            <AlertDialogCancel>ביטול</AlertDialogCancel>
                            <AlertDialogAction onClick={handleUpdateAllProfiles}>כן, הפעל עדכון</AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialog>
              )}

              <Button onClick={refresh} variant="outline" size="icon" title="רענן רשימה" disabled={loading}>
                <RotateCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </Button>
            </div>
          </div>
          <div className="flex flex-col sm:flex-row gap-2">
            {!filters.separateFiltering && (
              <div className="flex-1">
                <SearchBar
                  value={filters.searchQuery || ""}
                  onChange={handleSearch}
                  placeholder="חיפוש כללי בשם, עיר, עיסוק..."
                  recentSearches={recentSearches}
                  onClearRecentSearches={clearRecentSearches}
                />
              </div>
            )}
            <div className="flex gap-2 justify-between">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm"><ArrowUpDown className="w-4 h-4 ml-2" />מיון</Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuLabel>מיון לפי</DropdownMenuLabel>
                  <DropdownMenuSeparator />
                  {SORT_OPTIONS.map((option) => (
                    <DropdownMenuItem key={option.value} onClick={() => setSorting(option.value, option.defaultOrder as "asc" | "desc")}>
                      {option.label}
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>

              <div className="hidden lg:flex">
                <Button variant="outline" size="sm" onClick={() => setShowFiltersPanel(!showFiltersPanel)}>
                  <Filter className="w-4 h-4 ml-2" />
                  {showFiltersPanel ? "הסתר סינון" : "הצג סינון"}
                </Button>
              </div>

              <Sheet open={showFiltersMobile} onOpenChange={setShowFiltersMobile}>
                <SheetTrigger asChild>
                  <Button variant="outline" size="sm" className="lg:hidden relative">
                    <Filter className="w-4 h-4 ml-2" />
                    סינון
                    {activeFilterCount > 0 && <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center">{activeFilterCount}</Badge>}
                  </Button>
                </SheetTrigger>
                <SheetContent>
                    <FilterPanel
                        filters={filters}
                        onFiltersChange={setFilters}
                        onSavePreset={handleFilterSave}
                        onReset={resetFilters}
                        savedFilters={savedFilters.map((f) => ({ id: f.id, name: f.name, isDefault: f.isDefault }))}
                        popularFilters={popularFilters}
                        separateFiltering={filters.separateFiltering}
                        onToggleSeparateFiltering={toggleSeparateFiltering}
                        onMaleFiltersChange={updateMaleFilters}
                        onFemaleFiltersChange={updateFemaleFilters}
                        onCopyFilters={copyFilters}
                    />
                </SheetContent>
              </Sheet>
              
              <div className="flex gap-1 bg-gray-100 p-1 rounded-lg">
                {/* --- START OF CHANGE 4: Conditional display for mobile view toggle --- */}
                {isMobile ? (
                   <Button 
                     variant="ghost" 
                     size="icon" 
                     onClick={() => setMobileView(prev => prev === 'single' ? 'double' : 'single')}
                     title={mobileView === 'single' ? 'הצג שני טורים' : 'הצג טור אחד'}
                   >
                     {mobileView === 'single' ? <Columns className="w-4 h-4"/> : <View className="w-4 h-4"/>}
                   </Button>
                ) : (
                  VIEW_OPTIONS.map((option) => (
                    <Button key={option.value} variant={viewMode === option.value ? "default" : "ghost"} size="icon" onClick={() => setViewMode(option.value as ViewMode)}>
                      {option.value === 'grid' ? <LayoutGrid className="w-4 h-4"/> : <List className="w-4 h-4"/>}
                    </Button>
                  ))
                )}
                {/* --- END OF CHANGE 4 --- */}
              </div>
            </div>
          </div>
          <div className="mt-4">
            <ActiveFilters filters={filters} onRemoveFilter={handleRemoveFilter} onResetAll={resetFilters} />
          </div>
        </div>
      </header>
      
      <main className="container mx-auto py-6 px-4">
        <div className="flex gap-6">
          {showFiltersPanel && (
            <aside className="hidden lg:block w-80 flex-shrink-0">
              <FilterPanel
                filters={filters}
                onFiltersChange={setFilters}
                onSavePreset={handleFilterSave}
                onReset={resetFilters}
                savedFilters={savedFilters.map((f) => ({ id: f.id, name: f.name, isDefault: f.isDefault }))}
                popularFilters={popularFilters}
                separateFiltering={filters.separateFiltering}
                onToggleSeparateFiltering={toggleSeparateFiltering}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
              />
            </aside>
          )}

          <div className="flex-1 min-w-0">
            {loading ? (
              <LoadingContainer>
                <div className="h-[800px] bg-gray-200 rounded-lg animate-pulse"></div>
              </LoadingContainer>
            ) : (
              <SplitView
                maleCandidates={maleCandidates}
                femaleCandidates={femaleCandidates}
                allCandidates={candidates}
                onCandidateAction={handleCandidateAction}
                onCandidateClick={() => {}}
                viewMode={viewMode}
                // --- START OF CHANGE 5 ---
                mobileView={mobileView} // Pass the new state down
                // --- END OF CHANGE 5 ---
                isLoading={loading || isAiLoading}
                
                aiTargetCandidate={aiTargetCandidate}
                aiMatches={aiMatches}
                isAiLoading={isAiLoading}
                onSetAiTarget={handleSetAiTarget}
                onClearAiTarget={handleClearAiTarget}
                setAiMatches={setAiMatches}
                setIsAiLoading={setIsAiLoading}
                comparisonSelection={comparisonSelection}
                onToggleComparison={handleToggleComparison}
                
                separateFiltering={filters.separateFiltering ?? false}
                maleFilters={filters.maleFilters}
                femaleFilters={filters.femaleFilters}
                onMaleFiltersChange={updateMaleFilters}
                onFemaleFiltersChange={updateFemaleFilters}
                onCopyFilters={copyFilters}
                maleSearchQuery={filters.maleSearchQuery}
                femaleSearchQuery={filters.femaleSearchQuery}
                onMaleSearchChange={updateMaleSearchQuery}
                onFemaleSearchChange={updateFemaleSearchQuery}
              />
            )}
          </div>
        </div>
      </main>

      {/* Dialogs */}
      <AddManualCandidateDialog
        isOpen={showManualAddDialog}
        onClose={() => setShowManualAddDialog(false)}
        onCandidateAdded={handleCandidateAdded}
      />

      <AiMatchAnalysisDialog
        isOpen={isAnalysisDialogOpen}
        onClose={() => setIsAnalysisDialogOpen(false)}
        targetCandidate={aiTargetCandidate}
        comparisonCandidates={Object.values(comparisonSelection)}
      />
    </div>
  );
};

export default CandidatesManager;
--- End of Content for index.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\ActiveFilters.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { X, RefreshCw, Sparkles } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import type { CandidatesFilter } from "../types/candidates";
import { motion, AnimatePresence } from "framer-motion";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ActiveFiltersProps {
  filters: CandidatesFilter;
  onRemoveFilter: (key: keyof CandidatesFilter, value?: string) => void;
  onResetAll: () => void;
  onSuggestFilter?: () => void;
  className?: string;
}

interface ActiveFilter {
  key: keyof CandidatesFilter;
  label: string;
  value?: string;
  color?: string;
}

const ActiveFilters: React.FC<ActiveFiltersProps> = ({
  filters,
  onRemoveFilter,
  onResetAll,
  onSuggestFilter,
  className,
}) => {
  const getActiveFilters = (): ActiveFilter[] => {
    const activeFilters: ActiveFilter[] = [];

    // חיפוש כללי (מופיע רק אם אין סינון נפרד)
    if (!filters.separateFiltering && filters.searchQuery) {
      activeFilters.push({
        key: "searchQuery",
        label: `חיפוש: ${filters.searchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לגברים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.maleSearchQuery) {
      activeFilters.push({
        key: "maleSearchQuery",
        label: `חיפוש מועמדים: ${filters.maleSearchQuery}`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // חיפוש נפרד לנשים (מופיע רק במצב סינון נפרד)
    if (filters.separateFiltering && filters.femaleSearchQuery) {
      activeFilters.push({
        key: "femaleSearchQuery",
        label: `חיפוש מועמדות: ${filters.femaleSearchQuery}`,
        color: "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // מצב סינון נפרד
    if (filters.separateFiltering) {
      activeFilters.push({
        key: "separateFiltering",
        label: `סינון וחיפוש נפרד`,
        color: "bg-indigo-100 text-indigo-800 border-indigo-200",
      });
    }

    // Gender
    if (filters.gender) {
      activeFilters.push({
        key: "gender",
        label: `מגדר: ${filters.gender === "MALE" ? "גברים" : "נשים"}`,
        color:
          filters.gender === "MALE"
            ? "bg-blue-100 text-blue-800 border-blue-200"
            : "bg-purple-100 text-purple-800 border-purple-200",
      });
    }

    // Age Range
    if (filters.ageRange) {
      const isDefaultMin = filters.ageRange.min === 18;
      const isDefaultMax = filters.ageRange.max === 99;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גיל: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.ageRange.min}-${filters.ageRange.max}`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.ageRange.min}`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.ageRange.max}`;
        }

        activeFilters.push({
          key: "ageRange",
          label,
        });
      }
    }

    // Height Range
    if (filters.heightRange) {
      const isDefaultMin = filters.heightRange.min === 140;
      const isDefaultMax = filters.heightRange.max === 210;

      if (!isDefaultMin || !isDefaultMax) {
        let label = `גובה: `;

        if (!isDefaultMin && !isDefaultMax) {
          label += `${filters.heightRange.min}-${filters.heightRange.max} ס"מ`;
        } else if (!isDefaultMin) {
          label += `מעל ${filters.heightRange.min} ס"מ`;
        } else if (!isDefaultMax) {
          label += `עד ${filters.heightRange.max} ס"מ`;
        }

        activeFilters.push({
          key: "heightRange",
          label,
        });
      }
    }

    // Religious Level
    if (filters.religiousLevel) {
      activeFilters.push({
        key: "religiousLevel",
        label: `רמת דתיות: ${filters.religiousLevel}`,
        color: "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Education Level
    if (filters.educationLevel) {
      activeFilters.push({
        key: "educationLevel",
        label: `השכלה: ${filters.educationLevel}`,
      });
    }

    // Cities
    filters.cities?.forEach((city) => {
      activeFilters.push({
        key: "cities",
        value: city,
        label: `עיר: ${city}`,
        color: "bg-green-100 text-green-800 border-green-200",
      });
    });

    // Occupations
    filters.occupations?.forEach((occupation) => {
      activeFilters.push({
        key: "occupations",
        value: occupation,
        label: `תחום עיסוק: ${occupation}`,
      });
    });

    // Availability Status
    if (filters.availabilityStatus) {
      const statusLabel =
        filters.availabilityStatus === "AVAILABLE"
          ? "פנוי/ה"
          : filters.availabilityStatus === "DATING"
          ? "בתהליך הכרות"
          : filters.availabilityStatus === "UNAVAILABLE"
          ? "לא פנוי/ה"
          : filters.availabilityStatus;

      activeFilters.push({
        key: "availabilityStatus",
        label: `סטטוס: ${statusLabel}`,
        color:
          filters.availabilityStatus === "AVAILABLE"
            ? "bg-emerald-100 text-emerald-800 border-emerald-200"
            : "bg-amber-100 text-amber-800 border-amber-200",
      });
    }

    // Marital Status
    if (filters.maritalStatus) {
      activeFilters.push({
        key: "maritalStatus",
        label: `מצב משפחתי: ${filters.maritalStatus}`,
      });
    }

    // Verified Filter
    if (filters.isVerified !== undefined) {
      activeFilters.push({
        key: "isVerified",
        label: `מאומתים בלבד`,
        color: "bg-blue-100 text-blue-800 border-blue-200",
      });
    }

    // References Filter
    if (filters.hasReferences !== undefined) {
      activeFilters.push({
        key: "hasReferences",
        label: `עם המלצות`,
      });
    }

    // Profile Completeness
    if (filters.isProfileComplete !== undefined) {
      activeFilters.push({
        key: "isProfileComplete",
        label: `פרופיל מלא`,
      });
    }

    // Last Activity
    if (filters.lastActiveDays !== undefined) {
      let label: string;

      switch (filters.lastActiveDays) {
        case 1:
          label = "פעילים היום";
          break;
        case 3:
          label = "פעילים ב-3 ימים אחרונים";
          break;
        case 7:
          label = "פעילים בשבוע האחרון";
          break;
        case 30:
          label = "פעילים בחודש האחרון";
          break;
        default:
          label = `פעילים ב-${filters.lastActiveDays} ימים אחרונים`;
      }

      activeFilters.push({
        key: "lastActiveDays",
        label,
        color: "bg-cyan-100 text-cyan-800 border-cyan-200",
      });
    }

    return activeFilters;
  };

  const activeFilters = getActiveFilters();

  if (activeFilters.length === 0) {
    return null;
  }

  return (
    <div className={`${className || ""}`}>
      <div className="bg-white border rounded-lg p-3">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-sm font-medium text-gray-700 flex items-center gap-1.5">
            <span>סינון פעיל</span>
            <Badge variant="outline" className="bg-blue-50 text-xs">
              {activeFilters.length}
            </Badge>
          </h3>

          <div className="flex items-center gap-2">
            {onSuggestFilter && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={onSuggestFilter}
                      className="h-7 text-xs text-blue-600 hover:text-blue-700 hover:bg-blue-50"
                    >
                      <Sparkles className="w-3 h-3 mr-1" />
                      הצע פילטרים נוספים
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>הצעת פילטרים נוספים המתאימים לתוצאות הנוכחיות</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}

            <Button
              variant="ghost"
              size="sm"
              onClick={onResetAll}
              className="h-7 text-xs text-gray-600 hover:text-gray-700"
            >
              <RefreshCw className="w-3 h-3 mr-1" />
              נקה הכל
            </Button>
          </div>
        </div>

        <div className="flex flex-wrap gap-2">
          <AnimatePresence>
            {activeFilters.map((filter, index) => (
              <motion.div
                key={`${filter.key}-${filter.value || index}`}
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                transition={{ duration: 0.15 }}
              >
                <Badge
                  variant="secondary"
                  className={`px-2 py-0.5 whitespace-nowrap border ${
                    filter.color || "bg-gray-100 text-gray-800 border-gray-200"
                  }`}
                >
                  <span className="max-w-[200px] truncate">{filter.label}</span>
                  <button
                    className="ml-1.5 hover:bg-gray-200/40 rounded-full p-0.5 transition-colors"
                    onClick={() => onRemoveFilter(filter.key, filter.value)}
                    aria-label={`הסר פילטר ${filter.label}`}
                  >
                    <X className="w-3 h-3" />
                  </button>
                </Badge>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
};

export default ActiveFilters;
--- End of Content for ActiveFilters.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\FilterPanel.tsx
--------------------------------------------------------------------------------
Content:
// /Filters/FilterPanel.tsx - גרסה משופרת
import React, { useState } from "react";
import { Card } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { UserSource } from "@prisma/client"; // At the top
import { UserStatus } from "@prisma/client";

import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { UserPlus } from "lucide-react"; // Add UserPlus for the button

import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Save,
  User,
  GraduationCap,
  MapPin,
  Scroll,
  Calendar,
  ChevronDown,
  ChevronUp,
  Clock,
  Ruler,
  Heart,
  Briefcase,
  Star,
  RefreshCw,
  Bookmark,
  Check,
  Filter as FilterIcon,
  Copy,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type { FilterState } from "../types/filters";
import type { CandidatesFilter } from "../types/candidates";
import SavedFilters from "./SavedFilters";
import {
  AGE_RANGE,
  HEIGHT_RANGE,
  RELIGIOUS_LEVELS,
  EDUCATION_LEVELS,
  OCCUPATION_CATEGORIES,
  POPULAR_CITIES,
  AVAILABILITY_STATUS_OPTIONS,
  MARITAL_STATUS,
} from "../constants/filterOptions";

interface PopularFilterOption {
  id: string;
  label: string;
  icon: React.ReactNode;
  filter: Partial<CandidatesFilter>;
}

interface FilterPanelProps {
  filters: CandidatesFilter;
  onFiltersChange: (filters: CandidatesFilter) => void;
  onSavePreset?: (name: string) => void;
  onReset: () => void;
  onApplySavedFilter?: (id: string) => void;
  savedFilters?: Array<{
    id: string;
    name: string;
    isDefault?: boolean;
  }>;
  popularFilters?: string[];
  className?: string;
  compactMode?: boolean;

  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering?: boolean;
  onToggleSeparateFiltering?: () => void;
  onMaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onFemaleFiltersChange?: (filters: Partial<FilterState>) => void;
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}

interface FilterSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
  defaultOpen?: boolean;
  badge?: number;
}

const POPULAR_FILTERS: PopularFilterOption[] = [
  {
    id: "active-recently",
    label: "פעילים לאחרונה",
    icon: <Clock className="w-4 h-4 text-blue-600" />,
    filter: {
      lastActiveDays: 7,
    },
  },
  {
    id: "verified-only",
    label: "מאומתים בלבד",
    icon: <Check className="w-4 h-4 text-blue-600" />,
    filter: {
      isVerified: true,
    },
  },
  {
    id: "has-recommendations",
    label: "עם המלצות",
    icon: <Star className="w-4 h-4 text-blue-600" />,
    filter: {
      hasReferences: true,
    },
  },
  {
    id: "available-only",
    label: "פנויים בלבד",
    icon: <Heart className="w-4 h-4 text-blue-600" />,
    filter: {
      availabilityStatus: "AVAILABLE",
    },
  },
  {
    id: "complete-profiles",
    label: "פרופילים מלאים",
    icon: <User className="w-4 h-4 text-blue-600" />,
    filter: {
      isProfileComplete: true,
    },
  },
];

const FilterSection: React.FC<FilterSectionProps> = ({
  title,
  icon,
  children,
  defaultOpen = false,
  badge,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <Collapsible
      open={isOpen}
      onOpenChange={setIsOpen}
      className="border rounded-lg mb-3 overflow-hidden bg-white"
    >
      <CollapsibleTrigger asChild>
        <div className="flex items-center justify-between p-4 cursor-pointer hover:bg-blue-50/30 transition-colors">
          <div className="flex items-center gap-2">
            <div className="bg-blue-50 p-2 rounded-md text-blue-600">
              {icon}
            </div>
            <span className="font-medium">{title}</span>
            {badge !== undefined && (
              <Badge
                variant="secondary"
                className="bg-blue-100 text-blue-800 text-xs mr-2"
              >
                {badge}
              </Badge>
            )}
          </div>
          {isOpen ? (
            <ChevronUp size={16} className="text-gray-500" />
          ) : (
            <ChevronDown size={16} className="text-gray-500" />
          )}
        </div>
      </CollapsibleTrigger>
      <CollapsibleContent className="px-4 pb-4 pt-1 border-t">
        {children}
      </CollapsibleContent>
    </Collapsible>
  );
};

// קומפוננט חדש לסינון מגדרי
const GenderFilterPanel = ({
  gender,
  filters,
  onFiltersChange,
  className,
  copyTarget,
  onCopyFilters,
}: {
  gender: "male" | "female";
  filters: Partial<FilterState>;
  onFiltersChange: (filters: Partial<FilterState>) => void;
  className?: string;
  copyTarget: "male" | "female";
  onCopyFilters?: (
    source: "male" | "female",
    target: "male" | "female"
  ) => void;
}) => {
  const genderColors = {
    male: {
      bg: "bg-blue-50/50",
      border: "border-blue-200",
      text: "text-blue-800",
      icon: <User className="w-4 h-4 text-blue-600" />,
      title: "סינון מועמדים",
    },
    female: {
      bg: "bg-purple-50/50",
      border: "border-purple-200",
      text: "text-purple-800",
      icon: <User className="w-4 h-4 text-purple-600" />,
      title: "סינון מועמדות",
    },
  };

  const colorConfig = genderColors[gender];

  return (
    <div className={`${className} mb-4 border rounded-lg overflow-hidden`}>
      {/* כותרת עם צבע תואם מגדר */}
      <div
        className={`flex justify-between items-center px-4 py-2 ${colorConfig.bg} ${colorConfig.border} border-b`}
      >
        <div className="flex items-center gap-2">
          {colorConfig.icon}
          <h3 className={`text-sm font-medium ${colorConfig.text}`}>
            {colorConfig.title}
          </h3>
        </div>
        {onCopyFilters && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onCopyFilters(gender, copyTarget)}
            className="text-xs h-7 py-0 px-2 flex items-center gap-1"
            title={`העתק הגדרות ל${
              copyTarget === "male" ? "מועמדים" : "מועמדות"
            }`}
          >
            <Copy className="w-3 h-3" />
            <span>העתק ל{copyTarget === "male" ? "מועמדים" : "מועמדות"}</span>
          </Button>
        )}
      </div>

      {/* תוכן הפאנל */}
      <div className="p-3 space-y-4">
        {/* סינון גיל - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">גיל</Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.min || AGE_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= AGE_RANGE.min &&
                      newMin <= AGE_RANGE.max
                    ) {
                      const currentMax =
                        filters?.ageRange?.max || AGE_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={AGE_RANGE.min}
                  max={AGE_RANGE.max}
                  value={filters?.ageRange?.max || AGE_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= AGE_RANGE.min &&
                      newMax <= AGE_RANGE.max
                    ) {
                      const currentMin =
                        filters?.ageRange?.min || AGE_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        ageRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                value={[
                  filters?.ageRange?.min || AGE_RANGE.default.min,
                  filters?.ageRange?.max || AGE_RANGE.default.max,
                ]}
                min={AGE_RANGE.min}
                max={AGE_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    ageRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{AGE_RANGE.min}</span>
              <span className="text-xs text-gray-400">{AGE_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* סינון גובה - מיושר נכון מימין לשמאל */}
        <div className="space-y-2">
          <Label className="text-xs font-medium text-right block">
            גובה (סמ)
          </Label>
          <div className="px-2">
            <div className="flex justify-between items-center mb-2 rtl">
              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מינימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.min || HEIGHT_RANGE.default.min}
                  onChange={(e) => {
                    const newMin = parseInt(e.target.value);
                    if (
                      !isNaN(newMin) &&
                      newMin >= HEIGHT_RANGE.min &&
                      newMin <= HEIGHT_RANGE.max
                    ) {
                      const currentMax =
                        filters?.heightRange?.max || HEIGHT_RANGE.default.max;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: Math.min(newMin, currentMax),
                          max: currentMax,
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>

              <div className="text-center">
                <span className="text-sm font-bold text-gray-400">-</span>
              </div>

              <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-1.5">
                <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                <input
                  type="number"
                  min={HEIGHT_RANGE.min}
                  max={HEIGHT_RANGE.max}
                  value={filters?.heightRange?.max || HEIGHT_RANGE.default.max}
                  onChange={(e) => {
                    const newMax = parseInt(e.target.value);
                    if (
                      !isNaN(newMax) &&
                      newMax >= HEIGHT_RANGE.min &&
                      newMax <= HEIGHT_RANGE.max
                    ) {
                      const currentMin =
                        filters?.heightRange?.min || HEIGHT_RANGE.default.min;
                      onFiltersChange({
                        ...filters,
                        heightRange: {
                          min: currentMin,
                          max: Math.max(currentMin, newMax),
                        },
                      });
                    }
                  }}
                  className="w-12 text-center text-sm font-bold text-blue-700 focus:outline-none"
                />
              </div>
            </div>

            <div className="slider-wrapper" style={{ direction: "rtl" }}>
              <Slider
                defaultValue={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                value={[
                  filters?.heightRange?.min || HEIGHT_RANGE.default.min,
                  filters?.heightRange?.max || HEIGHT_RANGE.default.max,
                ]}
                min={HEIGHT_RANGE.min}
                max={HEIGHT_RANGE.max}
                step={1}
                onValueChange={(value) => {
                  onFiltersChange({
                    heightRange: { min: value[0], max: value[1] },
                  });
                }}
                className="h-4 mt-2"
                dir="rtl"
              />
            </div>

            <div className="flex justify-between mt-1 px-1">
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.min}</span>
              <span className="text-xs text-gray-400">{HEIGHT_RANGE.max}</span>
            </div>
          </div>
        </div>

        {/* רמת דתיות */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">רמת דתיות</Label>
          <div className="px-2">
            <Select
              value={filters?.religiousLevel || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  religiousLevel: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר רמת דתיות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {RELIGIOUS_LEVELS.map((level) => (
                  <SelectItem key={level.value} value={level.value}>
                    {level.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* מצב משפחתי */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">מצב משפחתי</Label>
          <div className="px-2">
            <Select
              value={filters?.maritalStatus || ""}
              onValueChange={(value) => {
                onFiltersChange({
                  maritalStatus: value === "all" ? undefined : value,
                });
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר מצב משפחתי" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                {MARITAL_STATUS.map((status) => (
                  <SelectItem key={status.value} value={status.value}>
                    {status.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* ערים */}
        <div className="space-y-2">
          <Label className="text-xs font-medium">ערים מבוקשות</Label>
          <div className="px-2">
            <Select
              value={filters.cities?.[0] || ""}
              onValueChange={(value) => {
                if (value === "all") {
                  onFiltersChange({ cities: [] });
                } else {
                  onFiltersChange({ cities: [value] });
                }
              }}
            >
              <SelectTrigger className="w-full text-xs h-8">
                <SelectValue placeholder="בחר עיר" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">כל הערים</SelectItem>
                {POPULAR_CITIES.map((city) => (
                  <SelectItem key={city} value={city}>
                    {city}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {/* סטטוס אימות ותוספות */}
        <div className="space-y-2 pt-2 border-t border-gray-100">
          <div className="flex items-center justify-between px-2">
            <span className="text-xs font-medium">מאומתים בלבד</span>
            <Switch
              checked={filters?.isVerified || false}
              onCheckedChange={(checked) => {
                onFiltersChange({
                  isVerified: checked || undefined,
                });
              }}
            />
          </div>
        </div>

        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">עם המלצות</span>
          <Switch
            checked={filters?.hasReferences || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                hasReferences: checked || undefined,
              });
            }}
          />
        </div>
        <FilterSection
          title="מקור המועמד"
          icon={<UserPlus className="w-4 h-4" />}
        >
          <div className="pt-2">
            <Select
              value={filters.source || ""}
              onValueChange={(value) =>
                onFiltersChange({
                  ...filters,
                  source: value ? (value as UserSource) : undefined,
                })
              }
            >
              <SelectTrigger className="w-full bg-white">
                <SelectValue placeholder="בחר מקור המועמד" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">הכל</SelectItem>
                <SelectItem value={UserSource.REGISTRATION}>
                  רישום עצמי
                </SelectItem>
                <SelectItem value={UserSource.MANUAL_ENTRY}>
                  הוספה ידנית
                </SelectItem>
              </SelectContent>
            </Select>
          </div>
        </FilterSection>
        <div className="flex items-center justify-between px-2">
          <span className="text-xs font-medium">פרופיל מלא</span>
          <Switch
            checked={filters?.isProfileComplete || false}
            onCheckedChange={(checked) => {
              onFiltersChange({
                isProfileComplete: checked || undefined,
              });
            }}
          />
        </div>
      </div>
    </div>
  );
};

const FilterPanel: React.FC<FilterPanelProps> = ({
  filters,
  onFiltersChange,
  onSavePreset,
  onReset,
  onApplySavedFilter,
  savedFilters = [],
  popularFilters = [],
  className,
  compactMode = false,
  // פרמטרים לתמיכה בסינון נפרד
  separateFiltering = false,
  onToggleSeparateFiltering,
  onMaleFiltersChange,
  onFemaleFiltersChange,
  onCopyFilters,
}) => {
  const [showSavePreset, setShowSavePreset] = useState(false);
  const [presetName, setPresetName] = useState("");
  const [activeTab, setActiveTab] = useState<string>("basic");
  const [activeGenderFilter, setActiveGenderFilter] = useState<
    "male" | "female"
  >("male");

  const handleSavePreset = () => {
    if (presetName && onSavePreset) {
      onSavePreset(presetName);
      setPresetName("");
      setShowSavePreset(false);
    }
  };
  const layoutClasses = compactMode
    ? "p-1 space-y-1 text-xs" // הרבה יותר קומפקטי
    : "p-4 space-y-4"; // תצוגה רגילה

  const handleAgeRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      ageRange: { min: value[0], max: value[1] },
    });
  };

  const handleHeightRangeChange = (value: number[]) => {
    onFiltersChange({
      ...filters,
      heightRange: { min: value[0], max: value[1] },
    });
  };
  const handleApplyPopularFilter = (filter: Partial<CandidatesFilter>) => {
    onFiltersChange({
      ...filters,
      ...filter,
    });
  };

  const countActiveFilters = (category: string): number => {
    let count = 0;

    switch (category) {
      case "basic":
        // Count basic filters
        if (filters.gender) count++;
        if (
          filters.ageRange &&
          (filters.ageRange.min !== AGE_RANGE.default.min ||
            filters.ageRange.max !== AGE_RANGE.default.max)
        )
          count++;
        if (filters.cities?.length) count++;
        if (filters.religiousLevel) count++;
        break;
      case "advanced":
        // Count advanced filters
        if (
          filters.heightRange &&
          (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
            filters.heightRange.max !== HEIGHT_RANGE.default.max)
        )
          count++;
        if (filters.occupations?.length) count++;
        if (filters.educationLevel) count++;
        if (filters.maritalStatus) count++;
        break;
      case "status":
        // Count status filters
        if (filters.availabilityStatus) count++;
        if (filters.isVerified !== undefined) count++;
        if (filters.hasReferences !== undefined) count++;
        if (filters.lastActiveDays !== undefined) count++;
        if (filters.isProfileComplete !== undefined) count++;
        break;
      case "saved":
        // Count of saved filters is just the length
        return savedFilters.length;
    }

    return count;
  };

  return (
    <Card
      className={`${layoutClasses} border border-slate-200 bg-white/90 shadow-sm ${className}`}
    >
      {/* Header */}
      {!compactMode && (
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <FilterIcon className="w-5 h-5 text-blue-600" />
            <h3 className="font-semibold text-lg">סינון מועמדים</h3>
          </div>
          <div className="flex gap-2">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={onReset}
                    className="h-8 w-8 p-0"
                  >
                    <RefreshCw className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>איפוס כל הפילטרים</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>

            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowSavePreset(!showSavePreset)}
                    className="h-8 w-8 p-0"
                  >
                    <Bookmark className="w-4 h-4 text-gray-500" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>שמירת הפילטר הנוכחי</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </div>
      )}

      {/* Popular Filters */}
      {!compactMode && (
        <div className="mb-4">
          <div className="flex flex-wrap gap-2">
            {POPULAR_FILTERS.map((option) => (
              <Button
                key={option.id}
                variant="outline"
                size="sm"
                onClick={() => handleApplyPopularFilter(option.filter)}
                className="bg-white flex items-center gap-1.5 transition-all hover:bg-blue-50 hover:text-blue-700 hover:border-blue-200"
              >
                {option.icon}
                <span>{option.label}</span>
              </Button>
            ))}
          </div>
        </div>
      )}

      {/* Save Preset Form */}
      {showSavePreset && !compactMode && (
        <div className="p-4 border rounded-lg bg-blue-50/50 mb-4">
          <Label>שם לשמירת הפילטר</Label>
          <div className="flex gap-2 mt-2">
            <Input
              value={presetName}
              onChange={(e) => setPresetName(e.target.value)}
              placeholder="פילטר מותאם אישית"
              className="h-9"
            />
            <Button size="sm" onClick={handleSavePreset}>
              <Save className="w-4 h-4 ml-1.5" />
              שמור
            </Button>
          </div>
        </div>
      )}

      {/* Separate Filtering Toggle */}
      <div className="mb-4 border rounded-lg p-4 bg-blue-50/10">
        <div className="flex items-center justify-between">
          <div className="space-y-1">
            <div className="font-medium">סינון וחיפוש נפרד לפי מגדר</div>
            <p className="text-sm text-gray-500">
              סנן מועמדים ומועמדות עם קריטריונים שונים
            </p>
          </div>
          <div className="flex items-center gap-2">
            <Switch
              checked={separateFiltering}
              onCheckedChange={onToggleSeparateFiltering}
            />
            {separateFiltering && (
              <Button
                variant="outline"
                size="sm"
                onClick={onToggleSeparateFiltering}
                className="text-sm"
              >
                <RefreshCw className="w-3.5 h-3.5 mr-1.5" />
                בטל סינון נפרד
              </Button>
            )}
          </div>
        </div>
      </div>

      {/* Separate Filtering UI */}
      {separateFiltering ? (
        <div className="space-y-4">
          {/* Gender Filter Switcher */}
          <div className="flex border rounded-lg overflow-hidden mb-2">
            <Button
              type="button"
              variant={activeGenderFilter === "male" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("male")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "male" ? "bg-blue-600" : ""
              }`}
            >
              סינון מועמדים
              <User className="w-4 h-4 mr-2" />
            </Button>
            <Button
              type="button"
              variant={activeGenderFilter === "female" ? "default" : "ghost"}
              onClick={() => setActiveGenderFilter("female")}
              className={`flex-1 rounded-none ${
                activeGenderFilter === "female" ? "bg-purple-600" : ""
              }`}
            >
              סינון מועמדות
              <User className="w-4 h-4 mr-2" />
            </Button>
          </div>

          {/* Conditionally render based on active gender filter */}
          {activeGenderFilter === "male" ? (
            <GenderFilterPanel
              gender="male"
              filters={filters.maleFilters || {}}
              onFiltersChange={onMaleFiltersChange || (() => {})}
              copyTarget="female"
              onCopyFilters={onCopyFilters}
            />
          ) : (
            <GenderFilterPanel
              gender="female"
              filters={filters.femaleFilters || {}}
              onFiltersChange={onFemaleFiltersChange || (() => {})}
              copyTarget="male"
              onCopyFilters={onCopyFilters}
            />
          )}
        </div>
      ) : (
        // Standard Filtering Tabs
        <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
          <TabsList
            className={`grid grid-cols-4 w-full bg-muted/30 p-1 rounded-xl shadow-sm ${
              compactMode ? "text-xs" : ""
            }`}
          >
            <TabsTrigger
              value="basic"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                בסיסי
                {countActiveFilters("basic") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("basic")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="advanced"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                מתקדם
                {countActiveFilters("advanced") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("advanced")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="status"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                סטטוס
                {countActiveFilters("status") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("status")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
            <TabsTrigger
              value="saved"
              className="rounded-lg data-[state=active]:bg-gradient-to-r data-[state=active]:from-blue-500/90 data-[state=active]:to-blue-600 data-[state=active]:text-white"
            >
              <div className="flex flex-col items-center relative">
                שמורים
                {countActiveFilters("saved") > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center bg-blue-600 text-white">
                    {countActiveFilters("saved")}
                  </Badge>
                )}
              </div>
            </TabsTrigger>
          </TabsList>

          <div className={compactMode ? "mt-2" : "mt-4"}>
            {/* Basic Filters Tab */}
            <TabsContent value="basic" className="space-y-4">
              {/* Gender Filter */}
              <FilterSection
                title="מגדר"
                icon={<User className="w-4 h-4" />}
                defaultOpen={true}
              >
                <div className="grid grid-cols-2 gap-2 pt-2">
                  <Button
                    type="button"
                    variant={filters.gender === "MALE" ? "default" : "outline"}
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "MALE" })
                    }
                    className={
                      filters.gender === "MALE" ? "bg-blue-600" : "bg-white"
                    }
                  >
                    גברים
                  </Button>
                  <Button
                    type="button"
                    variant={
                      filters.gender === "FEMALE" ? "default" : "outline"
                    }
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: "FEMALE" })
                    }
                    className={
                      filters.gender === "FEMALE" ? "bg-purple-600" : "bg-white"
                    }
                  >
                    נשים
                  </Button>
                </div>
                {filters.gender && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, gender: undefined })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                )}
              </FilterSection>
                           <FilterSection
                title="סטטוס משתמש"
                icon={<User className="w-4 h-4" />}
                defaultOpen={true}
                badge={filters.userStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  {/* --- START OF FIX --- */}
                  <Select
                    // 1. אם הסטטוס לא מוגדר, הערך של ה-Select יהיה "all"
                    value={filters.userStatus || "all"}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        // 2. אם המשתמש בחר "all", ננקה את הפילטר (undefined). אחרת, נגדיר את הערך שנבחר.
                        userStatus: value === "all" ? undefined : (value as UserStatus),
                      })
                    }
                  >
                  {/* --- END OF FIX --- */}
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="בחר סטטוס משתמש" />
                    </SelectTrigger>
                    <SelectContent>
                      {/* --- START OF FIX --- */}
                      {/* 3. שינוי הערך של "הכל" למחרוזת שאינה ריקה */}
                      <SelectItem value="all">הכל</SelectItem>
                      {/* --- END OF FIX --- */}
                      <SelectItem value={UserStatus.ACTIVE}>פעילים</SelectItem>
                      <SelectItem value={UserStatus.PENDING_PHONE_VERIFICATION}>ממתינים לאימות טלפון</SelectItem>
                      <SelectItem value={UserStatus.PENDING_EMAIL_VERIFICATION}>ממתינים לאימות מייל</SelectItem>
                    </SelectContent>
                  </Select>
                  {filters.userStatus && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          userStatus: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>
              {/* Age Range - משופר ומתוקן */}
              <FilterSection
                title="גיל"
                icon={<Calendar className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  filters.ageRange &&
                  (filters.ageRange.min !== AGE_RANGE.default.min ||
                    filters.ageRange.max !== AGE_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.max || AGE_RANGE.default.max}
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= AGE_RANGE.min &&
                            newMax <= AGE_RANGE.max
                          ) {
                            const currentMin =
                              filters.ageRange?.min || AGE_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        value={filters.ageRange?.min || AGE_RANGE.default.min}
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= AGE_RANGE.min &&
                            newMin <= AGE_RANGE.max
                          ) {
                            const currentMax =
                              filters.ageRange?.max || AGE_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              ageRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          AGE_RANGE.default.min,
                          AGE_RANGE.default.max,
                        ]}
                        min={AGE_RANGE.min}
                        max={AGE_RANGE.max}
                        step={1}
                        value={[
                          filters.ageRange?.min || AGE_RANGE.default.min,
                          filters.ageRange?.max || AGE_RANGE.default.max,
                        ]}
                        onValueChange={handleAgeRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.max}
                      </span>
                      <span className="text-xs text-gray-500">
                        {AGE_RANGE.min}
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Cities Filter */}
              <FilterSection
                title="ערים"
                icon={<MapPin className="w-4 h-4" />}
                badge={filters.cities?.length}
              >
                <ScrollArea className="h-48 mt-2 rounded-md border overflow-hidden bg-white pr-4">
                  <div className="p-2">
                    {POPULAR_CITIES.map((city) => (
                      <div
                        key={city}
                        className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                      >
                        <span className="text-sm">{city}</span>
                        <Switch
                          checked={filters.cities?.includes(city) || false}
                          onCheckedChange={(checked) => {
                            const newCities = checked
                              ? [...(filters.cities || []), city]
                              : filters.cities?.filter((c) => c !== city);
                            onFiltersChange({ ...filters, cities: newCities });
                          }}
                        />
                      </div>
                    ))}
                  </div>
                </ScrollArea>
                {filters.cities?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => onFiltersChange({ ...filters, cities: [] })}
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Religious Level */}
              <FilterSection
                title="רמת דתיות"
                icon={<Scroll className="w-4 h-4" />}
                badge={filters.religiousLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.religiousLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        religiousLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="בחר רמת דתיות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {RELIGIOUS_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Advanced Filters Tab */}
            <TabsContent value="advanced" className="space-y-4">
              {/* Height Range - משופר ומתוקן */}
              <FilterSection
                title="גובה (ס״מ)"
                icon={<Ruler className="w-4 h-4" />}
                badge={
                  filters.heightRange &&
                  (filters.heightRange.min !== HEIGHT_RANGE.default.min ||
                    filters.heightRange.max !== HEIGHT_RANGE.default.max)
                    ? 1
                    : undefined
                }
              >
                <div className="space-y-6 pt-4">
                  {/* הצגת ערכים נוכחיים עם אפשרות להזנה ידנית - סדר מתוקן */}
                  <div className="flex justify-between items-center">
                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מקסימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.max || HEIGHT_RANGE.default.max
                        }
                        onChange={(e) => {
                          const newMax = parseInt(e.target.value);
                          if (
                            !isNaN(newMax) &&
                            newMax >= HEIGHT_RANGE.min &&
                            newMax <= HEIGHT_RANGE.max
                          ) {
                            const currentMin =
                              filters.heightRange?.min ||
                              HEIGHT_RANGE.default.min;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: currentMin,
                                max: Math.max(currentMin, newMax),
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>

                    <div className="text-center">
                      <span className="text-lg font-bold text-gray-400">-</span>
                    </div>

                    <div className="text-center bg-white border border-gray-200 rounded-lg shadow-sm p-2">
                      <p className="text-xs text-gray-500 mb-1">מינימום</p>
                      <input
                        type="number"
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        value={
                          filters.heightRange?.min || HEIGHT_RANGE.default.min
                        }
                        onChange={(e) => {
                          const newMin = parseInt(e.target.value);
                          if (
                            !isNaN(newMin) &&
                            newMin >= HEIGHT_RANGE.min &&
                            newMin <= HEIGHT_RANGE.max
                          ) {
                            const currentMax =
                              filters.heightRange?.max ||
                              HEIGHT_RANGE.default.max;
                            onFiltersChange({
                              ...filters,
                              heightRange: {
                                min: Math.min(newMin, currentMax),
                                max: currentMax,
                              },
                            });
                          }
                        }}
                        className="w-16 text-center text-lg font-bold text-blue-700 focus:outline-none"
                      />
                    </div>
                  </div>

                  {/* סרגל משופר */}
                  <div className="px-2">
                    <div
                      className="slider-wrapper"
                      style={{ direction: "rtl" }}
                    >
                      <Slider
                        defaultValue={[
                          HEIGHT_RANGE.default.min,
                          HEIGHT_RANGE.default.max,
                        ]}
                        min={HEIGHT_RANGE.min}
                        max={HEIGHT_RANGE.max}
                        step={1}
                        value={[
                          filters.heightRange?.min || HEIGHT_RANGE.default.min,
                          filters.heightRange?.max || HEIGHT_RANGE.default.max,
                        ]}
                        onValueChange={handleHeightRangeChange}
                        className="h-5"
                        dir="rtl"
                      />
                    </div>

                    {/* טווח ערכים */}
                    <div className="flex justify-between mt-2 px-1">
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.min} ס״מ
                      </span>
                      <span className="text-xs text-gray-500">
                        {HEIGHT_RANGE.max} ס״מ
                      </span>
                    </div>
                  </div>
                </div>
              </FilterSection>

              {/* Occupation */}
              <FilterSection
                title="תחום עיסוק"
                icon={<Briefcase className="w-4 h-4" />}
                badge={filters.occupations?.length}
              >
                <ScrollArea className="h-48 rounded-md mt-2 border p-2 bg-white pr-4">
                  {OCCUPATION_CATEGORIES.map((occupation) => (
                    <div
                      key={occupation.value}
                      className="flex items-center justify-between py-1.5 hover:bg-gray-50 px-2 rounded-md"
                    >
                      <span className="text-sm">{occupation.label}</span>
                      <Switch
                        checked={
                          filters.occupations?.includes(occupation.value) ||
                          false
                        }
                        onCheckedChange={(checked) => {
                          const newOccupations = checked
                            ? [...(filters.occupations || []), occupation.value]
                            : filters.occupations?.filter(
                                (o) => o !== occupation.value
                              );
                          onFiltersChange({
                            ...filters,
                            occupations: newOccupations,
                          });
                        }}
                      />
                    </div>
                  ))}
                </ScrollArea>
                {filters.occupations?.length ? (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() =>
                      onFiltersChange({ ...filters, occupations: [] })
                    }
                    className="w-full mt-2 text-sm text-gray-500"
                  >
                    הסר בחירה
                  </Button>
                ) : null}
              </FilterSection>

              {/* Education Level */}
              <FilterSection
                title="השכלה"
                icon={<GraduationCap className="w-4 h-4" />}
                badge={filters.educationLevel ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.educationLevel || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        educationLevel: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="רמת השכלה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {EDUCATION_LEVELS.map((level) => (
                        <SelectItem key={level.value} value={level.value}>
                          {level.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>

              {/* Marital Status */}
              <FilterSection
                title="מצב משפחתי"
                icon={<Heart className="w-4 h-4" />}
                badge={filters.maritalStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.maritalStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        maritalStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="מצב משפחתי" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {MARITAL_STATUS.map((status) => (
                        <SelectItem key={status.value} value={status.value}>
                          {status.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </FilterSection>
            </TabsContent>

            {/* Status & Availability Filters Tab */}
            <TabsContent value="status" className="space-y-4">
              {/* Availability Status */}
              <FilterSection
                title="סטטוס זמינות"
                icon={<Clock className="w-4 h-4" />}
                defaultOpen={true}
                badge={filters.availabilityStatus ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.availabilityStatus || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        availabilityStatus: value || undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="סטטוס זמינות" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      {AVAILABILITY_STATUS_OPTIONS.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          <div className="flex items-center gap-2">
                            <div
                              className={`w-2 h-2 rounded-full ${
                                option.value === "AVAILABLE"
                                  ? "bg-emerald-500"
                                  : option.value === "DATING"
                                  ? "bg-amber-500"
                                  : "bg-red-500"
                              }`}
                            />
                            {option.label}
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {filters.availabilityStatus && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          availabilityStatus: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>

              {/* Verification Switches */}
              <FilterSection
                title="אימות ואיכות פרופיל"
                icon={<Check className="w-4 h-4" />}
                defaultOpen={true}
                badge={
                  (filters.isVerified !== undefined ? 1 : 0) +
                  (filters.hasReferences !== undefined ? 1 : 0) +
                  (filters.isProfileComplete !== undefined ? 1 : 0)
                }
              >
                <div className="space-y-3 pt-2">
                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">מועמדים מאומתים בלבד</span>
                    <Switch
                      checked={filters.isVerified || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isVerified: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">עם המלצות בלבד</span>
                    <Switch
                      checked={filters.hasReferences || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          hasReferences: checked || undefined,
                        })
                      }
                    />
                  </div>

                  <div className="flex items-center justify-between py-1 px-2 hover:bg-gray-50 rounded-md">
                    <span className="text-sm">פרופילים מלאים בלבד</span>
                    <Switch
                      checked={filters.isProfileComplete || false}
                      onCheckedChange={(checked) =>
                        onFiltersChange({
                          ...filters,
                          isProfileComplete: checked || undefined,
                        })
                      }
                    />
                  </div>
                </div>
              </FilterSection>

              {/* Activity Filter */}
              <FilterSection
                title="פעילות אחרונה"
                icon={<Clock className="w-4 h-4" />}
                badge={filters.lastActiveDays ? 1 : undefined}
              >
                <div className="pt-2">
                  <Select
                    value={filters.lastActiveDays?.toString() || ""}
                    onValueChange={(value) =>
                      onFiltersChange({
                        ...filters,
                        lastActiveDays: value ? parseInt(value) : undefined,
                      })
                    }
                  >
                    <SelectTrigger className="w-full bg-white">
                      <SelectValue placeholder="פעילות אחרונה" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">הכל</SelectItem>
                      <SelectItem value="1">היום</SelectItem>
                      <SelectItem value="3">3 ימים אחרונים</SelectItem>
                      <SelectItem value="7">שבוע אחרון</SelectItem>
                      <SelectItem value="30">חודש אחרון</SelectItem>
                    </SelectContent>
                  </Select>
                  {filters.lastActiveDays && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() =>
                        onFiltersChange({
                          ...filters,
                          lastActiveDays: undefined,
                        })
                      }
                      className="w-full mt-2 text-sm text-gray-500"
                    >
                      הסר בחירה
                    </Button>
                  )}
                </div>
              </FilterSection>
            </TabsContent>

            {/* Saved Filters Tab */}
            <TabsContent value="saved" className="space-y-4">
              {savedFilters.length === 0 ? (
                <div className="text-center py-8 text-gray-500 bg-white rounded-lg border p-4">
                  <Bookmark className="w-8 h-8 mx-auto mb-2 text-gray-400" />
                  <h3 className="mb-1 font-medium">אין פילטרים שמורים</h3>
                  <p className="text-sm">
                    שמור את הפילטר הנוכחי ע״י לחיצה על כפתור השמירה
                  </p>
                </div>
              ) : (
                <SavedFilters
                  filters={savedFilters.map((filter) => ({
                    id: filter.id,
                    name: filter.name,
                    filter: {},
                    isDefault: filter.isDefault,
                    createdAt: new Date(),
                  }))}
                  activeFilterId={filters.savedFilterId}
                  onSelect={(filter) => onApplySavedFilter?.(filter.id)}
                  onDelete={() => {}}
                  onEdit={() => {}}
                  onSetDefault={() => {}}
                />
              )}

              {popularFilters.length > 0 && (
                <div className="mt-4">
                  <h4 className="font-medium text-sm mb-2">
                    חיפושים פופולריים
                  </h4>
                  <div className="flex flex-wrap gap-2">
                    {popularFilters.map((term, index) => (
                      <Badge
                        key={index}
                        variant="outline"
                        className="cursor-pointer bg-blue-50 border-blue-200 hover:bg-blue-100 transition-colors"
                        onClick={() =>
                          onFiltersChange({
                            ...filters,
                            searchQuery: term,
                          })
                        }
                      >
                        {term}
                      </Badge>
                    ))}
                  </div>
                </div>
              )}
            </TabsContent>
          </div>
        </Tabs>
      )}

      {/* Action buttons */}
      <div
        className={`${
          compactMode ? "pt-2 mt-2" : "pt-4 mt-4"
        } border-t flex justify-end gap-2`}
      >
        <Button
          variant="outline"
          size={compactMode ? "sm" : "default"}
          onClick={onReset}
          className="bg-white"
        >
          איפוס
        </Button>
        {!compactMode && (
          <Button onClick={() => setShowSavePreset(true)} size="sm">
            <Save className="w-4 h-4 ml-1.5" />
            שמירת פילטר
          </Button>
        )}
      </div>
    </Card>
  );
};

export default FilterPanel;
--- End of Content for FilterPanel.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\SavedFilters.tsx
--------------------------------------------------------------------------------
Content:
// /components/matchmaker/Filters/SavedFilters.tsx
"use client";
import React from "react";
import { Star, MoreVertical, Edit, Trash } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import type { CandidatesFilter } from "../types/candidates";

interface SavedFilter {
  id: string;
  name: string;
  filter: CandidatesFilter;
  isDefault?: boolean;
  createdAt: Date;
}

interface SavedFiltersProps {
  filters: SavedFilter[];
  activeFilterId?: string;
  onSelect: (filter: SavedFilter) => void;
  onDelete: (filterId: string) => void;
  onEdit: (filter: SavedFilter) => void;
  onSetDefault: (filterId: string) => void;
  className?: string;
}

const SavedFilters: React.FC<SavedFiltersProps> = ({
  filters,
  activeFilterId,
  onSelect,
  onDelete,
  onEdit,
  onSetDefault,
  className,
}) => {
  return (
    <div className={`space-y-2 ${className}`}>
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium text-gray-700">פילטרים שמורים</h3>
        <Badge variant="secondary" className="text-xs">
          {filters.length}
        </Badge>
      </div>

      <ScrollArea className="h-[300px]">
        <div className="space-y-2">
          {filters.map((filter) => (
            <div
              key={filter.id}
              className={`
                flex items-center justify-between p-2 rounded-lg
                ${
                  activeFilterId === filter.id
                    ? "bg-blue-50 border border-blue-200"
                    : "bg-white hover:bg-gray-50"
                }
                transition-colors cursor-pointer
              `}
              onClick={() => onSelect(filter)}
            >
              <div className="flex items-center gap-2">
                {filter.isDefault && (
                  <Star className="w-4 h-4 text-yellow-400" />
                )}
                <div>
                  <p className="font-medium text-sm">{filter.name}</p>
                  <p className="text-xs text-gray-500">
                    {formatFilterSummary(filter.filter)}
                  </p>
                </div>
              </div>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8 w-8 p-0"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <MoreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onEdit(filter)}>
                    <Edit className="ml-2 h-4 w-4" />
                    עריכה
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => onSetDefault(filter.id)}
                    disabled={filter.isDefault}
                  >
                    <Star className="ml-2 h-4 w-4" />
                    הגדר כברירת מחדל
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onDelete(filter.id)}>
                    <Trash className="ml-2 h-4 w-4" />
                    מחיקה
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
};

// פונקציית עזר להצגת סיכום הפילטר
const formatFilterSummary = (filter: CandidatesFilter): string => {
  const parts: string[] = [];

  if (filter.ageRange) {
    parts.push(`גיל: ${filter.ageRange.min}-${filter.ageRange.max}`);
  }

  if (filter.cities?.length) {
    parts.push(`ערים: ${filter.cities.length}`);
  }

  if (filter.religiousLevel) {
    parts.push(`רמה דתית: ${filter.religiousLevel}`);
  }

  if (filter.occupations?.length) {
    parts.push(`תחומי עיסוק: ${filter.occupations.length}`);
  }

  return parts.join(" | ") || "פילטר ריק";
};

export default SavedFilters;
--- End of Content for SavedFilters.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\Filters\SearchBar.tsx
--------------------------------------------------------------------------------
Content:
// /Filters/SearchBar.tsx - גרסה עם לוגים לדיבאג
"use client";

import React, { useState, useEffect, useRef } from "react";
import { Search, X, History } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import type { Candidate } from "../types/candidates";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSelect?: (candidate: Candidate) => void;
  recentSearches?: string[];
  onSaveSearch?: (value: string) => void;
  onClearRecentSearches?: () => void;
  suggestions?: Candidate[];
  loading?: boolean;
  className?: string;
  placeholder?: string;
  autoFocus?: boolean;
  // הוספת שדה לציון לאיזה מגדר החיפוש מכוון
  genderTarget?: "male" | "female" | "all";
  // הוספת שדה לציון האם החיפוש מופעל במצב נפרד
  separateMode?: boolean;
}

const SEARCH_CATEGORIES = [
  { id: "name", label: "שם", placeholder: "חיפוש לפי שם..." },
  { id: "city", label: "עיר", placeholder: "חיפוש לפי עיר..." },
  {
    id: "occupation",
    label: "תחום עיסוק",
    placeholder: "חיפוש לפי תחום עיסוק...",
  },
  { id: "all", label: "הכל", placeholder: "חיפוש בכל השדות..." },
];

const SearchBar: React.FC<SearchBarProps> = ({
  value,
  onChange,
  onSelect,
  recentSearches = [],
  onSaveSearch,
  onClearRecentSearches,
  suggestions = [],
  loading = false,
  className = "",
  placeholder = "חיפוש מועמדים...",
  autoFocus = false,
  genderTarget = "all",
  separateMode = false,
}) => {
  const [open, setOpen] = useState(false);
  const [searchCategory, setSearchCategory] = useState<string>("all");
  const [inputValue, setInputValue] = useState(value);
  const [showClearButton, setShowClearButton] = useState(Boolean(value));
  const inputRef = useRef<HTMLInputElement>(null);
  const searchContainerRef = useRef<HTMLDivElement>(null);

  // לוג מצב התחלתי
  console.log("SearchBar mounted/updated. Props:", {
    initialValue: value,
    suggestionsCount: suggestions.length,
    recentSearchesCount: recentSearches.length,
  });

  // Sync input value with prop value
  useEffect(() => {
    console.log("Value prop changed:", value);
    setInputValue(value);
    setShowClearButton(Boolean(value));
  }, [value]);

  // Handle search when user presses Enter or selects a suggestion
  const handleSearch = (searchValue: string) => {
    console.log(
      `handleSearch called with: ${searchValue}, gender: ${genderTarget}, separate: ${separateMode}`
    );

    if (searchValue.trim()) {
      onChange(searchValue.trim());

      if (onSaveSearch) {
        // שמירת החיפוש בהיסטוריה
        // אפשר גם לשמור את המגדר אם יש צורך
        onSaveSearch(searchValue.trim());
      }
    }
  };
  // כשמשתמשים בחיפוש נפרד, נעדכן את הפלייסהולדר בהתאם
  const getSearchPlaceholder = () => {
    if (separateMode) {
      // מצא את ה-placeholder של הקטגוריה "all" או השתמש בברירת מחדל
      const allCategoryPlaceholder =
        SEARCH_CATEGORIES.find((cat) => cat.id === "all")?.placeholder ||
        "חיפוש בכל השדות...";

      if (genderTarget === "male") {
        return `חיפוש מועמדים - ${allCategoryPlaceholder}`;
      }
      if (genderTarget === "female") {
        return `חיפוש מועמדות - ${allCategoryPlaceholder}`;
      }
    }

    // אם לא במצב סינון נפרד, השתמש בקטגוריה הנוכחית שנבחרה
    const category = SEARCH_CATEGORIES.find((cat) => cat.id === searchCategory);
    return category?.placeholder || placeholder;
  };
  // Handle input change
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    console.log("handleInputChange:", { oldValue: inputValue, newValue });

    setInputValue(newValue);
    setShowClearButton(Boolean(newValue));

    // CRITICAL: הפעלת onChange בכל הקלדה כדי שהחיפוש יקרה בזמן אמת
    console.log(
      "Calling onChange directly from handleInputChange with:",
      newValue
    );
    onChange(newValue);
  };

  // Handle keyboard events
  const handleKeyDown = (e: React.KeyboardEvent) => {
    console.log("handleKeyDown:", e.key);

    if (e.key === "Enter" && inputValue.trim()) {
      console.log("Enter pressed with value:", inputValue);
      handleSearch(inputValue);
      setOpen(false);
    } else if (e.key === "Escape") {
      console.log("Escape pressed, closing dropdown");
      setOpen(false);
    }
  };

  // Clear search input
  const handleClear = () => {
    console.log("handleClear called");
    setInputValue("");
    console.log("Calling onChange with empty string from handleClear");
    onChange("");
    setShowClearButton(false);
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        searchContainerRef.current &&
        !searchContainerRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  // Handle suggestion selection
  const handleSuggestionSelect = (candidate: Candidate) => {
    console.log(
      "handleSuggestionSelect called with candidate:",
      `${candidate.firstName} ${candidate.lastName}`
    );

    if (onSelect) {
      console.log("Calling onSelect for the candidate");
      onSelect(candidate);
    } else {
      // אם אין פונקציית בחירה, התייחס לכך כחיפוש טקסט
      const searchText = `${candidate.firstName} ${candidate.lastName}`;
      console.log("No onSelect provided, using as text search:", searchText);
      setInputValue(searchText);
      console.log("Calling onChange with:", searchText);
      onChange(searchText);
    }
    setOpen(false);
  };

   return (
    <div className={`relative ${className}`} ref={searchContainerRef}>
      {/* Search Input Field */}
      <div className="relative flex items-center rounded-lg border border-input bg-background shadow-sm transition-colors focus-within:ring-1 focus-within:ring-blue-200">
        <Search className="absolute right-3 h-4 w-4 text-muted-foreground" />

        {/* הכנסת שדה הקלט */}
        <Input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onClick={() => {
            console.log("Search input clicked, opening dropdown");
            setOpen(true);
          }}
          placeholder={getSearchPlaceholder()}
          className={`border-0 pr-10 focus-visible:ring-0 focus-visible:ring-offset-0 ${
            separateMode ? "pl-16" : ""
          }`}
          autoFocus={autoFocus}
        />

        {/* תווית המגדר כתווית קבועה שלא חופפת את יתר האלמנטים */}
        {separateMode && (
          <div className="absolute left-4 top-1/2 -translate-y-1/2 z-10">
            <Badge
              variant="outline"
              className={
                genderTarget === "male"
                  ? "bg-blue-100 text-blue-800 border-blue-200"
                  : genderTarget === "female"
                  ? "bg-purple-100 text-purple-800 border-purple-200"
                  : ""
              }
            >
              {genderTarget === "male"
                ? "מועמדים"
                : genderTarget === "female"
                ? "מועמדות"
                : "הכל"}
            </Badge>
          </div>
        )}

        {/* כפתור ניקוי עם מיקום משופר */}
        {showClearButton && (
          <Button
            type="button"
            variant="ghost"
            size="icon"
            onClick={handleClear}
            className={`absolute ${
              separateMode ? "left-16" : "left-3 md:left-40"
            } top-1/2 -translate-y-1/2 h-7 w-7 z-10`}
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>

      {/* Suggestions Dropdown - Custom Styled */}
      {open && (
        <div
          className="absolute z-50 mt-1 w-full rounded-md border bg-white shadow-lg"
          style={{ maxHeight: "400px", overflowY: "auto" }}
        >
          {/* Search Input for Filtering */}
          <div className="p-2 border-b">
            <div className="relative">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-muted-foreground opacity-70" />
              <input
                type="text"
                value={inputValue}
                onChange={(e) => {
                  const newValue = e.target.value;
                  console.log("Dropdown filter input changed:", {
                    oldValue: inputValue,
                    newValue,
                  });
                  setInputValue(newValue);

                  // CRITICAL: וודא שהערך מועבר להורה בזמן הקלדה
                  console.log(
                    "Calling onChange from dropdown filter with:",
                    newValue
                  );
                  onChange(newValue);
                }}
                className="w-full border rounded-md px-3 pr-9 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-blue-300"
                placeholder="סנן תוצאות..."
                autoFocus
              />
            </div>
          </div>

          {/* No Results */}
          {suggestions.length === 0 && recentSearches.length === 0 && (
            <div className="p-4 text-center text-sm text-gray-500">
              {loading ? "טוען..." : "לא נמצאו תוצאות"}
            </div>
          )}

          {/* Recent Searches Section */}
          {recentSearches.length > 0 && (
            <div className="border-b">
              <div className="px-2 py-1.5 text-xs text-gray-500 flex justify-between">
                <span className="font-medium">חיפושים אחרונים</span>
                {onClearRecentSearches && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-5 text-xs"
                    onClick={(e) => {
                      e.stopPropagation();
                      console.log("Clear recent searches clicked");
                      onClearRecentSearches();
                    }}
                  >
                    נקה היסטוריה
                  </Button>
                )}
              </div>
              <div className="p-1">
                {recentSearches.slice(0, 5).map((search, index) => (
                  <div
                    key={`recent-${index}`}
                    className="flex items-center gap-2 text-right px-3 py-1.5 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log("Recent search clicked:", search);
                      handleSearch(search);
                      setOpen(false);
                    }}
                  >
                    <History className="h-4 w-4 text-blue-400" />
                    <span className="text-sm">{search}</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Suggestions Section */}
          {suggestions.length > 0 && (
            <div>
              <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
                תוצאות
              </div>
              <div className="p-1">
                {suggestions.map((candidate) => (
                  <div
                    key={candidate.id}
                    className="flex items-center gap-2 text-right px-3 py-2 hover:bg-blue-50 rounded-md cursor-pointer"
                    onClick={() => {
                      console.log(
                        "Suggestion clicked:",
                        `${candidate.firstName} ${candidate.lastName}`
                      );
                      handleSuggestionSelect(candidate);
                    }}
                  >
                    <div className="flex-1">
                      <div className="font-medium text-sm">
                        {`${candidate.firstName} ${candidate.lastName}`}
                      </div>
                      <div className="text-xs text-gray-500 truncate">
                        {[
                          candidate.profile.city,
                          candidate.profile.occupation,
                          candidate.profile.religiousLevel,
                        ]
                          .filter(Boolean)
                          .join(" | ")}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}



          {/* Search Categories on Mobile */}
          <div className="md:hidden border-t">
            <div className="px-2 py-1.5 text-xs text-gray-500 font-medium">
              חפש לפי
            </div>
            <div className="flex flex-wrap gap-1 p-2">
              {SEARCH_CATEGORIES.map((category) => (
                <Badge
                  key={category.id}
                  variant={
                    searchCategory === category.id ? "default" : "outline"
                  }
                  className={`cursor-pointer ${
                    searchCategory === category.id
                      ? "bg-blue-500 text-white"
                      : "bg-transparent hover:bg-blue-50"
                  }`}
                  onClick={() => {
                    console.log("Mobile category changed to:", category.id);
                    setSearchCategory(category.id);
                  }}
                >
                  {category.label}
                </Badge>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SearchBar;
--- End of Content for SearchBar.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants\filterOptions.ts
--------------------------------------------------------------------------------
Content:
// /constants/filterOptions.ts
import { AvailabilityStatus } from '@prisma/client';

export const AGE_RANGE = {
  min: 18,
  max: 99,
  default: {
    min: 20,
    max: 35
  }
};

export const HEIGHT_RANGE = {
  min: 140,
  max: 210,
  default: {
    min: 150,
    max: 190
  }
};

export const RELIGIOUS_LEVELS = [
  { value: 'חרדי', label: 'חרדי' },
  { value: 'דתי לאומי', label: 'דתי לאומי' },
  { value: 'דתי', label: 'דתי' },
  { value: 'מסורתי', label: 'מסורתי' }
];

export const EDUCATION_LEVELS = [
  { value: 'תיכונית', label: 'השכלה תיכונית' },
  { value: 'ישיבה', label: 'ישיבה' },
  { value: 'סמינר', label: 'סמינר' },
  { value: 'תואר ראשון', label: 'תואר ראשון' },
  { value: 'תואר שני', label: 'תואר שני' },
  { value: 'דוקטורט', label: 'דוקטורט' }
];

export const MARITAL_STATUS = [
  { value: 'רווק/ה', label: 'רווק/ה' },
  { value: 'גרוש/ה', label: 'גרוש/ה' },
  { value: 'אלמן/ה', label: 'אלמן/ה' }
];

export const OCCUPATION_CATEGORIES = [
  { value: 'חינוך', label: 'חינוך והוראה' },
  { value: 'הייטק', label: 'הייטק ותוכנה' },
  { value: 'רפואה', label: 'רפואה ובריאות' },
  { value: 'משפטים', label: 'משפטים' },
  { value: 'עסקים', label: 'עסקים וכלכלה' },
  { value: 'שירותים', label: 'שירותים' },
  { value: 'אחר', label: 'אחר' }
];

export const REGIONS = [
  { value: 'ירושלים', label: 'ירושלים והסביבה' },
  { value: 'תל אביב', label: 'תל אביב והמרכז' },
  { value: 'חיפה', label: 'חיפה והצפון' },
  { value: 'באר שבע', label: 'באר שבע והדרום' },
  { value: 'יהודה ושומרון', label: 'יהודה ושומרון' }
];

export const POPULAR_CITIES = [
  'ירושלים',
  'תל אביב',
  'חיפה',
  'בני ברק',
  'פתח תקווה',
  'אשדוד',
  'נתניה',
  'באר שבע',
  'חולון',
  'רמת גן',
  'בית שמש',
  'מודיעין עילית',
  'אלעד',
  'ביתר עילית'
];

export const AVAILABILITY_STATUS_OPTIONS = [
  { 
    value: AvailabilityStatus.AVAILABLE, 
    label: 'פנוי/ה',
    description: 'מועמד/ת פנוי/ה להצעות'
  },
  { 
    value: AvailabilityStatus.DATING, 
    label: 'בתהליך הכרות',
    description: 'נמצא/ת בתהליך הכרות'
  },
  { 
    value: AvailabilityStatus.UNAVAILABLE, 
    label: 'לא פנוי/ה',
    description: 'לא פנוי/ה להצעות כרגע'
  }
];

export const SORT_OPTIONS = [
  { 
    value: 'lastActive',
    label: 'פעילות אחרונה',
    defaultOrder: 'desc'
  },
  { 
    value: 'age',
    label: 'גיל',
    defaultOrder: 'asc'
  },
  { 
    value: 'name',
    label: 'שם',
    defaultOrder: 'asc'
  },
  { 
    value: 'city',
    label: 'עיר',
    defaultOrder: 'asc'
  },
  { 
    value: 'religiousLevel',
    label: 'רמת דתיות',
    defaultOrder: 'asc'
  },
  { 
    value: 'height',
    label: 'גובה',
    defaultOrder: 'desc'
  },
  { 
    value: 'registrationDate',
    label: 'תאריך הרשמה',
    defaultOrder: 'desc'
  }
];

export const VIEW_OPTIONS = [
  {
    value: 'grid',
    label: 'תצוגת גריד',
    icon: 'LayoutGrid'
  },
  {
    value: 'list',
    label: 'תצוגת רשימה',
    icon: 'List'
  }
];

export const CARD_SIZES = [
  {
    value: 'sm',
    label: 'קטן',
    dimensions: {
      grid: 'h-64',
      list: 'h-24'
    }
  },
  {
    value: 'md',
    label: 'בינוני',
    dimensions: {
      grid: 'h-80',
      list: 'h-32'
    }
  },
  {
    value: 'lg',
    label: 'גדול',
    dimensions: {
      grid: 'h-96',
      list: 'h-40'
    }
  }
];

export const GROUP_BY_OPTIONS = [
  {
    value: 'none',
    label: 'ללא קיבוץ'
  },
  {
    value: 'city',
    label: 'עיר'
  },
  {
    value: 'religiousLevel',
    label: 'רמת דתיות'
  },
  {
    value: 'ageGroup',
    label: 'קבוצת גיל'
  },
  {
    value: 'availability',
    label: 'סטטוס זמינות'
  }
];

export const DEFAULT_FILTERS = {
  gender: undefined,
  ageRange: AGE_RANGE.default,
  heightRange: HEIGHT_RANGE.default,
  cities: [],
  religiousLevel: undefined,
  occupations: [],
  availability: undefined,
  searchQuery: '',
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined
};

export const FILTER_CATEGORIES = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'education', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availability', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];
--- End of Content for filterOptions.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\constants\matchingCriteria.ts
--------------------------------------------------------------------------------
Content:
// /constants/matchingCriteria.ts

export const CRITERIA_WEIGHTS = {
    // קריטריונים בסיסיים
    age: {
      weight: 15,
      description: 'התאמת גיל',
      thresholds: {
        perfect: 2,  // הפרש של עד שנתיים
        good: 5,     // הפרש של עד 5 שנים
        fair: 8      // הפרש של עד 8 שנים
      }
    },
    
    religiousLevel: {
      weight: 20,
      description: 'התאמה דתית',
      bonusPoints: {
        exactMatch: 1.0,        // התאמה מדויקת
        adjacentLevel: 0.8,     // רמה דתית סמוכה
        twoLevelsApart: 0.4     // הפרש של שתי רמות
      }
    },
  
    location: {
      weight: 10,
      description: 'מיקום גיאוגרפי',
      bonusPoints: {
        sameCity: 1.0,          // אותה עיר
        sameRegion: 0.8,        // אותו אזור
        preferredCity: 0.7,     // עיר מועדפת
        differentRegion: 0.4    // אזור אחר
      }
    },
  
    // קריטריונים מקצועיים והשכלתיים
    education: {
      weight: 8,
      description: 'רמת השכלה',
      bonusPoints: {
        sameLevel: 1.0,         // רמת השכלה זהה
        adjacentLevel: 0.8,     // רמת השכלה סמוכה
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    occupation: {
      weight: 7,
      description: 'תחום עיסוק',
      bonusPoints: {
        sameField: 1.0,         // אותו תחום
        relatedField: 0.8,      // תחום קרוב
        meetPreferences: 0.7    // עומד בהעדפות
      }
    },
  
    // קריטריונים אישיים
    familyBackground: {
      weight: 12,
      description: 'רקע משפחתי',
      factors: {
        origin: 0.4,            // מוצא
        parentStatus: 0.3,      // מצב הורים
        familyType: 0.3         // סוג משפחה
      }
    },
  
    personalityMatch: {
      weight: 15,
      description: 'התאמה אישיותית',
      factors: {
        hobbies: 0.3,           // תחביבים משותפים
        lifestyle: 0.4,         // סגנון חיים
        values: 0.3             // ערכים משותפים
      }
    },
  
    // גורמים נוספים
    preferences: {
      weight: 8,
      description: 'העדפות אישיות',
      factors: {
        agePreference: 0.3,     // העדפות גיל
        locationPreference: 0.3, // העדפות מיקום
        otherPreferences: 0.4   // העדפות נוספות
      }
    },
  
    compatibility: {
      weight: 5,
      description: 'תאימות כללית',
      factors: {
        language: 0.3,          // שפה משותפת
        culture: 0.4,           // תרבות
        lifestyle: 0.3          // סגנון חיים
      }
    }
  };
  
  // סף ציון להתאמה טובה
  export const MATCH_THRESHOLDS = {
    EXCELLENT: 85,  // התאמה מצוינת
    GOOD: 75,       // התאמה טובה
    FAIR: 65,       // התאמה סבירה
    POOR: 50        // התאמה חלשה
  };
  
  // משקלים יחסיים לפי סוג התאמה
  export const MATCH_TYPE_WEIGHTS = {
    PRECISE: {     // התאמה מדויקת
      exact: 1.0,
      similar: 0.8,
      partial: 0.5
    },
    FLEXIBLE: {    // התאמה גמישה
      exact: 0.8,
      similar: 1.0,
      partial: 0.7
    },
    OPEN: {        // התאמה פתוחה
      exact: 0.7,
      similar: 0.9,
      partial: 1.0
    }
  };
  
  // הגדרת קטגוריות להתאמה
  export const MATCH_CATEGORIES = {
    IMMEDIATE: {
      minScore: 90,
      label: 'התאמה מיידית',
      description: 'התאמה גבוהה מאוד, מומלץ ליצור קשר בהקדם'
    },
    HIGH: {
      minScore: 80,
      label: 'התאמה גבוהה',
      description: 'התאמה טובה מאוד, שווה לבדוק'
    },
    GOOD: {
      minScore: 70,
      label: 'התאמה טובה',
      description: 'יש פוטנציאל טוב להתאמה'
    },
    MODERATE: {
      minScore: 60,
      label: 'התאמה בינונית',
      description: 'יש נקודות משותפות, אבל גם הבדלים'
    },
    LOW: {
      minScore: 50,
      label: 'התאמה נמוכה',
      description: 'יש פערים משמעותיים בין המועמדים'
    }
  };
--- End of Content for matchingCriteria.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\ActionDialogs.tsx
--------------------------------------------------------------------------------
Content:
"use client";

// --- שינוי: הוספת useEffect ליבוא ---
import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Clock, Mail, Loader2 } from "lucide-react";
import type { Candidate } from "../types/candidates";

interface NewSuggestionFormData {
  firstPartyId: string;
  secondPartyId: string;
  priority: Priority;
  status: MatchSuggestionStatus;
}
interface ActionDialogsProps {
  suggestDialog: {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: NewSuggestionFormData) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  availabilityDialog: {
    isOpen: boolean;
    onClose: () => void;
    onCheck: (candidate: Candidate) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
  inviteDialog: {
    isOpen: boolean;
    onClose: () => void;
    onInvite: (candidate: Candidate, email: string) => Promise<void>;
    selectedCandidate: Candidate | null;
  };
}

export const ActionDialogs: React.FC<ActionDialogsProps> = ({
  suggestDialog,
  availabilityDialog,
  inviteDialog,
}) => {
  // State for invite dialog
  const [inviteEmail, setInviteEmail] = useState("");
  const [isInviting, setIsInviting] = useState(false);
  const [inviteError, setInviteError] = useState<string | null>(null);

  // State for availability dialog
  const [isChecking, setIsChecking] = useState(false);
  const [availabilityError, setAvailabilityError] = useState<string | null>(
    null
  );

  // --- הוספה: useEffect למילוי אוטומטי של האימייל ---
  useEffect(() => {
    // בודקים אם דיאלוג ההזמנה פתוח ויש מועמד שנבחר
    if (inviteDialog.isOpen && inviteDialog.selectedCandidate) {
      // מעדכנים את שדה האימייל עם האימייל של המועמד מהדאטהבייס.
      // אם אין לו אימייל, השדה יישאר ריק.
      setInviteEmail(inviteDialog.selectedCandidate.email || "");
    } else {
      // כאשר הדיאלוג נסגר, מנקים את שדה האימייל
      setInviteEmail("");
    }
  }, [inviteDialog.isOpen, inviteDialog.selectedCandidate]); // ה-hook יופעל בכל פעם שהדיאלוג נפתח/נסגר או שהמועמד משתנה

  // Handler for invite submission
  const handleInviteSubmit = async () => {
    if (!inviteDialog.selectedCandidate || !inviteEmail) return;

    try {
      setIsInviting(true);
      setInviteError(null);
      await inviteDialog.onInvite(inviteDialog.selectedCandidate, inviteEmail);
      // setInviteEmail(""); // השורה הזו כבר לא הכרחית כי ה-useEffect ינקה את השדה בסגירה
      inviteDialog.onClose();
    } catch (error) {
      setInviteError(
        error instanceof Error ? error.message : "Failed to send invitation"
      );
    } finally {
      setIsInviting(false);
    }
  };

  // Handler for availability check
  const handleAvailabilityCheck = async () => {
    if (!availabilityDialog.selectedCandidate) return;

    try {
      setIsChecking(true);
      setAvailabilityError(null);
      await availabilityDialog.onCheck(availabilityDialog.selectedCandidate);
      availabilityDialog.onClose();
    } catch (error) {
      setAvailabilityError(
        error instanceof Error ? error.message : "Failed to check availability"
      );
    } finally {
      setIsChecking(false);
    }
  };

  return (
    <>
      {/* Invite Dialog */}
      <Dialog open={inviteDialog.isOpen} onOpenChange={inviteDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>שליחת הזמנה למועמד</DialogTitle>
            <DialogDescription>
              {inviteDialog.selectedCandidate && (
                <span>
                  שליחת הזמנה ל: {inviteDialog.selectedCandidate.firstName}{" "}
                  {inviteDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            <div>
              <Label>כתובת אימייל</Label>
              <Input
                type="email"
                value={inviteEmail}
                onChange={(e) => setInviteEmail(e.target.value)}
                placeholder="הזן כתובת אימייל"
                className="mt-2"
              />
            </div>

            {inviteError && (
              <Alert variant="destructive">
                <AlertDescription>{inviteError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={inviteDialog.onClose}
              disabled={isInviting}
            >
              ביטול
            </Button>
            <Button
              onClick={handleInviteSubmit}
              disabled={isInviting || !inviteEmail}
            >
              {isInviting ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Mail className="ml-2 h-4 w-4" />
              )}
              {isInviting ? "שולח..." : "שלח הזמנה"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Availability Check Dialog */}
      <Dialog
        open={availabilityDialog.isOpen}
        onOpenChange={availabilityDialog.onClose}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>בדיקת זמינות</DialogTitle>
            <DialogDescription>
              {availabilityDialog.selectedCandidate && (
                <span>
                  בדיקת זמינות עבור:{" "}
                  {availabilityDialog.selectedCandidate.firstName}{" "}
                  {availabilityDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            {availabilityError && (
              <Alert variant="destructive">
                <AlertDescription>{availabilityError}</AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={availabilityDialog.onClose}
              disabled={isChecking}
            >
              ביטול
            </Button>
            <Button onClick={handleAvailabilityCheck} disabled={isChecking}>
              {isChecking ? (
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              ) : (
                <Clock className="ml-2 h-4 w-4" />
              )}
              {isChecking ? "בודק..." : "בדוק זמינות"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Suggest Match Dialog */}
      <Dialog open={suggestDialog.isOpen} onOpenChange={suggestDialog.onClose}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>הצעת שידוך חדשה</DialogTitle>
            <DialogDescription>
              {suggestDialog.selectedCandidate && (
                <span>
                  יצירת הצעת שידוך עבור:{" "}
                  {suggestDialog.selectedCandidate.firstName}{" "}
                  {suggestDialog.selectedCandidate.lastName}
                </span>
              )}
            </DialogDescription>
          </DialogHeader>
          {/* תוכן הדיאלוג יועבר מהקומפוננטה NewSuggestionForm */}
        </DialogContent>
      </Dialog>
    </>
  );
};

export default ActionDialogs;
--- End of Content for ActionDialogs.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\AddManualCandidateDialog.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2, UserPlus, X, UploadCloud, Trash2 } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import Image from "next/image";
import { Gender } from "@prisma/client";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { DatePicker } from "@/components/ui/date-picker";
import {
  RadioGroup,
  RadioGroupItem,
} from "@/components/ui/radio-group";

interface AddManualCandidateDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onCandidateAdded: () => void;
}

const MAX_IMAGES = 5;
const MAX_IMAGE_SIZE_MB = 5;

export const AddManualCandidateDialog: React.FC<
  AddManualCandidateDialogProps
> = ({ isOpen, onClose, onCandidateAdded }) => {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [gender, setGender] = useState<Gender | undefined>(undefined);
  const [birthDate, setBirthDate] = useState<Date | undefined>(undefined);
  const [manualEntryText, setManualEntryText] = useState("");
  const [images, setImages] = useState<File[]>([]);
  const [imagePreviews, setImagePreviews] = useState<string[]>([]);
  const [sendInvite, setSendInvite] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [birthDateInputMode, setBirthDateInputMode] = useState<"date" | "age">(
    "date"
  );
  const [ageInput, setAgeInput] = useState<string>("");

  const resetForm = useCallback(() => {
    setFirstName("");
    setLastName("");
    setEmail("");
    setGender(undefined);
    setBirthDate(undefined);
    setManualEntryText("");
    setImages([]);
    setImagePreviews([]);
    setSendInvite(false);
    setIsSaving(false);
    setBirthDateInputMode("date");
    setAgeInput("");
  }, []);

  const handleClose = () => {
    resetForm();
    onClose();
  };

  const handleImageChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      const newFiles = Array.from(event.target.files);
      const validFiles: File[] = [];
      const validPreviews: string[] = [];

      newFiles.forEach((file) => {
        if (images.length + validFiles.length < MAX_IMAGES) {
          if (file.size <= MAX_IMAGE_SIZE_MB * 1024 * 1024) {
            validFiles.push(file);
            validPreviews.push(URL.createObjectURL(file));
          } else {
            toast.error(
              `הקובץ ${file.name} גדול מדי (מקסימום ${MAX_IMAGE_SIZE_MB}MB).`
            );
          }
        } else {
          toast.warning(`ניתן להעלות עד ${MAX_IMAGES} תמונות.`);
        }
      });

      setImages((prev) => [...prev, ...validFiles]);
      setImagePreviews((prev) => [...prev, ...validPreviews]);
    }
  };

  const removeImage = (index: number) => {
    const newImages = images.filter((_, i) => i !== index);
    const newImagePreviews = imagePreviews.filter((_, i) => i !== index);
    setImages(newImages);
    setImagePreviews(newImagePreviews);
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setIsSaving(true);

    if (!firstName || !lastName || !gender || !manualEntryText) {
      toast.error(
        "נא למלא את כל שדות החובה: שם פרטי, שם משפחה, מין וטקסט חופשי."
      );
      setIsSaving(false);
      return;
    }

    let finalBirthDate: Date | undefined;
    let isBirthDateApproximate: boolean = false;

    if (birthDateInputMode === "date") {
      if (!birthDate) {
        toast.error("נא לבחור תאריך לידה.");
        setIsSaving(false);
        return;
      }
      finalBirthDate = birthDate;
      isBirthDateApproximate = false;
    } else {
      const ageNum = parseInt(ageInput, 10);
      if (isNaN(ageNum) || ageNum <= 0 || ageNum > 120) {
        toast.error("נא להזין גיל תקין (בין 1 ל-120).");
        setIsSaving(false);
        return;
      }
      const currentYear = new Date().getFullYear();
      const birthYear = currentYear - ageNum;
      finalBirthDate = new Date(birthYear, 0, 1);
      isBirthDateApproximate = true;
    }

    if (!finalBirthDate) {
        toast.error("שגיאה בקביעת תאריך לידה. נא לבדוק את הקלט.");
        setIsSaving(false);
        return;
    }

    const formData = new FormData();
    formData.append("firstName", firstName);
    formData.append("lastName", lastName);
    if (email) formData.append("email", email);
    formData.append("gender", gender);
    formData.append("birthDate", finalBirthDate.toISOString());
    formData.append("birthDateIsApproximate", String(isBirthDateApproximate));
    formData.append("manualEntryText", manualEntryText);
    images.forEach((image) => {
      formData.append("images", image);
    });

    try {
      const response = await fetch("/api/matchmaker/candidates/manual", {
        method: "POST",
        body: formData,
      });

      const result = await response.json();

      if (response.ok && result.success) {
        if (sendInvite && email && result.candidate?.id) {
           const promise = fetch(`/api/matchmaker/candidates/${result.candidate.id}/invite-setup`, {
               method: 'POST',
               headers: { 'Content-Type': 'application/json' },
               body: JSON.stringify({ email }),
           }).then(async (inviteResponse) => {
               if (!inviteResponse.ok) {
                   const errorData = await inviteResponse.json().catch(() => ({}));
                   throw new Error(errorData.error || 'שליחת ההזמנה נכשלה.');
               }
               return inviteResponse.json();
           });

           toast.promise(promise, {
               loading: 'מוסיף מועמד ושולח הזמנה...',
               success: 'המועמד נוסף וההזמנה נשלחה בהצלחה!',
               error: (err: Error) => `המועמד נוסף, אך שליחת ההזמנה נכשלה: ${err.message}`,
           });
        } else {
            toast.success("המועמד הידני נוסף בהצלחה!");
        }

        onCandidateAdded();
        handleClose();
      } else {
        throw new Error(result.error || "שגיאה בהוספת המועמד.");
      }
    } catch (error) {
      console.error("Error adding manual candidate:", error);
      toast.error(
        "שגיאה בהוספת המועמד: " +
          (error instanceof Error ? error.message : "שגיאה לא ידועה")
      );
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => { if (!open) handleClose(); }}>
      <DialogContent className="max-w-2xl">
        <DialogClose asChild>
          <button className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground p-1">
            <X className="h-4 w-4" />
            <span className="sr-only">סגור</span>
          </button>
        </DialogClose>

        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-right">
            <UserPlus className="w-6 h-6 text-primary" />
            הוספת מועמד ידנית
          </DialogTitle>
          <DialogDescription className="text-right">
            הזן את פרטי המועמד שברצונך להוסיף למערכת באופן ידני.
          </DialogDescription>
        </DialogHeader>

        <form
          onSubmit={handleSubmit}
          className="space-y-6 py-4 max-h-[70vh] overflow-y-auto pr-2 pl-1"
        >
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="firstName" className="text-right block">
                שם פרטי <span className="text-red-500">*</span>
              </Label>
              <Input
                id="firstName"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                placeholder="לדוגמה: ישראל"
                required
                dir="rtl"
              />
            </div>
            <div>
              <Label htmlFor="lastName" className="text-right block">
                שם משפחה <span className="text-red-500">*</span>
              </Label>
              <Input
                id="lastName"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                placeholder="לדוגמה: ישראלי"
                required
                dir="rtl"
              />
            </div>
          </div>

          <div>
            <Label htmlFor="email" className="text-right block">
              כתובת אימייל (אופציונלי)
            </Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="לדוגמה: user@example.com"
              dir="ltr"
            />
            <p className="text-xs text-gray-500 mt-1 text-right">
              אם לא תסופק כתובת אימייל, תיווצר כתובת פנימית עבור המערכת.
            </p>
          </div>

          <div className="flex items-center space-x-2 rtl:space-x-reverse pt-2">
            <Checkbox
              id="sendInvite"
              checked={sendInvite}
              onCheckedChange={(checked) => setSendInvite(Boolean(checked))}
              disabled={!email || isSaving}
            />
            <Label
              htmlFor="sendInvite"
              className={`cursor-pointer transition-colors ${!email ? 'text-gray-400 cursor-not-allowed' : 'text-gray-700'}`}
            >
              שלח הזמנה למועמד/ת להגדרת חשבון לאחר ההוספה
            </Label>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="gender" className="text-right block">
                מין <span className="text-red-500">*</span>
              </Label>
              <Select
                value={gender}
                onValueChange={(value) => setGender(value as Gender)}
              >
                <SelectTrigger id="gender" dir="rtl">
                  <SelectValue placeholder="בחר/י מין" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Gender.MALE}>זכר</SelectItem>
                  <SelectItem value={Gender.FEMALE}>נקבה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div>
              <div>
                <Label className="text-right block mb-2">
                  אופן הזנת גיל/תאריך לידה <span className="text-red-500">*</span>
                </Label>
                <RadioGroup
                  dir="rtl"
                  value={birthDateInputMode}
                  onValueChange={(value: "date" | "age") => {
                    setBirthDateInputMode(value);
                    if (value === "date") {
                      setAgeInput("");
                    } else {
                      setBirthDate(undefined);
                    }
                  }}
                  className="flex space-x-4 rtl:space-x-reverse mb-3"
                >
                  <div className="flex items-center space-x-2 rtl:space-x-reverse">
                    <RadioGroupItem value="date" id="r-date" />
                    <Label htmlFor="r-date" className="cursor-pointer">לפי תאריך לידה</Label>
                  </div>
                  <div className="flex items-center space-x-2 rtl:space-x-reverse">
                    <RadioGroupItem value="age" id="r-age" />
                    <Label htmlFor="r-age" className="cursor-pointer">לפי גיל</Label>
                  </div>
                </RadioGroup>
              </div>

              {birthDateInputMode === "date" ? (
                <div>
                  <Label htmlFor="birthDate" className="text-right block">
                    תאריך לידה <span className="text-red-500">*</span>
                  </Label>
                  <DatePicker
                    value={
                      birthDate ? { from: birthDate, to: undefined } : undefined
                    }
                    onChange={({ from }) => setBirthDate(from)}
                    isRange={false}
                    placeholder="בחר תאריך לידה"
                    className="w-full"
                  />
                </div>
              ) : (
                <div>
                  <Label htmlFor="ageInput" className="text-right block">
                    גיל (משוער) <span className="text-red-500">*</span>
                  </Label>
                  <Input
                    id="ageInput"
                    type="number"
                    value={ageInput}
                    onChange={(e) => setAgeInput(e.target.value)}
                    placeholder="לדוגמה: 25"
                    required={birthDateInputMode === "age"}
                    dir="rtl"
                    min="1"
                    max="120"
                  />
                   <p className="text-xs text-gray-500 mt-1 text-right">
                    יוזן תאריך לידה משוער (1 בינואר של שנת הלידה) בהתאם לגיל שהוזן.
                  </p>
                </div>
              )}
            </div>
          </div>

          <div>
            <Label htmlFor="manualEntryText" className="text-right block">
              טקסט חופשי על המועמד <span className="text-red-500">*</span>
            </Label>
            <Textarea
              id="manualEntryText"
              value={manualEntryText}
              onChange={(e) => setManualEntryText(e.target.value)}
              placeholder="ספר על המועמד, רקע, תכונות, מה מחפש/ת וכו'..."
              rows={6}
              required
              className="min-h-[100px]"
              dir="rtl"
            />
          </div>

          <div>
            <Label htmlFor="image-upload" className="text-right block">
              תמונות (עד {MAX_IMAGES})
            </Label>
            <div className="mt-2 flex items-center justify-center w-full">
              <label
                htmlFor="image-upload"
                className="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100"
              >
                <div className="flex flex-col items-center justify-center pt-5 pb-6">
                  <UploadCloud className="w-8 h-8 mb-2 text-gray-500" />
                  <p className="mb-2 text-sm text-gray-500 text-center">
                    גרור ושחרר תמונות לכאן, או לחץ לבחירה
                  </p>
                  <p className="text-xs text-gray-500">
                    PNG, JPG, WEBP (עד {MAX_IMAGE_SIZE_MB}MB לתמונה)
                  </p>
                </div>
                <Input
                  id="image-upload"
                  type="file"
                  multiple
                  accept="image/png, image/jpeg, image/webp"
                  className="hidden"
                  onChange={handleImageChange}
                  disabled={images.length >= MAX_IMAGES}
                />
              </label>
            </div>
            {imagePreviews.length > 0 && (
              <div className="mt-4 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                {imagePreviews.map((preview, index) => (
                  <div key={index} className="relative group">
                    <Image
                      src={preview}
                      alt={`תצוגה מקדימה ${index + 1}`}
                      width={100}
                      height={100}
                      className="rounded-md object-cover w-full aspect-square"
                      onLoad={() => URL.revokeObjectURL(preview)} // Clean up object URLs
                    />
                    <Button
                      type="button"
                      variant="destructive"
                      size="icon"
                      className="absolute top-1 right-1 h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity p-0"
                      onClick={() => removeImage(index)}
                    >
                      <Trash2 className="h-3 w-3" />
                      <span className="sr-only">הסר תמונה</span>
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </div>

          <DialogFooter className="pt-4 sm:justify-start">
            <Button type="submit" disabled={isSaving} className="w-full sm:w-auto">
              {isSaving ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <UserPlus className="w-4 h-4 mr-2" />
              )}
              {isSaving ? "שומר..." : "הוסף מועמד"}
            </Button>
            <DialogClose asChild>
              <Button variant="outline" type="button" className="w-full sm:w-auto mt-2 sm:mt-0">
                <X className="w-4 h-4 mr-2" />
                ביטול
              </Button>
            </DialogClose>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};
--- End of Content for AddManualCandidateDialog.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\dialogs\AiMatchAnalysisDialog.tsx
--------------------------------------------------------------------------------
Content:
// File: src/app/components/matchmaker/new/dialogs/AiMatchAnalysisDialog.tsx

"use client";

import React, { useState, useEffect, useMemo } from 'react';
import Image from 'next/image';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogClose } from "@/components/ui/dialog";
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Skeleton } from '@/components/ui/skeleton';
import { X, Sparkles, CheckCircle, AlertTriangle, MessageSquare, Info, XCircle, Star, Cake, MapPin, BookMarked, Users, ChevronsUpDown } from 'lucide-react';
import type { Candidate } from '../types/candidates';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from "framer-motion";

// --- Interfaces ---
interface AiAnalysis {
  overallScore: number;
  matchSummary: string;
  compatibilityPoints: { area: string; explanation: string; strength: 'HIGH' | 'MEDIUM' | 'LOW' }[];
  potentialChallenges: { area: string; explanation: string; severity: 'HIGH' | 'MEDIUM' | 'LOW' }[];
  suggestedConversationStarters: string[];
}

interface AiMatchAnalysisDialogProps {
  isOpen: boolean;
  onClose: () => void;
  targetCandidate: Candidate | null;
  comparisonCandidates: Candidate[];
}

// --- Helper Functions ---
const getInitials = (firstName?: string, lastName?: string): string => {
  let initials = "";
  if (firstName && firstName.length > 0) initials += firstName[0];
  if (lastName && lastName.length > 0) initials += lastName[0];
  return initials.toUpperCase() || "?";
};

const calculateAge = (birthDate: Date | string): number => {
    if (!birthDate) return 0;
    const today = new Date();
    const birth = new Date(birthDate);
    if (isNaN(birth.getTime())) return 0;
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
        age--;
    }
    return age > 0 ? age : 0;
};

// --- Sub-components ---

const MiniProfileHeader: React.FC<{ candidate: Candidate; score?: number; isTarget?: boolean }> = ({ candidate, score, isTarget = false }) => {
  const mainImage = candidate.images?.find(img => img.isMain);
  const age = calculateAge(candidate.profile.birthDate);
  const initials = getInitials(candidate.firstName, candidate.lastName);

  return (
    <div className="p-4 rounded-t-lg bg-gradient-to-b from-slate-50 to-slate-100 border-b border-slate-200 text-center relative">
      <div className="relative w-24 h-24 mx-auto rounded-full overflow-hidden border-4 border-white shadow-lg ring-2 ring-offset-2 ring-cyan-400">
        {mainImage?.url ? (
          <Image src={mainImage.url} alt={`תמונת פרופיל של ${candidate.firstName}`} layout="fill" className="object-cover" />
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-slate-200 to-slate-300">
            <span className="text-4xl font-medium text-slate-500">{initials}</span>
          </div>
        )}
      </div>
      
      {!isTarget && typeof score === 'number' && (
        <Badge className="absolute top-4 left-4 bg-gradient-to-r from-teal-400 to-cyan-500 text-white border-0 shadow-lg px-3 py-1.5 text-sm font-bold flex items-center gap-1.5">
          <Sparkles className="w-4 h-4" />
          {score}% התאמה
        </Badge>
      )}

      {isTarget && (
        <Badge className="absolute top-4 right-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white border-0 shadow-lg px-3 py-1.5 text-sm font-bold flex items-center gap-1.5">
          <Star className="w-4 h-4" />
          מועמד מטרה
        </Badge>
      )}

      <h3 className="mt-3 text-lg font-bold text-slate-800">{candidate.firstName} {candidate.lastName}</h3>
      <div className="mt-2 flex justify-center items-center flex-wrap gap-x-3 gap-y-1 text-xs text-slate-600">
        <div className="flex items-center gap-1"><Cake className="w-3.5 h-3.5 text-slate-400"/> {age} שנים</div>
        <div className="flex items-center gap-1"><MapPin className="w-3.5 h-3.5 text-slate-400"/> {candidate.profile.city || 'לא צוין'}</div>
        <div className="flex items-center gap-1"><BookMarked className="w-3.5 h-3.5 text-slate-400"/> {candidate.profile.religiousLevel || 'לא צוין'}</div>
      </div>
    </div>
  );
};

const AnalysisItem: React.FC<{ icon: React.ElementType; iconColor: string; area: string; explanation: string; }> = ({ icon: Icon, iconColor, area, explanation }) => (
    <div className="flex items-start gap-4 p-3 rounded-lg hover:bg-slate-50/70 transition-colors">
        <div className={cn("mt-1 flex-shrink-0 rounded-full p-2 bg-opacity-10", iconColor.replace('text-', 'bg-'))}>
            <Icon className={cn("h-5 w-5", iconColor)} />
        </div>
        <div>
            <h4 className="font-semibold text-gray-800">{area}</h4>
            <p className="text-sm text-gray-600 leading-relaxed">{explanation}</p>
        </div>
    </div>
);

const ComparisonTable: React.FC<{ target: Candidate; comparison: Candidate; }> = ({ target, comparison }) => {
    const fieldsToCompare = [
        { key: 'age', label: 'גיל', formatter: (c: Candidate) => `${calculateAge(c.profile.birthDate)}${c.profile.birthDateIsApproximate ? ' (משוער)' : ''}` },
        { key: 'city', label: 'עיר', formatter: (c: Candidate) => c.profile.city || 'לא צוין' },
        { key: 'maritalStatus', label: 'מצב משפחתי', formatter: (c: Candidate) => c.profile.maritalStatus || 'לא צוין' },
        { key: 'religiousLevel', label: 'רמה דתית', formatter: (c: Candidate) => c.profile.religiousLevel || 'לא צוין' },
        { key: 'occupation', label: 'עיסוק', formatter: (c: Candidate) => c.profile.occupation || 'לא צוין' },
        { key: 'education', label: 'השכלה', formatter: (c: Candidate) => c.profile.education || 'לא צוין' },
    ];
  
    return (
      <div className="overflow-x-auto border rounded-lg">
        <table className="w-full text-sm text-right border-collapse">
          <thead>
            <tr className="bg-slate-50">
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200">קריטריון</th>
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200 text-center">{target.firstName}</th>
              <th className="p-3 font-semibold text-slate-600 border-b border-slate-200 text-center">{comparison.firstName}</th>
            </tr>
          </thead>
          <tbody>
            {fieldsToCompare.map((field, index) => (
              <tr key={field.key} className={index % 2 === 0 ? "bg-white" : "bg-slate-50/50"}>
                <td className="p-3 font-medium text-slate-500 border-b border-slate-200">{field.label}</td>
                <td className="p-3 text-slate-700 border-b border-slate-200 text-center">{field.formatter(target)}</td>
                <td className="p-3 text-slate-700 border-b border-slate-200 text-center">{field.formatter(comparison)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    );
};

const AnalysisSkeleton: React.FC = () => (
    <div className="space-y-6 p-4 animate-pulse">
        <div className="p-4 bg-gray-100 rounded-lg"><div className="h-20 bg-gray-200 rounded-md"></div></div>
        <div className="space-y-4">
            <div className="h-5 bg-gray-200 rounded-md w-1/3"></div>
            <div className="flex gap-4"><div className="rounded-full bg-gray-200 h-10 w-10"></div><div className="flex-1 space-y-2 py-1"><div className="h-4 bg-gray-200 rounded w-full"></div><div className="h-3 bg-gray-300 rounded w-5/6"></div></div></div>
            <div className="flex gap-4"><div className="rounded-full bg-gray-200 h-10 w-10"></div><div className="flex-1 space-y-2 py-1"><div className="h-4 bg-gray-200 rounded w-full"></div><div className="h-3 bg-gray-300 rounded w-4/6"></div></div></div>
        </div>
    </div>
);

// --- Main Dialog Component ---

export const AiMatchAnalysisDialog: React.FC<AiMatchAnalysisDialogProps> = ({ isOpen, onClose, targetCandidate, comparisonCandidates }) => {
  const [activeComparisonId, setActiveComparisonId] = useState<string | null>(null);
  const [analyses, setAnalyses] = useState<Record<string, AiAnalysis | 'error' | 'loading'>>({});
  const [language, setLanguage] = useState<'he' | 'en'>('he');
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const activeComparisonCandidate = useMemo(() => {
    return comparisonCandidates.find(c => c.id === activeComparisonId);
  }, [activeComparisonId, comparisonCandidates]);
  
  const activeAnalysis = useMemo(() => {
      if (!activeComparisonId) return null;
      return analyses[activeComparisonId] || null;
  }, [activeComparisonId, analyses]);

  useEffect(() => {
    if (isOpen && comparisonCandidates.length > 0 && !comparisonCandidates.some(c => c.id === activeComparisonId)) {
      setActiveComparisonId(comparisonCandidates[0].id);
    }
  }, [isOpen, comparisonCandidates, activeComparisonId]);

  useEffect(() => {
    if (isOpen && targetCandidate && activeComparisonId && analyses[activeComparisonId] === undefined) {
      const fetchAnalysis = async () => {
        setAnalyses(prev => ({ ...prev, [activeComparisonId]: 'loading' }));

        try {
          const response = await fetch('/api/ai/generate-rationale', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              userId1: targetCandidate.id,
              userId2: activeComparisonId,
              language: language,
            }),
          });

          const data = await response.json();
          if (response.ok && data.success) {
            setAnalyses(prev => ({ ...prev, [activeComparisonId]: data.analysis }));
          } else {
            throw new Error(data.error || "Failed to fetch analysis");
          }
        } catch (e) {
          console.error(`Failed to get analysis for ${activeComparisonId}:`, e);
          setAnalyses(prev => ({ ...prev, [activeComparisonId]: 'error' }));
        }
      };
      fetchAnalysis();
    }
  }, [isOpen, targetCandidate, activeComparisonId, language, analyses]);

  const handleLanguageChange = (newLang: 'he' | 'en') => {
    if (newLang !== language) {
      setLanguage(newLang);
      setAnalyses({});
    }
  };
  
  if (!isOpen || !targetCandidate) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl w-full h-[95vh] flex flex-col p-0 overflow-hidden" dir="rtl">
        <DialogHeader className="p-4 border-b flex-row justify-between items-center flex-shrink-0">
          <div className="flex items-center gap-3">
            <Sparkles className="w-7 h-7 text-teal-500" />
            <div>
              <DialogTitle className="text-xl">ניתוח התאמה מבוסס AI</DialogTitle>
              <DialogDescription>השוואה מפורטת בין מועמדים</DialogDescription>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Select value={language} onValueChange={handleLanguageChange}>
              <SelectTrigger className="w-[120px] text-xs h-9">
                <SelectValue placeholder="שפת ניתוח" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="he">עברית</SelectItem>
                <SelectItem value="en">English</SelectItem>
              </SelectContent>
            </Select>
            <DialogClose asChild>
              <Button variant="ghost" size="icon"><X className="h-5 w-5"/></Button>
            </DialogClose>
          </div>
        </DialogHeader>

        <div className="flex-1 flex flex-col md:flex-row min-h-0">
          {/* Sidebar (Desktop) or Select (Mobile) */}
          {isMobile ? (
            <div className="p-4 border-b md:hidden">
                <Select value={activeComparisonId || ''} onValueChange={setActiveComparisonId}>
                    <SelectTrigger className="w-full">
                        <SelectValue placeholder="בחר מועמד להשוואה" />
                    </SelectTrigger>
                    <SelectContent>
                        {comparisonCandidates.map(c => (
                            <SelectItem key={c.id} value={c.id}>{c.firstName} {c.lastName}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>
          ) : (
            <aside className="w-1/4 border-l bg-slate-50/50 flex flex-col flex-shrink-0">
              <h3 className="p-3 text-sm font-semibold text-slate-600 border-b">מועמדים להשוואה ({comparisonCandidates.length})</h3>
              <ScrollArea className="flex-1">
                {comparisonCandidates.map(candidate => (
                  <button
                    key={candidate.id}
                    onClick={() => setActiveComparisonId(candidate.id)}
                    className={cn(
                      "w-full text-right p-3 flex items-center gap-3 border-b border-slate-200/60 hover:bg-slate-100 transition-colors",
                      activeComparisonId === candidate.id && "bg-cyan-50 border-r-4 border-cyan-500 font-semibold"
                    )}
                  >
                    <div className="relative w-10 h-10 rounded-full overflow-hidden flex-shrink-0">
                       <Image src={candidate.images?.find(img => img.isMain)?.url || '/placeholder.jpg'} alt={candidate.firstName} layout="fill" className="object-cover" />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="truncate text-sm text-slate-800">{candidate.firstName} {candidate.lastName}</p>
                      <p className="text-xs text-slate-500">{calculateAge(candidate.profile.birthDate)} | {candidate.profile.city}</p>
                    </div>
                    {activeAnalysis && activeAnalysis !== 'error' && activeAnalysis !== 'loading' && (
                      <Badge variant="secondary" className="bg-teal-100 text-teal-800">{(activeAnalysis as AiAnalysis).overallScore}%</Badge>
                    )}
                  </button>
                ))}
              </ScrollArea>
            </aside>
          )}

          {/* Main content area */}
          <main className="flex-1 flex flex-col min-h-0 bg-white">
            {!activeComparisonCandidate ? (
                 <div className="flex-1 flex flex-col items-center justify-center text-center p-6 text-gray-500">
                    <Users className="w-16 h-16 text-gray-300 mb-4"/>
                    <h3 className="text-lg font-semibold">בחר מועמד/ת להשוואה</h3>
                    <p className="max-w-xs">בחר מועמד מהרשימה בצד (או מהתפריט הנפתח במובייל) כדי להתחיל בניתוח ההתאמה.</p>
                 </div>
            ) : (
                <>
                    <div className="grid grid-cols-1 md:grid-cols-2 flex-shrink-0">
                      <MiniProfileHeader candidate={targetCandidate} isTarget />
                      <MiniProfileHeader candidate={activeComparisonCandidate} score={(activeAnalysis as AiAnalysis)?.overallScore} />
                    </div>

                    <Tabs defaultValue="summary" className="flex-1 flex flex-col min-h-0">
                      <TabsList className="mx-4 mt-4 bg-slate-100 p-1 rounded-lg">
                        <TabsTrigger value="summary">סיכום וחוזקות</TabsTrigger>
                        <TabsTrigger value="challenges">אתגרים ופערים</TabsTrigger>
                        <TabsTrigger value="comparison">השוואת נתונים</TabsTrigger>
                        <TabsTrigger value="conversation">נושאים לשיחה</TabsTrigger>
                      </TabsList>
                      <ScrollArea className="flex-1">
                        <AnimatePresence mode="wait">
                          <motion.div
                            key={activeComparisonId}
                            initial={{ opacity: 0, y: 10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -10 }}
                            transition={{ duration: 0.2 }}
                            className="p-4 md:p-6"
                          >
                            {activeAnalysis === 'loading' && <AnalysisSkeleton />}
                            {activeAnalysis === 'error' && (
                                <div className="text-center py-10">
                                    <XCircle className="w-12 h-12 text-red-400 mx-auto mb-4"/>
                                    <h3 className="font-semibold text-xl text-red-600">שגיאה בניתוח ההתאמה</h3>
                                    <p className="text-gray-500 mt-2">לא הצלחנו להפיק ניתוח עבור זוג זה. אנא נסה שוב מאוחר יותר.</p>
                                </div>
                            )}
                            {activeAnalysis && activeAnalysis !== 'error' && activeAnalysis !== 'loading' && (
                              <>
                                <TabsContent value="summary" className="space-y-6 mt-0">
                                  <div className="p-4 bg-slate-50/70 rounded-lg border border-slate-200"><h3 className="font-semibold text-gray-800 mb-2 flex items-center gap-2"><Info className="w-5 h-5 text-blue-500"/> סיכום ההתאמה</h3><p className="text-sm text-gray-600 leading-relaxed">{(activeAnalysis as AiAnalysis).matchSummary}</p></div>
                                  <div><h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><CheckCircle className="w-5 h-5 text-green-500"/> נקודות חוזק וחיבור</h3><div className="space-y-4">{(activeAnalysis as AiAnalysis).compatibilityPoints.map(point => <AnalysisItem key={point.area} icon={CheckCircle} iconColor="text-green-500" {...point} />)}</div></div>
                                </TabsContent>
                                <TabsContent value="challenges" className="space-y-6 mt-0">
                                  <div><h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><AlertTriangle className="w-5 h-5 text-amber-500"/> אתגרים ופערים פוטנציאליים</h3><div className="space-y-4">{(activeAnalysis as AiAnalysis).potentialChallenges.map(challenge => <AnalysisItem key={challenge.area} icon={AlertTriangle} iconColor="text-amber-500" {...challenge} />)}</div></div>
                                </TabsContent>
                                <TabsContent value="comparison" className="mt-0"><ComparisonTable target={targetCandidate} comparison={activeComparisonCandidate} /></TabsContent>
                                <TabsContent value="conversation" className="space-y-4 mt-0">
                                  <h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2"><MessageSquare className="w-5 h-5 text-indigo-500"/> נושאים מומלצים לשיחה</h3>
                                  <ul className="space-y-3 list-inside">{(activeAnalysis as AiAnalysis).suggestedConversationStarters.map((starter, index) => (<li key={index} className="flex items-start gap-2 p-2 rounded-md hover:bg-indigo-50/50"><MessageSquare className="w-4 h-4 text-indigo-400 mt-1 flex-shrink-0"/><span className="text-sm text-gray-700">{starter}</span></li>))}</ul>
                                </TabsContent>
                              </>
                            )}
                          </motion.div>
                        </AnimatePresence>
                      </ScrollArea>
                    </Tabs>
                </>
            )}
          </main>
        </div>
      </DialogContent>
    </Dialog>
  );
};
--- End of Content for AiMatchAnalysisDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\filterUtils
--------------------------------------------------------------------------------
Content:
--- End of Content for filterUtils ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useCandidates.ts
--------------------------------------------------------------------------------
Content:
import { useState, useEffect, useMemo, useCallback } from 'react';
import Papa from 'papaparse';
import type { Candidate, CandidatesFilter } from '../types/candidates';
import type { CandidateProfile } from '../types/candidates';
import { Dispatch, SetStateAction } from 'react';

export interface UseCandidatesReturn {
  loading: boolean;
  error: string | null;
  candidates: Candidate[];
  maleCandidates: Candidate[];
  femaleCandidates: Candidate[];
  filteredCandidates: Candidate[];
  filters: CandidatesFilter;
  setFilters: Dispatch<SetStateAction<CandidatesFilter>>;
  refresh: () => Promise<void>;
  totalCount: number;
  filteredCount: number;
  maleCount: number;
  femaleCount: number;
  searchResults: {
    term: string;
    count: number;
    male: number;
    female: number;
  } | null;
  exportCandidates: (candidates: Candidate[], filters: CandidatesFilter) => Promise<void>;
  updateCandidate: (id: string, updates: Partial<CandidateProfile>) => Promise<void>;
  sorting: {
    field: string;
    direction: 'asc' | 'desc';
  };
  setSorting: (field: string, direction: 'asc' | 'desc') => void;
  searchSuggestions: (term: string) => Promise<Candidate[]>;
}

export const useCandidates = (initialFilters: CandidatesFilter = {}): UseCandidatesReturn => {
  // Base states
  const [candidates, setCandidates] = useState<Candidate[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<CandidatesFilter>(initialFilters);
  const [searchResults, setSearchResults] = useState<{
    term: string;
    count: number;
    male: number;
    female: number;
  } | null>(null);
  const [sorting, setSortingState] = useState<{
    field: string;
    direction: 'asc' | 'desc';
  }>({
    field: 'lastActive',
    direction: 'desc',
  });

  // Helper function to calculate age
  const calculateAge = useCallback((birthDate: Date): number => {
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    return age;
  }, []);

  // Fetch candidates data
  const fetchCandidates = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/matchmaker/candidates');
      if (!response.ok) {
        throw new Error(await response.text());
      }
      
      const data = await response.json();
     
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load candidates');
      }
  
      setCandidates(data.clients);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
      console.error('Error fetching candidates:', err);
    } finally {
      setLoading(false);
    }
  };

  // Set sorting field and direction
  const setSorting = useCallback((field: string, direction: 'asc' | 'desc') => {
    setSortingState({ field, direction });
  }, []);

  // Search suggestions based on a term
  const searchSuggestions = useCallback(async (term: string): Promise<Candidate[]> => {
    if (!term || term.length < 2) return [];
    
    // Local search implementation for quick response
    const searchTerm = term.toLowerCase();
    return candidates.filter(candidate => {
      const searchableText = `
        ${candidate.firstName} 
        ${candidate.lastName} 
        ${candidate.profile.occupation || ''} 
        ${candidate.profile.city || ''}
        ${candidate.profile.religiousLevel || ''}
      `.toLowerCase();
      
      return searchableText.includes(searchTerm);
    }).slice(0, 10);
    
    // Alternatively, you can implement an API call for server-side search
    // if the dataset is very large
  }, [candidates]);

  const sortCandidates = useCallback((candidatesList: Candidate[], field: string, direction: 'asc' | 'desc') => {
    return [...candidatesList].sort((a, b) => {
      let valueA, valueB;
      
      switch (field) {
        case 'name':
          valueA = `${a.firstName} ${a.lastName}`.toLowerCase();
          valueB = `${b.firstName} ${b.lastName}`.toLowerCase();
          break;
        case 'age':
          valueA = calculateAge(a.profile.birthDate);
          valueB = calculateAge(b.profile.birthDate);
          break;
        case 'city':
          valueA = (a.profile.city || '').toLowerCase();
          valueB = (b.profile.city || '').toLowerCase();
          break;
        case 'religiousLevel':
          valueA = (a.profile.religiousLevel || '').toLowerCase();
          valueB = (b.profile.religiousLevel || '').toLowerCase();
          break;
        case 'lastActive':
          valueA = a.profile.lastActive ? new Date(a.profile.lastActive).getTime() : 0;
          valueB = b.profile.lastActive ? new Date(b.profile.lastActive).getTime() : 0;
          break;
        case 'registrationDate':
          valueA = new Date(a.createdAt).getTime();
          valueB = new Date(b.createdAt).getTime();
          break;
        case 'height':
          valueA = a.profile.height || 0;
          valueB = b.profile.height || 0;
          break;
        default:
          valueA = 0;
          valueB = 0;
      }
      
      if (valueA < valueB) return direction === 'asc' ? -1 : 1;
      if (valueA > valueB) return direction === 'asc' ? 1 : -1;
      return 0;
    });
  }, [calculateAge]);
  
  // פונקציה לבדיקה אם מועמד עומד בקריטריוני חיפוש
  const checkSearchMatch = useCallback((candidate: Candidate, searchTerm: string): boolean => {
    if (!searchTerm) return true;
    
    // נרמול החיפוש
    const normalizedTerm = searchTerm.toLowerCase().trim();
    if (!normalizedTerm) return true;
    
    // בדיקת התאמה בשדות השונים
    const fullName = `${candidate.firstName} ${candidate.lastName}`.toLowerCase();
    const city = (candidate.profile.city || '').toLowerCase();
    const occupation = (candidate.profile.occupation || '').toLowerCase();
    const religiousLevel = (candidate.profile.religiousLevel || '').toLowerCase();
    
    return (
      fullName.includes(normalizedTerm) || 
      city.includes(normalizedTerm) || 
      occupation.includes(normalizedTerm) || 
      religiousLevel.includes(normalizedTerm)
    );
  }, []);

  // בקובץ useCandidates.ts - לעדכן את החלק של filteredCandidates
  const filteredCandidates = useMemo(() => {
    console.log("Filtering candidates with filters:", filters);
    
    // אם הסינון הנפרד מופעל, נשתמש בפילטרים הכלליים בלבד ללא מגדר
    const currentFilters = filters.separateFiltering 
      ? { ...filters, gender: undefined }
      : filters;

    let results = candidates.filter(candidate => {
      // סינון לפי מגדר רק אם הסינון הנפרד כבוי
      if (!filters.separateFiltering && currentFilters.gender && candidate.profile.gender !== currentFilters.gender) {
        return false;
      }
      if (currentFilters.source && candidate.source !== currentFilters.source) {
    return false;
}
      // בדיקת גיל מותאמת
      if (currentFilters.ageRange) {
        try {
          const age = calculateAge(candidate.profile.birthDate);
          if (age < currentFilters.ageRange.min || age > currentFilters.ageRange.max) {
            return false;
          }
        } catch (err) {
          console.error("Error calculating age for candidate:", candidate.id, err);
        }
      }
      
      // סינון סטטוס משתמש
      if (filters.userStatus && candidate.status !== filters.userStatus) {
        return false;
      }
   // סינון סטטוס משתמש
      if (filters.userStatus && candidate.status !== filters.userStatus) {
        return false;
      }
      // סינון סטטוס זמינות - ודא המרה נכונה של הטיפוס
      if (filters.availabilityStatus && 
          candidate.profile.availabilityStatus !== filters.availabilityStatus) {
        return false;
      }
      
      // בדיקת גובה
      if (filters.heightRange && candidate.profile.height) {
        if (
          candidate.profile.height < filters.heightRange.min || 
          candidate.profile.height > filters.heightRange.max
        ) {
          return false;
        }
      }

      // בדיקת רמת דתיות
      if (filters.religiousLevel && candidate.profile.religiousLevel !== filters.religiousLevel) {
        return false;
      }

      // בדיקת ערים
      if (filters.cities?.length && candidate.profile.city) {
        if (!filters.cities.includes(candidate.profile.city)) {
          return false;
        }
      }

      // בדיקת תחומי עיסוק
      if (filters.occupations?.length && candidate.profile.occupation) {
        if (!filters.occupations.includes(candidate.profile.occupation)) {
          return false;
        }
      }

      // בדיקת השכלה
      if (filters.educationLevel && candidate.profile.education !== filters.educationLevel) {
        return false;
      }

      // בדיקת מצב משפחתי
      if (filters.maritalStatus && candidate.profile.maritalStatus !== filters.maritalStatus) {
        return false;
      }

      // בדיקת אימות
      if (filters.isVerified !== undefined && candidate.isVerified !== filters.isVerified) {
        return false;
      }

      // בדיקת המלצות
   
      // בדיקת פעילות אחרונה
      if (filters.lastActiveDays && candidate.profile.lastActive) {
        const lastActive = new Date(candidate.profile.lastActive);
        const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
        if (daysDiff > filters.lastActiveDays) {
          return false;
        }
      }

      // בדיקת שלמות פרופיל
      if (filters.isProfileComplete !== undefined && 
          candidate.isProfileComplete !== filters.isProfileComplete) {
        return false;
      }

      // בדיקת חיפוש כללי - רק אם אין סינון נפרד
      if (!filters.separateFiltering && currentFilters.searchQuery) {
        return checkSearchMatch(candidate, currentFilters.searchQuery);
      }

      return true;
    });

    // מיון התוצאות
    if (sorting.field && sorting.direction) {
      results = sortCandidates(results, sorting.field, sorting.direction);
    }

    return results;
  }, [candidates, filters, calculateAge, sorting.field, sorting.direction, sortCandidates, checkSearchMatch]);

  // חלוקה למועמדים ומועמדות עם תמיכה בחיפוש נפרד
  const maleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לגברים
      return filteredCandidates
        .filter(c => c.profile.gender === 'MALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לגברים
          if (filters.maleFilters) {
            // בדיקת גיל
            if (filters.maleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.maleFilters.ageRange.min || age > filters.maleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.maleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.maleFilters.heightRange.min || 
                candidate.profile.height > filters.maleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.maleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.maleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.maleFilters.cities?.length && candidate.profile.city) {
              if (!filters.maleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.maleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.maleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.maleFilters.educationLevel && candidate.profile.education !== filters.maleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.maleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.maleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.maleFilters.isVerified !== undefined && candidate.isVerified !== filters.maleFilters.isVerified) {
              return false;
            }

    

            // בדיקת פעילות אחרונה
            if (filters.maleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.maleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.maleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.maleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הגברים
            if (filters.maleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.maleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לגברים
          if (filters.maleSearchQuery) {
            return checkSearchMatch(candidate, filters.maleSearchQuery);
          }
          
          return true;
        });
    
      }, [filteredCandidates, filters.maleFilters, filters.maleSearchQuery, calculateAge, checkSearchMatch]);
  const femaleCandidates = useMemo(() => {
    // בסינון נפרד, נבדוק גם את החיפוש הספציפי לנשים

      return filteredCandidates
        .filter(c => c.profile.gender === 'FEMALE')
        .filter(candidate => {
          // בדיקת פילטרים ספציפיים לנשים
          if (filters.femaleFilters) {
            // בדיקת גיל
            if (filters.femaleFilters.ageRange) {
              const age = calculateAge(candidate.profile.birthDate);
              if (age < filters.femaleFilters.ageRange.min || age > filters.femaleFilters.ageRange.max) {
                return false;
              }
            }
            
            // בדיקת גובה
            if (filters.femaleFilters.heightRange && candidate.profile.height) {
              if (
                candidate.profile.height < filters.femaleFilters.heightRange.min || 
                candidate.profile.height > filters.femaleFilters.heightRange.max
              ) {
                return false;
              }
            }

            // בדיקת רמת דתיות
            if (filters.femaleFilters.religiousLevel && candidate.profile.religiousLevel !== filters.femaleFilters.religiousLevel) {
              return false;
            }

            // בדיקת ערים
            if (filters.femaleFilters.cities?.length && candidate.profile.city) {
              if (!filters.femaleFilters.cities.includes(candidate.profile.city)) {
                return false;
              }
            }

            // בדיקת תחומי עיסוק
            if (filters.femaleFilters.occupations?.length && candidate.profile.occupation) {
              if (!filters.femaleFilters.occupations.includes(candidate.profile.occupation)) {
                return false;
              }
            }

            // בדיקת השכלה
            if (filters.femaleFilters.educationLevel && candidate.profile.education !== filters.femaleFilters.educationLevel) {
              return false;
            }

            // בדיקת מצב משפחתי
            if (filters.femaleFilters.maritalStatus && candidate.profile.maritalStatus !== filters.femaleFilters.maritalStatus) {
              return false;
            }

            // בדיקת אימות
            if (filters.femaleFilters.isVerified !== undefined && candidate.isVerified !== filters.femaleFilters.isVerified) {
              return false;
            }

       

            // בדיקת פעילות אחרונה
            if (filters.femaleFilters.lastActiveDays && candidate.profile.lastActive) {
              const lastActive = new Date(candidate.profile.lastActive);
              const daysDiff = (new Date().getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24);
              if (daysDiff > filters.femaleFilters.lastActiveDays) {
                return false;
              }
            }

            // בדיקת שלמות פרופיל
            if (filters.femaleFilters.isProfileComplete !== undefined && 
                candidate.isProfileComplete !== filters.femaleFilters.isProfileComplete) {
              return false;
            }

            // בדיקת חיפוש ספציפי לפילטרים של הנשים
            if (filters.femaleFilters.searchQuery) {
              return checkSearchMatch(candidate, filters.femaleFilters.searchQuery);
            }
          }
          
          // בדיקת חיפוש נפרד לנשים
          if (filters.femaleSearchQuery) {
            return checkSearchMatch(candidate, filters.femaleSearchQuery);
          }
          
          return true;
        });
      }, [filteredCandidates, filters.femaleFilters, filters.femaleSearchQuery, calculateAge, checkSearchMatch]);
  // עדכון תוצאות החיפוש
  useEffect(() => {
    if (!filters.separateFiltering && filters.searchQuery) {
      // מצב חיפוש רגיל
      setSearchResults({
        term: filters.searchQuery,
        count: filteredCandidates.length,
        male: maleCandidates.length,
        female: femaleCandidates.length
      });
    } else if (filters.separateFiltering) {
      // במצב חיפוש נפרד, לא מציגים תוצאות חיפוש מאוחדות
      setSearchResults(null);
    } else {
      setSearchResults(null);
    }
  }, [filteredCandidates, maleCandidates, femaleCandidates, filters.searchQuery, filters.separateFiltering]);

  // Export candidates to CSV
  const exportCandidates = async (
    candidates: Candidate[], 
    filters: CandidatesFilter
  ): Promise<void> => {
    try {
      // Prepare data for export
      const exportData = candidates.map(candidate => ({
        'שם פרטי': candidate.firstName,
        'שם משפחה': candidate.lastName,
        'גיל': calculateAge(candidate.profile.birthDate),
        'מגדר': candidate.profile.gender === 'MALE' ? 'זכר' : 'נקבה',
        'עיר': candidate.profile.city || '',
        'גובה': candidate.profile.height || '',
        'רמת דתיות': candidate.profile.religiousLevel || '',
        'תעסוקה': candidate.profile.occupation || '',
        'השכלה': candidate.profile.education || '',
        'מצב משפחתי': candidate.profile.maritalStatus || '',
        'סטטוס זמינות': candidate.profile.availabilityStatus || '',
        'מאומת': candidate.isVerified ? 'כן' : 'לא',
        'פעילות אחרונה': candidate.profile.lastActive 
          ? new Date(candidate.profile.lastActive).toLocaleDateString('he-IL')
          : ''
      }));

      // Add filter info to filename
      const filenameSegments = ['candidates'];
      
      if (filters.gender) {
        filenameSegments.push(filters.gender === 'MALE' ? 'male' : 'female');
      }
      
      if (filters.religiousLevel) {
        filenameSegments.push(filters.religiousLevel.replace(/ /g, '-'));
      }
      
      if (filters.cities?.length === 1) {
        filenameSegments.push(filters.cities[0].replace(/ /g, '-'));
      }
      
      // Convert to CSV
      const csv = Papa.unparse(exportData);
      
      // Create and download file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      const timestamp = new Date().toISOString().split('T')[0];
      
      link.setAttribute('href', url);
      link.setAttribute('download', `${filenameSegments.join('_')}_${timestamp}.csv`);
      document.body.appendChild(link);
      
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Error exporting candidates:', error);
      throw new Error('Failed to export candidates');
    }
  };

  // Update candidate
  const updateCandidate = async (
    id: string, 
    updates: Partial<CandidateProfile>
  ): Promise<void> => {
    try {
      const response = await fetch(`/api/matchmaker/candidates/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error('Failed to update candidate');
      }
      
      // Refresh candidates list after update
      await fetchCandidates();
    } catch (error) {
      console.error('Error updating candidate:', error);
      throw error;
    }
  };

  // Load candidates on mount
  useEffect(() => {
    fetchCandidates();
  }, []);

  // Return interface
  return {
    loading,
    error,
    candidates,
    filteredCandidates,
    maleCandidates,
    femaleCandidates,
    filters,
    setFilters,
    refresh: fetchCandidates,
    totalCount: candidates.length,
    filteredCount: filteredCandidates.length,
    maleCount: maleCandidates.length,
    femaleCount: femaleCandidates.length,
    searchResults,
    exportCandidates,
    updateCandidate,
    sorting,
    setSorting,
    searchSuggestions
  };
};
--- End of Content for useCandidates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useFilterLogic.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/hooks/useFilterLogic.ts - גרסה משופרת

import { useState, useEffect, useMemo, useCallback } from 'react';
import type {
  FilterState,
  SavedFilter,
  FilterOption,
  FilterChangeHandler,  
} from '../types/filters';
import { DEFAULT_FILTER_STATE } from '../types/filters'; 

type SavedFilterFromStorage = Omit<SavedFilter, 'createdAt'> & {
  createdAt: string;
};

interface SearchHistoryItemFromStorage {
  query: string;
  timestamp: string;
}
interface UseFilterLogicProps {
  onFilterChange?: FilterChangeHandler;
  defaultFilters?: Partial<FilterState>;
  localStorageKey?: string;
}

export const useFilterLogic = ({
  onFilterChange,
  defaultFilters = {},
  localStorageKey = 'candidateFilters'
}: UseFilterLogicProps = {}) => {
  // States
  const [filters, setFilters] = useState<FilterState>({
    ...DEFAULT_FILTER_STATE,
    ...defaultFilters
  });
  
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [searchHistory, setSearchHistory] = useState<{query: string, timestamp: Date}[]>([]);
  const [lastAppliedFilter, setLastAppliedFilter] = useState<string | null>(null);

  // Load saved filters and history from localStorage
  useEffect(() => {
    try {
      // Load saved filters
      const savedPrefs = localStorage.getItem(localStorageKey);
      if (savedPrefs) {
        const parsed = JSON.parse(savedPrefs);
        setSavedFilters(parsed.map((filter: SavedFilterFromStorage) => ({
          ...filter,
          createdAt: new Date(filter.createdAt)
        })));
      }

      // Load recent searches
      const searches = localStorage.getItem(`${localStorageKey}_recent_searches`);
      if (searches) {
        setRecentSearches(JSON.parse(searches));
      }

      // Load search history
      const history = localStorage.getItem(`${localStorageKey}_search_history`);
      if (history) {
        setSearchHistory(JSON.parse(history).map((item: SearchHistoryItemFromStorage) => ({
          ...item,
          timestamp: new Date(item.timestamp)
        })));
      }
    } catch (error) {
      console.error('Error loading saved filters:', error);
    }
  }, [localStorageKey]);

  // עדכון פילטרים כללי
  const updateFilters = useCallback((newFilters: Partial<FilterState>) => {
    console.log("updateFilters called with:", newFilters);
    
    setFilters(prev => {
      const updated = { ...prev, ...newFilters };
      console.log("Updated filters:", updated);
      
      // אם יש מחרוזת חיפוש חדשה, עדכן את היסטורית החיפוש
      if (newFilters.searchQuery && newFilters.searchQuery !== prev.searchQuery) {
        const newQuery = newFilters.searchQuery;
        console.log("New search query detected:", newQuery);
        
        // עדכון היסטוריית החיפוש
        const updatedHistory = [
          { query: newQuery, timestamp: new Date() },
          ...searchHistory.filter(item => item.query !== newQuery).slice(0, 9)
        ];
        
        setSearchHistory(updatedHistory);
        setRecentSearches(updatedHistory.map(item => item.query));
        
        // שמירה ב-localStorage
        try {
          localStorage.setItem(
            `${localStorageKey}_recent_searches`, 
            JSON.stringify(updatedHistory.map(item => item.query))
          );
          localStorage.setItem(
            `${localStorageKey}_search_history`,
            JSON.stringify(updatedHistory.map(item => ({
              query: item.query,
              timestamp: item.timestamp.toISOString()
            })))
          );
        } catch (e) {
          console.error("Error saving search history:", e);
        }
      }
      
      // טיפול בחיפוש נפרד לגברים
      if (newFilters.maleSearchQuery && newFilters.maleSearchQuery !== prev.maleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי גברים או לשמור בהיסטוריה הכללית
        console.log("New male search query:", newFilters.maleSearchQuery);
      }
      
      // טיפול בחיפוש נפרד לנשים
      if (newFilters.femaleSearchQuery && newFilters.femaleSearchQuery !== prev.femaleSearchQuery) {
        // כאן אפשר לייצר היסטוריה נפרדת לחיפושי נשים או לשמור בהיסטוריה הכללית
        console.log("New female search query:", newFilters.femaleSearchQuery);
      }

      // קריאה לפונקציית callback
      if (onFilterChange) {
        console.log("Calling onFilterChange with updated filters");
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange, searchHistory, localStorageKey, setRecentSearches, setSearchHistory]);

  // Reset filters
  const resetFilters = useCallback(() => {
    const defaultState: FilterState = {
      ...DEFAULT_FILTER_STATE,
      ...defaultFilters
    };

    setFilters(defaultState);
    setLastAppliedFilter(null);
    onFilterChange?.(defaultState);
  }, [defaultFilters, onFilterChange]);

  // Clear recent searches
  const clearRecentSearches = useCallback(() => {
    setRecentSearches([]);
    localStorage.removeItem(`${localStorageKey}_recent_searches`);
  }, [localStorageKey]);

  // Save new filter
  const saveFilter = useCallback(async (name: string, filters: FilterState) => {
    const newFilter: SavedFilter = {
      id: Date.now().toString(),
      name,
      filters,
      isDefault: false,
      createdAt: new Date()
    };

    setSavedFilters(prev => {
      const updated = [...prev, newFilter];
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });

    return newFilter;
  }, [localStorageKey]);

  // פונקציה משופרת להחלפת מצב הסינון הנפרד
  const toggleSeparateFiltering = useCallback(() => {
    console.log("toggleSeparateFiltering called");
    
    setFilters(prev => {
      const newState = {
        ...prev,
        separateFiltering: !prev.separateFiltering
      };
      
      console.log(`Changing separateFiltering from ${prev.separateFiltering} to ${newState.separateFiltering}`);
      
      return newState;
    });
  }, []);

  // פונקציה משופרת לעדכון סינון גברים
  const updateMaleFilters = useCallback((maleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedMaleFilters = {
        ...prev.maleFilters,
        ...maleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לגברים
      if (maleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          maleFilters: updatedMaleFilters,
          maleSearchQuery: maleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        maleFilters: updatedMaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת לעדכון סינון נשים
  const updateFemaleFilters = useCallback((femaleFilters: Partial<FilterState>) => {
    setFilters(prev => {
      const updatedFemaleFilters = {
        ...prev.femaleFilters,
        ...femaleFilters
      };
      
      // אם יש עדכון של מחרוזת חיפוש ספציפית לנשים
      if (femaleFilters.searchQuery !== undefined) {
        const updated = {
          ...prev,
          femaleFilters: updatedFemaleFilters,
          femaleSearchQuery: femaleFilters.searchQuery // שמירת החיפוש גם בשדה הנפרד
        };
        
        // קריאה לפונקציית callback אם קיימת
        if (onFilterChange) {
          onFilterChange(updated);
        }
        
        return updated;
      }
      
      const updated = {
        ...prev,
        femaleFilters: updatedFemaleFilters
      };
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  const updateMaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        maleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לגברים אם פעיל סינון נפרד
      if (prev.separateFiltering) {
        updated.maleFilters = {
          ...prev.maleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);
  
  // פונקציה חדשה לעדכון חיפוש נפרד לנשים
  const updateFemaleSearchQuery = useCallback((query: string) => {
    setFilters(prev => {
      // שומרים את החיפוש בשדה הייעודי
      const updated = {
        ...prev,
        femaleSearchQuery: query
      };
      
      // מעדכנים גם את הפילטרים הספציפיים לנשים אם פעיל סינון נפרד
      if (prev.separateFiltering) {
        updated.femaleFilters = {
          ...prev.femaleFilters,
          searchQuery: query
        };
      }
      
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // פונקציה משופרת להעתקת סינון מצד אחד לשני
  const copyFilters = useCallback((source: 'male' | 'female', target: 'male' | 'female') => {
    setFilters(prev => {
      const sourceFilters = source === 'male' ? prev.maleFilters : prev.femaleFilters;
      
      if (!sourceFilters) {
        return prev;
      }
      
      const updated = { ...prev };
      
      if (target === 'male') {
        updated.maleFilters = { ...sourceFilters };
      } else {
        updated.femaleFilters = { ...sourceFilters };
      }
      
      // קריאה לפונקציית callback אם קיימת
      if (onFilterChange) {
        onFilterChange(updated);
      }
      
      return updated;
    });
  }, [onFilterChange]);

  // Update existing filter
  const updateSavedFilter = useCallback((id: string, updates: Partial<SavedFilter>) => {
    setSavedFilters(prev => {
      const updated = prev.map(filter => 
        filter.id === id ? { ...filter, ...updates } : filter
      );
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Delete filter
  const deleteFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.filter(f => f.id !== id);
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      
      if (lastAppliedFilter === id) {
        setLastAppliedFilter(null);
      }
      
      return updated;
    });
  }, [localStorageKey, lastAppliedFilter]);

  // Set default filter
  const setDefaultFilter = useCallback((id: string) => {
    setSavedFilters(prev => {
      const updated = prev.map(f => ({
        ...f,
        isDefault: f.id === id
      }));
      localStorage.setItem(localStorageKey, JSON.stringify(updated));
      return updated;
    });
  }, [localStorageKey]);

  // Load saved filter - תמיכה בסינון נפרד
  const loadSavedFilter = useCallback((id: string) => {
    const filter = savedFilters.find(f => f.id === id);
    if (filter) {
      // בדוק אם יש בפילטר השמור מידע לגבי סינון נפרד
      setFilters({ 
        ...filter.filters, 
        savedFilterId: id,
        // וודא שיש תמיד את המאפיינים האלה, גם אם אינם מוגדרים בפילטר המקורי
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {}
      });
      
      setLastAppliedFilter(id);
      onFilterChange?.({ 
        ...filter.filters, 
        savedFilterId: id,
        separateFiltering: true as boolean,        maleFilters: filter.filters.maleFilters || {},
        femaleFilters: filter.filters.femaleFilters || {} 
      });
    }
  }, [savedFilters, onFilterChange]);

  // Apply popular filter
  const applyPopularFilter = useCallback((filterConfig: Partial<FilterState>) => {
    const updatedFilters = {
      ...DEFAULT_FILTER_STATE,
      ...filterConfig
    };
    setFilters(updatedFilters);
    onFilterChange?.(updatedFilters);
  }, [onFilterChange]);

  // Check for active filters
  const hasActiveFilters = useMemo(() => {
    return (
      filters.searchQuery ||
      filters.gender !== undefined ||
      (filters.cities?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      (filters.occupations?.length ?? 0) > 0 ||  // בדיקה בטוחה למערך
      filters.religiousLevel ||
      filters.educationLevel ||
      filters.maritalStatus ||
      filters.availabilityStatus ||
      filters.userStatus ||
      filters.isVerified ||
      filters.hasReferences ||
      filters.lastActiveDays ||
      filters.isProfileComplete ||
      (filters.ageRange && (
        filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min ||
        filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
      )) ||
      (filters.heightRange && (
        filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min ||
        filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
      )) ||
      // בדיקת פילטרים נפרדים פעילים
      filters.separateFiltering
    );
  }, [filters]);

  // Get active filters in formatted array
  const activeFilters = useMemo((): FilterOption[] => {
    const active: FilterOption[] = [];

    if (filters.searchQuery) {
      active.push({
        key: 'searchQuery',
        value: filters.searchQuery,
        label: `חיפוש: ${filters.searchQuery}`,
        category: 'חיפוש'
      });
    }

    if (filters.gender) {
      active.push({
        key: 'gender',
        value: filters.gender,
        label: `מגדר: ${filters.gender === 'MALE' ? 'זכר' : 'נקבה'}`,
        category: 'מידע בסיסי'
      });
    }

    if (filters.separateFiltering) {
      active.push({
        key: 'separateFiltering',
        value: true,
        label: 'סינון נפרד לפי מגדר',
        category: 'מידע בסיסי'
      });
    }

    // גיל
    if (filters.ageRange && (
      filters.ageRange.min !== DEFAULT_FILTER_STATE.ageRange?.min || 
      filters.ageRange.max !== DEFAULT_FILTER_STATE.ageRange?.max
    )) {
      active.push({
        key: 'ageRange',
        value: filters.ageRange,
        label: `גיל: ${filters.ageRange.min}-${filters.ageRange.max}`,
        category: 'מידע בסיסי'
      });
    }

    // גובה
    if (filters.heightRange && (
      filters.heightRange.min !== DEFAULT_FILTER_STATE.heightRange?.min || 
      filters.heightRange.max !== DEFAULT_FILTER_STATE.heightRange?.max
    )) {
      active.push({
        key: 'heightRange',
        value: filters.heightRange,
        label: `גובה: ${filters.heightRange.min}-${filters.heightRange.max} ס"מ`,
        category: 'מידע בסיסי'
      });
    }

    // ערים
    if (filters.cities?.length) {
      if (filters.cities.length === 1) {
        active.push({
          key: 'cities',
          value: filters.cities[0],
          label: `עיר: ${filters.cities[0]}`,
          category: 'מיקום'
        });
      } else {
        active.push({
          key: 'cities',
          value: filters.cities,
          label: `ערים: ${filters.cities.length} נבחרו`,
          category: 'מיקום'
        });
      }
    }

    // תחומי עיסוק
    if (filters.occupations?.length) {
      if (filters.occupations.length === 1) {
        active.push({
          key: 'occupations',
          value: filters.occupations[0],
          label: `תחום עיסוק: ${filters.occupations[0]}`,
          category: 'תעסוקה'
        });
      } else {
        active.push({
          key: 'occupations',
          value: filters.occupations,
          label: `תחומי עיסוק: ${filters.occupations.length} נבחרו`,
          category: 'תעסוקה'
        });
      }
    }

    // רמת דתיות
    if (filters.religiousLevel) {
      active.push({
        key: 'religiousLevel',
        value: filters.religiousLevel,
        label: `רמת דתיות: ${filters.religiousLevel}`,
        category: 'דת'
      });
    }

    // השכלה
    if (filters.educationLevel) {
      active.push({
        key: 'educationLevel',
        value: filters.educationLevel,
        label: `השכלה: ${filters.educationLevel}`,
        category: 'השכלה'
      });
    }

    // מצב משפחתי
    if (filters.maritalStatus) {
      active.push({
        key: 'maritalStatus',
        value: filters.maritalStatus,
        label: `מצב משפחתי: ${filters.maritalStatus}`,
        category: 'מידע אישי'
      });
    }

    // סטטוס זמינות
    if (filters.availabilityStatus) {
      const statusLabel = 
        filters.availabilityStatus === "AVAILABLE" ? "פנוי/ה" :
        filters.availabilityStatus === "DATING" ? "בתהליך הכרות" :
        filters.availabilityStatus === "UNAVAILABLE" ? "לא פנוי/ה" :
        filters.availabilityStatus;
      
      active.push({
        key: 'availabilityStatus',
        value: filters.availabilityStatus,
        label: `סטטוס זמינות: ${statusLabel}`,
        category: 'זמינות'
      });
    }

    // סטטוס משתמש
    if (filters.userStatus) {
      active.push({
        key: 'userStatus',
        value: filters.userStatus,
        label: `סטטוס משתמש: ${filters.userStatus}`,
        category: 'סטטוס'
      });
    }

    // משתמש מאומת
    if (filters.isVerified !== undefined) {
      active.push({
        key: 'isVerified',
        value: filters.isVerified,
        label: `משתמש מאומת: ${filters.isVerified ? 'כן' : 'לא'}`,
        category: 'אימות'
      });
    }

    // יש המלצות
    if (filters.hasReferences !== undefined) {
      active.push({
        key: 'hasReferences',
        value: filters.hasReferences,
        label: `יש המלצות: ${filters.hasReferences ? 'כן' : 'לא'}`,
        category: 'המלצות'
      });
    }

    // פעילות אחרונה
    if (filters.lastActiveDays !== undefined) {
      active.push({
        key: 'lastActiveDays',
        value: filters.lastActiveDays,
        label: `פעיל ב-${filters.lastActiveDays} הימים האחרונים`,
        category: 'פעילות'
      });
    }

    // פרופיל מלא
    if (filters.isProfileComplete !== undefined) {
      active.push({
        key: 'isProfileComplete',
        value: filters.isProfileComplete,
        label: `פרופיל מלא: ${filters.isProfileComplete ? 'כן' : 'לא'}`,
        category: 'שלמות פרופיל'
      });
    }

    return active;
  }, [filters]);

  // Remove single filter
  const removeFilter = useCallback((key: keyof FilterState, value?: string) => {
    setFilters(prev => {
      const updated = { ...prev };

      if (key === 'separateFiltering') {
        updated.separateFiltering = false;
      } else if (Array.isArray(updated[key]) && value !== undefined) {
        if (key === 'cities' || key === 'occupations') {
          updated[key] = (updated[key] as string[]).filter(v => v !== value);
        }
      } else {
        delete updated[key];
      }

      onFilterChange?.(updated);
      return updated;
    });
  }, [onFilterChange]);
  
  // Calculate popular filters based on search history
  const popularFilters = useMemo(() => {
    // Group searches by frequency
    const searchFrequency: Record<string, number> = {};
    searchHistory.forEach(item => {
      searchFrequency[item.query] = (searchFrequency[item.query] || 0) + 1;
    });
    
    // Sort by frequency
    return Object.entries(searchFrequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([query]) => query);
  }, [searchHistory]);

  return {
    // Current state
    filters,
    savedFilters,
    recentSearches,
    searchHistory,
    activeFilters,
    hasActiveFilters,
    popularFilters,
    lastAppliedFilter,
    
    // Separate filtering functions
    toggleSeparateFiltering,
    updateMaleFilters,
    updateFemaleFilters,
    copyFilters,
    
    // חיפוש נפרד פונקציות חדשות
    updateMaleSearchQuery,
    updateFemaleSearchQuery,
    
    // Actions
    setFilters: updateFilters,
    removeFilter,
    resetFilters,
    clearRecentSearches,
    applyPopularFilter,

    // Saved filters management
    saveFilter,
    updateSavedFilter,
    deleteFilter,
    setDefaultFilter,
    loadSavedFilter,
};
};
export default useFilterLogic;
--- End of Content for useFilterLogic.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\hooks\useStatistics.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useStatistics.ts

import { useMemo } from 'react';
import type { Candidate } from '../types/candidates';
import {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
} from '../../suggestions/utils/statisticsCalculator';

export interface Statistics {
  gender: {
    maleCount: number;
    femaleCount: number;
    ratio: number;
    total: number;
    percentages: {
      male: number;
      female: number;
    };
  };
  age: {
    ageGroups: Record<string, number>;
    averageAge: number;
    medianAge: number;
  };
  location: {
    cities: Record<string, number>;
    topCities: Array<{ city: string; count: number }>;
  };
  religious: {
    levels: Record<string, number>;
    percentages: Record<string, number>;
  };
  activity: {
    activeLastWeek: number;
    activeLastMonth: number;
    averageLoginFrequency: number;
    completedProfiles: number;
  };
  availability: {
    counts: Record<string, number>;
    percentages: Record<string, number>;
  };
  completion: {
    counts: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
    percentages: {
      hasPhotos: number;
      hasAbout: number;
      hasReferences: number;
      hasPreferences: number;
      isVerified: number;
      fullyCompleted: number;
    };
  };
}

export const useStatistics = (candidates: Candidate[]) => {
  const stats = useMemo<Statistics>(() => {
    return {
      gender: calculateGenderStats(candidates),
      age: calculateAgeDistribution(candidates),
      location: calculateLocationDistribution(candidates),
      religious: calculateReligiousDistribution(candidates),
      activity: calculateActivityStats(candidates),
      availability: calculateAvailabilityStats(candidates),
      completion: calculateCompletionStats(candidates)
    };
  }, [candidates]);

  // פונקציות עזר לשליפת נתונים ספציפיים
  const getGenderRatio = () => {
    return {
      ratio: stats.gender.ratio,
      formattedRatio: `${stats.gender.maleCount}:${stats.gender.femaleCount}`
    };
  };

  const getTopCities = (limit: number = 5) => {
    return stats.location.topCities.slice(0, limit);
  };

  const getActiveUsersPercent = () => {
    return Math.round((stats.activity.activeLastWeek / stats.gender.total) * 100);
  };

  const getCompletionRate = () => {
    return stats.completion.percentages.fullyCompleted;
  };

  const getAgeGroupDistribution = () => {
    return Object.entries(stats.age.ageGroups)
      .map(([range, count]) => ({
        range,
        count,
        percentage: Math.round((count / stats.gender.total) * 100)
      }))
      .sort((a, b) => {
        const [aMin] = a.range.split('-').map(Number);
        const [bMin] = b.range.split('-').map(Number);
        return aMin - bMin;
      });
  };

  const getReligiousDistribution = () => {
    return Object.entries(stats.religious.levels)
      .map(([level, count]) => ({
        level,
        count,
        percentage: stats.religious.percentages[level]
      }))
      .sort((a, b) => b.count - a.count);
  };

  const getActivityTrend = () => {
    return {
      weekly: stats.activity.activeLastWeek,
      monthly: stats.activity.activeLastMonth,
      average: stats.activity.averageLoginFrequency
    };
  };

  const getProfileCompletionStats = () => {
    return {
      completed: stats.completion.counts.fullyCompleted,
      partial: stats.gender.total - stats.completion.counts.fullyCompleted,
      percentage: stats.completion.percentages.fullyCompleted
    };
  };

  return {
    stats,
    getGenderRatio,
    getTopCities,
    getActiveUsersPercent,
    getCompletionRate,
    getAgeGroupDistribution,
    getReligiousDistribution,
    getActivityTrend,
    getProfileCompletionStats
  };
};

export default useStatistics;
--- End of Content for useStatistics.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\LoadingStates.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React from "react";
import { Loader2, AlertCircle } from "lucide-react";
import { cn } from "@/lib/utils";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";

interface LoadingContainerProps {
  children: React.ReactNode;
  className?: string;
}

interface LoadingSpinnerProps {
  size?: "sm" | "md" | "lg";
  className?: string;
}

interface LoadingCardProps {
  count?: number;
  layout?: "grid" | "list";
  className?: string;
}

interface LoadingTextProps {
  lines?: number;
  className?: string;
}

interface LoadingErrorProps {
  message: string;
  onRetry?: () => void;
  className?: string;
}

export const LoadingContainer: React.FC<LoadingContainerProps> = ({
  children,
  className,
}) => {
  return (
    <div className={cn("relative min-h-[200px]", className)}>
      <div className="absolute inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
      </div>
      <div className="opacity-50 pointer-events-none">{children}</div>
    </div>
  );
};

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = "md",
  className,
}) => {
  const sizeClasses = {
    sm: "w-4 h-4",
    md: "w-8 h-8",
    lg: "w-12 h-12",
  };

  return (
    <div className={cn("flex items-center justify-center", className)}>
      <Loader2
        className={cn("animate-spin text-blue-600", sizeClasses[size])}
      />
    </div>
  );
};

export const LoadingCard: React.FC<LoadingCardProps> = ({
  count = 1,
  layout = "grid",
  className,
}) => {
  return (
    <div
      className={cn(
        layout === "grid"
          ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
          : "space-y-4",
        className
      )}
    >
      {Array.from({ length: count }).map((_, index) => (
        <div
          key={index}
          className={cn(
            "bg-white rounded-lg overflow-hidden shadow-sm",
            layout === "list" ? "flex gap-4" : ""
          )}
        >
          <Skeleton
            className={cn(
              "bg-gray-200",
              layout === "list" ? "w-32 h-32" : "w-full h-48"
            )}
          />

          <div className="p-4 flex-1">
            <div className="flex items-center justify-between mb-4">
              <Skeleton className="h-6 w-1/3" />
              <Skeleton className="h-6 w-16" />
            </div>

            <div className="space-y-2">
              <Skeleton className="h-4 w-2/3" />
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-4 w-3/4" />
            </div>

            <div className="flex gap-2 mt-4">
              <Skeleton className="h-9 w-24" />
              <Skeleton className="h-9 w-24" />
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export const LoadingText: React.FC<LoadingTextProps> = ({
  lines = 3,
  className,
}) => {
  return (
    <div className={cn("space-y-2", className)}>
      {Array.from({ length: lines }).map((_, index) => (
        <Skeleton
          key={index}
          className={cn("h-4", index === lines - 1 ? "w-3/4" : "w-full")}
        />
      ))}
    </div>
  );
};

export const LoadingError: React.FC<LoadingErrorProps> = ({
  message,
  onRetry,
  className,
}) => {
  return (
    <Alert variant="destructive" className={cn("border-red-500", className)}>
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>שגיאה</AlertTitle>
      <AlertDescription className="flex items-center justify-between">
        <span>{message}</span>
        {onRetry && (
          <Button
            variant="outline"
            size="sm"
            onClick={onRetry}
            className="ml-4"
          >
            נסה שוב
          </Button>
        )}
      </AlertDescription>
    </Alert>
  );
};

export const LoadingStats: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("grid grid-cols-2 md:grid-cols-4 gap-4", className)}>
      {Array.from({ length: 4 }).map((_, index) => (
        <div key={index} className="bg-white p-4 rounded-lg shadow-sm">
          <Skeleton className="h-4 w-16 mb-2" />
          <Skeleton className="h-8 w-24" />
        </div>
      ))}
    </div>
  );
};

export const LoadingFilters: React.FC<{ className?: string }> = ({
  className,
}) => {
  return (
    <div className={cn("space-y-4", className)}>
      <Skeleton className="h-10 w-full" />
      <div className="flex flex-wrap gap-2">
        {Array.from({ length: 4 }).map((_, index) => (
          <Skeleton key={index} className="h-8 w-24" />
        ))}
      </div>
    </div>
  );
};

// Create a named object containing all loading components
const LoadingComponents = {
  LoadingContainer,
  LoadingSpinner,
  LoadingCard,
  LoadingText,
  LoadingError,
  LoadingStats,
  LoadingFilters,
};

// Export the named object as default
export default LoadingComponents;
--- End of Content for LoadingStates.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\Pagination.tsx
--------------------------------------------------------------------------------
Content:
// /shared/Pagination.tsx
"use client";


import React from 'react';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { 
  ChevronRight, 
  ChevronLeft,
  ChevronsLeft,
  ChevronsRight
} from 'lucide-react';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  pageSize: number;
  totalItems: number;
  onPageChange: (page: number) => void;
  onPageSizeChange: (size: number) => void;
  className?: string;
}

const pageSizeOptions = [10, 20, 50, 100];

const Pagination: React.FC<PaginationProps> = ({
  currentPage,
  totalPages,
  pageSize,
  totalItems,
  onPageChange,
  onPageSizeChange,
  className
}) => {
  // Helper to generate page numbers array
  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisiblePages = 5;
    
    if (totalPages <= maxVisiblePages) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    // Always show first page
    pages.push(1);

    // Calculate start and end of visible pages
    let start = Math.max(currentPage - 1, 2);
    let end = Math.min(currentPage + 1, totalPages - 1);

    // Adjust for edge cases
    if (currentPage <= 3) {
      end = Math.min(maxVisiblePages - 1, totalPages - 1);
    } else if (currentPage >= totalPages - 2) {
      start = Math.max(totalPages - maxVisiblePages + 2, 2);
    }

    // Add ellipsis and numbers
    if (start > 2) pages.push('...');
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    if (end < totalPages - 1) pages.push('...');

    // Always show last page
    if (totalPages > 1) pages.push(totalPages);

    return pages;
  };

  const startItem = (currentPage - 1) * pageSize + 1;
  const endItem = Math.min(currentPage * pageSize, totalItems);

  return (
    <div className={`flex flex-col sm:flex-row items-center justify-between gap-4 ${className}`}>
      {/* Page Size Selector */}
      <div className="flex items-center gap-2 text-sm text-gray-600">
        <span>הצג</span>
        <Select
          value={pageSize.toString()}
          onValueChange={(value) => onPageSizeChange(Number(value))}
        >
          <SelectTrigger className="w-[70px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {pageSizeOptions.map(size => (
              <SelectItem key={size} value={size.toString()}>
                {size}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <span>שורות</span>
      </div>

      {/* Results Count */}
      <div className="text-sm text-gray-600">
        מציג {startItem}-{endItem} מתוך {totalItems} תוצאות
      </div>

      {/* Page Navigation */}
      <div className="flex items-center gap-1">
        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(1)}
          disabled={currentPage === 1}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((page, index) => (
          typeof page === 'number' ? (
            <Button
              key={index}
              variant={currentPage === page ? "default" : "outline"}
              size="sm"
              onClick={() => onPageChange(page)}
              className="hidden sm:inline-flex min-w-[32px]"
            >
              {page}
            </Button>
          ) : (
            <span key={index} className="px-2">
              {page}
            </span>
          )
        ))}

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(totalPages)}
          disabled={currentPage === totalPages}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};

export default Pagination;
--- End of Content for Pagination.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\shared\StatusBadge.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Badge } from "@/components/ui/badge";
import {
  Circle,
  CheckCircle,
  XCircle,
  Clock,
  AlertTriangle,
} from "lucide-react";
import { MatchSuggestionStatus, VerificationStatus } from "@prisma/client";

type StatusType = "suggestion" | "verification" | "profile";
type StatusSize = "sm" | "md" | "lg";

interface StatusConfig {
  label: string;
  color: "destructive" | "outline" | "secondary" | "success" | "warning";
  icon:
    | typeof Circle
    | typeof CheckCircle
    | typeof XCircle
    | typeof Clock
    | typeof AlertTriangle;
}

interface StatusBadgeProps {
  type: StatusType;
  status: string;
  size?: StatusSize;
}

const suggestionStatuses: Record<MatchSuggestionStatus, StatusConfig> = {
  DRAFT: {
    label: "טיוטה",
    color: "secondary",
    icon: Circle,
  },
  PENDING_FIRST_PARTY: {
    label: "ממתין לצד ראשון",
    color: "warning",
    icon: Clock,
  },
  FIRST_PARTY_APPROVED: {
    label: 'אושר ע"י צד ראשון',
    color: "success",
    icon: CheckCircle,
  },
  FIRST_PARTY_DECLINED: {
    label: 'נדחה ע"י צד ראשון',
    color: "destructive",
    icon: XCircle,
  },
  PENDING_SECOND_PARTY: {
    label: "ממתין לצד שני",
    color: "warning",
    icon: Clock,
  },
  SECOND_PARTY_APPROVED: {
    label: 'אושר ע"י צד שני',
    color: "success",
    icon: CheckCircle,
  },
  SECOND_PARTY_DECLINED: {
    label: 'נדחה ע"י צד שני',
    color: "destructive",
    icon: XCircle,
  },
  AWAITING_MATCHMAKER_APPROVAL: {
    label: "ממתין לאישור שדכן",
    color: "warning",
    icon: Clock,
  },
  CONTACT_DETAILS_SHARED: {
    label: "פרטי קשר שותפו",
    color: "success",
    icon: CheckCircle,
  },
  AWAITING_FIRST_DATE_FEEDBACK: {
    label: "ממתין למשוב פגישה ראשונה",
    color: "warning",
    icon: Clock,
  },
  THINKING_AFTER_DATE: {
    label: "בשיקול לאחר פגישה",
    color: "warning",
    icon: Clock,
  },
  PROCEEDING_TO_SECOND_DATE: {
    label: "ממשיכים לפגישה שנייה",
    color: "success",
    icon: CheckCircle,
  },
  ENDED_AFTER_FIRST_DATE: {
    label: "הסתיים לאחר פגישה ראשונה",
    color: "destructive",
    icon: XCircle,
  },
  MEETING_PENDING: {
    label: "פגישה בתכנון",
    color: "warning",
    icon: Clock,
  },
  MEETING_SCHEDULED: {
    label: "פגישה נקבעה",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_APPROVED: {
    label: "השידוך אושר",
    color: "success",
    icon: CheckCircle,
  },
  MATCH_DECLINED: {
    label: "השידוך נדחה",
    color: "destructive",
    icon: XCircle,
  },
  DATING: {
    label: "בתהליך היכרות",
    color: "secondary",
    icon: Circle,
  },
  ENGAGED: {
    label: "מאורסים",
    color: "success",
    icon: CheckCircle,
  },
  MARRIED: {
    label: "נישאו",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  CLOSED: {
    label: "סגור",
    color: "destructive",
    icon: XCircle,
  },
  CANCELLED: {
    label: "בוטל",
    color: "destructive",
    icon: XCircle,
  },
};

const verificationStatuses: Record<VerificationStatus, StatusConfig> = {
  PENDING: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  COMPLETED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  EXPIRED: {
    label: "פג תוקף",
    color: "destructive",
    icon: XCircle,
  },
  FAILED: {
    label: "נכשל",
    color: "destructive",
    icon: XCircle,
  },
};

const profileStatuses: Record<string, StatusConfig> = {
  INCOMPLETE: {
    label: "לא הושלם",
    color: "warning",
    icon: AlertTriangle,
  },
  PENDING_VERIFICATION: {
    label: "ממתין לאימות",
    color: "warning",
    icon: Clock,
  },
  VERIFIED: {
    label: "מאומת",
    color: "success",
    icon: CheckCircle,
  },
  BLOCKED: {
    label: "חסום",
    color: "destructive",
    icon: XCircle,
  },
};

const defaultStatus: StatusConfig = {
  label: "לא ידוע",
  color: "secondary",
  icon: Circle,
};

const getStatusConfig = (type: StatusType, status: string): StatusConfig => {
  switch (type) {
    case "suggestion":
      return (
        suggestionStatuses[status as MatchSuggestionStatus] || defaultStatus
      );
    case "verification":
      return (
        verificationStatuses[status as VerificationStatus] || defaultStatus
      );
    case "profile":
      return profileStatuses[status] || defaultStatus;
    default:
      return defaultStatus;
  }
};

const StatusBadge: React.FC<StatusBadgeProps> = ({
  type,
  status,
  size = "md",
}) => {
  const config = getStatusConfig(type, status);
  const Icon = config.icon;

  const sizeClasses = {
    sm: "text-xs px-2 py-0.5",
    md: "text-sm px-2.5 py-1",
    lg: "text-base px-3 py-1.5",
  };

  return (
    <Badge
      variant={config.color}
      className={`flex items-center gap-1.5 ${sizeClasses[size]}`}
    >
      <Icon className={size === "sm" ? "w-3 h-3" : "w-4 h-4"} />
      <span>{config.label}</span>
    </Badge>
  );
};

export default StatusBadge;
--- End of Content for StatusBadge.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types\candidates.ts
--------------------------------------------------------------------------------
Content:
// candidates.ts
import { Gender, AvailabilityStatus, UserStatus, UserSource  } from '@prisma/client';
import type { UserProfile, UserImage, QuestionnaireResponse} from '@/types/next-auth';

// Base API Response Type
export interface APIResponse<T> {
  success: boolean;
  clients: T[];
  count: number;
  error?: string;
}

// Base Types
export type CandidateImage = UserImage;

export type CandidateProfile = UserProfile;

export type MobileView = 'single' | 'double';

export interface Candidate {
  id: string;
  email: string;
  firstName: string;
  createdAt: Date;
  lastName: string;
  status: UserStatus;
  isVerified: boolean;
  images: CandidateImage[];
  isProfileComplete: boolean;
  source: UserSource; // Add new field
  addedByMatchmakerId?: string | null; // Add new field
  profile: CandidateProfile; // Ensure this uses the updated CandidateProfile
}
export interface CandidatesFilter {
   source?: UserSource;
  gender?: Gender;
  ageRange?: {
    min: number;
    max: number;
  };
  heightRange?: {
    min: number;
    max: number;
  };
  cities?: string[];
  religiousLevel?: string;
  occupations?: string[];
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
  searchQuery?: string;
  savedFilterId?: string;
  separateFiltering?: boolean;
  
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;
  
  maleFilters?: Partial<CandidatesFilter>;
  femaleFilters?: Partial<CandidatesFilter>;
  userStatus?: UserStatus;
}

// ViewMode and Action Types - אלה נשארים כמו שהם
export type ViewMode = 'grid' | 'list';
export type CardSize = 'sm' | 'md' | 'lg';
export type CandidateAction = 'suggest' | 'invite' | 'contact' | 'favorite' | 'view' | 'edit';

// Profile Card Types
export interface ProfileCardData {
  profile: CandidateProfile;
  images: CandidateImage[];
  questionnaire?: QuestionnaireResponse;
}

/**
 * ממפה את אובייקט המועמד מהשרת למבנה הנדרש עבור ProfileCard
 */
export const mapCandidateToProfileCard = (candidate: Candidate): ProfileCardData => {
  return {
    profile: candidate.profile,
    images: candidate.images,
    questionnaire: undefined // יש להוסיף לוגיקה לטעינת השאלון בנפרד
  };
};

/**
 * מפריד מועמדים לפי מגדר
 */
export const separateCandidatesByGender = (candidates: Candidate[]) => {
  return {
    maleCandidates: candidates.filter(c => c.profile.gender === 'MALE'),
    femaleCandidates: candidates.filter(c => c.profile.gender === 'FEMALE')
  };
};

/**
 * בודק האם הפרופיל מלא
 */
export const isProfileComplete = (profile: CandidateProfile): boolean => {
  const requiredFields: Array<keyof CandidateProfile> = [
    'birthDate',
    'city',
    'religiousLevel',
    'about',
    'occupation',
    'education'
  ];

  return requiredFields.every(field => Boolean(profile[field]));
};

const candidateUtils = {
  mapCandidateToProfileCard,
  separateCandidatesByGender,
  isProfileComplete
};

export default candidateUtils;
--- End of Content for candidates.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\new\types\filters.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/new/types/filters.ts

import { Gender, AvailabilityStatus, UserStatus, UserSource  } from '@prisma/client';

// הגדרת טווח ערכים מספריים
export interface RangeFilter {
  min: number;
  max: number;
}

// הגדרת פילטר שמור
export interface SavedFilter {
  id: string;
  name: string;
  filters: FilterState;
  isDefault?: boolean;
  createdAt: Date;
}

export interface FilterState {
  // הוספת מצב תצוגה נפרדת
  separateFiltering: boolean;
    source?: UserSource | undefined;
  // הוספת שדות חיפוש נפרדים
  maleSearchQuery?: string;
  femaleSearchQuery?: string;

  // פילטרים נפרדים לגברים
  maleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;
  
  // פילטרים נפרדים לנשים
  femaleFilters?: Omit<FilterState, 'gender' | 'maleFilters' | 'femaleFilters' | 
    'separateFiltering' | 'maleSearchQuery' | 'femaleSearchQuery'>;

  searchQuery?: string;
  savedFilterId?: string;
  gender?: Gender | undefined;
  ageRange?: RangeFilter;
  heightRange?: RangeFilter;
  cities?: string[];
  occupations?: string[];
  religiousLevel?: string;
  educationLevel?: string;
  maritalStatus?: string;
  availabilityStatus?: AvailabilityStatus | string;
  userStatus?: UserStatus;
  isVerified?: boolean;
  hasReferences?: boolean;
  lastActiveDays?: number;
  isProfileComplete?: boolean;
}

// הגדרת אפשרות פילטר
export interface FilterOption {
  key: keyof (FilterState & { education: string });
  value: Gender | AvailabilityStatus | UserStatus | RangeFilter | string[] | string | number | boolean | undefined;
  label: string;
  category?: string;
}

// הגדרת קטגוריית פילטר
export interface FilterCategory {
  id: string;
  label: string;
  filters: Array<keyof (FilterState & { education: string })>;
}

// הגדרת פרופ לקומפוננטת הפילטרים
export interface FilterProps {
  filters: FilterState;
  onFiltersChange: (filters: FilterState) => void;
  onReset?: () => void;
  className?: string;
}

// הגדרת אפשרויות הפילטר
export interface FilterOptions {
  ages: RangeFilter;
  heights: RangeFilter;
  cities: string[];
  religiousLevels: string[];
  educationLevels: string[];
  occupations: string[];
  maritalStatuses: string[];
  availabilityStatuses: AvailabilityStatus[];
}

// הגדרת מצב הממשק של הפילטרים
export interface FilterUIState {
  isOpen: boolean;
  activeCategory?: string;
  showSaveDialog: boolean;
  presetName: string;
}

// הגדרה של אירועי שינוי בפילטרים
export type FilterChangeHandler = (filters: FilterState) => void;

// הגדרת אירועי שמירת פילטר
export interface SaveFilterHandler {
  (name: string, filters: FilterState): Promise<SavedFilter>;
}

// הגדרת אירועי טעינת פילטר
export interface LoadFilterHandler {
  (id: string): void;
}

// הגדרת הגדרות הפילטרים
export interface FilterSettings {
  localStorageKey?: string;
  defaultFilters?: Partial<FilterState>;
  onFilterChange?: FilterChangeHandler;
}

// הגדרת תוצאות הפילטר
export interface FilterResults {
  totalResults: number;
  filteredResults: number;
  categories: Record<string, number>;
}

// קונסטנטות של הפילטרים
export const DEFAULT_FILTER_STATE: FilterState = {
  separateFiltering: false,
  maleFilters: {},
  femaleFilters: {},
  maleSearchQuery: '',
  femaleSearchQuery: '',
  gender: undefined,
  ageRange: { min: 18, max: 99 },
  heightRange: { min: 140, max: 210 },
  cities: [],
  occupations: [],
  religiousLevel: undefined,
  educationLevel: undefined,
  maritalStatus: undefined,
  availabilityStatus: undefined,
    source: undefined,
  userStatus: undefined,
  isVerified: undefined,
  hasReferences: undefined,
  lastActiveDays: undefined,
  isProfileComplete: undefined,
  searchQuery: '',
  savedFilterId: undefined
};

// קטגוריות פילטרים מוגדרות מראש
export const FILTER_CATEGORIES: FilterCategory[] = [
  {
    id: 'basic',
    label: 'פילטרים בסיסיים',
    filters: ['gender', 'ageRange', 'cities', 'religiousLevel']
  },
  {
    id: 'advanced',
    label: 'פילטרים מתקדמים',
    filters: ['heightRange', 'occupations', 'educationLevel', 'maritalStatus']
  },
  {
    id: 'status',
    label: 'סטטוס ואימות',
    filters: ['availabilityStatus', 'isVerified', 'hasReferences', 'lastActiveDays']
  }
];

// טיפוסי מיון
export type SortDirection = 'asc' | 'desc';

export interface SortOption {
  field: keyof FilterState;
  direction: SortDirection;
  label: string;
}

// הגדרות קיבוץ
export interface GroupOption {
  field: keyof FilterState;
  label: string;
}

export const filterConstants = {
  DEFAULT_FILTER_STATE,
  FILTER_CATEGORIES
};

export default filterConstants;
--- End of Content for filters.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\EditSuggestionForm.tsx
--------------------------------------------------------------------------------
Content:
// קוד מתוקן ב-EditSuggestionForm.tsx עם פתרון לבעיית הטיפוסים

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { DatePicker } from "@/components/ui/date-picker";
import type { Suggestion } from "@/types/suggestions";

interface EditSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSave: (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      status?: MatchSuggestionStatus;
      statusNotes?: string;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => Promise<void>;
}

const EditSuggestionForm: React.FC<EditSuggestionFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSave,
}) => {
  const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
  // נשתמש בסוג נפרד לתיעוד אם נבחר סטטוס חדש או לא
  const [selectedStatus, setSelectedStatus] = useState<string | null>(null);
  // נשתמש במשתנה נפרד שיחזיק את הסטטוס האמיתי שיישלח לשרת
  const [statusToUpdate, setStatusToUpdate] =
    useState<MatchSuggestionStatus | null>(null);
  const [statusNotes, setStatusNotes] = useState("");
  const [matchingReason, setMatchingReason] = useState("");
  const [firstPartyNotes, setFirstPartyNotes] = useState("");
  const [secondPartyNotes, setSecondPartyNotes] = useState("");
  const [internalNotes, setInternalNotes] = useState("");
  const [decisionDeadline, setDecisionDeadline] = useState<Date | undefined>(
    undefined
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showStatusChange, setShowStatusChange] = useState(false);

  // עדכון הטופס כאשר נתוני ההצעה משתנים
  useEffect(() => {
    if (suggestion) {
      // עדכון כל השדות עם הנתונים הקיימים בהצעה
      setPriority(suggestion.priority as Priority);
      setSelectedStatus(null);
      setStatusToUpdate(null);
      setStatusNotes("");
      setMatchingReason(suggestion.matchingReason || "");
      setFirstPartyNotes(suggestion.firstPartyNotes || "");
      setSecondPartyNotes(suggestion.secondPartyNotes || "");
      setInternalNotes(suggestion.internalNotes || "");

      // טיפול נכון בתאריך
      if (suggestion.decisionDeadline) {
        // וידוא שמדובר בתאריך תקין
        const deadlineDate = new Date(suggestion.decisionDeadline);
        if (!isNaN(deadlineDate.getTime())) {
          setDecisionDeadline(deadlineDate);
        }
      } else {
        setDecisionDeadline(undefined);
      }
    }
  }, [suggestion]);

  const handleSubmit = async () => {
    if (!suggestion) return;

    try {
      setIsSubmitting(true);

      // מבנה העדכון עם אפשרות לסטטוס
      const updateData: {
        priority: Priority;
        status?: MatchSuggestionStatus;
        statusNotes?: string;
        matchingReason: string;
        firstPartyNotes: string;
        secondPartyNotes: string;
        internalNotes: string;
        decisionDeadline: string | null;
      } = {
        priority,
        matchingReason,
        firstPartyNotes,
        secondPartyNotes,
        internalNotes,
        decisionDeadline: decisionDeadline
          ? decisionDeadline.toISOString()
          : null,
      };

      // הוספת סטטוס רק אם נבחר סטטוס חדש לעדכון
      if (statusToUpdate) {
        updateData.status = statusToUpdate;
        updateData.statusNotes =
          statusNotes || `סטטוס שונה ל-${getStatusLabel(statusToUpdate)}`;
      }

      // עדכון הקומפוננטה ההורה
      await onSave({
        suggestionId: suggestion.id,
        updates: {
          priority,
          status: statusToUpdate || undefined,
          statusNotes: statusToUpdate ? statusNotes : undefined,
          matchingReason,
          firstPartyNotes,
          secondPartyNotes,
          internalNotes,
          decisionDeadline,
        },
      });

      toast.success("פרטי ההצעה עודכנו בהצלחה");
      onClose();
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    } finally {
      setIsSubmitting(false);
    }
  };

  // פונקציה להחזרת התווית המתאימה לסטטוס
  const getStatusLabel = (statusValue: string): string => {
    const statusLabels: Record<string, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
      FIRST_PARTY_APPROVED: "צד א׳ אישר",
      FIRST_PARTY_DECLINED: "צד א׳ דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
      SECOND_PARTY_APPROVED: "צד ב׳ אישר",
      SECOND_PARTY_DECLINED: "צד ב׳ דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
      PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
      ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
      MEETING_PENDING: "ממתין לקביעת פגישה",
      MEETING_SCHEDULED: "פגישה נקבעה",
      MATCH_APPROVED: "ההצעה אושרה",
      MATCH_DECLINED: "ההצעה נדחתה",
      DATING: "בתהליך היכרות",
      ENGAGED: "מאורסים",
      MARRIED: "נישאו",
      EXPIRED: "פג תוקף",
      CLOSED: "ההצעה נסגרה",
      CANCELLED: "ההצעה בוטלה",
    };

    return statusLabels[statusValue] || statusValue;
  };

  // הסטטוסים שניתן לשנות אליהם - יכול להשתנות לפי הסטטוס הנוכחי
  const getAvailableStatuses = (): MatchSuggestionStatus[] => {
    if (!suggestion) return [];

    // סטטוסים מרכזיים שתמיד זמינים
    const commonStatuses: MatchSuggestionStatus[] = [
      "PENDING_FIRST_PARTY",
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "PENDING_SECOND_PARTY",
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "CONTACT_DETAILS_SHARED",
      "DATING",
      "EXPIRED",
      "CLOSED",
      "CANCELLED",
    ];

    return commonStatuses;
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>עריכת הצעת שידוך</DialogTitle>
          <DialogDescription>
            עריכת הפרטים עבור ההצעה בין {suggestion.firstParty.firstName}{" "}
            {suggestion.firstParty.lastName} ל{suggestion.secondParty.firstName}{" "}
            {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Status and Priority Section */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Priority */}
            <div className="space-y-2">
              <Label>עדיפות ההצעה</Label>
              <Select
                value={priority}
                onValueChange={(value) => setPriority(value as Priority)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י עדיפות" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={Priority.URGENT}>דחוף</SelectItem>
                  <SelectItem value={Priority.HIGH}>גבוהה</SelectItem>
                  <SelectItem value={Priority.MEDIUM}>רגילה</SelectItem>
                  <SelectItem value={Priority.LOW}>נמוכה</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Status */}
            <div className="space-y-2">
              <Label>שינוי סטטוס (אופציונלי)</Label>
              <Select
                value={selectedStatus || undefined}
                onValueChange={(value) => {
                  setSelectedStatus(value);

                  // אם נבחר "ללא שינוי" או ערך ריק
                  if (value === "NO_CHANGE" || !value) {
                    setStatusToUpdate(null);
                    setShowStatusChange(false);
                  } else {
                    // אחרת, מעדכנים את הסטטוס שיישלח לשרת
                    setStatusToUpdate(value as MatchSuggestionStatus);
                    setShowStatusChange(true);
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="בחר/י סטטוס חדש (אופציונלי)" />
                </SelectTrigger>
                <SelectContent>
                  {/* משתמשים בערך חוקי מהמערכת */}
                  <SelectItem value="NO_CHANGE">ללא שינוי</SelectItem>
                  {getAvailableStatuses().map((availableStatus) => (
                    <SelectItem key={availableStatus} value={availableStatus}>
                      {getStatusLabel(availableStatus)}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Status Notes - מוצג רק אם נבחר סטטוס לעדכון */}
          {showStatusChange && statusToUpdate && (
            <div className="space-y-2 bg-slate-50 p-4 rounded-md border">
              <Label>הערות לשינוי הסטטוס</Label>
              <Textarea
                value={statusNotes}
                onChange={(e) => setStatusNotes(e.target.value)}
                placeholder="הערות אופציונליות לשינוי הסטטוס..."
                className="h-20"
              />
              <div className="text-xs text-gray-500 mt-1">
                הערות אלו יוצגו בהיסטוריית השינויים של ההצעה
              </div>
            </div>
          )}

          {/* Decision Deadline */}
          <div className="space-y-2">
            <Label>מועד החלטה אחרון</Label>
            <DatePicker
              value={{ from: decisionDeadline, to: undefined }}
              onChange={({ from }) => setDecisionDeadline(from)}
            />
          </div>

          {/* Matching Reason */}
          <div className="space-y-2">
            <Label>סיבת ההתאמה</Label>
            <Textarea
              value={matchingReason}
              onChange={(e) => setMatchingReason(e.target.value)}
              placeholder="פרט/י מדוע יש התאמה בין המועמדים..."
              className="h-24"
            />
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-2">
              <Label>הערות לצד א׳ ({suggestion.firstParty.firstName})</Label>
              <Textarea
                value={firstPartyNotes}
                onChange={(e) => setFirstPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד א׳..."
                className="h-24"
              />
            </div>

            <div className="space-y-2">
              <Label>הערות לצד ב׳ ({suggestion.secondParty.firstName})</Label>
              <Textarea
                value={secondPartyNotes}
                onChange={(e) => setSecondPartyNotes(e.target.value)}
                placeholder="הערות שיוצגו רק לצד ב׳..."
                className="h-24"
              />
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-2">
            <Label>הערות פנימיות</Label>
            <Textarea
              value={internalNotes}
              onChange={(e) => setInternalNotes(e.target.value)}
              placeholder="הערות פנימיות לשימוש השדכנים בלבד..."
              className="h-24"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? "שומר..." : "שמור שינויים"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default EditSuggestionForm;
--- End of Content for EditSuggestionForm.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\MessageForm.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "sonner";
import { MessageCircle, Send, AlertCircle } from "lucide-react";
import type { Suggestion } from "@/types/suggestions";

interface MessageFormProps {
  isOpen: boolean;
  onClose: () => void;
  suggestion: Suggestion | null;
  onSend: (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => Promise<void>;
}

const MessageForm: React.FC<MessageFormProps> = ({
  isOpen,
  onClose,
  suggestion,
  onSend,
}) => {
  const [partyType, setPartyType] = useState<"first" | "second" | "both">(
    "both"
  );
  const [messageType, setMessageType] = useState<
    "message" | "reminder" | "update"
  >("message");
  const [messageContent, setMessageContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async () => {
    if (!suggestion || !messageContent.trim()) return;

    try {
      setIsSubmitting(true);

      // Notify the parent component
      await onSend({
        suggestionId: suggestion.id,
        partyType,
        messageType,
        messageContent,
      });

      toast.success(
        `ההודעה נשלחה ${
          partyType === "first"
            ? `ל${suggestion.firstParty.firstName}`
            : partyType === "second"
            ? `ל${suggestion.secondParty.firstName}`
            : "לשני הצדדים"
        }`
      );
      onClose();
    } catch (error) {
      toast.error("שגיאה בשליחת ההודעה");
      console.error("Error sending message:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getMessagePlaceholder = () => {
    switch (messageType) {
      case "reminder":
        return "הודעת תזכורת למועמד/ת לגבי ההצעה...";
      case "update":
        return "עדכון לגבי סטטוס ההצעה או מידע חדש...";
      default:
        return "הודעה אישית למועמד/ת...";
    }
  };

  if (!suggestion) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>שליחת הודעה</DialogTitle>
          <DialogDescription>
            שליחת הודעה הקשורה להצעת השידוך בין{" "}
            {suggestion.firstParty.firstName} {suggestion.firstParty.lastName} ל
            {suggestion.secondParty.firstName} {suggestion.secondParty.lastName}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 pt-4">
          {/* Recipient Selection */}
          <div className="space-y-2">
            <Label>שלח אל</Label>
            <Select
              value={partyType}
              onValueChange={(value) =>
                setPartyType(value as "first" | "second" | "both")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר נמען" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="first">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} (צד א׳)
                </SelectItem>
                <SelectItem value="second">
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName} (צד ב׳)
                </SelectItem>
                <SelectItem value="both">שני הצדדים</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Type */}
          <div className="space-y-2">
            <Label>סוג ההודעה</Label>
            <Select
              value={messageType}
              onValueChange={(value) =>
                setMessageType(value as "message" | "reminder" | "update")
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="בחר סוג הודעה" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="message">
                  <div className="flex items-center">
                    <MessageCircle className="w-4 h-4 ml-2" />
                    הודעה רגילה
                  </div>
                </SelectItem>
                <SelectItem value="reminder">
                  <div className="flex items-center">
                    <AlertCircle className="w-4 h-4 ml-2" />
                    תזכורת
                  </div>
                </SelectItem>
                <SelectItem value="update">
                  <div className="flex items-center">
                    <Send className="w-4 h-4 ml-2" />
                    עדכון סטטוס
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Message Content */}
          <div className="space-y-2">
            <Label>תוכן ההודעה</Label>
            <Textarea
              value={messageContent}
              onChange={(e) => setMessageContent(e.target.value)}
              placeholder={getMessagePlaceholder()}
              className="h-36"
            />
          </div>
        </div>

        <DialogFooter className="mt-6">
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            ביטול
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={isSubmitting || !messageContent.trim()}
            className="gap-2"
          >
            <Send className="w-4 h-4" />
            {isSubmitting ? "שולח..." : "שלח הודעה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default MessageForm;
--- End of Content for MessageForm.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\CandidateSelector.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useCallback, KeyboardEvent } from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandList,
} from "@/components/ui/command";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { calculateAge } from "@/lib/utils";
import type { Candidate } from "../../new/types/candidates";

interface CandidateSelectorProps {
  value: Candidate | null;
  onChange: (candidate: Candidate | null) => void;
  otherParty?: Candidate | null;
  label: string;
  candidates: Candidate[];
  className?: string;
  fieldName: string;
  error?: string;
}

const CandidateSelector: React.FC<CandidateSelectorProps> = ({
  value,
  onChange,
  otherParty,
  label,
  candidates,
  className,
  error,
}) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [activeIndex, setActiveIndex] = useState(-1);

  const filteredCandidates = candidates.filter((candidate) => {
    if (otherParty && candidate.id === otherParty.id) return false;

    if (inputValue) {
      const searchTerm = inputValue.toLowerCase();
      return (
        candidate.firstName.toLowerCase().includes(searchTerm) ||
        candidate.lastName.toLowerCase().includes(searchTerm) ||
        candidate.profile.city?.toLowerCase().includes(searchTerm) ||
        candidate.profile.occupation?.toLowerCase().includes(searchTerm)
      );
    }
    return true;
  });

  const formatCandidateDisplay = useCallback((candidate: Candidate) => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  }, []);

  const handleSelect = useCallback(
    (candidate: Candidate) => {
      onChange(candidate);
      setOpen(false);
      setInputValue("");
      setActiveIndex(-1);
    },
    [onChange]
  );

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!open) return;

    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setActiveIndex((prev) =>
          prev < filteredCandidates.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setActiveIndex((prev) => (prev > 0 ? prev - 1 : prev));
        break;
      case "Enter":
        e.preventDefault();
        if (activeIndex >= 0 && activeIndex < filteredCandidates.length) {
          handleSelect(filteredCandidates[activeIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        setOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className={className}>
      <div className="space-y-2">
        <label className="text-sm font-medium">{label}</label>
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <div className="relative w-full">
              <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
              <Input
                value={value ? formatCandidateDisplay(value) : inputValue}
                onChange={(e) => {
                  setInputValue(e.target.value);
                  if (!open) setOpen(true);
                  setActiveIndex(-1);
                }}
                onKeyDown={handleKeyDown}
                onClick={() => !open && setOpen(true)}
                placeholder="בחר/י מועמד/ת..."
                className="pl-10 text-right cursor-pointer"
                role="combobox"
                aria-expanded={open}
                aria-controls="candidate-listbox"
                aria-activedescendant={
                  activeIndex >= 0
                    ? `candidate-${filteredCandidates[activeIndex]?.id}`
                    : undefined
                }
              />
              {error && <p className="text-sm text-red-500 mt-1">{error}</p>}
            </div>
          </PopoverTrigger>
          <PopoverContent
            className="p-0 w-[400px]"
            align="start"
            side="bottom"
            sideOffset={4}
          >
            <Command shouldFilter={false}>
              <CommandInput
                placeholder="חיפוש מועמדים..."
                value={inputValue}
                onValueChange={(value) => {
                  setInputValue(value);
                  setActiveIndex(-1);
                }}
              />
              <CommandList
                className="max-h-[300px] overflow-auto"
                id="candidate-listbox"
                role="listbox"
              >
                <CommandEmpty>לא נמצאו תוצאות</CommandEmpty>
                <CommandGroup>
                  {filteredCandidates.map((candidate, index) => (
                    <div
                      key={candidate.id}
                      onClick={() => handleSelect(candidate)}
                      className={`flex items-center gap-2 text-right p-2 hover:bg-accent/50 cursor-pointer ${
                        index === activeIndex ? "bg-accent" : ""
                      }`}
                      role="option"
                      id={`candidate-${candidate.id}`}
                      aria-selected={index === activeIndex}
                      onMouseEnter={() => setActiveIndex(index)}
                    >
                      <div className="flex-1">
                        <div className="font-medium">
                          {formatCandidateDisplay(candidate)}
                        </div>
                        <div className="text-sm text-gray-500">
                          {candidate.profile.religiousLevel} |
                          {candidate.profile.occupation &&
                            ` ${candidate.profile.occupation} |`}
                          {candidate.profile.education &&
                            ` ${candidate.profile.education}`}
                        </div>
                      </div>
                    </div>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      </div>

      {value && (
        <Card className="mt-2 p-4">
          <div className="flex justify-between items-start">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => {
                /* Add view profile handler */
              }}
              className="text-primary"
            >
              צפה בפרופיל מלא
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onChange(null)}
              className="text-destructive"
            >
              הסר בחירה
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

export default CandidateSelector;
--- End of Content for CandidateSelector.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\MatchPreview.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, AlertCircle, XCircle } from "lucide-react";
import { calculateMatchScore } from "../utils/matchingAlgorithm";
import type { Candidate } from "../../new/types/candidates";
import type { MatchScore } from "../utils/matchingAlgorithm";

interface MatchPreviewProps {
  firstParty: Candidate;
  secondParty: Candidate;
  className?: string;
}

const MatchPreview: React.FC<MatchPreviewProps> = ({
  firstParty,
  secondParty,
  className,
}) => {
  // Calculate match score using the existing algorithm
  const matchScore: MatchScore | null = calculateMatchScore(
    firstParty.profile,
    secondParty.profile
  );

  if (!matchScore) {
    return (
      <Card className={`p-4 ${className}`}>
        <div className="flex items-center gap-2 text-yellow-600">
          <AlertCircle className="w-5 h-5" />
          <span>לא ניתן לחשב התאמה - חסרים נתונים חיוניים</span>
        </div>
      </Card>
    );
  }

  // Determine match quality indicators
  const getMatchQuality = (score: number) => {
    if (score >= 85)
      return {
        icon: CheckCircle,
        color: "text-green-600",
        text: "התאמה גבוהה",
      };
    if (score >= 70)
      return { icon: CheckCircle, color: "text-blue-600", text: "התאמה טובה" };
    if (score >= 50)
      return {
        icon: AlertCircle,
        color: "text-yellow-600",
        text: "התאמה בינונית",
      };
    return { icon: XCircle, color: "text-red-600", text: "התאמה נמוכה" };
  };

  const quality = getMatchQuality(matchScore.score);
  const Icon = quality.icon;

  return (
    <Card className={`p-6 ${className}`}>
      <div className="space-y-6">
        {/* Match Score */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Icon className={`w-5 h-5 ${quality.color}`} />
            <span className="font-medium">{quality.text}</span>
          </div>
          <Badge variant="outline" className="text-lg">
            {Math.round(matchScore.score)}%
          </Badge>
        </div>

        {/* Score Bar */}
        <Progress value={matchScore.score} className="h-2" />

        {/* Match Criteria */}
        <div className="space-y-4">
          <h4 className="font-medium">קריטריונים מרכזיים:</h4>
          <div className="grid gap-3">
            {matchScore.criteria.map((criterion) => (
              <div
                key={criterion.name}
                className="flex items-center justify-between"
              >
                <span className="text-gray-600">
                  {criterion.name === "age" && "גיל"}
                  {criterion.name === "location" && "מיקום"}
                  {criterion.name === "religious" && "רמה דתית"}
                </span>
                <div className="flex items-center gap-2">
                  <Progress
                    value={criterion.score * 100}
                    className="w-24 h-1.5"
                  />
                  <span className="text-sm font-medium w-8 text-center">
                    {Math.round(criterion.score * 100)}%
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Match Reasons */}
        {matchScore.reasons.length > 0 && (
          <div className="space-y-2">
            <h4 className="font-medium">סיבות להתאמה:</h4>
            <ul className="space-y-1 text-gray-600">
              {matchScore.reasons.map((reason, index) => (
                <li key={index} className="flex items-center gap-2">
                  <span>•</span>
                  <span>{reason}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </Card>
  );
};

export default MatchPreview;
--- End of Content for MatchPreview.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\SuggestionDetails.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import React from "react";
import { useFormContext } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Priority } from "@prisma/client";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { calculateAge } from "@/lib/utils";
import type { NewSuggestionFormData } from "./schema";
import type { Candidate } from "../../new/types/candidates";

interface SuggestionDetailsProps {
  className?: string;
  firstParty: Candidate;
  secondParty: Candidate;
}

const SuggestionDetails: React.FC<SuggestionDetailsProps> = ({
  firstParty,
  secondParty,
}) => {
  const {
    register,
    formState: { errors },
    setValue,
    getValues,
  } = useFormContext<NewSuggestionFormData>();

  // Format candidate display
  const formatCandidateInfo = (candidate: Candidate): string => {
    const age = calculateAge(new Date(candidate.profile.birthDate));
    return `${candidate.firstName} ${candidate.lastName}, ${age}${
      candidate.profile.city ? `, ${candidate.profile.city}` : ""
    }`;
  };

  // Register all form fields
  React.useEffect(() => {
    // Set default values if not already set
    const currentValues = getValues();
    if (!currentValues.priority) {
      setValue("priority", Priority.MEDIUM);
    }
  }, [setValue, getValues]);

  return (
    <div className="space-y-6">
      {/* Selected Candidates Summary */}
      <Card className="bg-slate-50">
        <CardHeader className="pb-3">
          <h3 className="text-lg font-semibold">הצדדים המוצעים</h3>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד א׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(firstParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {firstParty.profile.religiousLevel} |
                {firstParty.profile.occupation &&
                  ` ${firstParty.profile.occupation} |`}
                {firstParty.profile.education &&
                  ` ${firstParty.profile.education}`}
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-primary font-medium">צד ב׳</Label>
            <div className="p-3 bg-white rounded-lg border">
              <div className="font-medium">
                {formatCandidateInfo(secondParty)}
              </div>
              <div className="text-sm text-gray-500 mt-1">
                {secondParty.profile.religiousLevel} |
                {secondParty.profile.occupation &&
                  ` ${secondParty.profile.occupation} |`}
                {secondParty.profile.education &&
                  ` ${secondParty.profile.education}`}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Priority Selection with Visual Indicators */}
      <Card>
        <CardContent className="pt-6">
          <div className="space-y-4">
            <Label className="text-lg">עדיפות ההצעה</Label>
            <Select
              onValueChange={(value: Priority) => {
                setValue("priority", value, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              value={getValues("priority") || Priority.MEDIUM}
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י עדיפות" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value={Priority.URGENT}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="destructive"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    דחופה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.HIGH}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="warning"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    גבוהה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.MEDIUM}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="default"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    רגילה
                  </div>
                </SelectItem>
                <SelectItem value={Priority.LOW}>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="secondary"
                      className="h-2 w-2 p-0 rounded-full"
                    />
                    נמוכה
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
            {errors.priority && (
              <p className="text-sm text-red-500">{errors.priority.message}</p>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Matching Details */}
      <Card>
        <CardContent className="pt-6 space-y-6">
          {/* Matching Reason */}
          <div className="space-y-3">
            <Label className="text-lg">סיבת ההתאמה</Label>
            <div className="text-sm text-gray-500 mb-2">
              פרט/י מדוע לדעתך יש התאמה בין המועמדים. מידע זה יוצג לשני הצדדים.
            </div>
            <Textarea
              {...register("matchingReason")}
              placeholder="לדוגמה: שני הצדדים מחפשים בן/בת זוג עם השקפת עולם דומה, שאיפות דומות..."
              className="min-h-[120px] resize-none"
            />
            {errors.matchingReason && (
              <p className="text-sm text-red-500">
                {errors.matchingReason.message}
              </p>
            )}
          </div>

          {/* Party-specific Notes */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-3">
              <Label className="text-lg">הערות לצד א׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{firstParty.firstName}
              </div>
              <Textarea
                {...register("firstPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.firstPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.firstPartyNotes.message}
                </p>
              )}
            </div>

            <div className="space-y-3">
              <Label className="text-lg">הערות לצד ב׳</Label>
              <div className="text-sm text-gray-500 mb-2">
                הערות אישיות שיוצגו רק ל{secondParty.firstName}
              </div>
              <Textarea
                {...register("secondPartyNotes")}
                placeholder="מידע נוסף שחשוב שידע..."
                className="min-h-[100px] resize-none"
              />
              {errors.secondPartyNotes && (
                <p className="text-sm text-red-500">
                  {errors.secondPartyNotes.message}
                </p>
              )}
            </div>
          </div>

          {/* Internal Notes */}
          <div className="space-y-3">
            <Label className="text-lg">הערות פנימיות</Label>
            <div className="text-sm text-gray-500 mb-2">
              הערות אלו יהיו גלויות רק לצוות השדכנים
            </div>
            <Textarea
              {...register("internalNotes")}
              placeholder="הערות והנחיות לשדכנים..."
              className="min-h-[100px] resize-none"
            />
            {errors.internalNotes && (
              <p className="text-sm text-red-500">
                {errors.internalNotes.message}
              </p>
            )}
          </div>

          {/* Decision Days */}
          <div className="space-y-3">
            <Label className="text-lg">זמן להחלטה</Label>
            <div className="text-sm text-gray-500 mb-2">
              תוך כמה ימים נדרשת החלטה סופית משני הצדדים
            </div>
            <Select
              onValueChange={(value) => {
                const days = parseInt(value);
                const deadline = new Date();
                deadline.setDate(deadline.getDate() + days);
                setValue("decisionDeadline", deadline, {
                  shouldValidate: true,
                  shouldDirty: true,
                  shouldTouch: true,
                });
              }}
              defaultValue="14"
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="בחר/י מספר ימים" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="2">2 ימים</SelectItem>
                <SelectItem value="3">3 ימים</SelectItem>
                <SelectItem value="5">5 ימים</SelectItem>
                <SelectItem value="7">7 ימים</SelectItem>
              </SelectContent>
            </Select>
            {errors.decisionDeadline && (
              <p className="text-sm text-red-500">
                {errors.decisionDeadline.message}
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default SuggestionDetails;
--- End of Content for SuggestionDetails.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\index.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/toast/use-toast";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import { Separator } from "@/components/ui/separator";
import { CheckCircle, UserPlus } from "lucide-react";
import { Steps } from "@/components/ui/steps";
import type { Candidate } from "../../new/types/candidates";
import { newSuggestionSchema } from "./schema";
import type { NewSuggestionFormData } from "./schema";
import SuggestionDetails from "./SuggestionDetails";
import MatchPreview from "./MatchPreview";
import CandidateSelector from "./CandidateSelector";

interface NewSuggestionFormProps {
  isOpen: boolean;
  onClose: () => void;
  candidates: Candidate[];
  selectedCandidate?: Candidate | null;
  onSubmit: (data: NewSuggestionFormData) => Promise<void>;
}

const STEPS = [
  {
    title: "בחירת מועמדים",
    description: "בחירת שני הצדדים להצעה",
    icon: UserPlus,
  },
  {
    title: "פרטי ההצעה",
    description: "הגדרת פרטי ההצעה ותזמונים",
    icon: CheckCircle,
  },
];

const NewSuggestionForm: React.FC<NewSuggestionFormProps> = ({
  isOpen,
  onClose,
  candidates,
  selectedCandidate,
  onSubmit,
}) => {
  const [step, setStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [firstParty, setFirstParty] = useState<Candidate | null>(
    selectedCandidate || null
  );
  const [secondParty, setSecondParty] = useState<Candidate | null>(null);

  const { toast } = useToast();

  const form = useForm<NewSuggestionFormData>({
    resolver: zodResolver(newSuggestionSchema),
    defaultValues: {
      priority: Priority.MEDIUM,
      status: MatchSuggestionStatus.DRAFT,
      firstPartyId: selectedCandidate?.id || "",
      secondPartyId: "",
    },
  });

  // Debug logging for form state changes
  useEffect(() => {
    const subscription = form.watch((value, { name, type }) => {
      console.log("Form value changed:", {
        name,
        value,
        type,
        allValues: form.getValues(),
        formState: form.formState,
      });
    });

    return () => subscription.unsubscribe();
  }, [form]);

  // Handle candidate selection
  const handleCandidateSelect =
    (type: "first" | "second") => (candidate: Candidate | null) => {
      console.log(`${type} party selection:`, { candidate });

      if (type === "first") {
        setFirstParty(candidate);
        if (candidate) {
          form.setValue("firstPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("firstPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      } else {
        setSecondParty(candidate);
        if (candidate) {
          form.setValue("secondPartyId", candidate.id, {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        } else {
          form.setValue("secondPartyId", "", {
            shouldValidate: true,
            shouldDirty: true,
            shouldTouch: true,
          });
        }
      }

      // Log form state after update
      console.log("Form state after selection:", {
        values: form.getValues(),
        errors: form.formState.errors,
        isDirty: form.formState.isDirty,
        isValid: form.formState.isValid,
      });
    };

  const handleSubmit = async (data: NewSuggestionFormData) => {
    console.log("Submit attempt:", {
      formData: data,
      formState: form.formState,
      firstParty,
      secondParty,
    });

    if (!firstParty || !secondParty) {
      console.log("Missing parties:", { firstParty, secondParty });
      return;
    }

    try {
      setIsSubmitting(true);
      console.log("=== Before API call ===");
      await onSubmit(data);
      console.log("=== After successful API call ===");
      toast({
        title: "ההצעה נוצרה בהצלחה",
        description: "ההצעה נשמרה במערכת והועברה לטיפול",
      });
      onClose();
    } catch (error) {
      console.log("=== API call failed ===", error);
      console.error("Submission error:", error);
      toast({
        title: "שגיאה",
        description: "אירעה שגיאה בעת יצירת ההצעה",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle form validation before moving to next step
  const handleNextStep = () => {
    form.trigger(["firstPartyId", "secondPartyId"]).then((isValid) => {
      if (isValid) {
        setStep(2);
      } else {
        console.log("Validation failed:", form.formState.errors);
      }
    });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto p-0">
        <DialogHeader className="px-8 pt-6 pb-2">
          <DialogTitle className="text-2xl">יצירת הצעת שידוך חדשה</DialogTitle>
          <DialogDescription>
            יצירת הצעת שידוך בין שני מועמדים והגדרת פרטי ההצעה
          </DialogDescription>
        </DialogHeader>

        {/* Steps Indicator */}
        <div className="px-8 py-4">
          <Steps steps={STEPS} currentStep={step} />
        </div>

        <Separator />

        <FormProvider {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="p-8 pt-6">
            {/* Step 1: Candidate Selection */}
            <div className={step !== 1 ? "hidden" : "space-y-8"}>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <CandidateSelector
                  label="צד א׳"
                  value={firstParty}
                  onChange={handleCandidateSelect("first")}
                  candidates={candidates}
                  otherParty={secondParty}
                  fieldName="firstPartyId"
                  error={form.formState.errors.firstPartyId?.message}
                />

                <CandidateSelector
                  label="צד ב׳"
                  value={secondParty}
                  onChange={handleCandidateSelect("second")}
                  candidates={candidates}
                  otherParty={firstParty}
                  fieldName="secondPartyId"
                  error={form.formState.errors.secondPartyId?.message}
                />
              </div>

              {firstParty && secondParty && (
                <div className="rounded-lg border bg-card">
                  <div className="px-6 py-4 border-b">
                    <h3 className="text-lg font-semibold">
                      התאמה בין המועמדים
                    </h3>
                  </div>
                  <div className="p-6">
                    <MatchPreview
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  </div>
                </div>
              )}

              <div className="flex justify-end mt-8">
                <Button
                  type="button"
                  size="lg"
                  onClick={handleNextStep}
                  disabled={!firstParty || !secondParty}
                >
                  המשך להגדרת פרטי ההצעה
                </Button>
              </div>
            </div>

            {/* Step 2: Suggestion Details */}
            <div className={step !== 2 ? "hidden" : "space-y-8"}>
              <div className="rounded-lg border bg-card">
                <div className="px-6 py-4 border-b">
                  <h3 className="text-lg font-semibold">פרטי ההצעה</h3>
                </div>
                <div className="p-6">
                  {firstParty && secondParty ? (
                    <SuggestionDetails
                      firstParty={firstParty}
                      secondParty={secondParty}
                    />
                  ) : (
                    <div className="text-center py-4 text-gray-500">
                      יש לבחור את שני הצדדים בשלב הראשון
                    </div>
                  )}
                </div>
              </div>

              <div className="flex justify-between mt-8">
                <Button
                  type="button"
                  variant="outline"
                  size="lg"
                  onClick={() => setStep(1)}
                >
                  חזרה לבחירת מועמדים
                </Button>

                <Button
                  type="submit"
                  size="lg"
                  disabled={isSubmitting || !form.formState.isValid}
                >
                  {isSubmitting ? "שומר הצעה..." : "שמור הצעה"}
                </Button>
              </div>
            </div>
          </form>
        </FormProvider>
      </DialogContent>
    </Dialog>
  );
};

export default NewSuggestionForm;
--- End of Content for index.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\NewSuggestionForm\schema.ts
--------------------------------------------------------------------------------
Content:
import { z } from "zod";
import { addDays, isBefore } from 'date-fns';

// Validation rules

const MIN_DECISION_DAYS = 1;
const MAX_DECISION_DAYS = 30;

// Helper function to validate dates
const isValidDeadlineDate = (date: Date | null | undefined, minDays: number, maxDays: number) => {
  if (!date) return false;
  
  const today = new Date();
  const minDate = addDays(today, minDays);
  const maxDate = addDays(today, maxDays);
  
  return !isBefore(date, minDate) && !isBefore(maxDate, date);
};

// Schema for new suggestion
export const newSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "יש לבחור מועמד/ת ראשון/ה",
  }),
  
  secondPartyId: z.string({
    required_error: "יש לבחור מועמד/ת שני/ה",
  }),
  
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const, {
    required_error: "יש לבחור רמת עדיפות",
  }),

  status: z.enum([
    'DRAFT',
    'PENDING_FIRST_PARTY',
    'FIRST_PARTY_APPROVED',
    'FIRST_PARTY_DECLINED',
    'PENDING_SECOND_PARTY',
    'SECOND_PARTY_APPROVED',
    'SECOND_PARTY_DECLINED',
    'AWAITING_MATCHMAKER_APPROVAL',
    'CONTACT_DETAILS_SHARED',
    'AWAITING_FIRST_DATE_FEEDBACK',
    'THINKING_AFTER_DATE',
    'PROCEEDING_TO_SECOND_DATE',
    'ENDED_AFTER_FIRST_DATE',
    'MEETING_PENDING',
    'MEETING_SCHEDULED',
    'MATCH_APPROVED',
    'MATCH_DECLINED',
    'DATING',
    'ENGAGED',
    'MARRIED',
    'EXPIRED',
    'CLOSED',
    'CANCELLED'
  ] as const, {
    required_error: "יש לבחור סטטוס",
  }).default('DRAFT'),

  matchingReason: z.string()
    .max(500, "סיבת ההתאמה לא יכולה להכיל יותר מ-500 תווים")
    .optional(),

  internalNotes: z.string()
    .max(1000, "ההערות הפנימיות לא יכולות להכיל יותר מ-1000 תווים")
    .optional(),

  firstPartyNotes: z.string()
    .max(500, "ההערות לצד א' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),

  secondPartyNotes: z.string()
    .max(500, "ההערות לצד ב' לא יכולות להכיל יותר מ-500 תווים")
    .optional(),


  decisionDeadline: z.date({
    required_error: "יש לבחור תאריך יעד להחלטה ",
  })
}).refine(
  (data) => data.firstPartyId !== data.secondPartyId,
  {
    message: "לא ניתן ליצור הצעה עבור אותו מועמד",
    path: ["secondPartyId"]
  }

).refine(
  (data) => isValidDeadlineDate(data.decisionDeadline, MIN_DECISION_DAYS, MAX_DECISION_DAYS),
  {
    message: `תאריך היעד להחלטה סופית חייב להיות בין ${MIN_DECISION_DAYS} ל-${MAX_DECISION_DAYS} ימים מהיום`,
    path: ["decisionDeadline"]
  }
);

export type NewSuggestionFormData = z.infer<typeof newSuggestionSchema>;

// Status mapping for display
export const suggestionStatusMap = {
  DRAFT: "טיוטה",
  PENDING_FIRST_PARTY: "ממתין לתשובת צד א'",
  FIRST_PARTY_APPROVED: "צד א' אישר",
  FIRST_PARTY_DECLINED: "צד א' דחה",
  PENDING_SECOND_PARTY: "ממתין לתשובת צד ב'",
  SECOND_PARTY_APPROVED: "צד ב' אישר",
  SECOND_PARTY_DECLINED: "צד ב' דחה",
  AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
  CONTACT_DETAILS_SHARED: "פרטי קשר הועברו",
  AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
  THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
  PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שנייה",
  ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
  MEETING_PENDING: "ממתין לקביעת פגישה",
  MEETING_SCHEDULED: "פגישה נקבעה",
  MATCH_APPROVED: "ההצעה אושרה",
  MATCH_DECLINED: "ההצעה נדחתה",
  DATING: "בתהליך היכרות",
  ENGAGED: "מאורסים",
  MARRIED: "נישאו",
  EXPIRED: "פג תוקף",
  CLOSED: "ההצעה נסגרה",
  CANCELLED: "ההצעה בוטלה"
} as const;

// Priority mapping for display
export const priorityMap = {
  LOW: { label: "נמוכה", color: "text-gray-500" },
  MEDIUM: { label: "רגילה", color: "text-blue-500" },
  HIGH: { label: "גבוהה", color: "text-yellow-500" },
  URGENT: { label: "דחופה", color: "text-red-500" }
} as const;
--- End of Content for schema.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\cards\SuggestionCard.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import Image from "next/image";
import {
  Clock,
  User,
  MessageCircle,
  Eye,
  AlertCircle,
  MoreHorizontal,
  Send,
  RefreshCw,
  Trash2,
  Edit,
  CheckCircle,
  XCircle,
  CalendarClock,
  Heart,
  MapPin,
  Calendar,
  Star,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestionStatus, Priority } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import { Progress } from "@/components/ui/progress";

interface SuggestionCardProps {
  suggestion: Suggestion;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const getStatusInfo = (status: MatchSuggestionStatus) => {
  switch (status) {
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לתשובת צד א׳",
        className: "bg-yellow-100 text-yellow-800 border-yellow-200",
        color: "text-yellow-600",
        bgColor: "bg-yellow-50",
        icon: Clock,
        progress: 25,
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לתשובת צד ב׳",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        color: "text-blue-600",
        bgColor: "bg-blue-50",
        icon: Clock,
        progress: 50,
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "צד א׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 40,
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "צד ב׳ אישר",
        className: "bg-green-100 text-green-800 border-green-200",
        color: "text-green-600",
        bgColor: "bg-green-50",
        icon: CheckCircle,
        progress: 60,
      };
    case "FIRST_PARTY_DECLINED":
      return {
        label: "צד א׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "SECOND_PARTY_DECLINED":
      return {
        label: "צד ב׳ דחה",
        className: "bg-red-100 text-red-800 border-red-200",
        color: "text-red-600",
        bgColor: "bg-red-50",
        icon: XCircle,
        progress: 100,
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        className: "bg-purple-100 text-purple-800 border-purple-200",
        color: "text-purple-600",
        bgColor: "bg-purple-50",
        icon: Send,
        progress: 70,
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        className: "bg-pink-100 text-pink-800 border-pink-200",
        color: "text-pink-600",
        bgColor: "bg-pink-50",
        icon: Heart,
        progress: 80,
      };
    case "AWAITING_FIRST_DATE_FEEDBACK":
      return {
        label: "ממתין למשוב פגישה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        color: "text-orange-600",
        bgColor: "bg-orange-50",
        icon: AlertCircle,
        progress: 75,
      };
    case "EXPIRED":
      return {
        label: "פג תוקף",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: Clock,
        progress: 100,
      };
    default:
      return {
        label: "בטיפול",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        color: "text-gray-600",
        bgColor: "bg-gray-50",
        icon: RefreshCw,
        progress: 30,
      };
  }
};

const getPriorityInfo = (priority: Priority) => {
  switch (priority) {
    case "URGENT":
      return {
        label: "דחוף",
        className: "bg-red-100 text-red-800 border-red-200",
        icon: AlertCircle,
        color: "text-red-600",
      };
    case "HIGH":
      return {
        label: "גבוה",
        className: "bg-orange-100 text-orange-800 border-orange-200",
        icon: Star,
        color: "text-orange-600",
      };
    case "MEDIUM":
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
    case "LOW":
      return {
        label: "נמוך",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: Star,
        color: "text-gray-600",
      };
    default:
      return {
        label: "רגיל",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: Star,
        color: "text-blue-600",
      };
  }
};

// Days left until deadline if applicable
const getDaysLeft = (decisionDeadline?: Date | string | null) => {
  if (!decisionDeadline) return null;

  const deadline = new Date(decisionDeadline);
  const today = new Date();
  const diffTime = deadline.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? diffDays : 0;
};

const SuggestionCard: React.FC<SuggestionCardProps> = ({
  suggestion,
  onAction,
  className,
}) => {
  const { firstParty, secondParty } = suggestion;
  const statusInfo = getStatusInfo(suggestion.status);
  const priorityInfo = getPriorityInfo(suggestion.priority);
  const StatusIcon = statusInfo.icon;
  const PriorityIcon = priorityInfo.icon;
  const daysLeft = getDaysLeft(suggestion.decisionDeadline);

  // Check if the suggestion is waiting for response
  const isWaitingForResponse =
    suggestion.status === "PENDING_FIRST_PARTY" ||
    suggestion.status === "PENDING_SECOND_PARTY";

  // Check if the suggestion has feedback requirement
  const needsFeedback = suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK";

  // Check if the suggestion can be resent
  const canBeResent =
    suggestion.status === "EXPIRED" ||
    suggestion.status === "FIRST_PARTY_DECLINED" ||
    suggestion.status === "SECOND_PARTY_DECLINED";

  const firstPartyAge = calculateAge(firstParty.profile.birthDate);
  const secondPartyAge = calculateAge(secondParty.profile.birthDate);

  const firstPartyMainImage = firstParty.images.find((img) => img.isMain);
  const secondPartyMainImage = secondParty.images.find((img) => img.isMain);

  return (
    <Card
      className={`${className} overflow-hidden hover:shadow-md transition-shadow`}
    >
      {/* Header with status and progress */}
      <div className={`p-4 ${statusInfo.bgColor} border-b relative`}>
        <div className="flex justify-between items-center mb-2">
          <div className="flex items-center gap-2">
            <StatusIcon className={`w-5 h-5 ${statusInfo.color}`} />
            <span className="font-medium text-gray-900">
              {statusInfo.label}
            </span>
          </div>
          <Badge className={priorityInfo.className}>
            <PriorityIcon className="w-3 h-3 ml-1" />
            {priorityInfo.label}
          </Badge>
        </div>

        <Progress value={statusInfo.progress} className="h-1.5" />

        {/* Deadline warning if needed */}
        {daysLeft !== null &&
          daysLeft <= 3 &&
          suggestion.status !== "EXPIRED" && (
            <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 bg-red-500 text-white text-xs font-bold py-0.5 px-2 rounded-full whitespace-nowrap z-10">
              <Clock className="w-3 h-3 inline-block ml-1" />
              {daysLeft === 0 ? "היום אחרון!" : `${daysLeft} ימים נותרו`}
            </div>
          )}
      </div>

      {/* Main content */}
      <div className="p-4">
        {/* Parties info */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          {/* First party */}
          <div className="space-y-2 border-l pl-4 order-1">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-blue-50">
                צד א׳
              </Badge>
              {suggestion.status === "FIRST_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "FIRST_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {firstPartyMainImage ? (
                  <Image
                    src={firstPartyMainImage.url}
                    alt={`${firstParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {firstParty.firstName} {firstParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{firstPartyAge} שנים</span>
                  </div>
                  {firstParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{firstParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Second party */}
          <div className="space-y-2 order-0">
            <div className="flex items-center justify-between">
              <Badge variant="outline" className="bg-purple-50">
                צד ב׳
              </Badge>
              {suggestion.status === "SECOND_PARTY_APPROVED" && (
                <Badge className="bg-green-100 text-green-800">
                  <CheckCircle className="w-3 h-3 ml-1" />
                  אישר
                </Badge>
              )}
              {suggestion.status === "SECOND_PARTY_DECLINED" && (
                <Badge className="bg-red-100 text-red-800">
                  <XCircle className="w-3 h-3 ml-1" />
                  דחה
                </Badge>
              )}
            </div>

            <div className="flex gap-3">
              <div className="relative h-16 w-16 rounded-full overflow-hidden bg-gray-100 border">
                {secondPartyMainImage ? (
                  <Image
                    src={secondPartyMainImage.url}
                    alt={`${secondParty.firstName}`}
                    className="object-cover"
                    fill
                    sizes="4rem"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <User className="w-8 h-8 text-gray-400" />
                  </div>
                )}
              </div>
              <div>
                <h4 className="font-semibold">
                  {secondParty.firstName} {secondParty.lastName}
                </h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <div className="flex items-center">
                    <Calendar className="w-3 h-3 ml-1 text-gray-400" />
                    <span>{secondPartyAge} שנים</span>
                  </div>
                  {secondParty.profile.city && (
                    <div className="flex items-center">
                      <MapPin className="w-3 h-3 ml-1 text-gray-400" />
                      <span>{secondParty.profile.city}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Matching reason snippet */}
        {suggestion.matchingReason && (
          <div className="mb-4 p-3 bg-gray-50 rounded-lg border text-sm">
            <h5 className="text-xs font-semibold text-gray-600 mb-1">
              סיבת ההתאמה:
            </h5>
            <p className="text-gray-800 line-clamp-2">
              {suggestion.matchingReason.length > 120
                ? `${suggestion.matchingReason.substring(0, 120)}...`
                : suggestion.matchingReason}
            </p>
          </div>
        )}

        {/* Info and time */}
        <div className="flex justify-between text-xs text-gray-500 mb-4">
          <div className="flex items-center">
            <Clock className="w-3.5 h-3.5 ml-1" />
            {formatDistanceToNow(new Date(suggestion.createdAt), {
              addSuffix: true,
              locale: he,
            })}
          </div>

          {suggestion.decisionDeadline && (
            <div className="flex items-center">
              <CalendarClock className="w-3.5 h-3.5 ml-1" />
              {daysLeft !== null
                ? daysLeft === 0
                  ? "היום!"
                  : `${daysLeft} ימים להחלטה`
                : "אין מועד אחרון"}
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="flex items-center justify-between pt-2 border-t">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onAction("message", suggestion)}
            className="text-gray-600 hover:text-primary"
          >
            <MessageCircle className="w-4 h-4 ml-1" />
            הודעה
          </Button>

          {/* סקציית פעולות בקובץ SuggestionCard.tsx */}
          {isWaitingForResponse && (
            <Button
              variant="outline"
              size="sm"
              className="text-yellow-600"
              onClick={() =>
                onAction("reminder", suggestion, {
                  partyType:
                    suggestion.status === "PENDING_FIRST_PARTY"
                      ? "first"
                      : "second",
                })
              }
            >
              <Send className="w-4 h-4 ml-1" />
              {suggestion.status === "PENDING_FIRST_PARTY"
                ? "שלח תזכורת לצד ראשון"
                : suggestion.status === "PENDING_SECOND_PARTY"
                ? "שלח תזכורת לצד שני"
                : suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK"
                ? "שלח בקשת עדכון מפגש"
                : "שלח תזכורת"}
            </Button>
          )}

          {needsFeedback && (
            <Button
              variant="outline"
              size="sm"
              className="text-blue-600"
              onClick={() =>
                onAction("contact", suggestion, { type: "feedback" })
              }
            >
              <MessageCircle className="w-4 h-4 ml-1" />
              בקש משוב
            </Button>
          )}

          <div className="flex items-center gap-1">
            {canBeResent && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAction("resend", suggestion)}
                className="px-2"
              >
                <RefreshCw className="w-4 h-4" />
              </Button>
            )}

            <Button
              variant="outline"
              size="sm"
              onClick={() => onAction("edit", suggestion)}
              className="px-2"
            >
              <Edit className="w-4 h-4" />
            </Button>

            <Button
              variant="default"
              size="sm"
              onClick={() => onAction("view", suggestion)}
            >
              <Eye className="w-4 h-4 ml-1" />
              פרטים
            </Button>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button size="sm" variant="ghost" className="px-1">
                  <MoreHorizontal className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => onAction("edit", suggestion)}>
                  <Edit className="w-4 h-4 ml-2" />
                  <span>ערוך הצעה</span>
                </DropdownMenuItem>

                {canBeResent && (
                  <DropdownMenuItem
                    onClick={() => onAction("resend", suggestion)}
                  >
                    <RefreshCw className="w-4 h-4 ml-2" />
                    <span>שלח מחדש</span>
                  </DropdownMenuItem>
                )}

                <DropdownMenuItem
                  onClick={() => onAction("delete", suggestion)}
                  className="text-red-600"
                >
                  <Trash2 className="w-4 h-4 ml-2" />
                  <span>מחק הצעה</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </Card>
  );
};

export default SuggestionCard;
--- End of Content for SuggestionCard.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MatchmakerDashboard.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useCallback, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Plus, Download, RefreshCw, BarChart } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import type {
  Suggestion,
  SuggestionFilters,
  ActionAdditionalData,
} from "@/types/suggestions";
import type { NewSuggestionFormData } from "../../suggestions/NewSuggestionForm/schema";
import { MatchSuggestionStatus, Priority } from "@prisma/client";
import NewSuggestionForm from "../../suggestions/NewSuggestionForm";
import SuggestionsStats from "./SuggestionsStats";
import SuggestionActionBar from "./SuggestionActionBar";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import SuggestionCard from "../cards/SuggestionCard";
import { toast } from "sonner";
import EditSuggestionForm from "../EditSuggestionForm";
import MessageForm from "../MessageForm";
import MonthlyTrendModal from "./MonthlyTrendModal";
type DialogActionData = {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyType?: "first" | "second" | "both";
  type?: string;
};
type ConfirmActionData = {
  suggestionId: string;
  partyType?: "first" | "second" | "both";
  type?: string;
};

export default function MatchmakerDashboard() {
  // State management
  const [activeTab, setActiveTab] = useState("pending"); // Changed default tab to "pending"
  const [showNewSuggestion, setShowNewSuggestion] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<SuggestionFilters>({});
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmAction, setConfirmAction] = useState<{
    type: string;
    data: ConfirmActionData;
  } | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [showEditForm, setShowEditForm] = useState(false);
  const [showMessageForm, setShowMessageForm] = useState(false);
  const [, setMessageRecipient] = useState<"first" | "second" | "both">("both");
  const [showMonthlyTrendDialog, setShowMonthlyTrendDialog] = useState(false);

  // Calculate suggestion counts
  const activeCount = suggestions.filter((s) => s.category === "ACTIVE").length;
  const pendingCount = suggestions.filter(
    (s) => s.category === "PENDING"
  ).length;
  const historyCount = suggestions.filter(
    (s) => s.category === "HISTORY"
  ).length;

  // Fetch suggestions data
  const fetchSuggestions = async () => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/matchmaker/suggestions");
      if (!response.ok) {
        throw new Error("Failed to fetch suggestions");
      }

      const data = await response.json();
      setSuggestions(data);

      // Log suggestions data for debugging
      console.log("Fetched suggestions:", data);
      console.log("Total suggestions count:", data.length);

      // Log suggestions by status
      const activeCount = data.filter(
        (s: Suggestion) => s.category === "ACTIVE"
      ).length;
      const pendingCount = data.filter(
        (s: Suggestion) => s.category === "PENDING"
      ).length;
      const historyCount = data.filter(
        (s: Suggestion) => s.category === "HISTORY"
      ).length;
      console.log("Suggestions by status:", {
        active: activeCount,
        pending: pendingCount,
        history: historyCount,
      });
    } catch (error) {
      console.error("Error fetching suggestions:", error);
      toast.error("שגיאה בטעינת ההצעות");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (confirmAction?.type === "delete" && !showConfirmDialog) {
      // בדיקה אם דיאלוג האישור נסגר אחרי פעולת מחיקה - ריענון הנתונים
      fetchSuggestions();
    }
  }, [showConfirmDialog, confirmAction]);
  // Initial data fetch
  useEffect(() => {
    fetchSuggestions();
  }, []);

  // Handle refresh button
  const handleRefresh = async () => {
    setIsRefreshing(true);
    await fetchSuggestions();
    setIsRefreshing(false);
    toast.success("נתוני ההצעות עודכנו");
  };

  // Handle new suggestion creation
  const handleNewSuggestion = async (data: NewSuggestionFormData) => {
    try {
      const response = await fetch("/api/suggestions", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!response.ok) throw new Error("Failed to create suggestion");

      setShowNewSuggestion(false);
      toast.success("ההצעה נוצרה בהצלחה");
      await fetchSuggestions();
    } catch (error) {
      console.error("Error creating suggestion:", error);
      toast.error("שגיאה ביצירת ההצעה");
    }
  };

  // Handle suggestion deletion
  const handleSuggestionDeleted = useCallback(
    (deletedId: string) => {
      // הסרת ההצעה מהמצב המקומי
      setSuggestions((prevSuggestions) =>
        prevSuggestions.filter((suggestion) => suggestion.id !== deletedId)
      );

      // סגירת כל חלונות המודאל הפתוחים במידת הצורך
      if (selectedSuggestion?.id === deletedId) {
        setSelectedSuggestion(null);
      }
      if (showEditForm && selectedSuggestion?.id === deletedId) {
        setShowEditForm(false);
      }
      if (showMessageForm && selectedSuggestion?.id === deletedId) {
        setShowMessageForm(false);
      }

      // הוספת הודעת הצלחה (אופציונלי - כבר נוסף בhandleConfirmAction)
      // toast.success("ההצעה נמחקה בהצלחה");
    },
    [selectedSuggestion, showEditForm, showMessageForm]
  );

  // Export suggestions to CSV
  const handleExport = async () => {
    try {
      const response = await fetch("/api/suggestions/export", {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        throw new Error("Failed to export suggestions");
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `suggestions-export-${new Date().toISOString()}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      toast.success("הקובץ הורד בהצלחה");
    } catch (error) {
      console.error("Error exporting suggestions:", error);
      toast.error("שגיאה בייצוא ההצעות");
    }
  };

  // Handle suggestion actions
  const handleSuggestionAction = (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => {
    console.log(
      `Action ${type} for suggestion ${suggestion.id}`,
      additionalData
    );

    switch (type) {
      case "view":
        setSelectedSuggestion(suggestion);
        break;
      case "delete":
        // הגדר את מידע הפעולה
        setConfirmAction({
          type: "delete",
          data: { suggestionId: suggestion.id },
        });

        // הצג את הדיאלוג
        setShowConfirmDialog(true);
        break;
      case "contact":
        // Show reminder sending confirmation
        setConfirmAction({
          type: "contact",
          data: {
            suggestionId: suggestion.id,
            partyType:
              suggestion.status === "PENDING_FIRST_PARTY" ? "first" : "second",
          },
        });
        setShowConfirmDialog(true);
        break;
      case "reminder":
        // Handle reminder action
        setConfirmAction({
          type: "contact", // או "reminder" אם יש טיפול שונה
          data: {
            suggestionId: suggestion.id,
            partyType: additionalData?.partyType || "both",
          },
        });
        setShowConfirmDialog(true);
        break;
      case "edit":
        // לפתיחת חלון עריכה
        setSelectedSuggestion(suggestion);
        setShowEditForm(true);
        break;
      case "message":
        // לפתיחת חלון הודעה
        setSelectedSuggestion(suggestion);
        setShowMessageForm(true);
        break;
      case "resend":
        // Show resend confirmation
        setConfirmAction({
          type: "resend",
          data: { suggestionId: suggestion.id },
        });
        setShowConfirmDialog(true);
        break;
      case "changeStatus":
        if (additionalData?.newStatus) {
          handleStatusChange(
            suggestion.id,
            additionalData.newStatus,
            additionalData?.notes
          );
        } else {
          console.error("Status change requested without providing new status");
          toast.error("שגיאה: סטטוס חדש לא סופק");
        }
        break;
    }
  };
  const getCategoryFromStatus = (
    status: MatchSuggestionStatus
  ): "ACTIVE" | "PENDING" | "HISTORY" => {
    switch (status) {
      case "DRAFT":
      case "AWAITING_MATCHMAKER_APPROVAL":
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return "PENDING";

      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
      case "MATCH_DECLINED":
      case "ENDED_AFTER_FIRST_DATE":
      case "ENGAGED":
      case "MARRIED":
      case "EXPIRED":
      case "CLOSED":
      case "CANCELLED":
        return "HISTORY";

      default:
        return "ACTIVE";
    }
  };
  // Handle status change
  const handleStatusChange = async (
    suggestionId: string,
    newStatus: MatchSuggestionStatus,
    notes?: string
  ) => {
    try {
      console.log(
        `Updating status for ${suggestionId} to ${newStatus}`,
        notes ? `with notes: ${notes}` : ""
      );

      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/status`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            status: newStatus,
            notes: notes || `סטטוס שונה מממשק ניהול הצעות`,
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Status update API error:", errorData);
        throw new Error(
          errorData.error ||
            `Failed to update status: ${response.status} ${response.statusText}`
        );
      }

      const data = await response.json();
      console.log("Status update success:", data);

      toast.success("סטטוס ההצעה עודכן בהצלחה");

      // עדכון רשימת ההצעות ללא צורך בטעינה מחדש
      setSuggestions((prevSuggestions) =>
        prevSuggestions.map((suggestion) =>
          suggestion.id === suggestionId
            ? {
                ...suggestion,
                status: newStatus,
                // עדכון קטגוריית ההצעה בהתאם לסטטוס החדש
                category: getCategoryFromStatus(newStatus),
                lastActivity: new Date().toISOString(),
                lastStatusChange: new Date().toISOString(),
                previousStatus: suggestion.status,
              }
            : suggestion
        )
      );
    } catch (error) {
      console.error("Error updating suggestion status:", error);
      toast.error(
        `שגיאה בעדכון סטטוס ההצעה: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Handle dialog actions
  const handleDialogAction = (action: string, data?: DialogActionData) => {
    console.log(`Dialog action: ${action}`, data);

    switch (action) {
      case "changeStatus":
        if (data?.suggestionId && data?.newStatus) {
          handleStatusChange(data.suggestionId, data.newStatus, data?.notes);
        }
        setSelectedSuggestion(null);
        break;
      case "delete":
        setConfirmAction({
          type: "delete",
          data: { suggestionId: data?.suggestionId as string },
        });
        setShowConfirmDialog(true);
        setSelectedSuggestion(null);
        break;
      case "message":
        // פתיחת טופס שליחת הודעה
        if (data?.suggestion) {
          setSelectedSuggestion(data.suggestion);
          setShowMessageForm(true);
          setMessageRecipient(data.partyType || "both");
        }
        break;
      case "edit":
        // פתיחת טופס עריכה
        if (data?.suggestion) {
          setSelectedSuggestion(data.suggestion);
          setShowEditForm(true);
        } else if (data?.suggestionId) {
          // מצב שבו יש רק מזהה הצעה
          const suggestion = suggestions.find(
            (s) => s.id === data.suggestionId
          );
          if (suggestion) {
            setSelectedSuggestion(suggestion);
            setShowEditForm(true);
          }
        }
        break;
      case "contact":
      case "reminder":
        if (data?.partyType && data?.suggestionId) {
          sendReminder(data.suggestionId, data.partyType);
        }
        break;
      case "sendReminder":
        if (data?.suggestionId && data?.type) {
          sendReminder(
            data.suggestionId,
            data.type as "first" | "second" | "both"
          );
        }
        break;
      case "resendToAll":
        if (data?.suggestionId) {
          resendSuggestion(data.suggestionId, "both");
        }
        break;
      case "export":
      case "exportHistory":
        toast.info("פונקציונליות ייצוא בפיתוח");
        break;
      case "scheduleMeeting":
        toast.info("פונקציונליות תיאום פגישה בפיתוח");
        break;
      case "shareContacts":
        if (data?.suggestionId) {
          setConfirmAction({
            type: "shareContacts",
            data: { suggestionId: data.suggestionId },
          });
          setShowConfirmDialog(true);
        }
        break;
    }
  };
  const handleUpdateSuggestion = async (data: {
    suggestionId: string;
    updates: {
      priority?: Priority;
      matchingReason?: string;
      firstPartyNotes?: string;
      secondPartyNotes?: string;
      internalNotes?: string;
      decisionDeadline?: Date;
    };
  }) => {
    try {
      const response = await fetch(`/api/suggestions/${data.suggestionId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data.updates),
      });

      if (!response.ok) throw new Error("Failed to update suggestion");

      toast.success("פרטי ההצעה עודכנו בהצלחה");

      // Update suggestions list without refetching
      setSuggestions((prevSuggestions) =>
        prevSuggestions.map((s) =>
          s.id === data.suggestionId ? { ...s, ...data.updates } : s
        )
      );

      setShowEditForm(false);
    } catch (error) {
      console.error("Error updating suggestion:", error);
      toast.error("שגיאה בעדכון פרטי ההצעה");
    }
  };

  // Handle sending message
  const handleSendMessage = async (data: {
    suggestionId: string;
    partyType: "first" | "second" | "both";
    messageType: "message" | "reminder" | "update";
    messageContent: string;
  }) => {
    try {
      // שימוש בנתיב API הנכון
      const response = await fetch(
        `/api/matchmaker/suggestions/${data.suggestionId}/message`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            partyType: data.partyType,
            messageType: data.messageType,
            content: data.messageContent,
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send message");
      }

      toast.success("ההודעה נשלחה בהצלחה");
      setShowMessageForm(false);
      fetchSuggestions(); // רענון נתונים לאחר שליחת הודעה
    } catch (error) {
      console.error("Error sending message:", error);
      toast.error(
        `שגיאה בשליחת ההודעה: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Send reminder function
  const sendReminder = async (
    suggestionId: string,
    partyType: "first" | "second" | "both" = "both" // Default value
  ) => {
    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/remind`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ partyType }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to send reminder");
      }

      toast.success(
        `תזכורת נשלחה ${
          partyType === "first"
            ? "לצד א'"
            : partyType === "second"
            ? "לצד ב'"
            : "לשני הצדדים"
        }`
      );
    } catch (error) {
      console.error("Error sending reminder:", error);
      toast.error(
        `שגיאה בשליחת התזכורת: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  };

  // Resend suggestion function
  const resendSuggestion = async (
    suggestionId: string,
    partyType: "first" | "second" | "both"
  ) => {
    try {
      const response = await fetch(`/api/suggestions/${suggestionId}/resend`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ partyType }),
      });

      if (!response.ok) throw new Error("Failed to resend suggestion");

      toast.success(
        `ההצעה נשלחה מחדש ${
          partyType === "first"
            ? "לצד א'"
            : partyType === "second"
            ? "לצד ב'"
            : "לשני הצדדים"
        }`
      );
      fetchSuggestions();
    } catch (error) {
      console.error("Error resending suggestion:", error);
      toast.error("שגיאה בשליחת ההצעה מחדש");
    }
  };

  // Share contact details function
  /*   const shareContactDetails = async (suggestionId: string) => {
    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionId}/share-contact`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to share contact details");
      }

      toast.success("פרטי הקשר שותפו בהצלחה בין שני הצדדים");
      fetchSuggestions(); // רענון הנתונים לאחר שיתוף פרטי קשר
    } catch (error) {
      console.error("Error sharing contact details:", error);
      toast.error(
        `שגיאה בשיתוף פרטי הקשר: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    }
  }; */

  // Handle confirm dialog actions

  const handleConfirmAction = async () => {
    if (!confirmAction) return;

    try {
      switch (confirmAction.type) {
        case "delete":
          // קריאה לשרת
          const deleteResponse = await fetch(
            `/api/matchmaker/suggestions/${confirmAction.data.suggestionId}/delete`,
            {
              method: "DELETE",
            }
          );

          // בדיקת תשובה
          if (!deleteResponse.ok) {
            // טיפול בשגיאה
          }

          // עדכון UI
          handleSuggestionDeleted(confirmAction.data.suggestionId);
          toast.success("ההצעה נמחקה בהצלחה");
          break;
      }
    } catch (error) {
      // טיפול בשגיאות
      console.error("שגיאה בתהליך המחיקה:", error);
      toast.error("אירעה שגיאה בעת מחיקת ההצעה");
    } finally {
      setShowConfirmDialog(false);
      setConfirmAction(null);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6 rtl matchmaker-dashboard">
      <div className="container mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4 justify-end">
            <Badge variant="outline" className="text-sm">
              {suggestions.length} הצעות
            </Badge>
            <h1 className="text-2xl font-bold">ניהול הצעות שידוכים</h1>
          </div>

          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={isRefreshing}
            >
              <RefreshCw
                className={`w-4 h-4 mr-2 ${isRefreshing ? "animate-spin" : ""}`}
              />
              {isRefreshing ? "מעדכן..." : "רענן נתונים"}
            </Button>

            <Button variant="outline" size="sm" onClick={handleExport}>
              <Download className="w-4 h-4 mr-2" />
              ייצוא
            </Button>

            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowMonthlyTrendDialog(true)}
            >
              <BarChart className="w-4 h-4 mr-2" />
              מגמה חודשית
            </Button>

            <Button onClick={() => setShowNewSuggestion(true)}>
              <Plus className="w-4 h-4 mr-2" />
              הצעה חדשה
            </Button>
          </div>
        </div>

        {/* Stats Overview */}
        <SuggestionsStats
          suggestions={suggestions}
          className="mb-6"
          onFilterChange={(filter) => {
            if (filter) {
              setFilters((currentFilters) => ({
                ...currentFilters,
                ...filter,
              }));
            }
          }}
        />

        {/* Main Content */}
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <div className="flex items-center justify-between mb-6">
            <TabsList dir="rtl" className="flex-row-reverse">
              <TabsTrigger value="pending">ממתין לאישור</TabsTrigger>
              <TabsTrigger value="active">הצעות פעילות</TabsTrigger>
              <TabsTrigger value="history">היסטוריה</TabsTrigger>
            </TabsList>
          </div>

          {/* Action Bar */}
          <SuggestionActionBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
            filters={filters}
            onFiltersChange={setFilters}
            totalCount={suggestions.length}
            activeCount={activeCount}
            pendingCount={pendingCount}
            historyCount={historyCount}
          />

          {/* Loading State */}
          {isLoading ? (
            <div className="flex items-center justify-center h-64">
              <div className="text-gray-500">טוען...</div>
            </div>
          ) : (
            <>
              {/* Suggestions Lists */}
              <TabsContent value="pending">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "PENDING")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "PENDING").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות ממתינות</p>
                  </div>
                )}
              </TabsContent>

              <TabsContent value="active">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "ACTIVE")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "ACTIVE").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות פעילות</p>
                  </div>
                )}
              </TabsContent>

              <TabsContent value="history">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
                  {suggestions
                    .filter((s) => s.category === "HISTORY")
                    .filter((s) => {
                      // Apply search filter
                      if (searchQuery) {
                        const query = searchQuery.toLowerCase();
                        return (
                          s.firstParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.firstParty.lastName.toLowerCase().includes(query) ||
                          s.secondParty.firstName
                            .toLowerCase()
                            .includes(query) ||
                          s.secondParty.lastName
                            .toLowerCase()
                            .includes(query) ||
                          (s.matchingReason &&
                            s.matchingReason.toLowerCase().includes(query)) ||
                          (s.firstParty.profile?.city &&
                            s.firstParty.profile.city
                              .toLowerCase()
                              .includes(query)) ||
                          (s.secondParty.profile?.city &&
                            s.secondParty.profile.city
                              .toLowerCase()
                              .includes(query))
                        );
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply priority filter
                      if (filters.priority && filters.priority.length > 0) {
                        return filters.priority.includes(s.priority);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply status filter
                      if (filters.status && filters.status.length > 0) {
                        return filters.status.includes(s.status);
                      }
                      return true;
                    })
                    .filter((s) => {
                      // Apply date range filter
                      if (filters.dateRange) {
                        const createdAt = new Date(s.createdAt);
                        return (
                          createdAt >= filters.dateRange.start &&
                          createdAt <= (filters.dateRange.end || new Date())
                        );
                      }
                      return true;
                    })
                    .map((suggestion) => (
                      <SuggestionCard
                        key={suggestion.id}
                        suggestion={suggestion}
                        onAction={handleSuggestionAction}
                      />
                    ))}
                </div>

                {suggestions.filter((s) => s.category === "HISTORY").length ===
                  0 && (
                  <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                    <p>אין הצעות בהיסטוריה</p>
                  </div>
                )}
              </TabsContent>
            </>
          )}
        </Tabs>
      </div>

      {/* New Suggestion Form */}
      <NewSuggestionForm
        isOpen={showNewSuggestion}
        onClose={() => setShowNewSuggestion(false)}
        candidates={[]}
        onSubmit={handleNewSuggestion}
      />

      {/* Suggestion Details Dialog */}
      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleDialogAction}
      />

      {/* Monthly Trend Dialog */}
      <Dialog
        open={showMonthlyTrendDialog}
        onOpenChange={setShowMonthlyTrendDialog}
      >
        <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>מגמה חודשית</DialogTitle>
            <DialogDescription>ניתוח מגמות הצעות לאורך זמן</DialogDescription>
          </DialogHeader>

          <div className="p-4">
            <MonthlyTrendModal suggestions={suggestions} />
          </div>

          <DialogFooter>
            <Button onClick={() => setShowMonthlyTrendDialog(false)}>
              סגור
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Confirm Action Dialog */}
      {confirmAction && (
        <AlertDialog
          open={showConfirmDialog}
          onOpenChange={setShowConfirmDialog}
        >
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
              <AlertDialogDescription>
                {confirmAction?.type === "delete" &&
                  "פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה."}
                {/* תנאים אחרים כאן */}
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel onClick={() => setShowConfirmDialog(false)}>
                ביטול
              </AlertDialogCancel>
              <AlertDialogAction
                onClick={handleConfirmAction}
                className={
                  confirmAction?.type === "delete"
                    ? "bg-red-600 hover:bg-red-700"
                    : ""
                }
              >
                {confirmAction?.type === "delete" ? "מחק" : "אשר"}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}

      {/* Edit Suggestion Form */}
      <EditSuggestionForm
        isOpen={showEditForm}
        onClose={() => setShowEditForm(false)}
        suggestion={selectedSuggestion}
        onSave={handleUpdateSuggestion}
      />

      {/* Message Form */}
      <MessageForm
        isOpen={showMessageForm}
        onClose={() => setShowMessageForm(false)}
        suggestion={selectedSuggestion}
        onSend={handleSendMessage}
      />
    </div>
  );
}
--- End of Content for MatchmakerDashboard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\MonthlyTrendModal.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion } from "@/types/suggestions";

interface MonthlyTrendModalProps {
  suggestions: Suggestion[];
}

interface MonthlyData {
  month: string;
  year: number;
  count: number;
  active: number;
  pending: number;
  success: number;
  declined: number;
}

const MonthlyTrendModal: React.FC<MonthlyTrendModalProps> = ({
  suggestions,
}) => {
  // Group suggestions by month to prepare data for chart
  const monthlyData = useMemo(() => {
    const data = suggestions.reduce((acc, s) => {
      const createdDate = new Date(s.createdAt);
      const month = createdDate.getMonth();
      const year = createdDate.getFullYear();
      const key = `${year}-${month + 1}`;

      if (!acc[key]) {
        acc[key] = {
          month: new Date(year, month).toLocaleString("he", {
            month: "short",
          }),
          year: year,
          count: 0,
          active: 0,
          pending: 0,
          success: 0,
          declined: 0,
        };
      }

      acc[key].count += 1;

      if (s.category === "ACTIVE") acc[key].active += 1;
      if (s.category === "PENDING") acc[key].pending += 1;
      if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
      if (
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
      ) {
        acc[key].declined += 1;
      }

      return acc;
    }, {} as Record<string, MonthlyData>);

    // Convert to array and sort by date
    return Object.values(data).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      const monthA = new Date(
        a.year,
        a.month === "ינו" ? 0 : new Date(`1 ${a.month} 2000`).getMonth()
      ).getMonth();
      const monthB = new Date(
        b.year,
        b.month === "ינו" ? 0 : new Date(`1 ${b.month} 2000`).getMonth()
      ).getMonth();
      return monthA - monthB;
    });
  }, [suggestions]);

  // Calculate trends
  const trends = useMemo(() => {
    if (monthlyData.length < 2)
      return { active: 0, pending: 0, success: 0, total: 0 };

    const current = monthlyData[monthlyData.length - 1];
    const previous = monthlyData[monthlyData.length - 2];

    const calculateTrend = (current: number, previous: number) => {
      if (previous === 0) return current > 0 ? 100 : 0;
      return Math.round(((current - previous) / previous) * 100);
    };

    return {
      active: calculateTrend(current.active, previous.active),
      pending: calculateTrend(current.pending, previous.pending),
      success: calculateTrend(current.success, previous.success),
      total: calculateTrend(current.count, previous.count),
    };
  }, [monthlyData]);

  if (monthlyData.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        <p>אין מספיק נתונים להצגת מגמה חודשית</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Summary stats */}
      <div className="grid grid-cols-4 gap-3">
        <Card className="p-3">
          <div className="text-sm text-gray-500"> סך כל ההצעות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].count}
            <span
              className={`text-xs ml-2 ${
                trends.total >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.total > 0 ? "+" : ""}
              {trends.total}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות פעילות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].active}
            <span
              className={`text-xs ml-2 ${
                trends.active >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.active > 0 ? "+" : ""}
              {trends.active}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">ממתינות לאישור</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].pending}
            <span
              className={`text-xs ml-2 ${
                trends.pending >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.pending > 0 ? "+" : ""}
              {trends.pending}%
            </span>
          </div>
        </Card>

        <Card className="p-3">
          <div className="text-sm text-gray-500">הצעות מוצלחות</div>
          <div className="text-xl font-semibold flex items-center mt-1">
            {monthlyData[monthlyData.length - 1].success}
            <span
              className={`text-xs ml-2 ${
                trends.success >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              {trends.success > 0 ? "+" : ""}
              {trends.success}%
            </span>
          </div>
        </Card>
      </div>

      {/* Main chart */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={monthlyData}
              margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="month" />
              <YAxis />
              <Tooltip
                formatter={(value) => [`${value} הצעות`, ""]}
                labelFormatter={(label) => `חודש ${label}`}
              />
              <Legend />
              <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
              <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
              <Bar dataKey="success" name="הצלחות" fill="#10B981" />
              <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* Monthly breakdown table */}
      <Card className="p-4">
        <h3 className="text-lg font-medium mb-4">פירוט חודשי</h3>
        <div className="overflow-x-auto">
          <table className="w-full border-collapse">
            <thead>
              <tr className="bg-gray-50">
                <th className="p-2 border text-right">חודש</th>
                <th className="p-2 border text-center">סך הכל</th>
                <th className="p-2 border text-center">פעילות</th>
                <th className="p-2 border text-center">ממתינות</th>
                <th className="p-2 border text-center">הצלחות</th>
                <th className="p-2 border text-center">נדחו</th>
              </tr>
            </thead>
            <tbody>
              {monthlyData
                .slice()
                .reverse()
                .map((month, idx) => (
                  <tr
                    key={idx}
                    className={idx % 2 === 0 ? "bg-white" : "bg-gray-50"}
                  >
                    <td className="p-2 border font-medium">
                      {month.month} {month.year}
                    </td>
                    <td className="p-2 border text-center">{month.count}</td>
                    <td className="p-2 border text-center">{month.active}</td>
                    <td className="p-2 border text-center">{month.pending}</td>
                    <td className="p-2 border text-center">{month.success}</td>
                    <td className="p-2 border text-center">{month.declined}</td>
                  </tr>
                ))}
            </tbody>
          </table>
        </div>
      </Card>
    </div>
  );
};

export default MonthlyTrendModal;
--- End of Content for MonthlyTrendModal.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionActionBar.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { DatePicker } from "@/components/ui/date-picker";
import {
  Search,
  Filter,
  X,
  Calendar,
  User,
  Clock,
  ChevronDown,
  AlertCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Priority, MatchSuggestionStatus } from "@prisma/client";
import type { SuggestionFilters, SortByOption } from "@/types/suggestions";

interface SuggestionActionBarProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  filters: SuggestionFilters;
  onFiltersChange: (filters: SuggestionFilters) => void;
  totalCount: number;
  activeCount: number;
  pendingCount: number;
  historyCount: number;
}

const SuggestionActionBar: React.FC<SuggestionActionBarProps> = ({
  searchQuery,
  onSearchChange,
  filters,
  onFiltersChange,
  totalCount,
  activeCount,
  pendingCount,
  historyCount,
}) => {
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const activeFilters = Object.keys(filters).length;
  const [dateRange, setDateRange] = useState<{
    from: Date | undefined;
    to: Date | undefined;
  }>({
    from: filters.dateRange?.start,
    to: filters.dateRange?.end,
  });

  const handleRemoveFilter = (key: keyof SuggestionFilters) => {
    const newFilters = { ...filters };
    delete newFilters[key];
    onFiltersChange(newFilters);
  };

  const handleDateRangeChange = (range: {
    from: Date | undefined;
    to: Date | undefined;
  }) => {
    setDateRange(range);
    if (range.from) {
      onFiltersChange({
        ...filters,
        dateRange: {
          start: range.from,
          end: range.to || new Date(),
        },
      });
    } else {
      const newFilters = { ...filters };
      delete newFilters.dateRange;
      onFiltersChange(newFilters);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "PENDING_FIRST_PARTY":
      case "PENDING_SECOND_PARTY":
        return <Clock className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_APPROVED":
      case "SECOND_PARTY_APPROVED":
        return <CheckCircle className="h-4 w-4 ml-1" />;
      case "FIRST_PARTY_DECLINED":
      case "SECOND_PARTY_DECLINED":
        return <XCircle className="h-4 w-4 ml-1" />;
      default:
        return <AlertCircle className="h-4 w-4 ml-1" />;
    }
  };

  return (
    <div className="space-y-4 mb-6">
      {/* Main filters and search */}
      <div className="flex items-center gap-4">
        <div className="flex-1 relative">
          <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            placeholder="חיפוש הצעות לפי שם, עיר או כל מידע אחר..."
            className="pl-10 text-right pr-10"
          />
        </div>

        <Select
          value={filters.priority?.[0] || "all"}
          onValueChange={(value) =>
            onFiltersChange({
              ...filters,
              priority: value === "all" ? undefined : [value as Priority],
            })
          }
        >
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="עדיפות" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">כל העדיפויות</SelectItem>
            <SelectItem value={Priority.URGENT}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-red-500"></span>
                דחוף
              </div>
            </SelectItem>
            <SelectItem value={Priority.HIGH}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-orange-500"></span>
                גבוהה
              </div>
            </SelectItem>
            <SelectItem value={Priority.MEDIUM}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-blue-500"></span>
                רגילה
              </div>
            </SelectItem>
            <SelectItem value={Priority.LOW}>
              <div className="flex items-center gap-2">
                <span className="h-2 w-2 rounded-full bg-gray-500"></span>
                נמוכה
              </div>
            </SelectItem>
          </SelectContent>
        </Select>

        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" className="flex items-center">
              <Calendar className="h-4 w-4 ml-2" />
              <span>טווח זמן</span>
              <ChevronDown className="h-4 w-4 mr-2" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-4" align="end">
            <div className="space-y-2">
              <h4 className="font-medium">בחר טווח תאריכים</h4>
              <DatePicker
                onChange={handleDateRangeChange}
                value={dateRange}
                isRange={true}
              />
              <div className="flex justify-end mt-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() =>
                    handleDateRangeChange({ from: undefined, to: undefined })
                  }
                >
                  נקה
                </Button>
              </div>
            </div>
          </PopoverContent>
        </Popover>

        <Button
          variant={showAdvancedFilters ? "default" : "outline"}
          onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
        >
          <Filter className="w-4 h-4 ml-2" />
          מסננים מתקדמים
        </Button>
      </div>

      {/* Stats Row */}
      <div className="flex justify-between bg-slate-50 rounded-md p-3">
        <div className="flex items-center gap-6">
          <div className="flex items-center">
            <Badge variant="outline" className="rounded-full px-2 py-0 mr-2">
              {totalCount}
            </Badge>
            <span className="text-sm font-medium">סה״כ הצעות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="default" className="rounded-full px-2 py-0 mr-2">
              {activeCount}
            </Badge>
            <span className="text-sm font-medium">פעילות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="warning" className="rounded-full px-2 py-0 mr-2">
              {pendingCount}
            </Badge>
            <span className="text-sm font-medium">ממתינות</span>
          </div>
          <div className="flex items-center">
            <Badge variant="secondary" className="rounded-full px-2 py-0 mr-2">
              {historyCount}
            </Badge>
            <span className="text-sm font-medium">היסטוריה</span>
          </div>
        </div>

        {activeFilters > 0 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onFiltersChange({})}
            className="text-gray-500 hover:text-gray-700"
          >
            נקה את כל המסננים ({activeFilters})
          </Button>
        )}
      </div>

      {/* Advanced Filters */}
      {showAdvancedFilters && (
        <div className="bg-slate-50 p-4 rounded-md space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="font-medium">מסננים מתקדמים</h3>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 px-2"
              onClick={() => setShowAdvancedFilters(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Status Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">סטטוס</h4>
              <div className="space-y-2">
                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-first"
                    checked={filters.status?.includes("PENDING_FIRST_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_FIRST_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_FIRST_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-first"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-yellow-600" />
                    ממתין לתשובת צד א׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-pending-second"
                    checked={filters.status?.includes("PENDING_SECOND_PARTY")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "PENDING_SECOND_PARTY",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "PENDING_SECOND_PARTY"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-pending-second"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Clock className="h-3 w-3 ml-1 text-blue-600" />
                    ממתין לתשובת צד ב׳
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-approved"
                    checked={
                      filters.status?.includes("FIRST_PARTY_APPROVED") ||
                      filters.status?.includes("SECOND_PARTY_APPROVED")
                    }
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [
                          ...(filters.status || []),
                          "FIRST_PARTY_APPROVED",
                          "SECOND_PARTY_APPROVED",
                        ];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) =>
                              s !== "FIRST_PARTY_APPROVED" &&
                              s !== "SECOND_PARTY_APPROVED"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-approved"
                    className="text-sm mr-2 flex items-center"
                  >
                    <CheckCircle className="h-3 w-3 ml-1 text-green-600" />
                    אושר ע״י אחד הצדדים
                  </label>
                </div>

                <div className="flex items-center">
                  <Checkbox
                    id="status-dating"
                    checked={filters.status?.includes("DATING")}
                    onCheckedChange={(checked) => {
                      if (checked) {
                        const newStatus = [...(filters.status || []), "DATING"];
                        onFiltersChange({
                          ...filters,
                          status: newStatus as MatchSuggestionStatus[],
                        });
                      } else {
                        onFiltersChange({
                          ...filters,
                          status: filters.status?.filter(
                            (s) => s !== "DATING"
                          ) as MatchSuggestionStatus[],
                        });
                      }
                    }}
                  />
                  <label
                    htmlFor="status-dating"
                    className="text-sm mr-2 flex items-center"
                  >
                    <Calendar className="h-3 w-3 ml-1 text-pink-600" />
                    בתהליך היכרות
                  </label>
                </div>
              </div>
            </div>

            {/* User Filter */}
            <div>
              <h4 className="text-sm font-medium mb-2">משתתפים</h4>
              <Select
                value={filters.userId || "all"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    userId: value === "all" ? undefined : value,
                  })
                }
              >
                <SelectTrigger>
                  <User className="h-4 w-4 ml-1" />
                  <SelectValue placeholder="בחר משתתף" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">כל המשתתפים</SelectItem>
                  {/* Replace with dynamic user data */}
                  <SelectItem value="user1">ישראל ישראלי</SelectItem>
                  <SelectItem value="user2">שרה כהן</SelectItem>
                  <SelectItem value="user3">דוד לוי</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Sort By */}
            <div>
              <h4 className="text-sm font-medium mb-2">מיון לפי</h4>
              <Select
                value={filters.sortBy || "lastActivity"}
                onValueChange={(value) =>
                  onFiltersChange({
                    ...filters,
                    sortBy: value as SortByOption, // Cast to SortByOption
                  })
                }
              >
                <SelectTrigger>
                  <SelectValue placeholder="מיון לפי" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="lastActivity">פעילות אחרונה</SelectItem>
                  <SelectItem value="createdAt">תאריך יצירה</SelectItem>
                  <SelectItem value="priority">עדיפות</SelectItem>
                  <SelectItem value="decisionDeadline">תאריך יעד</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      )}

      {/* Active Filters */}
      {activeFilters > 0 && (
        <div className="flex items-center gap-2 flex-wrap">
          {filters.priority && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                עדיפות:{" "}
                {filters.priority[0] === "URGENT"
                  ? "דחוף"
                  : filters.priority[0] === "HIGH"
                  ? "גבוהה"
                  : filters.priority[0] === "MEDIUM"
                  ? "רגילה"
                  : "נמוכה"}
              </span>
              <button
                onClick={() => handleRemoveFilter("priority")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.dateRange && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                תאריך:{" "}
                {new Date(filters.dateRange.start).toLocaleDateString("he-IL")}
                {filters.dateRange.end &&
                  ` - ${new Date(filters.dateRange.end).toLocaleDateString(
                    "he-IL"
                  )}`}
              </span>
              <button
                onClick={() => handleRemoveFilter("dateRange")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.status && filters.status.length > 0 && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>
                סטטוס:{" "}
                {filters.status.length === 1
                  ? ""
                  : `(${filters.status.length})`}
                {filters.status.length === 1 && (
                  <span className="flex items-center">
                    {getStatusIcon(filters.status[0])}
                    {filters.status[0] === "PENDING_FIRST_PARTY"
                      ? "ממתין לצד א׳"
                      : filters.status[0] === "PENDING_SECOND_PARTY"
                      ? "ממתין לצד ב׳"
                      : filters.status[0]}
                  </span>
                )}
              </span>
              <button
                onClick={() => handleRemoveFilter("status")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}

          {filters.userId && (
            <Badge variant="secondary" className="px-3 py-1 bg-white">
              <span>משתתף מסוים</span>
              <button
                onClick={() => handleRemoveFilter("userId")}
                className="ml-2 hover:text-red-500"
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          )}
        </div>
      )}
    </div>
  );
};

export default SuggestionActionBar;
--- End of Content for SuggestionActionBar.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\container\SuggestionsStats.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo } from "react";
import { Card } from "@/components/ui/card";
import {
  Users,
  CheckCircle,
  Clock,
  Calendar,
  AlertCircle,
  Ban,
  X,
} from "lucide-react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from "recharts";
import type { Suggestion, SuggestionFilters } from "@/types/suggestions";

interface StatsCardProps {
  icon: React.ElementType;
  title: string;
  value: string | number;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  onClick?: () => void;
  isClickable?: boolean;
}

interface SuggestionsStatsProps {
  suggestions: Suggestion[];
  className?: string;
  onFilterChange?: (filter: Partial<SuggestionFilters>) => void;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  trend,
  className,
  onClick,
  isClickable = false,
}) => (
  <Card
    className={`p-4 ${className} ${
      isClickable ? "cursor-pointer hover:shadow-md transition-shadow" : ""
    }`}
    onClick={onClick}
  >
    <div className="flex items-center justify-between">
      <div className="p-2 bg-primary/10 rounded-lg">
        <Icon className="w-5 h-5 text-primary" />
      </div>
      <div className="text-right">
        <p className="text-sm text-gray-500">{title}</p>
        <h3 className="text-2xl font-semibold mt-1">{value}</h3>
        {trend && (
          <div className="flex items-center gap-1 mt-1">
            <span
              className={trend.isPositive ? "text-green-600" : "text-red-600"}
            >
              {trend.value > 0 ? "+" : ""}
              {trend.value}%
            </span>
            <span className="text-xs text-gray-500">מהחודש שעבר</span>
          </div>
        )}
      </div>
    </div>
  </Card>
);

const SuggestionsStats: React.FC<SuggestionsStatsProps> = ({
  suggestions,
  className,
  onFilterChange,
}) => {
  const stats = useMemo(() => {
    const total = suggestions.length;
    const active = suggestions.filter((s) => s.category === "ACTIVE").length;
    const pending = suggestions.filter((s) => s.category === "PENDING").length;
    const history = suggestions.filter((s) => s.category === "HISTORY").length;

    const approvedByFirst = suggestions.filter(
      (s) => s.status === "FIRST_PARTY_APPROVED"
    ).length;
    const approvedBySecond = suggestions.filter(
      (s) => s.status === "SECOND_PARTY_APPROVED"
    ).length;
    const declined = suggestions.filter(
      (s) =>
        s.status === "FIRST_PARTY_DECLINED" ||
        s.status === "SECOND_PARTY_DECLINED"
    ).length;
    const expired = suggestions.filter((s) => s.status === "EXPIRED").length;
    const dating = suggestions.filter((s) => s.status === "DATING").length;
    const success = suggestions.filter((s) =>
      ["MARRIED", "ENGAGED"].includes(s.status)
    ).length;

    const byStatus = suggestions.reduce((acc, s) => {
      acc[s.status] = (acc[s.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Group suggestions by month
    const monthlyData = suggestions.reduce(
      (acc, s) => {
        const month = new Date(s.createdAt).getMonth();
        const year = new Date(s.createdAt).getFullYear();
        const key = `${year}-${month + 1}`;

        if (!acc[key]) {
          acc[key] = {
            month: new Date(year, month).toLocaleString("he", {
              month: "short",
            }),
            year: year,
            count: 0,
            active: 0,
            pending: 0,
            success: 0,
            declined: 0,
          };
        }

        acc[key].count += 1;

        if (s.category === "ACTIVE") acc[key].active += 1;
        if (s.category === "PENDING") acc[key].pending += 1;
        if (["MARRIED", "ENGAGED"].includes(s.status)) acc[key].success += 1;
        if (
          s.status === "FIRST_PARTY_DECLINED" ||
          s.status === "SECOND_PARTY_DECLINED"
        ) {
          acc[key].declined += 1;
        }

        return acc;
      },
      {} as Record<
        string,
        {
          month: string;
          year: number;
          count: number;
          active: number;
          pending: number;
          success: number;
          declined: number;
        }
      >
    );

    // Convert to array and sort by date
    const monthlyArray = Object.values(monthlyData).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      return a.month.localeCompare(b.month);
    });

    // Calculate trends
    const calculateTrend = (currentValue: number, previousValue: number) => {
      if (previousValue === 0) return currentValue > 0 ? 100 : 0;
      return Math.round(((currentValue - previousValue) / previousValue) * 100);
    };

    // Calculate success rate
    const successRate = total > 0 ? Math.round((success / total) * 100) : 0;

    // Get current month stats vs previous month for trend
    let activeTrend = 0;
    let pendingTrend = 0;
    let successTrend = 0;

    if (monthlyArray.length >= 2) {
      const currentMonth = monthlyArray[monthlyArray.length - 1];
      const previousMonth = monthlyArray[monthlyArray.length - 2];

      activeTrend = calculateTrend(currentMonth.active, previousMonth.active);
      pendingTrend = calculateTrend(
        currentMonth.pending,
        previousMonth.pending
      );
      successTrend = calculateTrend(
        currentMonth.success,
        previousMonth.success
      );
    }

    return {
      total,
      active,
      pending,
      history,
      approvedByFirst,
      approvedBySecond,
      declined,
      expired,
      dating,
      success,
      successRate,
      byStatus,
      monthlyData: monthlyArray,
      trends: {
        active: activeTrend,
        pending: pendingTrend,
        success: successTrend,
      },
    };
  }, [suggestions]);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Main Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatsCard
          icon={Users}
          title="סה״כ הצעות"
          value={stats.total}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() => onFilterChange && onFilterChange({})}
        />
        <StatsCard
          icon={CheckCircle}
          title="הצעות פעילות"
          value={stats.active}
          trend={{
            value: stats.trends.active,
            isPositive: stats.trends.active >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: [
                "DATING",
                "FIRST_PARTY_APPROVED",
                "SECOND_PARTY_APPROVED",
                "CONTACT_DETAILS_SHARED",
              ],
            })
          }
        />
        <StatsCard
          icon={Clock}
          title="ממתינות לתגובה"
          value={stats.pending}
          trend={{
            value: stats.trends.pending,
            isPositive: stats.trends.pending >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY"],
            })
          }
        />
        <StatsCard
          icon={Calendar}
          title="שידוכים מוצלחים"
          value={`${stats.successRate}%`}
          trend={{
            value: stats.trends.success,
            isPositive: stats.trends.success >= 0,
          }}
          isClickable={true}
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING", "ENGAGED", "MARRIED"],
            })
          }
        />
      </div>

      {/* Action Cards */}
      <div className="grid grid-cols-1 md:grid-cols-5 gap-3 mt-4">
        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-yellow-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_FIRST_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-yellow-600" />
            <div className="text-xs">ממתין לצד א׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_FIRST_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-blue-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["PENDING_SECOND_PARTY"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-blue-600" />
            <div className="text-xs">ממתין לצד ב׳</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["PENDING_SECOND_PARTY"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-red-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <X className="w-4 h-4 text-red-600" />
            <div className="text-xs">הצעות שנדחו</div>
            <div className="font-bold ml-auto">{stats.declined}</div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-pink-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["DATING"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Calendar className="w-4 h-4 text-pink-600" />
            <div className="text-xs">בתהליך היכרות</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["DATING"] || 0}
            </div>
          </div>
        </Card>

        <Card
          className="p-3 cursor-pointer hover:shadow-md transition-shadow bg-gray-50"
          onClick={() =>
            onFilterChange &&
            onFilterChange({
              status: ["EXPIRED"],
            })
          }
        >
          <div className="flex items-center gap-2">
            <Ban className="w-4 h-4 text-gray-600" />
            <div className="text-xs">פג תוקף</div>
            <div className="font-bold ml-auto">
              {stats.byStatus["EXPIRED"] || 0}
            </div>
          </div>
        </Card>
      </div>

      {/* מגמה חודשית נשארת כאן אבל עכשיו היא מוצגת בדיאלוג מודלי */}
      <div className="hidden">
        <Card className="p-4">
          <h3 className="text-lg font-medium mb-4">מגמה חודשית</h3>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={stats.monthlyData}
                margin={{ top: 5, right: 5, left: 5, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip
                  formatter={(value) => [`${value} הצעות`, ""]}
                  labelFormatter={(label) => `חודש ${label}`}
                />
                <Legend />
                <Bar dataKey="active" name="פעילות" fill="#3B82F6" />
                <Bar dataKey="pending" name="ממתינות" fill="#F59E0B" />
                <Bar dataKey="success" name="הצלחות" fill="#10B981" />
                <Bar dataKey="declined" name="נדחו" fill="#EF4444" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default SuggestionsStats;
--- End of Content for SuggestionsStats.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\details\SuggestionDetailsDialog.tsx
--------------------------------------------------------------------------------
Content:
// SuggestionDetailsDialog.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ProfileCard } from "@/app/components/profile";
import { Timeline } from "@/components/ui/timeline";
import {
  AlertCircle,
  CheckCircle,
  XCircle,
  MessageCircle,
  Send,
  RefreshCw,
  Edit,
  Calendar,
  Clock,
  Download,
  AlarmClock,
  Trash2,
  MapPin,
  Mail,
  Phone,
  User,
  ExternalLink,
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { MatchSuggestionStatus } from "@prisma/client";
import type { Suggestion, ActionAdditionalData } from "@/types/suggestions";
import type { QuestionnaireResponse } from "@/types/next-auth";
import Image from "next/image";

interface DialogActionData extends ActionAdditionalData {
  suggestionId?: string;
  newStatus?: MatchSuggestionStatus;
  notes?: string;
  suggestion?: Suggestion;
  partyId?: string;
  type?: string;
  partyType?: "first" | "second" | "both";
}

interface SuggestionDetailsDialogProps {
  suggestion: Suggestion | null;
  isOpen: boolean;
  onClose: () => void;
  onAction: (action: string, data?: DialogActionData) => void;
}

// Map status to its display info
const getStatusInfo = (status: MatchSuggestionStatus) => {
  const statusMap: Record<
    string,
    { label: string; icon: React.ElementType; color: string }
  > = {
    DRAFT: { label: "טיוטה", icon: Edit, color: "text-gray-600" },
    PENDING_FIRST_PARTY: {
      label: "ממתין לתשובת צד א׳",
      icon: Clock,
      color: "text-yellow-600",
    },
    FIRST_PARTY_APPROVED: {
      label: "צד א׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    FIRST_PARTY_DECLINED: {
      label: "צד א׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    PENDING_SECOND_PARTY: {
      label: "ממתין לתשובת צד ב׳",
      icon: Clock,
      color: "text-blue-600",
    },
    SECOND_PARTY_APPROVED: {
      label: "צד ב׳ אישר",
      icon: CheckCircle,
      color: "text-green-600",
    },
    SECOND_PARTY_DECLINED: {
      label: "צד ב׳ דחה",
      icon: XCircle,
      color: "text-red-600",
    },
    AWAITING_MATCHMAKER_APPROVAL: {
      label: "ממתין לאישור שדכן",
      icon: AlertCircle,
      color: "text-purple-600",
    },
    CONTACT_DETAILS_SHARED: {
      label: "פרטי קשר שותפו",
      icon: Send,
      color: "text-purple-600",
    },
    AWAITING_FIRST_DATE_FEEDBACK: {
      label: "ממתין למשוב פגישה",
      icon: MessageCircle,
      color: "text-orange-600",
    },
    DATING: {
      label: "בתהליך היכרות",
      icon: Calendar,
      color: "text-pink-600",
    },
    EXPIRED: { label: "פג תוקף", icon: AlarmClock, color: "text-gray-600" },
    CLOSED: { label: "סגור", icon: XCircle, color: "text-gray-600" },
  };
  return (
    statusMap[status] || {
      label: status as string,
      icon: AlertCircle as React.ElementType,
      color: "text-gray-600",
    }
  );
};

// Status groups for the progress indicator
const statusGroups = [
  ["DRAFT", "PENDING_FIRST_PARTY"],
  ["FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY"],
  ["SECOND_PARTY_APPROVED", "AWAITING_MATCHMAKER_APPROVAL"],
  ["CONTACT_DETAILS_SHARED", "AWAITING_FIRST_DATE_FEEDBACK"],
  ["DATING", "ENGAGED", "MARRIED"],
];
// הוספת מיפוי מלא של כל הסטטוסים האפשריים
const getAllStatusLabels = () => {
  // יצירת מיפוי של כל הסטטוסים האפשריים לפי הסכמה
  const statusLabels: Record<MatchSuggestionStatus, string> = {
    DRAFT: "טיוטה",
    PENDING_FIRST_PARTY: "ממתין לתשובת צד א׳",
    FIRST_PARTY_APPROVED: "צד א׳ אישר",
    FIRST_PARTY_DECLINED: "צד א׳ דחה",
    PENDING_SECOND_PARTY: "ממתין לתשובת צד ב׳",
    SECOND_PARTY_APPROVED: "צד ב׳ אישר",
    SECOND_PARTY_DECLINED: "צד ב׳ דחה",
    AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור שדכן",
    CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
    AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
    THINKING_AFTER_DATE: "בשלב מחשבה אחרי פגישה",
    PROCEEDING_TO_SECOND_DATE: "ממשיכים לפגישה שניה",
    ENDED_AFTER_FIRST_DATE: "הסתיים אחרי פגישה ראשונה",
    MEETING_PENDING: "ממתין לקביעת פגישה",
    MEETING_SCHEDULED: "פגישה נקבעה",
    MATCH_APPROVED: "ההצעה אושרה",
    MATCH_DECLINED: "ההצעה נדחתה",
    DATING: "בתהליך היכרות",
    ENGAGED: "מאורסים",
    MARRIED: "נישאו",
    EXPIRED: "פג תוקף",
    CLOSED: "סגור",
    CANCELLED: "בוטל",
  };

  return statusLabels;
};
// Helper to determine if a status change is possible
const canChangeStatus = (
  currentStatus: MatchSuggestionStatus
): MatchSuggestionStatus[] => {
  // Status changes that are allowed directly by the matchmaker
  const allowedChanges: Partial<
    Record<MatchSuggestionStatus, MatchSuggestionStatus[]>
  > = {
    // סטטוסים קיימים
    DRAFT: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_FIRST_PARTY: [
      "FIRST_PARTY_APPROVED",
      "FIRST_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    FIRST_PARTY_APPROVED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    FIRST_PARTY_DECLINED: ["PENDING_FIRST_PARTY", "CANCELLED", "CLOSED"],
    PENDING_SECOND_PARTY: [
      "SECOND_PARTY_APPROVED",
      "SECOND_PARTY_DECLINED",
      "EXPIRED",
      "CANCELLED",
      "CLOSED",
    ],
    SECOND_PARTY_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    SECOND_PARTY_DECLINED: ["PENDING_SECOND_PARTY", "CANCELLED", "CLOSED"],
    CONTACT_DETAILS_SHARED: [
      "AWAITING_FIRST_DATE_FEEDBACK",
      "DATING",
      "CANCELLED",
      "CLOSED",
    ],
    AWAITING_FIRST_DATE_FEEDBACK: ["DATING", "CANCELLED", "CLOSED"],
    DATING: ["ENGAGED", "CLOSED"],
    ENGAGED: ["MARRIED", "CLOSED"],
    MARRIED: ["CLOSED"],
    EXPIRED: ["PENDING_FIRST_PARTY", "PENDING_SECOND_PARTY", "CLOSED"],
    CANCELLED: ["DRAFT"],
    CLOSED: [],

    // הוספת הסטטוסים החסרים
    AWAITING_MATCHMAKER_APPROVAL: [
      "CONTACT_DETAILS_SHARED",
      "CANCELLED",
      "CLOSED",
    ],
    THINKING_AFTER_DATE: [
      "PROCEEDING_TO_SECOND_DATE",
      "ENDED_AFTER_FIRST_DATE",
      "CLOSED",
    ],
    PROCEEDING_TO_SECOND_DATE: ["DATING", "CLOSED"],
    ENDED_AFTER_FIRST_DATE: ["CLOSED"],
    MEETING_PENDING: ["MEETING_SCHEDULED", "CANCELLED", "CLOSED"],
    MEETING_SCHEDULED: ["AWAITING_FIRST_DATE_FEEDBACK", "CANCELLED", "CLOSED"],
    MATCH_APPROVED: ["CONTACT_DETAILS_SHARED", "CANCELLED", "CLOSED"],
    MATCH_DECLINED: ["CLOSED"],
  };

  return allowedChanges[currentStatus] || [];
};

const formatDateSafely = (
  dateInput: Date | string | null | undefined
): string => {
  if (!dateInput) return "לא נקבע";

  // Ensure we're working with a Date object
  const date = typeof dateInput === "string" ? new Date(dateInput) : dateInput;

  // Validate that the date is valid before formatting
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    return "תאריך לא תקין";
  }

  return new Intl.DateTimeFormat("he-IL", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  }).format(date);
};

const getDaysRemaining = (
  deadline: Date | string | null | undefined
): number | null => {
  if (!deadline) return null;

  // Convert string to Date if needed
  const deadlineDate =
    typeof deadline === "string" ? new Date(deadline) : deadline;

  // Validate date
  if (!(deadlineDate instanceof Date) || isNaN(deadlineDate.getTime())) {
    return null;
  }

  const today = new Date();
  const diffTime = deadlineDate.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
};

// Get the status group index for progress indicator
const getStatusGroupIndex = (status: MatchSuggestionStatus): number => {
  for (let i = 0; i < statusGroups.length; i++) {
    if (statusGroups[i].includes(status)) {
      return i;
    }
  }
  return -1;
};

const SuggestionDetailsDialog: React.FC<SuggestionDetailsDialogProps> = ({
  suggestion,
  isOpen,
  onClose,
  onAction,
}) => {
  const [activeTab, setActiveTab] = useState("overview");
  const [firstPartyQuestionnaire, setFirstPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [secondPartyQuestionnaire, setSecondPartyQuestionnaire] =
    useState<QuestionnaireResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [statusChangeNote, setStatusChangeNote] = useState("");
  const [newStatus, setNewStatus] = useState<MatchSuggestionStatus | null>(
    null
  );
  const [showStatusChange, setShowStatusChange] = useState(false);

  // Calculate allowed status changes based on current status
  const allowedStatusChanges = suggestion
    ? canChangeStatus(suggestion.status as MatchSuggestionStatus)
    : [];

  useEffect(() => {
    const loadQuestionnaire = async (userId: string) => {
      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${userId}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          return {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
        }
        return null;
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
        return null;
      }
    };

    const loadQuestionnaires = async () => {
      if (!suggestion) {
        setFirstPartyQuestionnaire(null);
        setSecondPartyQuestionnaire(null);
        return;
      }

      setIsLoading(true);
      try {
        const [firstParty, secondParty] = await Promise.all([
          loadQuestionnaire(suggestion.firstParty.id),
          loadQuestionnaire(suggestion.secondParty.id),
        ]);

        setFirstPartyQuestionnaire(firstParty);
        setSecondPartyQuestionnaire(secondParty);
      } catch (error) {
        console.error("Error loading questionnaires:", error);
        toast.error("שגיאה בטעינת השאלונים");
      } finally {
        setIsLoading(false);
      }
    };

    loadQuestionnaires();
  }, [suggestion]);

  // Handle status change
  const handleStatusChange = async () => {
    if (!newStatus || !suggestion) return;

    setIsLoading(true);
    try {
      console.log(
        `שולח בקשה לשינוי סטטוס: ${newStatus} עם הערות: ${
          statusChangeNote || "ללא הערות"
        }`
      );
      // עדכון הקומפוננטה ההורה
      onAction("changeStatus", {
        suggestionId: suggestion.id,
        newStatus,
        notes: statusChangeNote,
      });

      // איפוס מצב הטופס
      setShowStatusChange(false);
      setStatusChangeNote("");
      setNewStatus(null);
    } catch (error) {
      console.error("Error changing status:", error);
      toast.error(
        `שגיאה בעדכון הסטטוס: ${
          error instanceof Error ? error.message : "שגיאה לא מזוהה"
        }`
      );
    } finally {
      setIsLoading(false);
    }
  };

  if (!suggestion) return null;

  // Get status display info
  const statusInfo = getStatusInfo(suggestion.status as MatchSuggestionStatus);
  const StatusIcon = statusInfo.icon;

  // Format suggestion dates
  const createdDate = suggestion.createdAt;
  const lastActivityDate = suggestion.lastActivity;
  const decisionDeadlineDate = suggestion.decisionDeadline
    ? suggestion.decisionDeadline
    : null;

  // Days remaining for decision if applicable
  const daysRemaining = decisionDeadlineDate
    ? getDaysRemaining(decisionDeadlineDate)
    : null;

  // Get status progress index for the progress indicator
  const statusGroupIndex = getStatusGroupIndex(
    suggestion.status as MatchSuggestionStatus
  );

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="max-w-6xl max-h-[90vh] flex flex-col p-0"
        style={{ direction: "rtl" }}
      >
        {/* Header with Progress Bar */}
        <div className="bg-gradient-to-r from-slate-50 to-white border-b flex-shrink-0">
          <DialogHeader className="p-6 pb-3">
            <div className="flex items-center justify-between">
              <div>
                <DialogTitle className="text-2xl font-bold">
                  הצעת שידוך #{suggestion.id.toString().split("-")[0]}
                </DialogTitle>
                <DialogDescription className="text-lg mt-1">
                  {suggestion.firstParty.firstName}{" "}
                  {suggestion.firstParty.lastName} ו
                  {suggestion.secondParty.firstName}{" "}
                  {suggestion.secondParty.lastName}
                </DialogDescription>
              </div>
              <div className="flex items-center gap-3">
                <Badge
                  className={`px-3 py-1.5 ${statusInfo.color} flex items-center gap-1 text-sm shadow-sm`}
                >
                  <StatusIcon className="w-4 h-4" />
                  {statusInfo.label}
                </Badge>
                <Badge
                  variant="outline"
                  className={`px-3 shadow-sm ${
                    suggestion.priority === "URGENT"
                      ? "bg-red-50 text-red-600 border-red-200"
                      : suggestion.priority === "HIGH"
                      ? "bg-orange-50 text-orange-600 border-orange-200"
                      : suggestion.priority === "MEDIUM"
                      ? "bg-blue-50 text-blue-600 border-blue-200"
                      : "bg-gray-50 text-gray-600 border-gray-200"
                  }`}
                >
                  {suggestion.priority === "URGENT"
                    ? "דחוף"
                    : suggestion.priority === "HIGH"
                    ? "עדיפות גבוהה"
                    : suggestion.priority === "MEDIUM"
                    ? "עדיפות רגילה"
                    : "עדיפות נמוכה"}
                </Badge>
              </div>
            </div>
          </DialogHeader>

          {/* Status Progress Indicator */}
          <div className="px-6 pb-4">
            <div className="relative flex items-center justify-between w-full h-3 bg-gray-100 rounded-full mt-4">
              {statusGroupIndex >= 0 && (
                <div
                  className="absolute h-3 bg-gradient-to-r from-blue-400 to-blue-600 rounded-full"
                  style={{
                    width: `${Math.min(
                      ((statusGroupIndex + 1) / statusGroups.length) * 100,
                      100
                    )}%`,
                  }}
                ></div>
              )}
              {statusGroups.map((_, index) => (
                <div
                  key={index}
                  className={`relative z-10 w-6 h-6 rounded-full flex items-center justify-center border-2 ${
                    index <= statusGroupIndex
                      ? "bg-blue-600 border-blue-700 text-white"
                      : "bg-white border-gray-300"
                  }`}
                >
                  {index + 1}
                </div>
              ))}
            </div>
            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
              <span>יצירת הצעה</span>
              <span>אישור ראשוני</span>
              <span>אישור סופי</span>
              <span>שיתוף פרטים</span>
              <span>בתהליך היכרות</span>
            </div>
          </div>
        </div>
        {/* Main Content Area */}
        <Tabs
          value={activeTab}
          onValueChange={setActiveTab}
          className="flex-1 flex flex-col overflow-hidden"
        >
          <TabsList className="px-6 pt-2 border-b justify-end gap-1 flex-shrink-0">
            <TabsTrigger
              value="overview"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              סקירה כללית
            </TabsTrigger>
            <TabsTrigger
              value="firstParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד ראשון
            </TabsTrigger>
            <TabsTrigger
              value="secondParty"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              צד שני
            </TabsTrigger>
            <TabsTrigger
              value="timeline"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              ציר זמן
            </TabsTrigger>
            <TabsTrigger
              value="communication"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              תקשורת
            </TabsTrigger>
            <TabsTrigger
              value="actions"
              className="data-[state=active]:bg-blue-50 data-[state=active]:text-blue-700 rounded-t-lg"
            >
              פעולות
            </TabsTrigger>
          </TabsList>

          <div className="flex-1 overflow-y-auto">
            {/* Overview Tab */}

            <TabsContent
              value="overview"
              className="p-0 m-0 h-full overflow-auto"
            >
              <div className="p-6">
                {/* שינוי 1: שינוי המבנה כך שפרטי ההצעה יהיו בחלק העליון ושני הצדדים יהיו זה לצד זה */}
                <div className="space-y-3">
                  {/* פרטי הצעה - עיצוב מסודר וקומפקטי */}
                  <div className="bg-white rounded-xl shadow-sm border p-4 mb-3 hover:shadow-md transition-shadow">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="text-md font-semibold flex items-center">
                        <Calendar className="w-4 h-4 ml-1 text-blue-600" />
                        פרטי הצעה
                      </h3>
                      <Badge
                        className={`${statusInfo.color} px-2 py-0.5 text-xs`}
                      >
                        <StatusIcon className="w-3 h-3 ml-1" />
                        {statusInfo.label}
                      </Badge>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm">
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">תאריך יצירה:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(createdDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">עדכון אחרון:</span>
                        <span className="font-medium mr-1">
                          {formatDateSafely(lastActivityDate)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">שדכן:</span>
                        <span className="font-medium mr-1">
                          {`${suggestion.matchmaker?.firstName} ${suggestion.matchmaker?.lastName}`}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">דחיפות:</span>
                        <span
                          className={`font-medium mr-1 ${
                            suggestion.priority === "URGENT"
                              ? "text-red-600"
                              : suggestion.priority === "HIGH"
                              ? "text-orange-600"
                              : suggestion.priority === "MEDIUM"
                              ? "text-blue-600"
                              : "text-gray-600"
                          }`}
                        >
                          {suggestion.priority === "URGENT"
                            ? "דחוף"
                            : suggestion.priority === "HIGH"
                            ? "עדיפות גבוהה"
                            : suggestion.priority === "MEDIUM"
                            ? "עדיפות רגילה"
                            : "עדיפות נמוכה"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד תגובה:</span>
                        <span className="font-medium mr-1">
                          {suggestion.responseDeadline
                            ? formatDateSafely(suggestion.responseDeadline)
                            : "לא נקבע"}
                        </span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-gray-500">מועד להחלטה:</span>
                        <span
                          className={
                            daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED"
                              ? "text-red-600 font-medium"
                              : "font-medium"
                          }
                        >
                          {decisionDeadlineDate
                            ? formatDateSafely(decisionDeadlineDate)
                            : "לא נקבע"}
                          {daysRemaining !== null &&
                            daysRemaining < 3 &&
                            suggestion.status !== "EXPIRED" && (
                              <span className="mr-1 text-red-600 text-xs">
                                (
                                {daysRemaining === 0
                                  ? "היום!"
                                  : `נותרו ${daysRemaining} ימים`}
                                )
                              </span>
                            )}
                        </span>
                      </div>
                    </div>

                    <div className="flex justify-end mt-3">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowStatusChange(true)}
                        disabled={allowedStatusChanges.length === 0}
                        className="text-blue-600 border-blue-200 hover:bg-blue-50 text-xs py-1 h-7"
                      >
                        <RefreshCw className="w-3 h-3 ml-1" />
                        שנה סטטוס
                      </Button>
                    </div>
                  </div>

                  {/* שינוי 2: כרטיסי הצדדים מסודרים זה לצד זה בגריד עם 2 עמודות */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* First Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-blue-800">
                        <User className="w-5 h-5 ml-2 text-blue-600" />
                        צד א׳: {suggestion.firstParty.firstName}{" "}
                        {suggestion.firstParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.firstParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-blue-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.firstParty.firstName}{" "}
                            {suggestion.firstParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.firstPartySent
                              ? formatDateSafely(suggestion.firstPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "FIRST_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "FIRST_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_FIRST_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "FIRST_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "FIRST_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_FIRST_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.firstPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-blue-50 rounded-lg p-3 text-sm border border-blue-100">
                            {suggestion.firstPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-blue-200 hover:bg-blue-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_FIRST_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-yellow-500 hover:bg-yellow-600"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.firstParty.id,
                                partyType: "first",
                              })
                            }
                          >
                            <AlertCircle className="w-4 h-4 ml-2" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>

                    {/* Second Party Status Card */}
                    <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center text-purple-800">
                        <User className="w-5 h-5 ml-2 text-purple-600" />
                        צד ב׳: {suggestion.secondParty.firstName}{" "}
                        {suggestion.secondParty.lastName}
                      </h3>

                      <div className="flex items-center gap-3 mb-3">
                        <div className="relative h-14 w-14">
                          <Image
                            src={
                              suggestion.secondParty.images.find(
                                (img) => img.isMain
                              )?.url || "/placeholders/user.png"
                            }
                            alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                            fill
                            className="rounded-full object-cover border-2 border-purple-200"
                          />
                        </div>
                        <div>
                          <div className="font-medium">
                            {suggestion.secondParty.firstName}{" "}
                            {suggestion.secondParty.lastName}
                          </div>
                          <div className="text-sm text-gray-500 flex items-center">
                            <MapPin className="w-3 h-3 ml-1" />
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </div>
                        </div>
                      </div>

                      <div className="space-y-3 divide-y">
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">קיבל את ההצעה:</span>
                          <span className="font-medium">
                            {suggestion.secondPartySent
                              ? formatDateSafely(suggestion.secondPartySent)
                              : "טרם נשלח"}
                          </span>
                        </div>
                        <div className="flex justify-between py-1">
                          <span className="text-gray-500">תגובה:</span>
                          <Badge
                            className={
                              suggestion.status === "SECOND_PARTY_APPROVED"
                                ? "bg-green-100 text-green-800 border-green-200"
                                : suggestion.status === "SECOND_PARTY_DECLINED"
                                ? "bg-red-100 text-red-800 border-red-200"
                                : suggestion.status === "PENDING_SECOND_PARTY"
                                ? "bg-yellow-100 text-yellow-800 border-yellow-200"
                                : "bg-gray-100 text-gray-800 border-gray-200"
                            }
                          >
                            {suggestion.status === "SECOND_PARTY_APPROVED"
                              ? "אישר"
                              : suggestion.status === "SECOND_PARTY_DECLINED"
                              ? "דחה"
                              : suggestion.status === "PENDING_SECOND_PARTY"
                              ? "ממתין לתשובה"
                              : "לא רלוונטי"}
                          </Badge>
                        </div>
                      </div>

                      {suggestion.secondPartyNotes && (
                        <div className="mt-2">
                          <h4 className="text-sm font-medium text-gray-600 mb-1">
                            הערות:
                          </h4>
                          <div className="bg-purple-50 rounded-lg p-3 text-sm border border-purple-100">
                            {suggestion.secondPartyNotes}
                          </div>
                        </div>
                      )}

                      <div className="flex gap-2 mt-3">
                        <Button
                          size="sm"
                          variant="outline"
                          className="flex-1 border-purple-200 hover:bg-purple-50"
                          onClick={() =>
                            onAction("contact", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <MessageCircle className="w-4 h-4 ml-1" />
                          צור קשר
                        </Button>

                        {suggestion.status === "PENDING_SECOND_PARTY" && (
                          <Button
                            size="sm"
                            className="flex-1 bg-purple-600 hover:bg-purple-700"
                            onClick={() =>
                              onAction("reminder", {
                                suggestionId: suggestion.id,
                                partyId: suggestion.secondParty.id,
                                partyType: "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* מידע נוסף */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
                    {/* Matching Reason Card */}
                    {suggestion.matchingReason && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <User className="w-5 h-5 ml-2 text-green-600" />
                          סיבת ההתאמה
                        </h3>
                        <div className="bg-green-50 rounded-lg border border-green-100 p-4 text-gray-700">
                          {suggestion.matchingReason}
                        </div>
                      </div>
                    )}

                    {/* Internal Notes */}
                    {suggestion.internalNotes && (
                      <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                        <h3 className="text-lg font-semibold flex items-center">
                          <AlertCircle className="w-5 h-5 ml-2 text-amber-600" />
                          הערות פנימיות
                        </h3>
                        <div className="bg-amber-50 rounded-lg border border-amber-100 p-4 text-gray-700">
                          {suggestion.internalNotes}
                        </div>
                      </div>
                    )}

                    {/* Quick Actions */}
                    <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 hover:shadow-md transition-shadow">
                      <h3 className="text-lg font-semibold flex items-center">
                        <RefreshCw className="w-5 h-5 ml-2 text-gray-600" />
                        פעולות מהירות
                      </h3>

                      <div className="grid grid-cols-2 gap-2">
                        <Button
                          variant="outline"
                          className="justify-start"
                          onClick={() =>
                            onAction("edit", { suggestionId: suggestion.id })
                          }
                        >
                          <Edit className="w-4 h-4 ml-1" />
                          ערוך הצעה
                        </Button>

                        {(suggestion.status === "PENDING_FIRST_PARTY" ||
                          suggestion.status === "PENDING_SECOND_PARTY") && (
                          <Button
                            variant="outline"
                            className="justify-start"
                            onClick={() =>
                              onAction("sendReminder", {
                                suggestionId: suggestion.id,
                                type:
                                  suggestion.status === "PENDING_FIRST_PARTY"
                                    ? "first"
                                    : "second",
                              })
                            }
                          >
                            <Send className="w-4 h-4 ml-1" />
                            שלח תזכורת
                          </Button>
                        )}

                        {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                          suggestion.status === "SECOND_PARTY_APPROVED") && (
                          <Button
                            variant="default"
                            className="justify-start bg-green-600 hover:bg-green-700"
                            onClick={() =>
                              onAction("shareContacts", {
                                suggestionId: suggestion.id,
                              })
                            }
                          >
                            <ExternalLink className="w-4 h-4 ml-1" />
                            שתף פרטי קשר
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* First Party Tab */}
            <TabsContent value="firstParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-blue-800">
                      {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-blue-100 text-blue-700 border-blue-200">
                      צד א׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.firstParty.images.find((img) => img.isMain)
                            ?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-blue-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty?.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-blue-500" />
                          <span>
                            {suggestion.firstParty.profile?.birthDate
                              ? new Date(
                                  suggestion.firstParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-blue-200 hover:bg-blue-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.firstParty.id,
                          partyType: "first",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_FIRST_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד ראשון
                      </Button>
                    )}

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח תזכורת לצד שני
                      </Button>
                    )}

                    {suggestion.status === "AWAITING_FIRST_DATE_FEEDBACK" && (
                      <Button
                        className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyType: "both",
                          })
                        }
                      >
                        <AlertCircle className="w-4 h-4 ml-2" />
                        שלח בקשת עדכון מפגש
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.firstParty.profile}
                  images={suggestion.firstParty.images}
                  questionnaire={firstPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-blue-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.firstParty.firstName}
                  </h3>
                  {suggestion.firstPartyNotes ? (
                    <p>{suggestion.firstPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Second Party Tab */}
            <TabsContent value="secondParty" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 space-y-3 mb-6">
                  <div className="flex items-center justify-between">
                    <h3 className="text-xl font-semibold text-purple-800">
                      {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h3>
                    <Badge className="px-3 py-1.5 bg-purple-100 text-purple-700 border-purple-200">
                      צד ב׳
                    </Badge>
                  </div>

                  <div className="flex items-center gap-3 py-2">
                    <div className="relative h-16 w-16">
                      <Image
                        src={
                          suggestion.secondParty.images.find(
                            (img) => img.isMain
                          )?.url || "/placeholders/user.png"
                        }
                        alt={`${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`}
                        fill
                        className="rounded-full object-cover border-2 border-purple-200"
                      />
                    </div>
                    <div>
                      <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                        <div className="flex items-center">
                          <MapPin className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.city || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Mail className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.email || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Phone className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.phone || "לא צוין"}
                          </span>
                        </div>
                        <div className="flex items-center">
                          <Calendar className="w-4 h-4 ml-1 text-purple-500" />
                          <span>
                            {suggestion.secondParty.profile?.birthDate
                              ? new Date(
                                  suggestion.secondParty.profile.birthDate
                                ).toLocaleDateString("he-IL")
                              : "לא צוין"}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <Button
                      variant="outline"
                      className="flex-1 border-purple-200 hover:bg-purple-50"
                      onClick={() =>
                        onAction("contact", {
                          suggestionId: suggestion.id,
                          partyId: suggestion.secondParty.id,
                          partyType: "second",
                        })
                      }
                    >
                      <MessageCircle className="w-4 h-4 ml-1" />
                      צור קשר
                    </Button>

                    {suggestion.status === "PENDING_SECOND_PARTY" && (
                      <Button
                        className="flex-1 bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("reminder", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.secondParty.id,
                            partyType: "second",
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-1" />
                        שלח תזכורת
                      </Button>
                    )}
                  </div>
                </div>

                <ProfileCard
                  profile={suggestion.secondParty.profile}
                  images={suggestion.secondParty.images}
                  questionnaire={secondPartyQuestionnaire}
                  viewMode="matchmaker"
                />

                <div className="mt-4 p-4 border rounded-lg bg-purple-50">
                  <h3 className="font-medium mb-2">
                    הערות לגבי {suggestion.secondParty.firstName}
                  </h3>
                  {suggestion.secondPartyNotes ? (
                    <p>{suggestion.secondPartyNotes}</p>
                  ) : (
                    <p className="text-gray-500">אין הערות ספציפיות</p>
                  )}
                </div>
              </div>
            </TabsContent>

            {/* Timeline Tab */}
            <TabsContent value="timeline" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-white rounded-xl shadow-sm border p-5 space-y-3 mb-4">
                  <h3 className="text-lg font-semibold flex items-center">
                    <Calendar className="w-5 h-5 ml-2 text-blue-600" />
                    התקדמות ההצעה
                  </h3>
                  <div className="flex justify-between items-center">
                    <div className="flex items-center">
                      <div className="p-2 rounded-full bg-blue-100 mr-2">
                        <Clock className="w-5 h-5 text-blue-600" />
                      </div>
                      <div>
                        <div className="font-medium">
                          נוצר: {formatDateSafely(suggestion.createdAt)}
                        </div>
                        <div className="text-sm text-gray-500">
                          פעילות אחרונה:{" "}
                          {formatDateSafely(suggestion.lastActivity)}
                        </div>
                      </div>
                    </div>
                    <Badge
                      className={`px-3 py-1.5 flex items-center gap-1 ${statusInfo.color}`}
                    >
                      <StatusIcon className="w-4 h-4" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border p-5">
                  <h3 className="text-lg font-semibold mb-4">
                    היסטוריית סטטוסים
                  </h3>

                  <ScrollArea className="h-[400px] pr-4">
                    {isLoading ? (
                      <div className="flex items-center justify-center h-32">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-700"></div>
                      </div>
                    ) : (
                      <Timeline
                        items={(suggestion?.statusHistory || []).map(
                          (history) => ({
                            title: getStatusInfo(
                              history.status as MatchSuggestionStatus
                            ).label,
                            description: history.notes || "אין הערות",
                            date:
                              typeof history.createdAt === "string"
                                ? new Date(history.createdAt)
                                : history.createdAt,
                            icon: history.status.includes("APPROVED")
                              ? CheckCircle
                              : history.status.includes("DECLINED")
                              ? XCircle
                              : history.status.includes("PENDING")
                              ? Clock
                              : AlertCircle,
                            iconColor: history.status.includes("APPROVED")
                              ? "text-green-600"
                              : history.status.includes("DECLINED")
                              ? "text-red-600"
                              : history.status.includes("PENDING")
                              ? "text-yellow-600"
                              : "text-blue-600",
                          })
                        )}
                      />
                    )}
                  </ScrollArea>

                  <div className="mt-4 flex justify-end">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() =>
                        onAction("exportHistory", {
                          suggestionId: suggestion.id,
                        })
                      }
                    >
                      <Download className="w-4 h-4 ml-1" />
                      ייצא היסטוריה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>

            {/* Communication Tab */}
            <TabsContent value="communication" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-blue-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">תקשורת</h3>
                  <p className="text-gray-600">
                    ניהול התקשורת עם הצדדים השונים בהצעה. שליחת הודעות ותזכורות.
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* First Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-blue-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-blue-600" />
                      תקשורת עם {suggestion.firstParty.firstName}{" "}
                      {suggestion.firstParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full justify-start border-blue-200 hover:bg-blue-50"
                        onClick={() =>
                          onAction("message", {
                            suggestionId: suggestion.id,
                            partyId: suggestion.firstParty.id,
                            partyType: "first",
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <MessageCircle className="w-4 h-4 ml-2" />
                        שלח הודעה
                      </Button>

                      {suggestion.status === "PENDING_FIRST_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                              partyType: "first",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.firstParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>

                  {/* Second Party Communication */}
                  <div className="bg-white rounded-xl shadow-sm border border-purple-100 p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-4 text-purple-800 flex items-center">
                      <User className="w-5 h-5 ml-2 text-purple-600" />
                      תקשורת עם {suggestion.secondParty.firstName}{" "}
                      {suggestion.secondParty.lastName}
                    </h4>

                    <div className="space-y-3">
                      <Button
                        variant="outline"
                        className="w-full"
                        onClick={() =>
                          onAction("edit", {
                            suggestionId: suggestion.id,
                            suggestion: suggestion, // הוסף את ההצעה המלאה
                          })
                        }
                      >
                        <Edit className="w-4 h-4 ml-2" />
                        ערוך פרטי הצעה
                      </Button>

                      {suggestion.status === "PENDING_SECOND_PARTY" && (
                        <Button
                          className="w-full justify-start bg-yellow-500 hover:bg-yellow-600"
                          onClick={() =>
                            onAction("reminder", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                              partyType: "second",
                            })
                          }
                        >
                          <AlertCircle className="w-4 h-4 ml-2" />
                          שלח תזכורת
                        </Button>
                      )}

                      {(suggestion.status === "FIRST_PARTY_APPROVED" ||
                        suggestion.status === "SECOND_PARTY_APPROVED") && (
                        <Button
                          variant="default"
                          className="w-full justify-start bg-green-600 hover:bg-green-700"
                          onClick={() =>
                            onAction("shareContacts", {
                              suggestionId: suggestion.id,
                              partyId: suggestion.secondParty.id,
                            })
                          }
                        >
                          <Send className="w-4 h-4 ml-2" />
                          שתף פרטי קשר
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {/* Meeting Arrangement Section */}
                {(suggestion.status === "CONTACT_DETAILS_SHARED" ||
                  suggestion.status === "DATING") && (
                  <div className="mt-6 bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Calendar className="w-5 h-5 ml-2 text-pink-600" />
                      תיאום פגישה
                    </h4>
                    <div className="space-y-3">
                      <p className="text-gray-600">
                        סיוע בתיאום פגישה בין הצדדים ותיעוד מועדי הפגישות
                      </p>
                      <div className="flex gap-2">
                        <Button
                          className="flex-1 bg-pink-600 hover:bg-pink-700"
                          onClick={() =>
                            onAction("scheduleMeeting", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Calendar className="w-4 h-4 ml-2" />
                          תאם פגישה חדשה
                        </Button>
                        <Button
                          variant="outline"
                          className="flex-1"
                          onClick={() =>
                            onAction("viewMeetings", {
                              suggestionId: suggestion.id,
                            })
                          }
                        >
                          <Clock className="w-4 h-4 ml-2" />
                          צפה בפגישות קודמות
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </TabsContent>

            {/* Actions Tab */}
            <TabsContent value="actions" className="p-0 m-0 h-full">
              <div className="p-6">
                <div className="bg-gradient-to-r from-gray-50 to-white rounded-xl shadow-sm border p-5 mb-6">
                  <h3 className="text-xl font-semibold mb-2">פעולות נוספות</h3>
                  <p className="text-gray-600">
                    פעולות נוספות שניתן לבצע על הצעת השידוך
                  </p>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {/* Status Change */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-blue-100 w-fit mb-3">
                      <RefreshCw className="w-6 h-6 text-blue-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">שינוי סטטוס</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עדכון סטטוס ההצעה בהתאם להתקדמות התהליך
                    </p>
                    <Button
                      className="w-full"
                      onClick={() => setShowStatusChange(true)}
                      disabled={allowedStatusChanges.length === 0}
                    >
                      <RefreshCw className="w-4 h-4 ml-2" />
                      שנה סטטוס
                    </Button>
                  </div>

                  {/* Edit Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-amber-100 w-fit mb-3">
                      <Edit className="w-6 h-6 text-amber-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">עריכת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      עריכת פרטי ההצעה, סיבת ההתאמה והערות
                    </p>
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() =>
                        onAction("edit", { suggestionId: suggestion.id })
                      }
                    >
                      <Edit className="w-4 h-4 ml-2" />
                      ערוך פרטי הצעה
                    </Button>
                  </div>

                  {/* Delete Suggestion */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <div className="p-2 rounded-full bg-red-100 w-fit mb-3">
                      <Trash2 className="w-6 h-6 text-red-600" />
                    </div>
                    <h4 className="text-lg font-semibold mb-3">מחיקת הצעה</h4>
                    <p className="text-sm text-gray-600 mb-4 h-12">
                      מחיקת ההצעה לצמיתות מהמערכת
                    </p>
                    <Button
                      variant="outline"
                      className="border-red-200 hover:bg-red-50 text-red-600"
                      onClick={() =>
                        onAction("delete", { suggestionId: suggestion.id })
                      }
                    >
                      <Trash2 className="w-4 h-4 ml-1" />
                      מחק הצעה
                    </Button>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Resend to Both Parties */}
                  {canChangeStatus(
                    suggestion.status as MatchSuggestionStatus
                  ).includes("PENDING_FIRST_PARTY") && (
                    <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                      <h4 className="text-lg font-semibold mb-3 flex items-center">
                        <Send className="w-5 h-5 ml-2 text-purple-600" />
                        שליחה מחדש
                      </h4>
                      <p className="text-sm text-gray-600 mb-3">
                        שליחת ההצעה מחדש לשני הצדדים
                      </p>
                      <Button
                        className="w-full bg-purple-600 hover:bg-purple-700"
                        onClick={() =>
                          onAction("resendToAll", {
                            suggestionId: suggestion.id,
                          })
                        }
                      >
                        <Send className="w-4 h-4 ml-2" />
                        שלח מחדש לשני הצדדים
                      </Button>
                    </div>
                  )}

                  {/* Export Suggestion Details */}
                  <div className="bg-white rounded-xl shadow-sm border p-5 hover:shadow-md transition-shadow">
                    <h4 className="text-lg font-semibold mb-3 flex items-center">
                      <Download className="w-5 h-5 ml-2 text-green-600" />
                      ייצוא פרטי הצעה
                    </h4>
                    <p className="text-sm text-gray-600 mb-3">
                      ייצוא כל פרטי ההצעה בפורמט PDF או CSV
                    </p>
                    <Button
                      variant="outline"
                      className="w-full border-green-200 hover:bg-green-50 text-green-700"
                      onClick={() =>
                        onAction("export", { suggestionId: suggestion.id })
                      }
                    >
                      <Download className="w-4 h-4 ml-2" />
                      ייצא פרטי הצעה
                    </Button>
                  </div>
                </div>
              </div>
            </TabsContent>
          </div>
        </Tabs>
        {/* Status Change Dialog */}
        {showStatusChange && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-xl max-w-md w-full shadow-lg">
              <h3 className="text-xl font-bold mb-4 flex items-center">
                <RefreshCw className="w-5 h-5 ml-2 text-blue-600" />
                שינוי סטטוס הצעה
              </h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס נוכחי
                  </label>
                  <div className="flex items-center p-2 bg-gray-50 rounded border">
                    <StatusIcon
                      className={`w-5 h-5 ml-2 ${statusInfo.color}`}
                    />
                    <span className="font-medium">{statusInfo.label}</span>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    סטטוס חדש
                  </label>
                  <Select
                    value={newStatus || undefined}
                    onValueChange={(value) => {
                      console.log("Selected new status:", value);
                      setNewStatus(value as MatchSuggestionStatus);
                    }}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="בחר/י סטטוס חדש" />
                    </SelectTrigger>
                    <SelectContent className="max-h-80 overflow-y-auto">
                      {/* מציג את כל הסטטוסים האפשריים במערכת */}
                      {Object.entries(getAllStatusLabels()).map(
                        ([status, label]) => (
                          <SelectItem key={status} value={status}>
                            {label}
                          </SelectItem>
                        )
                      )}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">
                    הערות לשינוי סטטוס
                  </label>
                  <Textarea
                    value={statusChangeNote}
                    onChange={(e) => setStatusChangeNote(e.target.value)}
                    placeholder="הערות אופציונליות לשינוי הסטטוס..."
                    className="min-h-[100px] resize-none"
                  />
                </div>

                <div className="flex justify-end gap-2 pt-2">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowStatusChange(false);
                      setNewStatus(null);
                      setStatusChangeNote("");
                    }}
                  >
                    ביטול
                  </Button>
                  <Button
                    onClick={handleStatusChange}
                    disabled={!newStatus || isLoading}
                    className="bg-blue-600 hover:bg-blue-700"
                  >
                    {isLoading ? (
                      <>
                        <div className="h-4 w-4 ml-2 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                        מעדכן...
                      </>
                    ) : (
                      "שמור שינוי"
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}
        <DialogFooter className="px-6 py-4 border-t bg-gray-50">
          <div className="flex justify-between w-full">
            <Button
              variant="outline"
              className="border-red-200 hover:bg-red-50 text-red-600"
              onClick={() =>
                onAction("delete", { suggestionId: suggestion.id })
              }
            >
              <Trash2 className="w-4 h-4 ml-1" />
              מחק הצעה
            </Button>

            <div className="flex gap-2">
              <Button variant="outline" onClick={onClose}>
                סגור
              </Button>
              <Button
                // תיקון: המקום השלישי בו צריך לוודא שהפונקציה מופעלת נכון
                onClick={() => setShowStatusChange(true)}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <RefreshCw className="w-4 h-4 ml-1" />
                עדכן סטטוס
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default SuggestionDetailsDialog;
--- End of Content for SuggestionDetailsDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\hooks\useMatchmaking.ts
--------------------------------------------------------------------------------
Content:
// /hooks/useMatchmaking.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { AvailabilityStatus } from '@prisma/client';
import { calculateMatchScore, MatchScore } from '../utils/matchingAlgorithm';
import { MATCH_THRESHOLDS } from '../../new/constants/matchingCriteria';
import type { User } from '@/types/next-auth';
// Define types and interfaces
interface UseMatchmakingProps {
  candidates?: User[];
  onMatchFound?: (match: PotentialMatch) => void;
  onMatchScoreUpdate?: (scores: MatchScoreMap) => void;
}

export interface PotentialMatch {
  candidateA: User;
  candidateB: User;
  score: MatchScore;
  matchDate?: Date;
  status: 'new' | 'suggested' | 'rejected';
  lastUpdated: Date;
}

type MatchScoreMap = Map<string, Map<string, MatchScore>>;

interface MatchSuggestion {
  candidate: User;
  score: MatchScore;
  matchDate: Date;
}

export const useMatchmaking = ({
  candidates = [],
  onMatchScoreUpdate
}: UseMatchmakingProps = {}) => {
  // State declarations
  const [matchScores, setMatchScores] = useState<MatchScoreMap>(new Map());
  const [suggestedMatches, setSuggestedMatches] = useState<PotentialMatch[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastCalculation, setLastCalculation] = useState<Date | null>(null);

  // Calculate all possible matches
  const calculateAllMatches = useCallback(() => {
    setIsCalculating(true);
    const newScores = new Map<string, Map<string, MatchScore>>();
    const newMatches: PotentialMatch[] = [];

    candidates.forEach((candidateA, indexA) => {
      const candidateAScores = new Map<string, MatchScore>();
      newScores.set(candidateA.id, candidateAScores);

      candidates.slice(indexA + 1).forEach(candidateB => {
        // Check basic compatibility conditions
        if (
          candidateA.profile?.gender === candidateB.profile?.gender ||
          candidateA.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
          candidateB.profile?.availabilityStatus !== AvailabilityStatus.AVAILABLE
        ) {
          return;
        }

        // Calculate match score
        const matchScore = calculateMatchScore(candidateA.profile, candidateB.profile);
        
        if (matchScore) {
          candidateAScores.set(candidateB.id, matchScore);

          // Add to potential matches if score is good enough
          if (matchScore.score >= MATCH_THRESHOLDS.GOOD) {
            newMatches.push({
              candidateA,
              candidateB,
              score: matchScore,
              matchDate: new Date(),
              status: 'new',
              lastUpdated: new Date()
            });
          }
        }
      });
    });

    setMatchScores(newScores);
    setSuggestedMatches(prev => {
      const existing = new Set(prev.map(m => 
        `${m.candidateA.id}-${m.candidateB.id}`
      ));
      
      return [
        ...prev,
        ...newMatches.filter(m => 
          !existing.has(`${m.candidateA.id}-${m.candidateB.id}`)
        )
      ].sort((a, b) => b.score.score - a.score.score);
    });

    onMatchScoreUpdate?.(newScores);
    setIsCalculating(false);
    setLastCalculation(new Date());
  }, [candidates, onMatchScoreUpdate]);

  // Recalculate matches when candidates list changes
  useEffect(() => {
    if (candidates.length > 0 && !isCalculating) {
      calculateAllMatches();
    }
  }, [candidates, calculateAllMatches, isCalculating]);

  // Get best matches for a specific candidate
  const getBestMatchesForCandidate = useCallback((
    candidateId: string,
    limit: number = 5
  ): MatchSuggestion[] => {
    const candidate = candidates.find(c => c.id === candidateId);
    if (!candidate) return [];

    const matches: MatchSuggestion[] = [];
    const candidateScores = matchScores.get(candidateId);

    if (candidateScores) {
      candidateScores.forEach((score, otherId) => {
        const otherCandidate = candidates.find(c => c.id === otherId);
        if (otherCandidate && score.score >= MATCH_THRESHOLDS.FAIR) {
          matches.push({
            candidate: otherCandidate,
            score,
            matchDate: new Date()
          });
        }
      });
    }

    return matches
      .sort((a, b) => b.score.score - a.score.score)
      .slice(0, limit);
  }, [candidates, matchScores]);

  // Analyze matches by categories
  const matchAnalytics = useMemo(() => {
    const analytics = {
      total: suggestedMatches.length,
      byCategory: {
        excellent: 0,
        good: 0,
        fair: 0,
        poor: 0
      },
      averageScore: 0,
      recentMatches: [] as PotentialMatch[]
    };

    suggestedMatches.forEach(match => {
      if (match.score.score >= MATCH_THRESHOLDS.EXCELLENT) {
        analytics.byCategory.excellent++;
      } else if (match.score.score >= MATCH_THRESHOLDS.GOOD) {
        analytics.byCategory.good++;
      } else if (match.score.score >= MATCH_THRESHOLDS.FAIR) {
        analytics.byCategory.fair++;
      } else {
        analytics.byCategory.poor++;
      }
    });

    analytics.averageScore = suggestedMatches.reduce(
      (sum, match) => sum + match.score.score,
      0
    ) / (suggestedMatches.length || 1);

    // Get recent matches (last week)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    analytics.recentMatches = suggestedMatches
      .filter(match => match.matchDate && match.matchDate >= oneWeekAgo)
      .sort((a, b) => 
        (b.matchDate?.getTime() || 0) - (a.matchDate?.getTime() || 0)
      );

    return analytics;
  }, [suggestedMatches]);

  // Update match status
  const updateMatchStatus = useCallback((
    candidateAId: string,
    candidateBId: string,
    status: 'suggested' | 'rejected'
  ) => {
    setSuggestedMatches(prev => prev.map(match => {
      if (
        (match.candidateA.id === candidateAId && match.candidateB.id === candidateBId) ||
        (match.candidateA.id === candidateBId && match.candidateB.id === candidateAId)
      ) {
        return {
          ...match,
          status,
          lastUpdated: new Date()
        };
      }
      return match;
    }));
  }, []);

  // Return hook interface
  return {
    matchScores,
    suggestedMatches,
    isCalculating,
    lastCalculation,
    matchAnalytics,
    getBestMatchesForCandidate,
    calculateAllMatches,
    updateMatchStatus
  };
};

export default useMatchmaking;
--- End of Content for useMatchmaking.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\ManagerSuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useMemo, useState } from "react";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Users } from "lucide-react";

import type { Suggestion, SuggestionFilters } from "@/types/suggestions";
import SuggestionDetailsDialog from "../details/SuggestionDetailsDialog";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ManagerSuggestionsListProps {
  suggestions: Suggestion[];
  filters: SuggestionFilters;
  searchQuery: string;
  type: "active" | "pending" | "history";
  onSuggestionDeleted?: (id: string) => void;
}

const ManagerSuggestionsList: React.FC<ManagerSuggestionsListProps> = ({
  suggestions,
  filters,
  searchQuery,
  type,
  onSuggestionDeleted,
}) => {
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<Suggestion | null>(null);
  const [, setShowDeleteDialog] = useState(false);
  const [suggestionToDelete, setSuggestionToDelete] = useState<string | null>(
    null
  );

  const filteredSuggestions = useMemo(() => {
    return suggestions.filter((suggestion) => {
      // Base status filter
      if (
        type === "active" &&
        ["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }
      if (type === "pending" && !suggestion.status.includes("PENDING")) {
        return false;
      }
      if (
        type === "history" &&
        !["CLOSED", "CANCELLED", "EXPIRED"].includes(suggestion.status)
      ) {
        return false;
      }

      // Search query
      if (searchQuery && suggestion.firstParty && suggestion.secondParty) {
        const searchTerm = searchQuery.toLowerCase();
        const searchableText = `
          ${suggestion.firstParty.firstName} 
          ${suggestion.firstParty.lastName}
          ${suggestion.secondParty.firstName}
          ${suggestion.secondParty.lastName}
          ${suggestion.matchingReason || ""}
        `.toLowerCase();

        if (!searchableText.includes(searchTerm)) {
          return false;
        }
      }

      // Priority filter
      if (
        filters.priority?.length &&
        !filters.priority.includes(suggestion.priority)
      ) {
        return false;
      }

      // Date range filter
      if (filters.dateRange) {
        const createdAt = new Date(suggestion.createdAt);
        if (
          createdAt < filters.dateRange.start ||
          createdAt > filters.dateRange.end
        ) {
          return false;
        }
      }

      return true;
    });
  }, [suggestions, filters, searchQuery, type]);

  const confirmDelete = async () => {
    if (!suggestionToDelete) return;

    try {
      const response = await fetch(
        `/api/matchmaker/suggestions/${suggestionToDelete}/delete`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to delete suggestion");
      }

      toast.success("ההצעה נמחקה בהצלחה");
      if (onSuggestionDeleted) {
        onSuggestionDeleted(suggestionToDelete);
      }
    } catch (error) {
      console.error("Error deleting suggestion:", error);
      toast.error("שגיאה במחיקת ההצעה");
    } finally {
      setShowDeleteDialog(false);
      setSuggestionToDelete(null);
    }
  };

  const handleAction = (action: string) => {
    console.log(`Action ${action} for suggestion ${selectedSuggestion?.id}`);
  };

  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <Users className="w-12 h-12 mb-4" />
        <p>לא נמצאו הצעות</p>
      </div>
    );
  }

  return (
    <>
      <ScrollArea className="h-[600px] rounded-md border">
        <div className="p-4 space-y-4">
          {filteredSuggestions.map((suggestion) => {
            if (!suggestion.firstParty || !suggestion.secondParty) {
              return null;
            }

            return (
              <Card
                key={suggestion.id}
                className="p-4 hover:shadow-md transition-shadow"
              >
                {/* Rest of the JSX remains the same */}
              </Card>
            );
          })}
        </div>
      </ScrollArea>

      <SuggestionDetailsDialog
        suggestion={selectedSuggestion}
        isOpen={!!selectedSuggestion}
        onClose={() => setSelectedSuggestion(null)}
        onAction={handleAction}
      />

      <AlertDialog>
        {" "}
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>האם את/ה בטוח/ה?</AlertDialogTitle>
            <AlertDialogDescription>
              פעולה זו תמחק את ההצעה לצמיתות ולא ניתן יהיה לשחזר אותה.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              מחיקה
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default ManagerSuggestionsList;
--- End of Content for ManagerSuggestionsList.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\list\SuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useMemo } from "react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Search, Filter, SortDesc } from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";
import SuggestionCard from "../cards/SuggestionCard";
import { LoadingContainer } from "../../new/shared/LoadingStates";
import type {
  Suggestion,
  ActionAdditionalData,
  SuggestionStatusHistory,
} from "@/types/suggestions";

interface PartyInfo {
  id: string;
  firstName: string;
  lastName: string;
  profile: UserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: SuggestionStatusHistory[]; // הוספת השדה החסר
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  isLoading?: boolean;
  onAction: (
    type:
      | "view"
      | "contact"
      | "message"
      | "edit"
      | "delete"
      | "resend"
      | "changeStatus"
      | "reminder",
    suggestion: Suggestion,
    additionalData?: ActionAdditionalData
  ) => void;
  className?: string;
}

const SORT_OPTIONS = [
  { value: "latest", label: "החדשים ביותר" },
  { value: "oldest", label: "הישנים ביותר" },
  { value: "deadline", label: "לפי תאריך יעד" },
  { value: "priority", label: "לפי דחיפות" },
];

const STATUS_OPTIONS = [
  { value: "PENDING_FIRST_PARTY", label: "ממתין לצד א׳" },
  { value: "PENDING_SECOND_PARTY", label: "ממתין לצד ב׳" },
  { value: "FIRST_PARTY_APPROVED", label: "צד א׳ אישר" },
  { value: "SECOND_PARTY_APPROVED", label: "צד ב׳ אישר" },
  { value: "CONTACT_DETAILS_SHARED", label: "פרטי קשר שותפו" },
  { value: "DATING", label: "בתהליך היכרות" },
];

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions,
  isLoading = false,
  onAction,
  className,
}) => {
  // Filters state
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState("latest");
  const [statusFilter, setStatusFilter] = useState<string[]>([]);
  const [showFilters, setShowFilters] = useState(false);

  // Filter and sort suggestions
  const filteredSuggestions = useMemo(() => {
    let result = [...suggestions];

    // Apply status filter
    if (statusFilter.length > 0) {
      result = result.filter((s) => statusFilter.includes(s.status));
    }

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (s) =>
          s.firstParty.firstName.toLowerCase().includes(query) ||
          s.firstParty.lastName.toLowerCase().includes(query) ||
          s.secondParty.firstName.toLowerCase().includes(query) ||
          s.secondParty.lastName.toLowerCase().includes(query) ||
          s.firstParty.profile.city?.toLowerCase().includes(query) ||
          s.secondParty.profile.city?.toLowerCase().includes(query)
      );
    }

    // Apply sorting
    switch (sortBy) {
      case "latest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
        );
        break;
    }

    return result;
  }, [suggestions, searchQuery, sortBy, statusFilter]);

  return (
    <div className={className}>
      {/* Filters Bar */}
      <div className="mb-6 space-y-4">
        <div className="flex gap-4">
          <div className="relative flex-1">
            <Search className="absolute right-3 top-2.5 h-4 w-4 text-gray-500" />
            <Input
              placeholder="חיפוש לפי שם או עיר..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 text-right"
            />
          </div>

          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-48">
              <SortDesc className="w-4 h-4 ml-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {SORT_OPTIONS.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Button
            variant="outline"
            onClick={() => setShowFilters(!showFilters)}
          >
            <Filter className="w-4 h-4 ml-2" />
            סינון
          </Button>
        </div>

        {showFilters && (
          <div className="flex gap-4">
            {STATUS_OPTIONS.map((status) => (
              <Button
                key={status.value}
                variant={
                  statusFilter.includes(status.value) ? "default" : "outline"
                }
                onClick={() => {
                  setStatusFilter((prev) =>
                    prev.includes(status.value)
                      ? prev.filter((s) => s !== status.value)
                      : [...prev, status.value]
                  );
                }}
                className="text-sm"
              >
                {status.label}
              </Button>
            ))}
          </div>
        )}
      </div>

      {/* Suggestions Grid */}
      {isLoading ? (
        <LoadingContainer>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <div
                key={i}
                className="h-64 bg-gray-100 rounded-lg animate-pulse"
              />
            ))}
          </div>
        </LoadingContainer>
      ) : (
        // בערך בשורה 196 - שנה את הגריד להצגה מימין לשמאל
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 grid-flow-row-dense">
          {filteredSuggestions.map((suggestion) => (
            <SuggestionCard
              key={suggestion.id}
              suggestion={suggestion as unknown as Suggestion}
              onAction={onAction}
              className="rtl" // הוסף מחלקה זו
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default SuggestionsList;
--- End of Content for SuggestionsList.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\NotificationService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/NotificationService.ts

import { MatchSuggestionStatus } from '@prisma/client';
import { SuggestionWithParties } from '../suggestions/StatusTransitionService';

export type RecipientInfo = {
  email: string;
  phone?: string; // Phone number with international prefix, e.g.: +972501234567
  name: string;
};

export type NotificationContent = {
  subject: string;
  body: string;
  htmlBody?: string; // HTML version for email
};

export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
  channels: NotificationChannel[];
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
  priority?: 'high' | 'normal' | 'low';
  attachments?: Array<{
    filename: string;
    content: Buffer | string;
    contentType: string;
  }>;
  customMessage?: string;
  metadata?: Record<string, unknown>;
};

export interface NotificationAdapter {
  canSendTo(recipient: RecipientInfo): boolean;
  send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean>;
  getChannelType(): NotificationChannel;
}

export class NotificationService {
  private static instance: NotificationService;
  private adapters: Map<NotificationChannel, NotificationAdapter> = new Map();

  private constructor() {}

  public static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  public registerAdapter(adapter: NotificationAdapter): void {
    this.adapters.set(adapter.getChannelType(), adapter);
    console.log(`Registered ${adapter.getChannelType()} adapter`);
  }

  public async sendNotification(
    recipient: RecipientInfo,
    content: NotificationContent,
    options: NotificationOptions
  ): Promise<Record<NotificationChannel, boolean>> {
    const results: Record<NotificationChannel, boolean> = {} as Record<NotificationChannel, boolean>;
    console.log(`Attempting to send notification to ${recipient.name} via channels:`, options.channels);

    for (const channel of options.channels) {
      const adapter = this.adapters.get(channel);
      if (!adapter) {
        console.warn(`No adapter registered for channel: ${channel}`);
        results[channel] = false;
        continue;
      }

      if (!adapter.canSendTo(recipient)) {
        console.warn(`Cannot send to recipient via ${channel}: missing required info`);
        results[channel] = false;
        continue;
      }

      try {
        console.log(`Sending ${channel} notification to ${recipient.name}`);
        results[channel] = await adapter.send(recipient, content);
        console.log(`${channel} notification sent successfully: ${results[channel]}`);
      } catch (error) {
        console.error(`Error sending notification via ${channel}:`, error);
        results[channel] = false;
      }
    }

    return results;
  }

  // Dedicated method for handling suggestion-related notifications
  public async handleSuggestionStatusChange(
    suggestion: SuggestionWithParties,
    options: Partial<NotificationOptions> = {}
  ): Promise<void> {
    console.log(`Processing notifications for suggestion ${suggestion.id} with status ${suggestion.status}`);
    
    const templateContent = this.getSuggestionTemplate(suggestion, options.customMessage);
    if (!templateContent) {
      console.log(`No template found for status ${suggestion.status} - skipping notification`);
      return;
    }
  
    const recipientsWithChannels = this.getRecipientsForSuggestion(suggestion);
    console.log(`Found ${recipientsWithChannels.length} potential recipients`);
  
    for (const { recipient, preferredChannels } of recipientsWithChannels) {
      // Filter recipients based on notifyParties if provided
      if (options.notifyParties) {
        const recipientType = this.getRecipientType(recipient, suggestion);
        if (!recipientType || !options.notifyParties.includes(recipientType)) {
          console.log(`Skipping recipient ${recipient.name} (${recipientType}) - not in notifyParties`, options.notifyParties);
          continue;
        }
      }
      
      const channelsToUse = options.channels || preferredChannels || ['email'];
      console.log(`Sending notification to ${recipient.name} via channels:`, channelsToUse);
      
      await this.sendNotification(
        recipient,
        templateContent,
        { ...options, channels: channelsToUse }
      );
    }
    
    console.log(`Finished processing notifications for suggestion ${suggestion.id}`);
  }

  // Helper method to determine recipient type
  private getRecipientType(
    recipient: RecipientInfo, 
    suggestion: SuggestionWithParties
  ): 'first' | 'second' | 'matchmaker' | null {
    if (recipient.email === suggestion.firstParty.email) {
      return 'first';
    } else if (recipient.email === suggestion.secondParty.email) {
      return 'second';
    } else if (recipient.email === suggestion.matchmaker.email) {
      return 'matchmaker';
    }
    return null;
  }

  private getSuggestionTemplate(
    suggestion: SuggestionWithParties,
    customMessage?: string
  ): NotificationContent | null {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    // If there's a custom message, use it instead of the template
    if (customMessage) {
      const reviewUrl = `${baseUrl}/suggestions/${suggestion.id}/review`;
      return {
        subject: "עדכון בהצעת שידוך",
        body: `שלום,\n\n${customMessage}\n\nלצפייה בפרטי ההצעה: ${reviewUrl}\n\nבברכה,\nמערכת השידוכים`,
        htmlBody: `
          <div dir="rtl">
            <h2>שלום,</h2>
            <p>${customMessage}</p>
            <p>לצפייה בפרטי ההצעה: <a href="${reviewUrl}">לחץ כאן</a></p>
            <p>בברכה,<br>מערכת השידוכים</p>
          </div>
        `
      };
    }
    
    // Otherwise use the template based on status
    switch (suggestion.status) {
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.firstParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.firstParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>לצפייה בפרטי ההצעה ומענה, אנא היכנס/י לקישור הבא:</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בהצעה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד הראשון',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.\n\nההצעה תועבר כעת באופן אוטומטי לצד השני.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} אישר/ה את הצעת השידוך.</p><p>ההצעה תועבר כעת באופן אוטומטי לצד השני.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        return {
          subject: 'הצעת שידוך חדשה עבורך',
          body: `שלום ${suggestion.secondParty.firstName},\n\n${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.\n\nהצד הראשון כבר אישר את ההצעה.\n\nלצפייה בפרטי ההצעה ומענה: ${baseUrl}/suggestions/${suggestion.id}/review\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.secondParty.firstName},</h2><p>${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} הציע/ה עבורך הצעת שידוך.</p><p>הצד הראשון כבר אישר את ההצעה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/review">לצפייה בפרטי ההצעה ומענה</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך אושרה על ידי הצד השני',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.\n\nשני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} אישר/ה את הצעת השידוך.</p><p>שני הצדדים אישרו את ההצעה. ניתן כעת לשתף פרטי קשר.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        return {
          subject: 'עדכון סטטוס - הצעת שידוך נדחתה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\n${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} דחה/תה את הצעת השידוך.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };
    
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Prepare contact details with multi-line support
        const firstPartyDetails = this.formatUserDetails(suggestion.firstParty);
        const secondPartyDetails = this.formatUserDetails(suggestion.secondParty);
        
        return {
          subject: 'פרטי קשר להצעת השידוך',
          body: `ברכות! שני הצדדים אישרו את הצעת השידוך.\n\nפרטי הקשר של הצד הראשון:\n${firstPartyDetails}\n\nפרטי הקשר של הצד השני:\n${secondPartyDetails}\n\nאנא צרו קשר בהקדם לתיאום פגישה ראשונה.\n\nבהצלחה!`,
          htmlBody: `<div dir="rtl"><h2>ברכות! שני הצדדים אישרו את הצעת השידוך.</h2><p>פרטי הקשר של הצד הראשון:</p><pre>${firstPartyDetails}</pre><p>פרטי הקשר של הצד השני:</p><pre>${secondPartyDetails}</pre><p>אנא צרו קשר בהקדם לתיאום פגישה ראשונה.</p><p>בהצלחה!</p></div>`
        };
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        return {
          subject: 'בקשה למשוב על הפגישה הראשונה',
          body: `שלום,\n\nנשמח לקבל את המשוב שלך על הפגישה הראשונה.\n\nלשליחת המשוב: ${baseUrl}/suggestions/${suggestion.id}/feedback\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום,</h2><p>נשמח לקבל את המשוב שלך על הפגישה הראשונה.</p><p><a href="${baseUrl}/suggestions/${suggestion.id}/feedback">לשליחת המשוב</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.THINKING_AFTER_DATE:
        return {
          subject: 'בקשת זמן למחשבה לאחר הפגישה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nאחד הצדדים ביקש זמן למחשבה לאחר הפגישה.\n\nלצפייה בפרטים נוספים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>אחד הצדדים ביקש זמן למחשבה לאחר הפגישה.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים נוספים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.DATING:
        return {
          subject: 'עדכון סטטוס - בתהליך היכרות',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהזוג נמצא בתהליך היכרות.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הזוג נמצא בתהליך היכרות.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.ENGAGED:
        return {
          subject: 'מזל טוב! - אירוסין',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על האירוסין ומאחלים לכם המון הצלחה בהמשך הדרך.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.MARRIED:
        return {
          subject: 'מזל טוב! - חתונה',
          body: `מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!\n\nאנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>מזל טוב ${suggestion.firstParty.firstName} ו${suggestion.secondParty.firstName}!</h2><p>אנו שמחים לשמוע על החתונה ומאחלים לכם חיים מאושרים יחד.</p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      case MatchSuggestionStatus.EXPIRED:
        return {
          subject: 'הצעת השידוך פגה',
          body: `שלום ${suggestion.matchmaker.firstName},\n\nהצעת השידוך פגה עקב חוסר מענה במועד.\n\nלצפייה בפרטים: ${baseUrl}/dashboard/suggestions/${suggestion.id}\n\nבברכה,\nצוות המערכת`,
          htmlBody: `<div dir="rtl"><h2>שלום ${suggestion.matchmaker.firstName},</h2><p>הצעת השידוך פגה עקב חוסר מענה במועד.</p><p><a href="${baseUrl}/dashboard/suggestions/${suggestion.id}">לצפייה בפרטים</a></p><p>בברכה,<br>צוות המערכת</p></div>`
        };

      default:
        // For other statuses, return null to skip notification
        console.log(`No template defined for status: ${suggestion.status}`);
        return null;
    }
  }

  private getRecipientsForSuggestion(suggestion: SuggestionWithParties): Array<{
    recipient: RecipientInfo;
    preferredChannels: NotificationChannel[];
  }> {
    const recipients: Array<{
      recipient: RecipientInfo;
      preferredChannels: NotificationChannel[];
    }> = [];
    
    // Logic to determine recipients based on suggestion status
    switch (suggestion.status) {
      case MatchSuggestionStatus.DRAFT:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email'] // Email only for drafts
        });
        break;
      
      case MatchSuggestionStatus.PENDING_FIRST_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.firstParty.email,
            phone: suggestion.firstParty.phone || undefined,
            name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.PENDING_SECOND_PARTY:
        recipients.push({
          recipient: {
            email: suggestion.secondParty.email,
            phone: suggestion.secondParty.phone || undefined,
            name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for candidates
        });
        break;
      
      case MatchSuggestionStatus.SECOND_PARTY_APPROVED:
      case MatchSuggestionStatus.SECOND_PARTY_DECLINED:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL:
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email', 'whatsapp'] // Email and WhatsApp for matchmaker
        });
        break;
      
      case MatchSuggestionStatus.CONTACT_DETAILS_SHARED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email']
          }
        );
        break;
      
      case MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK:
        // Send to both parties
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;
      
      case MatchSuggestionStatus.ENGAGED:
      case MatchSuggestionStatus.MARRIED:
        // Send to both parties and matchmaker
        recipients.push(
          {
            recipient: {
              email: suggestion.firstParty.email,
              phone: suggestion.firstParty.phone || undefined,
              name: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.secondParty.email,
              phone: suggestion.secondParty.phone || undefined,
              name: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          },
          {
            recipient: {
              email: suggestion.matchmaker.email,
              phone: suggestion.matchmaker.phone || undefined,
              name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
            },
            preferredChannels: ['email', 'whatsapp']
          }
        );
        break;

      default:
        // Default: send to matchmaker only
        recipients.push({
          recipient: {
            email: suggestion.matchmaker.email,
            phone: suggestion.matchmaker.phone || undefined,
            name: `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`
          },
          preferredChannels: ['email']
        });
        break;
    }

    return recipients;
  }

  // Helper function to format contact details
  private formatUserDetails(user: { 
    firstName: string; 
    lastName: string; 
    email: string; 
    phone?: string | null 
  }): string {
    const details = [
      `שם: ${user.firstName} ${user.lastName}`,
      `אימייל: ${user.email}`,
    ];

    if (user.phone) {
      details.push(`טלפון: ${user.phone}`);
    }

    return details.join('\n');
  }
}

export const notificationService = NotificationService.getInstance();
--- End of Content for NotificationService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\initNotifications.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/initNotifications.ts

import { notificationService } from './NotificationService';
import { emailAdapter } from './adapters/EmailAdapter';
import { whatsAppAdapter } from './adapters/WhatsAppAdapter';

// Define notification channel type
export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationOptions = {
    channels: NotificationChannel[];
    notifyParties?: ('first' | 'second' | 'matchmaker')[];
    customMessage?: string;
  };

/**
 * Initializes the notification service by registering all available adapters
 * @returns The initialized notification service
 */
export function initNotificationService() {
  // Register adapters
  notificationService.registerAdapter(emailAdapter);
  notificationService.registerAdapter(whatsAppAdapter);
  
  console.log('Notification service initialized with email and WhatsApp adapters');
  
  return notificationService;
}
--- End of Content for initNotifications.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\EmailAdapter.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/notification/adapters/EmailAdapter.ts

import { NotificationAdapter, NotificationChannel, RecipientInfo, NotificationContent } from '../NotificationService';
import nodemailer from 'nodemailer';

export class EmailAdapter implements NotificationAdapter {
  private static instance: EmailAdapter;
  private transporter: nodemailer.Transporter;

  private constructor() {
    // Configure the transporter exactly like in EmailService
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER || '',
        pass: process.env.GMAIL_APP_PASSWORD || '',
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Verify email configuration on initialization
    this.verifyEmailConfig();
  }

  private async verifyEmailConfig(): Promise<void> {
    try {
      await this.transporter.verify();
      console.log('Email configuration verified successfully');
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      // Don't throw, to allow the system to continue even if verification fails
    }
  }

  public static getInstance(): EmailAdapter {
    if (!EmailAdapter.instance) {
      EmailAdapter.instance = new EmailAdapter();
    }
    return EmailAdapter.instance;
  }

  public getChannelType(): NotificationChannel {
    return 'email';
  }

  public canSendTo(recipient: RecipientInfo): boolean {
    return !!recipient.email;
  }

  public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
    try {
      const result = await this.transporter.sendMail({
        from: `${process.env.EMAIL_FROM_NAME || 'מערכת השידוכים'} <${process.env.GMAIL_USER || ''}>`,
        to: recipient.email,
        subject: content.subject,
        text: content.body,
        html: content.htmlBody || content.body.replace(/\n/g, '<br>'),
      });

      console.log('Email sent successfully:', {
        messageId: result.messageId,
        response: result.response,
        to: recipient.email,
        subject: content.subject
      });

      return true;
    } catch (error) {
      console.error('Detailed error sending email:', {
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        recipient: recipient.email,
        subject: content.subject
      });
      return false;
    }
  }
}

export const emailAdapter = EmailAdapter.getInstance();
--- End of Content for EmailAdapter.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\notification\adapters\WhatsAppAdapter.ts
--------------------------------------------------------------------------------
Content:
// lib/WhatsAppAdapter.ts
import {
  NotificationAdapter,
  NotificationChannel,
  RecipientInfo,
  NotificationContent as BaseNotificationContent
} from '../NotificationService'; // Assuming NotificationService.ts exists in the same directory
import twilio from 'twilio';
// Import the specific type for message creation options if available
import { MessageListInstanceCreateOptions } from 'twilio/lib/rest/api/v2010/account/message';

// --- Define an extended NotificationContent interface ---
// This adds the optional adapter-specific data structure
interface NotificationContent extends BaseNotificationContent {
  _adapterSpecificData?: {
      contentSid?: string;
      contentVariables?: string; // Should be a JSON string
      // Add other potential adapter-specific fields here
  };
}
// --- End Interface Extension ---

// --- Type Guard for Twilio-like Errors ---
interface PotentialTwilioError {
  code?: number | string;
  message?: string;
  // Add other potential properties like 'status', 'moreInfo', etc. if needed
}

/**
* Type guard to check if an unknown error object might be a Twilio API error
* by checking for the presence of 'code' or 'message' properties.
* @param error The unknown value caught in a catch block.
* @returns True if the error object has properties common to Twilio errors, false otherwise.
*/
function isPotentialTwilioError(error: unknown): error is PotentialTwilioError {
  // Check if it's a non-null object and has either 'code' or 'message' property
  return typeof error === 'object' && error !== null && ('code' in error || 'message' in error);
}
// --- End Type Guard ---

// --- Helper: Logger (optional but recommended) ---
// Using Record<string, unknown> or object instead of any
const logger = {
info: (message: string, meta?: Record<string, unknown> | object) => {
  console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
warn: (message: string, meta?: Record<string, unknown> | object) => {
  console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', service: 'WhatsAppAdapter', message, ...(meta || {}) }));
},
error: (message: string, meta?: Record<string, unknown> | object) => {
  let logMeta = meta || {};
  // If the meta object itself is an Error, extract relevant info
  if (meta instanceof Error) {
      logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
  } else if (isPotentialTwilioError(meta)) {
      // If it's potentially a Twilio error passed directly
      logMeta = { code: meta.code, message: meta.message, ...meta };
  }
  console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', service: 'WhatsAppAdapter', message, ...logMeta }));
},
};
// --- End Logger ---


export class WhatsAppAdapter implements NotificationAdapter {
// Singleton instance
private static instance: WhatsAppAdapter;
// Twilio client instance (typed)
private client: twilio.Twilio | null = null;
// Configured Twilio WhatsApp sender number
private fromNumber: string = '';

/**
 * Private constructor to enforce singleton pattern.
 * Initializes the Twilio client using environment variables.
 */
private constructor() {
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  this.fromNumber = process.env.TWILIO_WHATSAPP_NUMBER || ''; // Get number from env

  // Validate configuration
  if (!accountSid || !authToken || !this.fromNumber) {
    logger.error('Missing Twilio configuration details', {
        hasSid: !!accountSid,
        hasToken: !!authToken,
        hasWhatsAppNumber: !!this.fromNumber,
        detail: "WhatsApp notifications will be unavailable."
    });
    // Do not throw, allow graceful degradation if possible
  } else {
    try {
      // Initialize Twilio client
      this.client = twilio(accountSid, authToken);
      logger.info('Twilio client initialized successfully', { fromWhatsAppNumber: this.fromNumber });
    } catch (error: unknown) { // Catch as unknown
      logger.error('Failed to initialize Twilio client during constructor', { error });
      this.client = null; // Ensure client is null on initialization failure
    }
  }
}

/**
 * Gets the singleton instance of the WhatsAppAdapter.
 * @returns The WhatsAppAdapter instance.
 */
public static getInstance(): WhatsAppAdapter {
  if (!WhatsAppAdapter.instance) {
    WhatsAppAdapter.instance = new WhatsAppAdapter();
  }
  return WhatsAppAdapter.instance;
}

/**
 * Returns the channel type handled by this adapter.
 * @returns The notification channel type ('whatsapp').
 */
public getChannelType(): NotificationChannel {
  return 'whatsapp';
}

/**
 * Checks if this adapter is capable of sending a notification to the given recipient.
 * Requires a valid phone number, an initialized Twilio client, and a configured 'from' number.
 * @param recipient Information about the recipient.
 * @returns True if the adapter can send, false otherwise.
 */
public canSendTo(recipient: RecipientInfo): boolean {
  const hasValidPhone = !!recipient.phone && recipient.phone.length > 8; // Basic validation
  const isClientReady = this.client !== null;
  const hasFromNumber = this.fromNumber !== '';
  const canSend = hasValidPhone && isClientReady && hasFromNumber;

  if (!canSend) {
      let reason = 'Unknown';
      if (!hasValidPhone) reason = 'Invalid or missing phone number';
      else if (!isClientReady) reason = 'Twilio client not initialized';
      else if (!hasFromNumber) reason = 'Twilio "from" number not configured';
      logger.warn('Cannot send WhatsApp message due to configuration or recipient data', {
          reason: reason,
          recipientPhone: recipient.phone // Log phone for debugging
      });
  }
  return canSend;
}

/**
 * Formats a phone number into E.164 standard without the leading '+'.
 * Required for Twilio's `to` parameter when prefixed with `whatsapp:`.
 * Handles Israeli numbers starting with '0'.
 * Example: 0501234567 -> 972501234567
 * @param phone The phone number string to format.
 * @returns The formatted phone number string.
 */
private formatPhoneNumber(phone: string): string {
  // Remove all non-digit characters
  let cleaned = phone.replace(/\D/g, '');
  // Prepend country code for Israeli numbers if '0' prefix exists
  if (cleaned.startsWith('0')) {
    cleaned = '972' + cleaned.substring(1);
  }
  // Remove leading '+' if present (it's added later in the `whatsapp:` prefix)
  if (cleaned.startsWith('+')) {
    cleaned = cleaned.substring(1);
  }
  return cleaned;
}

/**
 * Sends a notification via WhatsApp using the Twilio API.
 * Prefers using template messages if configured via `_adapterSpecificData`.
 * Falls back to raw text messages otherwise (less reliable for business-initiated messages).
 * @param recipient Information about the recipient.
 * @param content The notification content, potentially including adapter-specific data.
 * @returns A promise that resolves to true if the message was successfully queued by Twilio, false otherwise.
 */
public async send(recipient: RecipientInfo, content: NotificationContent): Promise<boolean> {
  logger.info('Attempting to send WhatsApp message', {
    recipientPhone: recipient.phone,
    fromNumber: this.fromNumber,
    hasClient: !!this.client,
    contentSid: content._adapterSpecificData?.contentSid,
    hasContentVariables: !!content._adapterSpecificData?.contentVariables,
  });

  // --- Pre-send Checks ---
  if (!this.client) {
    logger.error('Twilio client not initialized. Cannot send WhatsApp message.');
    return false;
  }
  if (!recipient.phone) {
    logger.error('Recipient phone number is missing. Cannot send WhatsApp message.');
    return false;
  }
  if (!this.fromNumber) {
      logger.error('Twilio "from" WhatsApp number is not configured. Cannot send message.');
      return false;
  }
  // --- End Pre-send Checks ---


  try {
    // --- Format Numbers ---
    const toNumberE164 = this.formatPhoneNumber(recipient.phone);
    // Ensure 'from' number has '+' prefix for the whatsapp: schema
    const fromWhatsAppFormatted = `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`;
    // Ensure 'to' number has '+' prefix for the whatsapp: schema
    const toWhatsAppFormatted = `whatsapp:+${toNumberE164}`;

    logger.info(`Formatted numbers for sending via Twilio`, { from: fromWhatsAppFormatted, to: toWhatsAppFormatted });
    // --- End Format Numbers ---


    // --- Prepare Message Payload ---
    let messagePayload: MessageListInstanceCreateOptions;
    const adapterData = content._adapterSpecificData;

    if (adapterData?.contentSid && adapterData?.contentVariables) {
       // **Use Template Messaging**
       logger.info(`Preparing WhatsApp template message`, { contentSid: adapterData.contentSid });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          contentSid: adapterData.contentSid, // The approved template SID
          contentVariables: adapterData.contentVariables, // JSON string of variables {"1": "value1", "2": "value2"}
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    } else {
       // **Use Raw Text Messaging (Fallback)**
       // Note: This might fail if outside the 24-hour customer service window
       // or if WhatsApp/Twilio policies require templates for this type of message.
       const bodyText = content.body || content.subject || 'הודעה ממערכת השידוכים'; // Determine fallback content
       logger.warn(`Preparing raw text WhatsApp message (using fallback, might fail)`, { bodyLength: bodyText.length });
       messagePayload = {
          from: fromWhatsAppFormatted,
          to: toWhatsAppFormatted,
          body: bodyText, // The actual text message content
          // Optional: Specify Messaging Service SID if using one
          // messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID
       };
    }
    // --- End Prepare Message Payload ---


    // --- Send Message via Twilio API ---
    logger.info("Sending message payload to Twilio API", { payload: messagePayload }); // Be cautious logging full payload in production if sensitive
    const message = await this.client.messages.create(messagePayload);
    // --- End Send Message ---


    // --- Log Success ---
    // The message status here is typically 'queued' or 'sending'. Delivery confirmation is asynchronous.
    logger.info('WhatsApp message request processed successfully by Twilio', {
      messageSid: message.sid,
      status: message.status,
      to: toWhatsAppFormatted,
      from: fromWhatsAppFormatted,
      price: message.price, // Log cost if available
      priceUnit: message.priceUnit,
      errorCode: message.errorCode, // Log if Twilio detected an error immediately
      errorMessage: message.errorMessage,
    });
    // We return true because Twilio accepted the request. Delivery is not guaranteed at this point.
    return true;
    // --- End Log Success ---

  } catch (error: unknown) { // Catch error as unknown
    // --- Handle Errors ---
    let errorMessage = 'Unknown error occurred while sending WhatsApp message.';
    let errorCode: number | string | undefined;

    // Use the type guard to safely access potential error properties
    if (isPotentialTwilioError(error)) {
        errorCode = error.code;
        errorMessage = error.message || errorMessage;
    } else if (error instanceof Error) {
        // Standard JavaScript Error
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        // Simple string error
        errorMessage = error;
    }

    // Log detailed error information
    logger.error('Failed to send WhatsApp message via Twilio', {
      errorCode,
      errorMessage,
      recipient: `whatsapp:+${this.formatPhoneNumber(recipient.phone)}`, // Log formatted number for debugging
      from: `whatsapp:${this.fromNumber.startsWith('+') ? this.fromNumber : '+' + this.fromNumber}`,
      // Pass the original error object for full details in structured logs
      errorDetails: error
    });

    // Specific handling/logging for common, informative errors
    if (errorCode === 63018 || errorCode === 21614) { // Common codes for non-WhatsApp/incapable numbers
         logger.error(`Recipient number appears invalid or not registered on WhatsApp.`, { phone: recipient.phone, errorCode });
         // Consider adding logic here: maybe mark the user's number as invalid? Notify admin?
    } else if (errorCode === 63016) { // Common code for failing outside the 24-hour window without a template
          logger.warn(`Failed to send non-template message outside 24-hour window.`, { phone: recipient.phone, errorCode });
    }

    return false; // Indicate that sending failed
    // --- End Handle Errors ---
  }
}
}

// Export the singleton instance for use in other parts of the application
export const whatsAppAdapter = WhatsAppAdapter.getInstance();
--- End of Content for WhatsAppAdapter.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\StatusTransitionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService.ts

import { MatchSuggestionStatus, User, MatchSuggestion, Profile } from "@prisma/client";
import prisma from "@/lib/prisma";
import { notificationService } from "../notification/NotificationService";


type UserWithProfile = User & {
  profile: Profile | null;
};

export type SuggestionWithParties = MatchSuggestion & {
  firstParty: UserWithProfile;
  secondParty: UserWithProfile;
  matchmaker: User;
};

type TransitionOptions = {
  sendNotifications?: boolean;
  customMessage?: string;
  notifyParties?: ('first' | 'second' | 'matchmaker')[];
};

export class StatusTransitionService {
  private static instance: StatusTransitionService;
  private constructor() {}

  public static getInstance(): StatusTransitionService {
    if (!StatusTransitionService.instance) {
      StatusTransitionService.instance = new StatusTransitionService();
    }
    return StatusTransitionService.instance;
  }

  async transitionStatus(
    suggestion: SuggestionWithParties,
    newStatus: MatchSuggestionStatus,
    notes?: string,
    options: TransitionOptions = {}
  ): Promise<SuggestionWithParties> {
    const previousStatus = suggestion.status;
    const mergedOptions = {
      sendNotifications: true,
      notifyParties: ['first', 'second', 'matchmaker'],
      ...options
    };

    // Validate the transition
    this.validateStatusTransition(previousStatus, newStatus);

    // Perform the status transition in a transaction
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      // Update the suggestion status
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestion.id },
        data: {
          status: newStatus,
          previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          
          // Update timing fields based on status
          ...(newStatus === MatchSuggestionStatus.FIRST_PARTY_APPROVED && {
            firstPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.SECOND_PARTY_APPROVED && {
            secondPartyResponded: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            closedAt: new Date(),
          }),
          ...(newStatus === MatchSuggestionStatus.MEETING_SCHEDULED && {
            firstMeetingScheduled: new Date(),
          }),
        },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // Create status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: suggestion.id,
          status: newStatus,
          notes: notes || `Status changed from ${previousStatus} to ${newStatus}`,
        },
      });

      return updated;
    });

    // Only send notifications if option is enabled
    if (mergedOptions.sendNotifications) {
      try {
        // Utilize the notification service for all channels (email, WhatsApp, etc.)
        await notificationService.handleSuggestionStatusChange(
          
          updatedSuggestion, 
          {
            channels: ['email', 'whatsapp'],
            notifyParties: mergedOptions.notifyParties as ('first' | 'second' | 'matchmaker')[],
            customMessage: mergedOptions.customMessage
          }
        );
        
        console.log(`Notifications sent for suggestion ${updatedSuggestion.id} status change to ${newStatus}`);
      } catch (error) {
        // Log error but don't fail the transition
        console.error('Error sending status transition notifications:', error);
      }
    }

    return updatedSuggestion;
  }

  private validateStatusTransition(
    currentStatus: MatchSuggestionStatus, 
    newStatus: MatchSuggestionStatus
  ): void {
    const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
      DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY],
      PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
      ],
      FIRST_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      SECOND_PARTY_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      AWAITING_MATCHMAKER_APPROVAL: [
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.CANCELLED
      ],
      CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
      ],
      AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
      ],
      PROCEEDING_TO_SECOND_DATE: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      ENDED_AFTER_FIRST_DATE: [
        MatchSuggestionStatus.CLOSED
      ],
      MEETING_PENDING: [
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.CANCELLED
      ],
      MEETING_SCHEDULED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_APPROVED: [
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
      ],
      MATCH_DECLINED: [
        MatchSuggestionStatus.CLOSED
      ],
      DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED,
        MatchSuggestionStatus.CANCELLED
      ],
      ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CANCELLED
      ],
      MARRIED: [],
      EXPIRED: [],
      CLOSED: [],
      CANCELLED: []
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new Error(
        `Invalid status transition from ${currentStatus} to ${newStatus}. ` +
        `Valid transitions are: ${validTransitions[currentStatus]?.join(', ') || 'none'}`
      );
    }
  }
  
  getStatusLabel(status: MatchSuggestionStatus): string {
    const statusLabels: Record<MatchSuggestionStatus, string> = {
      DRAFT: "טיוטה",
      PENDING_FIRST_PARTY: "ממתין לתשובת הצד הראשון",
      FIRST_PARTY_APPROVED: "הצד הראשון אישר",
      FIRST_PARTY_DECLINED: "הצד הראשון דחה",
      PENDING_SECOND_PARTY: "ממתין לתשובת הצד השני",
      SECOND_PARTY_APPROVED: "הצד השני אישר",
      SECOND_PARTY_DECLINED: "הצד השני דחה",
      AWAITING_MATCHMAKER_APPROVAL: "ממתין לאישור השדכן",
      CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
      AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
      THINKING_AFTER_DATE: "בחשיבה לאחר הפגישה",
      PROCEEDING_TO_SECOND_DATE: "התקדמות לפגישה שנייה",
      ENDED_AFTER_FIRST_DATE: "הסתיים לאחר פגישה ראשונה",
      MEETING_PENDING: "פגישה בהמתנה",
      MEETING_SCHEDULED: "פגישה קבועה",
      MATCH_APPROVED: "השידוך אושר",
      MATCH_DECLINED: "השידוך נדחה",
      DATING: "בתהליך היכרות",
      ENGAGED: "אירוסין",
      MARRIED: "נישואין",
      CANCELLED: "בוטל",
      CLOSED: "נסגר",
      EXPIRED: "פג תוקף"
    };
    
    return statusLabels[status] || status;
  }
  
  // Get available actions for current status based on user role
  getAvailableActions(
    suggestion: SuggestionWithParties, 
    userId: string
  ): { id: string; label: string; nextStatus: MatchSuggestionStatus }[] {
    const isFirstParty = suggestion.firstPartyId === userId;
    const isSecondParty = suggestion.secondPartyId === userId;
    const isMatchmaker = suggestion.matchmakerId === userId;
    
    const actions: Record<MatchSuggestionStatus, { 
      firstParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      secondParty?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
      matchmaker?: { id: string; label: string; nextStatus: MatchSuggestionStatus }[];
    }> = {
      DRAFT: {
        matchmaker: [
          { id: "send-to-first", label: "שליחה לצד הראשון", nextStatus: MatchSuggestionStatus.PENDING_FIRST_PARTY }
        ]
      },
      PENDING_FIRST_PARTY: {
        firstParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.FIRST_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_APPROVED: {
        matchmaker: [
          { id: "send-to-second", label: "שליחה לצד השני", nextStatus: MatchSuggestionStatus.PENDING_SECOND_PARTY },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      FIRST_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      PENDING_SECOND_PARTY: {
        secondParty: [
          { id: "approve", label: "אישור ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_APPROVED },
          { id: "decline", label: "דחיית ההצעה", nextStatus: MatchSuggestionStatus.SECOND_PARTY_DECLINED }
        ],
        matchmaker: [
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_APPROVED: {
        matchmaker: [
          { id: "share-contacts", label: "שיתוף פרטי קשר", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      SECOND_PARTY_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      AWAITING_MATCHMAKER_APPROVAL: {
        matchmaker: [
          { id: "approve-share", label: "אישור שיתוף פרטים", nextStatus: MatchSuggestionStatus.CONTACT_DETAILS_SHARED },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      CONTACT_DETAILS_SHARED: {
        firstParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        secondParty: [
          { id: "provide-feedback", label: "דיווח משוב לאחר פגישה", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK }
        ],
        matchmaker: [
          { id: "request-feedback", label: "בקש משוב", nextStatus: MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK },
          { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      AWAITING_FIRST_DATE_FEEDBACK: {
         matchmaker: [
            { id: "mark-thinking", label: "סמן כ'בחשיבה'", nextStatus: MatchSuggestionStatus.THINKING_AFTER_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      THINKING_AFTER_DATE: {
         matchmaker: [
            { id: "proceed-second", label: "המשך לפגישה שניה", nextStatus: MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE },
            { id: "mark-ended-first", label: "סמן כ'הסתיים לאחר פגישה'", nextStatus: MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      PROCEEDING_TO_SECOND_DATE: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      ENDED_AFTER_FIRST_DATE: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      MEETING_PENDING: {
         matchmaker: [
            { id: "schedule-meeting", label: "קביעת פגישה", nextStatus: MatchSuggestionStatus.MEETING_SCHEDULED },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MEETING_SCHEDULED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_APPROVED: {
         matchmaker: [
            { id: "mark-dating", label: "סמן כ'בתהליך היכרות'", nextStatus: MatchSuggestionStatus.DATING },
            { id: "cancel", label: "ביטול ההצעה", nextStatus: MatchSuggestionStatus.CANCELLED }
         ]
      },
      MATCH_DECLINED: {
        matchmaker: [
          { id: "close", label: "סגירת הצעה", nextStatus: MatchSuggestionStatus.CLOSED }
        ]
      },
      DATING: {
        matchmaker: [
          { id: "mark-engaged", label: "עדכון אירוסין", nextStatus: MatchSuggestionStatus.ENGAGED },
          { id: "close", label: "סגירת תהליך", nextStatus: MatchSuggestionStatus.CLOSED },
          { id: "cancel", label: "ביטול השידוך", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      ENGAGED: {
        matchmaker: [
          { id: "mark-married", label: "עדכון נישואין", nextStatus: MatchSuggestionStatus.MARRIED },
          { id: "cancel", label: "ביטול אירוסין", nextStatus: MatchSuggestionStatus.CANCELLED }
        ]
      },
      MARRIED: {},
      EXPIRED: {},
      CLOSED: {},
      CANCELLED: {}
    };
    
    if (isFirstParty && actions[suggestion.status]?.firstParty) {
      return actions[suggestion.status].firstParty || [];
    }
    
    if (isSecondParty && actions[suggestion.status]?.secondParty) {
      return actions[suggestion.status].secondParty || [];
    }
    
    if (isMatchmaker && actions[suggestion.status]?.matchmaker) {
      return actions[suggestion.status].matchmaker || [];
    }
    
    return [];
  }
}

// Export singleton instance
export const statusTransitionService = StatusTransitionService.getInstance();
--- End of Content for StatusTransitionService.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\services\suggestions\SuggestionService.ts
--------------------------------------------------------------------------------
Content:
// src/app/components/matchmaker/suggestions/services/suggestions/SuggestionService.ts

import { MatchSuggestionStatus, Priority, UserRole } from "@prisma/client";
import prisma from "@/lib/prisma";
import { statusTransitionService, type SuggestionWithParties } from "./StatusTransitionService";
import { initNotificationService } from "../notification/initNotifications";
import type { 
  CreateSuggestionData,
  UpdateSuggestionData,
} from "@/types/suggestions";

// Initialize notification service
const notificationService = initNotificationService();

export class SuggestionService {
  private static instance: SuggestionService;

  private constructor() {}

  public static getInstance(): SuggestionService {
    if (!SuggestionService.instance) {
      SuggestionService.instance = new SuggestionService();
    }
    return SuggestionService.instance;
  }

  /**
   * יצירת הצעת שידוך חדשה
   */
  public async createSuggestion(data: CreateSuggestionData): Promise<SuggestionWithParties> {
    // 1. וידוא הרשאות השדכן
    const matchmaker = await prisma.user.findUnique({
      where: { id: data.matchmakerId },
    });

    if (!matchmaker || matchmaker.role !== UserRole.MATCHMAKER) {
      throw new Error("Unauthorized - User is not a matchmaker");
    }

    // 4. יצירת ההצעה בטרנזקציה
    const suggestion = await prisma.$transaction(async (tx) => {
      // יצירת ההצעה עם הנתונים המנוקים
      console.log('Decision deadline value:', data.decisionDeadline);
      console.log('Decision deadline type:', typeof data.decisionDeadline);
      
      const cleanedData = {
        matchmakerId: data.matchmakerId,
        firstPartyId: data.firstPartyId,
        secondPartyId: data.secondPartyId,
        status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
        priority: data.priority || Priority.MEDIUM,
        matchingReason: data.notes?.matchingReason || null,
        firstPartyNotes: data.notes?.forFirstParty || null,
        secondPartyNotes: data.notes?.forSecondParty || null,
        internalNotes: data.notes?.internal || null,
        followUpNotes: data.notes?.followUpNotes || null,
        decisionDeadline: new Date(data.decisionDeadline),
        firstPartySent: new Date(),
        lastActivity: new Date(),
        lastStatusChange: new Date()
      };

      const newSuggestion = await tx.matchSuggestion.create({
        data: cleanedData,
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      // יצירת רשומת היסטוריה ראשונית
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: newSuggestion.status,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 5. שליחת התראות באמצעות מערכת ההתראות המאוחדת
    try {
      console.log('Sending notifications for new suggestion...');
      await notificationService.handleSuggestionStatusChange(
        suggestion,
        {
          channels: ['email', 'whatsapp'],
          notifyParties: ['first'] // רק לצד הראשון בשלב זה
        }
      );
    } catch (error) {
      console.error('Error sending initial suggestion notifications:', error);
      // לא לעצור את התהליך - רק לדווח על השגיאה
    }

    return suggestion;
  }

  /**
   * עדכון פרטי הצעת שידוך
   */
  public async updateSuggestion(
    id: string,
    matchmakerId: string,
    data: UpdateSuggestionData
  ): Promise<SuggestionWithParties> {
    // 1. בדיקת קיום ההצעה והרשאות
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (suggestion.matchmakerId !== matchmakerId) {
      throw new Error("Unauthorized - Only the original matchmaker can update the suggestion");
    }

    // 2. ניקוי והכנת נתוני העדכון
    const cleanedUpdateData = {
      ...(data.notes?.matchingReason !== undefined && { 
        matchingReason: data.notes.matchingReason 
      }),
      ...(data.notes?.forFirstParty !== undefined && { 
        firstPartyNotes: data.notes.forFirstParty 
      }),
      ...(data.notes?.forSecondParty !== undefined && { 
        secondPartyNotes: data.notes.forSecondParty 
      }),
      ...(data.notes?.internal !== undefined && { 
        internalNotes: data.notes.internal 
      }),
      ...(data.notes?.followUpNotes !== undefined && { 
        followUpNotes: data.notes.followUpNotes 
      }),
      ...(data.priority && { priority: data.priority }),
      ...(data.responseDeadline && { 
        responseDeadline: new Date(data.responseDeadline) 
      }),
      ...(data.decisionDeadline && { 
        decisionDeadline: new Date(data.decisionDeadline) 
      }),
      lastActivity: new Date()
    };

    // 3. עדכון הנתונים
    return await prisma.matchSuggestion.update({
      where: { id },
      data: cleanedUpdateData,
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }

  /**
   * עדכון סטטוס של הצעת שידוך
   */
  public async updateSuggestionStatus(
    id: string,
    newStatus: MatchSuggestionStatus,
    userId: string,
    notes?: string
  ): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    this.validateStatusChangePermission(suggestion, userId, newStatus);
    return await statusTransitionService.transitionStatus(suggestion, newStatus, notes);
  }

  /**
   * קבלת פרטי הצעת שידוך
   */
  public async getSuggestionDetails(id: string, userId: string): Promise<SuggestionWithParties> {
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
    });

    if (!suggestion) {
      throw new Error("Suggestion not found");
    }

    if (
      userId !== suggestion.matchmakerId &&
      userId !== suggestion.firstPartyId &&
      userId !== suggestion.secondPartyId
    ) {
      throw new Error("Unauthorized to view this suggestion");
    }

    return suggestion;
  }

  /**
   * קבלת רשימת הצעות שידוך של משתמש
   */
  public async getUserSuggestions(userId: string): Promise<SuggestionWithParties[]> {
    return await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { matchmakerId: userId },
          { firstPartyId: userId },
          { secondPartyId: userId },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
        statusHistory: {
          orderBy: { createdAt: "desc" },
        },
        meetings: {
          include: {
            feedback: true
          }
        },
      },
      orderBy: {
        lastActivity: "desc",
      },
    });
  }

  /**
   * אימות הרשאות לשינוי סטטוס
   */
  private validateStatusChangePermission(
    suggestion: SuggestionWithParties,
    userId: string,
    newStatus: MatchSuggestionStatus
  ): void {
    const isMatchmaker = userId === suggestion.matchmakerId;
    const isFirstParty = userId === suggestion.firstPartyId;

    switch (newStatus) {
      case MatchSuggestionStatus.FIRST_PARTY_APPROVED:
      case MatchSuggestionStatus.FIRST_PARTY_DECLINED:
        if (!isFirstParty) throw new Error("Only first party can approve/decline at this stage");
        break;

      default:
        if (!isMatchmaker) throw new Error("Only matchmaker can change status at this stage");
    }
  }

  /**
   * בדיקת קיום הצעה פעילה בין שני מועמדים
   */
  private async checkExistingSuggestion(
    firstPartyId: string,
    secondPartyId: string
  ): Promise<SuggestionWithParties | null> {
    return await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              { firstPartyId, secondPartyId },
              { firstPartyId: secondPartyId, secondPartyId: firstPartyId },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
              ],
            },
          },
        ],
      },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true,
      },
    });
  }
}
export const suggestionService = SuggestionService.getInstance();
--- End of Content for SuggestionService.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\matchingAlgorithm.ts
--------------------------------------------------------------------------------
Content:
import { AvailabilityStatus } from '@prisma/client';
import type { UserProfile } from '@/types/next-auth';

export interface MatchScore {
  score: number;
  criteria: MatchCriteria[];
  compatibility: number;
  reasons: string[];
}

export interface MatchCriteria {
  name: string;
  weight: number;
  score: number;
  reason?: string;
}

interface AgePreference {
  min: number;
  max: number;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const calculateAgeCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile,
  preferences: { ageA?: AgePreference; ageB?: AgePreference }
): MatchCriteria => {
  const ageA = calculateAge(profileA.birthDate);
  const ageB = calculateAge(profileB.birthDate);
  const ageDiff = Math.abs(ageA - ageB);
  
  let score = 0;
  let reason = '';

  // בדיקת העדפות גיל הדדית
  const aPrefsMatch = preferences.ageA ? 
    (ageB >= preferences.ageA.min && ageB <= preferences.ageA.max) : true;
  const bPrefsMatch = preferences.ageB ?
    (ageA >= preferences.ageB.min && ageA <= preferences.ageB.max) : true;

  if (aPrefsMatch && bPrefsMatch) {
    if (ageDiff <= 2) {
      score = 1;
      reason = 'הפרש גילאים אידיאלי';
    } else if (ageDiff <= 5) {
      score = 0.8;
      reason = 'הפרש גילאים טוב';
    } else if (ageDiff <= 8) {
      score = 0.6;
      reason = 'הפרש גילאים סביר';
    } else {
      score = 0.4;
      reason = 'הפרש גילאים גדול';
    }
  } else {
    score = 0.2;
    reason = 'לא תואם להעדפות הגיל';
  }

  return {
    name: 'age',
    weight: 15,
    score,
    reason
  };
};

const calculateLocationCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.city || !profileB.city) {
    return {
      name: 'location',
      weight: 10,
      score: 0.5,
      reason: 'חסר מידע על מיקום'
    };
  }

  const sameCity = profileA.city === profileB.city;
  const preferredLocationsA = profileA.preferredLocations || [];
  const preferredLocationsB = profileB.preferredLocations || [];

  if (sameCity) {
    score = 1;
    reason = 'גרים באותה עיר';
  } else if (
    preferredLocationsA.includes(profileB.city) &&
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.8;
    reason = 'מיקום מועדף הדדי';
  } else if (
    preferredLocationsA.includes(profileB.city) ||
    preferredLocationsB.includes(profileA.city)
  ) {
    score = 0.6;
    reason = 'מיקום מועדף חד צדדי';
  } else {
    score = 0.4;
    reason = 'ערים שונות';
  }

  return {
    name: 'location',
    weight: 10,
    score,
    reason
  };
};

const calculateReligiousCompatibility = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchCriteria => {
  let score = 0;
  let reason = '';

  if (!profileA.religiousLevel || !profileB.religiousLevel) {
    return {
      name: 'religious',
      weight: 20,
      score: 0.5,
      reason: 'חסר מידע על רמת דתיות'
    };
  }

  const sameLevel = profileA.religiousLevel === profileB.religiousLevel;
  const preferredLevelsA = profileA.preferredReligiousLevels || [];
  const preferredLevelsB = profileB.preferredReligiousLevels || [];

  if (sameLevel) {
    score = 1;
    reason = 'רמת דתיות זהה';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) &&
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.8;
    reason = 'רמת דתיות מועדפת הדדית';
  } else if (
    preferredLevelsA.includes(profileB.religiousLevel) ||
    preferredLevelsB.includes(profileA.religiousLevel)
  ) {
    score = 0.6;
    reason = 'רמת דתיות מועדפת חד צדדית';
  } else {
    score = 0.3;
    reason = 'רמות דתיות שונות';
  }

  return {
    name: 'religious',
    weight: 20,
    score,
    reason
  };
};

export const calculateMatchScore = (
  profileA: UserProfile,
  profileB: UserProfile
): MatchScore | null => {
  // בדיקת תנאי סף
  if (
    profileA.gender === profileB.gender ||
    profileA.availabilityStatus !== AvailabilityStatus.AVAILABLE ||
    profileB.availabilityStatus !== AvailabilityStatus.AVAILABLE
  ) {
    return null;
  }

  // חישוב קריטריונים
  const ageCriteria = calculateAgeCompatibility(
    profileA,
    profileB,
    {
      ageA: profileA.preferredAgeMin && profileA.preferredAgeMax
        ? { min: profileA.preferredAgeMin, max: profileA.preferredAgeMax }
        : undefined,
      ageB: profileB.preferredAgeMin && profileB.preferredAgeMax
        ? { min: profileB.preferredAgeMin, max: profileB.preferredAgeMax }
        : undefined
    }
  );

  const locationCriteria = calculateLocationCompatibility(profileA, profileB);
  const religiousCriteria = calculateReligiousCompatibility(profileA, profileB);

  const criteria = [
    ageCriteria,
    locationCriteria,
    religiousCriteria
  ];

  // חישוב ציון סופי
  const totalWeight = criteria.reduce((sum, c) => sum + c.weight, 0);
  const weightedScore = criteria.reduce((sum, c) => sum + (c.score * c.weight), 0);
  const finalScore = (weightedScore / totalWeight) * 100;

  // סיבות להתאמה
  const reasons = criteria
    .filter(c => c.score >= 0.6)
    .map(c => c.reason)
    .filter((reason): reason is string => reason !== undefined);

  return {
    score: Math.round(finalScore),
    criteria,
    compatibility: finalScore / 100,
    reasons
  };
};

export const findBestMatches = (
  profile: UserProfile,
  profiles: UserProfile[],
  limit: number = 10
): { profile: UserProfile; score: MatchScore }[] => {
  const matches = profiles
    .filter(p => p.id !== profile.id)
    .map(p => {
      const score = calculateMatchScore(profile, p);
      return score ? { profile: p, score } : null;
    })
    .filter((match): match is { profile: UserProfile; score: MatchScore } => match !== null)
    .sort((a, b) => b.score.score - a.score.score);

  return matches.slice(0, limit);
};

const matchingAlgorithm = {
  calculateMatchScore,
  findBestMatches
};

export default matchingAlgorithm;
--- End of Content for matchingAlgorithm.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\matchmaker\suggestions\utils\statisticsCalculator.ts
--------------------------------------------------------------------------------
Content:
// /utils/statisticsCalculator.ts
import type { Candidate } from '../../new/types/candidates';
import { Gender, AvailabilityStatus } from '@prisma/client';


export interface AgeDistribution {
  ageGroups: Record<string, number>;
  averageAge: number;
  medianAge: number;
}

export interface LocationDistribution {
  cities: Record<string, number>;
  topCities: Array<{ city: string; count: number }>;
}

export interface ReligiousDistribution {
  levels: Record<string, number>;
  percentages: Record<string, number>;
}

export interface ActivityStats {
  activeLastWeek: number;
  activeLastMonth: number;
  averageLoginFrequency: number;
  completedProfiles: number;
}

export interface MatchingStats {
  totalMatches: number;
  successfulMatches: number;
  averageMatchScore: number;
  matchesByStatus: Record<string, number>;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const calculateAgeDistribution = (candidates: Candidate[]): AgeDistribution => {
  const ages = candidates.map(c => calculateAge(c.profile.birthDate));
  
  // חישוב קבוצות גיל
  const ageGroups = ages.reduce((acc, age) => {
    const group = `${Math.floor(age / 5) * 5}-${Math.floor(age / 5) * 5 + 4}`;
    acc[group] = (acc[group] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב ממוצע
  const averageAge = ages.reduce((sum, age) => sum + age, 0) / ages.length;

  // חישוב חציון
  const sortedAges = [...ages].sort((a, b) => a - b);
  const medianAge = sortedAges.length % 2 === 0
    ? (sortedAges[sortedAges.length / 2 - 1] + sortedAges[sortedAges.length / 2]) / 2
    : sortedAges[Math.floor(sortedAges.length / 2)];

  return {
    ageGroups,
    averageAge: Math.round(averageAge * 10) / 10,
    medianAge
  };
};

export const calculateLocationDistribution = (
  candidates: Candidate[],
  topCount: number = 10
): LocationDistribution => {
  // ספירת מועמדים לפי ערים
  const cities = candidates.reduce((acc, candidate) => {
    const city = candidate.profile.city || 'לא צוין';
    acc[city] = (acc[city] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // מיון הערים לפי כמות מועמדים
  const topCities = Object.entries(cities)
    .map(([city, count]) => ({ city, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, topCount);

  return {
    cities,
    topCities
  };
};

export const calculateReligiousDistribution = (candidates: Candidate[]): ReligiousDistribution => {
  const total = candidates.length;
  
  // ספירת מועמדים לפי רמת דתיות
  const levels = candidates.reduce((acc, candidate) => {
    const level = candidate.profile.religiousLevel || 'לא צוין';
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // חישוב אחוזים
  const percentages = Object.entries(levels).reduce((acc, [level, count]) => {
    acc[level] = Math.round((count / total) * 100);
    return acc;
  }, {} as Record<string, number>);

  return {
    levels,
    percentages
  };
};

export const calculateActivityStats = (candidates: Candidate[]): ActivityStats => {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

  const activeLastWeek = candidates.filter(c => 
    c.profile.lastActive && new Date(c.profile.lastActive) >= weekAgo
  ).length;

  const activeLastMonth = candidates.filter(c =>
    c.profile.lastActive && new Date(c.profile.lastActive) >= monthAgo
  ).length;

  // חישוב תדירות התחברות ממוצעת (בימים)
  const loginGaps = candidates
    .filter(c => c.profile.lastActive)
    .map(c => {
      const lastActive = new Date(c.profile.lastActive!);
      return Math.floor((now.getTime() - lastActive.getTime()) / (24 * 60 * 60 * 1000));
    });

  const averageLoginFrequency = loginGaps.length > 0
    ? loginGaps.reduce((sum, gap) => sum + gap, 0) / loginGaps.length
    : 0;

  // ספירת פרופילים מלאים
  const completedProfiles = candidates.filter(c => 
    c.profile.about &&
    c.profile.religiousLevel &&
    c.profile.city &&
    c.images.length > 0
  ).length;

  return {
    activeLastWeek,
    activeLastMonth,
    averageLoginFrequency: Math.round(averageLoginFrequency * 10) / 10,
    completedProfiles
  };
};

export const calculateGenderStats = (candidates: Candidate[]) => {
  const maleCount = candidates.filter(c => c.profile.gender === Gender.MALE).length;
  const femaleCount = candidates.filter(c => c.profile.gender === Gender.FEMALE).length;
  
  return {
    maleCount,
    femaleCount,
    ratio: maleCount / femaleCount,
    total: candidates.length,
    percentages: {
      male: Math.round((maleCount / candidates.length) * 100),
      female: Math.round((femaleCount / candidates.length) * 100)
    }
  };
};

export const calculateAvailabilityStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const statusCounts = candidates.reduce((acc, candidate) => {
    const status = candidate.profile.availabilityStatus;
    acc[status] = (acc[status] || 0) + 1;
    return acc;
  }, {} as Record<AvailabilityStatus, number>);

  return {
    counts: statusCounts,
    percentages: Object.entries(statusCounts).reduce((acc, [status, count]) => {
      acc[status] = Math.round((count / total) * 100);
      return acc;
    }, {} as Record<string, number>)
  };
};

export const calculateCompletionStats = (candidates: Candidate[]) => {
  const total = candidates.length;
  const  stats = {
    hasPhotos: 0,
    hasAbout: 0,
    hasReferences: 0,
    hasPreferences: 0,
    isVerified: 0,
    fullyCompleted: 0
  };

  candidates.forEach(candidate => {
    if (candidate.images.length > 0) stats.hasPhotos++;
    if (candidate.profile.about) stats.hasAbout++;
    if (candidate.profile.preferredAgeMin && candidate.profile.preferredAgeMax) stats.hasPreferences++;
    if (candidate.isVerified) stats.isVerified++;
    
    // בדיקת פרופיל מלא
    if (
      candidate.images.length > 0 &&
      candidate.profile.about &&
      candidate.profile.religiousLevel &&
      candidate.profile.city &&
      candidate.profile.preferredAgeMin &&
      candidate.profile.preferredAgeMax
    ) {
      stats.fullyCompleted++;
    }
  });

  return {
    counts: stats,
    percentages: {
      hasPhotos: Math.round((stats.hasPhotos / total) * 100),
      hasAbout: Math.round((stats.hasAbout / total) * 100),
      hasReferences: Math.round((stats.hasReferences / total) * 100),
      hasPreferences: Math.round((stats.hasPreferences / total) * 100),
      isVerified: Math.round((stats.isVerified / total) * 100),
      fullyCompleted: Math.round((stats.fullyCompleted / total) * 100)
    }
  };
};

const statisticsCalculator = {
  calculateAgeDistribution,
  calculateLocationDistribution,
  calculateReligiousDistribution,
  calculateActivityStats,
  calculateGenderStats,
  calculateAvailabilityStats,
  calculateCompletionStats
};

export default statisticsCalculator;
--- End of Content for statisticsCalculator.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\messages
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\messages\AvailabilityRequestCard.tsx
--------------------------------------------------------------------------------
Content:
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Clock, CheckCircle, XCircle } from "lucide-react";
import type { ExtendedInquiry } from "@/types/messages";

interface AvailabilityRequestCardProps {
  inquiry: ExtendedInquiry;
  currentUserId: string;
  onRespond: (inquiryId: string, isAvailable: boolean) => Promise<void>;
}

export default function AvailabilityRequestCard({
  inquiry,
  currentUserId,
  onRespond,
}: AvailabilityRequestCardProps) {
  const isFirstParty = inquiry.firstPartyId === currentUserId;
  const isSecondParty = inquiry.secondPartyId === currentUserId;
  const totalResponses = [
    inquiry.firstPartyResponse,
    inquiry.secondPartyResponse,
  ].filter((r) => r !== null).length;
  const progress = (totalResponses / 2) * 100;

  return (
    <Card>
      <CardContent className="p-6">
        <div className="flex justify-between items-start mb-4">
          <div>
            <h3 className="font-medium">בקשת בדיקת זמינות</h3>
            <p className="text-sm text-gray-600">
              מאת {inquiry.matchmaker.firstName} {inquiry.matchmaker.lastName}
            </p>
          </div>
          <Clock className="w-5 h-5 text-gray-400" />
        </div>

        <div className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <div className="text-sm text-gray-500">צד ראשון</div>
              <div className="flex items-center mt-1">
                {inquiry.firstPartyResponse === null ? (
                  <Clock className="w-4 h-4 text-yellow-500 mr-1" />
                ) : inquiry.firstPartyResponse ? (
                  <CheckCircle className="w-4 h-4 text-green-500 mr-1" />
                ) : (
                  <XCircle className="w-4 h-4 text-red-500 mr-1" />
                )}
                <span>
                  {inquiry.firstParty.firstName} {inquiry.firstParty.lastName}
                </span>
              </div>
            </div>
          </div>

          <div className="space-y-2">
            <div className="flex justify-between text-sm text-gray-500">
              <span>התקדמות</span>
              <span>{progress}%</span>
            </div>
            <Progress value={progress} className="w-full" />
          </div>

          {inquiry.note && (
            <div className="text-sm text-gray-600">
              <strong>הערה:</strong> {inquiry.note}
            </div>
          )}

          {isFirstParty && inquiry.firstPartyResponse === null && (
            <div className="flex gap-2 mt-4">
              <Button
                onClick={() => onRespond(inquiry.id, true)}
                className="flex-1 bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="mr-2 h-4 w-4" />
                אני זמין/ה
              </Button>
              <Button
                onClick={() => onRespond(inquiry.id, false)}
                variant="outline"
                className="flex-1"
              >
                <XCircle className="mr-2 h-4 w-4" />
                לא זמין/ה כרגע
              </Button>
            </div>
          )}

          {isSecondParty && inquiry.secondPartyResponse === null && (
            <div className="flex gap-2 mt-4">
              <Button
                onClick={() => onRespond(inquiry.id, true)}
                className="flex-1 bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="mr-2 h-4 w-4" />
                אני זמין/ה
              </Button>
              <Button
                onClick={() => onRespond(inquiry.id, false)}
                variant="outline"
                className="flex-1"
              >
                <XCircle className="mr-2 h-4 w-4" />
                לא זמין/ה כרגע
              </Button>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
--- End of Content for AvailabilityRequestCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\messages\MessagesPage.tsx
--------------------------------------------------------------------------------
Content:
"use client";
import { useNotifications } from "@/app/contexts/NotificationContext";
import { useState, useEffect, useCallback } from "react";
import { useSession } from "next-auth/react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Clock, CheckCircle, XCircle, Loader2, Users } from "lucide-react";
import type { ExtendedInquiry } from "@/types/messages";
import { Session } from "next-auth";

export default function MessagesPage() {
  const { data: session } = useSession() as { data: Session | null };
  const { refreshNotifications } = useNotifications();
  const [inquiries, setInquiries] = useState<ExtendedInquiry[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [filters, setFilters] = useState({
    status: "pending",
    timeframe: "all",
  });
  const [note, setNote] = useState("");

  const loadInquiries = useCallback(async () => {
    try {
      const queryParams = new URLSearchParams({
        status: filters.status,
        timeframe: filters.timeframe,
      });

      const response = await fetch(`/api/matchmaker/inquiries?${queryParams}`);
      if (!response.ok) throw new Error("Failed to load inquiries");
      const data = await response.json();
      setInquiries(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load inquiries");
    } finally {
      setLoading(false);
    }
  }, [filters]);

  useEffect(() => {
    if (session?.user) {
      loadInquiries();
    }
  }, [session, loadInquiries]);

  const handleResponse = async (inquiryId: string, isAvailable: boolean) => {
    try {
      const response = await fetch(
        `/api/matchmaker/inquiries/${inquiryId}/respond`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ isAvailable, note }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to submit response");
      }

      await loadInquiries();
      await refreshNotifications();
      setNote("");
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to submit response"
      );
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loader2 className="w-8 h-8 animate-spin" />
      </div>
    );
  }

  if (inquiries.length === 0) {
    return (
      <Card className="max-w-4xl mx-auto mt-8">
        <CardContent className="p-6 text-center">
          <Users className="w-12 h-12 mx-auto text-gray-400 mb-4" />
          <h3 className="text-lg font-medium">אין הודעות</h3>
          <p className="text-gray-500">אין הודעות או התראות חדשות</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4">
      <Card className="mb-6">
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle>הודעות והתראות</CardTitle>
          <div className="flex gap-4">
            <Select
              value={filters.status}
              onValueChange={(value) =>
                setFilters((prev) => ({ ...prev, status: value }))
              }
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="סינון לפי סטטוס" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                <SelectItem value="pending">ממתין לתגובה</SelectItem>
                <SelectItem value="completed">טופל</SelectItem>
              </SelectContent>
            </Select>

            <Select
              value={filters.timeframe}
              onValueChange={(value) =>
                setFilters((prev) => ({ ...prev, timeframe: value }))
              }
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="סינון לפי זמן" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">הכל</SelectItem>
                <SelectItem value="today">היום</SelectItem>
                <SelectItem value="week">שבוע אחרון</SelectItem>
                <SelectItem value="month">חודש אחרון</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardHeader>
      </Card>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 gap-6">
        {inquiries.map((inquiry) => (
          <Card key={inquiry.id}>
            <CardContent className="p-6">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h3 className="font-medium">בקשת בדיקת זמינות</h3>
                  <p className="text-sm text-gray-600">
                    מאת {inquiry.matchmaker.firstName}{" "}
                    {inquiry.matchmaker.lastName}
                  </p>
                </div>
                <Clock className="w-5 h-5 text-gray-400" />
              </div>

              <div className="space-y-4">
                {inquiry.note && (
                  <div className="text-sm text-gray-600 mt-2">
                    <strong>הערה:</strong> {inquiry.note}
                  </div>
                )}

                {!inquiry.firstPartyResponse && (
                  <>
                    <div className="space-y-2">
                      <label className="block text-sm font-medium">
                        הערות (אופציונלי):
                      </label>
                      <Textarea
                        value={note}
                        onChange={(e) => setNote(e.target.value)}
                        placeholder="הוסף/י הערות..."
                        className="w-full"
                      />
                    </div>

                    <div className="flex gap-2 mt-4">
                      <Button
                        onClick={() => handleResponse(inquiry.id, true)}
                        className="flex-1 bg-green-600 hover:bg-green-700"
                      >
                        <CheckCircle className="mr-2 h-4 w-4" />
                        אני זמין/ה
                      </Button>
                      <Button
                        onClick={() => handleResponse(inquiry.id, false)}
                        variant="outline"
                        className="flex-1"
                      >
                        <XCircle className="mr-2 h-4 w-4" />
                        לא זמין/ה כרגע
                      </Button>
                    </div>
                  </>
                )}

                {inquiry.firstPartyResponse !== null && (
                  <div className="space-y-4">
                    <div
                      className={`flex items-center gap-2 p-2 rounded-md ${
                        inquiry.firstPartyResponse
                          ? "bg-green-50 text-green-700"
                          : "bg-red-50 text-red-700"
                      }`}
                    >
                      {inquiry.firstPartyResponse ? (
                        <CheckCircle className="h-5 w-5" />
                      ) : (
                        <XCircle className="h-5 w-5" />
                      )}
                      <span>
                        {inquiry.firstPartyResponse
                          ? "אישרת זמינות"
                          : "ציינת שאינך זמין/ה"}
                      </span>
                    </div>

                    <div>
                      <Button
                        onClick={() =>
                          handleResponse(
                            inquiry.id,
                            !inquiry.firstPartyResponse
                          )
                        }
                        className={`w-full ${
                          inquiry.firstPartyResponse
                            ? "bg-red-600 hover:bg-red-700"
                            : "bg-green-600 hover:bg-green-700"
                        }`}
                      >
                        {inquiry.firstPartyResponse ? (
                          <>
                            <XCircle className="mr-2 h-4 w-4" />
                            שינוי תשובה - אינני זמין/ה
                          </>
                        ) : (
                          <>
                            <CheckCircle className="mr-2 h-4 w-4" />
                            שינוי תשובה - אני זמין/ה
                          </>
                        )}
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
--- End of Content for MessagesPage.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\ProfileCard.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/profile/ProfileCard.tsx
import React, { useState, useMemo, useCallback, useEffect } from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";

// UI Components
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogHeader,
  DialogFooter,
} from "@/components/ui/dialog";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area"; // <--- ודא שזה מיובא
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

// Icons
import {
  User,
  Heart,
  FileText,
  Image as ImageIcon,
  Info as InfoIcon,
  Eye,
  Phone,
  ChevronLeft,
  ChevronRight,
  Briefcase,
  GraduationCap,
  Users,
  BookOpen,
  School,
  Lock,
  Languages,
  Calendar,
  Star,
  MapPin,
  CheckCircle,
  Clock,
  Cake,
  Gem,
  Sparkles,
  Users2,
  Award,
  Palette,
  Smile,
  X,
  BookMarked,
  Maximize,
  Minimize,
  GripVertical,
  Search,
  Target,
  UserCheck,
  Link,
  Handshake,
  Edit3,
  ExternalLink,
  Bot,
  ShieldQuestion,
} from "lucide-react";

// Constants
const WORLDS: {
  [key: string]: { label: string; icon: React.ElementType; color: string };
} = {
  values: { label: "ערכים ועקרונות", icon: BookOpen, color: "blue" },
  personality: { label: "אישיות ותכונות", icon: Smile, color: "green" },
  relationship: { label: "זוגיות ומשפחה", icon: Heart, color: "rose" },
  partner: { label: "ציפיות מבן/בת הזוג", icon: Users, color: "indigo" },
  religion: { label: "דת ואמונה", icon: BookMarked, color: "amber" },
  general: { label: "שאלות כלליות", icon: FileText, color: "slate" },
};

// Types
import type {
  UserProfile,
  UserImage as UserImageType,
  QuestionnaireResponse,
  FormattedAnswer,
  ServiceType,
  HeadCoveringType,
  KippahType,
} from "@/types/next-auth";

// --- Helper Functions ---
const getInitials = (firstName?: string, lastName?: string): string => {
  let initials = "";
  if (firstName && firstName.length > 0) initials += firstName[0];
  if (lastName && lastName.length > 0) initials += lastName[0];
  if (initials.length === 0 && firstName && firstName.length > 0) {
    initials = firstName.length > 1 ? firstName.substring(0, 2) : firstName[0];
  }
  return initials.toUpperCase() || "?";
};

const calculateAge = (birthDate: Date | string | null | undefined): number => {
  if (!birthDate) return 0;
  try {
    const today = new Date();
    const birth = new Date(birthDate);
    if (isNaN(birth.getTime())) return 0;
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();
    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birth.getDate())
    ) {
      age--;
    }
    return age > 0 ? age : 0;
  } catch (e) {
    if (process.env.NODE_ENV === "development")
      console.error("Error calculating age:", e);
    return 0;
  }
};

const formatAvailabilityStatus = (
  status: UserProfile["availabilityStatus"] | undefined
) => {
  switch (status) {
    case "AVAILABLE":
      return {
        text: "פנוי/ה להצעות",
        color: "bg-emerald-500",
        icon: CheckCircle,
      };
    case "UNAVAILABLE":
      return { text: "לא פנוי/ה כרגע", color: "bg-red-500", icon: X };
    case "DATING":
      return { text: "בתהליך הכרות", color: "bg-amber-500", icon: Clock };
    case "PAUSED":
      return { text: "בהפסקה מהצעות", color: "bg-sky-500", icon: Clock };
    case "ENGAGED":
      return { text: "מאורס/ת", color: "bg-fuchsia-500", icon: Heart };
    case "MARRIED":
      return { text: "נשוי/אה", color: "bg-rose-500", icon: Heart };
    default:
      return { text: "סטטוס לא ידוע", color: "bg-slate-500", icon: InfoIcon };
  }
};

const formatCategoryLabel = (
  value: string | null | undefined,
  placeholder: string = "לא צוין"
): string => {
  if (!value || value.trim() === "") return placeholder;
  // Enhanced formatter for mixed case and specific abbreviations if needed
  // For now, keeping the existing logic which is generally good.
  // Example of more complex: value.replace(/_/g, ' ').replace(/\b(HS|BA|MA|PhD)\b/g, match => match.toUpperCase()).replace(/\b\w/g, l => l.toUpperCase());
  return value
    .replace(/_/g, " ")
    .replace(/\b(hs)\b/gi, (match) => match.toUpperCase()) // Example for HS
    .replace(/\b\w/g, (l) => l.toUpperCase())
    .replace(/ Hs$/, " HS") // Corrects trailing "Hs"
    .replace(/ Yes$/, " Yes")
    .replace(/ No$/, " No");
};

const formatBooleanPreference = (
  value: boolean | null | undefined,
  yesLabel: string = "כן",
  noLabel: string = "לא",
  notSpecifiedLabel: string = "לא צוין"
): string => {
  if (value === true) return yesLabel;
  if (value === false) return noLabel;
  return notSpecifiedLabel;
};

const formatStringBooleanPreference = (
  value: string | null | undefined,
  options: { [key: string]: string } = {
    yes: "כן",
    no: "לא",
    flexible: "גמיש/ה",
  },
  notSpecifiedLabel: string = "לא צוין"
): string => {
  if (value && options[value.toLowerCase()]) {
    return options[value.toLowerCase()];
  }
  return notSpecifiedLabel;
};

// --- Helper Components ---
const DetailItem: React.FC<{
  icon: React.ElementType;
  label: string;
  value: React.ReactNode;
  className?: string;
  iconColorClass?: string;
  valueClassName?: string;
  tooltip?: string;
}> = ({
  icon: Icon,
  label,
  value,
  className,
  iconColorClass = "text-gray-500",
  valueClassName,
  tooltip,
}) => {
  const content = (
    <div className={cn("flex items-start gap-1.5 sm:gap-2", className)}>
      <Icon
        className={cn(
          "w-3.5 h-3.5 mt-0.5 sm:mt-1 flex-shrink-0 sm:w-4 sm:h-4",
          iconColorClass
        )}
      />
      <div>
        <p className="text-[11px] sm:text-xs font-medium text-gray-500">
          {label}
        </p>
        <p
          className={cn(
            "text-xs sm:text-sm font-semibold text-gray-800 min-w-0 break-words",
            valueClassName
          )}
        >
          {value || "לא צוין"}
        </p>
      </div>
    </div>
  );

  if (tooltip) {
    return (
      <Tooltip>
        <TooltipTrigger asChild>{content}</TooltipTrigger>
        <TooltipContent side="top" className="max-w-xs text-center">
          <p>{tooltip}</p>
        </TooltipContent>
      </Tooltip>
    );
  }
  return content;
};

const EmptyState: React.FC<{
  icon: React.ElementType;
  message: string;
  description?: string;
  className?: string;
}> = ({ icon: Icon, message, description, className }) => (
  <div
    className={cn(
      "flex flex-col items-center justify-center py-6 sm:py-10 text-center",
      className
    )}
  >
    <Icon className="w-10 h-10 sm:w-12 sm:h-12 mb-2.5 sm:mb-3 text-gray-400/70" />
    <p className="text-sm sm:text-base font-semibold text-gray-600">
      {message}
    </p>
    {description && (
      <p className="text-xs sm:text-sm text-gray-500 mt-1 max-w-xs">
        {description}
      </p>
    )}
  </div>
);

const SectionCard: React.FC<{
  title: string;
  icon?: React.ElementType;
  children: React.ReactNode;
  className?: string;
  contentClassName?: string;
  titleClassName?: string;
  action?: React.ReactNode;
  description?: string;
}> = ({
  title,
  icon: Icon,
  children,
  className,
  contentClassName,
  titleClassName,
  action,
  description,
}) => {
  return (
    <div
      className={cn(
        "bg-white rounded-lg sm:rounded-xl shadow-lg border border-gray-200/60 overflow-hidden flex flex-col min-w-0",
        className
      )}
    >
      <div
        className={cn(
          "flex items-center justify-between gap-2 p-2.5 sm:p-3 md:p-3.5 border-b border-gray-200/70 bg-slate-50/80 min-w-0",
          titleClassName
        )}
      >
        <div className="flex items-center gap-1.5 sm:gap-2 min-w-0">
          {Icon && (
            <Icon className="w-4 h-4 sm:w-5 sm:h-5 text-cyan-600 flex-shrink-0" />
          )}
          <div className="min-w-0">
            <h3 className="text-sm sm:text-base md:text-lg font-semibold text-gray-700 truncate">
              {title}
            </h3>
            {description && (
              <p className="text-[11px] sm:text-xs text-gray-500 mt-0.5 truncate">
                {description}
              </p>
            )}
          </div>
        </div>
        {action && <div className="ml-auto flex-shrink-0">{action}</div>}
      </div>
      <div className={cn("p-2.5 sm:p-3 md:p-4 min-w-0", contentClassName)}>
        {children}
      </div>
    </div>
  );
};

// --- Profile Header Component ---
const ProfileHeader: React.FC<{
  profile: UserProfile;
  age: number; // This is already calculated
  userInitials: string;
  mainImageToDisplay: UserImageType | null;
  availability: ReturnType<typeof formatAvailabilityStatus>;
  viewMode: "matchmaker" | "candidate";
}> = ({
  profile,
  age,
  userInitials,
  mainImageToDisplay,
  availability,
  viewMode,
}) => {
  // Log 1: Check incoming props and calculated age at the component level
  console.log(
    "[ProfileHeader] Props:",
    {
      birthDate: profile.birthDate,
      birthDateIsApproximate: profile.birthDateIsApproximate,
      calculatedAge: age,
      firstName: profile.user?.firstName, // For identification
    }
  );

  const allProfileDetails = useMemo(
    () => {
      // Log 2: Inside useMemo, before defining the age detail object
      console.log(
        "[ProfileHeader useMemo] Values for age calculation:",
        {
          age, // Calculated age passed to useMemo
          birthDateIsApproximate: profile.birthDateIsApproximate,
        }
      );

      return [
        {
          label: "גיל",
          value: (() => {
            // Log 3: Inside the IIFE for age value
            console.log(
              "[ProfileHeader Age IIFE] Checking conditions:",
              {
                currentAge: age,
                isApprox: profile.birthDateIsApproximate,
              }
            );

            if (age > 0) {
              console.log("[ProfileHeader Age IIFE] Condition: age > 0 is TRUE");
              return (
                <>
                  {age}
                  {profile.birthDateIsApproximate && (
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <span className="text-xs text-gray-500 cursor-help"> (משוער)</span>
                      </TooltipTrigger>
                      <TooltipContent side="top">
                        <p className="text-xs max-w-xs text-center">
                          הגיל הוזן על ידי השדכן והוא משקף את הגיל בקירוב
                        </p>
                      </TooltipContent>
                    </Tooltip>
                  )}
                </>
              );
            }

            console.log("[ProfileHeader Age IIFE] Condition: age > 0 is FALSE");
            if (profile.birthDateIsApproximate === true) {
              console.log("[ProfileHeader Age IIFE] Condition: profile.birthDateIsApproximate === true is TRUE");
              return (
                <Tooltip>
                  <TooltipTrigger asChild>
                    <span>משוער (לא צוין ערך)</span>
                  </TooltipTrigger>
                  <TooltipContent side="top">
                    <p className="text-xs max-w-xs text-center">
                      צוין שהגיל הוא הערכה, אך לא הוזן תאריך לידה ספציפי.
                    </p>
                  </TooltipContent>
                </Tooltip>
              );
            }
            console.log("[ProfileHeader Age IIFE] Condition: profile.birthDateIsApproximate === true is FALSE, returning '-'");
            return "-";
          })(),
          icon: Cake,
          color: "pink-600",
          condition: age > 0 || profile.birthDateIsApproximate === true,
        },
        // ... (rest of allProfileDetails objects)
        {
          label: "מצב משפחתי",
          value: profile.maritalStatus
            ? formatCategoryLabel(profile.maritalStatus, "-")
            : "-",
          icon: Heart,
          color: "rose-600",
          condition: !!profile.maritalStatus,
        },
        {
          label: "סטטוס",
          value: availability.text,
          icon: availability.icon,
          color: availability.color.replace("bg-", ""),
          isBadge: true,
          badgeColor: availability.color,
          badgeTextColor: "text-white",
        },
        {
          label: "עיר",
          value: profile.city,
          icon: MapPin,
          color: "teal-600",
          condition: !!profile.city,
        },
        {
          label: "מוצא",
          value: profile.origin,
          icon: Gem,
          color: "purple-600",
          condition: !!profile.origin,
        },
        {
          label: "רמה דתית",
          value: profile.religiousLevel
            ? formatCategoryLabel(profile.religiousLevel)
            : "-",
          icon: BookMarked,
          color: "indigo-600",
          condition: !!profile.religiousLevel,
        },
        {
          label: "עיסוק",
          value: profile.occupation,
          icon: Briefcase,
          color: "emerald-600",
          condition: !!profile.occupation,
        },
        {
          label: "השכלה",
          value: profile.educationLevel
            ? formatCategoryLabel(profile.educationLevel)
            : profile.education || "-",
          icon: GraduationCap,
          color: "sky-600",
          condition: !!(profile.educationLevel || profile.education),
        },
        {
          label: "גובה",
          value: profile.height ? `${profile.height} ס״מ` : "-",
          icon: User,
          color: "slate-600",
          condition: !!profile.height,
        },
        {
          label: "שומר/ת נגיעה",
          value: formatBooleanPreference(profile.shomerNegiah),
          icon: Sparkles,
          color: "pink-600",
          condition:
            typeof profile.shomerNegiah === "boolean" ||
            profile.shomerNegiah === null,
        },
        ...(profile.gender === "FEMALE"
          ? [
              {
                label: "כיסוי ראש",
                value: profile.headCovering
                  ? formatCategoryLabel(profile.headCovering)
                  : "-",
                icon: UserCheck,
                color: "slate-600",
                condition: !!profile.headCovering,
              },
            ]
          : []),
        ...(profile.gender === "MALE"
          ? [
              {
                label: "סוג כיפה",
                value: profile.kippahType
                  ? formatCategoryLabel(profile.kippahType)
                  : "-",
                icon: UserCheck,
                color: "slate-600",
                condition: !!profile.kippahType,
              },
            ]
          : []),
        {
          label: "שפת אם",
          value: profile.nativeLanguage
            ? formatCategoryLabel(profile.nativeLanguage)
            : "-",
          icon: Languages,
          color: "emerald-600",
          condition: !!profile.nativeLanguage,
        },
      ].filter(
        (detail) =>
          detail.condition !== false && detail.value && detail.value !== "-"
      );
    },
    // Dependencies for useMemo
    [profile, age, availability] // profile includes birthDate, birthDateIsApproximate
  );

  // ... (rest of ProfileHeader JSX)
  return (
    <div className="p-3 sm:p-4 md:p-5 bg-gradient-to-br from-slate-100 via-white to-sky-100/30 border-b border-slate-200/80">
      <div className="flex flex-col sm:flex-row items-center sm:items-start gap-3 sm:gap-4 md:gap-6">
        <div className="relative h-20 w-20 sm:h-24 sm:w-24 md:h-32 md:w-32 rounded-full overflow-hidden border-2 border-white shadow-xl ring-2 ring-cyan-500/60 flex-shrink-0">
          {mainImageToDisplay && mainImageToDisplay.url ? (
            <Image
              src={mainImageToDisplay.url}
              alt={`תמונת פרופיל ראשית של ${
                profile.user?.firstName || "מועמד"
              }`}
              fill
              className="object-cover"
              sizes="(max-width: 640px) 80px, (max-width: 768px) 96px, 128px"
              priority
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-slate-200 to-slate-300">
              <span className="text-3xl sm:text-4xl md:text-5xl font-medium text-slate-500">
                {userInitials}
              </span>
            </div>
          )}
        </div>
        <div className="flex-grow text-center sm:text-right space-y-2 sm:space-y-2.5">
          <div>
            <h1 className="text-xl sm:text-2xl md:text-3xl font-bold text-slate-800">
              {profile.user?.firstName || "שם פרטי"}{" "}
              {profile.user?.lastName || "שם משפחה"}
            </h1>
          </div>
          <div className="grid grid-cols-2 gap-x-2 gap-y-1.5 pt-1 sm:grid-cols-3 sm:gap-x-3 sm:gap-y-2 md:grid-cols-3 lg:grid-cols-4">
            {allProfileDetails.map((detail, index) => {
              const IconComponent = detail.icon;
              const valueContent =
                typeof detail.value === "string"
                  ? detail.value
                  : React.isValidElement(detail.value)
                  ? detail.value
                  : "-";

              if (detail.isBadge) {
                return (
                  <div key={index} className="flex items-center gap-1">
                    <IconComponent
                      className={cn(
                        "w-3 h-3 sm:w-3.5 sm:h-3.5 flex-shrink-0",
                        detail.badgeTextColor
                          ? detail.badgeTextColor
                          : `text-${detail.color}`
                      )}
                    />
                    <div className="min-w-0">
                      <span className="text-[10px] sm:text-xs text-slate-500 whitespace-nowrap">
                        {detail.label}:
                      </span>
                      <Badge
                        className={cn(
                          "text-[9px] sm:text-[10px] px-1 py-px sm:px-1.5 sm:py-0.5 font-medium ml-0.5 sm:ml-1",
                          detail.badgeColor,
                          detail.badgeTextColor
                        )}
                      >
                        {valueContent}
                      </Badge>
                    </div>
                  </div>
                );
              }
              return (
                <div key={index} className="flex items-center gap-1 min-w-0">
                  <IconComponent
                    className={cn(
                      "w-3 h-3 sm:w-3.5 sm:h-3.5 flex-shrink-0",
                      `text-${detail.color}`
                    )}
                  />
                  <div className="min-w-0">
                    <span className="text-[10px] sm:text-xs text-slate-500 whitespace-nowrap">
                        {detail.label}:
                    </span>
                    <span
                      className="ml-0.5 sm:ml-1 text-xs sm:text-sm font-medium text-slate-700 truncate"
                      title={
                        typeof valueContent === "string" && valueContent.length > 20
                          ? valueContent
                          : undefined
                      }
                    >
                      {valueContent}
                    </span>
                  </div>
                </div>
              );
            })}
          </div>
          {profile.lastActive && viewMode === "matchmaker" && (
            <p className="text-[10px] sm:text-xs text-slate-500 flex items-center gap-1 pt-1 sm:pt-1.5 justify-center sm:justify-start">
              <Clock className="w-2.5 h-2.5 sm:w-3 sm:h-3" />
              נצפה לאחרונה:{" "}
              {new Date(profile.lastActive).toLocaleDateString("he-IL", {
                day: "2-digit",
                month: "2-digit",
                year: "2-digit",
              })}
            </p>
          )}
          {viewMode === "matchmaker" && (
            <div className="pt-1 sm:pt-2 flex justify-center sm:justify-start">
              <Button
                variant="outline"
                size="xs" // ensures it's small
                className="text-cyan-600 border-cyan-500 hover:bg-cyan-50 text-[10px] sm:text-xs px-2 py-1"
              >
                <Link className="w-3 h-3 sm:w-3.5 sm:h-3.5 ml-1 sm:ml-1.5" />
                הצע התאמה
              </Button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};


// ProfileCard.tsx - QuestionnaireItem component

const QuestionnaireItem: React.FC<{
  answer: FormattedAnswer;
  worldColor?: string;
}> = ({ answer, worldColor = "slate" }) => {
  return (
    <div
      className={cn(
        "p-2.5 sm:p-3.5 rounded-md sm:rounded-lg border hover:shadow-md transition-shadow",
        `bg-${worldColor}-50/50 border-${worldColor}-200/70`,
        "flex flex-col min-w-0" // min-w-0 חשוב למניעת גלישה של האלמנט עצמו
      )}
    >
      <p // Question
        className={cn(
          "text-xs sm:text-sm font-medium mb-1 sm:mb-1.5 min-w-0 break-words", // break-words לשאלה (בדרך כלל מספיק)
          `text-${worldColor}-700`
        )}
      >
        {answer.question}
      </p>
      <p // Answer
        className={cn(
          "text-sm sm:text-base font-semibold text-slate-800 whitespace-pre-wrap min-w-0",
          "break-all" // <--- שינוי: מ-break-words ל-break-all
        )}
      >
        {answer.displayText || answer.answer}
      </p>
    </div>
  );
};

interface ProfileCardProps {
  profile: UserProfile;
  images?: UserImageType[];
  questionnaire?: QuestionnaireResponse | null;
  viewMode?: "matchmaker" | "candidate";
  className?: string;
}

const ProfileCard: React.FC<ProfileCardProps> = ({
  profile,
  images = [],
  questionnaire,
  viewMode = "candidate",
  className,
}) => {
  const [isClient, setIsClient] = useState(false);
  const [isDesktop, setIsDesktop] = useState(true);

  useEffect(() => {
    setIsClient(true);
    const checkScreenSize = () => {
      setIsDesktop(window.innerWidth >= 768); // md breakpoint
    };
    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);
    return () => window.removeEventListener("resize", checkScreenSize);
  }, []);

  const [selectedImageForDialog, setSelectedImageForDialog] =
    useState<UserImageType | null>(null);
  const orderedImages = useMemo(() => {
    if (!images || images.length === 0) return [];
    const validImages = images.filter((img) => img.url);
    const mainImg = validImages.find((img) => img.isMain);
    const otherImages = validImages.filter((img) => !img.isMain);
    return mainImg ? [mainImg, ...otherImages] : otherImages;
  }, [images]);

  const [activeMainImageIndex, setActiveMainImageIndex] = useState<number>(
    () => {
      const mainIndex = orderedImages.findIndex((img) => img.isMain);
      return mainIndex !== -1 ? mainIndex : orderedImages.length > 0 ? 0 : -1;
    }
  );

  const [activeTab, setActiveTab] = useState("about_me");

  const [mainContentPanelSize, setMainContentPanelSize] = useState(65);
  const [sidePhotosPanelSize, setSidePhotosPanelSize] = useState(35);

  const age = useMemo(
    () => calculateAge(profile.birthDate),
    [profile.birthDate]
  );
  const userInitials = useMemo(
    () => getInitials(profile.user?.firstName, profile.user?.lastName),
    [profile.user?.firstName, profile.user?.lastName]
  );

  const mainImageToDisplay = useMemo(() => {
    if (activeMainImageIndex !== -1 && orderedImages[activeMainImageIndex]) {
      return orderedImages[activeMainImageIndex];
    }
    return null;
  }, [orderedImages, activeMainImageIndex]);

  const availability = useMemo(
    () => formatAvailabilityStatus(profile.availabilityStatus),
    [profile.availabilityStatus]
  );

  const handleOpenImageDialog = (image: UserImageType) =>
    image.url && setSelectedImageForDialog(image);
  const handleCloseImageDialog = () => setSelectedImageForDialog(null);

  const currentDialogImageIndex = useMemo(() => {
    if (!selectedImageForDialog || !selectedImageForDialog.url) return -1;
    return orderedImages.findIndex(
      (img) => img.id === selectedImageForDialog.id
    );
  }, [selectedImageForDialog, orderedImages]);

  const handleDialogNav = (direction: "next" | "prev") => {
    if (currentDialogImageIndex === -1 || orderedImages.length <= 1) return;
    let newIndex =
      direction === "next"
        ? currentDialogImageIndex + 1
        : currentDialogImageIndex - 1;
    newIndex = (newIndex + orderedImages.length) % orderedImages.length;
    setSelectedImageForDialog(orderedImages[newIndex]);
  };

  const hasDisplayableQuestionnaireAnswers = useMemo(
    () =>
      questionnaire &&
      questionnaire.formattedAnswers &&
      Object.values(questionnaire.formattedAnswers).some((answers) => {
        const typedAnswers = (answers || []) as FormattedAnswer[];
        return typedAnswers.some(
          (a) => a.isVisible !== false && (a.answer || a.displayText)
        );
      }),
    [questionnaire]
  );

  const tabItems = useMemo(
    () => [
      { value: "about_me", label: "קצת עליי", icon: User, activeColor: "cyan" },
      {
        value: "background_worldview",
        label: "רקע והשקפה",
        icon: BookOpen,
        activeColor: "indigo",
      },
      {
        value: "looking_for",
        label: "מה הם מחפשים?",
        icon: Target,
        activeColor: "green",
      },
      ...(questionnaire
        ? [
            {
              value: "questionnaire",
              label: "מהשאלון",
              icon: FileText,
              activeColor: "pink",
            },
          ]
        : []),
      {
        value: "photos_tab",
        label: "תמונות",
        icon: ImageIcon,
        activeColor: "slate",
        count: orderedImages.length,
      },
      ...(viewMode === "matchmaker"
        ? [
            {
              value: "matchmaker_info",
              label: "מידע לשדכן",
              icon: Lock,
              activeColor: "amber",
            },
          ]
        : []),
    ],
    [orderedImages.length, questionnaire, viewMode]
  );

  const togglePanels = useCallback(() => {
    if (mainContentPanelSize > 50) {
      setMainContentPanelSize(30);
      setSidePhotosPanelSize(70);
    } else {
      setMainContentPanelSize(65);
      setSidePhotosPanelSize(35);
    }
  }, [mainContentPanelSize]);

  const renderPreferenceBadges = (
    label: string,
    icon: React.ElementType,
    iconColorClass: string,
    values:
      | string[]
      | ServiceType[]
      | HeadCoveringType[]
      | KippahType[]
      | undefined,
    badgeColorClass: string,
    formatter: (val: string) => string = formatCategoryLabel
  ) => {
    if (!values || values.length === 0) return null;
    const IconComponent = icon;
    return (
      <div>
        <p
          className={cn(
            "text-xs font-medium text-slate-500 mb-1 sm:mb-1.5 flex items-center gap-1 sm:gap-1.5",
            iconColorClass
          )}
        >
          <IconComponent className="w-3.5 h-3.5 sm:w-4 sm:h-4" /> {label}
        </p>
        <div className="flex flex-wrap gap-1 sm:gap-1.5">
          {(values as string[]).map((val) => (
            <Badge
              key={val}
              variant="outline"
              className={cn(
                "text-[10px] sm:text-xs px-1.5 py-0.5 sm:px-2",
                badgeColorClass
              )}
            >
              {formatter(val)}
            </Badge>
          ))}
        </div>
      </div>
    );
  };

  const MainContentTabs = ({
    inScrollArea = false,
  }: {
    inScrollArea?: boolean;
  }) => (
    <Tabs
      value={activeTab}
      onValueChange={setActiveTab}
      className="w-full flex flex-col flex-grow min-h-0"
    >
      <div
        className={cn(
          "bg-white/90 backdrop-blur-sm p-1 sm:p-1.5 rounded-md sm:rounded-lg mb-2.5 sm:mb-3 shadow-md border border-gray-200/80 flex-shrink-0",
          inScrollArea ? "sticky top-0 z-20" : ""
        )}
      >
        <ScrollArea dir="rtl" className="w-full">
          {" "}
          {/* ודא שזה כאן */}
          <TabsList className="h-auto inline-flex bg-transparent flex-nowrap justify-start p-0.5 sm:p-1">
            {tabItems.map((tab) => (
              <TabsTrigger
                key={tab.value}
                value={tab.value}
                className={cn(
                  // הקטנתי ריווחים ופונטים למובייל עוד קצת
                  "flex items-center gap-0.5 px-1 py-0.5 text-[9px] rounded-sm", // Mobile base (very compact)
                  "sm:gap-1 sm:px-1.5 sm:py-1 sm:text-[10px] sm:rounded-md", // SM breakpoint
                  "md:gap-1.5 md:px-2 md:py-1.5 md:text-xs", // MD breakpoint
                  "whitespace-nowrap transition-all duration-200 border-b-2",
                  "text-slate-500 hover:text-slate-700 hover:bg-slate-100",
                  activeTab === tab.value
                    ? cn(
                        `font-semibold border-${tab.activeColor}-500 text-${tab.activeColor}-600 bg-white shadow-sm`,
                        `hover:text-${tab.activeColor}-700 hover:bg-${tab.activeColor}-50/50`
                      )
                    : "border-transparent"
                )}
              >
                <tab.icon
                  className={cn(
                    "w-2.5 h-2.5 sm:w-3 sm:h-3", // Smaller base icon
                    activeTab === tab.value
                      ? `text-${tab.activeColor}-500`
                      : "text-slate-400"
                  )}
                />
                <span>{tab.label}</span>
                {tab.count !== undefined && tab.count > 0 && (
                  <span
                    className={cn(
                      `text-[8px] sm:text-[9px] rounded-full px-1 py-px ml-0.5 hidden sm:inline-block font-mono`, // Smaller badge
                      activeTab === tab.value
                        ? `bg-${tab.activeColor}-100 text-${tab.activeColor}-700`
                        : `bg-slate-200 text-slate-600`
                    )}
                  >
                    {tab.count}
                  </span>
                )}
              </TabsTrigger>
            ))}
          </TabsList>
          <ScrollBar orientation="horizontal" /> {/* ודא שזה כאן */}
        </ScrollArea>
      </div>

      <div
        className={cn(
          "space-y-2.5 sm:space-y-3 focus:outline-none",
          !inScrollArea && "flex-grow min-h-0 overflow-y-auto overflow-x-hidden"
        )}
      >
        <TabsContent value="about_me" className="min-h-0 w-full">
          <SectionCard
            title="אודותיי"
            icon={InfoIcon}
            contentClassName="space-y-2.5 sm:space-y-3"
          >
            {profile.about ? (
              // === MODIFICATION HERE ===
              <p className="text-slate-700 whitespace-pre-wrap break-words text-xs sm:text-sm leading-relaxed p-1.5 sm:p-2 bg-slate-50 rounded-md min-w-0">
                {/* Added min-w-0 and ensured break-words */}
                {profile.about}
              </p>
            ) : (
              <EmptyState
                icon={InfoIcon}
                message="לא הוזן תיאור אישי"
                className="py-4 sm:py-6"
              />
            )}
          </SectionCard>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-2.5 sm:gap-3 mt-2.5 sm:mt-3">
            <SectionCard title="תכונות אופי (שלי)" icon={Smile}>
              {profile.profileCharacterTraits &&
              profile.profileCharacterTraits.length > 0 ? (
                <div className="flex flex-wrap gap-1 sm:gap-1.5">
                  {profile.profileCharacterTraits.map((trait, index) => (
                    <Badge
                      key={index}
                      variant="secondary"
                      className="px-1.5 py-0.5 sm:px-2 sm:py-1 bg-purple-100 text-purple-700 border border-purple-200/70 shadow-xs text-[10px] sm:text-xs"
                    >
                      {trait}
                    </Badge>
                  ))}
                </div>
              ) : (
                <EmptyState
                  icon={Smile}
                  message="לא צוינו תכונות"
                  className="py-4 sm:py-6"
                />
              )}
            </SectionCard>
            <SectionCard title="תחביבים (שלי)" icon={Palette}>
              {profile.profileHobbies && profile.profileHobbies.length > 0 ? (
                <div className="flex flex-wrap gap-1 sm:gap-1.5">
                  {profile.profileHobbies.map((hobby, index) => (
                    <Badge
                      key={index}
                      variant="secondary"
                      className="px-1.5 py-0.5 sm:px-2 sm:py-1 bg-teal-100 text-teal-700 border border-teal-200/70 shadow-xs text-[10px] sm:text-xs"
                    >
                      {hobby}
                    </Badge>
                  ))}
                </div>
              ) : (
                <EmptyState
                  icon={Palette}
                  message="לא צוינו תחביבים"
                  className="py-4 sm:py-6"
                />
              )}
            </SectionCard>
          </div>
          <SectionCard
            title="רקע משפחתי ואישי"
            icon={Users2}
            contentClassName="space-y-2.5 sm:space-y-3"
            className="mt-2.5 sm:mt-3"
          >
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-x-2.5 sm:gap-x-3 gap-y-2 sm:gap-y-2.5">
              <DetailItem
                icon={Users2}
                label="מצב הורים"
                value={formatCategoryLabel(profile.parentStatus)}
                iconColorClass="text-purple-600"
              />
              <DetailItem
                icon={Users}
                label="מספר אחים/אחיות"
                value={profile.siblings?.toString()}
                iconColorClass="text-purple-600"
              />
              <DetailItem
                icon={User}
                label="מיקום במשפחה"
                value={profile.position?.toString()}
                iconColorClass="text-purple-600"
              />
              {(profile.maritalStatus?.toLowerCase() === "divorced" ||
                profile.maritalStatus?.toLowerCase() === "widowed") && (
                <DetailItem
                  icon={Users2}
                  label="ילדים מקשר קודם (שלי)"
                  value={formatBooleanPreference(
                    profile.hasChildrenFromPrevious
                  )}
                  iconColorClass="text-purple-600"
                />
              )}
              {profile.aliyaCountry && (
                <DetailItem
                  icon={MapPin}
                  label="ארץ עלייה"
                  value={profile.aliyaCountry}
                  iconColorClass="text-cyan-600"
                />
              )}
              {profile.aliyaYear && (
                <DetailItem
                  icon={Calendar}
                  label="שנת עלייה"
                  value={profile.aliyaYear.toString()}
                  iconColorClass="text-cyan-600"
                />
              )}
            </div>
            {profile.additionalLanguages &&
              profile.additionalLanguages.length > 0 && (
                <div className="pt-2 sm:pt-2.5 border-t border-slate-200/60 mt-2 sm:mt-2.5">
                  <p className="text-xs font-medium text-slate-500 mb-1 sm:mb-1.5 flex items-center gap-1 sm:gap-1.5">
                    <Languages className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-emerald-600" />{" "}
                    שפות נוספות
                  </p>
                  <div className="flex flex-wrap gap-1 sm:gap-1.5">
                    {profile.additionalLanguages.map((lang) => (
                      <Badge
                        key={lang}
                        variant="outline"
                        className="px-1.5 py-0.5 bg-emerald-50 text-emerald-800 border-emerald-200 text-[10px] sm:text-xs shadow-xs"
                      >
                        {formatCategoryLabel(lang)}
                      </Badge>
                    ))}
                  </div>
                </div>
              )}
          </SectionCard>
        </TabsContent>

        <TabsContent value="background_worldview" className="min-h-0 w-full">
          <SectionCard
            title="דת ואמונה"
            icon={BookMarked}
            contentClassName="space-y-2.5 sm:space-y-3"
          >
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-x-2.5 sm:gap-x-3 gap-y-2 sm:gap-y-2.5">
              <DetailItem
                icon={BookMarked}
                label="רמה דתית"
                value={formatCategoryLabel(profile.religiousLevel)}
                iconColorClass="text-indigo-600"
              />
              <DetailItem
                icon={Sparkles}
                label="שמירת נגיעה"
                value={formatBooleanPreference(profile.shomerNegiah)}
                iconColorClass="text-pink-600"
              />
              {profile.gender === "FEMALE" && (
                <DetailItem
                  icon={UserCheck}
                  label="כיסוי ראש"
                  value={formatCategoryLabel(profile.headCovering)}
                  iconColorClass="text-slate-600"
                />
              )}
              {profile.gender === "MALE" && (
                <DetailItem
                  icon={UserCheck}
                  label="סוג כיפה"
                  value={formatCategoryLabel(profile.kippahType)}
                  iconColorClass="text-slate-600"
                />
              )}
            </div>
          </SectionCard>
          <SectionCard
            title="השכלה ותעסוקה"
            icon={GraduationCap}
            contentClassName="space-y-2.5 sm:space-y-3 mt-2.5 sm:mt-3"
          >
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-2.5 sm:gap-x-3 gap-y-2 sm:gap-y-2.5">
              <DetailItem
                icon={GraduationCap}
                label="רמת השכלה"
                value={formatCategoryLabel(profile.educationLevel)}
                iconColorClass="text-sky-600"
              />
              <DetailItem
                icon={School}
                label="פירוט השכלה"
                value={profile.education}
                iconColorClass="text-sky-600"
                valueClassName="whitespace-pre-wrap break-words"
              />
              <DetailItem
                icon={Briefcase}
                label="עיסוק"
                value={profile.occupation}
                iconColorClass="text-emerald-600"
              />
              <DetailItem
                icon={Award}
                label="שירות צבאי/לאומי"
                value={formatCategoryLabel(profile.serviceType)}
                iconColorClass="text-amber-600"
              />
              {profile.serviceDetails && (
                <DetailItem
                  icon={InfoIcon}
                  label="פרטי שירות"
                  value={profile.serviceDetails}
                  iconColorClass="text-amber-600"
                  valueClassName="whitespace-pre-wrap break-words"
                />
              )}
            </div>
          </SectionCard>
        </TabsContent>

        <TabsContent value="looking_for" className="min-h-0 w-full">
          <SectionCard
            title="העדפות לבן/בת הזוג"
            icon={Target}
            contentClassName="space-y-3 sm:space-y-4"
            description="מה המועמד/ת מחפש/ת בהתאמה"
          >
            {profile.matchingNotes && (
              <div>
                <p className="text-xs font-medium text-slate-500 mb-1 sm:mb-1.5 flex items-center gap-1 sm:gap-1.5">
                  <FileText className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-gray-500" />{" "}
                  תיאור כללי על המבוקש/ת:
                </p>
                <p className="text-xs sm:text-sm text-slate-700 whitespace-pre-wrap break-words bg-slate-100 p-2 sm:p-2.5 rounded-md border border-slate-200">
                  {profile.matchingNotes}
                </p>
              </div>
            )}
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-2.5 sm:gap-x-3 gap-y-2.5 sm:gap-y-3">
              {(profile.preferredAgeMin || profile.preferredAgeMax) && (
                <DetailItem
                  icon={Calendar}
                  label="טווח גילאים"
                  value={`${profile.preferredAgeMin || "?"} - ${
                    profile.preferredAgeMax || "?"
                  } שנים`}
                  iconColorClass="text-blue-600"
                />
              )}
              {(profile.preferredHeightMin || profile.preferredHeightMax) && (
                <DetailItem
                  icon={User}
                  label="טווח גבהים"
                  value={`${profile.preferredHeightMin || "?"} - ${
                    profile.preferredHeightMax || "?"
                  } ס״מ`}
                  iconColorClass="text-blue-600"
                />
              )}
              <DetailItem
                icon={ShieldQuestion}
                label="שמירת נגיעה"
                value={formatStringBooleanPreference(
                  profile.preferredShomerNegiah
                )}
                iconColorClass="text-pink-600"
                tooltip="העדפה לגבי שמירת נגיעה של בן/בת הזוג"
              />
              <DetailItem
                icon={Users2}
                label="ילדים מקשר קודם"
                value={formatBooleanPreference(
                  profile.preferredHasChildrenFromPrevious // Note: In your type this is boolean, should be string 'yes_ok', 'no_preferred', etc.
                  // Assuming it's string from context, if boolean, adjust formatStringBooleanPreference.
                )}
                iconColorClass="text-purple-600"
                tooltip="העדפה לגבי ילדים מקשר קודם של בן/בת הזוג"
              />
              {renderPreferenceBadges(
                "סטטוסים משפחתיים מועדפים",
                Heart,
                "text-rose-600",
                profile.preferredMaritalStatuses,
                "bg-rose-50 text-rose-700 border-rose-200"
              )}
              {renderPreferenceBadges(
                "מוצאים מועדפים",
                Gem,
                "text-purple-600",
                profile.preferredOrigins,
                "bg-purple-50 text-purple-700 border-purple-200"
              )}
              {renderPreferenceBadges(
                "רמות דתיות מועדפות",
                BookMarked,
                "text-indigo-600",
                profile.preferredReligiousLevels,
                "bg-indigo-50 text-indigo-700 border-indigo-200"
              )}
              {profile.preferredAliyaStatus && (
                <DetailItem
                  icon={MapPin}
                  label="סטטוס עלייה מועדף"
                  value={formatCategoryLabel(profile.preferredAliyaStatus)}
                  iconColorClass="text-cyan-600"
                />
              )}
            </div>
            {!profile.matchingNotes &&
              !profile.preferredAgeMin &&
              !profile.preferredAgeMax &&
              !profile.preferredHeightMin &&
              !profile.preferredHeightMax &&
              !profile.preferredShomerNegiah &&
              typeof profile.preferredHasChildrenFromPrevious !== "boolean" && // or check for undefined string
              (!profile.preferredMaritalStatuses ||
                profile.preferredMaritalStatuses.length === 0) &&
              (!profile.preferredOrigins ||
                profile.preferredOrigins.length === 0) &&
              (!profile.preferredReligiousLevels ||
                profile.preferredReligiousLevels.length === 0) &&
              !profile.preferredAliyaStatus && (
                <EmptyState
                  icon={Search}
                  message="לא צוינו העדפות ספציפיות לחיפוש"
                  className="py-4 sm:py-6"
                />
              )}
          </SectionCard>
        </TabsContent>

        {tabItems.find((tab) => tab.value === "questionnaire") && (
          <TabsContent
            value="questionnaire"
            className="focus:outline-none min-h-0 w-full"
          >
            {hasDisplayableQuestionnaireAnswers ? (
              <div className="space-y-2.5 sm:space-y-3">
                {Object.entries(questionnaire?.formattedAnswers || {}).map(
                  ([worldKey, answers]) => {
                    const worldConfig = WORLDS[worldKey] ||
                      WORLDS.general || {
                        label: formatCategoryLabel(worldKey, "שאלות נוספות"),
                        icon: FileText,
                        color: "slate",
                      };
                    const typedAnswers = (answers || []) as FormattedAnswer[];
                    const visibleAnswers = typedAnswers.filter(
                      (a) =>
                        a.isVisible !== false && (a.answer || a.displayText)
                    );
                    if (visibleAnswers.length === 0) return null;
                    return (
                      <SectionCard
                        key={worldKey}
                        title={worldConfig.label}
                        icon={worldConfig.icon}
                        contentClassName="space-y-2 sm:space-y-2.5"
                      >
                        {visibleAnswers.map((answer) => (
                          <QuestionnaireItem
                            key={answer.questionId}
                            answer={answer}
                            worldColor={worldConfig.color}
                          />
                        ))}
                      </SectionCard>
                    );
                  }
                )}
              </div>
            ) : (
              <SectionCard title="מהשאלון" icon={FileText}>
                <EmptyState
                  icon={FileText}
                  message="שאלון אינו זמין לצפייה כעת"
                  description={
                    questionnaire?.completed
                      ? "המועמד בחר לא להציג את תשובות השאלון, או שאין תשובות זמינות כעת."
                      : "המועמד טרם מילא את השאלון במלואו."
                  }
                  className="py-6 sm:py-8"
                />
              </SectionCard>
            )}
          </TabsContent>
        )}

        <TabsContent value="photos_tab" className="min-h-0 w-full">
          <SectionCard title="גלריית תמונות" icon={ImageIcon}>
            {orderedImages.length > 0 ? (
              <div className="grid grid-cols-2 gap-2 sm:grid-cols-3 sm:gap-2.5">
                {orderedImages.map((image) => (
                  <div
                    key={image.id}
                    className="relative aspect-[4/5] rounded-md sm:rounded-lg overflow-hidden cursor-pointer group shadow-md border border-gray-200/80 hover:shadow-xl transition-all duration-300"
                    onClick={() => handleOpenImageDialog(image)}
                  >
                    <Image
                      src={image.url!}
                      alt={`תמונה של ${profile.user?.firstName || "משתמש"}`}
                      fill
                      className="object-cover transition-transform duration-300 group-hover:scale-105"
                      sizes="(max-width: 640px) 50vw, (max-width: 768px) 33vw, 25vw"
                    />
                    <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-black/10 opacity-0 group-hover:opacity-100 transition-opacity flex items-end p-1.5 sm:p-2">
                      <Eye className="w-4 h-4 sm:w-5 sm:h-5 text-white drop-shadow-md" />
                    </div>
                    {image.isMain && (
                      <Badge className="absolute top-1 right-1 sm:top-1.5 sm:right-1.5 bg-yellow-400 text-black border-0 shadow-lg text-[9px] sm:text-xs px-1 sm:px-1.5 py-0.5 flex items-center gap-0.5 sm:gap-1">
                        <Star className="w-2.5 h-2.5 sm:w-3 sm:h-3 fill-black" />{" "}
                        ראשי
                      </Badge>
                    )}
                  </div>
                ))}
              </div>
            ) : (
              <EmptyState
                icon={ImageIcon}
                message="לא הועלו תמונות"
                description="מומלץ להעלות מספר תמונות ברורות."
                className="py-6 sm:py-8"
              />
            )}
          </SectionCard>
        </TabsContent>

        {viewMode === "matchmaker" && (
          <TabsContent value="matchmaker_info" className="min-h-0 w-full">
            <div className="bg-amber-50 border-2 border-amber-300/70 rounded-lg sm:rounded-xl shadow-lg p-2.5 sm:p-3 md:p-4 space-y-2.5 sm:space-y-3">
              <div className="flex items-center gap-1.5 sm:gap-2 text-amber-700">
                <Lock className="w-4 h-4 sm:w-5 sm:h-5" />
                <h3 className="font-semibold text-base sm:text-lg">
                  מידע רגיש לשדכנים בלבד
                </h3>
              </div>
              <DetailItem
                icon={Phone}
                label="העדפת יצירת קשר"
                value={formatCategoryLabel(profile.contactPreference, "-")}
                iconColorClass="text-amber-600"
              />
              <DetailItem
                icon={Handshake}
                label="העדפת מגדר שדכן/ית"
                value={
                  profile.preferredMatchmakerGender
                    ? profile.preferredMatchmakerGender === "MALE"
                      ? "גבר"
                      : "אישה"
                    : "אין העדפה / לא צוין"
                }
                iconColorClass="text-amber-600"
              />
              <div>
                <p className="text-xs font-medium text-amber-600 mb-1 sm:mb-1.5 flex items-center gap-1 sm:gap-1.5">
                  <Edit3 className="w-3.5 h-3.5 sm:w-4 sm:h-4" /> הערות לשדכנים:
                </p>
                {profile.matchingNotes ? ( // Reusing matchingNotes here; might need a specific field
                  <p className="text-xs sm:text-sm text-slate-700 whitespace-pre-wrap break-words bg-amber-100/70 p-2 sm:p-2.5 rounded-md border border-amber-200/80">
                    {profile.matchingNotes}
                  </p>
                ) : (
                  <p className="text-xs sm:text-sm text-slate-500 italic">
                    לא הוזנו הערות.
                  </p>
                )}
              </div>
              {profile.availabilityNote && (
                <div>
                  <p className="text-xs font-medium text-amber-600 mb-1 sm:mb-1.5 flex items-center gap-1 sm:gap-1.5">
                    <Clock className="w-3.5 h-3.5 sm:w-4 sm:h-4" /> הערת זמינות:
                  </p>
                  <p className="text-xs sm:text-sm text-slate-700 whitespace-pre-wrap break-words bg-amber-100/70 p-2 sm:p-2.5 rounded-md border border-amber-200/80">
                    {profile.availabilityNote}
                  </p>
                </div>
              )}
            </div>
          </TabsContent>
        )}
      </div>
    </Tabs>
  );

  if (!isClient) {
    return (
      <Card
        dir="rtl"
        className={cn(
          "w-full bg-slate-50 shadow-2xl rounded-xl sm:rounded-2xl overflow-hidden border-0 flex flex-col max-h-[calc(100vh-1rem)] sm:max-h-[calc(100vh-2rem)] h-full",
          className
        )}
      >
        <div className="p-4 animate-pulse bg-gray-200 h-40 sm:h-48 w-full"></div>
        <div className="p-4 animate-pulse bg-gray-100 flex-grow"></div>
      </Card>
    );
  }

  return (
    <TooltipProvider>
      <Card
        dir="rtl"
        className={cn(
          "w-full bg-slate-50 shadow-2xl rounded-xl sm:rounded-2xl overflow-hidden border-0 flex flex-col max-h-[calc(100vh-1rem)] sm:max-h-[calc(100vh-2rem)] h-full",
          className
        )}
      >
        <ProfileHeader
          profile={profile}
          age={age}
          userInitials={userInitials}
          mainImageToDisplay={mainImageToDisplay}
          availability={availability}
          viewMode={viewMode}
        />

        {isDesktop ? (
          <ResizablePanelGroup
            direction="horizontal"
            dir="rtl"
            className="flex-grow min-h-0 border-t border-slate-200/80"
            onLayout={(sizes: number[]) => {
              setMainContentPanelSize(sizes[0]);
              setSidePhotosPanelSize(sizes[1]);
            }}
          >
            <ResizablePanel
              defaultSize={mainContentPanelSize}
              minSize={25}
              maxSize={75}
              id="main-content-panel"
              order={1}
              className="min-w-0 bg-slate-100/40 flex flex-col"
            >
              <ScrollArea className="h-full focus-visible:outline-none focus-visible:ring-0 flex-grow min-h-0">
                <div className="p-3 md:p-4 h-full flex flex-col">
                  <MainContentTabs inScrollArea={true} />
                </div>
              </ScrollArea>
            </ResizablePanel>
            <ResizableHandle
              withHandle
              className="bg-slate-200 hover:bg-slate-300 transition-colors hidden md:flex"
            >
              <GripVertical className="w-2.5 h-2.5 text-slate-500" />
            </ResizableHandle>
            <ResizablePanel
              defaultSize={sidePhotosPanelSize}
              minSize={25}
              maxSize={75}
              id="side-photos-panel"
              order={2}
              className="min-w-0 bg-white hidden md:block"
            >
              <div className="h-full flex flex-col">
                <div className="p-3 md:p-4 flex-grow flex flex-col min-h-0">
                  <div className="flex justify-between items-center mb-2.5 sm:mb-3 flex-shrink-0">
                    <h3 className="text-base md:text-md font-semibold text-slate-700 flex items-center gap-1.5 sm:gap-2">
                      <ImageIcon className="w-4 h-4 md:w-5 md:h-5 text-cyan-600" />{" "}
                      תמונות ({orderedImages.length})
                    </h3>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={togglePanels}
                          className="text-slate-500 hover:text-cyan-600 w-7 h-7 sm:w-8 sm:h-8"
                        >
                          {sidePhotosPanelSize > 50 ? (
                            <Minimize className="w-3.5 h-3.5 md:w-4 md:h-4" />
                          ) : (
                            <Maximize className="w-3.5 h-3.5 md:w-4 md:h-4" />
                          )}
                        </Button>
                      </TooltipTrigger>
                      <TooltipContent side="bottom">
                        <p>
                          {sidePhotosPanelSize > 50
                            ? "צמצם גלריה צדדית"
                            : "הרחב גלריה צדדית"}
                        </p>
                      </TooltipContent>
                    </Tooltip>
                  </div>
                  {orderedImages.length > 0 ? (
                    <>
                      <Button
                        variant="outline"
                        size="sm"
                        className="w-full mb-2.5 sm:mb-3 text-cyan-600 border-cyan-400/70 hover:bg-cyan-50 hover:text-cyan-700 flex-shrink-0 text-xs md:text-sm"
                        onClick={() => {
                          setActiveTab("photos_tab");
                          if (sidePhotosPanelSize > 50) togglePanels();
                        }}
                      >
                        <ExternalLink className="w-3 h-3 md:w-3.5 md:h-3.5 ml-1.5" />{" "}
                        הצג את כל {orderedImages.length} התמונות בגלריה הראשית
                      </Button>
                      <div className="flex-grow flex flex-col gap-2.5 sm:gap-3 min-h-0">
                        {mainImageToDisplay && (
                          <div
                            className="relative aspect-video rounded-lg overflow-hidden cursor-pointer group shadow-lg border border-gray-200/70 hover:shadow-xl transition-all flex-shrink-0"
                            onClick={() =>
                              handleOpenImageDialog(mainImageToDisplay)
                            }
                          >
                            <Image
                              src={mainImageToDisplay.url}
                              alt={`תמונה ראשית של ${
                                profile.user?.firstName || "מועמד"
                              }`}
                              fill
                              className="object-cover transition-transform duration-300 group-hover:scale-105"
                              sizes="(max-width: 1024px) 40vw, 30vw"
                              priority={
                                activeMainImageIndex ===
                                orderedImages.findIndex((img) => img.isMain)
                              }
                            />
                            <div className="absolute inset-0 bg-gradient-to-t from-black/50 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center p-2">
                              <Eye className="w-6 h-6 md:w-8 md:h-8 text-white drop-shadow-lg" />
                            </div>
                            {mainImageToDisplay.isMain && (
                              <Badge className="absolute top-1.5 right-1.5 md:top-2 md:right-2 bg-yellow-400 text-black border-0 shadow-md text-[10px] md:text-xs px-1 md:px-1.5 py-0.5 flex items-center gap-1">
                                <Star className="w-2.5 h-2.5 md:w-3 md:h-3 fill-black" />{" "}
                                ראשי
                              </Badge>
                            )}
                          </div>
                        )}
                        {orderedImages.length > 1 && (
                          <ScrollArea
                            dir="rtl"
                            className="w-full flex-shrink-0"
                          >
                            <div className="flex gap-1.5 sm:gap-2 pb-1.5">
                              {orderedImages.map((image, index) => (
                                <div
                                  key={image.id}
                                  className={cn(
                                    "relative flex-shrink-0 w-16 h-16 md:w-20 md:h-20 rounded-md overflow-hidden cursor-pointer border-2 transition-all duration-200 shadow-sm hover:shadow-md",
                                    activeMainImageIndex === index
                                      ? "border-cyan-500 ring-2 ring-cyan-500/30 scale-105"
                                      : "border-slate-200 hover:border-cyan-400 opacity-80 hover:opacity-100"
                                  )}
                                  onClick={() => setActiveMainImageIndex(index)}
                                  onDoubleClick={() =>
                                    handleOpenImageDialog(image)
                                  }
                                >
                                  <Image
                                    src={image.url}
                                    alt={`תמונת פרופיל ${index + 1}`}
                                    fill
                                    className="object-cover"
                                    sizes="80px"
                                  />
                                </div>
                              ))}
                            </div>
                            <ScrollBar orientation="horizontal" />
                          </ScrollArea>
                        )}
                      </div>
                    </>
                  ) : (
                    <div className="flex-grow flex items-center justify-center">
                      <EmptyState
                        icon={ImageIcon}
                        message="אין תמונות להצגה"
                        className="py-6 w-full bg-slate-50 rounded-lg border border-slate-200/70"
                      />
                    </div>
                  )}
                </div>
                <div className="p-2 md:p-2.5 border-t border-slate-200/80 bg-slate-50/70 flex-shrink-0">
                  <SectionCard
                    title="ניתוח AI"
                    icon={Bot}
                    titleClassName="p-1.5 sm:p-2 md:p-2.5 bg-slate-100/80 text-sm"
                    contentClassName="p-1.5 sm:p-2 md:p-2.5"
                    className="shadow-md"
                  >
                    <div className="flex flex-col items-center gap-1 text-center">
                      <Bot className="w-5 h-5 sm:w-6 sm:h-6 text-sky-500 opacity-70 mb-0.5" />
                      <p className="text-[10px] sm:text-xs text-slate-600 max-w-md leading-tight">
                        קבל/י סיכום ותובנות מה-AI ונהל/י שיחת התייעצות.
                      </p>
                      <Button
                        size="xs"
                        className="mt-1 w-full bg-sky-500 hover:bg-sky-600 text-white font-medium py-1 px-1.5 rounded text-[10px] sm:text-xs shadow-sm hover:shadow-md transition-all"
                      >
                        <Sparkles className="w-2.5 h-2.5 sm:w-3 sm:h-3.5 ml-1 sm:ml-1.5" />{" "}
                        התחל התייעצות
                      </Button>
                    </div>
                  </SectionCard>
                </div>
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Mobile Layout
          <ScrollArea className="flex-grow min-h-0 w-full">
            {/* === MODIFIED HERE === */}
            <div className="p-2 sm:p-2.5">
              {" "}
              {/* Was p-2.5 sm:p-3. Reduced base padding */}
              <MainContentTabs />
            </div>
          </ScrollArea>
        )}

        {selectedImageForDialog && selectedImageForDialog.url && (
          <Dialog
            open={!!selectedImageForDialog}
            onOpenChange={(isOpen) => !isOpen && handleCloseImageDialog()}
          >
            <DialogContent
              className="max-w-5xl w-[95vw] h-[90vh] p-0 bg-black/95 backdrop-blur-md border-none shadow-2xl overflow-hidden rounded-lg flex flex-col"
              dir="rtl"
            >
              <DialogHeader className="p-2 sm:p-3 text-white flex flex-row justify-between items-center border-b border-slate-700/50 flex-shrink-0">
                <DialogTitle className="text-center text-sm sm:text-base md:text-lg font-semibold flex-grow truncate px-2">
                  תמונה {currentDialogImageIndex + 1} מתוך{" "}
                  {orderedImages.length}
                </DialogTitle>
                <Button
                  variant="ghost"
                  size="icon"
                  className="text-slate-300 hover:text-white hover:bg-white/10 rounded-full mr-auto w-7 h-7 sm:w-8 sm:h-8 flex-shrink-0"
                  onClick={handleCloseImageDialog}
                  aria-label="סגור"
                >
                  <X className="w-4 h-4 sm:w-5 sm:h-5" />
                </Button>
              </DialogHeader>
              <div className="relative flex-1 w-full min-h-0 flex items-center justify-center bg-black/80">
                <Image
                  key={selectedImageForDialog.id}
                  src={selectedImageForDialog.url}
                  alt={`תמונה מוגדלת ${currentDialogImageIndex + 1} של ${
                    profile.user?.firstName || "מועמד"
                  }`}
                  fill
                  className="object-contain"
                  sizes="90vw"
                  priority
                />
                {orderedImages.length > 1 && (
                  <>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="absolute right-1 sm:right-2 top-1/2 -translate-y-1/2 bg-black/40 hover:bg-black/60 text-white rounded-full h-8 w-8 sm:h-10 sm:w-10 md:h-12 md:w-12"
                      onClick={() => handleDialogNav("prev")}
                      aria-label="הקודם"
                    >
                      <ChevronRight className="h-5 w-5 sm:h-6 sm:w-6" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="absolute left-1 sm:left-2 top-1/2 -translate-y-1/2 bg-black/40 hover:bg-black/60 text-white rounded-full h-8 w-8 sm:h-10 sm:w-10 md:h-12 md:w-12"
                      onClick={() => handleDialogNav("next")}
                      aria-label="הבא"
                    >
                      <ChevronLeft className="h-5 w-5 sm:h-6 sm:w-6" />
                    </Button>
                  </>
                )}
              </div>
              {orderedImages.length > 1 && (
                <DialogFooter className="border-t border-slate-700/50 bg-black/70 p-0 flex-shrink-0">
                  <ScrollArea dir="rtl" className="w-full">
                    <div className="flex gap-1 sm:gap-1.5 p-1.5 sm:p-2 justify-center">
                      {orderedImages.map((img, idx) => (
                        <div
                          key={img.id}
                          className={cn(
                            "relative flex-shrink-0 w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 rounded overflow-hidden cursor-pointer border-2 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-cyan-400 focus:ring-offset-2 focus:ring-offset-black",
                            img.id === selectedImageForDialog.id
                              ? "border-cyan-400 scale-105 opacity-100 shadow-lg"
                              : "border-transparent hover:border-slate-400 opacity-60 hover:opacity-100"
                          )}
                          onClick={() => setSelectedImageForDialog(img)}
                          onKeyDown={(e) =>
                            e.key === "Enter" && setSelectedImageForDialog(img)
                          }
                          tabIndex={0}
                          role="button"
                          aria-label={`הצג תמונה ${idx + 1}`}
                        >
                          <Image
                            src={img.url}
                            alt={`תמונה קטנה ${idx + 1}`}
                            fill
                            className="object-cover"
                            sizes="56px"
                          />
                        </div>
                      ))}
                    </div>
                    <ScrollBar orientation="horizontal" />
                  </ScrollArea>
                </DialogFooter>
              )}
            </DialogContent>
          </Dialog>
        )}
      </Card>
    </TooltipProvider>
  );
};

export default ProfileCard;
--- End of Content for ProfileCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\constants.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/constants.ts
import { Heart, User, Users, Scroll, GraduationCap, MapPin } from "lucide-react";

export const WORLDS = {
  values: {
    key: "values",
    title: "ערכים ואמונות",
    icon: Heart,
    color: "text-pink-500",
    bgColor: "bg-pink-50",
    borderColor: "border-pink-200",
  },
  personality: {
    key: "personality",
    title: "אישיות",
    icon: User,
    color: "text-blue-500",
    bgColor: "bg-blue-50",
    borderColor: "border-blue-200",
  },
  relationship: {
    key: "relationship",
    title: "זוגיות ומשפחה",
    icon: Users,
    color: "text-purple-500",
    bgColor: "bg-purple-50",
    borderColor: "border-purple-200",
  },
  religion: {
    key: "religion",
    title: "דת ומסורת",
    icon: Scroll,
    color: "text-indigo-500",
    bgColor: "bg-indigo-50",
    borderColor: "border-indigo-200",
  },
  partner: {
    key: "partner",
    title: "העדפות בן/בת זוג",
    icon: Heart,
    color: "text-red-500",
    bgColor: "bg-red-50",
    borderColor: "border-red-200",
  },
} as const;

export const RELIGIOUS_LEVELS = [
  "חרדי",
  "חרדי מודרני",
  "דתי",
  "דתי-לייט",
  "מסורתי"
] as const;

export const MARITAL_STATUS = [
  "single",
  "divorced",
  "widowed"
] as const;

export const EDUCATION_LEVELS = [
  "תיכונית",
  "על תיכונית",
  "אקדמית",
  "תורנית"
] as const;

export const OCCUPATION_TYPES = [
  "עובד/ת",
  "סטודנט/ית",
  "אברך/אברכית",
  "עצמאי/ת"
] as const;

export const LOCATIONS = [
  "צפון",
  "מרכז",
  "דרום",
  "ירושלים",
  "יהודה ושומרון"
] as const;

export const PROFILE_SECTIONS = {
  BASIC_INFO: {
    title: "פרטים אישיים",
    icon: User,
  },
  EDUCATION: {
    title: "השכלה ותעסוקה",
    icon: GraduationCap,
  },
  LOCATION: {
    title: "מיקום",
    icon: MapPin,
  },
  FAMILY: {
    title: "מידע משפחתי",
    icon: Users,
  },
  PREFERENCES: {
    title: "העדפות",
    icon: Heart,
  },
} as const;

export const COMMUNICATION_STYLES = [
  "ישיר",
  "עקיף",
  "דיפלומטי"
] as const;

export const STRESS_MANAGEMENT = [
  "רגוע",
  "לחוץ",
  "משתנה"
] as const;

export const CONTACT_PREFERENCES = [
  { value: "direct", label: "ישירות" },
  { value: "matchmaker", label: "דרך השדכן/ית" },
  { value: "both", label: "שתי האפשרויות" }
] as const;

// הגדרות עבור הוולידציה
export const VALIDATION_RULES = {
  AGE: {
    MIN: 18,
    MAX: 99
  },
  HEIGHT: {
    MIN: 100,
    MAX: 250
  },
  NAME: {
    MIN_LENGTH: 2,
    MAX_LENGTH: 50
  }
} as const;
--- End of Content for constants.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\index.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/index.ts

// Main Components
export { default as ProfileCard } from './ProfileCard';

// Sections
export { default as PhotosSection } from './sections/PhotosSection';
export { default as PreferencesSection } from './sections/PreferencesSection';
export { default as ProfileSection } from './sections/ProfileSection';
export { default as QuestionnaireResponsesSection } from './sections/QuestionnaireResponsesSection';

// Elements
export { default as StatsCard } from './elements/StatsCard';
export { default as VisibilityControl } from './elements/VisibilityControl';
export { default as MinimalCard } from './elements/MinimalCard';

// Types
export * from './types/profile';
export * from './types/questionnaire';
--- End of Content for index.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\utils.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/utils.ts
import type { UserProfile } from "@/types/next-auth";

export const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

export const formatProfileData = (profile: UserProfile) => {
  return {
    ...profile,
    age: calculateAge(new Date(profile.birthDate)),
    // Add any other formatting needed
  };
};

export const validateProfileData = (data: Partial<UserProfile>) => {
  const errors: Record<string, string> = {};
  
  // Add validation rules as needed
  if (data.height && (data.height < 100 || data.height > 250)) {
    errors.height = "גובה חייב להיות בין 100 ל-250 ס\"מ";
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};
--- End of Content for utils.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements\MinimalCard.tsx
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/elements/MinimalCard.tsx
import React from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { User, MapPin, Scroll, Heart } from "lucide-react";
import Image from "next/image";
import { calculateAge } from "../utils";
import type { UserProfile, UserImage } from "@/types/next-auth";

interface MinimalCardProps {
  profile: UserProfile;
  mainImage?: UserImage;
  onClick?: () => void;
  className?: string;
}

const MinimalCard: React.FC<MinimalCardProps> = ({
  profile,
  mainImage,
  onClick,
  className = "",
}) => {
  const age = calculateAge(new Date(profile.birthDate));

  // Handle cases where profile.user might be undefined
  const userName = profile.user
    ? `${profile.user.firstName} ${profile.user.lastName}`
    : "שם לא זמין"; // "Name not available" in Hebrew

  return (
    <Card
      onClick={onClick}
      className={`relative overflow-hidden cursor-pointer hover:shadow-md transition-shadow ${className}`}
    >
      <div className="flex gap-4 p-4">
        {/* תמונת פרופיל */}
        <div className="relative w-24 h-24 rounded-lg overflow-hidden bg-gray-100">
          {mainImage ? (
            <Image
              src={mainImage.url}
              alt="תמונת פרופיל"
              fill
              className="object-cover"
              sizes="96px"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <User className="w-8 h-8 text-gray-400" />
            </div>
          )}
        </div>

        {/* מידע בסיסי */}
        <div className="flex-1 space-y-2">
          <div>
            <h3 className="text-lg font-medium">{userName}</h3>
            <p className="text-sm text-gray-500">{age} שנים</p>
          </div>

          <div className="flex flex-wrap gap-2">
            {profile.city && (
              <Badge variant="secondary" className="flex items-center gap-1">
                <MapPin className="w-3 h-3" />
                {profile.city}
              </Badge>
            )}
            {profile.religiousLevel && (
              <Badge variant="secondary" className="flex items-center gap-1">
                <Scroll className="w-3 h-3" />
                {profile.religiousLevel}
              </Badge>
            )}
          </div>

          {/* סטטוס זמינות */}
          <div className="flex items-center gap-2 text-sm">
            {profile.availabilityStatus === "AVAILABLE" ? (
              <Badge variant="success" className="flex items-center gap-1">
                <Heart className="w-3 h-3" />
                פנוי/ה להצעות
              </Badge>
            ) : (
              <Badge variant="secondary" className="flex items-center gap-1">
                <Heart className="w-3 h-3" />
                בתהליך הכרות
              </Badge>
            )}
          </div>
        </div>
      </div>
    </Card>
  );
};

export default MinimalCard;
--- End of Content for MinimalCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements\StatsCard.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";

interface StatsCardProps {
  /**
   * The icon to display in the card
   */
  icon: React.ElementType;

  /**
   * The title text to display
   */
  title: string;

  /**
   * The main value to display
   */
  value: string | number;

  /**
   * Optional progress value (0-100)
   */
  progress?: number;

  /**
   * Optional trend information
   */
  trend?: {
    value: number;
    label: string;
    isPositive?: boolean;
  };

  /**
   * Visual variant of the card
   */
  variant?: "default" | "success" | "warning" | "destructive";

  /**
   * Additional CSS classes
   */
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  icon: Icon,
  title,
  value,
  progress,
  trend,
  variant = "default",
  className,
}) => {
  // Determine variant-specific background color
  const getVariantStyles = () => {
    switch (variant) {
      case "success":
        return "bg-emerald-50 dark:bg-emerald-900/20";
      case "warning":
        return "bg-amber-50 dark:bg-amber-900/20";
      case "destructive":
        return "bg-red-50 dark:bg-red-900/20";
      default:
        return "bg-card";
    }
  };

  // Special handling for availability status
  const isAvailabilityStatus = title === "סטטוס פניות";
  const isAvailable = typeof value === 'string' && value.toLowerCase() === 'available';

  // Render the value with special handling for availability status
  const renderValue = () => {
    if (isAvailabilityStatus) {
      return (
        <div className="mt-1">
          <span className={cn(
            "inline-flex px-3 py-1 rounded-full text-sm font-semibold tracking-wide",
            isAvailable 
              ? "bg-emerald-100 text-emerald-800 dark:bg-emerald-900/30 dark:text-emerald-300"
              : "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
          )}>
            {value}
          </span>
        </div>
      );
    }
    return <h3 className="text-2xl font-semibold">{value}</h3>;
  };

  return (
    <Card
      className={cn(
        "hover:shadow-md transition-shadow",
        getVariantStyles(),
        className
      )}
    >
      <CardContent className="p-6">
        {/* Header Section */}
        <div className="flex items-center space-x-4 rtl:space-x-reverse">
          <div className="p-2 bg-primary/10 rounded-full">
            <Icon className="w-6 h-6 text-primary" />
          </div>
          <div className="flex-1 space-y-1">
            <p className="text-sm text-muted-foreground">{title}</p>
            {renderValue()}
          </div>
        </div>

        {/* Progress Bar Section */}
        {progress !== undefined && (
          <div className="mt-4 space-y-2">
            <Progress 
              value={progress} 
              className="h-2"
              aria-label={`${title} progress: ${progress}%`}
            />
            <p className="text-sm text-muted-foreground text-right">
              {progress}%
            </p>
          </div>
        )}

        {/* Trend Section */}
        {trend && (
          <div className="mt-4 flex items-center">
            <span
              className={cn(
                "text-sm font-medium",
                trend.isPositive ? "text-emerald-600" : "text-red-600"
              )}
            >
              {trend.isPositive ? "+" : "-"}
              {trend.value}%
            </span>
            <span className="text-sm text-muted-foreground mr-2">
              {trend.label}
            </span>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

// Default export
export default StatsCard;

// Named exports for specific use cases
export type { StatsCardProps };
--- End of Content for StatsCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\elements\VisibilityControl.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Eye, EyeOff } from "lucide-react";
import { Switch } from "@/components/ui/switch";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

interface VisibilityControlProps {
  /**
   * Current visibility state
   */
  isVisible: boolean;

  /**
   * Callback when visibility changes
   */
  onChange: (isVisible: boolean) => void;

  /**
   * Optional class name for additional styling
   */
  className?: string;

  /**
   * Optional disabled state
   */
  disabled?: boolean;

  /**
   * Optional custom tooltip text
   */
  tooltipText?: {
    visible?: string;
    hidden?: string;
    action?: string;
  };
}

const VisibilityControl: React.FC<VisibilityControlProps> = ({
  isVisible,
  onChange,
  className,
  disabled = false,
  tooltipText = {
    visible: "תשובה זו גלויה למועמדים",
    hidden: "תשובה זו מוסתרת מהמועמדים",
    action: "לחץ כדי",
  },
}) => {
  return (
    <div
      className={cn(
        "flex items-center gap-2 bg-secondary/20 p-2 rounded-md",
        disabled && "opacity-50 cursor-not-allowed",
        className
      )}
    >
      {/* Icon */}
      {isVisible ? (
        <Eye 
          className="h-4 w-4 text-primary" 
          aria-hidden="true"
        />
      ) : (
        <EyeOff 
          className="h-4 w-4 text-muted-foreground" 
          aria-hidden="true"
        />
      )}

      {/* Switch with Tooltip */}
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="relative">
              <Switch
                checked={isVisible}
                onCheckedChange={onChange}
                disabled={disabled}
                className={cn(
                  "data-[state=checked]:bg-primary",
                  disabled && "cursor-not-allowed"
                )}
                aria-label={`Toggle visibility: currently ${isVisible ? 'visible' : 'hidden'}`}
              />
              {/* Visually hidden text for screen readers */}
              <span className="sr-only">
                {isVisible ? "הסתר תוכן" : "הצג תוכן"}
              </span>
            </div>
          </TooltipTrigger>
          <TooltipContent 
            side="left" 
            className="max-w-[200px]"
            dir="rtl"
          >
            <p>
              {isVisible ? tooltipText.visible : tooltipText.hidden}
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              {tooltipText.action} {isVisible ? "להסתיר" : "להציג"} תשובה זו
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  );
};

// Default export
export default VisibilityControl;

// Named exports for types
export type { VisibilityControlProps };
--- End of Content for VisibilityControl.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\PhotosSection.tsx
--------------------------------------------------------------------------------
Content:

"use client";

import React, { useRef, useState, useEffect, useCallback } from "react"; // Added useCallback
import Image from "next/image";
import { cn } from "@/lib/utils";

// UI Components
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogDescription,
  DialogHeader,
  DialogFooter, // Added DialogFooter
} from "@/components/ui/dialog"; // Removed Card components as we use divs/structure directly now for more control

import { toast } from "sonner";

// Icons
import {
  Camera,
  Star,
  Loader2,
  ChevronLeft,
  ChevronRight,
  Upload,
  Trash2,
  X, // Icon for closing dialog
} from "lucide-react";

// Types
import type { UserImage } from "@/types/next-auth";

interface PhotosSectionProps {
  images: UserImage[];
  isUploading: boolean; // Note: Changed interpretation, this prop seems external loading state, use internal `isProcessing` for actions within component
  disabled?: boolean;
  maxImages?: number;
  onUpload: (file: File) => Promise<void>;
  onSetMain: (imageId: string) => Promise<void>;
  onDelete: (imageId: string) => Promise<void>;
  // Removed style props as per previous fix request and current design goals
}

const PhotosSection: React.FC<PhotosSectionProps> = ({
  images,
  isUploading: isExternallyUploading, // Renamed to avoid confusion with internal processing state
  disabled = false,
  maxImages = 5,
  onUpload,
  onSetMain,
  onDelete,
}) => {
  // Refs
  const fileInputRef = useRef<HTMLInputElement>(null);

  // State
  const [showImageViewer, setShowImageViewer] = useState(false);
  const [selectedViewerIndex, setSelectedViewerIndex] = useState<number | null>(null);
  const [isProcessing, setIsProcessing] = useState(false); // Internal state for actions like delete, set main
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [imageToDelete, setImageToDelete] = useState<string | null>(null);
  const [lastUploadedImageId, setLastUploadedImageId] = useState<string | null>(null); // Track ID instead of index

  // Combined Loading State
  const isLoading = isExternallyUploading || isProcessing;

  // Effect to open viewer for newly uploaded image
  useEffect(() => {
    if (lastUploadedImageId) {
      const newIndex = images.findIndex(img => img.id === lastUploadedImageId);
      if (newIndex !== -1) {
          setSelectedViewerIndex(newIndex);
          setShowImageViewer(true);
      }
      setLastUploadedImageId(null); // Reset tracker
    }
  }, [images, lastUploadedImageId]); // Depend on images array as well

  // --- Event Handlers ---

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Basic Validations (already implemented, kept as is)
    const validTypes = ["image/jpeg", "image/png", "image/jpg", "image/webp"]; // Added webp
    if (!validTypes.includes(file.type)) {
      toast.error("סוג קובץ לא חוקי. יש להעלות JPG, PNG, או WEBP.");
      return;
    }
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      toast.error("הקובץ גדול מדי (מקסימום 5MB).");
      return;
    }

    // Prevent multiple uploads
    if (isLoading) return;

    // Use the external onUpload handler
    try {
      // Note: We don't set isProcessing here, assuming isExternallyUploading reflects the upload state
      await onUpload(file);
      // We need the ID of the new image to track it.
      // Assuming onUpload updates the `images` prop via the parent component,
      // we'll rely on the useEffect to find and show the new image.
      // We need a way to get the ID - this might require adjustment in the parent or API response.
      // For now, we'll assume the parent handles setting the ID correctly and updates `images`.
      // A potential workaround is to find the image added (if only one is added)
      // This is brittle. A better approach is if `onUpload` returns the new image ID.
      // Let's simulate getting the last image ID for the effect hook.
      // This requires the parent component to update `images` prop immediately after upload success.
      // const newImage = images[images.length - 1]; // Risky assumption
      // if (newImage) setLastUploadedImageId(newImage.id);

      toast.success("התמונה הועלתה בהצלחה.");

      // Automatically set as main if it's the very first image
      if (images.length === 0) {
        // Need the ID here too. This logic might need to move to the parent
        // or the API should return the ID for immediate use.
        // Assuming the `images` prop updates quickly after onUpload resolves:
        const newImageId = images.find(img => !img.isMain)?.id; // Find the first non-main, likely the new one
        if (newImageId) {
            await handleSetMainImage(newImageId, false); // Set main without toast
        }
      }

    } catch (error) {
      console.error("Error during upload process:", error);
      // Toast handled by onUpload or here as fallback
      if (!(error instanceof Error && error.message.includes("Toast"))) {
         toast.error("שגיאה בהעלאת התמונה.");
      }
    } finally {
      // Reset file input regardless of success/fail
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      //setIsProcessing(false); // Only manage internal processing state
    }
  };

  const triggerFileInput = () => {
    if (!isLoading && !disabled && images.length < maxImages) {
      fileInputRef.current?.click();
    }
  };

  const handleImageClick = (index: number) => {
    setSelectedViewerIndex(index);
    setShowImageViewer(true);
  };

  const closeImageViewer = useCallback(() => { // Use useCallback for keydown listener
    setShowImageViewer(false);
    setSelectedViewerIndex(null);
  }, []);

  const handleNextImage = useCallback(() => { // Use useCallback
      setSelectedViewerIndex((prevIndex) => {
          if (prevIndex === null || prevIndex >= images.length - 1) return prevIndex;
          return prevIndex + 1;
      });
  }, [images.length]);

  const handlePreviousImage = useCallback(() => { // Use useCallback
      setSelectedViewerIndex((prevIndex) => {
          if (prevIndex === null || prevIndex <= 0) return prevIndex;
          return prevIndex - 1;
      });
  }, []); // Dependency images.length removed as index check handles boundary


  // Handler for delete confirmation
  const confirmDelete = async () => {
    if (!imageToDelete || isProcessing) return;

    setIsProcessing(true);
    try {
      const imageIndex = images.findIndex((img) => img.id === imageToDelete);
      if (imageIndex === -1) throw new Error("Image not found for deletion.");

      const imageObj = images[imageIndex];

      // If deleting the main image, and there are others, set a new main one
      if (imageObj.isMain && images.length > 1) {
        const nextMainIndex = imageIndex === 0 ? 1 : 0; // Pick first or second
        await onSetMain(images[nextMainIndex].id);
      }

      // Call the external delete handler
      await onDelete(imageToDelete);

      toast.success("התמונה נמחקה בהצלחה.");
      closeImageViewer(); // Close viewer if open
      setDeleteConfirmOpen(false); // Close confirmation dialog
      setImageToDelete(null); // Reset delete target

    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error("שגיאה במחיקת התמונה.");
    } finally {
      setIsProcessing(false);
    }
  };

  // Open confirmation dialog
  const requestDelete = (imageId: string, event?: React.MouseEvent) => {
    event?.stopPropagation(); // Prevent grid click or other triggers
    if (isLoading) return;
    setImageToDelete(imageId);
    setDeleteConfirmOpen(true);
  };


  // Handler for setting main image
  const handleSetMainImage = async (imageId: string, showToast = true, event?: React.MouseEvent) => {
    event?.stopPropagation();
    if (isLoading) return;

    const currentImage = images.find(img => img.id === imageId);
    if (!currentImage || currentImage.isMain) return; // Already main or not found

    setIsProcessing(true);
    try {
      await onSetMain(imageId);
      if (showToast) {
        toast.success("התמונה הראשית עודכנה.");
      }
    } catch (error) {
      console.error("Error setting main image:", error);
      toast.error("שגיאה בעדכון התמונה הראשית.");
    } finally {
      setIsProcessing(false);
    }
  };

   // Prevent event bubbling for controls
   const handleControlClick = (e: React.MouseEvent) => {
    e.stopPropagation();
   };

   // Keyboard navigation for viewer
   useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!showImageViewer) return;

      switch (e.key) {
        case "ArrowRight": // Assuming RTL means right arrow goes to PREVIOUS visually (index decreases)
          handlePreviousImage();
          break;
        case "ArrowLeft": // Assuming RTL means left arrow goes to NEXT visually (index increases)
          handleNextImage();
          break;
        case "Escape":
          closeImageViewer();
          break;
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [showImageViewer, handlePreviousImage, handleNextImage, closeImageViewer]); // Add dependencies


  // --- Render ---

  return (
    // Inspired Card Structure
    <div dir="rtl" className="bg-white/80 backdrop-blur-lg rounded-3xl shadow-xl p-6 md:p-8">
      {/* Header */}
      <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-6 pb-4 border-b border-gray-200/80">
        <div className="mb-3 sm:mb-0 text-right">
          <h2 className="text-xl font-semibold text-gray-800">תמונות פרופיל</h2>
          <p className="mt-1 text-sm text-gray-600">
            העלה עד {maxImages} תמונות. התמונה הראשית תוצג בכרטיס. (מומלץ: תמונות ברורות של הפנים)
          </p>
        </div>
        {!disabled && (
          <Button
            variant="outline"
            onClick={triggerFileInput}
            disabled={isLoading || images.length >= maxImages}
            className="rounded-full border-2 border-cyan-300 text-cyan-700 hover:bg-cyan-50/50 hover:border-cyan-400 transition-all duration-300 px-5 py-2.5 text-sm font-medium flex items-center gap-2 self-end sm:self-center" // Adjusted padding/text size
          >
            {isExternallyUploading ? ( // Show spinner only for external upload
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Upload className="w-4 h-4" />
            )}
            <span>העלאת תמונה</span>
          </Button>
        )}
      </div>

      {/* Input for file selection (hidden) */}
      <input
        type="file"
        ref={fileInputRef}
        className="hidden"
        accept="image/jpeg,image/png,image/jpg,image/webp" // Added webp
        onChange={handleFileSelect}
        disabled={isLoading || disabled || images.length >= maxImages}
      />

      {/* Images Grid */}
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 md:gap-5">
        {/* Render Images */}
        {images.map((image, index) => (
          <div
            key={image.id}
            className="relative group aspect-square rounded-xl overflow-hidden cursor-pointer bg-gray-100 shadow-md hover:shadow-lg transition-all duration-300 ease-in-out"
            onClick={() => handleImageClick(index)}
          >
            <Image
              src={image.url}
              alt={`תמונת פרופיל ${index + 1}`}
              fill
              className="object-cover transition-transform duration-300 group-hover:scale-105"
              sizes="(max-width: 640px) 50vw, (max-width: 768px) 33vw, (max-width: 1024px) 25vw, 20vw"
              priority={index < 2} // Prioritize loading first few images
            />

            {/* Controls Overlay - Always visible, subtle */}
            {!disabled && (
              <div
                className="absolute top-2 right-2 z-10 flex gap-1.5 opacity-85 group-hover:opacity-100 transition-opacity duration-200"
                onClick={handleControlClick} // Prevent triggering image click
              >
                {/* Set Main Button */}
                <Button
                  variant="secondary"
                  size="icon"
                  className={cn(
                    "w-8 h-8 rounded-full shadow-md border border-white/30 bg-black/40 text-white hover:bg-black/60 transition-colors",
                    image.isMain ? "cursor-default" : "hover:text-yellow-300" // Visual cue for main
                  )}
                  onClick={(e) => handleSetMainImage(image.id, true, e)}
                  disabled={image.isMain || isLoading}
                  title={image.isMain ? "תמונה ראשית" : "הפוך לתמונה ראשית"}
                >
                  <Star
                    className={cn(
                      "w-4 h-4 transition-colors",
                      image.isMain ? "text-yellow-400 fill-yellow-400" : "text-white"
                    )}
                  />
                </Button>

                {/* Delete Button */}
                <Button
                  variant="secondary"
                  size="icon"
                  className="w-8 h-8 rounded-full shadow-md border border-white/30 bg-black/40 text-white hover:bg-red-600 hover:border-red-700 transition-colors"
                  onClick={(e) => requestDelete(image.id, e)}
                  disabled={isLoading}
                  title="מחק תמונה"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            )}

            {/* Main Image Badge */}
            {image.isMain && (
              <Badge className="absolute bottom-2 left-2 rounded-full px-2.5 py-0.5 text-xs font-medium shadow-md text-white bg-gradient-to-r from-cyan-500 to-pink-500 border-none">
                ראשי
              </Badge>
            )}
          </div>
        ))}

        {/* Upload Placeholder */}
        {!disabled && images.length < maxImages && (
          <div
            onClick={triggerFileInput}
            className="flex flex-col items-center justify-center text-center p-4 aspect-square rounded-xl border-2 border-dashed border-cyan-300/70 bg-cyan-50/30 hover:bg-cyan-50/60 hover:border-cyan-400 transition-colors duration-300 cursor-pointer group"
          >
            <Upload className="w-8 h-8 text-cyan-500 mb-2 transition-transform group-hover:scale-110" />
            <span className="text-sm font-medium text-cyan-700">העלאת תמונה</span>
            <span className="text-xs text-cyan-600/90 mt-1">
              עד {maxImages - images.length} תמונות נוספות
            </span>
          </div>
        )}
      </div>

      {/* Empty State (if no images and not disabled) */}
      {images.length === 0 && !disabled && (
         <div className="text-center py-16 mt-6 bg-gradient-to-br from-cyan-50/20 to-pink-50/20 rounded-xl border border-dashed border-gray-300">
              <Camera className="w-12 h-12 mx-auto text-gray-400/80" />
              <p className="mt-4 text-gray-600 font-medium">
                אין עדיין תמונות בפרופיל
              </p>
         <p className="text-sm text-gray-500 mt-1 px-4">
  תמונה טובה היא הרושם הראשוני שלכם. כדאי להעלות אחת כדי להשלים את הפרופיל.
</p>
          </div>
      )}
      {/* Empty State (if disabled and no images) */}
       {images.length === 0 && disabled && (
         <div className="text-center py-16 mt-6 bg-gray-50/50 rounded-xl border border-gray-200">
              <Camera className="w-12 h-12 mx-auto text-gray-400" />
              <p className="mt-4 text-gray-500 font-medium">
                לא הועלו תמונות לפרופיל זה.
              </p>
          </div>
      )}

      {/* Delete Confirmation Dialog */}
      <Dialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
        <DialogContent className="sm:max-w-md bg-white/95 backdrop-blur-md rounded-2xl shadow-2xl border-none p-6" dir="rtl">
          <DialogHeader>
            <DialogTitle className="text-lg font-semibold text-gray-800">אישור מחיקת תמונה</DialogTitle>
            <DialogDescription className="text-sm text-gray-600 mt-2">
              האם למחוק את התמונה לצמיתות? לא ניתן לשחזר פעולה זו.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="mt-6 flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 sm:space-x-reverse gap-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => setDeleteConfirmOpen(false)}
              disabled={isLoading}
              className="rounded-full px-5"
            >
              ביטול
            </Button>
            <Button
              type="button"
              variant="destructive"
              onClick={confirmDelete}
              disabled={isLoading}
               className="rounded-full px-5"
            >
              {isProcessing ? (
                <Loader2 className="w-4 h-4 ml-2 animate-spin" />
              ) : (
                <Trash2 className="w-4 h-4 ml-2" /> // Keep icon consistent
              )}
              <span>מחק</span>
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

       {/* Image Viewer Dialog */}
       <Dialog open={showImageViewer} onOpenChange={setShowImageViewer}>
        <DialogContent
            className="p-0 m-0 w-screen h-screen max-w-none sm:max-w-full sm:h-full bg-black/90 backdrop-blur-sm border-none rounded-none flex items-center justify-center outline-none"
            aria-describedby={undefined} // Remove default description link if header is hidden
            >
            {/* Close Button */}
            <Button
                variant="ghost"
                size="icon"
                className="absolute top-4 left-4 z-50 bg-black/40 hover:bg-black/60 text-white rounded-full w-10 h-10 sm:w-12 sm:h-12 transition-colors"
                onClick={closeImageViewer}
                aria-label="סגור תצוגת תמונה"
            >
                <X className="w-6 h-6" />
            </Button>

            {/* Image Display Area */}
            {selectedViewerIndex !== null && images[selectedViewerIndex] && (
                <div className="relative w-full h-full flex items-center justify-center">
                    {/* Image */}
                     <div className="relative w-[95%] h-[85%] sm:w-[90%] sm:h-[90%]">
                        <Image
                            src={images[selectedViewerIndex].url}
                            alt={`תצוגה מוגדלת של תמונה ${selectedViewerIndex + 1}`}
                            fill
                            className="object-contain select-none" // Prevent image selection/drag
                            sizes="90vw" // Simplified sizes for viewer
                            priority // Load the viewed image with high priority
                        />
                    </div>


                    {/* Viewer Controls (Nav + Actions) */}
                    <div className="absolute top-0 left-0 w-full h-full pointer-events-none">
                         {/* Navigation */}
                         {images.length > 1 && (
                            <>
                            {/* Previous Button (Visually Right in RTL) */}
                            <Button
                                variant="ghost"
                                size="icon"
                                className="absolute right-2 sm:right-4 top-1/2 transform -translate-y-1/2 z-40 bg-black/40 hover:bg-black/60 text-white rounded-full w-10 h-10 sm:w-12 sm:h-12 transition-colors pointer-events-auto"
                                onClick={(e) => {e.stopPropagation(); handlePreviousImage();}}
                                disabled={selectedViewerIndex === 0}
                                aria-label="התמונה הקודמת"
                            >
                                <ChevronRight className="w-7 h-7" />
                            </Button>
                             {/* Next Button (Visually Left in RTL) */}
                            <Button
                                variant="ghost"
                                size="icon"
                                className="absolute left-2 sm:left-4 top-1/2 transform -translate-y-1/2 z-40 bg-black/40 hover:bg-black/60 text-white rounded-full w-10 h-10 sm:w-12 sm:h-12 transition-colors pointer-events-auto"
                                onClick={(e) => {e.stopPropagation(); handleNextImage();}}
                                disabled={selectedViewerIndex === images.length - 1}
                                aria-label="התמונה הבאה"
                            >
                                <ChevronLeft className="w-7 h-7" />
                            </Button>
                            </>
                         )}

                        {/* Action Buttons (Top Right) */}
                         {!disabled && (
                            <div className="absolute top-4 right-4 z-50 flex flex-col sm:flex-row gap-2 pointer-events-auto">
                                {/* Set as Main Button */}
                                {!images[selectedViewerIndex].isMain && (
                                <Button
                                    variant="secondary"
                                    className="rounded-full bg-white/70 backdrop-blur-sm shadow-md hover:bg-white/90 text-gray-800 px-3 py-1.5 text-xs sm:text-sm border border-white/20 flex items-center gap-1.5"
                                    onClick={(e) => handleSetMainImage(images[selectedViewerIndex].id, true, e)}
                                    size="sm"
                                    disabled={isLoading}
                                >
                                    <Star className="w-4 h-4" />
                                    <span>הפוך לראשי</span>
                                </Button>
                                )}

                                {/* Delete Button */}
                                <Button
                                    variant="destructive" // Using destructive variant directly
                                    className="rounded-full bg-red-600/80 hover:bg-red-700 text-white px-3 py-1.5 text-xs sm:text-sm shadow-md border-none flex items-center gap-1.5"
                                    onClick={(e) => requestDelete(images[selectedViewerIndex].id, e)}
                                    size="sm"
                                    disabled={isLoading}
                                >
                                    <Trash2 className="w-4 h-4" />
                                    <span>מחק תמונה</span>
                                </Button>
                            </div>
                        )}

                        {/* Counter */}
                        {images.length > 0 && (
                           <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/60 text-white px-3 py-1 rounded-full text-xs sm:text-sm font-medium select-none">
                             {selectedViewerIndex + 1} / {images.length}
                           </div>
                        )}
                    </div>
                 </div>
            )}
        </DialogContent>
       </Dialog>
    </div>
  );
};

export default PhotosSection;

--- End of Content for PhotosSection.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\PreferencesSection.tsx
--------------------------------------------------------------------------------
Content:
// src/app/(authenticated)/profile/components/dashboard/PreferencesSection.tsx
"use client";

import React, { useState, useEffect } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Pencil,
  Save,
  X,
  FileText, // Icon for General Description
  SlidersHorizontal, // Icon for Age/Height
  MapPin, // Icon for Location/Religious (expanded)
  GraduationCap, // Icon for Education/Occupation (expanded)
  Users, // Icon for Family/Personal Background (new)
  Sparkles, // Icon for Character/Hobbies (new)
  Heart, // For shomer negiah, children etc.
  Briefcase, // For service type
  Shield, // Could be for traits
  Palette, // Could be for hobbies
  Smile, // Could be for traits
} from "lucide-react";
import { UserProfile } from "@/types/next-auth";
import { cn } from "@/lib/utils";
import {
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
} from "@prisma/client";
interface PreferencesSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onChange: (data: Partial<UserProfile>) => void;
}

// --- Options for existing multi-select fields ---
const locationOptions = [
  { value: "צפון", label: "צפון" },
  { value: "מרכז", label: "מרכז" },
  { value: "דרום", label: "דרום" },
  { value: "ירושלים", label: "ירושלים" },
  { value: "יהודה ושומרון", label: "יהודה ושומרון" },
  { value: 'חו"ל', label: 'חו"ל' },
];

const religiousLevelOptions = [
  { value: "חרדי", label: "חרדי" },
  { value: "חרדי מודרני", label: "חרדי מודרני" },
  { value: "דתי", label: "דתי" },
  { value: "דתי-לייט", label: "דתי-לייט" },
  { value: "מסורתי", label: "מסורתי" },
  { value: "חילוני", label: "חילוני" },
  { value: "לא משנה", label: "ללא העדפה / גמיש" },
];

const educationPreferenceOptions = [
  { value: "תיכונית", label: "תיכונית" },
  { value: "על תיכונית", label: "על תיכונית" },
  { value: "אקדמית", label: "אקדמית" },
  { value: "תורנית", label: "תורנית" },
  { value: "ללא העדפה", label: "ללא העדפה" },
];

const occupationPreferenceOptions = [
  { value: "עובד/ת", label: "עובד/ת" },
  { value: "סטודנט/ית", label: "סטודנט/ית" },
  { value: "אברך/כולל", label: "אברך/כולל" },
  { value: "עצמאי/ת", label: "עצמאי/ת" },
  { value: "שירות צבאי/לאומי", label: "שירות צבאי/לאומי" },
  { value: "ללא העדפה", label: "ללא העדפה" },
];

// --- Options for NEW fields ---
const preferredShomerNegiahOptions = [
  { value: "yes", label: "כן, חשוב לי" },
  { value: "no", label: "לא, אין העדפה" }, // Or "לא, לא רלוונטי"
  { value: "flexible", label: "גמיש/תלוי באדם" },
];

const preferredPartnerHasChildrenOptions = [
  { value: "yes_ok", label: "כן, זה בסדר גמור" },
  { value: "no_preferred", label: "מעדיפ/ה שלא יהיו" },
  { value: "does_not_matter", label: "לא משנה לי" },
];

const preferredOriginOptions = [
  { value: "ashkenazi", label: "אשכנזי/ה" },
  { value: "sephardi", label: "ספרדי/ה" },
  { value: "mizrachi", label: "מזרחי/ה" },
  { value: "temani", label: "תימני/ה" },
  { value: "mixed", label: "מעורב/ת" },
  { value: "ethiopian", label: "אתיופי/ה" },
  { value: "american", label: "אמריקאי/ה" },
  { value: "european", label: "אירופאי/ה" },
  { value: "russian_speaking", label: "ממדינות דוברות רוסית" },
  { value: "french_speaking", label: "ממדינות דוברות צרפתית" },
  { value: "south_american", label: "דרום אמריקאי/ה" },
  { value: "other", label: "אחר" },
  { value: "no_preference", label: "ללא העדפה מיוחדת" },
];

const preferredAliyaStatusOptions = [
  { value: "oleh", label: "עולה חדש/ה" },
  { value: "tzabar", label: "צבר/ית" },
  { value: "no_preference", label: "ללא העדפה" },
];

// Options copied/adapted from ProfileSection.tsx (or similar source)
const maritalStatusOptions = [
  // For preferredMaritalStatuses
  { value: "single", label: "רווק/ה" },
  { value: "divorced", label: "גרוש/ה" },
  { value: "widowed", label: "אלמן/ה" },
  { value: "annulled", label: "נישואין שבוטלו" },
  { value: "any", label: "כל האפשרויות פתוחות" },
];

const serviceTypeOptions = [
  // For preferredServiceTypes
  { value: ServiceType.MILITARY_COMBATANT, label: "צבאי - לוחם/ת" },
  { value: ServiceType.MILITARY_SUPPORT, label: "צבאי - תומכ/ת לחימה" },
  { value: ServiceType.MILITARY_OFFICER, label: "צבאי - קצונה" },
  {
    value: ServiceType.MILITARY_INTELLIGENCE_CYBER_TECH,
    label: "צבאי - מודיעין/סייבר/טכנולוגי",
  },
  { value: ServiceType.NATIONAL_SERVICE_ONE_YEAR, label: "שירות לאומי - שנה" },
  {
    value: ServiceType.NATIONAL_SERVICE_TWO_YEARS,
    label: "שירות לאומי - שנתיים",
  },
  { value: ServiceType.HESDER_YESHIVA, label: "ישיבת הסדר" },
  {
    value: ServiceType.YESHIVA_ONLY_POST_HS,
    label: "ישיבה גבוהה / מדרשה (ללא שירות)",
  },
  {
    value: ServiceType.PRE_MILITARY_ACADEMY_AND_SERVICE,
    label: "מכינה קדם-צבאית ושירות",
  },
  { value: ServiceType.EXEMPTED, label: "פטור משירות" },
  { value: ServiceType.CIVILIAN_SERVICE, label: "שירות אזרחי" },
  { value: ServiceType.OTHER, label: "אחר / לא רלוונטי" },
  { value: "no_preference", label: "ללא העדפה / לא משנה" },
];

const headCoveringOptions = [
  // For preferredHeadCoverings (if user is Male)
  { value: HeadCoveringType.FULL_COVERAGE, label: "כיסוי ראש מלא" },
  { value: HeadCoveringType.PARTIAL_COVERAGE, label: "כיסוי ראש חלקי" },
  { value: HeadCoveringType.HAT_BERET, label: "כובע / ברט" },
  {
    value: HeadCoveringType.SCARF_ONLY_SOMETIMES,
    label: "מטפחת (רק באירועים/בית כנסת)",
  },
  { value: HeadCoveringType.NONE, label: "ללא כיסוי ראש" },
  { value: "any", label: "כל האפשרויות פתוחות" },
];

const kippahTypeOptions = [
  // For preferredKippahTypes (if user is Female)
  { value: KippahType.BLACK_VELVET, label: "קטיפה שחורה" },
  { value: KippahType.KNITTED_SMALL, label: "סרוגה קטנה" },
  { value: KippahType.KNITTED_LARGE, label: "סרוגה גדולה" },
  { value: KippahType.CLOTH, label: "בד" },
  { value: KippahType.BRESLEV, label: "ברסלב (לבנה גדולה)" },
  { value: KippahType.NONE_AT_WORK_OR_CASUAL, label: "לא בעבודה / ביומיום" },
  { value: KippahType.NONE_USUALLY, label: "לרוב לא חובש" },
  { value: KippahType.OTHER, label: "אחר" },
  { value: "any", label: "כל האפשרויות פתוחות" },
];

const characterTraitsOptions = [
  // For preferredCharacterTraits
  { value: "empathetic", label: "אמפתי/ת", icon: Heart },
  { value: "driven", label: "שאפתן/ית", icon: Briefcase },
  { value: "optimistic", label: "אופטימי/ת", icon: Smile },
  { value: "family_oriented", label: "משפחתי/ת", icon: Users },
  { value: "intellectual", label: "אינטלקטואל/ית", icon: GraduationCap },
  { value: "organized", label: "מאורגנ/ת", icon: Palette },
  { value: "calm", label: "רגוע/ה", icon: Heart },
  { value: "humorous", label: "בעל/ת חוש הומור", icon: Smile },
  { value: "sociable", label: "חברותי/ת", icon: Users },
  { value: "sensitive", label: "רגיש/ה", icon: Heart },
  { value: "independent", label: "עצמאי/ת", icon: MapPin }, // Icon might need adjustment
  { value: "creative", label: "יצירתי/ת", icon: Palette },
  { value: "honest", label: "כן/ה וישר/ה", icon: Shield },
  { value: "responsible", label: "אחראי/ת", icon: Shield },
  { value: "easy_going", label: "זורם/ת וקליל/ה", icon: Smile },
  { value: "no_strong_preference", label: "ללא העדפה חזקה", icon: Sparkles },
];

const hobbiesOptions = [
  // For preferredHobbies
  { value: "travel", label: "טיולים", icon: MapPin },
  { value: "sports", label: "ספורט", icon: Briefcase }, // Icon might need adjustment
  { value: "reading", label: "קריאה", icon: GraduationCap },
  { value: "cooking_baking", label: "בישול/אפיה", icon: Palette },
  { value: "music_playing_instrument", label: "מוזיקה/נגינה", icon: Palette }, // Icon might need adjustment
  { value: "art_crafts", label: "אומנות/יצירה", icon: Palette },
  { value: "volunteering", label: "התנדבות", icon: Heart },
  { value: "learning_courses", label: "למידה/קורסים", icon: GraduationCap },
  { value: "board_games_puzzles", label: "משחקי קופסא/פאזלים", icon: Smile },
  { value: "movies_theater", label: "סרטים/תיאטרון", icon: Smile },
  { value: "dancing", label: "ריקוד", icon: Users },
  { value: "writing", label: "כתיבה", icon: GraduationCap },
  { value: "nature_hiking", label: "טבע/טיולים רגליים", icon: MapPin },
  { value: "photography", label: "צילום", icon: Palette },
  { value: "no_strong_preference", label: "ללא העדפה חזקה", icon: Sparkles },
];

const PreferencesSection: React.FC<PreferencesSectionProps> = ({
  profile,
  isEditing,
  viewOnly = false,
  setIsEditing,
  onChange,
}) => {
  const [formData, setFormData] = useState<Partial<UserProfile>>({});
  const [initialData, setInitialData] = useState<Partial<UserProfile>>({});

  useEffect(() => {
    if (profile) {
      const nullToUndefined = <T,>(value: T | null): T | undefined =>
        value === null ? undefined : value;

      const newFormData: Partial<UserProfile> = {
        ...profile,
        // Numeric fields
        preferredAgeMin: nullToUndefined(profile.preferredAgeMin),
        preferredAgeMax: nullToUndefined(profile.preferredAgeMax),
        preferredHeightMin: nullToUndefined(profile.preferredHeightMin),
        preferredHeightMax: nullToUndefined(profile.preferredHeightMax),

        // String fields
        matchingNotes: profile.matchingNotes ?? "",
        contactPreference: nullToUndefined(profile.contactPreference),
        preferredShomerNegiah: nullToUndefined(profile.preferredShomerNegiah),
        preferredPartnerHasChildren: nullToUndefined(
          profile.preferredPartnerHasChildren
        ),
        preferredAliyaStatus: nullToUndefined(profile.preferredAliyaStatus),

        // Array fields
        preferredLocations: profile.preferredLocations ?? [],
        preferredReligiousLevels: profile.preferredReligiousLevels ?? [],
        preferredEducation: profile.preferredEducation ?? [],
        preferredOccupations: profile.preferredOccupations ?? [],
        preferredMaritalStatuses: profile.preferredMaritalStatuses ?? [],
        preferredOrigins: profile.preferredOrigins ?? [],
        preferredServiceTypes: profile.preferredServiceTypes ?? [],
        preferredHeadCoverings: profile.preferredHeadCoverings ?? [],
        preferredKippahTypes: profile.preferredKippahTypes ?? [],
        preferredCharacterTraits: profile.preferredCharacterTraits ?? [],
        preferredHobbies: profile.preferredHobbies ?? [],
      };
      setFormData(newFormData);
      setInitialData(newFormData);
    }
  }, [profile]);

  useEffect(() => {
    if (!isEditing && initialData) {
      // Check initialData to prevent reset before it's set
      setFormData(initialData);
    }
  }, [isEditing, initialData]);

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value, type } = e.target;
    const field = name as keyof UserProfile;

    setFormData((prev) => {
      let processedValue: string | number | undefined;
      if (type === "number") {
        const num = parseInt(value, 10);
        processedValue = isNaN(num) ? undefined : num;
      } else {
        processedValue = value === "" ? undefined : value; // Treat empty string as undefined for optional fields
      }
      return { ...prev, [field]: processedValue };
    });
  };

  const handleSelectChange = (field: keyof UserProfile, value: string) => {
    setFormData((prev) => ({
      ...prev,
      [field]:
        value === "" ||
        value === "לא_משנה" ||
        value === "any" ||
        value === "no_preference"
          ? undefined
          : (value as UserProfile[typeof field]),
    }));
  };

  const handleMultiSelectChange = (field: keyof UserProfile, value: string) => {
    setFormData((prev) => {
      const currentValues =
        (Array.isArray(prev[field]) ? (prev[field] as string[]) : []) ?? [];
      let newValues;
      if (
        value === "any" ||
        value === "no_preference" ||
        value === "לא_משנה" ||
        value === "no_strong_preference"
      ) {
        newValues = currentValues.includes(value) ? [] : [value]; // Select "any" deselects others, or selects only "any"
      } else {
        // Remove "any" or "no_preference" if another specific option is selected
        const filteredValues = currentValues.filter(
          (v) =>
            v !== "any" &&
            v !== "no_preference" &&
            v !== "לא_משנה" &&
            v !== "no_strong_preference"
        );
        newValues = filteredValues.includes(value)
          ? filteredValues.filter((v) => v !== value)
          : [...filteredValues, value];
      }
      return { ...prev, [field]: newValues };
    });
  };

  const handleSave = () => {
    // Filter out empty strings from array fields before saving, if desired
    const dataToSave = { ...formData };
    // Example: dataToSave.preferredLocations = dataToSave.preferredLocations?.filter(loc => loc !== "");
    onChange(dataToSave);
    setIsEditing(false);
    setInitialData(dataToSave);
  };

  const handleCancel = () => {
    setFormData(initialData);
    setIsEditing(false);
  };

  const renderMultiSelectBadges = (
    fieldValues: string[] | undefined | null,
    options: { value: string; label: string; icon?: React.ElementType }[],
    badgeClass: string = "bg-sky-100 text-sky-700",
    emptyPlaceholder: string = "לא נבחרו פריטים."
  ) => {
    if (!fieldValues || fieldValues.length === 0) {
      return <p className="text-sm text-gray-500 italic">{emptyPlaceholder}</p>;
    }
    return fieldValues.map((value) => {
      const option = options.find((opt) => opt.value === value);
      return option ? (
        <Badge
          key={value}
          variant="secondary"
          className={cn(
            "mr-1 mb-1 text-xs px-2 py-0.5 rounded-full flex items-center",
            badgeClass
          )}
        >
          {option.icon && <option.icon className="w-3 h-3 rtl:ml-1 mr-1" />}
          {option.label}
        </Badge>
      ) : null;
    });
  };

  const getSelectDisplayValue = (
    value: string | undefined | null,
    options: { value: string; label: string }[],
    placeholder: string = "לא צוין."
  ) => {
    if (!value)
      return <span className="text-gray-500 italic">{placeholder}</span>;
    const option = options.find((opt) => opt.value === value);
    return option ? (
      option.label
    ) : (
      <span className="text-gray-500 italic">{placeholder}</span>
    );
  };

  return (
    <div className="relative" dir="rtl">
      <div className="sticky top-0 z-10 bg-gradient-to-b from-white via-white/95 to-white/0 pt-4 pb-3 backdrop-blur-sm">
        <div className="container mx-auto max-w-screen-xl px-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-xl md:text-2xl font-bold text-slate-800">
                העדפות התאמה
              </h1>
              <p className="text-sm text-slate-500">
                {isEditing && !viewOnly
                  ? "ערוך/י את העדפותיך למציאת התאמה."
                  : "העדפות שהוגדרו לחיפוש התאמה."}
              </p>
            </div>
            {!viewOnly && (
              <div className="flex gap-2">
                {!isEditing ? (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setIsEditing(true)}
                    className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-cyan-400 text-cyan-700 hover:bg-cyan-50"
                  >
                    <Pencil className="w-3.5 h-3.5 ml-1.5" />
                    עריכה
                  </Button>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleCancel}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-gray-300 text-gray-700 hover:bg-gray-50"
                    >
                      <X className="w-3.5 h-3.5 ml-1.5" />
                      ביטול
                    </Button>
                    <Button
                      variant="default"
                      size="sm"
                      onClick={handleSave}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 bg-cyan-600 hover:bg-cyan-700 text-white"
                    >
                      <Save className="w-3.5 h-3.5 ml-1.5" />
                      שמירה
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="container mx-auto max-w-screen-xl py-6 px-4">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* --- Column 1 --- */}
          <div className="space-y-6">
            {/* Card: General Description & Contact Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-slate-50/40 to-gray-100/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <FileText className="w-5 h-5 text-slate-600" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  תיאור כללי והעדפות קשר
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-5">
                <div>
                  <Label
                    htmlFor="matchingNotes"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    תיאור כללי על המועמד/ת המבוקש/ת
                  </Label>
                  {isEditing ? (
                    <Textarea
                      id="matchingNotes"
                      name="matchingNotes"
                      value={formData.matchingNotes || ""}
                      onChange={handleInputChange}
                      placeholder="פרט/י על סוג האדם שאת/ה מחפש/ת, תכונות חשובות, ציפיות וכו'..."
                      className="text-sm focus:ring-cyan-500 min-h-[100px] rounded-lg"
                      rows={4}
                    />
                  ) : (
                    <p className="mt-1 text-sm text-gray-700 whitespace-pre-wrap min-h-[60px] bg-slate-50/70 p-3 rounded-lg border border-slate-200/50">
                      {formData.matchingNotes || (
                        <span className="text-gray-500 italic">
                          לא הוזן תיאור.
                        </span>
                      )}
                    </p>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="contactPreference"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    אופן יצירת קשר מועדף (לאחר אישור הצעה)
                  </Label>
                  {isEditing ? (
                    <Select
                      name="contactPreference"
                      value={formData.contactPreference || ""}
                      onValueChange={(value: string) =>
                        handleSelectChange("contactPreference", value)
                      }
                    >
                      <SelectTrigger
                        id="contactPreference"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י אפשרות..." />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="direct">ישירות</SelectItem>
                        <SelectItem value="matchmaker">דרך השדכן/ית</SelectItem>
                        <SelectItem value="both">שתי האפשרויות</SelectItem>
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.contactPreference,
                        [
                          { value: "direct", label: "ישירות" },
                          { value: "matchmaker", label: "דרך השדכן/ית" },
                          { value: "both", label: "שתי האפשרויות" },
                        ],
                        "לא צוין"
                      )}
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Card: Age & Height Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-indigo-50/40 to-purple-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <SlidersHorizontal className="w-5 h-5 text-indigo-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  העדפות גיל וגובה
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      טווח גילאים מועדף
                    </Label>
                    <div className="flex items-center gap-2">
                      <Input
                        type="number"
                        name="preferredAgeMin"
                        placeholder="מגיל"
                        aria-label="גיל מינימלי מועדף"
                        value={formData.preferredAgeMin ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                      <span className="text-gray-500">-</span>
                      <Input
                        type="number"
                        name="preferredAgeMax"
                        placeholder="עד גיל"
                        aria-label="גיל מקסימלי מועדף"
                        value={formData.preferredAgeMax ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                    </div>
                    {!isEditing &&
                      !formData.preferredAgeMin &&
                      !formData.preferredAgeMax && (
                        <p className="text-xs text-gray-500 italic mt-1">
                          לא הוגדר טווח גילאים.
                        </p>
                      )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      טווח גבהים מועדף (סמ)
                    </Label>
                    <div className="flex items-center gap-2">
                      <Input
                        type="number"
                        name="preferredHeightMin"
                        placeholder="מ-"
                        aria-label="גובה מינימלי מועדף בסנטימטרים"
                        value={formData.preferredHeightMin ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                      <span className="text-gray-500">-</span>
                      <Input
                        type="number"
                        name="preferredHeightMax"
                        placeholder="עד-"
                        aria-label="גובה מקסימלי מועדף בסנטימטרים"
                        value={formData.preferredHeightMax ?? ""}
                        onChange={handleInputChange}
                        disabled={!isEditing}
                        className="h-9 text-sm focus:ring-cyan-500 disabled:bg-gray-100/70"
                      />
                    </div>
                    {!isEditing &&
                      !formData.preferredHeightMin &&
                      !formData.preferredHeightMax && (
                        <p className="text-xs text-gray-500 italic mt-1">
                          לא הוגדר טווח גבהים.
                        </p>
                      )}
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* --- Column 2 --- */}
          <div className="space-y-6">
            {/* Card: Location, Religious & Lifestyle Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-sky-50/40 to-blue-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <MapPin className="w-5 h-5 text-sky-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  מיקום, רמה דתית ואורח חיים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    אזורי מגורים מועדפים
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {locationOptions.map((loc) => (
                        <Button
                          key={loc.value}
                          type="button"
                          variant={
                            (formData.preferredLocations || []).includes(
                              loc.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredLocations",
                              loc.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredLocations || []).includes(
                              loc.value
                            )
                              ? "bg-sky-500 hover:bg-sky-600 text-white border-sky-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {loc.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredLocations,
                        locationOptions,
                        "bg-sky-100 text-sky-700",
                        "לא נבחרו אזורי מגורים."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    רמות דתיות מועדפות
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {religiousLevelOptions.map((level) => (
                        <Button
                          key={level.value}
                          type="button"
                          variant={
                            (formData.preferredReligiousLevels || []).includes(
                              level.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredReligiousLevels",
                              level.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredReligiousLevels || []).includes(
                              level.value
                            )
                              ? "bg-pink-500 hover:bg-pink-600 text-white border-pink-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {level.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredReligiousLevels,
                        religiousLevelOptions,
                        "bg-pink-100 text-pink-700",
                        "לא נבחרו רמות דתיות."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="preferredShomerNegiah"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    שמירת נגיעה אצל הצד השני
                  </Label>
                  {isEditing ? (
                    <Select
                      name="preferredShomerNegiah"
                      value={formData.preferredShomerNegiah || ""}
                      onValueChange={(value) =>
                        handleSelectChange("preferredShomerNegiah", value)
                      }
                    >
                      <SelectTrigger
                        id="preferredShomerNegiah"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י העדפה..." />
                      </SelectTrigger>
                      <SelectContent>
                        {preferredShomerNegiahOptions.map((opt) => (
                          <SelectItem key={opt.value} value={opt.value}>
                            {opt.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.preferredShomerNegiah,
                        preferredShomerNegiahOptions
                      )}
                    </p>
                  )}
                </div>
                {/* Conditional rendering for preferredHeadCoverings / preferredKippahTypes */}
                {profile?.gender === Gender.MALE && (
                  <div>
                    <Label className="block mb-2 text-xs font-medium text-gray-600">
                      העדפת כיסוי ראש לבת הזוג
                    </Label>
                    {isEditing ? (
                      <div className="flex flex-wrap gap-2">
                        {headCoveringOptions.map((opt) => (
                          <Button
                            key={opt.value}
                            type="button"
                            variant={
                              (formData.preferredHeadCoverings || []).includes(
                                opt.value as HeadCoveringType
                              )
                                ? "default"
                                : "outline"
                            }
                            size="sm"
                            onClick={() =>
                              handleMultiSelectChange(
                                "preferredHeadCoverings",
                                opt.value as HeadCoveringType
                              )
                            }
                            className={cn(
                              "rounded-full text-xs px-3 py-1.5 transition-all",
                              (formData.preferredHeadCoverings || []).includes(
                                opt.value as HeadCoveringType
                              )
                                ? "bg-purple-500 hover:bg-purple-600 text-white border-purple-500"
                                : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                            )}
                          >
                            {opt.label}
                          </Button>
                        ))}
                      </div>
                    ) : (
                      <div className="mt-1 flex flex-wrap gap-1.5">
                        {renderMultiSelectBadges(
                          formData.preferredHeadCoverings as string[],
                          headCoveringOptions,
                          "bg-purple-100 text-purple-700",
                          "לא נבחרו העדפות כיסוי ראש."
                        )}
                      </div>
                    )}
                  </div>
                )}
                {profile?.gender === Gender.FEMALE && (
                  <div>
                    <Label className="block mb-2 text-xs font-medium text-gray-600">
                      העדפת סוג כיפה לבן הזוג
                    </Label>
                    {isEditing ? (
                      <div className="flex flex-wrap gap-2">
                        {kippahTypeOptions.map((opt) => (
                          <Button
                            key={opt.value}
                            type="button"
                            variant={
                              (formData.preferredKippahTypes || []).includes(
                                opt.value as KippahType
                              )
                                ? "default"
                                : "outline"
                            }
                            size="sm"
                            onClick={() =>
                              handleMultiSelectChange(
                                "preferredKippahTypes",
                                opt.value as KippahType
                              )
                            }
                            className={cn(
                              "rounded-full text-xs px-3 py-1.5 transition-all",
                              (formData.preferredKippahTypes || []).includes(
                                opt.value as KippahType
                              )
                                ? "bg-orange-500 hover:bg-orange-600 text-white border-orange-500"
                                : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                            )}
                          >
                            {opt.label}
                          </Button>
                        ))}
                      </div>
                    ) : (
                      <div className="mt-1 flex flex-wrap gap-1.5">
                        {renderMultiSelectBadges(
                          formData.preferredKippahTypes as string[],
                          kippahTypeOptions,
                          "bg-orange-100 text-orange-700",
                          "לא נבחרו העדפות סוג כיפה."
                        )}
                      </div>
                    )}
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Card: Education, Occupation & Service Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-teal-50/40 to-green-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <GraduationCap className="w-5 h-5 text-teal-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  השכלה, תעסוקה ושירות
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    רמות השכלה מועדפות
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {educationPreferenceOptions.map((edu) => (
                        <Button
                          key={edu.value}
                          type="button"
                          variant={
                            (formData.preferredEducation || []).includes(
                              edu.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredEducation",
                              edu.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredEducation || []).includes(
                              edu.value
                            )
                              ? "bg-teal-500 hover:bg-teal-600 text-white border-teal-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {edu.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredEducation,
                        educationPreferenceOptions,
                        "bg-teal-100 text-teal-700",
                        "לא נבחרו רמות השכלה."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    תחומי עיסוק מועדפים
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {occupationPreferenceOptions.map((occ) => (
                        <Button
                          key={occ.value}
                          type="button"
                          variant={
                            (formData.preferredOccupations || []).includes(
                              occ.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredOccupations",
                              occ.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredOccupations || []).includes(
                              occ.value
                            )
                              ? "bg-green-500 hover:bg-green-600 text-white border-green-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {occ.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredOccupations,
                        occupationPreferenceOptions,
                        "bg-green-100 text-green-700",
                        "לא נבחרו תחומי עיסוק."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    סוג שירות מועדף (צבאי/לאומי)
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {serviceTypeOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredServiceTypes || []).includes(
                              opt.value as ServiceType
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredServiceTypes",
                              opt.value as ServiceType
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredServiceTypes || []).includes(
                              opt.value as ServiceType
                            )
                              ? "bg-lime-500 hover:bg-lime-600 text-white border-lime-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredServiceTypes as string[],
                        serviceTypeOptions,
                        "bg-lime-100 text-lime-700",
                        "לא נבחרו העדפות שירות."
                      )}
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>

          {/* --- Column 3 --- */}
          <div className="space-y-6">
            {/* Card: Personal & Family Background Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-rose-50/40 to-fuchsia-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Users className="w-5 h-5 text-rose-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  רקע אישי ומשפחתי
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    מצב משפחתי מועדף
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {maritalStatusOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredMaritalStatuses || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredMaritalStatuses",
                              opt.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredMaritalStatuses || []).includes(
                              opt.value
                            )
                              ? "bg-rose-500 hover:bg-rose-600 text-white border-rose-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredMaritalStatuses,
                        maritalStatusOptions,
                        "bg-rose-100 text-rose-700",
                        "לא נבחרו העדפות למצב משפחתי."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="preferredPartnerHasChildren"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    העדפה לגבי ילדים מקשר קודם
                  </Label>
                  {isEditing ? (
                    <Select
                      name="preferredPartnerHasChildren"
                      value={formData.preferredPartnerHasChildren || ""}
                      onValueChange={(value) =>
                        handleSelectChange("preferredPartnerHasChildren", value)
                      }
                    >
                      <SelectTrigger
                        id="preferredPartnerHasChildren"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י העדפה..." />
                      </SelectTrigger>
                      <SelectContent>
                        {preferredPartnerHasChildrenOptions.map((opt) => (
                          <SelectItem key={opt.value} value={opt.value}>
                            {opt.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.preferredPartnerHasChildren,
                        preferredPartnerHasChildrenOptions
                      )}
                    </p>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    מוצא/עדה מועדפים
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {preferredOriginOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredOrigins || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredOrigins",
                              opt.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.preferredOrigins || []).includes(
                              opt.value
                            )
                              ? "bg-fuchsia-500 hover:bg-fuchsia-600 text-white border-fuchsia-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredOrigins,
                        preferredOriginOptions,
                        "bg-fuchsia-100 text-fuchsia-700",
                        "לא נבחרו העדפות מוצא/עדה."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label
                    htmlFor="preferredAliyaStatus"
                    className="block mb-1.5 text-xs font-medium text-gray-600"
                  >
                    העדפת סטטוס עליה
                  </Label>
                  {isEditing ? (
                    <Select
                      name="preferredAliyaStatus"
                      value={formData.preferredAliyaStatus || ""}
                      onValueChange={(value) =>
                        handleSelectChange("preferredAliyaStatus", value)
                      }
                    >
                      <SelectTrigger
                        id="preferredAliyaStatus"
                        className="h-9 text-sm focus:ring-cyan-500"
                      >
                        <SelectValue placeholder="בחר/י העדפה..." />
                      </SelectTrigger>
                      <SelectContent>
                        {preferredAliyaStatusOptions.map((opt) => (
                          <SelectItem key={opt.value} value={opt.value}>
                            {opt.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <p className="text-sm text-gray-800 font-medium mt-1">
                      {getSelectDisplayValue(
                        formData.preferredAliyaStatus,
                        preferredAliyaStatusOptions
                      )}
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Card: Character & Hobbies Preferences */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-amber-50/40 to-yellow-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Sparkles className="w-5 h-5 text-amber-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  אופי ותחומי עניין
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    תכונות אופי מועדפות (עד 3)
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {characterTraitsOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredCharacterTraits || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredCharacterTraits",
                              opt.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.preferredCharacterTraits || []).length >=
                              3 &&
                            !(formData.preferredCharacterTraits || []).includes(
                              opt.value
                            ) &&
                            opt.value !== "no_strong_preference"
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all flex items-center",
                            (formData.preferredCharacterTraits || []).includes(
                              opt.value
                            )
                              ? "bg-yellow-500 hover:bg-yellow-600 text-white border-yellow-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.icon && (
                            <opt.icon className="w-3.5 h-3.5 rtl:ml-1.5 mr-1.5" />
                          )}
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredCharacterTraits,
                        characterTraitsOptions,
                        "bg-yellow-100 text-yellow-700",
                        "לא נבחרו תכונות אופי מועדפות."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-xs font-medium text-gray-600">
                    תחביבים מועדפים (עד 3)
                  </Label>
                  {isEditing ? (
                    <div className="flex flex-wrap gap-2">
                      {hobbiesOptions.map((opt) => (
                        <Button
                          key={opt.value}
                          type="button"
                          variant={
                            (formData.preferredHobbies || []).includes(
                              opt.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectChange(
                              "preferredHobbies",
                              opt.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.preferredHobbies || []).length >= 3 &&
                            !(formData.preferredHobbies || []).includes(
                              opt.value
                            ) &&
                            opt.value !== "no_strong_preference"
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all flex items-center",
                            (formData.preferredHobbies || []).includes(
                              opt.value
                            )
                              ? "bg-amber-500 hover:bg-amber-600 text-white border-amber-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {opt.icon && (
                            <opt.icon className="w-3.5 h-3.5 rtl:ml-1.5 mr-1.5" />
                          )}
                          {opt.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.preferredHobbies,
                        hobbiesOptions,
                        "bg-amber-100 text-amber-700",
                        "לא נבחרו תחביבים מועדפים."
                      )}
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PreferencesSection;
--- End of Content for PreferencesSection.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\ProfileSection.tsx
--------------------------------------------------------------------------------
Content:
"use client";

import React, { useState, useEffect } from "react";
import {
  Gender,
  AvailabilityStatus,
  ServiceType,
  HeadCoveringType,
  KippahType,
} from "@prisma/client";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Pencil,
  Save,
  X,
  Users,
  BookOpen,
  Briefcase,
  Shield,
  Heart,
  MapPin,
  Languages,
  Palette,
  Smile,
  UserCircle, // אייקון חדש
  Info, // אייקון חדש
} from "lucide-react";
import { UserProfile } from "@/types/next-auth";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { languageOptions } from "@/lib/languageOptions"; 
// --- Options Arrays (נשארים כפי שהיו) ---

const maritalStatusOptions = [
  { value: "single", label: "רווק/ה" },
  { value: "divorced", label: "גרוש/ה" },
  { value: "widowed", label: "אלמן/ה" },
  { value: "annulled", label: "נישואין שבוטלו" },
];

const religiousLevelOptions = [
  { value: "charedi", label: "חרדי/ת" },
  { value: "charedi_modern", label: "חרדי/ת מודרני/ת" },
  { value: "dati_leumi_torani", label: "דתי/ה לאומי/ת תורני/ת" },
  { value: "dati_leumi_liberal", label: "דתי/ה לאומי/ת ליברלי/ת" },
  { value: "dati_leumi_standard", label: "דתי/ה לאומי/ת (סטנדרטי)" },
  { value: "masorti_strong", label: "מסורתי/ת (קרוב/ה לדת)" },
  { value: "masorti_light", label: "מסורתי/ת (קשר קל למסורת)" },
  { value: "secular_traditional_connection", label: "חילוני/ת עם זיקה למסורת" },
  { value: "secular", label: "חילוני/ת" },
  { value: "spiritual_not_religious", label: "רוחני/ת (לאו דווקא דתי/ה)" },
  { value: "other", label: "אחר (נא לפרט ב'אודות')" },
];

const educationLevelOptions = [
  { value: "high_school", label: "תיכונית" },
  { value: "vocational", label: "מקצועית / תעודה" },
  { value: "academic_student", label: "סטודנט/ית לתואר" },
  { value: "academic_ba", label: "תואר ראשון (BA/BSc)" },
  { value: "academic_ma", label: "תואר שני (MA/MSc)" },
  { value: "academic_phd", label: "דוקטורט (PhD)" },
  { value: "yeshiva_seminary", label: "לימודים תורניים (ישיבה/מדרשה/כולל)" },
  { value: "other", label: "אחר" },
];

const serviceTypeOptions = [
  { value: ServiceType.MILITARY_COMBATANT, label: "צבאי - לוחם/ת" },
  { value: ServiceType.MILITARY_SUPPORT, label: "צבאי - תומכ/ת לחימה" },
  { value: ServiceType.MILITARY_OFFICER, label: "צבאי - קצונה" },
  {
    value: ServiceType.MILITARY_INTELLIGENCE_CYBER_TECH,
    label: "צבאי - מודיעין/סייבר/טכנולוגי",
  },
  { value: ServiceType.NATIONAL_SERVICE_ONE_YEAR, label: "שירות לאומי - שנה" },
  {
    value: ServiceType.NATIONAL_SERVICE_TWO_YEARS,
    label: "שירות לאומי - שנתיים",
  },
  { value: ServiceType.HESDER_YESHIVA, label: "ישיבת הסדר" },
  {
    value: ServiceType.YESHIVA_ONLY_POST_HS,
    label: "ישיבה גבוהה / מדרשה (ללא שירות צבאי/לאומי)",
  },
  {
    value: ServiceType.PRE_MILITARY_ACADEMY_AND_SERVICE,
    label: "מכינה קדם-צבאית ושירות",
  },
  { value: ServiceType.EXEMPTED, label: "פטור משירות" },
  { value: ServiceType.CIVILIAN_SERVICE, label: "שירות אזרחי" },
  { value: ServiceType.OTHER, label: "אחר / לא רלוונטי" },
];

const headCoveringOptions = [
  { value: HeadCoveringType.FULL_COVERAGE, label: "כיסוי ראש מלא" },
  { value: HeadCoveringType.PARTIAL_COVERAGE, label: "כיסוי ראש חלקי" },
  { value: HeadCoveringType.HAT_BERET, label: "כובע / ברט" },
  {
    value: HeadCoveringType.SCARF_ONLY_SOMETIMES,
    label: "מטפחת (רק באירועים/בית כנסת)",
  },
  { value: HeadCoveringType.NONE, label: "ללא כיסוי ראש" },
];

const kippahTypeOptions = [
  { value: KippahType.BLACK_VELVET, label: "קטיפה שחורה" },
  { value: KippahType.KNITTED_SMALL, label: "סרוגה קטנה" },
  { value: KippahType.KNITTED_LARGE, label: "סרוגה גדולה" },
  { value: KippahType.CLOTH, label: "בד" },
  { value: KippahType.BRESLEV, label: "ברסלב (לבנה גדולה)" },
  { value: KippahType.NONE_AT_WORK_OR_CASUAL, label: "לא בעבודה / ביומיום" },
  { value: KippahType.NONE_USUALLY, label: "לרוב לא חובש" },
  { value: KippahType.OTHER, label: "אחר" },
];

const characterTraitsOptions = [
  { value: "empathetic", label: "אמפתי/ת", icon: Heart },
  { value: "driven", label: "שאפתן/ית", icon: Briefcase },
  { value: "optimistic", label: "אופטימי/ת", icon: Smile },
  { value: "family_oriented", label: "משפחתי/ת", icon: Users },
  { value: "intellectual", label: "אינטלקטואל/ית", icon: BookOpen },
  { value: "organized", label: "מאורגנ/ת", icon: Palette },
  { value: "calm", label: "רגוע/ה", icon: Heart },
  { value: "humorous", label: "בעל/ת חוש הומור", icon: Smile },
  { value: "sociable", label: "חברותי/ת", icon: Users },
  { value: "sensitive", label: "רגיש/ה", icon: Heart },
  { value: "independent", label: "עצמאי/ת", icon: MapPin },
  { value: "creative", label: "יצירתי/ת", icon: Palette },
  { value: "honest", label: "כן/ה וישר/ה", icon: Shield },
  { value: "responsible", label: "אחראי/ת", icon: Shield },
  { value: "easy_going", label: "זורם/ת וקליל/ה", icon: Smile },
];

const hobbiesOptions = [
  { value: "travel", label: "טיולים", icon: MapPin },
  { value: "sports", label: "ספורט", icon: Briefcase },
  { value: "reading", label: "קריאה", icon: BookOpen },
  { value: "cooking_baking", label: "בישול/אפיה", icon: Palette },
  { value: "music_playing_instrument", label: "מוזיקה/נגינה", icon: Languages },
  { value: "art_crafts", label: "אומנות/יצירה", icon: Palette },
  { value: "volunteering", label: "התנדבות", icon: Heart },
  { value: "learning_courses", label: "למידה/קורסים", icon: BookOpen },
  { value: "board_games_puzzles", label: "משחקי קופסא/פאזלים", icon: Smile },
  { value: "movies_theater", label: "סרטים/תיאטרון", icon: Smile },
  { value: "dancing", label: "ריקוד", icon: Users },
  { value: "writing", label: "כתיבה", icon: BookOpen },
  { value: "nature_hiking", label: "טבע/טיולים רגליים", icon: MapPin },
  { value: "photography", label: "צילום", icon: Palette },
];

const preferredMatchmakerGenderOptions = [
  { value: "MALE", label: "משדך" },
  { value: "FEMALE", label: "שדכנית" },
  { value: "NONE", label: "ללא העדפה" },
];
// --- End of Options Arrays ---

interface ProfileSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  setIsEditing: (value: boolean) => void;
  viewOnly?: boolean;
  onSave: (data: Partial<UserProfile>) => void;
}

const ensureDateObject = (
  value: string | number | Date | null | undefined
): Date | undefined => {
  if (!value) return undefined;
  if (value instanceof Date && !isNaN(value.getTime())) {
    return value;
  }
  if (typeof value === "string" || typeof value === "number") {
    const date = new Date(value);
    if (!isNaN(date.getTime())) {
      return date;
    }
  }
  return undefined;
};

const ProfileSection: React.FC<ProfileSectionProps> = ({
  profile: profileProp,
  isEditing,
  setIsEditing,
  viewOnly = false,
  onSave,
}) => {
  const [formData, setFormData] = useState<Partial<UserProfile>>({});
  const [loading, setLoading] = useState(true);
  const [initialData, setInitialData] = useState<Partial<UserProfile>>({});

  const initializeFormData = (profileData: UserProfile | null) => {
    const dataToSet: Partial<UserProfile> = {
      gender: profileData?.gender || undefined,
      birthDate: ensureDateObject(profileData?.birthDate),
      nativeLanguage: profileData?.nativeLanguage || undefined,
      additionalLanguages: profileData?.additionalLanguages || [],
      height: profileData?.height ?? undefined,
      maritalStatus: profileData?.maritalStatus || undefined,
      occupation: profileData?.occupation || "",
      education: profileData?.education || "",
      educationLevel: profileData?.educationLevel || undefined,
      city: profileData?.city || "",
      origin: profileData?.origin || "",
      religiousLevel: profileData?.religiousLevel || undefined,
      about: profileData?.about || "",
      parentStatus: profileData?.parentStatus || undefined,
      siblings: profileData?.siblings ?? undefined,
      position: profileData?.position ?? undefined,
      isProfileVisible: profileData?.isProfileVisible ?? true,
      preferredMatchmakerGender:
        profileData?.preferredMatchmakerGender || undefined,
      availabilityStatus:
        profileData?.availabilityStatus || AvailabilityStatus.AVAILABLE,
      availabilityNote: profileData?.availabilityNote || "",
      availabilityUpdatedAt: ensureDateObject(
        profileData?.availabilityUpdatedAt
      ),
      matchingNotes: profileData?.matchingNotes || "",
      shomerNegiah: profileData?.shomerNegiah ?? undefined,
      serviceType: profileData?.serviceType || undefined,
      serviceDetails: profileData?.serviceDetails || "",
      headCovering: profileData?.headCovering || undefined,
      kippahType: profileData?.kippahType || undefined,
      hasChildrenFromPrevious:
        profileData?.hasChildrenFromPrevious ?? undefined,
      profileCharacterTraits: profileData?.profileCharacterTraits || [],
      profileHobbies: profileData?.profileHobbies || [],
      aliyaCountry: profileData?.aliyaCountry || "",
      aliyaYear: profileData?.aliyaYear ?? undefined,
      preferredAgeMin: profileData?.preferredAgeMin ?? undefined,
      preferredAgeMax: profileData?.preferredAgeMax ?? undefined,
      preferredHeightMin: profileData?.preferredHeightMin ?? undefined,
      preferredHeightMax: profileData?.preferredHeightMax ?? undefined,
      preferredReligiousLevels: profileData?.preferredReligiousLevels || [],
      preferredLocations: profileData?.preferredLocations || [],
      preferredEducation: profileData?.preferredEducation || [],
      preferredOccupations: profileData?.preferredOccupations || [],
      contactPreference: profileData?.contactPreference || undefined,
      id: profileData?.id,
      userId: profileData?.userId,
      createdAt: ensureDateObject(profileData?.createdAt),
      updatedAt: ensureDateObject(profileData?.updatedAt),
      lastActive: ensureDateObject(profileData?.lastActive),
    };
    setFormData(dataToSet);
    setInitialData(dataToSet);
  };

  useEffect(() => {
    setLoading(true);
    if (profileProp) {
      initializeFormData(profileProp);
      setLoading(false);
    } else {
      const fetchProfileAndInitialize = async () => {
        try {
          const response = await fetch("/api/profile");
          if (!response.ok) throw new Error("Failed to fetch profile");
          const data = await response.json();
          if (data.success && data.profile) {
            initializeFormData(data.profile);
          } else {
            initializeFormData(null);
          }
        } catch (error) {
          console.error("Failed to fetch profile:", error);
          initializeFormData(null);
        } finally {
          setLoading(false);
        }
      };
      fetchProfileAndInitialize();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [profileProp]);

  const handleChange = (
    field: keyof UserProfile,
    value:
      | UserProfile[keyof UserProfile]
      | string
      | number
      | boolean
      | Date
      | string[]
      | null
  ) => {
    setFormData((prev) => {
      let finalValue: UserProfile[keyof UserProfile] | undefined = undefined;

      if (
        field === "height" ||
        field === "siblings" ||
        field === "position" ||
        field === "aliyaYear" ||
        field === "preferredAgeMin" || // Add preference fields
        field === "preferredAgeMax" ||
        field === "preferredHeightMin" ||
        field === "preferredHeightMax"
      ) {
        const rawValue = value as string | number;
        if (rawValue === "" || rawValue === null || rawValue === undefined) {
          finalValue = undefined;
        } else {
          const parsed = parseInt(String(rawValue), 10);
          finalValue = !isNaN(parsed)
            ? (parsed as UserProfile[typeof field])
            : undefined;
        }
      } else if (field === "birthDate") {
        finalValue = ensureDateObject(
          value as string | Date | null | undefined
        ) as UserProfile[typeof field];
      } else if (
        typeof prev[field] === "boolean" ||
        field === "shomerNegiah" || // Explicitly handle boolean fields
        field === "hasChildrenFromPrevious" ||
        field === "isProfileVisible"
      ) {
        finalValue = value as boolean as UserProfile[typeof field];
      } else if (Array.isArray(prev[field])) {
        finalValue = value as string[] as UserProfile[typeof field];
      } else if (value === "" || value === null) {
        const nullableStringFields: (keyof UserProfile)[] = [
          "nativeLanguage",
          "occupation",
          "education",
          "city",
          "origin",
          "religiousLevel",
          "about",
          "parentStatus",
          "serviceDetails",
          "aliyaCountry",
          "availabilityNote",
          "matchingNotes",
          "educationLevel",
          "maritalStatus",
          "serviceType",
          "headCovering",
          "kippahType",
          "preferredMatchmakerGender",
          "contactPreference",
        ];
        if (nullableStringFields.includes(field as keyof UserProfile)) {
          finalValue = undefined;
        } else {
          finalValue = value as UserProfile[typeof field];
        }
      } else {
        finalValue = value as UserProfile[typeof field];
      }

      return {
        ...prev,
        [field]: finalValue,
      };
    });
  };

  const handleMultiSelectToggle = (
    field: keyof UserProfile,
    optionValue: string
  ) => {
    setFormData((prev) => {
      const currentValues = (prev[field] as string[]) || [];
      const newValues = currentValues.includes(optionValue)
        ? currentValues.filter((v) => v !== optionValue)
        : [...currentValues, optionValue];
      return { ...prev, [field]: newValues };
    });
  };

  const handleSave = () => {
    const dataToSave = { ...formData };
    onSave(dataToSave);
    setIsEditing(false);
    setInitialData(dataToSave);
  };

  const handleCancel = () => {
    setFormData(initialData);
    setIsEditing(false);
  };

  const renderDisplayValue = (
    value: string | number | Date | undefined | null,
    placeholder: string = "לא צוין"
  ) => {
    if (value === undefined || value === null || value === "") {
      return <span className="italic text-gray-500">{placeholder}</span>;
    }
    if (value instanceof Date && !isNaN(value.getTime())) {
      return new Intl.DateTimeFormat("he-IL").format(value);
    }
    return String(value);
  };

  const renderSelectDisplayValue = (
    value: string | undefined | null,
    options: { value: string; label: string }[],
    placeholder: string = "לא צוין"
  ) => {
    if (!value) {
      return <span className="italic text-gray-500">{placeholder}</span>;
    }
    const option = options.find((opt) => opt.value === value);
    return option ? (
      option.label
    ) : (
      <span className="italic text-gray-500">{placeholder}</span>
    );
  };

  const renderBooleanDisplayValue = (
    value: boolean | undefined | null,
    trueLabel: string = "כן",
    falseLabel: string = "לא",
    placeholder: string = "לא צוין"
  ) => {
    if (value === undefined || value === null) {
      return <span className="italic text-gray-500">{placeholder}</span>;
    }
    return value ? trueLabel : falseLabel;
  };

  if (loading) {
    return <div className="text-center p-4">טוען נתוני פרופיל...</div>;
  }

  const renderMultiSelectBadges = (
    fieldValues: string[] | undefined,
    options: { value: string; label: string; icon?: React.ElementType }[],
    emptyPlaceholder: string = "לא נבחרו פריטים."
  ) => {
    if (!fieldValues || fieldValues.length === 0) {
      return <p className="text-sm text-gray-500 italic">{emptyPlaceholder}</p>;
    }
    return fieldValues.map((value) => {
      const option = options.find((opt) => opt.value === value);
      return option ? (
        <Badge
          key={value}
          variant="secondary"
          className="mr-1 mb-1 bg-sky-100 text-sky-700 text-xs px-2 py-0.5 rounded-full"
        >
          {option.icon && <option.icon className="w-3 h-3 mr-1" />}
          {option.label}
        </Badge>
      ) : null;
    });
  };

  return (
    <div className="relative" dir="rtl">
      <div className="sticky top-0 z-10 bg-gradient-to-b from-white via-white/95 to-white/0 pt-4 pb-3 backdrop-blur-sm">
        <div className="container mx-auto max-w-screen-xl px-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-xl md:text-2xl font-bold text-slate-800">
                פרופיל אישי
              </h1>
              <p className="text-sm text-slate-500">
                {isEditing && !viewOnly
                  ? "ערוך/י את פרטי הפרופיל שלך."
                  : "פרטי הפרופיל של המועמד/ת."}
              </p>
            </div>
            {!viewOnly && (
              <div className="flex gap-2">
                {!isEditing ? (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setIsEditing(true)}
                    className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-cyan-400 text-cyan-700 hover:bg-cyan-50"
                  >
                    <Pencil className="w-3.5 h-3.5 ml-1.5" />
                    עריכה
                  </Button>
                ) : (
                  <>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleCancel}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 border-gray-300 text-gray-700 hover:bg-gray-50"
                    >
                      <X className="w-3.5 h-3.5 ml-1.5" />
                      ביטול
                    </Button>
                    <Button
                      variant="default"
                      size="sm"
                      onClick={handleSave}
                      className="rounded-full shadow-sm hover:shadow-md transition-all duration-300 bg-cyan-600 hover:bg-cyan-700 text-white"
                    >
                      <Save className="w-3.5 h-3.5 ml-1.5" />
                      שמירה
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="container mx-auto max-w-screen-xl py-6 px-4">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* --- טור 1 --- */}
          <div className="space-y-6">
            {/* --- כרטיס פרטים אישיים ודמוגרפיים --- */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-cyan-50/40 to-pink-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <UserCircle className="w-5 h-5 text-cyan-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  פרטים אישיים ודמוגרפיים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מגדר
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.gender || ""}
                        onValueChange={(value) =>
                          handleChange("gender", value as Gender)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י מגדר" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="MALE">זכר</SelectItem>
                          <SelectItem value="FEMALE">נקבה</SelectItem>
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.gender === "MALE"
                            ? "זכר"
                            : formData.gender === "FEMALE"
                            ? "נקבה"
                            : undefined
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      תאריך לידה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="date"
                        value={
                          formData.birthDate instanceof Date &&
                          !isNaN(formData.birthDate.getTime())
                            ? formData.birthDate.toISOString().split("T")[0]
                            : ""
                        }
                        onChange={(e) =>
                          handleChange("birthDate", e.target.value || undefined)
                        }
                        className="h-9 text-sm focus:ring-cyan-500"
                        max={new Date().toISOString().split("T")[0]}
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.birthDate)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      גובה (סמ)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.height ?? ""}
                        onChange={(e) => handleChange("height", e.target.value)}
                        className="h-9 text-sm focus:ring-cyan-500"
                        placeholder="גובה בסמ"
                        min="100"
                        max="250"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.height ? `${formData.height} ס"מ` : undefined
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      עיר מגורים
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.city || ""}
                        onChange={(e) => handleChange("city", e.target.value)}
                        placeholder="לדוגמה: ירושלים"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.city)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מוצא / עדה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.origin || ""}
                        onChange={(e) => handleChange("origin", e.target.value)}
                        placeholder="לדוגמה: אשכנזי, ספרדי"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.origin)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      עלה/תה לארץ
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.aliyaCountry || ""}
                        onChange={(e) =>
                          handleChange("aliyaCountry", e.target.value)
                        }
                        placeholder="אם רלוונטי, מאיזו מדינה?"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.aliyaCountry,
                          "לא רלוונטי"
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שנת עליה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.aliyaYear ?? ""}
                        onChange={(e) =>
                          handleChange("aliyaYear", e.target.value)
                        }
                        disabled={!formData.aliyaCountry}
                        placeholder="אם רלוונטי"
                        className="h-9 text-sm focus:ring-cyan-500"
                        min="1900"
                        max={new Date().getFullYear()}
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(
                          formData.aliyaYear,
                          formData.aliyaCountry ? "לא צוינה שנה" : "לא רלוונטי"
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שפת אם
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.nativeLanguage || ""}
                        onValueChange={(value) =>
                          handleChange("nativeLanguage", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י שפת אם" />
                        </SelectTrigger>
                        <SelectContent className="max-h-[200px]">
                          {languageOptions.map((lang) => (
                            <SelectItem key={lang.value} value={lang.value}>
                              {lang.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.nativeLanguage,
                          languageOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2 lg:col-span-1">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שפות נוספות
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        onValueChange={(value) => {
                          const currentLanguages =
                            formData.additionalLanguages || [];
                          if (!currentLanguages.includes(value)) {
                            handleChange("additionalLanguages", [
                              ...currentLanguages,
                              value,
                            ]);
                          }
                        }}
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="הוסף/י שפה..." />
                        </SelectTrigger>
                        <SelectContent className="max-h-[200px]">
                          {languageOptions
                            .filter(
                              (lang) =>
                                !(formData.additionalLanguages || []).includes(
                                  lang.value
                                ) && lang.value !== formData.nativeLanguage
                            )
                            .map((lang) => (
                              <SelectItem key={lang.value} value={lang.value}>
                                {lang.label}
                              </SelectItem>
                            ))}
                        </SelectContent>
                      </Select>
                    ) : null}
                    <div className="mt-2 flex flex-wrap gap-1.5">
                      {(formData.additionalLanguages || []).map((langValue) => {
                        const lang = languageOptions.find(
                          (l) => l.value === langValue
                        );
                        return lang ? (
                          <Badge
                            key={lang.value}
                            variant="secondary"
                            className="bg-cyan-100/70 text-cyan-800 px-2 py-0.5 rounded-full text-[11px] font-medium flex items-center"
                          >
                            {lang.label}
                            {isEditing && !viewOnly && (
                              <button
                                type="button"
                                onClick={() =>
                                  handleChange(
                                    "additionalLanguages",
                                    (formData.additionalLanguages || []).filter(
                                      (l) => l !== langValue
                                    )
                                  )
                                }
                                className="mr-1.5 text-cyan-600 hover:text-cyan-800 text-xs"
                                aria-label={`הסר ${lang.label}`}
                              >
                                ×
                              </button>
                            )}
                          </Badge>
                        ) : null;
                      })}
                      {(!isEditing || viewOnly) &&
                        (!formData.additionalLanguages ||
                          formData.additionalLanguages.length === 0) && (
                          <p className="text-sm text-gray-500 italic">
                            לא צוינו שפות נוספות.
                          </p>
                        )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* --- כרטיס מצב משפחתי ורקע --- */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-purple-50/40 to-indigo-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Users className="w-5 h-5 text-purple-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  מצב משפחתי ורקע
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-5 items-start">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מצב משפחתי
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.maritalStatus || ""}
                        onValueChange={(value) =>
                          handleChange("maritalStatus", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י מצב" />
                        </SelectTrigger>
                        <SelectContent>
                          {maritalStatusOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.maritalStatus,
                          maritalStatusOptions
                        )}
                      </p>
                    )}
                  </div>
                  {(formData.maritalStatus === "divorced" ||
                    formData.maritalStatus === "widowed" ||
                    formData.maritalStatus === "annulled") && (
                    <div
                      className={cn(
                        "pt-1 sm:pt-0",
                        isEditing && !viewOnly ? "sm:pt-5" : "sm:pt-0"
                      )}
                    >
                      <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                        ילדים מקשר קודם?
                      </Label>
                      {isEditing && !viewOnly ? (
                        <div className="flex items-center space-x-2 rtl:space-x-reverse mt-2">
                          <Checkbox
                            id="hasChildrenFromPrevious"
                            checked={formData.hasChildrenFromPrevious || false}
                            onCheckedChange={(checked) =>
                              handleChange(
                                "hasChildrenFromPrevious",
                                checked as boolean
                              )
                            }
                          />
                          <Label
                            htmlFor="hasChildrenFromPrevious"
                            className="text-sm font-normal text-gray-700"
                          >
                            יש ילדים
                          </Label>
                        </div>
                      ) : (
                        <p className="text-sm text-gray-800 font-medium mt-1">
                          {renderBooleanDisplayValue(
                            formData.hasChildrenFromPrevious
                          )}
                        </p>
                      )}
                    </div>
                  )}
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מצב הורים
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.parentStatus || ""}
                        onChange={(e) =>
                          handleChange("parentStatus", e.target.value)
                        }
                        placeholder="לדוגמה: נשואים, גרושים"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.parentStatus)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מספר אחים/אחיות
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.siblings ?? ""}
                        onChange={(e) =>
                          handleChange("siblings", e.target.value)
                        }
                        className="h-9 text-sm focus:ring-cyan-500"
                        placeholder="כולל אותך"
                        min="0"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.siblings)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מיקום במשפחה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        type="number"
                        value={formData.position ?? ""}
                        onChange={(e) =>
                          handleChange("position", e.target.value)
                        }
                        className="h-9 text-sm focus:ring-cyan-500"
                        placeholder="לדוגמה: 1 (בכור/ה)"
                        min="0"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.position)}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* --- כרטיס דת ואורח חיים --- */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-yellow-50/40 to-amber-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <BookOpen className="w-5 h-5 text-amber-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  דת ואורח חיים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-5 items-start">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      רמה דתית
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.religiousLevel || ""}
                        onValueChange={(value) =>
                          handleChange("religiousLevel", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י רמה" />
                        </SelectTrigger>
                        <SelectContent className="max-h-[250px]">
                          {religiousLevelOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.religiousLevel,
                          religiousLevelOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div
                    className={cn(
                      "pt-1 sm:pt-0",
                      isEditing && !viewOnly ? "sm:pt-5" : "sm:pt-0"
                    )}
                  >
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שומר/ת נגיעה?
                    </Label>
                    {isEditing && !viewOnly ? (
                      <div className="flex items-center space-x-2 rtl:space-x-reverse mt-2">
                        <Checkbox
                          id="shomerNegiah"
                          checked={formData.shomerNegiah || false}
                          onCheckedChange={(checked) =>
                            handleChange("shomerNegiah", checked as boolean)
                          }
                        />
                        <Label
                          htmlFor="shomerNegiah"
                          className="text-sm font-normal text-gray-700"
                        >
                          כן
                        </Label>
                      </div>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderBooleanDisplayValue(formData.shomerNegiah)}
                      </p>
                    )}
                  </div>
                  {formData.gender === Gender.FEMALE && (
                    <div>
                      <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                        כיסוי ראש
                      </Label>
                      {isEditing && !viewOnly ? (
                        <Select
                          value={formData.headCovering || ""}
                          onValueChange={(value) =>
                            handleChange(
                              "headCovering",
                              (value as HeadCoveringType) || undefined
                            )
                          }
                        >
                          <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                            <SelectValue placeholder="בחר/י סוג כיסוי" />
                          </SelectTrigger>
                          <SelectContent>
                            {headCoveringOptions.map((opt) => (
                              <SelectItem key={opt.value} value={opt.value}>
                                {opt.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      ) : (
                        <p className="text-sm text-gray-800 font-medium mt-1">
                          {renderSelectDisplayValue(
                            formData.headCovering,
                            headCoveringOptions,
                            "ללא"
                          )}
                        </p>
                      )}
                    </div>
                  )}
                  {formData.gender === Gender.MALE && (
                    <div>
                      <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                        סוג כיפה
                      </Label>
                      {isEditing && !viewOnly ? (
                        <Select
                          value={formData.kippahType || ""}
                          onValueChange={(value) =>
                            handleChange(
                              "kippahType",
                              (value as KippahType) || undefined
                            )
                          }
                        >
                          <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                            <SelectValue placeholder="בחר/י סוג כיפה" />
                          </SelectTrigger>
                          <SelectContent className="max-h-[200px]">
                            {kippahTypeOptions.map((opt) => (
                              <SelectItem key={opt.value} value={opt.value}>
                                {opt.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      ) : (
                        <p className="text-sm text-gray-800 font-medium mt-1">
                          {renderSelectDisplayValue(
                            formData.kippahType,
                            kippahTypeOptions,
                            "ללא"
                          )}
                        </p>
                      )}
                    </div>
                  )}
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      מגדר שדכן/ית מועדף
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.preferredMatchmakerGender || ""}
                        onValueChange={(value) =>
                          handleChange(
                            "preferredMatchmakerGender",
                            (value as Gender) || undefined
                          )
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י העדפה (לא חובה)" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="MALE">משדך</SelectItem>
                          <SelectItem value="FEMALE">שדכנית</SelectItem>
                          <SelectItem value="NONE">ללא העדפה</SelectItem>
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.preferredMatchmakerGender,
                          preferredMatchmakerGenderOptions,
                          "ללא העדפה"
                        )}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* --- טור 2 --- */}
          <div className="space-y-6">
            {/* --- כרטיס אודות ומידע נוסף (עבר לכאן) --- */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-slate-50/40 to-gray-100/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Info className="w-5 h-5 text-slate-600" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  קצת עלי ומידע נוסף
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="space-y-6">
                  <div>
                    <Label className="block mb-1.5 text-sm font-medium text-gray-700">
                      ספר/י קצת על עצמך (תיאור חופשי)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Textarea
                        value={formData.about || ""}
                        onChange={(e) => handleChange("about", e.target.value)}
                        className="text-sm focus:ring-cyan-500 min-h-[120px] rounded-lg"
                        placeholder="תאר/י את עצמך, מה מאפיין אותך, מה חשוב לך..."
                        rows={5}
                      />
                    ) : (
                      <p className="mt-1 text-sm text-gray-700 whitespace-pre-wrap min-h-[60px] bg-slate-50/70 p-3 rounded-lg border border-slate-200/50">
                        {formData.about || (
                          <span className="text-gray-500 italic">
                            לא הוזן תיאור אישי.
                          </span>
                        )}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-sm font-medium text-gray-700">
                      הערות נוספות לשדכן/ית (לא יוצג לצד השני)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Textarea
                        value={formData.matchingNotes || ""}
                        onChange={(e) =>
                          handleChange("matchingNotes", e.target.value)
                        }
                        className="text-sm focus:ring-cyan-500 min-h-[90px] rounded-lg"
                        placeholder="דברים נוספים שחשוב שהשדכן/ית יידעו עליך..."
                        rows={3}
                      />
                    ) : (
                      <p className="mt-1 text-sm text-gray-700 whitespace-pre-wrap min-h-[50px] bg-slate-50/70 p-3 rounded-lg border border-slate-200/50">
                        {formData.matchingNotes || (
                          <span className="text-gray-500 italic">
                            אין הערות נוספות לשדכן/ית.
                          </span>
                        )}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* --- כרטיס השכלה, עיסוק ושירות --- */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-teal-50/40 to-green-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Briefcase className="w-5 h-5 text-teal-700" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  השכלה, עיסוק ושירות
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      רמת השכלה
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.educationLevel || ""}
                        onValueChange={(value) =>
                          handleChange("educationLevel", value || undefined)
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י רמה" />
                        </SelectTrigger>
                        <SelectContent>
                          {educationLevelOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.educationLevel,
                          educationLevelOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      פירוט השכלה (מוסד, תחום)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.education || ""}
                        onChange={(e) =>
                          handleChange("education", e.target.value)
                        }
                        placeholder="לדוגמה: אוני' בר אילן, משפטים"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.education)}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      עיסוק נוכחי
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.occupation || ""}
                        onChange={(e) =>
                          handleChange("occupation", e.target.value)
                        }
                        placeholder="לדוגמה: מורה, מהנדס תוכנה"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.occupation)}
                      </p>
                    )}
                  </div>
                  <div>
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      שירות (צבאי/לאומי/אחר)
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Select
                        value={formData.serviceType || ""}
                        onValueChange={(value) =>
                          handleChange(
                            "serviceType",
                            (value as ServiceType) || undefined
                          )
                        }
                      >
                        <SelectTrigger className="h-9 text-sm focus:ring-cyan-500">
                          <SelectValue placeholder="בחר/י סוג שירות" />
                        </SelectTrigger>
                        <SelectContent className="max-h-[250px]">
                          {serviceTypeOptions.map((opt) => (
                            <SelectItem key={opt.value} value={opt.value}>
                              {opt.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderSelectDisplayValue(
                          formData.serviceType,
                          serviceTypeOptions
                        )}
                      </p>
                    )}
                  </div>
                  <div className="sm:col-span-2">
                    <Label className="block mb-1.5 text-xs font-medium text-gray-600">
                      פירוט על השירות
                    </Label>
                    {isEditing && !viewOnly ? (
                      <Input
                        value={formData.serviceDetails || ""}
                        onChange={(e) =>
                          handleChange("serviceDetails", e.target.value)
                        }
                        placeholder="חיל, יחידה, תפקיד, שם ישיבה/מכינה"
                        className="h-9 text-sm focus:ring-cyan-500"
                      />
                    ) : (
                      <p className="text-sm text-gray-800 font-medium mt-1">
                        {renderDisplayValue(formData.serviceDetails)}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* --- כרטיס תכונות אופי ותחביבים --- */}
            <Card className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg border border-gray-200/40 overflow-hidden">
              <CardHeader className="bg-gradient-to-r from-amber-50/40 to-yellow-50/40 border-b border-gray-200/50 p-4 flex items-center space-x-2 rtl:space-x-reverse">
                <Smile className="w-5 h-5 text-amber-600" />
                <CardTitle className="text-base font-semibold text-gray-700">
                  תכונות אופי ותחביבים
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4 md:p-6 space-y-6">
                <div>
                  <Label className="block mb-2 text-sm font-medium text-gray-700">
                    תכונות אופי בולטות (עד 3)
                  </Label>
                  {isEditing && !viewOnly ? (
                    <div className="flex flex-wrap gap-2">
                      {characterTraitsOptions.map((trait) => (
                        <Button
                          key={trait.value}
                          type="button"
                          variant={
                            (formData.profileCharacterTraits || []).includes(
                              trait.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectToggle(
                              "profileCharacterTraits",
                              trait.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.profileCharacterTraits || []).length >=
                              3 &&
                            !(formData.profileCharacterTraits || []).includes(
                              trait.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all", 
                            (formData.profileCharacterTraits || []).includes(
                              trait.value
                            )
                              ? "bg-amber-500 hover:bg-amber-600 text-white border-amber-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {trait.icon && (
                            <trait.icon className="w-3.5 h-3.5 ml-1.5 rtl:mr-1.5 rtl:ml-0" />
                          )}
                          {trait.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.profileCharacterTraits,
                        characterTraitsOptions,
                        "לא נבחרו תכונות אופי."
                      )}
                    </div>
                  )}
                </div>
                <div>
                  <Label className="block mb-2 text-sm font-medium text-gray-700">
                    תחביבים עיקריים (עד 3)
                  </Label>
                  {isEditing && !viewOnly ? (
                    <div className="flex flex-wrap gap-2">
                      {hobbiesOptions.map((hobby) => (
                        <Button
                          key={hobby.value}
                          type="button"
                          variant={
                            (formData.profileHobbies || []).includes(
                              hobby.value
                            )
                              ? "default"
                              : "outline"
                          }
                          size="sm"
                          onClick={() =>
                            handleMultiSelectToggle(
                              "profileHobbies",
                              hobby.value
                            )
                          }
                          disabled={
                            !viewOnly &&
                            (formData.profileHobbies || []).length >= 3 &&
                            !(formData.profileHobbies || []).includes(
                              hobby.value
                            )
                          }
                          className={cn(
                            "rounded-full text-xs px-3 py-1.5 transition-all",
                            (formData.profileHobbies || []).includes(
                              hobby.value
                            )
                              ? "bg-sky-500 hover:bg-sky-600 text-white border-sky-500"
                              : "border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400"
                          )}
                        >
                          {hobby.icon && (
                            <hobby.icon className="w-3.5 h-3.5 ml-1.5 rtl:mr-1.5 rtl:ml-0" />
                          )}
                          {hobby.label}
                        </Button>
                      ))}
                    </div>
                  ) : (
                    <div className="mt-1 flex flex-wrap gap-1.5">
                      {renderMultiSelectBadges(
                        formData.profileHobbies,
                        hobbiesOptions,
                        "לא נבחרו תחביבים."
                      )}
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ProfileSection;
--- End of Content for ProfileSection.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\sections\QuestionnaireResponsesSection.tsx
--------------------------------------------------------------------------------
Content:
// src/app/components/profile/sections/QuestionnaireResponsesSection.tsx

import React, { useState, useMemo, useEffect } from "react"; // Added useEffect
import Link from "next/link";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import {
  Book,
  CheckCircle,
  Clock,
  Pencil,
  X,
  Save,
  Eye,
  EyeOff,
  Loader2,
  ArrowRight,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type {
  QuestionnaireResponse,
  FormattedAnswer,
  UpdateValue,
} from "@/types/next-auth";

import { WORLDS } from "../constants";

// --- קבוע עבור כתובת השאלון ---
const QUESTIONNAIRE_URL = "/questionnaire"; // שימוש בנתיב יחסי אם האפליקציה רצה באותו דומיין
// אם אתה צריך את הכתובת המלאה (פחות מומלץ אם זה באותו אתר):
// const QUESTIONNAIRE_URL = "http://localhost:3000/questionnaire";

interface QuestionnaireResponsesSectionProps {
  questionnaire: QuestionnaireResponse | null;
  onUpdate?: (
    world: string,
    questionId: string,
    value: UpdateValue
  ) => Promise<void>;
  isEditable?: boolean;
  viewMode?: "matchmaker" | "candidate";
}

// --- QuestionCard Component ---
interface QuestionCardProps {
  question: string;
  answer: FormattedAnswer;
  isEditingGlobally: boolean;
  worldKey: string;
  onUpdate: (
    world: string,
    questionId: string,
    value: UpdateValue
  ) => Promise<void>;
}

const QuestionCard: React.FC<QuestionCardProps> = ({
  question,
  answer,
  isEditingGlobally,
  worldKey,
  onUpdate,
}) => {
  const [isEditingText, setIsEditingText] = useState(false);
  const [editValue, setEditValue] = useState(answer.displayText);
  const [isSavingText, setIsSavingText] = useState(false);
  const [isSavingVisibility, setIsSavingVisibility] = useState(false);

  // --- START OF MODIFIED SECTION ---
  // Local state for optimistic UI update of visibility
  const [currentIsVisible, setCurrentIsVisible] = useState(
    answer.isVisible ?? true
  );

  // Sync local state if the prop changes (e.g., due to parent update or initial load)
  useEffect(() => {
    setCurrentIsVisible(answer.isVisible ?? true);
  }, [answer.isVisible]);
  // --- END OF MODIFIED SECTION ---

  const isSaving = isSavingText || isSavingVisibility;

  const handleStartEdit = () => {
    if (isSaving) return;
    setIsEditingText(true);
    setEditValue(answer.displayText);
  };

  const handleSaveText = async () => {
    if (!editValue?.trim()) {
      toast.error("לא ניתן לשמור תשובה ריקה.");
      return;
    }
    if (editValue.trim() === answer.displayText) {
      setIsEditingText(false);
      return;
    }

    setIsSavingText(true);
    try {
      await onUpdate(worldKey, answer.questionId, {
        type: "answer",
        value: editValue.trim(),
      });
      toast.success("התשובה עודכנה בהצלחה");
      setIsEditingText(false);
      // No need to update editValue here, as parent will re-render with new answer prop
    } catch (error) {
      console.error("Error updating answer:", error);
      toast.error("שגיאה בעדכון התשובה");
    } finally {
      setIsSavingText(false);
    }
  };

  const handleCancelEdit = () => {
    setIsEditingText(false);
    setEditValue(answer.displayText);
  };

  const handleVisibilityChange = async (newIsVisibleState: boolean) => {
    // --- START OF MODIFIED SECTION ---
    // Optimistically update the local UI state
    setCurrentIsVisible(newIsVisibleState);
    // --- END OF MODIFIED SECTION ---
    setIsSavingVisibility(true);
    try {
      await onUpdate(worldKey, answer.questionId, {
        type: "visibility",
        isVisible: newIsVisibleState,
      });
      toast.success("הגדרות הנראות עודכנו");
      // If successful, the parent should eventually re-render with the updated answer.isVisible,
      // and the useEffect will sync if needed, but currentIsVisible is already correct.
    } catch (error) {
      console.error("Error updating visibility:", error);
      toast.error("שגיאה בעדכון הנראות");
      // --- START OF MODIFIED SECTION ---
      // Revert optimistic update on error
      setCurrentIsVisible(answer.isVisible ?? true);
      // --- END OF MODIFIED SECTION ---
    } finally {
      setIsSavingVisibility(false);
    }
  };

  // --- START OF MODIFIED SECTION ---
  // Update visibilityLabel to use currentIsVisible
  const visibilityLabel = `הצג תשובה זו למועמדים: ${
    currentIsVisible ? "מופעל" : "כבוי"
  }`;
  // --- END OF MODIFIED SECTION ---

  return (
    <div className="rounded-lg border bg-card p-4 shadow-sm transition-shadow duration-300 hover:shadow-md">
      <div className="flex items-start justify-between gap-4">
        <div className="flex-1 min-w-0">
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-3 gap-2">
            <h4 className="font-medium text-sm sm:text-base flex-1 text-right">
              {question}
            </h4>
            <div
              className="flex items-center gap-2 self-end sm:self-center"
              dir="ltr"
            >
              {isSavingVisibility && (
                <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
              )}
              <TooltipProvider delayDuration={200}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div
                      className={cn(
                        "flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs shrink-0 flex-row-reverse",
                        "transition-colors duration-200",
                        // --- START OF MODIFIED SECTION ---
                        currentIsVisible // Use currentIsVisible for styling
                          ? // --- END OF MODIFIED SECTION ---
                            "bg-emerald-100/70 text-emerald-800"
                          : "bg-gray-100 text-gray-600"
                      )}
                    >
                      {/* --- START OF MODIFIED SECTION --- */}
                      {currentIsVisible ? ( // Use currentIsVisible for icon and text
                        <Eye className="h-3.5 w-3.5" />
                      ) : (
                        <EyeOff className="h-3.5 w-3.5" />
                      )}
                      <span className="font-medium whitespace-nowrap" dir="rtl">
                        {currentIsVisible ? "גלוי למועמדים" : "מוסתר"}
                      </span>
                      {/* --- END OF MODIFIED SECTION --- */}
                    </div>
                  </TooltipTrigger>
                  <TooltipContent side="top" dir="rtl">
                    <p>
                      {/* --- START OF MODIFIED SECTION --- */}
                      {currentIsVisible // Use currentIsVisible for tooltip content
                        ? // --- END OF MODIFIED SECTION ---
                          "תשובה זו גלויה למועמדים פוטנציאליים"
                        : "תשובה זו מוסתרת וגלויה רק לך ולשדכנים"}
                    </p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>

              {isEditingGlobally && (
                <Switch
                  // --- START OF MODIFIED SECTION ---
                  checked={currentIsVisible} // Control Switch with local state
                  // --- END OF MODIFIED SECTION ---
                  onCheckedChange={handleVisibilityChange}
                  disabled={isSaving}
                  className="data-[state=checked]:bg-emerald-500 data-[state=unchecked]:bg-gray-300 transform scale-90"
                  aria-label={visibilityLabel}
                />
              )}
            </div>
          </div>

          {isEditingText ? (
            <div className="space-y-2 mt-1">
              <Textarea
                value={editValue}
                onChange={(e) => setEditValue(e.target.value)}
                className="min-h-[80px] text-sm focus:ring-cyan-500 focus:border-cyan-500"
                placeholder="הקלד/י את תשובתך כאן..."
                disabled={isSavingText}
              />
              <div className="flex justify-end gap-2">
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={handleCancelEdit}
                  disabled={isSavingText}
                  className="text-gray-600 hover:bg-gray-100"
                >
                  <X className="h-4 w-4 ml-1" />
                  ביטול
                </Button>
                <Button
                  size="sm"
                  onClick={handleSaveText}
                  disabled={isSavingText || !editValue?.trim()}
                  className="bg-cyan-600 hover:bg-cyan-700 text-white"
                >
                  {isSavingText ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <CheckCircle className="h-4 w-4 ml-1" />
                  )}
                  שמירה
                </Button>
              </div>
            </div>
          ) : (
            <div className="relative group overflow-hidden mt-1">
              <div className="p-3 bg-gray-50/50 rounded-md border border-gray-200/60 min-h-[40px]">
                <p className="text-sm text-gray-800 break-words overflow-wrap-anywhere whitespace-pre-wrap">
                  {answer.displayText}
                </p>
                <TooltipProvider delayDuration={200}>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <span className="text-xs text-gray-400 block mt-2 text-left">
                        {new Date(answer.answeredAt).toLocaleDateString(
                          "he-IL",
                          { year: "numeric", month: "2-digit", day: "2-digit" }
                        )}
                      </span>
                    </TooltipTrigger>
                    <TooltipContent side="top" dir="rtl">
                      <p>תאריך עדכון אחרון</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              {isEditingGlobally && !isSaving && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="absolute top-0 right-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200 h-7 w-7 text-cyan-600 hover:bg-cyan-50"
                  onClick={handleStartEdit}
                  title="עריכת תשובה"
                >
                  <Pencil className="h-4 w-4" />
                  <span className="sr-only">עריכת תשובה</span>
                </Button>
              )}
              {isSavingText && !isEditingText && (
                <div className="absolute top-1 right-1">
                  <Loader2 className="h-4 w-4 animate-spin text-cyan-500" />
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

// --- WorldSection Component ---
// (ללא שינוי)
interface WorldSectionProps {
  worldKey: keyof typeof WORLDS;
  worldConfig: (typeof WORLDS)[keyof typeof WORLDS];
  answers: FormattedAnswer[];
  isEditingGlobally: boolean;
  onUpdate: (
    world: string,
    questionId: string,
    value: UpdateValue
  ) => Promise<void>;
  isCompleted: boolean;
  className?: string;
}

const WorldSection: React.FC<WorldSectionProps> = ({
  worldKey,
  worldConfig,
  answers,
  isEditingGlobally,
  onUpdate,
  isCompleted,
  className,
}) => {
  const { title, icon: Icon, color, bgColor, borderColor } = worldConfig;

  return (
    <Card
      className={cn(
        "overflow-hidden shadow-sm border",
        bgColor,
        borderColor,
        className
      )}
    >
      <CardHeader
        className="p-4 border-b"
        style={{
          borderColor: `rgba(var(--${color.split("-")[1]}-200-rgb), 0.5)`,
        }}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div
              className={cn(
                "p-2 rounded-full",
                color.replace("text-", "bg-") + "/10"
              )}
            >
              <Icon className={cn("h-5 w-5", color)} />
            </div>
            <div>
              <CardTitle className="text-md sm:text-lg text-gray-800">
                {title}
              </CardTitle>
              <CardDescription className="text-xs text-gray-500 mt-0.5">
                {answers.length} {answers.length === 1 ? "תשובה" : "תשובות"}
              </CardDescription>
            </div>
          </div>
          <Badge
            variant={isCompleted ? "success" : "secondary"}
            className={cn(
              "gap-1 text-xs px-2 py-0.5 rounded-full",
              isCompleted
                ? "bg-emerald-100 text-emerald-800"
                : "bg-blue-100 text-blue-800"
            )}
          >
            {isCompleted ? (
              <CheckCircle className="h-3 w-3" />
            ) : (
              <Clock className="h-3 w-3" />
            )}
            {isCompleted ? "הושלם" : "בתהליך"}
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-4">
        <div className="space-y-4">
          {answers.map((answer) => (
            <QuestionCard
              key={answer.questionId}
              question={answer.question}
              answer={answer}
              isEditingGlobally={isEditingGlobally}
              worldKey={worldKey}
              onUpdate={onUpdate}
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

// --- QuestionnaireResponsesSection Component ---
const QuestionnaireResponsesSection: React.FC<
  QuestionnaireResponsesSectionProps
> = ({ questionnaire, onUpdate, isEditable = false }) => {
  const [isEditingGlobally, setIsEditingGlobally] = useState(false);

  const worldsWithAnswers = useMemo(() => {
    if (!questionnaire?.formattedAnswers) return [];
    return Object.entries(WORLDS)
      .map(([key, config]) => ({
        key: key as keyof typeof WORLDS,
        config,
        answers:
          questionnaire.formattedAnswers?.[
            key as keyof typeof questionnaire.formattedAnswers
          ] ?? [],
        isCompleted:
          (questionnaire[
            `${key}Completed` as keyof QuestionnaireResponse
          ] as boolean) ?? false,
      }))
      .filter((world) => world.answers.length > 0);
  }, [questionnaire]);

  if (!questionnaire) {
    return (
      <Card className="text-center py-12 text-gray-500 bg-gray-50 rounded-lg border border-dashed">
        <Book className="h-10 w-10 mx-auto mb-3 opacity-50 text-gray-400" />
        <p className="font-medium">לא מולא שאלון עבור פרופיל זה.</p>
        <p className="text-sm mt-1">אין תשובות להציג.</p>
        <div className="mt-6">
          <Button
            asChild
            variant="default"
            className="bg-cyan-600 hover:bg-cyan-700"
          >
            <Link
              href={QUESTIONNAIRE_URL}
              className="flex items-center gap-1.5"
            >
              מלא את השאלון
              <ArrowRight className="h-4 w-4" />
            </Link>
          </Button>
        </div>
      </Card>
    );
  }

  const hasAnyAnswers = worldsWithAnswers.length > 0;

  return (
    <div className="space-y-6">
      <Card className="shadow-sm border">
        <CardHeader className="p-4">
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
            <div className="flex items-center gap-3">
              {questionnaire.completed ? (
                <CheckCircle className="h-5 w-5 text-emerald-500 flex-shrink-0" />
              ) : (
                <Clock className="h-5 w-5 text-blue-500 flex-shrink-0" />
              )}
              <div>
                <p className="font-semibold text-base text-gray-800">
                  {questionnaire.completed ? "שאלון הושלם" : "שאלון בתהליך"}
                </p>
                <p className="text-xs text-gray-500 mt-0.5">
                  {hasAnyAnswers
                    ? `עודכן לאחרונה: ${new Date(
                        questionnaire.lastSaved
                      ).toLocaleDateString("he-IL")}`
                    : "השאלון טרם החל"}
                </p>
              </div>
            </div>

            <div className="flex flex-col sm:flex-row items-center gap-2 self-end sm:self-center">
              <Button
                asChild
                variant="outline"
                size="sm"
                className="rounded-full px-4 py-2 text-xs sm:text-sm"
              >
                <Link
                  href={QUESTIONNAIRE_URL}
                  className="flex items-center gap-1.5"
                >
                  עבור לשאלון
                  <ArrowRight className="h-4 w-4" />
                </Link>
              </Button>
              {isEditable && hasAnyAnswers && onUpdate && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setIsEditingGlobally(!isEditingGlobally)}
                  className="gap-1.5 rounded-full px-4 py-2 text-xs sm:text-sm"
                >
                  {isEditingGlobally ? (
                    <>
                      <Save className="h-4 w-4" />
                      סיום עריכה
                    </>
                  ) : (
                    <>
                      <Pencil className="h-4 w-4" />
                      עריכת תשובות
                    </>
                  )}
                </Button>
              )}
            </div>
          </div>
        </CardHeader>
      </Card>

      {hasAnyAnswers ? (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {worldsWithAnswers.map(({ key, config, answers, isCompleted }) => (
            <WorldSection
              key={key}
              worldKey={key}
              worldConfig={config}
              answers={answers}
              isEditingGlobally={isEditingGlobally}
              onUpdate={onUpdate!}
              isCompleted={isCompleted}
            />
          ))}
        </div>
      ) : (
        <div className="text-center py-10 text-gray-500 bg-gray-50/50 rounded-lg border border-gray-200">
          <Book className="h-8 w-8 mx-auto mb-2 opacity-50 text-gray-400" />
          <p className="font-medium text-lg">השאלון טרם מולא במלואו</p>
          <p className="text-sm mt-1 text-gray-600">
            עדיין אין תשובות להציג, אך ניתן להמשיך למלא את השאלון.
          </p>
          <div className="mt-6">
            <Button
              asChild
              variant="default"
              className="bg-cyan-600 hover:bg-cyan-700 text-white"
            >
              <Link
                href={QUESTIONNAIRE_URL}
                className="flex items-center gap-1.5 px-6 py-2"
              >
                המשך מילוי השאלון
                <ArrowRight className="h-4 w-4" />
              </Link>
            </Button>
          </div>
        </div>
      )}
    </div>
  );
};

export default QuestionnaireResponsesSection;
--- End of Content for QuestionnaireResponsesSection.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\types
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\types\profile.ts
--------------------------------------------------------------------------------
Content:
import type { UserProfile, UserImage, QuestionnaireResponse } from "@/types/next-auth";

// Define specific types for questionnaire updates
export interface QuestionnaireUpdateValue {
  type: 'answer' | 'visibility';
  value?: string;
  isVisible?: boolean;
}

// Interfaces for the main sections
export interface PhotosSectionProps {
  images: UserImage[];
  isUploading: boolean;
  disabled?: boolean;
  onUpload: (file: File) => Promise<void>;
  onSetMain: (imageId: string) => Promise<void>;
  onDelete: (imageId: string) => Promise<void>;
}


export interface PreferencesSectionProps {
  profile: UserProfile | null;
  isEditing: boolean;
  viewOnly?: boolean;
  setIsEditing: (value: boolean) => void;
  onChange: (data: Partial<UserProfile>) => void;
}

export interface QuestionnaireResponsesSectionProps {
  questionnaire: QuestionnaireResponse | null;
  onUpdate?: (world: string, questionId: string, value: QuestionnaireUpdateValue) => Promise<void>;
  isEditable?: boolean;
  viewMode?: "matchmaker" | "candidate";
}

// Types for the extended profile data
export interface ExtendedProfileData {
  personalityTraits?: {
    temperament?: string;
    decisionMaking?: string;
    stressManagement?: string;
    communicationStyle?: string;
  };
  spiritualProfile?: {
    prayerStyle?: string;
    secularStudiesAttitude?: string;
    modestyLevel?: string;
    childrenEducationApproach?: string;
  };
  familyBackground?: {
    parentsSpiritualLevel?: string;
    parentsOccupations?: {
      father?: string;
      mother?: string;
    };
    familyDynamics?: string;
  };
  lifestylePreferences?: {
    careerAspiration?: string;
    futureStudyPlans?: string;
    livingPreferences?: {
      proximity?: string;
    };
    relationshipExpectations?: string;
  };
  healthProfile?: {
    generalHealth?: string;
    dietaryRestrictions?: string[];
    physicalActivity?: string;
  };
  personalValues?: {
    parentalRespect?: number;
    communityInvolvement?: string;
    volunteeringPreferences?: string;
    financialManagement?: string;
  };
  futureGoals?: string[];
  [key: string]: unknown;
}

// Additional utility types
export type ViewMode = "matchmaker" | "candidate";
export type CardSize = "sm" | "md" | "lg";
--- End of Content for profile.ts ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\profile\types\questionnaire.ts
--------------------------------------------------------------------------------
Content:
// src/components/shared/profile/types/questionnaire.ts

export type QuestionnaireAnswerValue = {
  type: 'answer';
  value: string;
} | {
  type: 'visibility';
  isVisible: boolean;
} | string | number | boolean;

export interface FormattedAnswer {
  questionId: string;
  question: string;
  value: QuestionnaireAnswerValue;
  displayText: string;
  answeredAt: string;
  category?: string;
  isVisible: boolean;
}

export interface QuestionnaireResponse {
  id: string;
  userId: string;
  formattedAnswers: {
    values: FormattedAnswer[];
    personality: FormattedAnswer[];
    relationship: FormattedAnswer[];
    partner: FormattedAnswer[];
    religion: FormattedAnswer[];
  };
  valuesCompleted: boolean;
  personalityCompleted: boolean;
  relationshipCompleted: boolean;
  partnerCompleted: boolean;
  religionCompleted: boolean;
  worldsCompleted: string[];
  completed: boolean;
  startedAt: string | Date;
  completedAt?: string | Date;
  lastSaved: string | Date;
}

export interface QuestionnaireWorld {
  key: string;
  title: string;
  icon: React.ElementType;
  color: string;
  bgColor: string;
  borderColor: string;
}

export interface QuestionCardProps {
  question: string;
  answer: FormattedAnswer;
  isEditing: boolean;
  onEdit: (value: string) => void;
  onVisibilityChange: (isVisible: boolean) => void;
}

export interface WorldSectionProps {
  title: string;
  icon: React.ElementType;
  answers: FormattedAnswer[];
  isEditing: boolean;
  onEdit: (questionId: string, value: string) => void;
  onVisibilityChange: (questionId: string, isVisible: boolean) => void;
  isCompleted: boolean;
  className?: string;
}
--- End of Content for questionnaire.ts ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\MatchSuggestionsContainer.tsx
--------------------------------------------------------------------------------
Content:
// Full path: src/app/components/suggestions/MatchSuggestionsContainer.tsx

"use client";

import React, { useState, useEffect, useCallback } from "react"; // Import useCallback
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Clock, History, AlertCircle, RefreshCw, Bell } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";

import SuggestionsList from "./list/SuggestionsList";

// Interfaces remain the same
interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface StatusHistoryItem {
  id: string;
  suggestionId: string;
  status: string;
  notes?: string | null;
  createdAt: Date | string;
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: StatusHistoryItem[];
}

interface MatchSuggestionsContainerProps {
  userId: string;
  className?: string;
}

const MatchSuggestionsContainer: React.FC<MatchSuggestionsContainerProps> = ({
  userId,
  className,
}) => {
  // States
  const [activeSuggestions, setActiveSuggestions] = useState<
    ExtendedMatchSuggestion[]
  >([]);
  const [historySuggestions, setHistorySuggestions] = useState<
    ExtendedMatchSuggestion[]
  >([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("active");
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [hasNewSuggestions, setHasNewSuggestions] = useState(false);

  // Calculate counts
  const pendingCount = activeSuggestions.filter(
    (s) =>
      s.status === "PENDING_FIRST_PARTY" || s.status === "PENDING_SECOND_PARTY"
  ).length;

  // Fetch suggestions function - wrapped in useCallback
  // Added `activeSuggestions.length` to dependency array because it's used inside
  // for the `hasNewSuggestions` check.
  const fetchSuggestions = useCallback(
    async (showLoadingState = true) => {
      try {
        if (showLoadingState) {
          setIsLoading(true);
        } else {
          setIsRefreshing(true);
        }
        setError(null);

        // Assume API endpoints implicitly use authenticated user context if userId is not passed
        // If userId *was* needed in the URL, it should be a dependency of useCallback
        const [activeResponse, historyResponse] = await Promise.all([
          fetch(`/api/suggestions/active`),
          fetch(`/api/suggestions/history`),
        ]);

        if (!activeResponse.ok || !historyResponse.ok) {
          const activeError = !activeResponse.ok
            ? await activeResponse.text()
            : "";
          const historyError = !historyResponse.ok
            ? await historyResponse.text()
            : "";
          console.error("Fetch errors:", { activeError, historyError });
          throw new Error(
            `Failed to fetch suggestions (${activeResponse.status}/${historyResponse.status})`
          );
        }

        const activeData = await activeResponse.json();
        const historyData = await historyResponse.json();

        // Check if there are new suggestions compared to previous state length
        // Use functional state update for `setHasNewSuggestions` if it depended on previous state
        // but direct comparison with `activeSuggestions.length` is okay here.
        if (
          !showLoadingState &&
          activeData.suggestions.length > activeSuggestions.length
        ) {
          setHasNewSuggestions(true);
          toast.success("התקבלו הצעות שידוך חדשות!");
        }

        setActiveSuggestions(activeData.suggestions);
        setHistorySuggestions(historyData.suggestions);
      } catch (error) {
        console.error("Error loading suggestions:", error);
        setError(
          `אירעה שגיאה בטעינת ההצעות: ${
            error instanceof Error ? error.message : "שגיאה לא ידועה"
          }`
        );
      } finally {
        setIsLoading(false);
        setIsRefreshing(false);
      }
      // We include `activeSuggestions.length` because it's read inside the function for comparison.
      // While `activeSuggestions` state itself is modified, `useCallback` depends on the value *at the time of definition*.
      // A safer alternative might be to pass the current length as an argument if complex dependencies arise,
      // but for this specific comparison, depending on the length should be acceptable.
      // If the API endpoints depended on `userId`, add `userId` here too.
    },
    [activeSuggestions.length]
  ); // Dependency array for useCallback

  // Initial load and periodic refresh
  useEffect(() => {
    fetchSuggestions(); // Initial fetch

    const intervalId = setInterval(() => {
      fetchSuggestions(false); // Periodic refresh without full loading state
    }, 5 * 60 * 1000); // Refresh every 5 minutes

    return () => clearInterval(intervalId); // Cleanup interval on unmount
  }, [userId, fetchSuggestions]); // Added fetchSuggestions to dependency array

  // Clear new suggestions notification when changing to active tab
  useEffect(() => {
    if (activeTab === "active") {
      setHasNewSuggestions(false);
    }
  }, [activeTab]);

  // Handle suggestion status change - wrapped in useCallback
  const handleStatusChange = useCallback(
    async (suggestionId: string, newStatus: string, notes?: string) => {
      try {
        const response = await fetch(
          `/api/suggestions/${suggestionId}/status`,
          {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ status: newStatus, notes }),
          }
        );

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(
            errorData.error || "Failed to update suggestion status"
          );
        }

        // Refresh suggestions to get the updated state
        // Pass false to avoid showing the main loading spinner
        await fetchSuggestions(false);

        const statusMessages: Record<string, string> = {
          FIRST_PARTY_APPROVED: "אישרת את ההצעה בהצלחה",
          SECOND_PARTY_APPROVED: "אישרת את ההצעה בהצלחה",
          FIRST_PARTY_DECLINED: "דחית את ההצעה בהצלחה",
          SECOND_PARTY_DECLINED: "דחית את ההצעה בהצלחה",
        };

        toast.success(statusMessages[newStatus] || "הסטטוס עודכן בהצלחה");
      } catch (error) {
        console.error("Error updating suggestion status:", error);
        toast.error(
          `אירעה שגיאה בעדכון הסטטוס: ${
            error instanceof Error ? error.message : "שגיאה לא ידועה"
          }`
        );
        // Re-throw the error if the calling component needs to handle it (e.g., disable a button)
        // throw error; // Uncomment if needed
      }
    },
    [fetchSuggestions]
  ); // Depends on the memoized fetchSuggestions

  // Handle manual refresh - wrapped in useCallback
  const handleRefresh = useCallback(async () => {
    // Pass false to indicate it's a refresh, not initial load
    await fetchSuggestions(false);
    toast.success("הנתונים עודכנו בהצלחה");
  }, [fetchSuggestions]); // Depends on the memoized fetchSuggestions

  return (
    <Card className={`shadow-md ${className}`}>
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          {/* Refresh Button on the left (assuming LTR context despite RTL text for UI layout) */}
          <Button
            variant="ghost"
            size="icon"
            onClick={handleRefresh}
            disabled={isRefreshing || isLoading} // Disable if initial loading or refreshing
            aria-label="רענן הצעות" // Accessibility
          >
            <RefreshCw
              className={`h-4 w-4 ${isRefreshing ? "animate-spin" : ""}`}
            />
          </Button>

          <CardTitle className="text-xl text-right flex-grow mr-2">
            הצעות שידוך
          </CardTitle>
        </div>
      </CardHeader>

      <CardContent className="pb-6">
        <Tabs value={activeTab} onValueChange={setActiveTab} dir="rtl">
          {" "}
          {/* Added dir="rtl" */}
          <div className="flex flex-col sm:flex-row items-center justify-between mb-6 gap-4">
            {" "}
            {/* Responsive layout */}
            <TabsList className="relative">
              <TabsTrigger
                value="active"
                className="flex items-center gap-2 px-3"
              >
                {" "}
                {/* Added padding */}
                <Clock className="w-4 h-4 ml-1" /> {/* Icon spacing */}
                <span>פעילות</span> {/* Shortened label */}
                {activeSuggestions.length > 0 && (
                  <Badge className="mr-2 px-1.5 py-0.5 rounded-full bg-primary text-primary-foreground text-xs font-normal">
                    {" "}
                    {/* Adjusted badge */}
                    {activeSuggestions.length}
                  </Badge>
                )}
                {/* Keep indicator relative to trigger */}
                {hasNewSuggestions && (
                  <span className="absolute top-0 right-0 -mt-1 -mr-1 flex h-3 w-3">
                    <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
                    <span className="relative inline-flex rounded-full h-3 w-3 bg-red-500"></span>
                  </span>
                )}
              </TabsTrigger>

              <TabsTrigger
                value="history"
                className="flex items-center gap-2 px-3"
              >
                {" "}
                {/* Added padding */}
                <History className="w-4 h-4 ml-1" /> {/* Icon spacing */}
                <span>היסטוריה</span>
                {historySuggestions.length > 0 && (
                  <Badge
                    variant="outline"
                    className="mr-2 px-1.5 py-0.5 rounded-full text-xs font-normal"
                  >
                    {" "}
                    {/* Adjusted badge */}
                    {historySuggestions.length}
                  </Badge>
                )}
              </TabsTrigger>

              {pendingCount > 0 && (
                <TabsTrigger
                  value="pending"
                  className="flex items-center gap-2 px-3"
                >
                  {" "}
                  {/* Added padding */}
                  <Bell className="w-4 h-4 ml-1" /> {/* Icon spacing */}
                  <span>ממתינות</span>
                  <Badge className="mr-2 px-1.5 py-0.5 rounded-full bg-yellow-500 text-white text-xs font-normal">
                    {" "}
                    {/* Adjusted badge */}
                    {pendingCount}
                  </Badge>
                </TabsTrigger>
              )}
            </TabsList>
            {/* View Mode Toggle on the left */}
            <div className="flex">
              <Button
                variant="outline"
                size="sm"
                className="text-xs px-3" // Adjusted padding
                onClick={() =>
                  setViewMode(viewMode === "grid" ? "list" : "grid")
                }
              >
                {viewMode === "grid" ? "תצוגת רשימה" : "תצוגת קלפים"}{" "}
                {/* Adjusted text */}
              </Button>
            </div>
          </div>
          {error && (
            <Alert variant="destructive" className="mb-6" dir="rtl">
              {" "}
              {/* Added dir="rtl" */}
              <AlertCircle className="h-4 w-4 ml-2" /> {/* Icon spacing */}
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          {/* Pass memoized handlers to child */}
          <TabsContent value="active">
            <SuggestionsList
              suggestions={activeSuggestions}
              userId={userId}
              viewMode={viewMode}
              isLoading={isLoading}
              onStatusChange={handleStatusChange}
              onRefresh={handleRefresh} // Pass handleRefresh for consistency if needed inside list items
            />
          </TabsContent>
          <TabsContent value="history">
            <SuggestionsList
              suggestions={historySuggestions}
              userId={userId}
              viewMode={viewMode}
              isLoading={isLoading}
              isHistory={true}
              onRefresh={handleRefresh} // Pass handleRefresh for consistency if needed inside list items
              // No status change for history items
            />
          </TabsContent>
          <TabsContent value="pending">
            <SuggestionsList
              suggestions={activeSuggestions.filter(
                (s) =>
                  s.status === "PENDING_FIRST_PARTY" ||
                  s.status === "PENDING_SECOND_PARTY"
              )}
              userId={userId}
              viewMode={viewMode}
              isLoading={isLoading}
              onStatusChange={handleStatusChange}
              onRefresh={handleRefresh} // Pass handleRefresh for consistency if needed inside list items
            />
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
};

export default MatchSuggestionsContainer;
--- End of Content for MatchSuggestionsContainer.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\cards
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\cards\MinimalSuggestionCard.tsx
--------------------------------------------------------------------------------
Content:
// Full path: src/app/components/suggestions/cards/MinimalSuggestionCard.tsx

import React from "react";
import { Card, CardContent, CardFooter } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  User,
  MapPin,
  Briefcase,
  Clock,
  UserCircle,
  Eye,
  CheckCircle,
  XCircle,
  MessageCircle,
  Heart,
  BookOpen,
  Scroll,
  Calendar,
  AlertTriangle,
} from "lucide-react";
import Image from "next/image";
import { format, formatDistanceToNow, isAfter, subDays } from "date-fns";
import { he } from "date-fns/locale";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";
import { cn } from "@/lib/utils";

interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
}

interface MinimalSuggestionCardProps {
  suggestion: ExtendedMatchSuggestion;
  userId: string;
  onClick: (suggestion: ExtendedMatchSuggestion) => void;
  onQuickAction?: (suggestion: ExtendedMatchSuggestion) => void;
  onApprove?: (suggestion: ExtendedMatchSuggestion) => void;
  onInquiry?: (suggestion: ExtendedMatchSuggestion) => void;
  onDecline?: (suggestion: ExtendedMatchSuggestion) => void;
  className?: string;
  isHistory?: boolean;
}

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const getStatusInfo = (status: string) => {
  switch (status) {
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לתשובתך",
        className: "bg-yellow-100 text-yellow-800 border-yellow-200",
        icon: <Clock className="w-3 h-3 ml-1" />,
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לתשובת הצד השני",
        className: "bg-blue-100 text-blue-800 border-blue-200",
        icon: <Clock className="w-3 h-3 ml-1" />,
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "אישרת את ההצעה",
        className: "bg-green-100 text-green-800 border-green-200",
        icon: <CheckCircle className="w-3 h-3 ml-1" />,
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "הצד השני אישר את ההצעה",
        className: "bg-green-100 text-green-800 border-green-200",
        icon: <CheckCircle className="w-3 h-3 ml-1" />,
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        className: "bg-purple-100 text-purple-800 border-purple-200",
        icon: <MessageCircle className="w-3 h-3 ml-1" />,
      };
    case "FIRST_PARTY_DECLINED":
    case "SECOND_PARTY_DECLINED":
      return {
        label: "ההצעה נדחתה",
        className: "bg-red-100 text-red-800 border-red-200",
        icon: <XCircle className="w-3 h-3 ml-1" />,
      };
    case "CANCELLED":
      return {
        label: "ההצעה בוטלה",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: <XCircle className="w-3 h-3 ml-1" />,
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        className: "bg-pink-100 text-pink-800 border-pink-200",
        icon: <Heart className="w-3 h-3 ml-1" />,
      };
    case "ENGAGED":
      return {
        label: "אירוסין",
        className: "bg-indigo-100 text-indigo-800 border-indigo-200",
        icon: <Heart className="w-3 h-3 ml-1" fill="currentColor" />,
      };
    case "MARRIED":
      return {
        label: "נישואין",
        className: "bg-indigo-100 text-indigo-800 border-indigo-200",
        icon: <Heart className="w-3 h-3 ml-1" fill="currentColor" />,
      };
    default:
      return {
        label: "בטיפול",
        className: "bg-gray-100 text-gray-800 border-gray-200",
        icon: <Clock className="w-3 h-3 ml-1" />,
      };
  }
};

const isDeadlineApproaching = (deadline: Date): boolean => {
  return (
    isAfter(deadline, new Date()) && isAfter(subDays(deadline, 2), new Date())
  );
};

const isDeadlineUrgent = (deadline: Date): boolean => {
  return (
    isAfter(deadline, new Date()) && !isAfter(subDays(deadline, 2), new Date())
  );
};

const MinimalSuggestionCard: React.FC<MinimalSuggestionCardProps> = ({
  suggestion,
  userId,
  onClick,
  onApprove,
  onInquiry,
  onDecline,
  className,
  isHistory = false,
}) => {
  const targetParty =
    suggestion.firstPartyId === userId
      ? suggestion.secondParty
      : suggestion.firstParty;

  const isFirstParty = suggestion.firstPartyId === userId;

  if (!targetParty || !targetParty.profile) {
    return null;
  }

  const mainImage = targetParty.images?.find((img) => img.isMain);
  const age = targetParty.profile?.birthDate
    ? calculateAge(new Date(targetParty.profile.birthDate))
    : null;
  const statusInfo = getStatusInfo(suggestion.status);

  const hasDeadline = suggestion.decisionDeadline !== null;
  const deadlineClass = hasDeadline
    ? isDeadlineUrgent(new Date(suggestion.decisionDeadline!))
      ? "bg-red-50 border-red-100"
      : isDeadlineApproaching(new Date(suggestion.decisionDeadline!))
      ? "bg-amber-50 border-amber-100"
      : ""
    : "";

  // Extract compatibility reasons from matching reason (if available)
  const getCompatibilityHighlights = () => {
    if (!suggestion.matchingReason) return [];

    // Explicitly define the type of highlights
    const highlights: { icon: React.ReactNode; text: string }[] = [];
    const reason = suggestion.matchingReason.toLowerCase();

    if (reason.includes("ערכים") || reason.includes("value"))
      highlights.push({
        icon: <Scroll className="w-4 h-4" />,
        text: "ערכים משותפים",
      });

    if (reason.includes("השכלה") || reason.includes("education"))
      highlights.push({
        icon: <BookOpen className="w-4 h-4" />,
        text: "רקע השכלתי דומה",
      });

    if (reason.includes("אופי") || reason.includes("personality"))
      highlights.push({
        icon: <User className="w-4 h-4" />,
        text: "התאמה אישיותית",
      });

    if (reason.includes("רמה דתית") || reason.includes("religious"))
      highlights.push({
        icon: <Scroll className="w-4 h-4" />,
        text: "רמה דתית מתאימה",
      });

    return highlights.slice(0, 2); // Limit to 2 highlights
  };

  const compatibilityHighlights = getCompatibilityHighlights();

  return (
    <Card
      className={cn(
        "relative overflow-hidden transition-all hover:shadow-lg",
        deadlineClass,
        className
      )}
      onClick={(e) => {
        if (!(e.target as Element).closest("button")) {
          onClick(suggestion);
        }
      }}
    >
      <div className="relative h-48 bg-gradient-to-b from-blue-50 to-blue-100">
        {mainImage?.url ? (
          <Image
            src={mainImage.url}
            alt={`${targetParty.firstName} ${targetParty.lastName}`}
            fill
            className="object-cover"
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            <User className="w-16 h-16 text-gray-400" />
          </div>
        )}

        <div className="absolute top-3 right-3">
          <Badge className={cn("flex items-center", statusInfo.className)}>
            {statusInfo.icon}
            <span>{statusInfo.label}</span>
          </Badge>
        </div>

        <div className="absolute top-3 left-3">
          <Badge variant="outline" className="bg-white/90 flex items-center">
            <UserCircle className="w-3 h-3 ml-1" />
            {suggestion.matchmaker.firstName} {suggestion.matchmaker.lastName}
          </Badge>
        </div>

        {hasDeadline && (
          <div
            className={cn(
              "absolute bottom-3 right-3 max-w-[70%]",
              isDeadlineUrgent(new Date(suggestion.decisionDeadline!)) &&
                "animate-pulse"
            )}
          >
            <Badge
              variant="outline"
              className={cn(
                "bg-white/90 flex items-center",
                isDeadlineUrgent(new Date(suggestion.decisionDeadline!)) &&
                  "bg-red-50 text-red-700"
              )}
            >
              {isDeadlineUrgent(new Date(suggestion.decisionDeadline!)) ? (
                <AlertTriangle className="w-3 h-3 ml-1" />
              ) : (
                <Calendar className="w-3 h-3 ml-1" />
              )}
              <span className="text-xs truncate">
                נדרשת החלטה עד{" "}
                {format(new Date(suggestion.decisionDeadline!), "dd/MM/yyyy", {
                  locale: he,
                })}
              </span>
            </Badge>
          </div>
        )}
      </div>

      <CardContent className="p-4">
        <h3 className="text-lg font-semibold mb-2 text-right flex justify-between items-center">
          <span>
            {targetParty.firstName} {targetParty.lastName}
          </span>
          {age && (
            <Badge variant="outline" className="text-xs font-normal">
              גיל {age}
            </Badge>
          )}
        </h3>

        <div className="space-y-3 text-gray-600 text-sm">
          <div className="grid grid-cols-2 gap-2">
            {targetParty.profile.city && (
              <div className="flex items-center justify-end gap-2">
                <span>{targetParty.profile.city}</span>
                <MapPin className="w-4 h-4" />
              </div>
            )}

            {targetParty.profile.occupation && (
              <div className="flex items-center justify-end gap-2">
                <span>{targetParty.profile.occupation}</span>
                <Briefcase className="w-4 h-4" />
              </div>
            )}

            {targetParty.profile.religiousLevel && (
              <div className="flex items-center justify-end gap-2">
                <span>{targetParty.profile.religiousLevel}</span>
                <Scroll className="w-4 h-4" />
              </div>
            )}

            {targetParty.profile.education && (
              <div className="flex items-center justify-end gap-2">
                <span className="truncate">
                  {targetParty.profile.education}
                </span>
                <BookOpen className="w-4 h-4 flex-shrink-0" />
              </div>
            )}
          </div>

          {compatibilityHighlights.length > 0 && (
            <div className="border-t border-gray-100 pt-2">
              <p className="text-xs mb-1 text-right text-gray-500">
                התאמה מיוחדת:
              </p>
              <div className="flex flex-wrap justify-end gap-2">
                {compatibilityHighlights.map((highlight, index) => (
                  <Badge
                    key={index}
                    variant="outline"
                    className="flex items-center gap-1 bg-green-50"
                  >
                    {highlight.icon}
                    <span className="text-xs">{highlight.text}</span>
                  </Badge>
                ))}
              </div>
            </div>
          )}

          <div className="flex items-center justify-end gap-2 text-xs text-gray-400">
            <span>
              {`הוצע ${formatDistanceToNow(new Date(suggestion.createdAt), {
                addSuffix: true,
                locale: he,
              })}`}
            </span>
            <Clock className="w-3 h-3" />
          </div>
        </div>
      </CardContent>

      {!isHistory && (
        <CardFooter className="grid grid-cols-2 gap-2 px-4 pb-4 pt-0 border-t border-gray-100">
          <Button
            size="sm"
            variant="default"
            className="w-full"
            onClick={(e) => {
              e.stopPropagation();
              onClick(suggestion);
            }}
          >
            <Eye className="w-4 h-4 ml-2" />
            פרטים מלאים
          </Button>

          {suggestion.status === "PENDING_FIRST_PARTY" && isFirstParty && (
            <Button
              size="sm"
              variant="default"
              className="w-full bg-green-600 hover:bg-green-700"
              onClick={(e) => {
                e.stopPropagation();
                onApprove?.(suggestion);
              }}
            >
              <CheckCircle className="w-4 h-4 ml-2" />
              אישור הצעה
            </Button>
          )}

          {suggestion.status === "PENDING_SECOND_PARTY" && !isFirstParty && (
            <Button
              size="sm"
              variant="default"
              className="w-full bg-green-600 hover:bg-green-700"
              onClick={(e) => {
                e.stopPropagation();
                onApprove?.(suggestion);
              }}
            >
              <CheckCircle className="w-4 h-4 ml-2" />
              אישור הצעה
            </Button>
          )}

          {((suggestion.status === "PENDING_FIRST_PARTY" && isFirstParty) ||
            (suggestion.status === "PENDING_SECOND_PARTY" &&
              !isFirstParty)) && (
            <Button
              size="sm"
              variant="outline"
              className="w-full text-red-600 hover:text-red-700 hover:bg-red-50"
              onClick={(e) => {
                e.stopPropagation();
                onDecline?.(suggestion);
              }}
            >
              <XCircle className="w-4 h-4 ml-2" />
              דחיית הצעה
            </Button>
          )}

          <Button
            size="sm"
            variant="outline"
            className="w-full"
            onClick={(e) => {
              e.stopPropagation();
              onInquiry?.(suggestion);
            }}
          >
            <MessageCircle className="w-4 h-4 ml-2" />
            שאלה לשדכן
          </Button>
        </CardFooter>
      )}
    </Card>
  );
};

export default MinimalSuggestionCard;
--- End of Content for MinimalSuggestionCard.tsx ---

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\cards\SuggestionQuickView.tsx
--------------------------------------------------------------------------------
Content:
import React from "react";
import { Button } from "@/components/ui/button";
import {
  Heart,
  User,
  Clock,
  Eye,
  Scroll,
  GraduationCap,
  Briefcase,
  MapPin,
  MessageCircle,
  CheckCircle,
  XCircle,
} from "lucide-react";
import type { MatchSuggestion } from "@prisma/client";
import type { UserProfile, UserImage } from "@/types/next-auth";

interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
}

interface SuggestionQuickViewProps {
  suggestion: ExtendedMatchSuggestion;
  userId?: string;
  onAction: (action: "approve" | "reject" | "ask" | "view") => void;
}

const SuggestionQuickView: React.FC<SuggestionQuickViewProps> = ({
  suggestion,
  userId,
  onAction,
}) => {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const profile = userId
    ? suggestion.firstPartyId === userId
      ? suggestion.secondParty.profile
      : suggestion.firstParty.profile
    : suggestion.secondParty.profile;

  return (
    <div
      className="bg-white/95 backdrop-blur-sm p-4 rounded-lg shadow-lg flex flex-col"
      onClick={handleClick}
    >
      <div className="flex-1 space-y-4 text-right overflow-y-auto max-h-96">
        <div className="grid grid-cols-2 gap-3">
          {profile.height && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.height} ס״מ</span>
              <User className="w-4 h-4" />
            </div>
          )}

          {profile.maritalStatus && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.maritalStatus}</span>
              <Heart className="w-4 h-4" />
            </div>
          )}

          {profile.religiousLevel && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.religiousLevel}</span>
              <Scroll className="w-4 h-4" />
            </div>
          )}

          {profile.education && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.education}</span>
              <GraduationCap className="w-4 h-4" />
            </div>
          )}
        </div>

        {profile.about && (
          <div className="border-t border-gray-100 pt-3">
            <h4 className="text-sm font-medium mb-1">אודות:</h4>
            <p className="text-sm text-gray-600 leading-relaxed line-clamp-3">
              {profile.about}
            </p>
          </div>
        )}

        {suggestion.matchingReason && (
          <div className="border-t border-gray-100 pt-3">
            <h4 className="text-sm font-medium mb-1">סיבת ההצעה:</h4>
            <p className="text-sm text-gray-600 leading-relaxed line-clamp-3">
              {suggestion.matchingReason}
            </p>
          </div>
        )}

        <div className="border-t border-gray-100 pt-3 space-y-2">
          {profile.city && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.city}</span>
              <MapPin className="w-4 h-4" />
            </div>
          )}

          {profile.occupation && (
            <div className="flex items-center justify-end gap-2 text-sm text-gray-600">
              <span>{profile.occupation}</span>
              <Briefcase className="w-4 h-4" />
            </div>
          )}
        </div>

        {suggestion.decisionDeadline && (
          <div className="border-t border-gray-100 pt-3">
            <div className="flex items-center justify-end gap-2 text-sm text-yellow-600">
              <span>
                נדרשת תשובה עד{" "}
                {new Date(suggestion.decisionDeadline).toLocaleDateString(
                  "he-IL"
                )}
              </span>
              <Clock className="w-4 h-4" />
            </div>
          </div>
        )}
      </div>

      <div className="grid grid-cols-2 gap-2 mt-4 pt-3 border-t border-gray-100">
        <Button
          variant="default"
          className="w-full"
          onClick={() => onAction("view")}
        >
          <Eye className="w-4 h-4 ml-2" />
          צפייה בפרופיל
        </Button>

        <Button
          variant="default"
          className="w-full bg-green-600 hover:bg-green-700"
          onClick={() => onAction("approve")}
        >
          <CheckCircle className="w-4 h-4 ml-2" />
          אישור הצעה
        </Button>

        <Button
          variant="outline"
          className="w-full text-red-600 hover:text-red-700 hover:bg-red-50"
          onClick={() => onAction("reject")}
        >
          <XCircle className="w-4 h-4 ml-2" />
          דחיית הצעה
        </Button>

        <Button
          variant="outline"
          className="w-full"
          onClick={() => onAction("ask")}
        >
          <MessageCircle className="w-4 h-4 ml-2" />
          שאלה לשדכן
        </Button>
      </div>
    </div>
  );
};

export default SuggestionQuickView;
--- End of Content for SuggestionQuickView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\compatibility
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\compatibility\MatchCompatibilityView.tsx
--------------------------------------------------------------------------------
Content:
// Full path: src/app/components/suggestions/compatibility/MatchCompatibilityView.tsx

import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import {
  Heart,
  User,
  Scroll,
  GraduationCap,
  MapPin,
  BookOpen,
  Home,
  Languages,
  Star,
  CheckCircle,
  XCircle,
} from "lucide-react";
import { cn } from "@/lib/utils";

interface ProfileData {
  birthDate?: Date | string | null;
  age?: number;
  height?: number | null;
  preferredHeightMin?: number | null;
  preferredHeightMax?: number | null;
  city?: string | null;
  preferredLocations?: string[] | null;
  religiousLevel?: string | null;
  preferredReligiousLevels?: string[] | null;
  origin?: string | null;
  education?: string | null;
  preferredEducation?: string[] | null;
  occupation?: string | null;
  preferredOccupations?: string[] | null;
  preferredAgeMin?: number | null;
  preferredAgeMax?: number | null;
  nativeLanguage?: string | null;
  additionalLanguages?: string[] | null;
}

interface Party {
  firstName: string;
  profile: ProfileData;
}

interface MatchCompatibilityProps {
  firstParty: Party;
  secondParty: Party;
  matchingReason?: string | null;
  className?: string;
}

interface CompatibilityItem {
  criterion: string;
  icon: React.ReactNode;
  compatible: boolean;
  reason: string;
  first?: string | number | null;
  second?: string | number | null;
}


const calculateAge = (birthDate?: Date | string | null): number | null => {
  if (!birthDate) return null;

  try {
    const today = new Date();
    const birth = new Date(birthDate);
    // Basic validation if Date constructor returns invalid date
    if (isNaN(birth.getTime())) return null;

    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();

    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
      age--;
    }
    // Ensure age is not negative if birthDate is in the future
    return age >= 0 ? age : null;
  } catch (error) {
    console.error("Error calculating age:", error);
    return null;
  }
};

const MatchCompatibilityView: React.FC<MatchCompatibilityProps> = ({
  firstParty,
  secondParty,
  matchingReason,
  className,
}) => {
  // Calculate ages if not provided
  const firstPartyAge =
    firstParty.profile.age ?? calculateAge(firstParty.profile.birthDate);
  const secondPartyAge =
    secondParty.profile.age ?? calculateAge(secondParty.profile.birthDate);

  // Helper to check if a value is within the preferred range (handles null/undefined)
  const isWithinRange = (value: number | null | undefined, min: number | null | undefined, max: number | null | undefined): boolean => {
    if (value == null) return false; // Cannot check compatibility if the value itself is missing
    const minOk = min == null || value >= min;
    const maxOk = max == null || value <= max;
    return minOk && maxOk;
  }

  // Helper to check if a value exists in preferred list (handles null/undefined/empty list)
  const isInPreferredList = (value: string | null | undefined, preferredList: string[] | null | undefined): boolean => {
    if (value == null) return false; // Cannot check compatibility if the value itself is missing
    // If no preferences are set (list is null, undefined, or empty), consider it compatible
    if (preferredList == null || preferredList.length === 0) {
      return true;
    }
    return preferredList.includes(value);
  }


  // Calculate compatibility score
  const calculateCompatibilityItems = (): CompatibilityItem[] => {
    const items: CompatibilityItem[] = [];

    // Age compatibility
    if (firstPartyAge != null && secondPartyAge != null) {
      const firstAgePreferenceMatch = isWithinRange(
        secondPartyAge,
        firstParty.profile.preferredAgeMin,
        firstParty.profile.preferredAgeMax
      );

      const secondAgePreferenceMatch = isWithinRange(
        firstPartyAge,
        secondParty.profile.preferredAgeMin,
        secondParty.profile.preferredAgeMax
      );

      const compatible = firstAgePreferenceMatch && secondAgePreferenceMatch;
      items.push({
        criterion: "גיל",
        icon: <User className="h-5 w-5" />,
        compatible: compatible,
        reason: compatible
          ? "התאמה הדדית בציפיות הגיל"
          : "אי התאמה בציפיות הגיל",
        first: firstPartyAge,
        second: secondPartyAge,
      });
    }

    // Height compatibility
    const firstHeight = firstParty.profile.height;
    const secondHeight = secondParty.profile.height;
    // Only check if both heights are present
    if (firstHeight != null && secondHeight != null) {
      const firstHeightPreferenceMatch = isWithinRange(
        secondHeight,
        firstParty.profile.preferredHeightMin,
        firstParty.profile.preferredHeightMax
      );

      const secondHeightPreferenceMatch = isWithinRange(
        firstHeight,
        secondParty.profile.preferredHeightMin,
        secondParty.profile.preferredHeightMax
      );

      const compatible = firstHeightPreferenceMatch && secondHeightPreferenceMatch;
      items.push({
        criterion: "גובה",
        icon: <User className="h-5 w-5" />, // Consider a different icon? Maybe ArrowsUpDown?
        compatible: compatible,
        reason: compatible
          ? "התאמה הדדית בציפיות הגובה"
          : "אי התאמה בציפיות הגובה",
        first: `${firstHeight} ס"מ`,
        second: `${secondHeight} ס"מ`,
      });
    }

    // Location compatibility
    const firstCity = firstParty.profile.city;
    const secondCity = secondParty.profile.city;
    // Only check if both cities are present
    if (firstCity != null && secondCity != null) {
        const firstLocationPreferenceMatch = isInPreferredList(
            secondCity,
            firstParty.profile.preferredLocations
        );

        const secondLocationPreferenceMatch = isInPreferredList(
            firstCity,
            secondParty.profile.preferredLocations
        );

        const compatible = firstLocationPreferenceMatch && secondLocationPreferenceMatch;
        items.push({
            criterion: "מקום מגורים",
            icon: <MapPin className="h-5 w-5" />,
            compatible: compatible,
            reason: compatible
              ? "התאמה הדדית בהעדפות מיקום"
              : "אי התאמה בהעדפות מיקום",
            first: firstCity,
            second: secondCity,
        });
    }


    // Religious level compatibility
    const firstReligious = firstParty.profile.religiousLevel;
    const secondReligious = secondParty.profile.religiousLevel;
    // Only check if both levels are present
    if (firstReligious != null && secondReligious != null) {
      const firstReligiousPreferenceMatch = isInPreferredList(
        secondReligious,
        firstParty.profile.preferredReligiousLevels
      );

      const secondReligiousPreferenceMatch = isInPreferredList(
        firstReligious,
        secondParty.profile.preferredReligiousLevels
      );

      const compatible = firstReligiousPreferenceMatch && secondReligiousPreferenceMatch;
      items.push({
        criterion: "רמה דתית",
        icon: <Scroll className="h-5 w-5" />,
        compatible: compatible,
        reason: compatible
          ? "התאמה הדדית בהעדפות רמה דתית"
          : "אי התאמה בהעדפות רמה דתית",
        first: firstReligious,
        second: secondReligious,
      });
    }

    // Origin compatibility (informational, always 'compatible' in this logic)
    const firstOrigin = firstParty.profile.origin;
    const secondOrigin = secondParty.profile.origin;
    if (firstOrigin != null && secondOrigin != null) {
      const sameOrigin = firstOrigin === secondOrigin;
      items.push({
        criterion: "מוצא",
        icon: <Home className="h-5 w-5" />,
        compatible: true, // Not marking as incompatible, just informational based on sameness
        reason: sameOrigin ? "מוצא זהה" : "מוצא שונה",
        first: firstOrigin,
        second: secondOrigin,
      });
    }

    // Education compatibility
    const firstEdu = firstParty.profile.education;
    const secondEdu = secondParty.profile.education;
    // Only check if both education levels are present
    if (firstEdu != null && secondEdu != null) {
      const firstEducationPreferenceMatch = isInPreferredList(
        secondEdu,
        firstParty.profile.preferredEducation
      );

      const secondEducationPreferenceMatch = isInPreferredList(
        firstEdu,
        secondParty.profile.preferredEducation
      );

      const compatible = firstEducationPreferenceMatch && secondEducationPreferenceMatch;
      items.push({
        criterion: "השכלה",
        icon: <GraduationCap className="h-5 w-5" />,
        compatible: compatible,
        reason: compatible
          ? "התאמה הדדית בהעדפות השכלה"
          : "אי התאמה בהעדפות השכלה",
        first: firstEdu,
        second: secondEdu,
      });
    }

    // Occupation compatibility
    const firstOcc = firstParty.profile.occupation;
    const secondOcc = secondParty.profile.occupation;
    // Only check if both occupations are present
    if (firstOcc != null && secondOcc != null) {
      const firstOccupationPreferenceMatch = isInPreferredList(
        secondOcc,
        firstParty.profile.preferredOccupations
      );

      const secondOccupationPreferenceMatch = isInPreferredList(
        firstOcc,
        secondParty.profile.preferredOccupations
      );

      const compatible = firstOccupationPreferenceMatch && secondOccupationPreferenceMatch;
      items.push({
        criterion: "תעסוקה",
        icon: <BookOpen className="h-5 w-5" />,
        compatible: compatible,
        reason: compatible
          ? "התאמה הדדית בהעדפות תעסוקה"
          : "אי התאמה בהעדפות תעסוקה",
        first: firstOcc,
        second: secondOcc,
      });
    }

    // Language compatibility
    const firstLang = firstParty.profile.nativeLanguage;
    const secondLang = secondParty.profile.nativeLanguage;
    // Only check if both native languages are present
    if (firstLang != null && secondLang != null) {
        // Check if native languages match OR if one speaks the other's native language as additional
        const nativeMatch = firstLang === secondLang;
        const firstSpeaksSecondNative = firstParty.profile.additionalLanguages?.includes(secondLang) ?? false;
        const secondSpeaksFirstNative = secondParty.profile.additionalLanguages?.includes(firstLang) ?? false;

        const sharedLanguage = nativeMatch || firstSpeaksSecondNative || secondSpeaksFirstNative;

        items.push({
            criterion: "שפה",
            icon: <Languages className="h-5 w-5" />,
            compatible: sharedLanguage, // This is inherently boolean
            reason: sharedLanguage ? "יש שפה משותפת" : "אין שפה משותפת מוכרת",
            first: firstLang,
            second: secondLang,
        });
    }


    return items;
  };

  const compatibilityItems = calculateCompatibilityItems();
  const compatibleCount = compatibilityItems.filter(
    (item) => item.compatible
  ).length;
  // Avoid division by zero if no items could be calculated
  const compatibilityScore =
    compatibilityItems.length > 0
      ? Math.round((compatibleCount / compatibilityItems.length) * 100)
      : 0;

  return (
    <Card className={cn("shadow-sm", className)}>
      <CardHeader className="pb-2">
        <CardTitle className="text-lg flex items-center gap-2">
          <Heart className="h-5 w-5 text-pink-500" />
          ניתוח התאמה
        </CardTitle>
      </CardHeader>

      <CardContent>
        <div className="mb-6">
          <div className="flex justify-between mb-2 text-sm">
            <span className="font-medium">{compatibilityScore}% התאמה</span>
            <div className="flex items-center gap-1">
              <span className="text-xs text-gray-500">
                {compatibleCount} מתוך {compatibilityItems.length} קריטריונים
                תואמים
              </span>
            </div>
          </div>
          <Progress value={compatibilityScore} className="h-2" />
        </div>

        {compatibilityItems.length > 0 ? (
          <div className="grid gap-4">
            {compatibilityItems.map((item, index) => (
              <div key={index} className="border-b pb-3 last:border-b-0 last:pb-0"> {/* Improved styling for last item */}
                <div className="flex justify-between items-start mb-2 gap-2"> {/* Added gap */}
                  <div className="flex items-center gap-1 flex-shrink-0"> {/* Prevent shrinking */}
                    {item.compatible ? (
                      <CheckCircle className="h-4 w-4 text-green-500" />
                    ) : (
                      <XCircle className="h-4 w-4 text-red-500" />
                    )}
                    <Badge variant="outline" className="gap-1 text-xs sm:text-sm whitespace-nowrap"> {/* Adjusted text size and nowrap */}
                      {item.icon}
                      <span>{item.criterion}</span>
                    </Badge>
                  </div>
                  <div className="text-sm text-right flex-grow"> {/* Allow reason to take space */}
                    <p
                      className={cn(
                        "font-medium", // Make reason slightly bolder
                        item.compatible ? "text-green-600" : "text-red-600"
                      )}
                    >
                      {item.reason}
                    </p>
                  </div>
                </div>

                {/* Show details only if they exist */}
                {(item.first != null || item.second != null) && (
                  <div className="grid grid-cols-2 gap-2 text-sm">
                    <div className="text-left truncate"> {/* Added truncate */}
                      <span className="text-gray-500">
                        {firstParty.firstName}:{" "}
                      </span>
                      <span className="font-medium">{item.first ?? "לא צוין"}</span> {/* Handle null/undefined */}
                    </div>
                    <div className="text-right truncate"> {/* Added truncate */}
                      <span className="text-gray-500">
                        {secondParty.firstName}:{" "}
                      </span>
                      <span className="font-medium">{item.second ?? "לא צוין"}</span> {/* Handle null/undefined */}
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        ) : (
            <p className="text-sm text-gray-500 text-center">אין מספיק נתונים לחישוב התאמה.</p>
        )}


        {matchingReason && (
          <div className="mt-6 bg-blue-50 p-4 rounded-lg border border-blue-200"> {/* Added border */}
            <div className="flex items-center gap-2 mb-2">
              <Star className="h-5 w-5 text-blue-500" />
              <h3 className="font-semibold text-blue-800">סיבת ההצעה מהשדכן</h3> {/* Enhanced styling */}
            </div>
            <p className="text-sm text-gray-800 text-right">{matchingReason}</p> {/* Adjusted text size/color */}
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default MatchCompatibilityView;
--- End of Content for MatchCompatibilityView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\dialogs
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\dialogs\AskMatchmakerDialog.tsx
--------------------------------------------------------------------------------
Content:
// Full path: src/app/components/suggestions/dialogs/AskMatchmakerDialog.tsx

import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { MessageCircle, Send, AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

interface AskMatchmakerDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (question: string) => Promise<void>;
  matchmakerName?: string;
  suggestionId?: string;
}

export const AskMatchmakerDialog: React.FC<AskMatchmakerDialogProps> = ({
  isOpen,
  onClose,
  onSubmit,
  matchmakerName,
}) => {
  const [question, setQuestion] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedTopic, setSelectedTopic] = useState<string | null>(null);

  const handleSubmit = async () => {
    if (!question.trim()) return;

    try {
      setIsSubmitting(true);
      setError(null);
      await onSubmit(question);
      setQuestion("");
      setSelectedTopic(null);
      onClose();
    } catch (error) {
      console.error("Error submitting question:", error);
      setError("אירעה שגיאה בשליחת השאלה. אנא נסה שוב מאוחר יותר.");
    } finally {
      setIsSubmitting(false);
    }
  };

  const topics = [
    { id: "values", label: "ערכים ואמונות" },
    { id: "family", label: "משפחה ורקע" },
    { id: "career", label: "תעסוקה ולימודים" },
    { id: "personality", label: "אופי ומזג" },
    { id: "future", label: "תוכניות לעתיד" },
    { id: "other", label: "אחר" },
  ];

  const topicQuestions: Record<string, string[]> = {
    values: [
      "האם יש משהו שחשוב לדעת לגבי השקפת העולם שלו/ה?",
      "מה מידת החשיבות שהוא/היא מייחס/ת לנושאים דתיים?",
      "האם יש לו/ה קווים אדומים בנושאי השקפה?",
    ],
    family: [
      "איך ניתן לתאר את המשפחה שלו/ה?",
      "האם יש דברים חשובים לדעת לגבי המשפחה?",
      "מה חשוב לו/ה בנושא בניית משפחה?",
    ],
    career: [
      "מה התוכניות המקצועיות שלו/ה לטווח הארוך?",
      "האם הוא/היא מעוניין/ת בשינוי תעסוקתי?",
      "איך הוא/היא רואה את האיזון בין קריירה ומשפחה?",
    ],
    personality: [
      "איך היית מתאר/ת את האופי שלו/ה?",
      "מה הן התכונות החזקות ביותר שלו/ה?",
      "האם יש משהו שכדאי לדעת לגבי המזג?",
    ],
    future: [
      "מה החלומות שלו/ה לטווח הארוך?",
      "האם יש לו/ה תוכניות לשינוי מקום מגורים?",
      "מה החזון שלו/ה לחיי המשפחה?",
    ],
    other: ["יש לי שאלה ספציפית..."],
  };

  const getInitials = (name?: string) => {
    if (!name) return "שד";

    const parts = name.split(" ");
    if (parts.length === 1) return parts[0].charAt(0);
    return `${parts[0].charAt(0)}${parts[parts.length - 1].charAt(0)}`;
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <MessageCircle className="w-5 h-5" />
            שאלה ל{matchmakerName ? `שדכן ${matchmakerName}` : "שדכן"}
          </DialogTitle>
          <DialogDescription>
            השדכן ישמח לענות על כל שאלה שיש לך לגבי המועמד/ת
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-2">
          <div className="flex items-center gap-2 mb-4">
            <Avatar className="w-10 h-10 bg-primary text-primary-foreground">
              <AvatarFallback>{getInitials(matchmakerName)}</AvatarFallback>
            </Avatar>
            <div className="text-sm">
              <p className="font-medium">{matchmakerName || "השדכן"}</p>
              <p className="text-gray-500">זמין/ה לענות על שאלותיך</p>
            </div>
          </div>

          {error && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <div>
            <Label className="block mb-2 text-right">בחר נושא לשאלה</Label>
            <div className="grid grid-cols-2 gap-2">
              {topics.map((topic) => (
                <Button
                  key={topic.id}
                  type="button"
                  variant={selectedTopic === topic.id ? "default" : "outline"}
                  className="justify-center"
                  onClick={() => setSelectedTopic(topic.id)}
                >
                  {topic.label}
                </Button>
              ))}
            </div>
          </div>

          {selectedTopic && (
            <div className="space-y-2">
              <Label className="block mb-2 text-right">שאלות לדוגמה</Label>
              <div className="space-y-2 max-h-32 overflow-y-auto">
                {topicQuestions[selectedTopic].map((q, index) => (
                  <Button
                    key={index}
                    type="button"
                    variant="ghost"
                    className="w-full justify-end text-right hover:bg-gray-100"
                    onClick={() => setQuestion(q)}
                  >
                    {q}
                  </Button>
                ))}
              </div>
            </div>
          )}

          <div>
            <Label htmlFor="question" className="block mb-2 text-right">
              שאלתך
            </Label>
            <Textarea
              id="question"
              value={question}
              onChange={(e) => setQuestion(e.target.value)}
              placeholder="הזן את שאלתך כאן..."
              className="min-h-[120px] text-right"
            />
          </div>
        </div>

        <DialogFooter className="gap-2">
          <Button
            type="button"
            variant="outline"
            onClick={onClose}
            disabled={isSubmitting}
          >
            ביטול
          </Button>
          <Button
            type="submit"
            onClick={handleSubmit}
            disabled={!question.trim() || isSubmitting}
            className="gap-2"
          >
            <Send className="w-4 h-4" />
            {isSubmitting ? "שולח..." : "שלח שאלה"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default AskMatchmakerDialog;
--- End of Content for AskMatchmakerDialog.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\inquiries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\inquiries\InquiryThreadView.tsx
--------------------------------------------------------------------------------
Content:
import React, { useState, useEffect, useCallback } from "react"; // Import useCallback
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardFooter,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { format } from "date-fns";
import { he } from "date-fns/locale";
import { Send, MessageCircle, Loader2 } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { toast } from "sonner";
import { cn } from "@/lib/utils";

// Interface Inquiry remains the same...
interface Inquiry {
  id: string;
  suggestionId: string;
  fromUserId: string;
  toUserId: string;
  question: string;
  answer: string | null;
  status: "PENDING" | "ANSWERED" | "CLOSED";
  createdAt: string | Date;
  answeredAt: string | Date | null;
  fromUser: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
  toUser: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface InquiryThreadViewProps {
  suggestionId: string;
  userId: string;
  showComposer?: boolean;
  className?: string;
}

const InquiryThreadView: React.FC<InquiryThreadViewProps> = ({
  suggestionId,
  userId,
  showComposer = true,
  className,
}) => {
  const [inquiries, setInquiries] = useState<Inquiry[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [newQuestion, setNewQuestion] = useState("");
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Wrap fetchInquiries in useCallback
  // It depends on suggestionId, so list suggestionId as its dependency.
  const fetchInquiries = useCallback(async () => {
    // Check suggestionId inside useCallback or rely on useEffect condition
    if (!suggestionId) {
      // Optionally clear inquiries or handle appropriately if suggestionId becomes null/undefined
      setInquiries([]);
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(
        `/api/suggestions/${suggestionId}/inquiries`
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({})); // Try to get error details
        console.error("Failed to fetch inquiries:", response.status, errorData);
        throw new Error(`Failed to fetch inquiries (${response.status})`);
      }

      const data = await response.json();
      // Ensure data.inquiries is always an array
      setInquiries(Array.isArray(data.inquiries) ? data.inquiries : []);
    } catch (error) {
      console.error("Error fetching inquiries:", error);
      setError("אירעה שגיאה בטעינת השאלות");
      // Optionally show a toast notification for fetch errors too
      // toast.error("אירעה שגיאה בטעינת השאלות");
    } finally {
      setIsLoading(false);
    }
    // Add suggestionId as a dependency for useCallback
  }, [suggestionId]);

  useEffect(() => {
    // Now the effect depends on the memoized fetchInquiries function.
    // It will run initially and whenever fetchInquiries changes (i.e., when suggestionId changes).
    fetchInquiries();
    // Add the memoized fetchInquiries to the dependency array.
  }, [fetchInquiries]);

  const handleSendQuestion = async () => {
    if (!newQuestion.trim()) return;

    try {
      setIsSending(true);
      setError(null); // Clear previous errors

      const response = await fetch(
        `/api/suggestions/${suggestionId}/inquiries`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ question: newQuestion }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({})); // Try to get error details
        console.error("Failed to send inquiry:", response.status, errorData);
        throw new Error(`Failed to send inquiry (${response.status})`);
      }

      // Refresh the inquiries list by calling the memoized fetch function
      await fetchInquiries();
      setNewQuestion(""); // Clear input only on success
      toast.success("השאלה נשלחה בהצלחה");
    } catch (error) {
      console.error("Error sending inquiry:", error);
      setError("אירעה שגיאה בשליחת השאלה"); // Set error state for potential display
      toast.error("אירעה שגיאה בשליחת השאלה");
    } finally {
      setIsSending(false);
    }
  };

  // getInitials, formatDate, getStatusLabel remain the same...
  const getInitials = (name: string) => {
    const parts = name?.split(" ") || ["?"]; // Handle potential null/undefined name
    if (parts.length === 1) return parts[0].charAt(0).toUpperCase();
    return `${parts[0].charAt(0)}${parts[parts.length - 1].charAt(
      0
    )}`.toUpperCase();
  };

  const formatDate = (date: string | Date | null) => {
    if (!date) return ""; // Handle null date
    try {
      return format(new Date(date), "dd בMMMM yyyy, HH:mm", { locale: he });
    } catch (e) {
      console.error("Error formatting date:", date, e);
      return "תאריך לא תקין"; // Fallback for invalid date
    }
  };

  const getStatusLabel = (status: Inquiry["status"]) => {
    switch (status) {
      case "PENDING":
        return {
          label: "ממתין לתשובה",
          className: "border-yellow-300 bg-yellow-50 text-yellow-700", // Adjusted colors for better contrast/style
        };
      case "ANSWERED":
        return {
          label: "נענה",
          className: "border-green-300 bg-green-50 text-green-700",
        };
      case "CLOSED":
        return {
          label: "סגור",
          className: "border-gray-300 bg-gray-50 text-gray-600",
        };
      default:
        // Handle potential unknown status gracefully
        const statusStr = String(status);
        return {
          label: statusStr,
          className: "border-gray-300 bg-gray-50 text-gray-600",
        };
    }
  };

  // JSX structure remains largely the same
  return (
    <Card className={cn("bg-white shadow-sm flex flex-col", className)}>
      <CardHeader className="pb-3 border-b">
        {" "}
        {/* Added border */}
        <CardTitle className="text-lg flex items-center gap-2 text-gray-800">
          {" "}
          {/* Adjusted text color */}
          <MessageCircle className="w-5 h-5 text-primary" />{" "}
          {/* Use primary color */}
          שאלות לשדכן
        </CardTitle>
      </CardHeader>

      {/* Make content area scrollable, not the whole card */}
      <CardContent className="flex-1 py-4 px-4 space-y-6 overflow-y-auto max-h-[400px]">
        {" "}
        {/* Adjusted padding and added scroll */}
        {isLoading ? (
          <div className="space-y-4 p-4">
            {" "}
            {/* Added padding for skeleton */}
            {Array.from({ length: 2 }).map(
              (
                _,
                i // Reduced skeleton count slightly
              ) => (
                <div key={i} className="flex gap-3">
                  <Skeleton className="h-10 w-10 rounded-full" />
                  <div className="space-y-2 flex-1">
                    <Skeleton className="h-4 w-28" />
                    <Skeleton className="h-10 w-full" /> {/* Adjusted height */}
                  </div>
                </div>
              )
            )}
          </div>
        ) : error ? (
          <div className="text-center text-red-600 py-4 px-4 flex flex-col items-center">
            {" "}
            {/* Adjusted text color */}
            <MessageCircle className="mx-auto h-10 w-10 mb-2 opacity-50 text-red-500" />
            <p className="font-medium">שגיאה</p>
            <p className="text-sm">{error}</p>
            <Button
              variant="outline"
              size="sm"
              onClick={fetchInquiries}
              className="mt-4"
            >
              נסה שוב
            </Button>
          </div>
        ) : inquiries.length === 0 ? (
          <div className="text-center text-gray-500 py-8 flex flex-col items-center">
            <MessageCircle className="mx-auto h-12 w-12 mb-3 opacity-20" />
            <p className="font-medium">אין עדיין שאלות</p>
            {showComposer && (
              <p className="text-sm mt-1 text-gray-400">
                תוכל לשאול את השדכן שאלה כאן למטה.
              </p>
            )}
          </div>
        ) : (
          // Removed max-h and overflow from here, moved to CardContent
          <div className="space-y-6">
            {inquiries.map((inquiry) => {
              const isMyQuestion = inquiry.fromUserId === userId; // User asking the question
              // Determine alignment based on who *asked* the original question
              const alignRight = isMyQuestion; // Align right if the current user asked the question

              const asker = inquiry.fromUser;
              const responder = inquiry.toUser; // Usually the matchmaker
              const statusInfo = getStatusLabel(inquiry.status);

              return (
                <div
                  key={inquiry.id}
                  className={cn(
                    "flex gap-3",
                    alignRight ? "flex-row-reverse" : "flex-row" // Align based on asker
                  )}
                >
                  {/* Avatar of the person who asked the question */}
                  <Avatar className="h-9 w-9 mt-1 flex-shrink-0">
                    <AvatarFallback className="text-xs">
                      {getInitials(`${asker.firstName} ${asker.lastName}`)}
                    </AvatarFallback>
                  </Avatar>

                  <div className={cn("flex-1 space-y-1")}>
                    {/* Question Section */}
                    <div className="flex items-center justify-between flex-wrap gap-x-2 gap-y-1">
                      <div
                        className={cn(
                          "flex items-center gap-2",
                          alignRight ? "flex-row-reverse" : "flex-row"
                        )}
                      >
                        <span className="font-medium text-sm text-gray-800">
                          {`${asker.firstName} ${asker.lastName}`}
                        </span>
                        <Badge
                          variant="outline"
                          className={cn(
                            "text-xs px-1.5 py-0.5 font-normal",
                            statusInfo.className
                          )}
                        >
                          {statusInfo.label}
                        </Badge>
                      </div>
                      <span className="text-xs text-gray-400">
                        {formatDate(inquiry.createdAt)}
                      </span>
                    </div>
                    <div
                      className={cn(
                        "p-3 rounded-lg max-w-[85%]", // Limit width
                        alignRight
                          ? "bg-blue-50 text-blue-900 ml-auto text-right" // Asker's question style
                          : "bg-gray-100 text-gray-800 mr-auto text-left" // Other person's question style
                      )}
                      dir="auto" // Auto direction based on text content
                    >
                      <p className="whitespace-pre-wrap text-sm">
                        {inquiry.question}
                      </p>
                    </div>

                    {/* Answer Section (if exists) */}
                    {inquiry.answer && inquiry.answeredAt && (
                      <div className="mt-2 flex gap-3">
                        {/* Answer Avatar (Matchmaker/Responder) - Aligned opposite to question */}
                        {!alignRight && (
                          <div className="w-9 flex-shrink-0"></div>
                        )}{" "}
                        {/* Spacer */}
                        <Avatar className="h-9 w-9 mt-1 flex-shrink-0">
                          <AvatarFallback className="text-xs bg-green-100 text-green-700">
                            {getInitials(
                              `${responder.firstName} ${responder.lastName}`
                            )}
                          </AvatarFallback>
                        </Avatar>
                        {alignRight && (
                          <div className="w-9 flex-shrink-0"></div>
                        )}{" "}
                        {/* Spacer */}
                        {/* Answer Content */}
                        <div className="flex-1">
                          <div className="flex items-center justify-between flex-wrap gap-x-2 gap-y-1">
                            {/* Answer Meta - aligned opposite */}
                            <div
                              className={cn(
                                "flex items-center gap-2",
                                !alignRight ? "flex-row-reverse" : "flex-row"
                              )}
                            >
                              <span className="font-medium text-sm text-gray-800">
                                {`${responder.firstName} ${responder.lastName}`}{" "}
                                (תשובה)
                              </span>
                            </div>
                            <span className="text-xs text-gray-400">
                              {formatDate(inquiry.answeredAt)}
                            </span>
                          </div>
                          <div
                            className={cn(
                              "p-3 rounded-lg bg-green-50 text-green-900 max-w-[85%]", // Limit width
                              !alignRight
                                ? "ml-auto text-right"
                                : "mr-auto text-left" // Align answer opposite to question
                            )}
                            dir="auto" // Auto direction
                          >
                            <p className="whitespace-pre-wrap text-sm">
                              {inquiry.answer}
                            </p>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </CardContent>

      {showComposer && (
        <CardFooter className="flex-col space-y-2 pt-4 pb-4 border-t bg-gray-50">
          {" "}
          {/* Added border and subtle bg */}
          <Textarea
            placeholder="כתוב כאן את שאלתך לשדכן..."
            value={newQuestion}
            onChange={(e) => setNewQuestion(e.target.value)}
            className="bg-white text-right" // Ensure white background for textarea
            rows={3}
            disabled={isSending} // Disable textarea while sending
          />
          <div className="flex justify-end w-full">
            <Button
              onClick={handleSendQuestion}
              disabled={!newQuestion.trim() || isSending || isLoading} // Also disable if loading inquiries
              className="gap-2"
              size="sm" // Slightly smaller button
            >
              {isSending ? (
                <>
                  <Loader2 className="h-4 w-4 animate-spin" />
                  שולח...
                </>
              ) : (
                <>
                  <Send className="h-4 w-4" />
                  שלח שאלה
                </>
              )}
            </Button>
          </div>
        </CardFooter>
      )}
    </Card>
  );
};

export default InquiryThreadView;
--- End of Content for InquiryThreadView.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\list
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\list\SuggestionsList.tsx
--------------------------------------------------------------------------------
Content:
// Full path: src/app/components/suggestions/list/SuggestionsList.tsx

"use client";
import React, { useState, useEffect } from "react";
import {
  User,
  Search,
  Filter,
  SortAsc,
  SortDesc,
  Calendar,
  Grid3X3,
  List as ListIcon,
  Check,
  XCircle,
} from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import type { MatchSuggestion } from "@prisma/client";
import type {
  UserProfile,
  UserImage,
  QuestionnaireResponse,
} from "@/types/next-auth";

import MinimalSuggestionCard from "../cards/MinimalSuggestionCard";
import SuggestionDetailsModal from "../modals/SuggestionDetailsModal";
import AskMatchmakerDialog from "../dialogs/AskMatchmakerDialog";
import { cn } from "@/lib/utils";

interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface StatusHistoryItem {
  id: string;
  suggestionId: string;
  status: string;
  notes?: string | null;
  createdAt: Date | string;
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: StatusHistoryItem[];
}

interface SuggestionsListProps {
  suggestions: ExtendedMatchSuggestion[];
  userId: string;
  isHistory?: boolean;
  viewMode: "grid" | "list";
  isLoading?: boolean;
  className?: string;
  onStatusChange?: (
    suggestionId: string,
    newStatus: string,
    notes?: string
  ) => Promise<void>;
  onRefresh?: () => void;
}

type SortOption = "newest" | "oldest" | "deadline" | "priority";
type FilterOption =
  | "all"
  | "pending"
  | "accepted"
  | "declined"
  | "contact_shared";

const SuggestionsList: React.FC<SuggestionsListProps> = ({
  suggestions: initialSuggestions,
  isHistory = false,
  viewMode: initialViewMode,
  isLoading = false,
  userId,
  className,
  onStatusChange,
  onRefresh,
}) => {
  // State
  const [selectedSuggestion, setSelectedSuggestion] =
    useState<ExtendedMatchSuggestion | null>(null);
  const [showAskDialog, setShowAskDialog] = useState(false);
  const [showStatusDialog, setShowStatusDialog] = useState(false);
  const [actionType, setActionType] = useState<"approve" | "decline" | null>(
    null
  );
  const [questionnaireResponse, setQuestionnaireResponse] =
    useState<QuestionnaireResponse | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [sortOption, setSortOption] = useState<SortOption>("newest");
  const [filterOption, setFilterOption] = useState<FilterOption>("all");
  const [viewMode, setViewMode] = useState<"grid" | "list">(initialViewMode);
  const [filteredSuggestions, setFilteredSuggestions] =
    useState<ExtendedMatchSuggestion[]>(initialSuggestions);

  // Filter and sort suggestions
  useEffect(() => {
    let result = [...initialSuggestions];

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter((suggestion) => {
        const targetParty =
          suggestion.firstPartyId === userId
            ? suggestion.secondParty
            : suggestion.firstParty;
        return (
          targetParty.firstName.toLowerCase().includes(query) ||
          targetParty.lastName.toLowerCase().includes(query) ||
          targetParty.profile?.city?.toLowerCase().includes(query) ||
          targetParty.profile?.occupation?.toLowerCase().includes(query) ||
          targetParty.profile?.religiousLevel?.toLowerCase().includes(query)
        );
      });
    }

    // Apply status filter
    if (filterOption !== "all") {
      switch (filterOption) {
        case "pending":
          result = result.filter(
            (s) =>
              s.status === "PENDING_FIRST_PARTY" ||
              s.status === "PENDING_SECOND_PARTY"
          );
          break;
        case "accepted":
          result = result.filter(
            (s) =>
              s.status === "FIRST_PARTY_APPROVED" ||
              s.status === "SECOND_PARTY_APPROVED"
          );
          break;
        case "declined":
          result = result.filter(
            (s) =>
              s.status === "FIRST_PARTY_DECLINED" ||
              s.status === "SECOND_PARTY_DECLINED"
          );
          break;
        case "contact_shared":
          result = result.filter((s) => s.status === "CONTACT_DETAILS_SHARED");
          break;
      }
    }

    // Apply sorting
    switch (sortOption) {
      case "newest":
        result.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        break;
      case "oldest":
        result.sort(
          (a, b) =>
            new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
        break;
      case "deadline":
        result.sort((a, b) => {
          if (!a.decisionDeadline) return 1;
          if (!b.decisionDeadline) return -1;
          return (
            new Date(a.decisionDeadline).getTime() -
            new Date(b.decisionDeadline).getTime()
          );
        });
        break;
      case "priority":
        const priorityOrder = { URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        result.sort(
          (a, b) =>
            (priorityOrder[a.priority as keyof typeof priorityOrder] || 4) -
            (priorityOrder[b.priority as keyof typeof priorityOrder] || 4)
        );
        break;
    }

    setFilteredSuggestions(result);
  }, [initialSuggestions, searchQuery, sortOption, filterOption, userId]);

  // Load questionnaire when a suggestion is selected
  useEffect(() => {
    const loadQuestionnaire = async () => {
      if (!selectedSuggestion) {
        setQuestionnaireResponse(null);
        return;
      }

      const targetParty =
        selectedSuggestion.firstPartyId === userId
          ? selectedSuggestion.secondParty
          : selectedSuggestion.firstParty;

      try {
        const response = await fetch(
          `/api/profile/questionnaire?userId=${targetParty.id}`
        );
        const data = await response.json();

        if (data.success && data.questionnaireResponse) {
          const formattedQuestionnaire = {
            ...data.questionnaireResponse,
            formattedAnswers: {
              values: data.questionnaireResponse.formattedAnswers.values || [],
              personality:
                data.questionnaireResponse.formattedAnswers.personality || [],
              relationship:
                data.questionnaireResponse.formattedAnswers.relationship || [],
              partner:
                data.questionnaireResponse.formattedAnswers.partner || [],
              religion:
                data.questionnaireResponse.formattedAnswers.religion || [],
            },
          };
          setQuestionnaireResponse(formattedQuestionnaire);
        }
      } catch (error) {
        console.error("Failed to load questionnaire:", error);
        toast.error("שגיאה בטעינת השאלון");
      }
    };

    loadQuestionnaire();
  }, [selectedSuggestion, userId]);

  // Handlers
  const handleOpenDetails = (suggestion: ExtendedMatchSuggestion) => {
    setSelectedSuggestion(suggestion);
  };

  const handleInquiry = (suggestion: ExtendedMatchSuggestion) => {
    setSelectedSuggestion(suggestion);
    setShowAskDialog(true);
  };

  const handleStatusAction = (
    suggestion: ExtendedMatchSuggestion,
    action: "approve" | "decline"
  ) => {
    setSelectedSuggestion(suggestion);
    setActionType(action);
    setShowStatusDialog(true);
  };

  const handleActionConfirm = async () => {
    if (!selectedSuggestion || !actionType || !onStatusChange) return;

    try {
      const isFirstParty = selectedSuggestion.firstPartyId === userId;

      let newStatus = "";
      if (actionType === "approve") {
        newStatus = isFirstParty
          ? "FIRST_PARTY_APPROVED"
          : "SECOND_PARTY_APPROVED";
      } else {
        newStatus = isFirstParty
          ? "FIRST_PARTY_DECLINED"
          : "SECOND_PARTY_DECLINED";
      }

      await onStatusChange(selectedSuggestion.id, newStatus);

      toast.success(
        actionType === "approve" ? "ההצעה אושרה בהצלחה" : "ההצעה נדחתה בהצלחה"
      );

      if (onRefresh) {
        onRefresh();
      }
    } catch (error) {
      console.error("Error updating suggestion status:", error);
      toast.error("אירעה שגיאה בעדכון הסטטוס");
    } finally {
      setShowStatusDialog(false);
      setSelectedSuggestion(null);
      setActionType(null);
    }
  };

  const handleSendQuestion = async (questionText: string) => {
    if (!selectedSuggestion) return;

    try {
      const response = await fetch(
        `/api/suggestions/${selectedSuggestion.id}/inquiries`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ question: questionText }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to send inquiry");
      }

      toast.success("השאלה נשלחה בהצלחה לשדכן");
      setShowAskDialog(false);
    } catch (error) {
      console.error("Error sending question:", error);
      toast.error("אירעה שגיאה בשליחת השאלה");
    }
  };

  // Render loading state
  if (isLoading) {
    return (
      <div
        className={cn(
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
            : "space-y-4",
          className
        )}
      >
        {Array.from({ length: 6 }).map((_, i) => (
          <Skeleton key={i} className="h-64 w-full" />
        ))}
      </div>
    );
  }

  // Render empty state
  if (filteredSuggestions.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-gray-400">
        <User className="w-12 h-12 mb-4" />
        {searchQuery || filterOption !== "all" ? (
          <div className="text-center">
            <p>לא נמצאו הצעות התואמות את החיפוש</p>
            <Button
              variant="ghost"
              className="mt-2"
              onClick={() => {
                setSearchQuery("");
                setFilterOption("all");
              }}
            >
              נקה סינון
            </Button>
          </div>
        ) : (
          <p>{isHistory ? "אין הצעות בהיסטוריה" : "אין הצעות פעילות"}</p>
        )}
      </div>
    );
  }

  return (
    <>
      {/* Filters and search bar */}
      <div className="mb-6 flex flex-col gap-4">
        <div className="flex items-center gap-2">
          <div className="relative flex-1">
            <Search className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
            <Input
              type="text"
              placeholder="חיפוש לפי שם, עיר, או מקצוע..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pr-10 text-right"
            />
          </div>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="icon">
                <Filter className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>סינון הצעות</DropdownMenuLabel>
              <DropdownMenuGroup>
                <DropdownMenuItem onClick={() => setFilterOption("all")}>
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      filterOption === "all" ? "opacity-100" : "opacity-0"
                    )}
                  />
                  הכל
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => setFilterOption("pending")}>
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      filterOption === "pending" ? "opacity-100" : "opacity-0"
                    )}
                  />
                  ממתינות לתשובה
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => setFilterOption("accepted")}>
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      filterOption === "accepted" ? "opacity-100" : "opacity-0"
                    )}
                  />
                  מאושרות
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => setFilterOption("declined")}>
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      filterOption === "declined" ? "opacity-100" : "opacity-0"
                    )}
                  />
                  שנדחו
                </DropdownMenuItem>
                <DropdownMenuItem
                  onClick={() => setFilterOption("contact_shared")}
                >
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      filterOption === "contact_shared"
                        ? "opacity-100"
                        : "opacity-0"
                    )}
                  />
                  פרטי קשר שותפו
                </DropdownMenuItem>
              </DropdownMenuGroup>
            </DropdownMenuContent>
          </DropdownMenu>

          <Select
            value={sortOption}
            onValueChange={(value) => setSortOption(value as SortOption)}
          >
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="מיון לפי" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="newest">
                <div className="flex items-center gap-2">
                  <SortDesc className="h-4 w-4" />
                  החדש ביותר
                </div>
              </SelectItem>
              <SelectItem value="oldest">
                <div className="flex items-center gap-2">
                  <SortAsc className="h-4 w-4" />
                  הישן ביותר
                </div>
              </SelectItem>
              <SelectItem value="deadline">
                <div className="flex items-center gap-2">
                  <Calendar className="h-4 w-4" />
                  תאריך יעד
                </div>
              </SelectItem>
              <SelectItem value="priority">
                <div className="flex items-center gap-2">
                  <Filter className="h-4 w-4" />
                  עדיפות
                </div>
              </SelectItem>
            </SelectContent>
          </Select>

          <div className="flex gap-1 border rounded-md">
            <Button
              variant={viewMode === "grid" ? "default" : "ghost"}
              size="icon"
              className={cn(
                "rounded-none",
                viewMode === "grid" ? "" : "hover:bg-muted"
              )}
              onClick={() => setViewMode("grid")}
            >
              <Grid3X3 className="h-4 w-4" />
            </Button>
            <Button
              variant={viewMode === "list" ? "default" : "ghost"}
              size="icon"
              className={cn(
                "rounded-none",
                viewMode === "list" ? "" : "hover:bg-muted"
              )}
              onClick={() => setViewMode("list")}
            >
              <ListIcon className="h-4 w-4" />
            </Button>
          </div>
        </div>

        {/* Active filters display */}
        {(searchQuery || filterOption !== "all") && (
          <div className="flex items-center gap-2">
            <span className="text-sm text-gray-500">סינון פעיל:</span>
            {searchQuery && (
              <Badge variant="outline" className="flex items-center gap-1">
                חיפוש: {searchQuery}
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={() => setSearchQuery("")}
                >
                  <XCircle className="h-3 w-3" />
                </Button>
              </Badge>
            )}
            {filterOption !== "all" && (
              <Badge variant="outline" className="flex items-center gap-1">
                {filterOption === "pending" && "ממתינות לתשובה"}
                {filterOption === "accepted" && "מאושרות"}
                {filterOption === "declined" && "שנדחו"}
                {filterOption === "contact_shared" && "פרטי קשר שותפו"}
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={() => setFilterOption("all")}
                >
                  <XCircle className="h-3 w-3" />
                </Button>
              </Badge>
            )}
            <Button
              variant="ghost"
              size="sm"
              className="text-xs"
              onClick={() => {
                setSearchQuery("");
                setFilterOption("all");
              }}
            >
              נקה הכל
            </Button>
          </div>
        )}
      </div>

      {/* Results count */}
      <div className="mb-4 text-sm text-gray-500 text-left">
        מציג {filteredSuggestions.length}{" "}
        {filteredSuggestions.length === 1 ? "הצעה" : "הצעות"} מתוך{" "}
        {initialSuggestions.length}
      </div>

      {/* Suggestions grid/list */}
      <div
        className={cn(
          viewMode === "grid"
            ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
            : "space-y-4",
          className
        )}
      >
        {filteredSuggestions.map((suggestion) => (
          <div key={suggestion.id} className="relative">
            <MinimalSuggestionCard
              suggestion={suggestion}
              userId={userId}
              onClick={() => handleOpenDetails(suggestion)}
              onInquiry={() => handleInquiry(suggestion)}
              onApprove={() => handleStatusAction(suggestion, "approve")}
              onDecline={() => handleStatusAction(suggestion, "decline")}
              isHistory={isHistory}
              className={viewMode === "list" ? "flex" : ""}
            />
          </div>
        ))}
      </div>

      {/* Suggestion Details Modal */}
      <SuggestionDetailsModal
        suggestion={selectedSuggestion}
        userId={userId}
        isOpen={!!selectedSuggestion && !showAskDialog && !showStatusDialog}
        onClose={() => setSelectedSuggestion(null)}
        onStatusChange={onStatusChange}
        questionnaire={questionnaireResponse}
      />

      {/* Ask Matchmaker Dialog */}
      <AskMatchmakerDialog
        isOpen={showAskDialog}
        onClose={() => setShowAskDialog(false)}
        onSubmit={handleSendQuestion}
        matchmakerName={selectedSuggestion?.matchmaker.firstName}
        suggestionId={selectedSuggestion?.id}
      />

      {/* Status Change Confirmation Dialog */}
      <AlertDialog open={showStatusDialog} onOpenChange={setShowStatusDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>
              {actionType === "approve"
                ? "אישור הצעת השידוך"
                : "דחיית הצעת השידוך"}
            </AlertDialogTitle>
            <AlertDialogDescription>
              {actionType === "approve"
                ? "האם אתה בטוח שברצונך לאשר את הצעת השידוך? לאחר האישור, ההצעה תעבור לשלב הבא בתהליך."
                : "האם אתה בטוח שברצונך לדחות את הצעת השידוך? פעולה זו אינה ניתנת לביטול."}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ביטול</AlertDialogCancel>
            <AlertDialogAction onClick={handleActionConfirm}>
              {actionType === "approve" ? "אישור ההצעה" : "דחיית ההצעה"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};

export default SuggestionsList;
--- End of Content for SuggestionsList.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\modals
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\modals\SuggestionDetailsModal.tsx
--------------------------------------------------------------------------------
Content:
// Full path: src/app/components/suggestions/modals/SuggestionDetailsModal.tsx

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card, CardContent } from "@/components/ui/card";
import {
  CheckCircle,
  XCircle,
  MessageCircle,
  Calendar,
  Info,
  User,
  Clock,
  Briefcase,
  GraduationCap,
  MapPin,
  Scroll,
} from "lucide-react";
import { format } from "date-fns";
import { he } from "date-fns/locale";
import { ProfileCard } from "@/app/components/profile";
import SuggestionTimeline from "../timeline/SuggestionTimeline";
import { AskMatchmakerDialog } from "../dialogs/AskMatchmakerDialog";
import type { MatchSuggestion } from "@prisma/client";
import type {
  UserProfile,
  UserImage,
  QuestionnaireResponse,
} from "@/types/next-auth";
import { cn } from "@/lib/utils";

interface ExtendedUserProfile extends UserProfile {
  user: {
    firstName: string;
    lastName: string;
    email: string;
  };
}

interface PartyInfo {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profile: ExtendedUserProfile;
  images: UserImage[];
}

interface StatusHistoryItem {
  id: string;
  suggestionId: string;
  status: string;
  notes?: string | null;
  createdAt: Date | string;
}

interface ExtendedMatchSuggestion extends MatchSuggestion {
  matchmaker: {
    firstName: string;
    lastName: string;
  };
  firstParty: PartyInfo;
  secondParty: PartyInfo;
  statusHistory: StatusHistoryItem[];
}

interface SuggestionDetailsModalProps {
  suggestion: ExtendedMatchSuggestion | null;
  userId: string;
  isOpen: boolean;
  onClose: () => void;
  onStatusChange?: (suggestionId: string, newStatus: string) => Promise<void>;
  questionnaire?: QuestionnaireResponse | null;
}

const getStatusLabel = (status: string): string => {
  const statusMap: Record<string, string> = {
    DRAFT: "טיוטה",
    PENDING_FIRST_PARTY: "ממתין לתשובת הצד הראשון",
    FIRST_PARTY_APPROVED: "הצד הראשון אישר",
    FIRST_PARTY_DECLINED: "הצד הראשון דחה",
    PENDING_SECOND_PARTY: "ממתין לתשובת הצד השני",
    SECOND_PARTY_APPROVED: "הצד השני אישר",
    SECOND_PARTY_DECLINED: "הצד השני דחה",
    CONTACT_DETAILS_SHARED: "פרטי קשר שותפו",
    AWAITING_FIRST_DATE_FEEDBACK: "ממתין למשוב פגישה ראשונה",
    THINKING_AFTER_DATE: "בחשיבה לאחר הפגישה",
    PROCEEDING_TO_SECOND_DATE: "התקדמות לפגישה שנייה",
    ENDED_AFTER_FIRST_DATE: "הסתיים לאחר פגישה ראשונה",
    DATING: "בתהליך היכרות",
    ENGAGED: "אירוסין",
    MARRIED: "נישואין",
    CANCELLED: "בוטל",
    CLOSED: "נסגר",
    EXPIRED: "פג תוקף",
  };

  return statusMap[status] || status;
};

const getPriorityLabel = (
  priority: string
): { label: string; color: string } => {
  switch (priority) {
    case "LOW":
      return { label: "נמוכה", color: "bg-gray-100 text-gray-800" };
    case "MEDIUM":
      return { label: "בינונית", color: "bg-blue-100 text-blue-800" };
    case "HIGH":
      return { label: "גבוהה", color: "bg-yellow-100 text-yellow-800" };
    case "URGENT":
      return { label: "דחופה", color: "bg-red-100 text-red-800" };
    default:
      return { label: "בינונית", color: "bg-blue-100 text-blue-800" };
  }
};

const calculateAge = (birthDate: Date): number => {
  const today = new Date();
  const birth = new Date(birthDate);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
};

const SuggestionDetailsModal: React.FC<SuggestionDetailsModalProps> = ({
  suggestion,
  userId,
  isOpen,
  onClose,
  onStatusChange,
  questionnaire,
}) => {
  const [activeTab, setActiveTab] = useState("profile");
  const [showAskDialog, setShowAskDialog] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    if (isOpen) {
      setActiveTab("profile");
    }
  }, [isOpen]);

  if (!suggestion) return null;

  const isFirstParty = suggestion.firstPartyId === userId;
  const targetParty = isFirstParty
    ? suggestion.secondParty
    : suggestion.firstParty;
  const targetPartyAge = targetParty.profile?.birthDate
    ? calculateAge(new Date(targetParty.profile.birthDate))
    : null;

  const priorityInfo = getPriorityLabel(suggestion.priority);

  const canApprove =
    (isFirstParty && suggestion.status === "PENDING_FIRST_PARTY") ||
    (!isFirstParty && suggestion.status === "PENDING_SECOND_PARTY");

  const canDecline = canApprove;

  const handleStatusChange = async (newStatus: string) => {
    if (!onStatusChange) return;

    try {
      setIsSubmitting(true);
      await onStatusChange(suggestion.id, newStatus);
      onClose();
    } catch (error) {
      console.error("Failed to update status:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleSendQuestion = async (question: string) => {
    try {
      setIsSubmitting(true);

      const response = await fetch(
        `/api/suggestions/${suggestion.id}/inquiries`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ question }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to send inquiry");
      }

      setShowAskDialog(false);
    } catch (error) {
      console.error("Error sending question:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-6xl h-[90vh] max-h-[90vh] flex flex-col p-0">
          <DialogHeader className="px-6 py-4 border-b">
            <div className="flex justify-between items-center">
              <Badge className={cn("text-xs py-1", priorityInfo.color)}>
                {priorityInfo.label}
              </Badge>
              <DialogTitle className="text-xl">
                הצעת שידוך עם {targetParty.firstName} {targetParty.lastName}
                {targetPartyAge && (
                  <span className="text-sm font-normal mr-2">
                    ({targetPartyAge})
                  </span>
                )}
              </DialogTitle>
            </div>
          </DialogHeader>

          <div className="flex-1 overflow-hidden flex flex-col">
            <Tabs
              defaultValue="profile"
              value={activeTab}
              onValueChange={setActiveTab}
              className="flex-1 flex flex-col overflow-hidden"
            >
              <div className="border-b px-6">
                <TabsList className="mt-2">
                  <TabsTrigger
                    value="profile"
                    className="flex items-center gap-2"
                  >
                    <User className="w-4 h-4" />
                    פרופיל
                  </TabsTrigger>
                  <TabsTrigger
                    value="details"
                    className="flex items-center gap-2"
                  >
                    <Info className="w-4 h-4" />
                    פרטי ההצעה
                  </TabsTrigger>
                  <TabsTrigger
                    value="timeline"
                    className="flex items-center gap-2"
                  >
                    <Clock className="w-4 h-4" />
                    היסטוריה
                  </TabsTrigger>
                </TabsList>
              </div>

              <ScrollArea className="flex-1">
                <TabsContent value="profile" className="flex-1 p-6">
                  <ProfileCard
                    profile={{
                      ...targetParty.profile,
                      user: {
                        firstName: targetParty.firstName,
                        lastName: targetParty.lastName,
                        email: targetParty.email,
                      },
                    }}
                    images={targetParty.images}
                    questionnaire={questionnaire}
                    viewMode="candidate"
                  />
                </TabsContent>

                <TabsContent value="details" className="flex-1 p-6">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <Card>
                      <CardContent className="p-6">
                        <h3 className="text-lg font-medium mb-4 text-right">
                          פרטי ההצעה
                        </h3>
                        <div className="space-y-4 text-right">
                          <div>
                            <p className="text-sm text-gray-500 mb-1">סטטוס</p>
                            <Badge className="text-sm">
                              {getStatusLabel(suggestion.status)}
                            </Badge>
                          </div>

                          <div>
                            <p className="text-sm text-gray-500 mb-1">שדכן</p>
                            <div className="flex items-center justify-end gap-2">
                              <p>
                                {suggestion.matchmaker.firstName}{" "}
                                {suggestion.matchmaker.lastName}
                              </p>
                              <Briefcase className="w-4 h-4" />
                            </div>
                          </div>

                          {suggestion.decisionDeadline && (
                            <div>
                              <p className="text-sm text-gray-500 mb-1">
                                תאריך יעד להחלטה
                              </p>
                              <div className="flex items-center justify-end gap-2">
                                <p>
                                  {format(
                                    new Date(suggestion.decisionDeadline),
                                    "dd/MM/yyyy",
                                    { locale: he }
                                  )}
                                </p>
                                <Calendar className="w-4 h-4" />
                              </div>
                            </div>
                          )}

                          <div>
                            <p className="text-sm text-gray-500 mb-1">
                              תאריך יצירה
                            </p>
                            <div className="flex items-center justify-end gap-2">
                              <p>
                                {format(
                                  new Date(suggestion.createdAt),
                                  "dd/MM/yyyy",
                                  { locale: he }
                                )}
                              </p>
                              <Calendar className="w-4 h-4" />
                            </div>
                          </div>
                        </div>
                      </CardContent>
                    </Card>

                    <Card>
                      <CardContent className="p-6">
                        <h3 className="text-lg font-medium mb-4 text-right">
                          סיבות להצעה
                        </h3>
                        {suggestion.matchingReason ? (
                          <p className="text-right whitespace-pre-line">
                            {suggestion.matchingReason}
                          </p>
                        ) : (
                          <p className="text-right text-gray-500">
                            לא צוינו סיבות מיוחדות
                          </p>
                        )}

                        {isFirstParty && suggestion.firstPartyNotes && (
                          <div className="mt-4">
                            <h4 className="font-medium text-sm text-right mb-2">
                              הערות עבורך:
                            </h4>
                            <div className="bg-blue-50 p-3 rounded text-right">
                              {suggestion.firstPartyNotes}
                            </div>
                          </div>
                        )}

                        {!isFirstParty && suggestion.secondPartyNotes && (
                          <div className="mt-4">
                            <h4 className="font-medium text-sm text-right mb-2">
                              הערות עבורך:
                            </h4>
                            <div className="bg-blue-50 p-3 rounded text-right">
                              {suggestion.secondPartyNotes}
                            </div>
                          </div>
                        )}
                      </CardContent>
                    </Card>

                    <Card className="md:col-span-2">
                      <CardContent className="p-6">
                        <h3 className="text-lg font-medium mb-4 text-right">
                          נקודות התאמה
                        </h3>

                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                          <div className="bg-green-50 p-4 rounded-lg">
                            <div className="flex items-center justify-end gap-2 mb-2">
                              <h4 className="font-medium">רקע והשכלה</h4>
                              <GraduationCap className="w-5 h-5 text-green-600" />
                            </div>
                            <ul className="text-right text-sm space-y-2">
                              {targetParty.profile.education && (
                                <li className="flex items-center justify-end gap-2">
                                  <span>{targetParty.profile.education}</span>
                                </li>
                              )}
                              {targetParty.profile.occupation && (
                                <li className="flex items-center justify-end gap-2">
                                  <span>{targetParty.profile.occupation}</span>
                                </li>
                              )}
                            </ul>
                          </div>

                          <div className="bg-blue-50 p-4 rounded-lg">
                            <div className="flex items-center justify-end gap-2 mb-2">
                              <h4 className="font-medium">מקום מגורים</h4>
                              <MapPin className="w-5 h-5 text-blue-600" />
                            </div>
                            <ul className="text-right text-sm space-y-2">
                              {targetParty.profile.city && (
                                <li className="flex items-center justify-end gap-2">
                                  <span>{targetParty.profile.city}</span>
                                </li>
                              )}
                             
                            </ul>
                          </div>
                          <div className="bg-purple-50 p-4 rounded-lg">
                            <div className="flex items-center justify-end gap-2 mb-2">
                              <h4 className="font-medium">רקע דתי</h4>
                              <Scroll className="w-5 h-5 text-purple-600" />
                            </div>
                            <ul className="text-right text-sm space-y-2">
                              {targetParty.profile.religiousLevel && (
                                <li className="flex items-center justify-end gap-2">
                                  <span>
                                    {targetParty.profile.religiousLevel}
                                  </span>
                                </li>
                              )}
                              {targetParty.profile.origin && (
                                <li className="flex items-center justify-end gap-2">
                                  <span>
                                    מוצא: {targetParty.profile.origin}
                                  </span>
                                </li>
                              )}
                            </ul>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  </div>
                </TabsContent>

                <TabsContent value="timeline" className="flex-1 p-6">
                  <SuggestionTimeline
                    statusHistory={suggestion.statusHistory}
                  />
                </TabsContent>
              </ScrollArea>
            </Tabs>
          </div>

          <DialogFooter className="px-6 py-4 border-t flex-shrink-0">
            <div className="flex gap-2 w-full">
              {canApprove && (
                <Button
                  variant="default"
                  className="bg-green-600 hover:bg-green-700"
                  disabled={isSubmitting}
                  onClick={() =>
                    handleStatusChange(
                      isFirstParty
                        ? "FIRST_PARTY_APPROVED"
                        : "SECOND_PARTY_APPROVED"
                    )
                  }
                >
                  <CheckCircle className="w-4 h-4 ml-2" />
                  אישור ההצעה
                </Button>
              )}

              {canDecline && (
                <Button
                  variant="outline"
                  className="text-red-600 hover:bg-red-50 hover:text-red-700"
                  disabled={isSubmitting}
                  onClick={() =>
                    handleStatusChange(
                      isFirstParty
                        ? "FIRST_PARTY_DECLINED"
                        : "SECOND_PARTY_DECLINED"
                    )
                  }
                >
                  <XCircle className="w-4 h-4 ml-2" />
                  דחיית ההצעה
                </Button>
              )}

              <Button
                variant="outline"
                onClick={() => setShowAskDialog(true)}
                disabled={isSubmitting}
              >
                <MessageCircle className="w-4 h-4 ml-2" />
                שאלה לשדכן
              </Button>

              <Button
                variant="ghost"
                className="mr-auto"
                onClick={onClose}
                disabled={isSubmitting}
              >
                סגירה
              </Button>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <AskMatchmakerDialog
        isOpen={showAskDialog}
        onClose={() => setShowAskDialog(false)}
        onSubmit={handleSendQuestion}
        matchmakerName={`${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`}
      />
    </>
  );
};

export default SuggestionDetailsModal;
--- End of Content for SuggestionDetailsModal.tsx ---

================================================================================
Directory: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\timeline
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\user\Desktop\matchpoint\shidduch-system\src\app\components\suggestions\timeline\SuggestionTimeline.tsx
--------------------------------------------------------------------------------
Content:
// Full path: src/app/components/suggestions/timeline/SuggestionTimeline.tsx

import React from "react";
import { format } from "date-fns";
import { he } from "date-fns/locale";
import {
  Clock,
  CheckCircle,
  XCircle,
  MessageCircle,
  Heart,
  AlertCircle,
  User,
  Calendar
} from "lucide-react";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

interface StatusHistoryItem {
  id: string;
  status: string;
  notes?: string | null;
  createdAt: Date | string;
}

interface SuggestionTimelineProps {
  statusHistory: StatusHistoryItem[];
  className?: string;
}

const getStatusInfo = (status: string) => {
  switch (status) {
    case "DRAFT":
      return {
        label: "טיוטה",
        icon: <Clock className="w-4 h-4" />,
        color: "text-gray-500 bg-gray-100",
        description: "ההצעה נוצרה אך טרם נשלחה למועמדים"
      };
    case "PENDING_FIRST_PARTY":
      return {
        label: "ממתין לתשובת הצד הראשון",
        icon: <User className="w-4 h-4" />,
        color: "text-yellow-700 bg-yellow-100",
        description: "ההצעה נשלחה לצד הראשון וממתינה לתשובה"
      };
    case "FIRST_PARTY_APPROVED":
      return {
        label: "הצד הראשון אישר",
        icon: <CheckCircle className="w-4 h-4" />,
        color: "text-green-700 bg-green-100",
        description: "הצד הראשון אישר את ההצעה"
      };
    case "FIRST_PARTY_DECLINED":
      return {
        label: "הצד הראשון דחה",
        icon: <XCircle className="w-4 h-4" />,
        color: "text-red-700 bg-red-100",
        description: "הצד הראשון דחה את ההצעה"
      };
    case "PENDING_SECOND_PARTY":
      return {
        label: "ממתין לתשובת הצד השני",
        icon: <User className="w-4 h-4" />,
        color: "text-blue-700 bg-blue-100",
        description: "ההצעה נשלחה לצד השני וממתינה לתשובה"
      };
    case "SECOND_PARTY_APPROVED":
      return {
        label: "הצד השני אישר",
        icon: <CheckCircle className="w-4 h-4" />,
        color: "text-green-700 bg-green-100",
        description: "הצד השני אישר את ההצעה"
      };
    case "SECOND_PARTY_DECLINED":
      return {
        label: "הצד השני דחה",
        icon: <XCircle className="w-4 h-4" />,
        color: "text-red-700 bg-red-100",
        description: "הצד השני דחה את ההצעה"
      };
    case "CONTACT_DETAILS_SHARED":
      return {
        label: "פרטי קשר שותפו",
        icon: <MessageCircle className="w-4 h-4" />,
        color: "text-purple-700 bg-purple-100",
        description: "פרטי הקשר של שני הצדדים שותפו ביניהם"
      };
    case "AWAITING_FIRST_DATE_FEEDBACK":
      return {
        label: "ממתין למשוב פגישה ראשונה",
        icon: <Calendar className="w-4 h-4" />,
        color: "text-indigo-700 bg-indigo-100",
        description: "ממתין למשוב לאחר הפגישה הראשונה"
      };
    case "DATING":
      return {
        label: "בתהליך היכרות",
        icon: <Heart className="w-4 h-4" />,
        color: "text-pink-700 bg-pink-100",
        description: "הצדדים נמצאים בתהליך היכרות"
      };
    case "ENGAGED":
      return {
        label: "אירוסין",
        icon: <Heart className="w-4 h-4" fill="currentColor" />,
        color: "text-pink-700 bg-pink-100",
        description: "הצדדים התארסו"
      };
    case "MARRIED":
      return {
        label: "נישואין",
        icon: <Heart className="w-4 h-4" fill="currentColor" />,
        color: "text-pink-700 bg-pink-100",
        description: "הצדדים נישאו"
      };
    case "CANCELLED":
      return {
        label: "בוטל",
        icon: <XCircle className="w-4 h-4" />,
        color: "text-red-700 bg-red-100",
        description: "ההצעה בוטלה"
      };
    case "CLOSED":
      return {
        label: "נסגר",
        icon: <XCircle className="w-4 h-4" />,
        color: "text-gray-700 bg-gray-100",
        description: "ההצעה נסגרה"
      };
    default:
      return {
        label: status,
        icon: <AlertCircle className="w-4 h-4" />,
        color: "text-gray-700 bg-gray-100",
        description: "סטטוס אחר"
      };
  }
};

const SuggestionTimeline: React.FC<SuggestionTimelineProps> = ({ 
  statusHistory,
  className
}) => {
  // Sort history from newest to oldest
  const sortedHistory = [...statusHistory].sort((a, b) => 
    new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  );

  return (
    <div className={cn("px-4 py-2", className)}>
      <h3 className="text-lg font-semibold mb-4 text-right">היסטוריית סטטוסים</h3>
      
      <div className="relative border-r-2 border-gray-200 pr-6 space-y-6">
        {sortedHistory.map((item, index) => {
          const statusInfo = getStatusInfo(item.status);
          const formattedDate = format(
            new Date(item.createdAt),
            "dd בMMMM yyyy, HH:mm",
            { locale: he }
          );
          
          return (
            <div 
              key={item.id} 
              className={cn(
                "relative",
                index === 0 ? "opacity-100" : "opacity-80"
              )}
            >
              {/* Timeline node */}
              <div 
                className={cn(
                  "absolute right-[-21px] p-1 rounded-full",
                  statusInfo.color
                )}
              >
                {statusInfo.icon}
              </div>
              
              {/* Content */}
              <div className="bg-white rounded-lg p-3 shadow-sm">
                <div className="flex justify-between items-start">
                  <span className="text-xs text-gray-500 mt-1">{formattedDate}</span>
                  <div className="flex items-center gap-2">
                    <span className="font-medium">{statusInfo.label}</span>
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <Badge className={cn("h-2 w-2 rounded-full p-0", statusInfo.color)} />
                        </TooltipTrigger>
                        <TooltipContent className="text-right">
                          <p>{statusInfo.description}</p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                  </div>
                </div>
                
                {item.notes && (
                  <p className="mt-2 text-sm text-gray-600 text-right">
                    {item.notes}
                  </p>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default SuggestionTimeline;
--- End of Content for SuggestionTimeline.tsx ---

