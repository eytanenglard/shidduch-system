################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api
# Generated on: 2025-08-18 13:44:20
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\api_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * מטפל בבקשות POST לניתוח פרופיל המשתמש באמצעות AI.
 * הפונקציה מאמתת את המשתמש, יוצרת פרופיל נרטיבי מקיף,
 * שולחת אותו לניתוח AI, ומחזירה את התוצאה המובנית.
 */
export async function POST(req: Request) {
  try {
    // שלב 1: אימות משתמש
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // שלב 2: ודא שהמשתמש והפרופיל קיימים לפני יצירת הנרטיב
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] לא נמצא פרופיל עבור משתמש: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // שלב 3: יצירת פרופיל נרטיבי מקיף
    // שימוש חוזר בלוגיקה הקיימת והמצוינת מ-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] נכשל ביצירת פרופיל נרטיבי עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // שלב 4: שליחת הנרטיב לניתוח AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] שירות ה-AI לא החזיר תוצאה עבור: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // שלב 5: החזרת התוצאה ללקוח
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * מטפל בבקשות POST לניתוח הצעת שידוך עבור המשתמש המחובר.
 * הפונקציה מאמתת את המשתמש, מאחזרת את הפרופיל שלו ואת הפרופיל של המשתמש המוצע,
 * יוצרת פרופילים נרטיביים עבור שניהם, שולחת אותם לניתוח AI מותאם למשתמש,
 * ומחזירה את התוצאה המובנית.
 */
export async function POST(req: Request) {
  try {
    // 1. אימות וקבלת המשתמש הנוכחי
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] ניסיון גישה לא מורשה.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. קבלת ID של המשתמש המוצע מגוף הבקשה
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3. ודא ששני הפרופילים קיימים
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] אחד הפרופילים או שניהם לא נמצאו. נמצאו: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. יצירת פרופילים נרטיביים עבור שני המשתמשים במקביל
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] נכשל ביצירת פרופיל נרטיבי עבור אחד המשתמשים.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. שליחת הנרטיבים לניתוח AI מותאם למשתמש
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] שירות ה-AI לא החזיר תוצאת ניתוח הצעה.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. החזרת התוצאה ללקוח
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] שגיאה פטאלית ב-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * פונקציית עזר שמריצה את תהליך העדכון ברקע
 * ומדפיסה לוג מפורט בסיומו.
 * @param userIds - מערך מזהי המשתמשים לעדכון
 * @param adminId - מזהה האדמין שהפעיל את התהליך
 */
async function runBulkUpdateAndLog(userIds: string[], adminId: string) {
  const totalUsers = userIds.length;
  // הודעת התחלה ברורה לתהליך הרקע
 
  try {
    // נשתמש ב-Promise.allSettled כדי להמתין לסיום כל העדכונים, גם אם חלקם נכשלים
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // איסוף מזהי המשתמשים שנכשלו (אם יש כאלה)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // הדפסת סיכום מפורט
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // במקרה של שגיאה קריטית בתהליך הרקע עצמו
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // כאן הלוג המקורי נשאר, כדי שתראה שה-API הופעל
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds, adminId).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// הסר את הלוגים או הפעל אותם רק בסביבת פיתוח
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// פונקציה שבודקת אם ה-metadata מכיל את הסיסמה המוצפנת
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // וידוא שהטוקן הוא מספרי בן 6 ספרות
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "קוד אימות לא תקין. נדרש קוד בן 6 ספרות." },
        { status: 400 }
      );
    }

    // מציאת הטוקן
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "קוד לא תקף או שפג תוקפו" },
        { status: 400 }
      );
    }

    // בדיקה שהמטא-דאטה תקין ומכיל את הסיסמה המוצפנת
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "מידע אימות חסר או לא תקין, אנא התחל את התהליך מחדש" },
        { status: 400 }
      );
    }

    // כעת ניתן לגשת ל-hashedNewPassword בבטחה, המטא-דאטה אומת
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // עדכון הסיסמה והשלמת האימות
    await db.$transaction([
      // עדכון סיסמה
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // עדכון סטטוס האימות
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "הסיסמה עודכנה בהצלחה"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בהשלמת שינוי הסיסמה" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // ודא שהנתיב הזה נכון ומצביע על קובץ authOptions שלך
import prisma from '@/lib/prisma'; // ודא שהנתיב הזה נכון
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus } from '@prisma/client'; // ייבוא Gender ו-UserStatus

// Zod Schema - כולל phone לאימות מהלקוח
const completeProfileSchema = z.object({
  // --- הוספת שם פרטי ושם משפחה ---
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),
  // --- סוף הוספה ---
  phone: z.string().regex(/^0\d{9}$/, "Invalid phone number format (e.g., 0501234567)"),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });
  console.log("[API /api/auth/complete-profile] Request Headers:", JSON.stringify(headersObject, null, 2));

  // !!! הסר את זה בסביבת Production !!!
  // console.log("[API /api/auth/complete-profile] DEBUG: NEXTAUTH_SECRET value (first 5 chars):", process.env.NEXTAUTH_SECRET?.substring(0, 5) || "NOT SET");

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    console.log("[API /api/auth/complete-profile] Session object from getServerSession:", JSON.stringify(session, null, 2));

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);
    console.log(`[API /api/auth/complete-profile] User email from session: ${session.user.email}`);

    if (session.user.isPhoneVerified) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} phone is ALREADY verified according to session. Proceeding, but this might indicate a flow issue.`);
    }
    if (session.user.isProfileComplete) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} profile is ALREADY complete according to session. Proceeding, but this might indicate a flow issue.`);
    }

    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
        console.log("[API /api/auth/complete-profile] Request body parsed successfully:", JSON.stringify(body, null, 2));
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    const {
        // --- הוספת שם פרטי ושם משפחה ---
        firstName,
        lastName,
        // --- סוף הוספה ---
        phone,
        gender,
        birthDate,
        maritalStatus,
        height,
        occupation,
        education
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);
    console.log("[API /api/auth/complete-profile] Data to be saved:", JSON.stringify(validation.data, null, 2));

    const updatedUser = await prisma.$transaction(async (tx) => {
      console.log(`[API /api/auth/complete-profile] Inside transaction for user ${userId}. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted for user ${userId}.`);

      console.log(`[API /api/auth/complete-profile] Updating User record for user ${userId} (names, phone, isProfileComplete, status)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          // --- הוספת שם פרטי ושם משפחה ---
          firstName: firstName,
          lastName: lastName,
          // --- סוף הוספה ---
          phone: phone,
          isProfileComplete: true,
          // אם המשתמש מגיע לכאן, סביר להניח שאימות המייל הושלם (אם היה כזה).
          // לכן, הסטטוס צריך לעבור ל-PENDING_PHONE_VERIFICATION.
          // אם אימות הטלפון הוא אופציונלי או לא השלב הבא המיידי, ייתכן ו-ACTIVE הוא הסטטוס הנכון.
          status: UserStatus.PENDING_PHONE_VERIFICATION, // ודא שזה הסטטוס הנכון בהתאם לזרימה
          updatedAt: new Date(),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true
         }
      });
      console.log(`[API /api/auth/complete-profile] User record updated for user ${userId}. New profile status: isProfileComplete=${user.isProfileComplete}, isPhoneVerified=${user.isPhoneVerified}, status=${user.status}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    console.log("[API /api/auth/complete-profile] Returning success response with user data:", JSON.stringify({ message: "Profile completed successfully", user: updatedUser }, null, 2));
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error during processing:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Known Request Error - Code: ${error.code}`);
        console.error("[API /api/auth/complete-profile] Prisma Error Meta:", error.meta);
        console.error("[API /api/auth/complete-profile] Prisma Error Message:", error.message);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone') && target?.includes('User')) {
                 return NextResponse.json({ error: 'מספר טלפון זה כבר רשום במערכת.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error (Prisma Validation Error).' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- הוספה ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- סוף הוספה ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "קישור לא תקין או שפג תוקפו. אנא בקש מהשדכן לשלוח הזמנה חדשה." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // עדכון הסיסמה, סטטוס המשתמש, וסטטוס האימות בטרנזקציה אחת
    await prisma.$transaction(async (tx) => {
      // עדכון סיסמה, אימות מייל, וסטטוס המשתמש
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- הוספה ---
          isVerified: true, // המייל אומת מכיוון שהמשתמש הגיע מהקישור
          status: UserStatus.PENDING_PHONE_VERIFICATION, // העבר את המשתמש לשלב הבא
          // isProfileComplete נשאר false כי הוא עדיין צריך למלא פרטים
          // --- סוף הוספה ---
        },
      });

      // עדכון סטטוס האימות (הטוקן נוצל)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "החשבון הוגדר בהצלחה! כעת ניתן להתחבר עם הסיסמה החדשה." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "אירעה שגיאה בהגדרת החשבון." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `שגיאת מסד נתונים בעת מחיקת המשתמש (קוד: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || 'שגיאה במחיקת החשבון.', status: 400 };
    }

    return { message: 'אירעה שגיאה בלתי צפויה במחיקת החשבון.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. לא זוהתה סשן פעיל.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: 'החשבון נמחק בהצלחה.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: 'המשתמש המבוקש למחיקה לא נמצא.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: Request) {
  try {
    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "משתמש לא נמצא" },
        { status: 404 }
      );
    }

    // הוספת בדיקה: אם למשתמש אין סיסמה (למשל, נרשם דרך OAuth)
    if (!user.password) {
      return NextResponse.json(
        { error: "לא הוגדרה סיסמה לחשבון זה. ייתכן שנרשמת באמצעות שירות חיצוני." },
        { status: 400 }
      );
    }

    // בדיקת סיסמה נוכחית
    // כעת, user.password מובטח להיות string
    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "סיסמה נוכחית שגויה" },
        { status: 400 }
      );
    }

    // הצפנת הסיסמה החדשה
    const hashedNewPassword = await hash(newPassword, 12);

    // יצירת קוד אימות בן 6 ספרות באמצעות שירות האימות
    // שינוי שם הפונקציה והוספת פרמטר target
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email, // הוספת user.email כפרמטר target
      24 // תקף ל-24 שעות (expiresInHours)
    );

    // שמירת הסיסמה המוצפנת במטא-דאטה של האימות
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // שליחת מייל עם קוד האימות
    await emailService.sendPasswordReset(user.email, verification.token);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "שגיאה בתהליך שינוי הסיסמה" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/register/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, UserRole, UserStatus, Prisma, VerificationType, UserSource  } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 

const prisma = new PrismaClient();

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
    marketingConsent?: boolean;

};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
        // For now, we'll keep it.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  // --- START OF CHANGE ---
  marketingConsent?: boolean;
  // --- END OF CHANGE ---
}

function handleError(error: unknown): { message: string; status: number } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: 'משתמש עם כתובת אימייל זו כבר קיים במערכת.', status: 409 };
          }
          return { message: `משתמש עם פרטים אלה כבר קיים במערכת (קוד ${error.code}).`, status: 409 };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `שגיאת תלות בנתונים (שדה: ${fieldName || 'לא ידוע'}). אנא נסה שנית.`, status: 500};
        }
        case 'P2014': return { message: 'שגיאה בנתונים שהוזנו.', status: 400 };
        default: 
            return { message: `שגיאה בשמירת הנתונים (קוד שגיאת DB: ${error.code}).`, status: 500 };
      }
    }
    if (error instanceof Error) {
       if (error.message === 'משתמש עם כתובת אימייל זו כבר קיים במערכת.') {
           return { message: error.message, status: 409 };
       }
       if (['חסרים פרטים חובה', 'כתובת אימייל לא תקינה', 'הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר'].includes(error.message)) {
           return { message: error.message, status: 400 };
       }
       if (error.message.includes('אירעה שגיאה ביצירת קוד אימות') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: 'אירעה שגיאה ביצירת רשומת האימות עקב בעיית תלות. אנא נסה שנית.', status: 500 };
       }
      return { message: error.message, status: 400 }; 
    }
    return { message: 'אירעה שגיאה בלתי צפויה.', status: 500 };
}


export async function POST(req: Request) {
  logger.info('Initial registration process initiated');

  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password,
      // --- START OF CHANGE ---
      marketingConsent: body.marketingConsent,
      // --- END OF CHANGE ---
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('חסרים פרטים חובה');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('כתובת אימייל לא תקינה');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('הסיסמה חייבת להכיל לפחות 8 תווים, אות גדולה, אות קטנה ומספר');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('משתמש עם כתובת אימייל זו כבר קיים במערכת.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(),
            // --- START OF CHANGE ---
            marketingConsent: body.marketingConsent || false,
            // --- END OF CHANGE ---
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });
    
    let emailSentSuccess = false;
    const emailOtpExpiryText = "שעה אחת"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
      await emailService.sendVerificationEmail({
        email: result.user.email,
        verificationCode: result.generatedOtp, 
        firstName: result.user.firstName,
        expiresIn: emailOtpExpiryText 
      });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = 'החשבון נוצר בהצלחה. ';
    if (emailSentSuccess) {
        responseMessage += `נשלח קוד אימות לכתובת הדוא"ל שלך (${result.user.email}). אנא הזן את הקוד כדי להמשיך.`;
    } else {
        responseMessage += 'הייתה בעיה בשליחת קוד האימות. תוכל לבקש קוד חדש במסך הבא או לפנות לתמיכה.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { userId: result.user.id });
    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id, 
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType, UserStatus, VerificationStatus } from '@prisma/client'; // Added VerificationStatus
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

const prisma = new PrismaClient(); // Consider using your global prisma instance if you have one at @/lib/prisma

const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "כתובת מייל לא תקינה" }),
});

// Helper for logging (consistent with your existing logs)
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string; // <--- הוספה של המאפיין החסר
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus; // For logging user or verification status
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: Request) {
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined; // Define type for requestBody
  try {
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "כתובת מייל לא תקינה" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    logger.info('Processing password reset request', { action, email: normalizedEmail });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    const genericSuccessMessage = 'אם קיימת כתובת מייל זו במערכת וניתן לאפס עבורה סיסמה, קוד אימות נשלח כעת.';

    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING, // Use VerificationStatus enum
        },
        data: {
            status: VerificationStatus.EXPIRED, // Use VerificationStatus enum
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60
    );
    // Now this log line is valid because verificationId is in LogMetadata
    logger.info('Password reset OTP created in VerificationService', { action, userId: user.id, verificationId: passwordResetVerification.id });

    try {
      await emailService.sendPasswordResetOtpEmail({
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: `${expiresInMinutes} דקות`,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message, stack: (process.env.NODE_ENV === 'development' ? error.stack : undefined) } : String(error),
    });

    return NextResponse.json(
      { success: false, error: 'אירעה שגיאה בתהליך. אנא נסה שנית מאוחר יותר.' },
      { status: 500 }
    );
  } finally {
    // Only disconnect if prisma instance was created locally in this file
    // If using a global instance from @/lib/prisma, it's usually managed globally
    // await prisma.$disconnect().catch(e => logger.error('Failed to disconnect Prisma in request-password-reset', { error: e }));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Adjust path if needed
import prisma from '@/lib/prisma'; // Adjust path if needed
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService'; // Adjust path if needed
import { VerificationType } from '@prisma/client'; // Import necessary enums/types

// --- Configuration ---
// How long (in seconds) the user must wait between resend requests
const RESEND_RATE_LIMIT_SECONDS = 60;

// --- Helper: Logger (optional but recommended) ---
const logger = {
    info: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...(meta || {}) }));
    },
    warn: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...(meta || {}) }));
    },
    error: (message: string, meta?: Record<string, unknown> | object) => { // <-- שינוי הטיפוס
      // במקרה של שגיאה, נרצה אולי לטפל ב-meta בצורה שונה אם הוא אובייקט Error
      let logMeta = meta || {};
      if (meta instanceof Error) {
          // אם ה-meta הוא אובייקט Error, נרצה אולי לפרק אותו
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
  };
// --- End Helper ---


// --- Main POST Handler ---
export async function POST() {
    logger.info("Resend phone code request received");

    // 1. --- Authentication Check ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });
    // --- End Authentication Check ---

    try {
        // 2. --- Find Last Pending Verification ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING', // Only find codes that haven't been used, expired, or failed
            },
            orderBy: {
                createdAt: 'desc' // Get the most recent one if multiple exist (shouldn't happen often with cleanup)
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            // This could mean the user is already verified, the code expired and wasn't updated, etc.
            // Provide a generic message.
            return NextResponse.json({ error: 'לא נמצאה בקשת אימות פעילה. ייתכן שכבר אימתת את מספרך או שהקוד פג תוקף.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });
        // --- End Find Last Pending Verification ---


        // 3. --- Rate Limiting Check ---
        const now = new Date();
        // Use 'createdAt' as the timestamp of the last *send attempt* for pending codes
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: `אנא המתן ${timeLeft} שניות לפני בקשת קוד חדש.` }, { status: 429 }); // Too Many Requests
        }
        logger.info("Rate limit check passed", { userId });
        // --- End Rate Limiting Check ---


        // 4. --- Determine Target Phone and User Name ---
        // Initialize with 'let' to allow modification in fallback
        let targetPhone = lastVerification.target;
        // Try to get name from session first for personalization
        let userFirstName = session.user.firstName || ''; // Use empty string as fallback

        // Fallback: If target phone wasn't stored in verification, fetch from User model
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true } // Select only needed fields
             });
             if (!user?.phone) {
                // This is a more critical error, shouldn't happen if registration flow is correct
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                // Don't expose internal details, give a generic error
                return NextResponse.json({ error: 'שגיאה: לא ניתן לאתר את מספר הטלפון לשליחת הקוד.' }, { status: 500 });
             }
             targetPhone = user.phone; // Assign the fetched phone number
             userFirstName = user.firstName || ''; // Update first name if fetched
             logger.info("Successfully fetched phone number from user model as fallback", { userId });
        }

        // Final check to ensure we have a phone number
        if (!targetPhone) {
             logger.error(`Target phone is still null/undefined after fallback for user ${userId}.`);
             return NextResponse.json({ error: 'שגיאה: לא ניתן לקבוע את מספר הטלפון ליצירת קשר.' }, { status: 500 });
        }
        // --- End Determine Target Phone ---


        // 5. --- Generate New OTP ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // New 10-minute expiration
        logger.info("Generated new OTP", { userId });
        // --- End Generate New OTP ---


        // 6. --- Update Verification Record ---
        // Update the *existing* pending record with the new code, expiry, reset attempts, and timestamp
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // Reset attempts count for the new code
                createdAt: new Date() // Update timestamp to reflect this new send attempt (for rate limiting)
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });
        // --- End Update Verification Record ---


        // 7. --- Send New OTP via WhatsApp ---
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName // Pass name for personalization
        );

        if (!otpSent) {
            // Log the failure but still return a potentially helpful message to the user
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            // Let the user know there was an issue, maybe suggest trying again later
            return NextResponse.json({ error: 'שליחת קוד האימות החדש באמצעות WhatsApp נכשלה. אנא נסה שוב בעוד מספר רגעים.' }, { status: 500 });
        }
        // --- End Send New OTP ---


        // 8. --- Success Response ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: 'קוד אימות חדש נשלח בהצלחה באמצעות WhatsApp.' }, { status: 200 });
        // --- End Success Response ---

    } catch (error: unknown) { // Catch errors as unknown
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id, // Log userId if available
            error: error instanceof Error ? { name: error.name, message: error.message, stack: error.stack } : String(error)
        });
        // Return a generic server error response
        return NextResponse.json({ error: 'אירעה שגיאה פנימית בשרת. נסה שוב מאוחר יותר.' }, { status: 500 });
    } finally {
        // Disconnect Prisma client if necessary (depends on Prisma setup)
        // await prisma.$disconnect();
        // logger.info("Database connection closed (if applicable)");
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:

import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { randomBytes } from "crypto";
import { emailService } from "@/lib/email/emailService";
import { VerificationType } from "@prisma/client";

export async function POST(req: Request) {
  try {
    const { email, type } = await req.json();

    if (!email || !type) {
      return NextResponse.json(
        { error: "חסרים פרטים נדרשים" },
        { status: 400 }
      );
    }

    // מציאת המשתמש
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { error: "לא נמצא משתמש עם כתובת האימייל הזו" },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { error: "המשתמש כבר מאומת" },
        { status: 400 }
      );
    }

    // יצירת טוקן אימות חדש
    const verification = await prisma.verification.create({
      data: {
        userId: user.id,
        type: type as VerificationType,
        token: randomBytes(32).toString('hex'),
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // תוקף ל-24 שעות
        status: 'PENDING',
        attempts: 0
      }
    });

    // שליחת מייל אימות חדש
    // *** התיקון כאן: שימוש ב-verificationCode במקום verificationLink ***
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: verification.token, // שונה מ-verificationLink
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({
      success: true,
      message: "מייל אימות חדש נשלח בהצלחה"
    });

  } catch (error) {
    console.error('Resend verification error:', error);
    const errorMessage = error instanceof Error ? error.message : "שגיאה בשליחת מייל האימות";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-verification-code/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType, UserStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';

const prisma = new PrismaClient();

// Updated LogMetadata type
type LogMetadata = {
  email?: string;
  error?: unknown;
  timestamp?: string; // Note: logger already adds a timestamp. This allows overriding or adding a specific one.
  userId?: string;
  verificationId?: string; // Added to fix the error
  status?: UserStatus;     // Added for metadata in a logger.warn call
  isVerified?: boolean;    // Added for metadata in a logger.warn call
};

// Updated logger object with 'warn' method
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })) // Added 'warn' method
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: Request) {
  let requestBody: ResendCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });


    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: 'חסרה כתובת אימייל.' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    logger.info('Attempting to resend verification code', { email: normalizedEmail });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail }); // Now valid
      return NextResponse.json({ success: false, error: 'משתמש עם כתובת אימייל זו אינו רשום.' }, { status: 404 });
    }

    // ודא שהמשתמש עדיין צריך לאמת אימייל
    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        // This log call now correctly uses properties defined in LogMetadata
        logger.warn('User email already verified or not pending email verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: 'כתובת האימייל כבר מאומתת או שאינה ממתינה לאימות.' }, { status: 400 });
    }
    
    // יצירת קוד אימות חדש ושליחתו
    const expiresInHoursForOtp = 1; // תוקף של שעה
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email, // השתמש באימייל מהמשתמש (שכבר מנורמל)
      expiresInHoursForOtp
    );
    // This log call now correctly uses verificationId defined in LogMetadata
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });


    // שליחת המייל עם הקוד החדש
    const emailOtpExpiryText = "שעה אחת"; // התאם ל-expiresInHoursForOtp
    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    return NextResponse.json({
      success: true,
      message: `קוד אימות חדש נשלח לכתובת ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = 'אירעה שגיאה בשליחה חוזרת של הקוד.';
    const errorStatus = 500;

    if (error instanceof Error) {
        if (error.message === 'אירעה שגיאה ביצירת קוד אימות') {
            errorMessage = error.message; // השתמש בהודעה הספציפית מהשירות
        }
        // אפשר להוסיף טיפול בשגיאות ספציפיות אחרות משירות המייל למשל
    }
    

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect();
    logger.info('Database connection closed for resend-verification-code');
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient, VerificationType} from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService'; // For password change confirmation
import { hash } from 'bcryptjs';
import { z } from 'zod';

const prisma = new PrismaClient();

const resetPasswordSchema = z.object({
  email: z.string().email({ message: "כתובת מייל לא תקינה" }),
  otp: z.string().length(6, { message: "קוד האימות חייב להכיל 6 ספרות" }).regex(/^\d+$/, { message: "קוד אימות יכול להכיל ספרות בלבד" }),
  newPassword: z.string().min(8, { message: "הסיסמה חייבת להכיל לפחות 8 תווים" })
    .regex(/[a-z]/, { message: "הסיסמה חייבת להכיל לפחות אות קטנה אחת באנגלית" })
    .regex(/[A-Z]/, { message: "הסיסמה חייבת להכיל לפחות אות גדולה אחת באנגלית" })
    .regex(/[0-9]/, { message: "הסיסמה חייבת להכיל לפחות ספרה אחת" }),
});

// Helper for logging
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: Request) {
  const action = "reset-password-with-otp";
  let requestBody;

  try {
    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid input for password reset', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "נתונים לא תקינים.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];
      
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });

    // Step 1: Verify the OTP using VerificationService
    // This should not mark the verification as 'COMPLETED' yet for PASSWORD_RESET type.
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    // If verifyCode doesn't throw an error, it means the OTP is valid (not expired, not too many attempts, exists).
    // It returns { success: true, message: 'Code verified.', userId: '...', id: '...' }
    
   if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      // This scenario should ideally be handled by verifyCode throwing an error.
      // If verifyCode is changed to return success:false instead of throwing for some cases, handle here.
      logger.error('OTP verification failed or did not return expected data', { 
        action, 
        email: normalizedEmail, 
        error: verificationResult // Changed 'result' to 'error'
      });
      throw new Error(verificationResult.message || 'שגיאה באימות הקוד.');
    }
    
    const userId = verificationResult.userId;
    const verificationId = verificationResult.id; // ID of the verification record

    logger.info('OTP verified successfully for password reset', { action, email: normalizedEmail, userId, verificationId });

    // Step 2: Hash the new password
    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    // Step 3: Update the user's password in the database
    await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
        // Optional: Reset login attempts if you track them, or other security measures
      },
    });
    logger.info('User password updated in database', { action, userId });

    // Step 4: Explicitly mark the verification record as COMPLETED
    await VerificationService.completeVerification(verificationId);
    logger.info('Password reset verification record marked as completed', { action, verificationId });

    // Step 5: Optional - Send password change confirmation email
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { email: true, firstName: true } });
    if (user) {
        try {
            await emailService.sendPasswordChangedConfirmationEmail({
                email: user.email,
                firstName: user.firstName,
            });
            logger.info('Password change confirmation email sent', { action, userId });
        } catch (emailError) {
            logger.error('Failed to send password change confirmation email', {
                action,
                userId,
                error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
            });
            // Non-critical error for the overall success of password reset, proceed
        }
    }

    return NextResponse.json({ success: true, message: 'הסיסמה אופסה בהצלחה. כעת תוכל להתחבר עם הסיסמה החדשה.' }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = typeof requestBody === 'object' && requestBody && 'email' in requestBody ? String(requestBody.email) : undefined;
    logger.error('Error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message, stack: (process.env.NODE_ENV === 'development' ? error.stack : undefined) } : String(error),
    });

    let errorMessage = 'אירעה שגיאה באיפוס הסיסמה.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        'הקוד כבר נוצל.', // This shouldn't happen if completeVerification is called after successful password update.
        'תוקף הקוד פג. אנא בקש קוד חדש.',
        'קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.',
        'קוד אימות שגוי.',
        'חרגת ממספר ניסיונות האימות המותר. אנא בקש קוד חדש.',
        'שגיאה פנימית: אימות הקוד הצליח אך לא נמצא משתמש משויך.',
        'שגיאה פנימית: רשומת האימות אינה משויכת למשתמש.' // from verifyCode
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
        if (error.message.includes("פג תוקפו")) errorStatus = 410; // Gone
        if (error.message.includes("חרגת ממספר ניסיונות")) errorStatus = 429; // Too Many Requests
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => logger.error('Failed to disconnect Prisma in reset-password API', { error: e }));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST() {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. קבל את פרטי המשתמש מה-DB (בעיקר מספר הטלפון)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // שגיאה זו לא אמורה לקרות אם המשתמש הגיע לכאן דרך השלמת פרופיל
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. יצירת OTP חדש
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 דקות תפוגה

        // 3. שמירת/עדכון רשומת האימות
        // מחק רשומות קודמות לאותו משתמש כדי למנוע בלבול
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // צור רשומה חדשה
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. שליחת ה-OTP בוואטסאפ
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // החזר שגיאה כדי שהקליינט יוכל להציג הודעה מתאימה
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
export const runtime = 'nodejs';

import { NextResponse } from "next/server";
import { PrismaClient, VerificationType } from "@prisma/client";
import { generateToken } from "@/lib/tokens";
import { emailService } from "@/lib/email/emailService";

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { email } = await req.json();
    
    if (!email) {
      return NextResponse.json({ error: "אימייל הוא שדה חובה" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return NextResponse.json({ error: "משתמש לא נמצא" }, { status: 404 });
    }

    await prisma.verification.updateMany({
      where: {
        userId: user.id,
        type: VerificationType.EMAIL,
        status: "PENDING"
      },
      data: { status: "EXPIRED" }
    });

    const token = await generateToken();
    const verification = await prisma.verification.create({
      data: {
        token,
        userId: user.id,
        type: VerificationType.EMAIL,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
        status: "PENDING"
      }
    });

    await emailService.sendVerificationEmail({
      email: user.email,
      verificationCode: verification.token, // Changed from verificationLink to verificationCode
      firstName: user.firstName,
      expiresIn: '24 שעות'
    });

    return NextResponse.json({ success: true }, { status: 200 });

  } catch (error) {
    console.error('Error sending verification:', error);
    return NextResponse.json({ error: "שגיאה בשליחת קוד האימות" }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().regex(/^0\d{9}$/, "Invalid phone number format (e.g., 0501234567)"),
});

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. בדוק שהמספר החדש לא תפוס על ידי משתמש מאומת אחר
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } // לא המשתמש הנוכחי
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: 'מספר הטלפון כבר רשום ופעיל במערכת עבור משתמש אחר.' }, { status: 409 }); // Conflict
          }

        // 2. עדכן את מספר הטלפון של המשתמש
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // קח את השם המעודכן אם צריך
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. צור OTP חדש
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 דקות תפוגה

        // 4. צור/עדכן רשומת אימות עבור המספר החדש
        // בטל רשומות קודמות אם היו
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // סמן קודמים כפגי תוקף
         });
         // צור רשומה חדשה
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // המספר החדש
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. שלח את ה-OTP למספר החדש
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // החזר שגיאה, ייתכן שהמספר החדש לא תקין בוואטסאפ
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // הגדרת error כ-unknown
        console.error("API update-and-resend: An error occurred:", error);

        // טיפול בשגיאות ספציפיות
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // שגיאת כפילות - למרות שבדקנו, ייתכן מצב race condition
            return NextResponse.json({ error: 'מספר הטלפון כבר רשום במערכת.' }, { status: 409 });
        }

        // שגיאה כללית
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextResponse } from 'next/server';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId כאן יכול להיות string או undefined אם הוא לא קיים במטאדאטה
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: Request) {
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: 'חסרים פרטי אימייל או קוד.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `פורמט קוד לא תקין. הקוד צריך להכיל ${OTP_LENGTH_FROM_SERVICE} ספרות.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- התיקון מתחיל כאן ---
    // וודא ש-userId קיים והוא מחרוזת לפני שנמשיך
    // סביר להניח ש-verificationResult.userId יכול להיות string | null
    // על פי ההגדרה של VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // זרוק שגיאה שתטופל בלוק ה-catch הכללי, או טפל בה באופן ספציפי יותר
      // שגיאה זו מצביעה על בעיה לוגית פנימית אם הקוד אומת אך אין משתמש משויך
      throw new Error('שגיאה פנימית: לא נמצא משתמש משויך לאימות לאחר אימות קוד מוצלח.');
    }
    
    // כעת, לאחר הבדיקה, TypeScript יכול להסיק (או שנוכל להצהיר במפורש)
    // ש-userId הוא string.
    const userId: string = verificationResult.userId; 
    // --- סוף התיקון ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, // כאן userId מובטח להיות string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: 'כתובת האימייל אומתה בהצלחה! מתבצעת התחברות אוטומטית...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = 'אירעה שגיאה באימות הקוד.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        'הקוד כבר נוצל.', 
        'תוקף הקוד פג. אנא בקש קוד חדש.', 
        'קוד אימות לא תקין או שלא קיימת בקשת אימות פעילה.', 
        'קוד אימות שגוי.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === 'שגיאה פנימית: לא נמצא משתמש משויך לאימות.' || 
                 error.message === 'שגיאה פנימית: לא נמצא משתמש משויך לאימות לאחר אימות קוד מוצלח.') { // הוספת השגיאה החדשה אם רוצים טיפול מיוחד
        errorMessage = 'אירעה שגיאה פנימית. אנא נסה שנית מאוחר יותר.';
        // errorStatus נשאר 500 כברירת מחדל לשגיאות פנימיות, או שתשנה לפי הצורך
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-phone-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus } from '@prisma/client';
import { z } from 'zod';

const verifyCodeSchema = z.object({
  code: z.string().length(6, "Verification code must be 6 digits").regex(/^\d+$/, "Invalid code format"),
});

// Define Max Attempts
const MAX_VERIFICATION_ATTEMPTS = 5;

export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = verifyCodeSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { code } = validation.data;

        // 1. מצא את רשומת האימות הרלוונטית
        const verification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc' // קח את הרשומה האחרונה
            }
        });

        if (!verification) {
            return NextResponse.json({ error: 'No pending verification found or already verified.' }, { status: 404 });
        }

        // 2. בדוק אם פג תוקף
        if (new Date() > verification.expiresAt) {
            // עדכן את סטטוס הרשומה ל-EXPIRED
            await prisma.verification.update({
                where: { id: verification.id },
                data: { status: 'EXPIRED' }
            });
            return NextResponse.json({ error: 'Verification code expired.' }, { status: 410 }); // 410 Gone
        }

        // 3. בדוק מספר ניסיונות
        if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
             // עדכן סטטוס ל-FAILED אם עבר את המגבלה
            await prisma.verification.update({
                where: { id: verification.id },
                data: { status: 'FAILED' }
            });
            return NextResponse.json({ error: 'Too many verification attempts.' }, { status: 429 }); // 429 Too Many Requests
        }

        // 4. השווה את הקודים
        if (verification.token !== code) {
            // עדכן מספר ניסיונות
            await prisma.verification.update({
                where: { id: verification.id },
                data: { attempts: { increment: 1 } }
            });
            const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - (verification.attempts + 1);
            return NextResponse.json({ error: `Invalid verification code. ${attemptsLeft} attempts remaining.` }, { status: 400 });
        }

        // 5. אימות הצליח! עדכן את המשתמש ואת רשומת האימות
        const [, updatedUser] = await prisma.$transaction([
            prisma.verification.update({
                where: { id: verification.id },
                data: {
                    status: 'COMPLETED',
                    completedAt: new Date(),
                    attempts: verification.attempts + 1
                 }
            }),
            prisma.user.update({
                where: { id: userId },
                data: {
                    isPhoneVerified: true,
                    isProfileComplete: true, // לאחר אימות טלפון, הפרופיל נחשב שלם
                    status: UserStatus.ACTIVE, // הפוך את המשתמש לפעיל
                    updatedAt: new Date(),
                },
                select: { // החזר רק את המידע הנדרש לעדכון הסשן
                    id: true,
                    isPhoneVerified: true,
                    isProfileComplete: true,
                    status: true,
                 }
            })
        ]);

        console.log(`API verify-phone-code: Phone verified successfully for user ${userId}`);

        // החזר את פרטי המשתמש המעודכנים כדי שהקליינט יוכל לעדכן את הסשן
        return NextResponse.json({
             message: 'Phone number verified successfully!',
             user: updatedUser // מכיל isPhoneVerified, isProfileComplete, status
             }, { status: 200 });

    } catch (error) {
        console.error("API verify-phone-code: An error occurred:", error);
        if (error instanceof z.ZodError) { // Catch potential Zod errors during validation
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability\check
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability\check\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/availability/check/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { clientId } = await req.json();

    const result = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId: clientId,
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error("Error checking availability:", error);
    return NextResponse.json(
      { error: "Failed to check availability" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\chat
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\chat\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} from '@google/generative-ai';
import nodemailer from 'nodemailer';

// --- START: Updated Knowledge Base ---
// מאגר הידע נכתב מחדש כדי לשקף את קול המותג: מקצועי, חם, ממוקד-יתרון ובונה אמון.
const knowledgeBase = [
  {
    question: "מה זה NeshamaTech? מה אתם עושים?",
    answer:
      "NeshamaTech היא פלטפורמת שידוכים שנוסדה מתוך הבנה עמוקה של האתגרים בעולם הדייטים המודרני. אנחנו משלבים טכנולוגיה חכמה עם ליווי אנושי וחם של צוות שדכנים, כדי ליצור חיבורים רציניים ומשמעותיים.\n\nהמטרה שלנו היא להחזיר את העומק והכבוד לתהליך ההיכרות, ולאפשר לכם לפגוש אנשים על בסיס התאמה אמיתית של אישיות וערכים, ולא רק על סמך תמונה."
  },
  {
    question: "מה השיטה שלכם? איך התהליך עובד?",
    answer:
      "השיטה שלנו בנויה על שלושה יסודות: עומק, טכנולוגיה וליווי אישי.\n\n1.  **היכרות מעמיקה:** התהליך מתחיל עם שאלון 'חמשת העולמות' הייחודי שלנו. זה לא מבחן, אלא מסע היכרות אישי שבו אתם משתפים אותנו בתפיסות עולמכם ובמה שחשוב לכם.\n\n2.  **טכנולוגיה בשירות הלב:** המערכת החכמה שלנו מנתחת את המידע ומאתרת מתוך מאגר רחב את האנשים בעלי פוטנציאל ההתאמה הגבוה ביותר עבורכם.\n\n3.  **ליווי ושיקול דעת אנושי:** כל הצעה פוטנציאלית עוברת בדיקה ואישור של שדכן אישי. תקבלו רק הצעות מנומקות, כאלו שאנחנו מאמינים בהן. השדכן גם מלווה אתכם לאורך כל הדרך, והכל בדיסקרטיות מוחלטת."
  },
  {
    question: 'במה אתם שונים מאפליקציות היכרויות או משדכנים רגילים?',
    answer:
      "זו שאלה מצוינת. אנחנו משלבים את הטוב משני העולמות:\n\n*   **מול אפליקציות:** אנחנו מציעים דיסקרטיות מלאה (הפרופיל שלכם לא חשוף לכל), חוסכים לכם את זמן החיפוש (אנחנו עובדים בשבילכם), והמטרה שלנו היא שתמצאו זוגיות ותעזבו אותנו.\n\n*   **מול שדכנות מסורתית:** אנחנו משתמשים בטכנולוגיה כדי לגשת למאגר גדול ורחב הרבה יותר, מה שמגדיל את סיכויי ההצלחה, תוך שמירה על הליווי האישי והיכולת לראות את מה שמעבר לנתונים היבשים.\n\nבמילים פשוטות, אנחנו שדכנות אישית בעידן הדיגיטלי."
  },
  {
      question: 'איך הפרטיות שלי נשמרת? מי רואה את המידע שלי?',
      answer: "הפרטיות והדיסקרטיות שלכם הן ערך עליון עבורנו. זו הבטחה. הפרופיל שלכם חשוף אך ורק לצוות השדכנים המצומצם שמטפל בכם. הוא אינו חשוף למשתמשים אחרים. כאשר אנחנו מזהים התאמה, אנו מציגים לכל צד פרופיל מפורט ומכבד של הצד השני, וזאת רק לאחר שקיבלנו את אישורכם המפורש. אתם תמיד בשליטה מלאה על המידע שלכם."
  },
  {
    question: 'מה העלות של השירות? כמה זה עולה?',
    answer:
      'כחלק מתקופת ההשקה והרצון שלנו לבנות קהילה איכותית, השירות כרגע מוצע **ללא עלות**. ההרשמה, מילוי הפרופיל והשאלון, וקבלת הצעות - הכל ללא תשלום.\n\nחשוב להדגיש: בשלב זה, **אין אצלנו "דמי הצלחה" כלל**, גם אם תתארסו דרכנו. המטרה שלנו היא שתכירו את הגישה הייחודית שלנו ללא מחסומים. בעתיד, ייתכן שנוסיף מסלולי פרימיום או מודל אחר, אך כל שינוי כזה יהיה כפוף לעדכון תנאי השימוש ולקבלת הסכמתכם המחודשת.'
  },
  {
    question: 'מה הסיכוי שלי למצוא התאמה וכמה זמן זה לוקח?',
    answer:
      "זו שאלה חשובה. אין לוח זמנים מדויק לאהבה, אך הגישה הממוקדת שלנו חוסכת זמן יקר ואנרגיה רגשית. במקום מאות שיחות שטחיות, תקבלו מספר מצומצם של הצעות איכותיות ומנומקות. המטרה היא איכות על פני כמות, כדי שכל הצעה תהיה משמעותית."
  },
  {
    question: 'איך הבינה המלאכותית (AI) עוזרת לי?',
    answer:
      "ה-AI הוא כלי עזר חכם גם עבורכם וגם עבור השדכנים שלנו. לשדכנים, הוא מסייע בניתוח מעמיק של פרופילים כדי לזהות דפוסי התאמה נסתרים. עבורכם, המערכת יכולה להציע תובנות לשיפור הפרופיל, ולסייע לכם להתייעץ לגבי הצעות שתקבלו כדי להבין טוב יותר את נקודות החוזק בהתאמה."
  },
  {
    question: 'למי השירות מיועד?',
    answer:
      'השירות שלנו מיועד לרווקים ורווקות מהקהילה היהודית המחפשים קשר רציני המוביל לחתונה. בשלב זה, אנו מתמקדים בעיקר בקהל הדתי-לאומי והאקדמי בישראל, אך פתוחים לכל מי שמתחבר לגישה המעמיקה והמכבדת שלנו. המערכת מיועדת כרגע לשידוכים בין גברים לנשים (סטרייטים) בלבד.'
  }
];
// --- END: Updated Knowledge Base ---

const knowledgeContext = knowledgeBase
  .map((item) => `שאלה: ${item.question}\nתשובה: ${item.answer}`)
  .join('\n\n');

if (!process.env.GOOGLE_API_KEY) {
  console.error('[CHAT API ERROR] GOOGLE_API_KEY is not defined!');
}

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);

const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
];

export async function POST(req: NextRequest) {
  try {
    const { message, type, userEmail } = await req.json();

    if (!message || typeof message !== 'string') {
      return NextResponse.json({ error: 'Message is required' }, { status: 400 });
    }

    if (type === 'email') {
      if (!userEmail || typeof userEmail !== 'string') {
        return NextResponse.json({ error: 'User email is required' }, { status: 400 });
      }

      const transporter = nodemailer.createTransport({
        service: process.env.EMAIL_SERVICE || 'gmail',
        auth: {
          user: process.env.GMAIL_USER || process.env.EMAIL_USER,
          pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
        },
        tls: { rejectUnauthorized: process.env.NODE_ENV === 'production' },
      });

      const mailOptions = {
        from: `"${process.env.EMAIL_FROM_NAME || 'NeshamaTech Chatbot'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to: 'jewish.matchpoint@gmail.com',
        subject: `פנייה חדשה מהצ'אט באתר: ${userEmail}`,
        replyTo: userEmail,
        html: `
          <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6; color: #333;">
            <h2 style="color: #0891b2;">פנייה חדשה מהצ'אט-בוט באתר NeshamaTech:</h2>
            <p><strong>מאת:</strong> <a href="mailto:${userEmail}">${userEmail}</a></p>
            <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
              <p style="margin: 0;">${message.replace(/\n/g, '<br>')}</p>
            </div>
            <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
              זוהי הודעה אוטומטית. ניתן להשיב למייל זה ישירות כדי לענות לפונה.
            </p>
          </div>
        `,
      };

      await transporter.sendMail(mailOptions);
      return NextResponse.json({
        reply: 'תודה רבה! פנייתך נשלחה בהצלחה. אחד מאנשי הצוות שלנו יחזור אליך באופן אישי בהקדם האפשרי.',
      });
    }

    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash', safetySettings });

    // --- START: Upgraded Prompt ---
    const prompt = `
      **הפרסונה שלך:**
      אתה "העוזר האישי" של NeshamaTech. אתה הנקודה הראשונה במגע עם משתמשים פוטנציאליים שמחפשים קשר רציני. הטון שלך הוא כמו של איש מקצוע ותיק, חם ומהימן.
      - **מקצועי ומרגיע:** השתמש בשפה ברורה, מכבדת ובוטחת. דבר בגובה העיניים.
      - **אמפתי ומבין:** הכר באתגרים של עולם הדייטים, אך הצע תקווה ודרך פעולה.
      - **אמין ודיסקרטי:** הדגש תמיד את חשיבות הפרטיות והאמון.
      - **ממוקד-ערך:** הסבר לא רק *מה* אנחנו עושים, אלא *למה* זה טוב ומועיל למשתמש.
      - **דובר עברית רהוטה וטבעית בלבד.**

      **הכללים המחייבים שלך:**
      1.  **התבסס אך ורק על מאגר הידע:** אל תמציא מידע בשום אופן. כל תשובה חייבת לנבוע ישירות מהטקסט שסופק לך.
      2.  **אל תבטיח הבטחות:** הימנע מהבטחות כמו "תמצא אהבה". במקום זאת, דבר על "הגדלת הסיכויים", "תהליך יעיל", ו"חיבורים משמעותיים".
      3.  **זיהוי שאלה מחוץ למאגר:** אם השאלה אינה מכוסה במאגר הידע, עליך להשיב באמפתיה ובצורה שירותית. ענה: "זו שאלה חשובה שראויה לתשובה אישית מהצוות שלנו. אין לי מידע מדויק על כך במערכת, אך אני יכול להעביר את פנייתך ישירות לאחד השדכנים. האם תרצה/י לשלוח להם פנייה במייל?".
      4.  **פרשנות שאלות:** הבן את כוונת המשתמש. "כמה עולה" -> התייחס לעלות. "איך זה עובד" -> התייחס לשיטה. "האם זה בטוח?" -> התייחס לפרטיות.
      5.  **הימנע מסופרלטיבים:** אל תגיד "אנחנו הכי טובים". במקום, הסבר *מדוע* הגישה שלנו ייחודית ומועילה.

      --- מאגר הידע המלא (האמת המוחלטת שלך) ---
      ${knowledgeContext}
      --- סוף מאגר הידע ---

      **הבקשה:**
      ענה על שאלת המשתמש הבאה, בהתבסס על הפרסונה והכללים המחמירים שהוגדרו לך.

      שאלת המשתמש: "${message}"

      תשובה בעברית:
    `;
    // --- END: Upgraded Prompt ---

    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text();

    const isFallback = text.includes('לשלוח להם פנייה במייל');

    if (isFallback) {
      return NextResponse.json({
        reply: text,
        isFallback: true,
        actions: [{ type: 'email', label: 'כן, אשמח לשלוח פנייה לצוות' }],
      });
    }

    return NextResponse.json({ reply: text, isFallback: false });
  } catch (error) {
    console.error('Error in /api/chat route:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { error: 'Internal Server Error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/contact/route.ts
import { NextRequest, NextResponse } from "next/server";
import nodemailer from 'nodemailer';
import { z } from 'zod';

// Zod schema for validating the contact form data
const contactSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters long" }),
  email: z.string().email({ message: "Invalid email address" }),
  message: z.string().min(10, { message: "Message must be at least 10 characters long" }),
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Validate the request body
    const validationResult = contactSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: "Invalid input", details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { name, email, message } = validationResult.data;

    // Configure the email transporter using environment variables
    const transporter = nodemailer.createTransport({
      service: process.env.EMAIL_SERVICE || 'gmail',
      auth: {
        user: process.env.GMAIL_USER || process.env.EMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
      },
      tls: {
        rejectUnauthorized: process.env.NODE_ENV === 'production',
      }
    });

    // Define the email options
    const mailOptions = {
      from: `"${process.env.EMAIL_FROM_NAME || 'Match Point Contact Form'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
      to: "jewish.matchpoint@gmail.com", // Your support/admin email address
      subject: `פנייה חדשה מאתר Match Point - ${name}`,
      replyTo: email, // This allows you to reply directly to the user
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6;">
          <h2 style="color: #0891b2;">התקבלה הודעה חדשה מטופס יצירת הקשר באתר:</h2>
          <p><strong>מאת:</strong> ${name} (<a href="mailto:${email}">${email}</a>)</p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;" />
          <h3 style="color: #333;">תוכן ההודעה:</h3>
          <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
            <p style="margin: 0; white-space: pre-wrap;">${message.replace(/\n/g, '<br>')}</p>
          </div>
          <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
            זוהי הודעה אוטומטית. ניתן להשיב למייל זה ישירות כדי לענות לפונה.
          </p>
        </div>
      `,
    };

    // Send the email
    await transporter.sendMail(mailOptions);

    // Return a success response
    return NextResponse.json({ success: true, message: "ההודעה נשלחה בהצלחה." });

  } catch (error) {
    console.error("Error in /api/contact route:", error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal Server Error", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
# Generated on: 2025-08-11 08:21:25
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';
export const dynamic = 'force-dynamic';
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });

    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client"; // הוספתי Prisma עבור סוגי שגיאות
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. ייבוא
export const dynamic = 'force-dynamic';
// פונקציית GET הקיימת שלך
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker or admin
    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true, // Added to fetch candidate's role
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }] // Main image first
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: { // Include user basic details
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role, // Include role in user object
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

// פונקציית PATCH הקיימת שלך
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // Only Matchmakers or Admins can edit
    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const { id: candidateIdToUpdate } = params; // ID of the candidate to update

    const candidateExists = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true } // Fetch role to prevent non-admins from editing admins
    });

    if (!candidateExists) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Prevent non-admin matchmakers from editing admin profiles (if desired)
    if (candidateExists.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }


    const profileData = await req.json();

    // Ensure numeric fields are numbers or null
    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    numericFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        } else if (profileData[field] !== null) {
            profileData[field] = parseInt(profileData[field], 10);
            if (isNaN(profileData[field])) {
                // Or throw an error if invalid number is critical
                console.warn(`Invalid number for ${field}: ${profileData[field]}, setting to null`);
                profileData[field] = null;
            }
        }
    });
    
    // Ensure enum fields are valid enum values or null
    const enumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney'];
    enumFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        }
        // Add specific enum validation here if needed, though Prisma handles this on write
    });

    // Ensure boolean fields are booleans or null
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious', 'preferredHasChildrenFromPrevious', 'isProfileVisible'];
    booleanFields.forEach(field => {
        if (profileData[field] === undefined) {
            profileData[field] = null; // Or a default boolean if appropriate
        } else if (typeof profileData[field] !== 'boolean' && profileData[field] !== null) {
             // Attempt to convert common string representations
            if (profileData[field] === 'true') profileData[field] = true;
            else if (profileData[field] === 'false') profileData[field] = false;
            else profileData[field] = null; // Default to null if not clearly boolean
        }
    });

    // Ensure array fields are arrays
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    arrayFields.forEach(field => {
        if (profileData[field] === undefined || profileData[field] === null) {
            profileData[field] = []; // Default to empty array
        } else if (!Array.isArray(profileData[field])) {
            console.warn(`Field ${field} is not an array, attempting to convert or defaulting to empty.`);
            // Basic attempt to convert comma-separated string or single value to array
            if (typeof profileData[field] === 'string' && profileData[field].includes(',')) {
                profileData[field] = profileData[field].split(',').map((s: string) => s.trim());
            } else if (typeof profileData[field] === 'string' && profileData[field].trim() !== '') {
                 profileData[field] = [profileData[field].trim()];
            } else {
                profileData[field] = [];
            }
        }
    });
    
    // Separate data for User model and Profile model if needed,
    // but current PATCH seems to only update Profile.

    const updatedProfile = await prisma.profile.update({
      where: { userId: candidateIdToUpdate },
      data: {
        ...profileData,
        updatedAt: new Date(), // Explicitly set updatedAt
        lastActive: new Date() // Also update lastActive
      }
    });
  // --- START OF NEW CODE ---
    // 2. הפעלת עדכון פרופיל ה-AI ברקע עבור המועמד שעודכן
    updateUserAiProfile(candidateIdToUpdate).catch(err => {
        console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
    });
    // --- END OF NEW CODE ---
    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });
  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        // Handle specific Prisma errors
        if (error.code === 'P2002') { // Unique constraint failed
            errorMessage = `שגיאה: נראה שאחד השדות שהזנת (כמו מייל או טלפון אם רלוונטי לפרופיל) כבר קיים במערכת עבור משתמש אחר. (${error.meta?.target})`;
            statusCode = 409; // Conflict
        } else if (error.code === 'P2025') { // Record to update not found
            errorMessage = "הפרופיל או המועמד המבוקש לעדכון לא נמצא.";
            statusCode = 404;
        } else {
            errorMessage = `שגיאת מסד נתונים (קוד ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        errorMessage = `שגיאת ולידציה בעדכון הפרופיל: ${error.message}`;
        statusCode = 400; // Bad Request
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

// פונקציית DELETE החדשה
export async function DELETE(
  req: NextRequest, // NextRequest is fine here, not used for body
  { params }: { params: { id: string } }
) {
  const candidateIdToDelete = params.id; // Changed from params.candidateId to params.id to match your GET/PATCH
  const timestamp = new Date().toISOString();
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. לא זוהתה סשן פעיל או הרשאה.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  // Only ADMINs can delete candidates
  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. נדרשת הרשאת אדמין.' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: 'מזהה מועמד (candidateId) חסר.' },
        { status: 400 }
    );
  }

  // Prevent admin from deleting themselves via this endpoint
  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: 'מנהל אינו יכול למחוק את חשבונו האישי דרך ממשק זה. השתמש בהגדרות חשבון אישיות.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true } // Select role to log and potentially prevent deleting other admins
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: 'המועמד המבוקש למחיקה לא נמצא.' },
        { status: 404 }
      );
    }

    // Optional: Prevent an admin from deleting another admin (unless explicitly allowed)
    // if (candidateToDelete.role === UserRole.ADMIN) {
    //   console.warn(`[${timestamp}] Admin ${performingUserId} attempting to delete another Admin ${candidateToDelete.id} (${candidateToDelete.email}). This might be restricted.`);
    //   return NextResponse.json(
    //     { success: false, error: 'לא ניתן למחוק חשבון אדמין אחר דרך ממשק זה כרגע.' },
    //     { status: 403 }
    //   );
    // }

    // onDelete: Cascade in your schema should handle related data (Profile, Images, Accounts, etc.)
    // Verify this carefully for all related models.
    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: 'המועמד נמחק בהצלחה.' },
      { status: 200 } // OK
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') { // Record to delete not found.
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: 'המועמד המבוקש למחיקה לא נמצא (שגיאת Prisma).'},
                { status: 404 }
            );
        }
        // Log other Prisma known errors
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `שגיאת מסד נתונים במחיקת המועמד (קוד: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `שגיאת ולידציה במחיקת המועמד: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : 'שגיאה לא ידועה בעת מחיקת המועמד.';
    return NextResponse.json(
      {
        success: false,
        error: 'אירעה שגיאה במחיקת המועמד. נסה שוב מאוחר יותר.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

// טייפ פשוט לתוצאה
type UploadResult = {
  secure_url: string;
  public_id: string;
};

// Check for required environment variables
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Validate environment variables
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    // Convert to buffer
    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload using cloudinary.uploader.upload with string transformation
    // זה עוקף את בעיות הטייפים לגמרי
  // אם עדיין יש בעיות, השתמש בזה:
    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        // עוקף את בעיות הטייפים עם type assertion
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client"; // ודא ש-ADMIN מוגדר כאן ב-enum שלך
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Check if required environment variables are set
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: cloudName as string,
  api_key: apiKey as string,
  api_secret: apiSecret as string,
});

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CORRECTED CODE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN]; // Explicitly type the array

    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CORRECTED CODE ----

    // Get params
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Find the image
    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    // Check if this is the main image and there are other images
    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      // If there are other images, set the most recent one as main
      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
        // Continue with DB deletion even if Cloudinary fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get params
    const { id, imageId } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Verify image exists and belongs to candidate
    const imageToSetMain = await prisma.userImage.findFirst({ // Renamed variable for clarity
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) { // Used the new variable name
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    // Start a transaction to update main image
    await prisma.$transaction([
      // First, unset all other images as main for this user
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId } // Don't unset the one we are about to set
        },
        data: { isMain: false }
      }),
      
      // Then, set the specified image as main
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";

export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "כתובת אימייל תקינה היא שדה חובה." }, { status: 400 });
    }

    const normalizedEmail = email.toLowerCase();

    // Find the candidate to invite. We fetch their current email to compare.
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    // If the candidate's email is already the one we're trying to set,
    // we can just resend the invite without a DB update.
    if (candidate.email === normalizedEmail) {
        // Here, we can just resend the invite. For simplicity, we'll proceed,
        // but a dedicated "resend" logic would be cleaner.
        console.log(`Email ${normalizedEmail} is already set for candidate ${candidateId}. Proceeding to send invite.`);
    }

    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      72 // Token valid for 72 hours
    );

    // This transaction will now attempt to update the email.
    // The catch block below will handle the unique constraint violation if it occurs.
    await prisma.$transaction(async (tx) => {
      // Only update the email if it's different from the current one.
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }

      // Invalidate previous setup tokens for this user
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id },
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    // Send the email with the correct token
    await emailService.sendAccountSetupEmail({
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "השדכן/ית שלך",
      setupToken: setupToken,
      expiresIn: "3 ימים",
    });

    return NextResponse.json({ success: true, message: "הזמנה להגדרת חשבון נשלחה בהצלחה." });

  } catch (error) {
    console.error("Error sending account setup invite:", error);
    
    // --- START: Enhanced Error Handling ---
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // Check for unique constraint violation (P2002)
      if (error.code === 'P2002') {
        // The 'target' field in the error metadata tells us which field caused the violation.
        const target = error.meta?.target as string[] | undefined;
        if (target?.includes('email')) {
          return NextResponse.json(
            { success: false, error: "כתובת אימייל זו כבר משויכת לחשבון אחר." },
            { status: 409 } // 409 Conflict is the appropriate status code
          );
        }
      }
      // Handle other potential database errors
      return NextResponse.json({ success: false, error: "שגיאת מסד נתונים." }, { status: 500 });
    }
    // --- END: Enhanced Error Handling ---

    let errorMessage = "An unexpected error occurred.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

// Define the type for Cloudinary upload result for clarity
type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// Helper function to upload image to Cloudinary
async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await request.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "משתמש עם כתובת אימייל זו כבר קיים במערכת." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
   status: UserStatus.PENDING_EMAIL_VERIFICATION, // הסטטוס הנכון. המשתמש צריך לפעול על המייל כדי להמשיך
    isVerified: false,                             // המייל עדיין לא אומת
    isProfileComplete: false,                      // הפרופיל בהחלט לא שלם
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: {
            gender,
            birthDate,
            birthDateIsApproximate,
            manualEntryText,
            availabilityStatus: 'AVAILABLE',
          },
        },
      },
      include: {
        profile: true,
      },
    });

    // --- START OF FIX ---
    // 1. Define the type for the image data objects that will be created.
    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    // 2. Explicitly type the array upon initialization to avoid the 'never[]' type inference.
    const uploadedImageData: UserImageCreateInput[] = [];
    // --- END OF FIX ---

    if (images && images.length > 0) {
      // (Optional but good practice) File validation loop
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) { // 5MB limit
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          // 3. Push an object that matches the defined type.
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        // 4. The `createMany` call is now simpler and type-safe.
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for candidates_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';
export const dynamic = 'force-dynamic';
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });

    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
export const dynamic = 'force-dynamic';

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const { id: candidateIdToUpdate } = params;

    const candidateExists = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true }
    });

    if (!candidateExists) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateExists.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const profileData = await req.json();

    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    numericFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        } else if (profileData[field] !== null) {
            profileData[field] = parseInt(profileData[field], 10);
            if (isNaN(profileData[field])) {
                console.warn(`Invalid number for ${field}: ${profileData[field]}, setting to null`);
                profileData[field] = null;
            }
        }
    });
    
    // --- START: הוספת שדות מקצוע הורים לרשימת העיבוד ---
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation'];
    // --- END: הוספת שדות מקצוע הורים לרשימת העיבוד ---
    stringAndEnumFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        }
    });

    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious', 'preferredHasChildrenFromPrevious', 'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible'];
    booleanFields.forEach(field => {
        if (profileData[field] === undefined) {
            profileData[field] = null;
        } else if (typeof profileData[field] !== 'boolean' && profileData[field] !== null) {
            if (profileData[field] === 'true') profileData[field] = true;
            else if (profileData[field] === 'false') profileData[field] = false;
            else profileData[field] = null;
        }
    });

    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    arrayFields.forEach(field => {
        if (profileData[field] === undefined || profileData[field] === null) {
            profileData[field] = [];
        } else if (!Array.isArray(profileData[field])) {
            console.warn(`Field ${field} is not an array, attempting to convert or defaulting to empty.`);
            if (typeof profileData[field] === 'string' && profileData[field].includes(',')) {
                profileData[field] = profileData[field].split(',').map((s: string) => s.trim());
            } else if (typeof profileData[field] === 'string' && profileData[field].trim() !== '') {
                 profileData[field] = [profileData[field].trim()];
            } else {
                profileData[field] = [];
            }
        }
    });
    
    const updatedProfile = await prisma.profile.update({
      where: { userId: candidateIdToUpdate },
      data: {
        ...profileData,
        updatedAt: new Date(),
        lastActive: new Date()
      }
    });

    updateUserAiProfile(candidateIdToUpdate).catch(err => {
        console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });
  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `שגיאה: נראה שאחד השדות שהזנת (כמו מייל או טלפון אם רלוונטי לפרופיל) כבר קיים במערכת עבור משתמש אחר. (${error.meta?.target})`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "הפרופיל או המועמד המבוקש לעדכון לא נמצא.";
            statusCode = 404;
        } else {
            errorMessage = `שגיאת מסד נתונים (קוד ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        errorMessage = `שגיאת ולידציה בעדכון הפרופיל: ${error.message}`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const candidateIdToDelete = params.id;
  const timestamp = new Date().toISOString();
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. לא זוהתה סשן פעיל או הרשאה.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: 'אינך מורשה לבצע פעולה זו. נדרשת הרשאת אדמין.' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: 'מזהה מועמד (candidateId) חסר.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: 'מנהל אינו יכול למחוק את חשבונו האישי דרך ממשק זה. השתמש בהגדרות חשבון אישיות.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: 'המועמד המבוקש למחיקה לא נמצא.' },
        { status: 404 }
      );
    }

    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: 'המועמד נמחק בהצלחה.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: 'המועמד המבוקש למחיקה לא נמצא (שגיאת Prisma).'},
                { status: 404 }
            );
        }
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `שגיאת מסד נתונים במחיקת המועמד (קוד: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `שגיאת ולידציה במחיקת המועמד: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : 'שגיאה לא ידועה בעת מחיקת המועמד.';
    return NextResponse.json(
      {
        success: false,
        error: 'אירעה שגיאה במחיקת המועמד. נסה שוב מאוחר יותר.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

// טייפ פשוט לתוצאה
type UploadResult = {
  secure_url: string;
  public_id: string;
};

// Check for required environment variables
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Validate environment variables
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    // Convert to buffer
    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload using cloudinary.uploader.upload with string transformation
    // זה עוקף את בעיות הטייפים לגמרי
  // אם עדיין יש בעיות, השתמש בזה:
    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        // עוקף את בעיות הטייפים עם type assertion
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client"; // ודא ש-ADMIN מוגדר כאן ב-enum שלך
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Check if required environment variables are set
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: cloudName as string,
  api_key: apiKey as string,
  api_secret: apiSecret as string,
});

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CORRECTED CODE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN]; // Explicitly type the array

    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CORRECTED CODE ----

    // Get params
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Find the image
    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    // Check if this is the main image and there are other images
    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      // If there are other images, set the most recent one as main
      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
        // Continue with DB deletion even if Cloudinary fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get params
    const { id, imageId } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Verify image exists and belongs to candidate
    const imageToSetMain = await prisma.userImage.findFirst({ // Renamed variable for clarity
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) { // Used the new variable name
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    // Start a transaction to update main image
    await prisma.$transaction([
      // First, unset all other images as main for this user
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId } // Don't unset the one we are about to set
        },
        data: { isMain: false }
      }),
      
      // Then, set the specified image as main
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";

export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "כתובת אימייל תקינה היא שדה חובה." }, { status: 400 });
    }

    const normalizedEmail = email.toLowerCase();

    // Find the candidate to invite. We fetch their current email to compare.
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    // If the candidate's email is already the one we're trying to set,
    // we can just resend the invite without a DB update.
    if (candidate.email === normalizedEmail) {
        // Here, we can just resend the invite. For simplicity, we'll proceed,
        // but a dedicated "resend" logic would be cleaner.
        console.log(`Email ${normalizedEmail} is already set for candidate ${candidateId}. Proceeding to send invite.`);
    }

    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      72 // Token valid for 72 hours
    );

    // This transaction will now attempt to update the email.
    // The catch block below will handle the unique constraint violation if it occurs.
    await prisma.$transaction(async (tx) => {
      // Only update the email if it's different from the current one.
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }

      // Invalidate previous setup tokens for this user
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id },
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    // Send the email with the correct token
    await emailService.sendAccountSetupEmail({
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "השדכן/ית שלך",
      setupToken: setupToken,
      expiresIn: "3 ימים",
    });

    return NextResponse.json({ success: true, message: "הזמנה להגדרת חשבון נשלחה בהצלחה." });

  } catch (error) {
    console.error("Error sending account setup invite:", error);
    
    // --- START: Enhanced Error Handling ---
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // Check for unique constraint violation (P2002)
      if (error.code === 'P2002') {
        // The 'target' field in the error metadata tells us which field caused the violation.
        const target = error.meta?.target as string[] | undefined;
        if (target?.includes('email')) {
          return NextResponse.json(
            { success: false, error: "כתובת אימייל זו כבר משויכת לחשבון אחר." },
            { status: 409 } // 409 Conflict is the appropriate status code
          );
        }
      }
      // Handle other potential database errors
      return NextResponse.json({ success: false, error: "שגיאת מסד נתונים." }, { status: 500 });
    }
    // --- END: Enhanced Error Handling ---

    let errorMessage = "An unexpected error occurred.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await request.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: הוספת שדות מקצוע הורים ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: הוספת שדות מקצוע הורים ---

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "משתמש עם כתובת אימייל זו כבר קיים במערכת." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
    };

    // --- START: הוספת השדות החדשים לאובייקט היצירה ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: הוספת השדות החדשים לאובייקט היצירה ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import prisma from "@/lib/prisma"; // Added prisma
import { UserRole } from "@prisma/client"; // Added UserRole
export const dynamic = 'force-dynamic';
export async function GET(
  req: Request, // req is not used, consider removing if not planned for future use
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    // ---- START OF CHANGE ----
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized - Not logged in" }, { status: 401 });
    }

    // Fetch user role for permission check
    const performingUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    // Additionally, a user involved in the inquiry should be able to see it.
    // This needs more context on how AvailabilityService.getInquiryById checks permissions.
    // For now, limiting to Matchmaker/Admin.
    // You might need to adjust this if users (CANDIDATE) should see their own inquiries via this route.
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
        // Before returning 403, check if the user is part of the inquiry if that's a requirement
        // For simplicity, the original request was about ADMIN access to MATCHMAKER functions.
        return NextResponse.json(
            { error: 'Unauthorized - Matchmaker or Admin access required to view this inquiry' },
            { status: 403 }
        );
    }
    // ---- END OF CHANGE ----

    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    // Potentially, AvailabilityService.getInquiryById already handles ownership/role checks.
    // If so, the above check might be redundant or could be simplified.
    // If 'inquiry' is null and no error was thrown, it means not found or no permission from service.
    if (!inquiry) {
        return NextResponse.json({ error: "Inquiry not found or access denied" }, { status: 404 });
    }
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    let message = "Failed to fetch inquiry";
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
import { type NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";

export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

// הגדרת טיפוס גנרי עבור הפרמטרים
type RouteSegment<T> = (
  request: NextRequest,
  params: { params: T }
) => Promise<NextResponse> | NextResponse;

// יצירת פונקציית הטיפול בבקשה
const handler: RouteSegment<{ id: string }> = async (request, { params }) => {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { isAvailable, note } = await request.json();

    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note
    });

    return NextResponse.json(updatedInquiry);
  } catch (error) {
    console.error("Error updating inquiry response:", error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : "Failed to update response"
      },
      { status: 500 }
    );
  }
};

// יצוא הפונקציה כ-POST handler
export const POST = handler;
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, Prisma, UserRole } from "@prisma/client";
import { suggestionService } from "@/app/components/matchmaker/suggestions/services/suggestions/SuggestionService";
import type { CreateSuggestionData } from "@/types/suggestions";
export const dynamic = 'force-dynamic';
const getSuggestionCategory = (status: MatchSuggestionStatus) => {
  switch (status) {
    case 'DRAFT':
    case 'AWAITING_MATCHMAKER_APPROVAL':
    case 'PENDING_FIRST_PARTY':
    case 'PENDING_SECOND_PARTY':
      return 'PENDING';
    
    case 'FIRST_PARTY_DECLINED':
    case 'SECOND_PARTY_DECLINED':
    case 'MATCH_DECLINED':
    case 'ENDED_AFTER_FIRST_DATE':
    case 'ENGAGED':
    case 'MARRIED':
    case 'EXPIRED':
    case 'CLOSED':
    case 'CANCELLED':
      return 'HISTORY';
    
    default:
      return 'ACTIVE';
  }
};

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id || !session.user.role) {
        return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const allowedRolesToCreate: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRolesToCreate.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: "Unauthorized - Matchmaker or Admin access required to create suggestions" }, { status: 403 });
    }
    
    const data = await req.json();
    
    const suggestionData: CreateSuggestionData = {
      ...data,
      matchmakerId: session.user.id,
    };

    const newSuggestion = await suggestionService.createSuggestion(suggestionData);
    
    return NextResponse.json(newSuggestion);
    
  } catch (error) {
    console.error('Error creating suggestion:', error);
    let message = 'Failed to create suggestion';
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions); 
    
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const priority = searchParams.get("priority");
    const timeframe = searchParams.get("timeframe");

    const where: Prisma.MatchSuggestionWhereInput = {};
    
    // ---- START OF FIX ----
    // שינינו את הלוגיקה כדי לטפל נכון בהרשאות
    if (session.user.role === UserRole.MATCHMAKER) {
        // שדכן רואה רק את ההצעות שהוא יצר
        where.matchmakerId = session.user.id;
    } else if (session.user.role === UserRole.CANDIDATE) {
        // מועמד רואה רק הצעות שהוא צד בהן
        where.OR = [
            { firstPartyId: session.user.id },
            { secondPartyId: session.user.id }
        ];
    }
    // אם המשתמש הוא ADMIN, לא נוסיף סינון לפי מזהה משתמש, וכך הוא יראה את כל ההצעות.
    // ---- END OF FIX ----

    if (status) where.status = status as MatchSuggestionStatus;
    if (priority) where.priority = priority as Prisma.EnumPriorityFieldUpdateOperationsInput["set"];
    
    if (timeframe) {
      const date = new Date();
      switch (timeframe) {
        case 'today':
          date.setHours(0, 0, 0, 0);
          where.createdAt = { gte: date };
          break;
        case 'week':
          date.setDate(date.getDate() - 7);
          where.createdAt = { gte: date };
          break;
        case 'month':
          date.setMonth(date.getMonth() - 1);
          where.createdAt = { gte: date };
          break;
      }
    }

    const suggestions = await prisma.matchSuggestion.findMany({
      where,
      include: {
        firstParty: {
          select: { id: true, email: true, firstName: true, lastName: true, status: true, isVerified: true, images: { select: { id: true, url: true, isMain: true }, orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] }, profile: true }
        },
        secondParty: {
          select: { id: true, email: true, firstName: true, lastName: true, status: true, isVerified: true, images: { select: { id: true, url: true, isMain: true }, orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] }, profile: true }
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true, role: true }
        },
        statusHistory: { orderBy: { createdAt: 'desc' } },
        meetings: { orderBy: { createdAt: 'desc' } },
         inquiries: {
          include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
          },
          orderBy: { createdAt: 'asc' }
        }
      },
      orderBy: { lastActivity: 'desc' }
    });

    const formattedSuggestions = suggestions.map(suggestion => ({
      ...suggestion,
      category: getSuggestionCategory(suggestion.status),
      firstParty: {
        ...suggestion.firstParty,
        profile: suggestion.firstParty.profile ? {
          ...suggestion.firstParty.profile,
          birthDate: suggestion.firstParty.profile.birthDate?.toISOString(),
          lastActive: suggestion.firstParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: suggestion.firstParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: suggestion.firstParty.profile.createdAt?.toISOString(),
          updatedAt: suggestion.firstParty.profile.updatedAt?.toISOString()
        } : null
      },
      secondParty: {
        ...suggestion.secondParty,
        profile: suggestion.secondParty.profile ? {
          ...suggestion.secondParty.profile,
          birthDate: suggestion.secondParty.profile.birthDate?.toISOString(),
          lastActive: suggestion.secondParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: suggestion.secondParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: suggestion.secondParty.profile.createdAt?.toISOString(),
          updatedAt: suggestion.secondParty.profile.updatedAt?.toISOString()
        } : null
      },
      statusHistory: suggestion.statusHistory.map(history => ({
        ...history,
        createdAt: history.createdAt.toISOString()
      })),
      meetings: suggestion.meetings.map(meeting => ({
        ...meeting,
        scheduledDate: meeting.scheduledDate.toISOString(),
        createdAt: meeting.createdAt.toISOString(),
        updatedAt: meeting.updatedAt.toISOString()
      })),
      responseDeadline: suggestion.responseDeadline?.toISOString(),
      decisionDeadline: suggestion.decisionDeadline?.toISOString(),
      lastStatusChange: suggestion.lastStatusChange?.toISOString(),
      firstPartySent: suggestion.firstPartySent?.toISOString(),
      firstPartyResponded: suggestion.firstPartyResponded?.toISOString(),
      secondPartySent: suggestion.secondPartySent?.toISOString(),
      secondPartyResponded: suggestion.secondPartyResponded?.toISOString(),
      firstMeetingScheduled: suggestion.firstMeetingScheduled?.toISOString(),
      closedAt: suggestion.closedAt?.toISOString(),
      createdAt: suggestion.createdAt.toISOString(),
      updatedAt: suggestion.updatedAt.toISOString(),
      lastActivity: suggestion.lastActivity.toISOString()
    }));
    
    // =================  LOGGING START (Improved) =================
    console.log(`[API GET /suggestions] User: ${session.user.id} (Role: ${session.user.role}). Found ${suggestions.length} suggestions matching query.`);
    if (suggestions.length > 0) {
        console.log(`[API GET /suggestions] Example suggestion being sent (ID: ${suggestions[0].id}, Status: ${suggestions[0].status})`);
    }
    // =================   LOGGING END   =================

    return NextResponse.json(formattedSuggestions);
    
  } catch (error) {
    console.error('Error fetching suggestions:', error);
    let message = 'Failed to fetch suggestions';
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { SuggestionService } from "@/app/components/matchmaker/suggestions/services/suggestions/SuggestionService";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // וידוא משתמש מחובר
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    // וידוא הרשאות שדכן
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const suggestionId = params.id;
    const data = await req.json();
    
    const suggestionService = SuggestionService.getInstance();
    
    try {
      // שימוש בשירות עדכון הצעה
      const updatedSuggestion = await suggestionService.updateSuggestion(
        suggestionId,
        session.user.id,
        {
          id: suggestionId,
          priority: data.priority,
          notes: {
            internal: data.internalNotes,
            forFirstParty: data.firstPartyNotes,
            forSecondParty: data.secondPartyNotes,
            matchingReason: data.matchingReason,
            followUpNotes: data.followUpNotes
          },
          decisionDeadline: data.decisionDeadline ? new Date(data.decisionDeadline) : undefined,
          responseDeadline: data.responseDeadline ? new Date(data.responseDeadline) : undefined
        }
      );
      
      return NextResponse.json({
        success: true,
        data: updatedSuggestion
      });
      
    } catch (serviceError: unknown) {
        console.error("Error from suggestion service:", serviceError);
        
        if (serviceError instanceof Error) {
          return NextResponse.json(
            { success: false, error: serviceError.message || "Failed to update suggestion" },
            { status: serviceError.message.includes("Unauthorized") ? 403 : 400 }
          );
        }
        
        // במקרה של שגיאה שאינה מסוג Error
        return NextResponse.json(
          { success: false, error: "Failed to update suggestion" },
          { status: 400 }
        );
      }
  } catch (error) {
    console.error("Error updating suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // וידוא שמשתמש מחובר
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // וידוא הרשאות שדכן או אדמין
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;

    // וידוא קיום ההצעה
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // בדיקת הרשאות ספציפיות - רק השדכן שיצר את ההצעה או אדמין יכולים למחוק
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to delete this suggestion" },
        { status: 403 }
      );
    }

    // מחיקת רכיבים קשורים בנפרד במקום בטרנזקציה
    // 1. מחיקת רשומות היסטוריה
    await prisma.suggestionStatusHistory.deleteMany({
      where: { suggestionId }
    });

    // 2. מחיקת משוב פגישות אם קיים
    await prisma.dateFeedback.deleteMany({
      where: { suggestionId }
    });

    // 3. מחיקת פגישות קשורות (אם יש)
    await prisma.meeting.deleteMany({
      where: { suggestionId }
    });

    // 4. מחיקת שאלות/פניות אם קיימות
    await prisma.suggestionInquiry.deleteMany({
      where: { suggestionId }
    });

    // 5. הסרת קשרים בטבלאות קשר רבים-לרבים (אם יש)
    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        approvedBy: {
          set: []
        },
        reviewedBy: {
          set: []
        }
      }
    });

    // 6. מחיקת ההצעה עצמה
    await prisma.matchSuggestion.delete({
      where: { id: suggestionId }
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully"
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    
    // החזרת פרטי שגיאה אם קיימים
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete suggestion", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/message/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { initNotificationService } from "@/app/components/matchmaker/suggestions/services/notification/initNotifications";

// Initialize the notification service
const notificationService = initNotificationService();


export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;
    const { partyType, messageType, content } = await req.json();

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for this suggestion
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to send messages for this suggestion" },
        { status: 403 }
      );
    }

    // Define which parties will receive the message
    const notifyParties: ('first' | 'second')[] = [];
    
    if (partyType === "first" || partyType === "both") {
      notifyParties.push('first');
    }
    
    if (partyType === "second" || partyType === "both") {
      notifyParties.push('second');
    }

     console.log(`Message request received for suggestion ${suggestionId}, will be handled through transactions`);

    // Log the message in the system
    await prisma.$transaction(async (tx) => {
      try {
        // Update the lastActivity field in the suggestion
        await tx.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            lastActivity: new Date(),
          },
        });
        
        // Add a record to the status history
        await tx.suggestionStatusHistory.create({
          data: {
            suggestionId,
            status: suggestion.status as MatchSuggestionStatus,
            notes: `הודעה נשלחה מאת השדכן: ${messageType} - ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`,
          },
        });
    
        // שליחת ההודעה רק אחרי העדכון בדאטהבייס
        await notificationService.handleSuggestionStatusChange(
          suggestion, 
          {
            channels: ['email', 'whatsapp'],
            notifyParties,
            customMessage: content
          }
        );
      } catch (txError) {
        console.error("Transaction error:", txError);
        throw txError;
      }
    });

    return NextResponse.json({
      success: true,
      message: "Messages sent successfully",
      recipients: notifyParties
    });
  } catch (error) {
    console.error("Error sending message:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send message" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/remind/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { initNotificationService } from "@/app/components/matchmaker/suggestions/services/notification/initNotifications";

// Initialize the notification service
const notificationService = initNotificationService();

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for this suggestion
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to send reminders for this suggestion" },
        { status: 403 }
      );
    }
    
    // Define parties that will receive the reminder
    const notifyParties: ('first' | 'second')[] = [];
    let sentCount = 0;
    
    if (partyType === "first" || partyType === "both") {
      if (suggestion.status === MatchSuggestionStatus.PENDING_FIRST_PARTY) {
        notifyParties.push('first');
        sentCount++;
      }
    }
    
    if (partyType === "second" || partyType === "both") {
      if (suggestion.status === MatchSuggestionStatus.PENDING_SECOND_PARTY) {
        notifyParties.push('second');
        sentCount++;
      }
    }
    
    // Construct reminder content
    const reminderContent = `זוהי תזכורת ידידותית שהצעת שידוך מאת ${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName} ממתינה לתשובתך. לצפייה בפרטי ההצעה ומענה, אנא לחץ/י על הקישור.`;
    
    // Check if we have applicable recipients
    if (sentCount === 0) {
      return NextResponse.json({
        success: false,
        error: "No applicable recipients for reminder in current status"
      }, { status: 400 });
    }

    // Update the last activity timestamp in the suggestion
    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        lastActivity: new Date(),
      },
    });

    // Log the reminder to history
    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId,
        status: suggestion.status,
        notes: `תזכורת נשלחה ל${partyType === "first" ? "צד ראשון" : partyType === "second" ? "צד שני" : "שני הצדדים"} על ידי ${session.user.firstName} ${session.user.lastName}`,
      },
    });
    
    // רק לאחר העדכון בדאטהבייס - שלח את ההודעה
    await notificationService.handleSuggestionStatusChange(
      suggestion,
      {
        channels: ['email', 'whatsapp'],
        notifyParties,
        customMessage: reminderContent
      }
    );
    
    return NextResponse.json({
      success: true,
      message: "Reminder sent successfully",
      recipientCount: sentCount
    });
  } catch (error) {
    console.error("Error sending reminder:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send reminder" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/resend/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { StatusTransitionService } from "@/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";

// Initialize the notification service

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for resending
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to resend this suggestion" },
        { status: 403 }
      );
    }

    const statusTransitionService = StatusTransitionService.getInstance();
    let updatedSuggestion = suggestion;
    const transitionNotes = `הצעה נשלחה מחדש ע"י ${session.user.firstName} ${session.user.lastName}`;
    
    // Update suggestion status to the appropriate status for resending
    if (partyType === "both" || partyType === "first") {
      // Resend to first party
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_FIRST_PARTY,
        `${transitionNotes} - לצד ראשון`,
        {
          sendNotifications: true,
          notifyParties: ['first']
        }
      );
      
      // If this is just for the first party, update the sent time
      if (partyType === "first") {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            firstPartySent: new Date(),
            lastActivity: new Date()
          }
        });
      }
    }
    
    if (partyType === "both" || partyType === "second") {
      // Resend to second party (directly or after the first)
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        `${transitionNotes} - לצד שני`,
        {
          sendNotifications: true,
          notifyParties: ['second']
        }
      );
      
      // Update the sent time
      await prisma.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          secondPartySent: new Date(),
          lastActivity: new Date()
        }
      });
    }

    return NextResponse.json({
      success: true,
      message: `Suggestion successfully resent to ${partyType === "first" ? "first party" : partyType === "second" ? "second party" : "both parties"}`,
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error resending suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to resend suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/share-contact/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { StatusTransitionService } from "@/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // Verify user is logged in
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify matchmaker permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;

    // Verify suggestion exists
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: {
          include: { profile: true }
        },
        secondParty: {
          include: { profile: true }
        },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // Verify matchmaker permissions for sharing contact details
    if (
      suggestion.matchmakerId !== session.user.id &&
      session.user.role !== UserRole.ADMIN
    ) {
      return NextResponse.json(
        { success: false, error: "You are not authorized to share contact details for this suggestion" },
        { status: 403 }
      );
    }

    // Verify suggestion is in appropriate status for sharing contact details
    if (
      suggestion.status !== MatchSuggestionStatus.FIRST_PARTY_APPROVED &&
      suggestion.status !== MatchSuggestionStatus.SECOND_PARTY_APPROVED &&
      suggestion.status !== MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL
    ) {
      return NextResponse.json({
        success: false,
        error: "Suggestion is not in a valid status for sharing contact details"
      }, { status: 400 });
    }

    // Update suggestion status to CONTACT_DETAILS_SHARED using the StatusTransitionService
    // This will automatically trigger notifications to both parties with contact details
    const statusTransitionService = StatusTransitionService.getInstance();
    const updatedSuggestion = await statusTransitionService.transitionStatus(
      suggestion,
      MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
      `פרטי קשר שותפו בין ${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} ל${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} ע"י ${session.user.firstName} ${session.user.lastName}`,
      {
        sendNotifications: true,
        notifyParties: ['first', 'second', 'matchmaker']
      }
    );

    return NextResponse.json({
      success: true,
      message: "Contact details shared successfully",
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error sharing contact details:", error);
    return NextResponse.json(
      { success: false, error: "Failed to share contact details" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { z } from "zod";

// Schema for validating status update data
const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

/**
 * PATCH endpoint for updating suggestion status
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. Verify permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    // 3. Validate request data
    const body = await req.json();
    console.log("Received status update request:", body);
    
    const validationResult = updateStatusSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error:", validationResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid request data", 
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }
    
    const { status, notes } = validationResult.data;

    // 4. Verify suggestion exists
    const suggestionId = params.id;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 5. Verify permission on specific suggestion
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to update this suggestion" },
        { status: 403 }
      );
    }

    // 6. Calculate category based on new status
    const getCategory = (status: MatchSuggestionStatus) => {
      switch (status) {
        case "DRAFT":
        case "AWAITING_MATCHMAKER_APPROVAL":
        case "PENDING_FIRST_PARTY":
        case "PENDING_SECOND_PARTY":
          return "PENDING";
        
        case "FIRST_PARTY_DECLINED":
        case "SECOND_PARTY_DECLINED":
        case "MATCH_DECLINED":
        case "ENDED_AFTER_FIRST_DATE":
        case "ENGAGED":
        case "MARRIED":
        case "EXPIRED":
        case "CLOSED":
        case "CANCELLED":
          return "HISTORY";
        
        default:
          return "ACTIVE";
      }
    };

    // 7. Update status in a transaction
    const result = await prisma.$transaction(async (tx) => {
      // Save previous status
      const previousStatus = suggestion.status;

      // Update the suggestion
      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status,
          previousStatus: previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          category: getCategory(status),
          
          // Update additional fields based on new status
          ...(status === MatchSuggestionStatus.CLOSED ? { closedAt: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_FIRST_PARTY ? { firstPartySent: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY ? { secondPartySent: new Date() } : {}),
        },
      });

      // Add status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes: notes || `סטטוס שונה ל-${status} על ידי ${session.user.firstName} ${session.user.lastName}`,
        },
      });

      return updatedSuggestion;
    });

    // 8. Return success response
    return NextResponse.json({
      success: true,
      message: "Status updated successfully",
      suggestion: {
        id: result.id,
        status: result.status,
        previousStatus: result.previousStatus,
        lastStatusChange: result.lastStatusChange,
        category: result.category,
      },
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    // Return detailed error message if available
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to update status", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint for fetching suggestion history
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse URL parameters
    const searchParams = new URL(req.url).searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 50;

    // 3. Check viewing permissions
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        matchmakerId: true,
        firstPartyId: true,
        secondPartyId: true,
      }
    });
    
    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    
    // Check if user has permission to view this suggestion
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return NextResponse.json({ error: "Not authorized to view this suggestion" }, { status: 403 });
    }
    
    // 4. Build history query
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(startDate && {
          createdAt: {
            gte: new Date(startDate),
            ...(endDate && {
              lte: new Date(endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            secondParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            matchmaker: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc" as const,
      },
      take: limit,
    };

    // 5. Fetch status change history
    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    // 6. Format results
    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { error: "Failed to fetch history", details: errorMessage },
      { status: 500 }
    );
  }
}

/**
 * HEAD endpoint for getting status summary
 */
export async function HEAD(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new Response(null, { status: 401 });
    }

    // 2. Fetch suggestion details
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      }
    });

    if (!suggestion) {
      return new Response(null, { status: 404 });
    }

    // 3. Check viewing permissions
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return new Response(null, { status: 403 });
    }

    // 4. Prepare headers
    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    // Add lastStatusChange header only if it exists
    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages\feed
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages\feed\route.ts
--------------------------------------------------------------------------------
Content:
// FILENAME: src/app/api/messages/feed/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
// ADDED: Import the ExtendedSuggestionInquiry type
import type { FeedItem, FeedItemType, ExtendedSuggestionInquiry } from "@/types/messages";
import type { ExtendedMatchSuggestion } from "@/app/components/suggestions/types";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";

export const dynamic = 'force-dynamic';

// הגדרה אחידה לשליפת פרטי משתמשים
const partySelect = {
  id: true, email: true, firstName: true, lastName: true, isProfileComplete: true, 
  profile: true,
  images: {
    select: { 
      id: true, url: true, isMain: true, createdAt: true, updatedAt: true,
      cloudinaryPublicId: true, userId: true
    },
    orderBy: { isMain: "desc" as const },
  },
};

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const userId = session.user.id;
  const userRole = session.user.role as UserRole;

  try {
    // 1. שלוף הצעות שידוך רלוונטיות
    const suggestionsFromDb = await prisma.matchSuggestion.findMany({
      where: {
        OR: [{ firstPartyId: userId }, { secondPartyId: userId }],
        status: { notIn: [MatchSuggestionStatus.DRAFT, MatchSuggestionStatus.CANCELLED] },
      },
      include: {
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: { select: partySelect },
        secondParty: { select: partySelect },
        statusHistory: { orderBy: { createdAt: "desc" } },
      },
      orderBy: { lastActivity: "desc" },
    });
    const suggestions: ExtendedMatchSuggestion[] = suggestionsFromDb.filter(
      (s) => s.firstParty?.profile && s.secondParty?.profile
    ) as ExtendedMatchSuggestion[];

    // 2. שלוף הודעות צ'אט רלוונטיות
    const inquiriesFromDb = await prisma.suggestionInquiry.findMany({
        where: {
            OR: [{ fromUserId: userId }, { toUserId: userId }]
        },
        include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
            suggestion: {
                include: {
                    firstParty: { select: partySelect },
                    secondParty: { select: partySelect },
                    matchmaker: { select: { firstName: true, lastName: true } },
                }
            }
        },
        orderBy: { createdAt: 'desc' },
        take: 30 // הגבלת כמות ההודעות לביצועים טובים יותר
    });

    // 3. המרת הצעות למבנה FeedItem
    const suggestionFeedItems: FeedItem[] = suggestions.map((s) => {
      const isFirstParty = s.firstPartyId === userId;
      const otherParty = isFirstParty ? s.secondParty : s.firstParty;
      let type: FeedItemType = 'STATUS_UPDATE';
      let title = `עדכון בהצעה עם ${otherParty.firstName}`;
      let description = "הסטטוס התעדכן. לחץ/י לפרטים.";

      if ((s.status === "PENDING_FIRST_PARTY" && isFirstParty) || (s.status === "PENDING_SECOND_PARTY" && !isFirstParty)) {
        type = 'ACTION_REQUIRED';
        title = `הצעה חדשה ממתינה לך!`;
        description = `${s.matchmaker.firstName} חושב/ת שיש כאן פוטנציאל גדול.`;
      } else if (s.status === "CONTACT_DETAILS_SHARED") {
        title = "מזל טוב, יש התאמה!";
        description = `פרטי הקשר הועברו. זה הזמן ליצור קשר.`;
      } else if (s.status === "AWAITING_FIRST_DATE_FEEDBACK") {
        type = 'ACTION_REQUIRED';
        title = "איך הייתה הפגישה הראשונה?";
        description = "נשמח לשמוע את דעתך כדי להמשיך ולסייע.";
      }
      
      return {
        id: `${s.id}-${s.status}`, type, title, description,
        timestamp: s.lastActivity, isRead: false,
        link: `/matches?suggestionId=${s.id}`,
        payload: { suggestion: s },
      };
    });

    // 4. המרת הודעות צ'אט למבנה FeedItem
    const inquiryFeedItems: FeedItem[] = inquiriesFromDb.map((inquiry): FeedItem => {
        const isMyMessage = inquiry.fromUserId === userId;
        const otherUser = isMyMessage ? inquiry.toUser : inquiry.fromUser;
        const suggestionParticipant = inquiry.suggestion.firstPartyId === userId ? inquiry.suggestion.secondParty : inquiry.suggestion.firstParty;
        
        let title: string;
        let description: string;
        let type: FeedItemType;

        if (isMyMessage) {
            // זו הודעה שאני שלחתי
            title = `שלחת שאלה ל${otherUser.firstName}`;
            description = `"${inquiry.question.substring(0, 50)}..."`;
            type = inquiry.answer ? 'INQUIRY_RESPONSE' : 'MATCHMAKER_MESSAGE';
        } else {
            // זו הודעה שקיבלתי
            if (inquiry.answer) {
                 title = `התקבלה תשובה מ${otherUser.firstName}`;
                 description = `לגבי שאלתך על ${suggestionParticipant.firstName}: "${inquiry.answer.substring(0, 40)}..."`;
                 type = 'INQUIRY_RESPONSE';
            } else {
                 title = `הודעה חדשה מ${otherUser.firstName}`;
                 description = `לגבי ההצעה עם ${suggestionParticipant.firstName}`;
                 type = userRole === 'MATCHMAKER' && inquiry.status === 'PENDING' ? 'ACTION_REQUIRED' : 'MATCHMAKER_MESSAGE';
            }
        }

        return {
            id: inquiry.id,
            type: type,
            title,
            description,
            timestamp: inquiry.answeredAt ? inquiry.answeredAt : inquiry.createdAt,
            isRead: isMyMessage || inquiry.status !== 'PENDING',
            link: `/matches?suggestionId=${inquiry.suggestionId}&view=chat`,
            payload: { 
                suggestion: inquiry.suggestion as unknown as ExtendedMatchSuggestion,
                // CHANGED: Replaced 'any' with the specific 'ExtendedSuggestionInquiry' type
                suggestionInquiry: inquiry as ExtendedSuggestionInquiry 
            }
        };
    });

    // 5. איחוד, מיון והחזרה
    const allFeedItems = [...suggestionFeedItems, ...inquiryFeedItems];
    allFeedItems.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    
    return NextResponse.json({ success: true, feed: allFeedItems });

  } catch (error) {
    console.error("Error fetching activity feed:", error);
    return NextResponse.json({ success: false, error: "Failed to fetch activity feed" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\notifications
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\notifications\route.ts
--------------------------------------------------------------------------------
Content:
// FILENAME: src/app/api/notifications/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Session } from "next-auth";

export const dynamic = 'force-dynamic';

export async function GET() {
  try {
    const session = await getServerSession(authOptions) as Session | null;
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userId = session.user.id;

    // 1. ספירת בקשות זמינות כלליות שממתינות למשתמש זה
    const pendingAvailabilityRequests = await prisma.availabilityInquiry.count({
      where: {
        OR: [
          { 
            firstPartyId: userId,
            firstPartyResponse: null,
            expiresAt: { gt: new Date() }
          },
          { 
            secondPartyId: userId,
            secondPartyResponse: null,
            expiresAt: { gt: new Date() }
          }
        ]
      },
    });

    // 2. ספירת הודעות צ'אט חדשות שממתינות למשתמש זה
    // (הודעות שהמשתמש הוא הנמען שלהן והסטטוס שלהן הוא "ממתין")
    const unreadChatMessages = await prisma.suggestionInquiry.count({
        where: {
            toUserId: userId,
            status: 'PENDING'
        }
    });

    const total = pendingAvailabilityRequests + unreadChatMessages;

    return NextResponse.json({
      availabilityRequests: pendingAvailabilityRequests,
      messages: unreadChatMessages, // זה עכשיו סופר הודעות צ'אט אמיתיות
      total: total
    });

  } catch (error) {
    console.error("Error fetching notifications:", error);
    return NextResponse.json(
      { error: "Failed to fetch notifications" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/route.ts (GET handler)

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, HeadCoveringType, KippahType, ServiceType, ReligiousJourney  } from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    let targetUserId: string;
    if (requestedUserId) {
      targetUserId = requestedUserId;
    } else if (session.user.id) {
      targetUserId = session.user.id;
    } else {
       return NextResponse.json(
        { success: false, message: 'User ID not found in session' },
        { status: 400 }
      );
    }

    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true,
        profile: {
          select: {
            id: true,
            userId: true,
            gender: true,
            birthDate: true,
            nativeLanguage: true,
            additionalLanguages: true,
            height: true,
            city: true,
            origin: true,
            aliyaCountry: true,
            aliyaYear: true,
            maritalStatus: true,
            hasChildrenFromPrevious: true,
            parentStatus: true,
            fatherOccupation: true,
            motherOccupation: true,
            siblings: true,
            position: true,
            educationLevel: true,
            education: true,
            occupation: true,
            serviceType: true,
            serviceDetails: true,
            religiousLevel: true,
            religiousJourney: true,
            shomerNegiah: true,
            headCovering: true,
            kippahType: true,
            profileCharacterTraits: true,
            profileHobbies: true,
            about: true,
            // --- START: הוספת שדות חדשים ---
            profileHeadline: true,
            humorStory: true,
            inspiringCoupleStory: true,
            influentialRabbi: true,
            // --- END: הוספת שדות חדשים ---
            matchingNotes: true,
            preferredAgeMin: true,
            preferredAgeMax: true,
            preferredHeightMin: true,
            preferredHeightMax: true,
            preferredReligiousLevels: true,
            preferredLocations: true,
            preferredEducation: true,
            preferredOccupations: true,
            preferredReligiousJourneys: true,
            contactPreference: true,
            isProfileVisible: true,
            preferredMatchmakerGender: true,
            availabilityStatus: true,
            availabilityNote: true,
            availabilityUpdatedAt: true,
            preferredMaritalStatuses: true,
            preferredOrigins: true,
            preferredServiceTypes: true,
            preferredHeadCoverings: true,
            preferredKippahTypes: true,
            preferredShomerNegiah: true,
            preferredHasChildrenFromPrevious: true,
            preferredCharacterTraits: true,
            preferredHobbies: true,
            preferredAliyaStatus: true,
            createdAt: true,
            updatedAt: true,
            lastActive: true,
            verifiedBy: true,
            hasViewedProfilePreview: true,
            hasMedicalInfo: true,
            medicalInfoDetails: true,
            medicalInfoDisclosureTiming: true,
            isMedicalInfoVisible: true,
          }
        },
        images: {
          select: {
            id: true,
            url: true,
            isMain: true,
            createdAt: true,
            cloudinaryPublicId: true,
            updatedAt: true,
          }
        }
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        console.error(`Profile data not found for user ID: ${targetUserId}`);
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    if (!dbProfile.birthDate) {
        console.error(`birthDate is null or undefined for profile ID: ${dbProfile.id}`);
        return NextResponse.json(
            { success: false, message: 'Data integrity issue: birthDate is missing for the profile.' },
            { status: 500 }
        );
    }

    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      parentStatus: dbProfile.parentStatus || undefined,
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType as ServiceType | null || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney || undefined,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering as HeadCoveringType | null || undefined,
      kippahType: dbProfile.kippahType as KippahType | null || undefined,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      about: dbProfile.about || "",
      // --- START: הוספת שדות חדשים ---
      profileHeadline: dbProfile.profileHeadline || undefined,
      humorStory: dbProfile.humorStory || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      // --- END: הוספת שדות חדשים ---
      matchingNotes: dbProfile.matchingNotes || "",
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender as Gender | null || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [],
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredHasChildrenFromPrevious: dbProfile.preferredHasChildrenFromPrevious ?? undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };
    
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
export const dynamic = 'force-dynamic';
// Configure Cloudinary
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// פונקציה עוטפת ל-Upload עם Promise נכון
function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: 'profile-images',
        resource_type: 'image',
      },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({
            secure_url: result.secure_url,
            public_id: result.public_id,
          });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// GET - Fetch all images for a user
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: {
        user: {
          email: session.user.email,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error('[GetImages] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch images' },
      { status: 500 }
    );
  }
}

// POST - Upload new images (can be adapted for multiple files)
export async function POST(req: Request) {
  const startTime = Date.now();

  try {
    console.log('[Upload] Starting upload process');

    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error('[Upload] Authentication failed - No user session');
      return NextResponse.json(
        {
          success: false,
          error: 'Unauthorized',
        },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      select: { id: true, email: true, _count: { select: { images: true } } },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.error('[Upload] No file provided in request');
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    if (user._count.images >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { success: false, error: 'Maximum number of images reached' },
        { status: 400 }
      );
    }

    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid file type. Only JPG, PNG and WEBP are allowed',
        },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { success: false, error: 'File size must be less than 5MB' },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    console.log(`[Upload] File processed, uploading to Cloudinary...`);

    const cloudinaryResult = await uploadToCloudinary(buffer);

    const isFirstImage = user._count.images === 0;

    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });

    console.log(
      `[Upload] Database save completed in ${Date.now() - startTime}ms`
    );
    return NextResponse.json({
      success: true,
      image,
      timing: `${Date.now() - startTime}ms`,
    });
  } catch (error) {
    console.error('[Upload] General error:', error);
    console.log(`[Upload] Failed after ${Date.now() - startTime}ms`);
    return NextResponse.json(
      { success: false, error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// --- NEW ---
// DELETE - Bulk delete images
export async function DELETE(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const { imageIds } = await req.json();

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Image IDs must be a non-empty array' },
        { status: 400 }
      );
    }

    // 1. Find images to verify ownership and get necessary data
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: userId, // CRUCIAL: Ensures user only deletes their own images
      },
      select: {
        id: true,
        cloudinaryPublicId: true,
        isMain: true,
      },
    });

    if (imagesToDelete.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No matching images found to delete.' },
        { status: 404 }
      );
    }

    // 2. Check if the main image is being deleted
    const wasMainImageDeleted = imagesToDelete.some((image) => image.isMain);

    // 3. Delete from Cloudinary
    const cloudinaryIdsToDelete = imagesToDelete
      .map((image) => image.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (cloudinaryIdsToDelete.length > 0) {
      const cloudinaryDeletions = cloudinaryIdsToDelete.map((publicId) =>
        cloudinary.uploader.destroy(publicId).catch((err) => {
          console.error(
            `[Bulk Delete] Failed to delete image ${publicId} from Cloudinary:`,
            err
          );
        })
      );
      await Promise.all(cloudinaryDeletions);
    }

    // 4. Delete from database
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) }, // Use validated IDs
        userId: userId,
      },
    });

    // 5. If main image was deleted, assign a new one if possible
    if (wasMainImageDeleted) {
      const newMainImage = await prisma.userImage.findFirst({
        where: { userId: userId },
        orderBy: { createdAt: 'desc' },
      });

      if (newMainImage) {
        await prisma.userImage.update({
          where: { id: newMainImage.id },
          data: { isMain: true },
        });
      }
    }

    // 6. Fetch the updated list of images to return to the client
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, images: updatedImages });
  } catch (error) {
    console.error('[Bulk Delete Images] Error:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete images',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;
    
    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Delete from Cloudinary if cloudinaryPublicId exists
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
        // Continue with database deletion even if Cloudinary deletion fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId },
    });

    // If this was the main image, set another image as main if available
    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;

    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Reset all user's images to non-main
    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    // Set the selected image as main
    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    // Get updated images list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/questionnaire/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma, UserRole } from '@prisma/client';
import { updateUserAiProfile } from '@/lib/services/profileAiService';

// --- START: שינוי מרכזי - ייבוא הפונקציות המרכזיות במקום להגדיר אותן כאן ---
import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { DbWorldKey, FormattedAnswersType } from '@/lib/questionnaireFormatter';
// --- END: שינוי מרכזי ---

import type { WorldId, FormattedAnswer } from '@/types/next-auth';

// --- הגדרות הטיפוסים נשארות כאן כי הן ספציפיות ל-API הזה ---
type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

interface UpdateData {
  type: 'answer' | 'visibility';
  value?: Prisma.JsonValue;
  isVisible?: boolean;
}

// --- פונקציות העזר שהיו כאן נמחקו, כי הן נמצאות עכשיו ב-questionnaireFormatter.ts ---

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const userId = url.searchParams.get('userId') || session.user.id;

    const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });

    if (!questionnaireResponse) {
       return NextResponse.json({ success: true, questionnaireResponse: null });
    }

    // שימוש בפונקציה המיובאת
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
       const dbKey = KEY_MAPPING[worldKey];
       formattedAnswers[worldKey] = formatAnswers(questionnaireResponse[dbKey]);
    });

    const formattedResponse = {
      ...questionnaireResponse,
      formattedAnswers: formattedAnswers
    };

    // בדיקת הרשאות צפייה
    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });
    if (!performingUser) {
      return NextResponse.json({ success: false, error: 'Performing user not found' }, { status: 404 });
    }
    const viewerIsAdminOrMatchmaker = performingUser.role === 'ADMIN' || performingUser.role === 'MATCHMAKER';

    if (!viewerIsAdminOrMatchmaker && userId !== session.user.id) {
        Object.keys(formattedResponse.formattedAnswers).forEach((worldKey) => {
            const key = worldKey as WorldId;
            if (formattedResponse.formattedAnswers[key]) {
                formattedResponse.formattedAnswers[key] =
                  formattedResponse.formattedAnswers[key]!.filter(answer => answer.isVisible !== false);
            }
        });
    }

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedResponse
    });

  } catch (error) {
    console.error('Error in GET /api/profile/questionnaire:', error);
    return NextResponse.json({ success: false, error: "Failed to fetch questionnaire" }, { status: 500 });
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
     const userId = session.user.id;

     const body = await req.json();
     
     const { worldKey, questionId, value } = body as {
       worldKey: WorldId;
       questionId: string;
       value: UpdateData;
     };

     if (!worldKey || !questionId || !value || !value.type || !KEY_MAPPING[worldKey]) {
        return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
     }

     const dbKey = KEY_MAPPING[worldKey];

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       return NextResponse.json({ success: false, error: "שאלון לא נמצא" }, { status: 404 });
     }

     const currentAnswersJson = questionnaire[dbKey];
     const currentAnswers = Array.isArray(currentAnswersJson) ? currentAnswersJson as unknown as JsonAnswerData[] : [];

     const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
     const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

     let updatedAnswer: JsonAnswerData;

     if (value.type === 'visibility') {
        if (!existingAnswer) return NextResponse.json({ success: false, error: "לא נמצאה תשובה לעדכון נראות" }, { status: 404 });
        if (typeof value.isVisible !== 'boolean') return NextResponse.json({ success: false, error: "ערך נראות לא תקין" }, { status: 400 });
        updatedAnswer = { ...existingAnswer, isVisible: value.isVisible, answeredAt: new Date().toISOString() };
     } else if (value.type === 'answer') {
       if (value.value === undefined) return NextResponse.json({ success: false, error: "ערך תשובה חסר" }, { status: 400 });
       updatedAnswer = {
         questionId,
         value: value.value,
         isVisible: existingAnswer?.isVisible ?? true,
         answeredAt: new Date().toISOString()
       };
     } else {
         return NextResponse.json({ success: false, error: "סוג עדכון לא תקין" }, { status: 400 });
     }

     const updatedAnswers = [...currentAnswers];
     if (existingAnswerIndex !== -1) {
         updatedAnswers[existingAnswerIndex] = updatedAnswer;
     } else if (value.type === 'answer') {
         updatedAnswers.push(updatedAnswer);
     }

     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });

     updateUserAiProfile(userId).catch(err => {
        console.error(`[AI Profile Trigger - Questionnaire Update] Failed to update AI profile in the background for user ${userId}:`, err);
     });

    // שימוש חוזר בפונקציה המיובאת
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach(key => {
       const currentDbKey = KEY_MAPPING[key];
        formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
    });

     const formattedResponse = {
       ...updated,
       formattedAnswers: formattedAnswers
     };

     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            return NextResponse.json({ success: false, error: "שגיאת מסד נתונים" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           return NextResponse.json({ success: false, error: "גוף הבקשה אינו JSON תקין" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "שגיאה בעדכון השאלון" }, { status: 500 });
   }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/update/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  ReligiousJourney,
  Profile, // Import Prisma's Profile type
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. ייבוא

// Helper to convert to number or null
const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

// Helper to convert to Date or error if invalid for required fields
const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

// Helper to convert to Date or null for optional fields
const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

// Helper to convert empty string or null to null, otherwise return the string
const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};

export async function PUT(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    let body;
    try {
      body = await req.json();
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      religiousJourney,
      preferredReligiousJourneys, 
      about,
      // --- START: הוספת שדות חדשים ---
      profileHeadline,
      humorStory,
      inspiringCoupleStory,
      influentialRabbi,
      // --- END: הוספת שדות חדשים ---
      parentStatus,
      fatherOccupation,
      motherOccupation,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious,
      profileCharacterTraits,
      profileHobbies,
      aliyaCountry,
      aliyaYear,
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      preferredHasChildrenFromPrevious,
      preferredCharacterTraits,
      preferredHobbies,
      preferredAliyaStatus,
      hasViewedProfilePreview,
      hasMedicalInfo,
      medicalInfoDetails,
      medicalInfoDisclosureTiming,
      isMedicalInfoVisible,
    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status & Background (User's own) ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious; // User's own
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
     if (fatherOccupation !== undefined) dataToUpdate.fatherOccupation = emptyStringToNull(fatherOccupation);
    if (motherOccupation !== undefined) dataToUpdate.motherOccupation = emptyStringToNull(motherOccupation);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education, Occupation & Service (User's own) ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion & Lifestyle (User's own) ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
        if (religiousJourney !== undefined) dataToUpdate.religiousJourney = emptyStringToNull(religiousJourney) as ReligiousJourney | null;

    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (body.hasOwnProperty('kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (body.hasOwnProperty('headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits & Hobbies (User's own) ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || []; // User's own hobbies

    // --- About & Additional Info ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
      if (profileHeadline !== undefined) dataToUpdate.profileHeadline = emptyStringToNull(profileHeadline);
    if (humorStory !== undefined) dataToUpdate.humorStory = emptyStringToNull(humorStory);
    if (inspiringCoupleStory !== undefined) dataToUpdate.inspiringCoupleStory = emptyStringToNull(inspiringCoupleStory);
    if (influentialRabbi !== undefined) dataToUpdate.influentialRabbi = emptyStringToNull(influentialRabbi);
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    
    // --- Preferences (related to matching partner) ---
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah); // Assuming it's a string like "yes", "no" that needs to be nullable
    
    if (preferredHasChildrenFromPrevious !== undefined) {
      dataToUpdate.preferredHasChildrenFromPrevious = preferredHasChildrenFromPrevious;
    }

    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || []; // Preference for partner
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || []; // Preference for partner's hobbies
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);
    if (preferredReligiousJourneys !== undefined) dataToUpdate.preferredReligiousJourneys = preferredReligiousJourneys || [];

    // --- Profile Management ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
    if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
   
    // --- START: הוספת לוגיקת עדכון לשדות רפואיים ---
    if (hasMedicalInfo !== undefined) dataToUpdate.hasMedicalInfo = hasMedicalInfo;
    if (medicalInfoDetails !== undefined) dataToUpdate.medicalInfoDetails = emptyStringToNull(medicalInfoDetails);
    if (medicalInfoDisclosureTiming !== undefined) dataToUpdate.medicalInfoDisclosureTiming = emptyStringToNull(medicalInfoDisclosureTiming);
    if (isMedicalInfoVisible !== undefined) dataToUpdate.isMedicalInfoVisible = isMedicalInfoVisible;
    // --- END: הוספת לוגיקת עדכון לשדות רפואיים ---

    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      if (!body.hasOwnProperty('availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    if (body.hasOwnProperty('availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // --- Perform the database update ---
    let updatedProfileRecord: Profile | null = null;
    if (Object.keys(dataToUpdate).length > 0) {
      try {
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
        
        updateUserAiProfile(userId).catch(err => {
            console.error(`[AI Profile Trigger - Profile Update] Failed to update AI profile in the background for user ${userId}:`, err);
        });
      } catch (dbError) {
        console.error('Prisma profile update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // Construct the response, ensuring all UserProfile fields are mapped
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, 
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],
      about: dbProfile.about || "",
        profileHeadline: dbProfile.profileHeadline || undefined,
      humorStory: dbProfile.humorStory || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: refreshedUserWithProfile.isProfileComplete,
      // --- START: הוספת שדות רפואיים לתגובה ---
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      // --- END: הוספת שדות רפואיים לתגובה ---
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, 
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], 
      profileHobbies: dbProfile.profileHobbies || [],                 
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], 
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined, 
      preferredHasChildrenFromPrevious: dbProfile.preferredHasChildrenFromPrevious ?? undefined, 
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], 
      preferredHobbies: dbProfile.preferredHobbies || [],                 
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, 

      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('Profile update route error:', error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/questionnaire/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
export const dynamic = 'force-dynamic';
function isPrismaError(
  error: unknown
): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

const WORLD_IDS = [
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
] as const;

const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const baseAnswerSchema = z.object({
  questionId: z.string().min(1),
  worldId: WorldId,
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
  ]),
  answeredAt: z.string().datetime(),
  isVisible: z.boolean().optional().default(true), // הוספת השדה החדש עם ברירת מחדל
});

type QuestionAnswer = z.infer<typeof baseAnswerSchema>;

const QuestionnaireAnswer = baseAnswerSchema;

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional(),
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

function groupAnswersByWorld(answers: QuestionnaireSubmission['answers']) {
  return answers.reduce<Record<string, QuestionAnswer[]>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer: QuestionAnswer = {
      questionId: answer.questionId,
      worldId: answer.worldId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      isVisible: answer.isVisible, // העברת השדה
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);

    return acc;
  }, {});
}

function validateSubmissionData(
  data: unknown
): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);

  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'נדרשת התחברות' }, { status: 401 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    const transformedData = questionnaire
      ? {
          ...questionnaire,
          valuesAnswers: questionnaire.valuesAnswers || [],
          personalityAnswers: questionnaire.personalityAnswers || [],
          relationshipAnswers: questionnaire.relationshipAnswers || [],
          partnerAnswers: questionnaire.partnerAnswers || [],
          religionAnswers: questionnaire.religionAnswers || [],
        }
      : null;

    return NextResponse.json({
      success: true,
      data: transformedData,
    });
  } catch (error: unknown) {
    console.error('Error fetching questionnaire:', {
      message: isError(error) ? error.message : 'Unknown error occurred',
      stack: process.env.NODE_ENV === 'development' ? error : undefined,
    });

    return NextResponse.json(
      {
        error: 'אירעה שגיאה בטעינת השאלון',
        details: process.env.NODE_ENV === 'development' ? error : undefined,
      },
      { status: 500 }
    );
  }
}

type Answer = {
  questionId: string;
  worldId: WorldId;
  value: string | number | string[] | number[] | Record<string, number>;
  answeredAt: string;
  isVisible?: boolean; // הוספת השדה
};

type MergedAnswers = {
  valuesAnswers: Answer[];
  personalityAnswers: Answer[];
  relationshipAnswers: Answer[];
  partnerAnswers: Answer[];
  religionAnswers: Answer[];
};

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'נדרשת התחברות' }, { status: 401 });
    }

    const rawBody = await req.json();

    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json({ error: 'משתמש לא נמצא' }, { status: 404 });
    }

    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers:
        rawBody.answers?.filter(
          (answer: Answer) =>
            answer &&
            answer.questionId &&
            answer.worldId &&
            answer.value !== undefined &&
            answer.value !== null &&
            answer.value !== ''
        ) ?? [],
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json(
        {
          error: 'שגיאת ולידציה',
          details: isError(error) ? error.message : 'Unknown validation error',
        },
        { status: 400 }
      );
    }

    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    const result = await prisma.$transaction(async (prisma) => {
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' },
      });

      const mergedAnswers: MergedAnswers = {
        valuesAnswers: [
          ...((existingResponse?.valuesAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.valuesAnswers || []),
        ],
        personalityAnswers: [
          ...((existingResponse?.personalityAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.personalityAnswers || []),
        ],
        relationshipAnswers: [
          ...((existingResponse?.relationshipAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.relationshipAnswers || []),
        ],
        partnerAnswers: [
          ...((existingResponse?.partnerAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.partnerAnswers || []),
        ],
        religionAnswers: [
          ...((existingResponse?.religionAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.religionAnswers || []),
        ],
      };

      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof MergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce(
            (acc: Answer[], curr: Answer) => {
              const existingIndex = acc.findIndex(
                (a) => a.questionId === curr.questionId
              );
              if (existingIndex >= 0) {
                if (
                  new Date(curr.answeredAt) >
                  new Date(acc[existingIndex].answeredAt)
                ) {
                  acc[existingIndex] = curr;
                }
              } else {
                acc.push(curr);
              }
              return acc;
            },
            []
          );
          mergedAnswers[worldKey as keyof MergedAnswers] = uniqueAnswers;
        }
      }

      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          lastSaved: new Date(),
        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          lastSaved: new Date(),
        },
      });

      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: 'ACTIVE' },
        });
      }

      return savedQuestionnaire;
    });

    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error: unknown) {
    const errorMessage = isError(error)
      ? error.message
      : 'Unknown error occurred';
    const errorStack = isError(error) ? error.stack : undefined;

    console.error('Error details:', {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined,
    });

    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json(
            {
              error: 'שגיאה בשמירת השאלון - משתמש לא קיים',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 400 }
          );
        case 'P2002':
          return NextResponse.json(
            {
              error: 'שגיאה בשמירת השאלון - רשומה כבר קיימת',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 409 }
          );
        default:
          return NextResponse.json(
            {
              error: 'שגיאה בשמירת השאלון',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 500 }
          );
      }
    }

    return NextResponse.json(
      {
        error: 'אירעה שגיאה בשמירת השאלון',
        details:
          process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "נדרשת התחברות" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const requiredWorlds = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;
    const allWorldsCompleted = requiredWorlds.every(
      world => validatedData.worldsCompleted.includes(world)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "לא כל העולמות הושלמו"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: "לא נמצא שאלון להשלמה"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
      prisma.user.update({
        where: { id: session.user.id },
        data: { status: "ACTIVE" }
      })
    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "שגיאת ולידציה",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "אירעה שגיאה בהשלמת השאלון"
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/questionnaire/world/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
import { updateUserAiProfile } from '@/lib/services/profileAiService';

const WorldId = z.enum([
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
]);
type WorldId = z.infer<typeof WorldId>;

const answerSchema = z.object({
  questionId: z.string().min(1),
  value: z
    .union([
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined(),
    ])
    .optional(),
  answeredAt: z
    .string()
    .datetime()
    .transform((str) => new Date(str)),
  isVisible: z.boolean().optional().default(true), // הוספת השדה
});

const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(answerSchema),
});

type AnswerPayload = z.infer<typeof answerSchema>;

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const body = await req.json();
    const validationResult = worldAnswersSchema.safeParse(body);
    if (!validationResult.success) {
      console.error(
        'Validation error in /questionnaire/world:',
        validationResult.error
      );
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.flatten(),
        },
        { status: 400 }
      );
    }
    const { worldId, answers: newAnswers } = validationResult.data;

    const dbAnswersKey =
      `${worldId.toLowerCase()}Answers` as keyof Prisma.QuestionnaireResponseCreateInput;
    const dbCompletedKey =
      `${worldId.toLowerCase()}Completed` as keyof Prisma.QuestionnaireResponseCreateInput;

    const updatedQuestionnaire = await prisma.$transaction(async (tx) => {
      const existingResponse = await tx.questionnaireResponse.findFirst({
        where: { userId },
      });

      const newAnswersJson = newAnswers.map((ans) => ({
        ...ans,
        answeredAt: ans.answeredAt.toISOString(),
      })) as unknown as Prisma.JsonArray;

      const questionnaire = await tx.questionnaireResponse.upsert({
        where: { id: existingResponse?.id || 'new-response-placeholder' },
        create: {
          userId,
          startedAt: new Date(),
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: [worldId],
        },
        update: {
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: {
            push: worldId,
          },
        },
      });
      return questionnaire;
    });

    updateUserAiProfile(userId).catch((err) => {
      console.error(
        `[AI Profile Trigger - World Update] Failed to update AI profile for user ${userId} after updating world ${worldId}:`,
        err
      );
    });

    return NextResponse.json({
      success: true,
      message: `Successfully saved answers for world: ${worldId}`,
      data: updatedQuestionnaire,
    });
  } catch (error: unknown) {
    console.error('Error in PUT /api/questionnaire/world:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }

    const errorMessage =
      error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.string().refine((val) => !isNaN(Date.parse(val)), { // Validate as date string
    message: "Invalid date format for decisionDeadline",
  }).transform((val) => new Date(val)), // Transform to Date object
});

export async function POST(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) { // Check for user.id and user.role
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for POST ----
    // 2. Role verification (only matchmakers or admins can create suggestions)
    const allowedCreatorRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedCreatorRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to create suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE for POST ----

    // 3. Parse and validate request body
    const body = await req.json();
    const validationResult = createSuggestionSchema.safeParse(body);

    if (!validationResult.success) {
        return NextResponse.json(
            { error: "Validation error", details: validationResult.error.errors },
            { status: 400 }
        );
    }
    const validatedData = validationResult.data;


    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
                MatchSuggestionStatus.FIRST_PARTY_DECLINED, // Added
                MatchSuggestionStatus.SECOND_PARTY_DECLINED, // Added
                MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // Added
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: `Active or pending suggestion (ID: ${existingSuggestion.id}, Status: ${existingSuggestion.status}) already exists between these parties` },
        { status: 409 } // Conflict
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id, // The user creating is the matchmaker
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline,
          firstPartySent: new Date(),
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Initialize lastActivity
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion); // Consider passing the full suggestion object

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion, // Return the created suggestion object
    }, { status: 201 }); // HTTP 201 Created
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    // Handle Prisma unique constraint errors specifically if needed
    // if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {}
    
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for PATCH (General permission) ----
    const allowedUpdaterRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN, UserRole.CANDIDATE]; // CANDIDATE can update if they are a party
    if (!allowedUpdaterRoles.includes(session.user.role as UserRole)) {
        return NextResponse.json({ error: "Forbidden - Insufficient permissions to update suggestion status" }, { status: 403 });
    }
    // ---- END OF CHANGE for PATCH ----

    const body = await req.json();
    const { suggestionId, status, notes } = body; // Assuming status and notes are part of body

    // Validate incoming data (basic example)
    if (!suggestionId || !status) {
        return NextResponse.json({ error: "Missing suggestionId or status" }, { status: 400 });
    }
    if (!Object.values(MatchSuggestionStatus).includes(status as MatchSuggestionStatus)) {
        return NextResponse.json({ error: "Invalid status value" }, { status: 400 });
    }


    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true, // Include matchmaker for permission checks
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // ---- Specific permission check for PATCH ----
    // An ADMIN can update any suggestion.
    // A MATCHMAKER can update suggestions they created.
    // A CANDIDATE can update suggestions they are a party to (firstPartyId or secondPartyId).
    const isUserAdmin = session.user.role === UserRole.ADMIN;
    const isUserMatchmakerOwner = session.user.role === UserRole.MATCHMAKER && suggestion.matchmakerId === session.user.id;
    const isUserParty = session.user.role === UserRole.CANDIDATE && (suggestion.firstPartyId === session.user.id || suggestion.secondPartyId === session.user.id);

    if (!isUserAdmin && !isUserMatchmakerOwner && !isUserParty) {
        return NextResponse.json({ error: "Forbidden - You do not have permission to update this specific suggestion's status." }, { status: 403 });
    }
    // ---- End specific permission check ----


    // 3. Validate status transition (using your existing helper)
    const isValidTransition = validateStatusTransition(suggestion.status, status as MatchSuggestionStatus);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: `Invalid status transition from ${suggestion.status} to ${status}` },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status as MatchSuggestionStatus,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Update lastActivity
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            // closedAt: new Date(), // Typically, CONTACT_DETAILS_SHARED doesn't mean closed
          }),
          ...(status === MatchSuggestionStatus.CLOSED && { // Explicitly set closedAt for CLOSED status
            closedAt: new Date(),
          }),
        },
      });

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status: status as MatchSuggestionStatus,
          notes: notes || `Status changed to ${status} by user ${session.user.id}`, // Add more context to notes
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    // This logic might be better suited in a service layer or triggered by events
    // For example, if status is FIRST_PARTY_APPROVED, you might automatically transition to PENDING_SECOND_PARTY
    // and send notifications.
    // if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
    //   // TODO: Transition to PENDING_SECOND_PARTY and notify
    // } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
    //   // TODO: Transition to CONTACT_DETAILS_SHARED and notify
    // }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    if (error instanceof z.ZodError) { // Handle Zod validation errors if you add more validation
        return NextResponse.json(
            { error: "Validation error for status update", details: error.errors },
            { status: 400 }
        );
    }
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY, MatchSuggestionStatus.CANCELLED],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL, // Often matchmaker confirms before sharing
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED, // Or directly share
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [ // Matchmaker action after both parties approve
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.MATCH_DECLINED, // Matchmaker can decide not to proceed
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.MEETING_PENDING, // Or AWAITING_FIRST_DATE_FEEDBACK
        MatchSuggestionStatus.DATING, // If they skip formal feedback and start dating
        MatchSuggestionStatus.CLOSED, // If one party decides not to proceed after contact
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE, // If feedback leads to this
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [ // This might be too granular, DATNG might cover it
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK, // For feedback after 2nd date etc.
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // If it ends after 2nd date
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [ // This status might be redundant if AWAITING_FIRST_DATE_FEEDBACK is used
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [ // Similar to MEETING_PENDING
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [ // This is often equivalent to CONTACT_DETAILS_SHARED or DATNG
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENGAGED, // Could jump here
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED, // If dating ends
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CLOSED, // If engagement breaks
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [MatchSuggestionStatus.CLOSED], // Or just stay MARRIE
    EXPIRED: [MatchSuggestionStatus.CLOSED],
    CLOSED: [], // No transitions from CLOSED typically, except maybe reopening
    CANCELLED: [MatchSuggestionStatus.CLOSED] // Or just stay CANCELLED
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// תיקון קובץ src/app/api/matchmaker/suggestions/[id]/route.ts - בלי any

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole, Priority, Prisma } from "@prisma/client";
import prisma from "@/lib/prisma";

// הגדרת טיפוס לנתונים הנכנסים
interface SuggestionUpdateData {
  priority?: Priority;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: string | null;
}

// הגדרת טיפוס לנתוני העדכון של Prisma
interface PrismaUpdateData {
  lastActivity: Date;
  priority?: Priority;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: Date | null;
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    // וידוא משתמש מחובר
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    // וידוא הרשאות שדכן או אדמין
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const suggestionId = params.id;
    const data: SuggestionUpdateData = await req.json();
    
    console.log("PATCH request for suggestion:", suggestionId, "with data:", data);

    // בדיקת קיום ההצעה והרשאות
    const existingSuggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      select: {
        id: true,
        matchmakerId: true,
        status: true
      }
    });

    if (!existingSuggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // בדיקת הרשאות ספציפיות
    if (existingSuggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to edit this suggestion" },
        { status: 403 }
      );
    }

    // הכנת הנתונים לעדכון עם טיפוס מדויק
    const updateData: PrismaUpdateData = {
      lastActivity: new Date(),
    };

    // עדכון שדות אם קיימים
    if (data.priority !== undefined) {
      updateData.priority = data.priority;
    }

    if (data.matchingReason !== undefined) {
      updateData.matchingReason = data.matchingReason;
    }

    if (data.firstPartyNotes !== undefined) {
      updateData.firstPartyNotes = data.firstPartyNotes;
    }

    if (data.secondPartyNotes !== undefined) {
      updateData.secondPartyNotes = data.secondPartyNotes;
    }

    if (data.internalNotes !== undefined) {
      updateData.internalNotes = data.internalNotes;
    }

    if (data.decisionDeadline !== undefined) {
      updateData.decisionDeadline = data.decisionDeadline ? new Date(data.decisionDeadline) : null;
    }

    console.log("Updating suggestion with data:", updateData);

    // ביצוע העדכון
    const updatedSuggestion = await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: updateData,
      include: {
        firstParty: {
          select: { 
            id: true, 
            firstName: true, 
            lastName: true,
            images: { 
              select: { id: true, url: true, isMain: true }, 
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] 
            }, 
            profile: true 
          }
        },
        secondParty: {
          select: { 
            id: true, 
            firstName: true, 
            lastName: true,
            images: { 
              select: { id: true, url: true, isMain: true }, 
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] 
            }, 
            profile: true 
          }
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true }
        },
        statusHistory: { 
          orderBy: { createdAt: 'desc' } 
        }
      }
    });

    console.log("Suggestion updated successfully:", updatedSuggestion.id);

    // פורמט התאריכים ל-ISO strings
    const formattedSuggestion = {
      ...updatedSuggestion,
      firstParty: {
        ...updatedSuggestion.firstParty,
        profile: updatedSuggestion.firstParty.profile ? {
          ...updatedSuggestion.firstParty.profile,
          birthDate: updatedSuggestion.firstParty.profile.birthDate?.toISOString(),
          lastActive: updatedSuggestion.firstParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: updatedSuggestion.firstParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: updatedSuggestion.firstParty.profile.createdAt?.toISOString(),
          updatedAt: updatedSuggestion.firstParty.profile.updatedAt?.toISOString()
        } : null
      },
      secondParty: {
        ...updatedSuggestion.secondParty,
        profile: updatedSuggestion.secondParty.profile ? {
          ...updatedSuggestion.secondParty.profile,
          birthDate: updatedSuggestion.secondParty.profile.birthDate?.toISOString(),
          lastActive: updatedSuggestion.secondParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: updatedSuggestion.secondParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: updatedSuggestion.secondParty.profile.createdAt?.toISOString(),
          updatedAt: updatedSuggestion.secondParty.profile.updatedAt?.toISOString()
        } : null
      },
      statusHistory: updatedSuggestion.statusHistory.map(history => ({
        ...history,
        createdAt: history.createdAt.toISOString()
      })),
      responseDeadline: updatedSuggestion.responseDeadline?.toISOString(),
      decisionDeadline: updatedSuggestion.decisionDeadline?.toISOString(),
      lastStatusChange: updatedSuggestion.lastStatusChange?.toISOString(),
      firstPartySent: updatedSuggestion.firstPartySent?.toISOString(),
      firstPartyResponded: updatedSuggestion.firstPartyResponded?.toISOString(),
      secondPartySent: updatedSuggestion.secondPartySent?.toISOString(),
      secondPartyResponded: updatedSuggestion.secondPartyResponded?.toISOString(),
      firstMeetingScheduled: updatedSuggestion.firstMeetingScheduled?.toISOString(),
      closedAt: updatedSuggestion.closedAt?.toISOString(),
      createdAt: updatedSuggestion.createdAt.toISOString(),
      updatedAt: updatedSuggestion.updatedAt.toISOString(),
      lastActivity: updatedSuggestion.lastActivity.toISOString()
    };
      
    return NextResponse.json({
      success: true,
      data: formattedSuggestion
    });
      
  } catch (error) {
    console.error("Error updating suggestion:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest, // req is not used, can be removed if not needed
  context: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const suggestionId = context.params.id;

    // בדיקה שההצעה קיימת
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // ---- START OF CHANGE ----
    // הרשאות:
    // 1. אדמין יכול למחוק כל הצעה.
    // 2. שדכן יכול למחוק רק הצעה שהוא יצר.
    const userRole = session.user.role as UserRole;
    const isOwner = suggestion.matchmakerId === session.user.id;

    if (userRole === UserRole.ADMIN) {
      // Admin can delete any suggestion
    } else if (userRole === UserRole.MATCHMAKER && isOwner) {
      // Matchmaker can delete their own suggestion
    } else {
      // Any other case is forbidden
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to delete this suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE ----

    // מחיקת ההצעה וכל הנתונים הקשורים אליה (ודא ש-onDelete: Cascade מוגדר בסכמה אם רלוונטי)
    // אם אין Cascade, יש למחוק רשומות קשורות ידנית קודם.
    // הסדר הנוכחי שלך נראה טוב אם אין Cascade על הכל.
    await prisma.$transaction(async (tx) => { // Changed to async for await inside
      // מחיקת היסטוריית סטטוסים
      await tx.suggestionStatusHistory.deleteMany({
        where: { suggestionId },
      });
      // מחיקת שאלות
      await tx.suggestionInquiry.deleteMany({
        where: { suggestionId },
      });
      // מחיקת פגישות (אם קיימות וקשורות ישירות)
      await tx.meeting.deleteMany({
        where: { suggestionId },
      });
      // Consider other related data like DateFeedback
      await tx.dateFeedback.deleteMany({
        where: { suggestionId },
      });

      // הסרת קשרים בטבלאות קשר רבים-לרבים (אם יש)
      // לדוגמה, אם יש קשר approvedBy, reviewedBy ב-MatchSuggestion
      await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          approvedBy: { set: [] }, // Assuming relation exists
          reviewedBy: { set: [] }, // Assuming relation exists
        }
      });
      
      // מחיקת ההצעה עצמה
      await tx.matchSuggestion.delete({
        where: { id: suggestionId },
      });
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully",
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    // Consider more specific error handling (e.g., Prisma errors)
    return NextResponse.json(
      { error: "Internal server error during suggestion deletion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/inquiries/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { InquiryStatus, UserRole } from "@prisma/client";
import type { Session } from "next-auth";

type AuthSession = Session | null;

async function checkPermissions(suggestionId: string, session: AuthSession) {
  if (!session?.user?.id) {
    throw new Error("Unauthorized");
  }

  const suggestion = await prisma.matchSuggestion.findUnique({
    where: { id: suggestionId },
    select: { firstPartyId: true, secondPartyId: true, matchmakerId: true },
  });

  if (!suggestion) {
    throw new Error("Suggestion not found");
  }

  const isAuthorized =
    session.user.id === suggestion.firstPartyId ||
    session.user.id === suggestion.secondPartyId ||
    session.user.id === suggestion.matchmakerId ||
    session.user.role === UserRole.ADMIN;

  if (!isAuthorized) {
    throw new Error("Forbidden");
  }

  return { suggestion, userId: session.user.id, userRole: session.user.role as UserRole };
}

/**
 * GET: Fetch all inquiries for a specific suggestion.
 * Users can only see inquiries for suggestions they are a part of.
 */
export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    await checkPermissions(params.id, session);

    const inquiries = await prisma.suggestionInquiry.findMany({
      where: { suggestionId: params.id },
      include: {
        fromUser: { select: { id: true, firstName: true, lastName: true } },
        toUser: { select: { id: true, firstName: true, lastName: true } },
      },
      orderBy: { createdAt: "asc" },
    });

    return NextResponse.json({ success: true, inquiries });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error fetching inquiries:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * POST: Create a new inquiry (question) for a suggestion.
 * A user (candidate) sends a question to the matchmaker.
 */
export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const { suggestion, userId } = await checkPermissions(params.id, session);

    const { question } = await req.json();
    if (!question || typeof question !== 'string' || question.trim().length === 0) {
      return NextResponse.json({ error: "Question content is required" }, { status: 400 });
    }

    // --- START OF MODIFICATION ---
    // Perform both operations in a single transaction
    const inquiry = await prisma.$transaction(async (tx) => {
      // 1. Create the new inquiry
      const newInquiry = await tx.suggestionInquiry.create({
        data: {
          suggestionId: params.id,
          fromUserId: userId,
          toUserId: suggestion.matchmakerId, // Questions always go to the matchmaker
          question,
          status: InquiryStatus.PENDING,
        },
      });

      // 2. Update the parent suggestion's lastActivity timestamp
      await tx.matchSuggestion.update({
        where: { id: params.id },
        data: { lastActivity: new Date() },
      });

      return newInquiry;
    });
    // --- END OF MODIFICATION ---
    
    // TODO: Add notification to matchmaker about the new question

    return NextResponse.json({ success: true, inquiry });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error creating inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * PATCH: Answer an inquiry.
 * Only the matchmaker (or an admin) can answer an inquiry.
 */
export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const { userRole, userId } = await checkPermissions(params.id, session); // params.id is suggestionId

    if (userRole !== UserRole.MATCHMAKER && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: Only matchmakers or admins can answer inquiries." }, { status: 403 });
    }

    const { inquiryId, answer } = await req.json();
    if (!inquiryId || !answer || typeof answer !== 'string' || answer.trim().length === 0) {
      return NextResponse.json({ error: "Inquiry ID and answer content are required" }, { status: 400 });
    }

    const inquiryToUpdate = await prisma.suggestionInquiry.findUnique({
        where: { id: inquiryId },
    });

    if (!inquiryToUpdate) {
        return NextResponse.json({ error: "Inquiry not found." }, { status: 404 });
    }

    if (inquiryToUpdate.toUserId !== userId && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: You are not the recipient of this inquiry." }, { status: 403 });
    }

    // --- START OF MODIFICATION ---
    // Perform both operations in a single transaction
    const updatedInquiry = await prisma.$transaction(async (tx) => {
      // 1. Update the inquiry with the answer
      const inquiry = await tx.suggestionInquiry.update({
        where: { id: inquiryId },
        data: {
          answer,
          status: InquiryStatus.ANSWERED,
          answeredAt: new Date(),
        },
      });

      // 2. Update the parent suggestion's lastActivity timestamp
      await tx.matchSuggestion.update({
        where: { id: params.id }, // params.id is the suggestionId
        data: { lastActivity: new Date() },
      });

      return inquiry;
    });
    // --- END OF MODIFICATION ---
    
    // TODO: Add notification to the user who asked the question

    return NextResponse.json({ success: true, inquiry: updatedInquiry });
  } catch (error) {
     if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error answering inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// Full path: src/app/api/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { MatchSuggestionStatus, MatchSuggestion, UserRole } from "@prisma/client";
import { statusTransitionService } from "@/app/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";

// Validation schema for status update
const statusUpdateSchema = z.object({
  status: z.enum([
    "DRAFT",
    "PENDING_FIRST_PARTY",
    "FIRST_PARTY_APPROVED",
    "FIRST_PARTY_DECLINED",
    "PENDING_SECOND_PARTY",
    "SECOND_PARTY_APPROVED",
    "SECOND_PARTY_DECLINED",
    "AWAITING_MATCHMAKER_APPROVAL",
    "CONTACT_DETAILS_SHARED",
    "AWAITING_FIRST_DATE_FEEDBACK",
    "THINKING_AFTER_DATE",
    "PROCEEDING_TO_SECOND_DATE",
    "ENDED_AFTER_FIRST_DATE",
    "MEETING_PENDING",
    "MEETING_SCHEDULED",
    "MATCH_APPROVED",
    "MATCH_DECLINED",
    "DATING",
    "ENGAGED",
    "MARRIED",
    "EXPIRED",
    "CLOSED",
    "CANCELLED"
  ] as const),
  notes: z.string().optional(),
  feedback: z.string().optional(),
  meetingDate: z.string().optional(),
  customMessage: z.string().optional(),
});

export async function PATCH(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    // Extract parameters
    const params = await context.params;
    const suggestionId = params.id;

    // Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Parse and validate request body
    const body = await req.json();
    
    try {
      const validatedData = statusUpdateSchema.parse(body);
      
      // Fetch current suggestion with related parties
      const suggestion = await prisma.matchSuggestion.findUnique({
        where: { id: suggestionId },
        include: {
          firstParty: {
            include: { profile: true }
          },
          secondParty: {
            include: { profile: true }
          },
          matchmaker: true,
        },
      });

      if (!suggestion) {
        return NextResponse.json(
          { error: "Suggestion not found" },
          { status: 404 }
        );
      }

      // --- START OF CHANGE ---
      // Check if a candidate is trying to approve a suggestion while another one is already active.
      const isCandidateApproval =
        session.user.role === UserRole.CANDIDATE &&
        (validatedData.status === MatchSuggestionStatus.FIRST_PARTY_APPROVED ||
         validatedData.status === MatchSuggestionStatus.SECOND_PARTY_APPROVED);

      if (isCandidateApproval) {
        const activeProcessStatuses: MatchSuggestionStatus[] = [
          "FIRST_PARTY_APPROVED",
          "SECOND_PARTY_APPROVED",
          "AWAITING_MATCHMAKER_APPROVAL",
          "CONTACT_DETAILS_SHARED",
          "AWAITING_FIRST_DATE_FEEDBACK",
          "THINKING_AFTER_DATE",
          "PROCEEDING_TO_SECOND_DATE",
          "MEETING_PENDING",
          "MEETING_SCHEDULED",
          "MATCH_APPROVED",
          "DATING",
          "ENGAGED",
        ];

        const existingActiveSuggestion = await prisma.matchSuggestion.findFirst({
          where: {
            id: { not: suggestionId }, // Exclude the current suggestion being updated
            OR: [
              { firstPartyId: session.user.id },
              { secondPartyId: session.user.id },
            ],
            status: { in: activeProcessStatuses },
          },
        });

        if (existingActiveSuggestion) {
          return NextResponse.json(
            { error: "לא ניתן לאשר הצעה חדשה כאשר ישנה הצעה אחרת בתהליך פעיל." },
            { status: 409 } // 409 Conflict
          );
        }
      }
      // --- END OF CHANGE ---

      // Validate user permissions
      if (
        suggestion.firstPartyId !== session.user.id &&
        suggestion.secondPartyId !== session.user.id &&
        suggestion.matchmakerId !== session.user.id
      ) {
        return NextResponse.json(
          { error: "Unauthorized to update this suggestion" },
          { status: 403 }
        );
      }

      // Define transition options based on the type of update
      const transitionOptions = {
        sendNotifications: true,
        customMessage: validatedData.customMessage,
        notifyParties: ['first', 'second', 'matchmaker'] as ('first' | 'second' | 'matchmaker')[]
      };

      // Handle special cases for different status updates
      if (validatedData.status === "CONTACT_DETAILS_SHARED" && 
          validatedData.feedback && 
          validatedData.notes) {
        await createMeetingIfNecessary(suggestionId, validatedData);
      }

      // Process automatic secondary actions for certain status changes
      const secondaryAction = determineSecondaryAction(suggestion.status, validatedData.status);

      // Update suggestion status
      let updatedSuggestion = await statusTransitionService.transitionStatus(
        suggestion,
        validatedData.status as MatchSuggestionStatus,
        validatedData.notes,
        transitionOptions
      );

      // Process any secondary action if needed
      if (secondaryAction) {
        try {
          updatedSuggestion = await statusTransitionService.transitionStatus(
            updatedSuggestion,
            secondaryAction,
            `Automatic transition after ${validatedData.status}`,
            { 
              ...transitionOptions,
              customMessage: `התבצע מעבר אוטומטי לסטטוס ${statusTransitionService.getStatusLabel(secondaryAction)}`
            }
          );
        } catch (secondaryActionError) {
          console.warn("Warning: Secondary status transition failed:", secondaryActionError);
          // Continue with the response even if secondary action fails
        }
      }

      // Update party profiles if needed (e.g., changing availability status)
      await updateProfilesIfNeeded(validatedData.status as MatchSuggestionStatus, suggestion);

      return NextResponse.json({
        success: true,
        suggestion: updatedSuggestion,
      });

    } catch (validationError) {
      if (validationError instanceof z.ZodError) {
        return NextResponse.json({
          error: "Validation error",
          details: validationError.errors
        }, { status: 400 });
      }
      throw validationError;
    }

  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json(
      { 
        error: "Internal server error",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

// Helper function to determine if a secondary action should be taken
function determineSecondaryAction(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): MatchSuggestionStatus | null {
  // Automatic transitions

const automaticTransitions: Partial<Record<MatchSuggestionStatus, MatchSuggestionStatus>> = {    FIRST_PARTY_APPROVED: MatchSuggestionStatus.PENDING_SECOND_PARTY,
    SECOND_PARTY_APPROVED: MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
    FIRST_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
    SECOND_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
  };

  return automaticTransitions[newStatus] || null;
}

// Helper function to create a meeting record if needed
async function createMeetingIfNecessary(
  suggestionId: string,
  data: z.infer<typeof statusUpdateSchema>
) {
  if (data.meetingDate) {
    // Create a meeting record
    await prisma.meeting.create({
      data: {
        suggestionId,
        scheduledDate: new Date(data.meetingDate),
        status: "SCHEDULED",
        notes: data.notes || "Automatically created when contact details were shared",
      }
    });
  }
}

// Helper function to update profiles if needed
async function updateProfilesIfNeeded(
  newStatus: MatchSuggestionStatus,
  suggestion: MatchSuggestion,
) {
  // Special handling for ENGAGED and MARRIED statuses
  if (newStatus === "ENGAGED" || newStatus === "MARRIED") {
    const availabilityStatus = newStatus === "ENGAGED" ? "ENGAGED" : "MARRIED";
    
    // Update both profiles with the new status
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: {
          availabilityStatus,
          availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`,
          availabilityUpdatedAt: new Date()
        }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: {
          availabilityStatus,
          availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`,
          availabilityUpdatedAt: new Date()
        }
      })
    ]);
  }
  
  // For DATING status, mark both profiles as unavailable
  if (newStatus === "DATING") {
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: {
          availabilityStatus: "DATING",
          availabilityNote: "Currently in a dating process",
          availabilityUpdatedAt: new Date()
        }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: {
          availabilityStatus: "DATING",
          availabilityNote: "Currently in a dating process",
          availabilityUpdatedAt: new Date()
        }
      })
    ]);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/active/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { formatAnswers, KEY_MAPPING, DbWorldKey, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { ExtendedMatchSuggestion, PartyInfo, QuestionnaireResponse } from "@/app/components/suggestions/types";
import type { FormattedAnswer, WorldId } from "@/types/next-auth";
export const dynamic = 'force-dynamic';
// --- טיפוסים חזקים ומדויקים לתהליך העיבוד ---
type ProcessedQuestionnaireResponse = Omit<QuestionnaireResponse, 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers'> & {
  formattedAnswers: FormattedAnswersType;
};

type ProcessedPartyInfo = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: ProcessedQuestionnaireResponse[];
};

type SuggestionWithFormattedData = Omit<ExtendedMatchSuggestion, 'firstParty' | 'secondParty'> & {
  firstParty: ProcessedPartyInfo;
  secondParty: ProcessedPartyInfo;
};

// הטיפוס שמגיע מ-Prisma. שימו לב ש-questionnaireResponses הוא מהסוג הגולמי.
type PartyInfoFromPrisma = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: QuestionnaireResponse[];
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: session.user.id, status: { in: ["PENDING_FIRST_PARTY", "FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] } },
          { secondPartyId: session.user.id, status: { in: ["PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] } },
        ],
      },
      include: {
        statusHistory: { orderBy: { createdAt: 'desc' } },
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
        secondParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // --- עיבוד נתונים עם טיפוסים חזקים (ללא any) ---
    const suggestionsWithFormattedQuestionnaires: SuggestionWithFormattedData[] = activeSuggestions.map((suggestion) => {
        
        // הפונקציה הזו מקבלת את הטיפוס הגולמי מפריזמה ומחזירה את הטיפוס המעובד
        const formatPartyQuestionnaire = (party: PartyInfoFromPrisma): ProcessedPartyInfo => {
            const { questionnaireResponses, ...restOfParty } = party;

            if (questionnaireResponses && questionnaireResponses.length > 0) {
                const qr = questionnaireResponses[0];
                const formattedAnswers: Partial<FormattedAnswersType> = {};

                (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
                    const dbKey = KEY_MAPPING[worldKey];
                    // גישה בטוחה יותר לשדה דינמי
                    const answersJson = qr[dbKey];
                    formattedAnswers[worldKey] = formatAnswers(answersJson);
                });
                
                // הסרת השדות הגולמיים ויצירת האובייקט המעובד
                const { valuesAnswers, personalityAnswers, relationshipAnswers, partnerAnswers, religionAnswers, ...restOfQr } = qr;
                const processedQr: ProcessedQuestionnaireResponse = {
                    ...restOfQr,
                    formattedAnswers: formattedAnswers as FormattedAnswersType,
                };
                
                return { ...restOfParty, questionnaireResponses: [processedQr] };
            }
            // אם אין שאלון, מחזירים את שאר המידע על המשתמש
            return restOfParty;
        };

        return {
            ...suggestion,
            firstParty: formatPartyQuestionnaire(suggestion.firstParty),
            secondParty: formatPartyQuestionnaire(suggestion.secondParty),
        };
    });

    return NextResponse.json({
      success: true,
      suggestions: suggestionsWithFormattedQuestionnaires,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/history/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { formatAnswers, KEY_MAPPING, DbWorldKey, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { ExtendedMatchSuggestion, PartyInfo, QuestionnaireResponse, WorldId } from "@/app/components/suggestions/types";
import type { FormattedAnswer } from "@/types/next-auth";
export const dynamic = 'force-dynamic';
// --- טיפוסים חזקים ומדויקים לתהליך העיבוד ---
type ProcessedQuestionnaireResponse = Omit<QuestionnaireResponse, 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers'> & {
  formattedAnswers: FormattedAnswersType;
};

type ProcessedPartyInfo = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: ProcessedQuestionnaireResponse[];
};

type SuggestionWithFormattedData = Omit<ExtendedMatchSuggestion, 'firstParty' | 'secondParty'> & {
  firstParty: ProcessedPartyInfo;
  secondParty: ProcessedPartyInfo;
};

// הטיפוס שמגיע מ-Prisma.
type PartyInfoFromPrisma = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: QuestionnaireResponse[];
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: session.user.id, status: { in: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] } },
          { secondPartyId: session.user.id, status: { in: ["SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] } },
        ],
      },
      include: {
        statusHistory: { orderBy: { createdAt: 'desc' } },
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
        secondParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
      },
      orderBy: { updatedAt: "desc" },
    });

    const suggestionsWithFormattedQuestionnaires: SuggestionWithFormattedData[] = historySuggestions.map(suggestion => {
        const formatPartyQuestionnaire = (party: PartyInfoFromPrisma): ProcessedPartyInfo => {
            const { questionnaireResponses, ...restOfParty } = party;

            if (questionnaireResponses && questionnaireResponses.length > 0) {
                const qr = questionnaireResponses[0];
                const formattedAnswers: Partial<FormattedAnswersType> = {};

                (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
                    const dbKey = KEY_MAPPING[worldKey];
                    const answersJson = qr[dbKey];
                    formattedAnswers[worldKey] = formatAnswers(answersJson);
                });
                
                const { valuesAnswers, personalityAnswers, relationshipAnswers, partnerAnswers, religionAnswers, ...restOfQr } = qr;
                const processedQr: ProcessedQuestionnaireResponse = {
                    ...restOfQr,
                    formattedAnswers: formattedAnswers as FormattedAnswersType,
                };
                
                return { ...restOfParty, questionnaireResponses: [processedQr] };
            }
            return restOfParty;
        };

        return {
            ...suggestion,
            firstParty: formatPartyQuestionnaire(suggestion.firstParty),
            secondParty: formatPartyQuestionnaire(suggestion.secondParty),
        };
    });

    return NextResponse.json({
      success: true,
      suggestions: suggestionsWithFormattedQuestionnaires,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/accept-terms/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // ודא שהנתיב ל-authOptions נכון
import prisma from "@/lib/prisma";

export async function POST() {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const userId = session.user.id;

    // בדוק אם המשתמש כבר אישר את התנאים כדי למנוע עדכונים מיותרים
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { termsAndPrivacyAcceptedAt: true },
    });

    if (user?.termsAndPrivacyAcceptedAt) {
      return NextResponse.json({ success: true, message: 'Terms already accepted' });
    }

    // עדכן את המשתמש עם חתימת זמן ההסכמה
    await prisma.user.update({
      where: { id: userId },
      data: {
        termsAndPrivacyAcceptedAt: new Date(),
      },
    });

    // אין צורך להחזיר את הסשן המעודכן כאן, הלקוח ירענן אותו עם update()
    return NextResponse.json({ success: true, message: 'Terms accepted successfully' });

  } catch (error) {
    console.error('Error accepting terms:', error);
    let errorMessage = 'An unexpected error occurred';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\complete-onboarding
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\complete-onboarding\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/complete-onboarding/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth"; // ודא שהנתיב נכון לקובץ ה-auth שלך
import prisma from "@/lib/prisma"; // ודא שהנתיב נכון לקובץ ה-prisma client שלך

export async function POST(req: Request) {
  try {
    // 1. אימות הסשן של המשתמש בצד השרת
    const session = await getServerSession(authOptions);

    // 2. בדיקה אם המשתמש מחובר
    if (!session || !session.user || !session.user.id) {
      console.warn("[API/complete-onboarding] Unauthorized attempt: No session found.");
      return NextResponse.json(
        { success: false, error: "Unauthorized: User not authenticated." },
        { status: 401 }
      );
    }

    const userId = session.user.id;
    console.log(`[API/complete-onboarding] Received request for user ID: ${userId}`);

    // 3. עדכון מסד הנתונים
    // אנו בודקים אם המשתמש כבר השלים את הסיור כדי למנוע כתיבות מיותרות ל-DB
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { hasCompletedOnboarding: true }
    });

    if (user?.hasCompletedOnboarding) {
      console.log(`[API/complete-onboarding] User ${userId} has already completed onboarding. No update needed.`);
      return NextResponse.json(
        { success: true, message: "Onboarding was already completed." },
        { status: 200 }
      );
    }
    
    // אם לא הושלם, עדכן את הדגל ל-true
    await prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        hasCompletedOnboarding: true,
      },
    });

    console.log(`[API/complete-onboarding] Successfully updated hasCompletedOnboarding for user ID: ${userId}`);

    // 4. החזרת תגובת הצלחה
    return NextResponse.json(
      { success: true, message: "Onboarding status updated successfully." },
      { status: 200 }
    );

  } catch (error) {
    console.error("[API/complete-onboarding] Error:", error);

    // טיפול בשגיאות כלליות
    let errorMessage = "An internal server error occurred.";
    if (error instanceof Error) {
      errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\marketing-consent
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\marketing-consent\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/marketing-consent/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';

// Zod schema for validation
const updateConsentSchema = z.object({
  marketingConsent: z.boolean({
    required_error: "Marketing consent status is required.",
    invalid_type_error: "Marketing consent must be a boolean.",
  }),
});

export async function PUT(req: Request) {
  try {
    // 1. Authenticate user
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. Parse and validate request body
    const body = await req.json();
    const validationResult = updateConsentSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: 'Invalid input', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }
    
    const { marketingConsent } = validationResult.data;

    // 3. Update the user record in the database
    await prisma.user.update({
      where: { id: userId },
      data: {
        marketingConsent: marketingConsent,
      },
    });

    // 4. Return success response
    // The client will use useSession().update() to refresh the session token
    return NextResponse.json({ success: true, message: 'Marketing consent updated successfully.' });

  } catch (error) {
    console.error('Error updating marketing consent:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json(
      { success: false, error: "Internal server error.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

