################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api
# Generated on: 2025-10-08 07:17:21
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\api_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
# Generated on: 2025-10-07 23:51:32
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log(' Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/send-manual/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // 爪 转 砖转砖
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } },
        dripCampaign: true
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    //  驻专驻 engagement
    const profile = await SmartEngagementOrchestrator['buildUserEngagementProfile'](userId);
    
    // 爪专  转
    let email;
    switch (emailType) {
      case 'EVENING_FEEDBACK':
        const dailyActivity = await SmartEngagementOrchestrator['detectDailyActivity'](userId);
        email = await SmartEngagementOrchestrator['getEveningFeedbackEmail'](profile, dailyActivity);
        break;
      case 'AI_SUMMARY':
        email = await SmartEngagementOrchestrator['getAiSummaryEmail'](profile);
        break;
      case 'NUDGE':
        email = await SmartEngagementOrchestrator['getQuestionnaireNudgeEmail'](profile);
        break;
      // 住祝 注 拽专 驻 爪专
      default:
        return NextResponse.json(
          { error: 'Unsupported email type' },
          { status: 400 }
        );
    }

    if (!email) {
      return NextResponse.json(
        { error: 'Could not generate email for this user state' },
        { status: 400 }
      );
    }

    // 砖
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: email.type
    });

  } catch (error) {
    console.error('Error sending manual email:', error);
    return NextResponse.json(
      { error: 'Failed to send email' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    // 拽转 专砖转
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // 住驻专转  
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // 住驻专转  砖注
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // 砖转砖 驻注
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // 转驻转 砖
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // 砖 驻砖 砖  砖
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // 驻注转 专
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // 转驻转 住 
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for engagement_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log(' Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/send-manual/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // 爪 转 砖转砖
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } },
        dripCampaign: true
      }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    //  驻专驻 engagement
    const profile = await SmartEngagementOrchestrator['buildUserEngagementProfile'](userId);
    
    // 爪专  转
    let email;
    switch (emailType) {
      case 'EVENING_FEEDBACK':
        const dailyActivity = await SmartEngagementOrchestrator['detectDailyActivity'](userId);
        email = await SmartEngagementOrchestrator['getEveningFeedbackEmail'](profile, dailyActivity);
        break;
      case 'AI_SUMMARY':
        email = await SmartEngagementOrchestrator['getAiSummaryEmail'](profile);
        break;
      case 'NUDGE':
        email = await SmartEngagementOrchestrator['getQuestionnaireNudgeEmail'](profile);
        break;
      // 住祝 注 拽专 驻 爪专
      default:
        return NextResponse.json(
          { error: 'Unsupported email type' },
          { status: 400 }
        );
    }

    if (!email) {
      return NextResponse.json(
        { error: 'Could not generate email for this user state' },
        { status: 400 }
      );
    }

    // 砖
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: email.type
    });

  } catch (error) {
    console.error('Error sending manual email:', error);
    return NextResponse.json(
      { error: 'Failed to send email' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    // 拽转 专砖转
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // 住驻专转  
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // 住驻专转  砖注
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // 砖转砖 驻注
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // 转驻转 砖
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // 砖 驻砖 砖  砖
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // 驻注转 专
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // 转驻转 住 
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
# Generated on: 2025-10-05 16:19:59
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * 驻 拽砖转 POST 转 驻专驻 砖转砖 爪注转 AI.
 * 驻拽爪 转转 转 砖转砖, 爪专转 驻专驻 专 拽祝,
 * 砖转 转 转 AI, 专 转 转爪 转.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 砖 1: 转 砖转砖
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 砖 2:  砖砖转砖 驻专驻 拽 驻 爪专转 专
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile]  爪 驻专驻 注专 砖转砖: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 砖 3: 爪专转 驻专驻 专 拽祝
    // 砖砖 专 拽 拽转 爪转 -profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] 砖 爪专转 驻专驻 专 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 砖 4: 砖转 专 转 AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] 砖专转 -AI  专 转爪 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // 砖 5: 专转 转爪 拽
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * 驻 拽砖转 POST 转 爪注转 砖 注专 砖转砖 专.
 * 驻拽爪 转转 转 砖转砖, 专转 转 驻专驻 砖 转 驻专驻 砖 砖转砖 爪注,
 * 爪专转 驻专驻 专 注专 砖, 砖转 转 转 AI 转 砖转砖,
 * 专 转 转爪 转.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. 转 拽转 砖转砖 
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. 拽转 ID 砖 砖转砖 爪注 祝 拽砖
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3.  砖砖 驻专驻 拽
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion]  驻专驻  砖  爪. 爪: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. 爪专转 驻专驻 专 注专 砖 砖转砖 拽
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] 砖 爪专转 驻专驻 专 注专  砖转砖.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. 砖转 专 转 AI 转 砖转砖
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] 砖专转 -AI  专 转爪转 转 爪注.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. 专转 转爪 拽
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
# Generated on: 2025-09-28 20:43:55
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * 驻 拽砖转 POST 转 驻专驻 砖 砖转砖 住驻爪驻 注  砖.
 */
export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 砖 1: 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 砖 2: 拽转 ID 注 转 祝 拽砖
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId 住专   转拽 拽砖.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 砖 3: 爪专转 驻专驻 专 注专 砖转砖 拽砖
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] 砖 爪专转 驻专驻 专 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 砖 4: 砖转 专 转 AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] 砖专转 -AI  专 转爪 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // 砖 5: 专转 转爪 爪转
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. 拽转 ID 注 祝 拽砖
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. 爪专转 驻专驻 专 拽祝
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. 砖转 专 -AI 爪专转 住
    const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. 专转 转爪 爪转
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// 专砖 helpers 砖 Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // 注转 
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // 拽 砖  拽
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // 爪专转  注 驻住 转拽
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict //  专 驻住 
    );

    // 转 拽拽住 转转
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "漏 {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "砖/转 砖",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // 注转 转转 -Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // 住驻转 greeting 拽拽住
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "砖 {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // 专转 转 注 headers 
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// 拽专 砖专转  注 转 注专
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * 驻 拽砖转 POST 转 驻专驻 砖 砖转砖 住驻爪驻 注  砖.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 砖 1: 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 砖 2: 拽转 ID 注 转 祝 拽砖
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId 住专   转拽 拽砖.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 砖 3: 爪专转 驻专驻 专 注专 砖转砖 拽砖
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] 砖 爪专转 驻专驻 专 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 砖 4: 砖转 专 转 AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] 砖专转 -AI  专 转爪 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // 砖 5: 专转 转爪 爪转
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. 拽转 ID 注 祝 拽砖
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. 爪专转 驻专驻 专 拽祝
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. 砖转 专 -AI 爪专转 住
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. 专转 转爪 爪转
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// 专砖 helpers 砖 Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // 注转 
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // 拽 砖  拽
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // 爪专转  注 驻住 转拽
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict //  专 驻住 
    );

    // 转 拽拽住 转转
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "漏 {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "砖/转 砖",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // 注转 转转 -Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // 住驻转 greeting 拽拽住
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "砖 {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // 专转 转 注 headers 
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// 拽专 砖专转  注 转 注专
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/test-connection/route.ts

import { NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function GET() {
  console.log('--- [API TEST] Received request at /api/ai/test-connection ---');

  const apiKey = process.env.GOOGLE_API_KEY;

  if (!apiKey) {
    console.error('--- [API TEST] FATAL ERROR: GOOGLE_API_KEY is not set in .env or .env.local!');
    return NextResponse.json(
      { success: false, error: 'Server configuration error: GOOGLE_API_KEY is missing.' },
      { status: 500 }
    );
  }

  // --- 拽注 转 砖住驻 ---
  const keyIdentifier = `Starts with: ${apiKey.substring(0, 5)}... | Ends with: ...${apiKey.substring(apiKey.length - 4)} | Length: ${apiKey.length}`; // <-- 住祝
  console.log(`--- [API TEST] Verifying the loaded API Key: ${keyIdentifier} ---`); // <-- 住祝
  // -----------------------------

  console.log('--- [API TEST] GOOGLE_API_KEY found. Proceeding with API call.');

  try {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' }); 
    const prompt = 'Say "Connection Successful" in one sentence.';

    console.log('--- [API TEST] Sending a simple prompt to Google AI...');
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    console.log('--- [API TEST] SUCCESS! Google AI responded:', text);
    return NextResponse.json({ success: true, message: 'Connection to Google AI is working!', response: text });

  } catch (error) {
    console.error('--- [API TEST] FAILED! The API call to Google threw an error.', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to connect to Google AI. This is likely an API key, permissions, or billing issue.',
        details: JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * 驻拽爪转 注专 砖专爪 转 转 注 专拽注
 * 驻住  驻专 住.
 * @param userIds - 注专  砖转砖 注
 * @param adminId -   砖驻注 转 转
 */
async function runBulkUpdateAndLog(userIds: string[], adminId: string) {
  const totalUsers = userIds.length;
  // 注转 转 专专 转 专拽注
 
  try {
    // 砖转砖 -Promise.allSettled  转 住  注,   拽 砖
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // 住祝  砖转砖 砖砖 ( 砖 )
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // 驻住转 住 驻专
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // 拽专 砖 砖 拽专转 转 专拽注 注爪
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    //   拽专 砖专,  砖转专 砖-API 驻注
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds, adminId).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for ai_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * 驻 拽砖转 POST 转 驻专驻 砖转砖 爪注转 AI.
 * 驻拽爪 转转 转 砖转砖, 爪专转 驻专驻 专 拽祝,
 * 砖转 转 转 AI, 专 转 转爪 转.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 砖 1: 转 砖转砖
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 砖 2:  砖砖转砖 驻专驻 拽 驻 爪专转 专
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile]  爪 驻专驻 注专 砖转砖: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 砖 3: 爪专转 驻专驻 专 拽祝
    // 砖砖 专 拽 拽转 爪转 -profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] 砖 爪专转 驻专驻 专 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 砖 4: 砖转 专 转 AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] 砖专转 -AI  专 转爪 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // 砖 5: 专转 转爪 拽
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * 驻 拽砖转 POST 转 爪注转 砖 注专 砖转砖 专.
 * 驻拽爪 转转 转 砖转砖, 专转 转 驻专驻 砖 转 驻专驻 砖 砖转砖 爪注,
 * 爪专转 驻专驻 专 注专 砖, 砖转 转 转 AI 转 砖转砖,
 * 专 转 转爪 转.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. 转 拽转 砖转砖 
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. 拽转 ID 砖 砖转砖 爪注 祝 拽砖
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3.  砖砖 驻专驻 拽
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion]  驻专驻  砖  爪. 爪: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. 爪专转 驻专驻 专 注专 砖 砖转砖 拽
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] 砖 爪专转 驻专驻 专 注专  砖转砖.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. 砖转 专 转 AI 转 砖转砖
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] 砖专转 -AI  专 转爪转 转 爪注.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. 专转 转爪 拽
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
# Generated on: 2025-09-28 20:43:55
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * 驻 拽砖转 POST 转 驻专驻 砖 砖转砖 住驻爪驻 注  砖.
 */
export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 砖 1: 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 砖 2: 拽转 ID 注 转 祝 拽砖
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId 住专   转拽 拽砖.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 砖 3: 爪专转 驻专驻 专 注专 砖转砖 拽砖
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] 砖 爪专转 驻专驻 专 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 砖 4: 砖转 专 转 AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] 砖专转 -AI  专 转爪 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // 砖 5: 专转 转爪 爪转
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. 拽转 ID 注 祝 拽砖
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. 爪专转 驻专驻 专 拽祝
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. 砖转 专 -AI 爪专转 住
    const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. 专转 转爪 爪转
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// 专砖 helpers 砖 Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // 注转 
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // 拽 砖  拽
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // 爪专转  注 驻住 转拽
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict //  专 驻住 
    );

    // 转 拽拽住 转转
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "漏 {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "砖/转 砖",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // 注转 转转 -Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // 住驻转 greeting 拽拽住
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "砖 {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // 专转 转 注 headers 
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// 拽专 砖专转  注 转 注专
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * 驻 拽砖转 POST 转 驻专驻 砖 砖转砖 住驻爪驻 注  砖.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 砖 1: 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] 住 砖  专砖.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 砖 2: 拽转 ID 注 转 祝 拽砖
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId 住专   转拽 拽砖.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 砖 3: 爪专转 驻专驻 专 注专 砖转砖 拽砖
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] 砖 爪专转 驻专驻 专 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 砖 4: 砖转 专 转 AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] 砖专转 -AI  专 转爪 注专: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // 砖 5: 专转 转爪 爪转
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] 砖 驻转 -endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. 转 专砖转 (砖   )
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. 拽转 ID 注 祝 拽砖
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. 爪专转 驻专驻 专 拽祝
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. 砖转 专 -AI 爪专转 住
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. 专转 转爪 爪转
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// 专砖 helpers 砖 Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // 注转 
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // 拽 砖  拽
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // 爪专转  注 驻住 转拽
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict //  专 驻住 
    );

    // 转 拽拽住 转转
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "漏 {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "砖/转 砖",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // 注转 转转 -Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // 住驻转 greeting 拽拽住
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "砖 {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // 专转 转 注 headers 
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// 拽专 砖专转  注 转 注专
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/test-connection/route.ts

import { NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function GET() {
  console.log('--- [API TEST] Received request at /api/ai/test-connection ---');

  const apiKey = process.env.GOOGLE_API_KEY;

  if (!apiKey) {
    console.error('--- [API TEST] FATAL ERROR: GOOGLE_API_KEY is not set in .env or .env.local!');
    return NextResponse.json(
      { success: false, error: 'Server configuration error: GOOGLE_API_KEY is missing.' },
      { status: 500 }
    );
  }

  // --- 拽注 转 砖住驻 ---
  const keyIdentifier = `Starts with: ${apiKey.substring(0, 5)}... | Ends with: ...${apiKey.substring(apiKey.length - 4)} | Length: ${apiKey.length}`; // <-- 住祝
  console.log(`--- [API TEST] Verifying the loaded API Key: ${keyIdentifier} ---`); // <-- 住祝
  // -----------------------------

  console.log('--- [API TEST] GOOGLE_API_KEY found. Proceeding with API call.');

  try {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' }); 
    const prompt = 'Say "Connection Successful" in one sentence.';

    console.log('--- [API TEST] Sending a simple prompt to Google AI...');
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    console.log('--- [API TEST] SUCCESS! Google AI responded:', text);
    return NextResponse.json({ success: true, message: 'Connection to Google AI is working!', response: text });

  } catch (error) {
    console.error('--- [API TEST] FAILED! The API call to Google threw an error.', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to connect to Google AI. This is likely an API key, permissions, or billing issue.',
        details: JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * 驻拽爪转 注专 砖专爪 转 转 注 专拽注
 * 驻住  驻专 住.
 * @param userIds - 注专  砖转砖 注
 * @param adminId -   砖驻注 转 转
 */
async function runBulkUpdateAndLog(userIds: string[], adminId: string) {
  const totalUsers = userIds.length;
  // 注转 转 专专 转 专拽注
 
  try {
    // 砖转砖 -Promise.allSettled  转 住  注,   拽 砖
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // 住祝  砖转砖 砖砖 ( 砖 )
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // 驻住转 住 驻专
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // 拽专 砖 砖 拽专转 转 专拽注 注爪
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    //   拽专 砖专,  砖转专 砖-API 驻注
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds, adminId).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
# Generated on: 2025-10-05 16:46:15
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// 住专 转   驻注 转 专拽 住转 驻转
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// 驻拽爪 砖拽转  -metadata  转 住住 爪驻转
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    //  砖拽  住驻专  6 住驻专转
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "拽 转  转拽. 专砖 拽  6 住驻专转." },
        { status: 400 }
      );
    }

    // 爪转 拽
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "拽  转拽祝  砖驻 转拽驻" },
        { status: 400 }
      );
    }

    // 拽 砖- 转拽  转 住住 爪驻转
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "注 转 住专   转拽,  转 转 转 砖" },
        { status: 400 }
      );
    }

    // 注转 转 砖转 -hashedNewPassword , - 转
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // 注 住住 砖转 转
    await db.$transaction([
      // 注 住住
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // 注 住住 转
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "住住 注 爪"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "砖 砖转 砖 住住" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; //  砖转   爪注 注 拽抓 authOptions 砖
import prisma from '@/lib/prisma'; //  砖转  
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus } from '@prisma/client'; //  Gender -UserStatus

// Zod Schema -  phone 转 拽
const completeProfileSchema = z.object({
  // --- 住驻转 砖 驻专 砖 砖驻 ---
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),
  // --- 住祝 住驻 ---
  phone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });
  console.log("[API /api/auth/complete-profile] Request Headers:", JSON.stringify(headersObject, null, 2));

  // !!! 住专 转  住转 Production !!!
  // console.log("[API /api/auth/complete-profile] DEBUG: NEXTAUTH_SECRET value (first 5 chars):", process.env.NEXTAUTH_SECRET?.substring(0, 5) || "NOT SET");

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    console.log("[API /api/auth/complete-profile] Session object from getServerSession:", JSON.stringify(session, null, 2));

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);
    console.log(`[API /api/auth/complete-profile] User email from session: ${session.user.email}`);

    if (session.user.isPhoneVerified) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} phone is ALREADY verified according to session. Proceeding, but this might indicate a flow issue.`);
    }
    if (session.user.isProfileComplete) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} profile is ALREADY complete according to session. Proceeding, but this might indicate a flow issue.`);
    }

    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
        console.log("[API /api/auth/complete-profile] Request body parsed successfully:", JSON.stringify(body, null, 2));
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    const {
        // --- 住驻转 砖 驻专 砖 砖驻 ---
        firstName,
        lastName,
        // --- 住祝 住驻 ---
        phone,
        gender,
        birthDate,
        maritalStatus,
        height,
        occupation,
        education
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);
    console.log("[API /api/auth/complete-profile] Data to be saved:", JSON.stringify(validation.data, null, 2));

    const updatedUser = await prisma.$transaction(async (tx) => {
      console.log(`[API /api/auth/complete-profile] Inside transaction for user ${userId}. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted for user ${userId}.`);

      console.log(`[API /api/auth/complete-profile] Updating User record for user ${userId} (names, phone, isProfileComplete, status)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          // --- 住驻转 砖 驻专 砖 砖驻 ---
          firstName: firstName,
          lastName: lastName,
          // --- 住祝 住驻 ---
          phone: phone,
          isProfileComplete: true,
          //  砖转砖 注 , 住专  砖转  砖 (  ).
          // , 住住 爪专 注专 -PENDING_PHONE_VERIFICATION.
          //  转 驻  驻爪   砖  , 转 -ACTIVE  住住 .
          status: UserStatus.PENDING_PHONE_VERIFICATION, //  砖 住住  转 专
          updatedAt: new Date(),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true
         }
      });
      console.log(`[API /api/auth/complete-profile] User record updated for user ${userId}. New profile status: isProfileComplete=${user.isProfileComplete}, isPhoneVerified=${user.isPhoneVerified}, status=${user.status}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    console.log("[API /api/auth/complete-profile] Returning success response with user data:", JSON.stringify({ message: "Profile completed successfully", user: updatedUser }, null, 2));
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error during processing:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Known Request Error - Code: ${error.code}`);
        console.error("[API /api/auth/complete-profile] Prisma Error Meta:", error.meta);
        console.error("[API /api/auth/complete-profile] Prisma Error Message:", error.message);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone') && target?.includes('User')) {
                 return NextResponse.json({ error: '住驻专 驻  专 专砖 注专转.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error (Prisma Validation Error).' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- 住驻 ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- 住祝 住驻 ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "拽砖专  转拽  砖驻 转拽驻.  拽砖 砖 砖  砖." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // 注 住住, 住住 砖转砖, 住住 转 专拽爪 转
    await prisma.$transaction(async (tx) => {
      // 注 住住, 转 , 住住 砖转砖
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- 住驻 ---
          isVerified: true, //  转  砖砖转砖 注 拽砖专
          status: UserStatus.PENDING_PHONE_VERIFICATION, // 注专 转 砖转砖 砖 
          // isProfileComplete 砖专 false   注 爪专  驻专
          // --- 住祝 住驻 ---
        },
      });

      // 注 住住 转 (拽 爪)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "砖 专 爪! 注转 转 转专 注 住住 砖." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "专注 砖 专转 砖." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `砖转 住 转 注转 拽转 砖转砖 (拽: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || '砖 拽转 砖.', status: 400 };
    }

    return { message: '专注 砖 转 爪驻 拽转 砖.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 .  转 住砖 驻注.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: '砖 拽 爪.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: '砖转砖 拽砖 拽  爪.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse, NextRequest } from "next/server"; //  NextRequest
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: NextRequest) { // 砖 -NextRequest
  try {
    // ================ 1. 砖驻转 -locale -URL ================
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    // ==========================================================

    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "砖转砖  爪" },
        { status: 404 }
      );
    }

    if (!user.password) {
      return NextResponse.json(
        { error: " 专 住住 砖 . 转 砖专砖转 爪注转 砖专转 爪." },
        { status: 400 }
      );
    }

    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "住住 转 砖" },
        { status: 400 }
      );
    }

    const hashedNewPassword = await hash(newPassword, 12);

    // 砖专转 爪专 OTP  6 住驻专转
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      24 // Expires in 24 hours
    );

    // 砖专转 住住 爪驻转 - 砖 转
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // ================ 2. 拽专 驻拽爪  注 驻专专 注 ================
    const otpCode = verification.token; // 拽 砖爪专  -OTP
    const expiresInText = locale === 'he' ? '24 砖注转' : '24 hours';

    await emailService.sendPasswordResetOtpEmail({
      locale,
      email: user.email,
      otp: otpCode,
      firstName: user.firstName,
      expiresIn: expiresInText,
    });
    // =================================================================================

    return NextResponse.json({ success: true, message: "拽 转 砖 住住 砖  砖." });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "砖 转 砖 住住" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/register/route.ts

import { NextRequest, NextResponse } from "next/server";
import { PrismaClient, UserRole, UserStatus, Prisma, VerificationType, UserSource  } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 
import { applyRateLimit } from '@/lib/rate-limiter';
import { UserEngagementService } from '@/lib/engagement/userEngagementService';

const prisma = new PrismaClient();

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
    marketingConsent?: boolean;

};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
        // For now, we'll keep it.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  // --- START OF CHANGE ---
  marketingConsent?: boolean;
  // --- END OF CHANGE ---
}

function handleError(error: unknown): { message: string; status: number } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: '砖转砖 注 转转   专 拽 注专转.', status: 409 };
          }
          return { message: `砖转砖 注 驻专  专 拽 注专转 (拽 ${error.code}).`, status: 409 };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `砖转 转转 转 (砖: ${fieldName || ' 注'}).  住 砖转.`, status: 500};
        }
        case 'P2014': return { message: '砖 转 砖.', status: 400 };
        default: 
            return { message: `砖 砖专转 转 (拽 砖转 DB: ${error.code}).`, status: 500 };
      }
    }
    if (error instanceof Error) {
       if (error.message === '砖转砖 注 转转   专 拽 注专转.') {
           return { message: error.message, status: 409 };
       }
       if (['住专 驻专 ', '转转   转拽', '住住 转  驻转 8 转, 转 , 转 拽 住驻专'].includes(error.message)) {
           return { message: error.message, status: 400 };
       }
       if (error.message.includes('专注 砖 爪专转 拽 转') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: '专注 砖 爪专转 专砖转 转 注拽 注转 转转.  住 砖转.', status: 500 };
       }
      return { message: error.message, status: 400 }; 
    }
    return { message: '专注 砖 转 爪驻.', status: 500 };
}


export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  logger.info('Initial registration process initiated');

 const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // 专专转  注专转
  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password,
      // --- START OF CHANGE ---
      marketingConsent: body.marketingConsent,
      // --- END OF CHANGE ---
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('住专 驻专 ');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('转转   转拽');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('住住 转  驻转 8 转, 转 , 转 拽 住驻专');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('砖转砖 注 转转   专 拽 注专转.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(),
            // --- START OF CHANGE ---
            marketingConsent: body.marketingConsent || false,
            // --- END OF CHANGE ---
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });
    // ---  住驻 砖: 驻注转 拽驻   ---
// 拽专   砖转  转,  专拽 转转 转  专砖 注 住驻专 .
try {
  await UserEngagementService.startCampaignForNewUser(result.user.id);
  logger.info('User engagement campaign successfully scheduled', { userId: result.user.id });
} catch (campaignError) {
  //  砖 注 转 拽驻,  专拽 转注 转  注爪专 转 转 专砖.
  logger.error('Failed to start user engagement campaign', { 
    userId: result.user.id,
    errorObject: campaignError 
  });
}
// --- 住祝 住驻 ---

    let emailSentSuccess = false;
        const emailOtpExpiryText = locale === 'he' ? "砖注 转" : "1 hour"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
        await emailService.sendVerificationEmail({
                locale, // <<<<<<<<<<<< 住驻转 -locale
                email: result.user.email,
                verificationCode: result.generatedOtp, 
                firstName: result.user.firstName,
                expiresIn: emailOtpExpiryText 
            });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = '砖 爪专 爪. ';
    if (emailSentSuccess) {
        responseMessage += `砖 拽 转 转转 " 砖 (${result.user.email}).   转 拽  砖.`;
    } else {
        responseMessage += '转 注 砖转 拽 转. 转 拽砖 拽 砖 住   驻转 转.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { userId: result.user.id });
    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id, 
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus, VerificationStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

// Zod schema for validating the request body
const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "转转   转拽" }),
});

// Helper for logging (consistent with your existing logs)
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus;
  locale?: 'he' | 'en'; // <<<<<<<<<<<< 转拽: 住驻转 驻 住专
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting (prevents email spam)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  // 2. Get Locale from URL for translation
  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Default to Hebrew
  
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined;

  try {
    // 3. Parse and Validate Request Body
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "转转   转拽" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    // 拽专  转拽 注砖
    logger.info('Processing password reset request', { action, email: normalizedEmail, locale });

    // 4. Find the user in the database
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    // SECURITY: Always return a generic success message to prevent user enumeration attacks.
    const genericSuccessMessage = locale === 'he'
      ? ' 拽转 转转   注专转 转 驻住 注专 住住, 拽 转 砖 注转.'
      : 'If an account with this email exists and is eligible for password reset, a code has been sent.';

    // 5. Handle cases where no email should be sent, but still return success to the client
    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    // 6. Invalidate previous pending password reset OTPs for this user
    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING,
        },
        data: {
            status: VerificationStatus.EXPIRED,
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    // 7. Create a new OTP using the Verification Service
    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60 // Service expects hours
    );
    logger.info('New password reset OTP created', { action, userId: user.id, verificationId: passwordResetVerification.id });

    // 8. Send the password reset email using the updated Email Service
    try {
      const expiresInText = locale === 'he' ? `${expiresInMinutes} 拽转` : `${expiresInMinutes} minutes`;

      await emailService.sendPasswordResetOtpEmail({
        locale,
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: expiresInText,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    // 9. Return the generic success response
    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    // 10. Handle unexpected errors
    const emailForLog = requestBody?.email;
    logger.error('Critical error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    const errorMessage = locale === 'he'
      ? '专注 砖 转.  住 砖转 专 转专.'
      : 'An error occurred. Please try again later.';

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, VerificationStatus } from '@prisma/client';

// --- 专转 ---
const RESEND_RATE_LIMIT_SECONDS = 60; //  转 砖转  拽砖转 专转

// --- 专 注专  ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => {
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta }));
    },
    warn: (message: string, meta?: Record<string, unknown>) => {
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta }));
    },
    error: (message: string, meta?: any) => {
      let logMeta = meta || {};
      if (meta instanceof Error) {
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
};

// --- 驻拽爪转 -API 专砖转 ---
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
    if (rateLimitResponse) {
        return rateLimitResponse;
    }

    logger.info("Resend phone code request received");

    // 1. --- 拽转 转 砖转砖 ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });

    try {
        // ============================ 转拽 专 (1 转 2) ============================
        // 2. --- 拽专转 砖驻 (locale) 驻专专 -URL ---
        const url = new URL(req.url);
        // 专转 注专转 砖驻转 专专转   驻专专  拽
        const locale = (url.searchParams.get('locale') || 'he') as 'he' | 'en';
        logger.info("Processing request with locale", { userId, locale });
        // =================================================================================

        // 3. --- 转专 拽砖转 转 专 砖 砖转砖 ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc'
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            return NextResponse.json({ error: ' 爪 拽砖转 转 驻注. 转 砖专 转转 转 住驻专  砖拽 驻 转拽祝.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });

        // 4. --- 拽转 转 拽爪 (Rate Limiting) ---
        const now = new Date();
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: ` 转 ${timeLeft} 砖转 驻 拽砖转 拽 砖.` }, { status: 429 });
        }
        logger.info("Rate limit check passed", { userId });

        // 5. --- 拽注转 住驻专 驻 砖 ---
        let targetPhone = lastVerification.target;
        let userFirstName = session.user.firstName || '';

        // 拽专 砖住驻专 驻  砖专 专砖转 转, 砖祝 转 砖转砖
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true }
             });
             if (!user?.phone) {
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                return NextResponse.json({ error: '砖:  转 转专 转 住驻专 驻 砖转 拽.' }, { status: 500 });
             }
             targetPhone = user.phone;
             userFirstName = user.firstName || '';
        }
        
        // 6. --- 爪专转 拽 砖 转专 转驻 砖 ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 转拽祝 -10 拽转
        logger.info("Generated new OTP", { userId });

        // 7. --- 注 专砖转 转 住 转 ---
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // 驻住  住转
                createdAt: new Date() // 注 转转  拽转 -rate limit 
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });

        // ============================ 转拽 专 (2 转 2) ============================
        // 8. --- 砖转 拽 砖, 转 注专转 砖驻 (locale) 砖专转 砖 ---
        // 注专: 砖  砖驻拽爪 `sendOtpViaWhatsApp`  拽转 驻专专 专注 砖 砖驻
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone, locale });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName,
        );
        // =================================================================================

        if (!otpSent) {
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            return NextResponse.json({ error: '砖转 拽 转 砖 爪注转 WhatsApp 砖.  住 砖 注 住驻专 专注.' }, { status: 500 });
        }

        // 9. --- 专转 转砖转 爪 ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: '拽 转 砖 砖 爪 爪注转 WhatsApp.' }, { status: 200 });

    } catch (error: unknown) {
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id,
            error: error
        });
        return NextResponse.json({ error: '专注 砖 驻转 砖专转. 住 砖 专 转专.' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification/route.ts

import { NextResponse, NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * 驻 拽砖转 砖 专转 砖 拽 转 .
 * 拽转 拽爪  注 砖转砖 砖专砖   拽 转 拽 转 专砖.
 */
export async function POST(req: NextRequest) {
  // 1. 转 拽爪 拽砖转 注转 砖砖 专注 砖转 住驻
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. 砖驻转 砖驻转 砖拽 -URL 爪专 转专 
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. 拽专转 转 祝 拽砖
    const body = await req.json();
    const { email } = body;

    if (!email || typeof email !== 'string') {
      return NextResponse.json(
        { success: false, error: "转转   砖 ." },
        { status: 400 }
      );
    }

    const normalizedEmail = email.toLowerCase();

    // 4. 转专 砖转砖 住 转
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    });

    // 拽转 拽爪 拽专转
    if (!user) {
      return NextResponse.json(
        { success: false, error: " 爪 砖转砖 注 转转  ." },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { success: false, error: "砖  专 转. 转 转专." },
        { status: 400 }
      );
    }

    // 5. 爪专转 拽 转 砖 爪注转 砖专转 转 专
    // 砖专转   转拽祝 砖 拽 拽 砖专 爪.
    const expiresInHours = 1; // 转拽祝 砖注
    const { otp: verificationCode } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email,
        expiresInHours
    );

    console.log(`[Resend Verification] New OTP generated for user: ${user.id}`);

    // 6. 砖转  转 砖 注 拽 砖爪专, 转 砖驻 砖专
    const expiresInText = locale === 'he' ? '砖注 转' : '1 hour';
    
    await emailService.sendVerificationEmail({
      locale, // 注专转 驻专专 砖驻
      email: user.email,
      verificationCode: verificationCode,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Resend Verification] Verification email sent successfully to ${user.email} in ${locale}`);

    // 7. 专转 转砖转 爪 拽
    return NextResponse.json({
      success: true,
      message: " 转 砖 砖 爪."
    });

  } catch (error: unknown) {
    // 8. 驻 砖转  爪驻转
    console.error('[API Resend Verification] A critical error occurred:', error);
    
    const errorMessage = error instanceof Error ? error.message : "砖  爪驻 砖转  转.";
    
    return NextResponse.json(
        { success: false, error: "专注 砖 转,  住 砖转 专 转专.", details: errorMessage }, 
        { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification-code/route.ts

import { NextResponse, NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { VerificationType, UserStatus } from '@prisma/client';
import { applyRateLimit } from '@/lib/rate-limiter';

// 专转 驻住 注 砖专 
type LogMetadata = {
  email?: string;
  error?: unknown;
  userId?: string;
  verificationId?: string;
  status?: UserStatus;
  isVerified?: boolean;
};

// 拽 专 驻砖 注拽
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: NextRequest) {
  // 1. 转 拽爪 拽砖转
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  let requestBody: ResendCodeRequest | null = null;
  try {
    // 2. 砖驻转 砖驻转 砖拽 -URL
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. 拽专转 转 祝 拽砖
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });

    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: '住专 转转 .' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    
    // 4. 转专 砖转砖 爪
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail });
      return NextResponse.json({ success: false, error: '砖转砖 注 转转    专砖.' }, { status: 404 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        logger.warn('User email already verified or not pending verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: '转转  专 转转  砖 转 转.' }, { status: 400 });
    }
    
    // 5. 爪专转 拽 转 砖 专 砖专转 专
    const expiresInHoursForOtp = 1;
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHoursForOtp
    );
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });

    // 6. 砖转  注 拽 砖 砖驻 
    const emailOtpExpiryText = locale === 'he' ? "砖注 转" : "1 hour";
    await emailService.sendVerificationEmail({
      locale, // <<<<<<<<<<<< 注专转 -locale
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    // 7. 专转 转砖转 爪
    return NextResponse.json({
      success: true,
      message: `拽 转 砖 砖 转转 ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    // 8. 驻 砖转  爪驻转
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails });

    let errorMessage = '专注 砖 砖 专转 砖 拽.';
    const errorStatus = 500;

    if (error instanceof Error && error.message.includes('专注 砖 爪专转 拽 转')) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { hash } from 'bcryptjs';
import { z } from 'zod';

// Zod schema for validating the request body with detailed messages
const resetPasswordSchema = z.object({
  email: z.string().email({ message: "转转   转拽" }),
  otp: z.string()
    .length(6, { message: "拽 转   6 住驻专转" })
    .regex(/^\d+$/, { message: "拽 转   住驻专转 " }),
  newPassword: z.string()
    .min(8, { message: "住住 转  驻转 8 转" })
    .regex(/[a-z]/, { message: "住住 转  驻转 转 拽 转 转" })
    .regex(/[A-Z]/, { message: "住住 转  驻转 转  转 转" })
    .regex(/[0-9]/, { message: "住住 转  驻转 住驻专 转" }),
});

// Helper for consistent logging
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "reset-password-with-otp";
  let requestBody: { email?: string } | undefined;

  try {
    // 1. Apply Rate Limiting (prevents brute-force attacks on OTP)
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '15 m' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Default to Hebrew

    // 3. Parse and Validate Request Body
    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action, locale });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "转  转拽.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];

      logger.warn('Invalid input for password reset', { action, error: errors });
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    // 4. Verify the OTP using the centralized VerificationService
    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });
    
    // This service will throw an error if the OTP is invalid, expired, or has too many attempts.
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    // Ensure the result from the service contains the necessary data
    if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      logger.error('OTP verification failed unexpectedly or did not return required data', {
        action,
        email: normalizedEmail,
        error: verificationResult.message,
      });
      throw new Error(verificationResult.message || '砖 转 拽.');
    }

    const { userId, id: verificationId } = verificationResult;
    logger.info('OTP verified successfully', { action, userId, verificationId });

    // 5. Hash the new password
    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    // 6. Update user's password and mark OTP as used
    // These are done sequentially. If marking as completed fails, it's not critical as the token will expire.
    
    // Update the user's password
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
      },
      select: { email: true, firstName: true } // Select data needed for confirmation email
    });
    logger.info('User password updated in database', { action, userId });

    // Mark the verification record as COMPLETED
    await VerificationService.completeVerification(verificationId);
    logger.info('Verification record marked as completed', { action, verificationId });

    // 7. Send password change confirmation email (non-critical step)
    if (user) {
      try {
        // *** CRITICAL FIX: Pass the locale to the email service ***
        await emailService.sendPasswordChangedConfirmationEmail({
          locale, // Pass the determined locale
          email: user.email,
          firstName: user.firstName,
        });
        logger.info('Password change confirmation email sent', { action, userId, locale });
      } catch (emailError) {
        // Log the error but do not fail the request, as the password has been successfully changed.
        logger.error('Failed to send password change confirmation email', {
          action,
          userId,
          error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
        });
      }
    }

    // 8. Return success response
    const successMessage = locale === 'he'
      ? '住住 驻住 爪. 注转 转 转专 注 住住 砖.'
      : 'Password has been reset successfully. You can now log in with your new password.';
      
    return NextResponse.json({ success: true, message: successMessage }, { status: 200 });

  } catch (error: unknown) {
    // 9. Handle all errors gracefully
    const emailForLog = requestBody?.email;
    logger.error('Critical error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    let errorMessage = '专注 砖 驻住 住住.';
    let errorStatus = 500;

    // Map specific known errors from VerificationService to user-friendly messages and statuses
    if (error instanceof Error) {
      const knownClientErrors = [
        '拽 专 爪.',
        '转拽祝 拽 驻.  拽砖 拽 砖.',
        '拽 转  转拽  砖 拽转 拽砖转 转 驻注.',
        '拽 转 砖.',
        '专转 住驻专 住转 转 转专.  拽砖 拽 砖.',
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; // Bad Request
        if (error.message.includes("驻 转拽驻")) errorStatus = 410; // Gone
        if (error.message.includes("专转 住驻专 住转")) errorStatus = 429; // Too Many Requests
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 requests per user per hour (costly SMS/WhatsApp)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. 拽 转 驻专 砖转砖 -DB (注拽专 住驻专 驻)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // 砖   专 拽专转  砖转砖 注  专 砖转 驻专驻
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. 爪专转 OTP 砖
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 拽转 转驻

        // 3. 砖专转/注 专砖转 转
        // 拽 专砖转 拽转 转 砖转砖  注 
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // 爪专 专砖 砖
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. 砖转 -OTP 住驻
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // 专 砖  砖拽  爪 注 转
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/send-verification/route.ts

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { VerificationType, UserStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

export const runtime = 'nodejs';

/**
 * Handles requests to send a new email verification code to an existing, unverified user.
 */
export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting to prevent email spam
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. Parse and Validate Request Body
    const { email } = await req.json();
    if (!email || typeof email !== 'string') {
      return NextResponse.json({ success: false, error: "  砖 " }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 4. Find the user and perform necessary checks
    const user = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (!user) {
      // Security: Return a generic message even if the user doesn't exist to prevent enumeration.
      return NextResponse.json({ success: true, message: " 拽 砖 砖  , 砖  拽 转." }, { status: 200 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        return NextResponse.json({ success: false, error: "砖  专 转  砖 转 转." }, { status: 400 });
    }

    // 5. Create a new verification OTP using the central service
    const expiresInHours = 1; // 1-hour validity for the new code
    const { otp: generatedOtp } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHours
    );

    console.log(`[Send Verification] New OTP generated for user: ${user.id}`);

    // 6. Send the verification email using the updated Email Service
    const expiresInText = locale === 'he' ? '砖注 转' : '1 hour';
    await emailService.sendVerificationEmail({
      locale, // <-- Pass the correct locale
      email: user.email,
      verificationCode: generatedOtp,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Send Verification] Verification email re-sent successfully to ${user.email} in ${locale}`);

    // 7. Return a success response
    return NextResponse.json({ success: true, message: "拽 转 砖 砖 爪." }, { status: 200 });

  } catch (error) {
    // 8. Handle unexpected errors
    console.error('[API Send Verification] A critical error occurred:', error);
    const errorMessage = error instanceof Error ? error.message : "砖  爪驻 砖转 拽 转.";
    return NextResponse.json(
      { success: false, error: "专注 砖 转,  住 砖转 专 转专.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
});


export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. 拽 砖住驻专 砖  转驻住 注  砖转砖 转 专
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } //  砖转砖 
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: '住驻专 驻 专 专砖 驻注 注专转 注专 砖转砖 专.' }, { status: 409 }); // Conflict
          }

        // 2. 注 转 住驻专 驻 砖 砖转砖
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // 拽 转 砖 注  爪专
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. 爪专 OTP 砖
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 拽转 转驻

        // 4. 爪专/注 专砖转 转 注专 住驻专 砖
        //  专砖转 拽转  
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // 住 拽 驻 转拽祝
         });
         // 爪专 专砖 砖
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // 住驻专 砖
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. 砖 转 -OTP 住驻专 砖
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // 专 砖, 转 砖住驻专 砖  转拽 住驻
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // 专转 error -unknown
        console.error("API update-and-resend: An error occurred:", error);

        // 驻 砖转 住驻爪驻转
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // 砖转 驻转 - 专转 砖拽, 转 爪 race condition
            return NextResponse.json({ error: '住驻专 驻 专 专砖 注专转.' }, { status: 409 });
        }

        // 砖 转
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId   转 string  undefined    拽 
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 verification attempts per IP per 15 minutes (prevents brute-force)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '15 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: '住专 驻专   拽.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `驻专 拽  转拽. 拽 爪专  ${OTP_LENGTH_FROM_SERVICE} 住驻专转.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- 转拽 转  ---
    //  砖-userId 拽  专转 驻 砖砖
    // 住专  砖-verificationResult.userId  转 string | null
    // 注 驻 专 砖 VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // 专拽 砖 砖转驻 拽 -catch ,  驻  驻 住驻爪驻 转专
      // 砖  爪注 注 注 转 驻转  拽 转   砖转砖 砖
      throw new Error('砖 驻转:  爪 砖转砖 砖 转 专 转 拽 爪.');
    }
    
    // 注转, 专 拽, TypeScript  住拽 ( 砖 爪专 驻专砖)
    // 砖-userId  string.
    const userId: string = verificationResult.userId; 
    // --- 住祝 转拽 ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, //  userId  转 string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: '转转  转 爪! 转爪注转 转专转 转...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = '专注 砖 转 拽.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '拽 专 爪.', 
        '转拽祝 拽 驻.  拽砖 拽 砖.', 
        '拽 转  转拽  砖 拽转 拽砖转 转 驻注.', 
        '拽 转 砖.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === '砖 驻转:  爪 砖转砖 砖 转.' || 
                 error.message === '砖 驻转:  爪 砖转砖 砖 转 专 转 拽 爪.') { // 住驻转 砖 砖  专爪 驻 
        errorMessage = '专注 砖 驻转.  住 砖转 专 转专.';
        // errorStatus 砖专 500 专专转  砖转 驻转,  砖转砖 驻 爪专
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/verify-phone-code/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { z } from 'zod';
import { Prisma, VerificationType, UserStatus } from '@prisma/client';

import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { emailService } from '@/lib/email/emailService';

// --- 专转 ---
// 住驻专 住转 转 拽住 驻 砖拽 砖
const MAX_VERIFICATION_ATTEMPTS = 5;

// --- 住转 Zod 转 祝 拽砖 ---
// 转 砖拽 砖 拽 注 砖 'code' 转拽
const verifyCodeSchema = z.object({
  code: z.string()
    .length(6, { message: "拽 转   6 住驻专转" })
    .regex(/^\d+$/, { message: "驻专 拽  转拽, 住驻专转 " }),
});


// --- 专 驻砖  ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
    warn: (message: string, meta?: Record<string, unknown>) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
    error: (message: string, meta?: Record<string, unknown>) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};


// --- 拽转 拽爪 (Endpoint) 专砖转 ---
export async function POST(req: NextRequest) {
  const action = "verify-phone-code";

  try {
    // 砖 1: 转 砖转砖
    // ------------------------------------
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      logger.warn("住 转 驻  住砖 驻注", { action });
      return NextResponse.json({ error: 'Unauthorized - 专砖转 转专转' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("转 转 驻  注专 砖转砖", { action, userId });


    // 砖 2: 拽转 砖驻转 砖拽 拽
    // ------------------------------------
    // 砖驻 砖转 驻专专 -URL, 砖: /api/auth/verify-phone-code?locale=en
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // 专专转  注专转
    logger.info("砖驻转 砖拽 转", { action, userId, locale });


    // 砖 3: 拽专转 转 祝 拽砖
    // ------------------------------------
    const body = await req.json();
    const validation = verifyCodeSchema.safeParse(body);

    if (!validation.success) {
      logger.warn("转  转拽 拽砖", { action, userId, errors: validation.error.flatten() });
      return NextResponse.json({ error: '转  转拽', details: validation.error.flatten() }, { status: 400 });
    }
    const { code } = validation.data;


    // 砖 4: 转专 拽砖转 转 住住 转
    // ------------------------------------
    const verification = await prisma.verification.findFirst({
        where: {
            userId: userId,
            type: VerificationType.PHONE_WHATSAPP,
            status: 'PENDING',
        },
        orderBy: {
            createdAt: 'desc' //  砖 拽 转 拽砖 专
        }
    });

    if (!verification) {
      logger.warn(" 爪 拽砖转 转 驻 驻注", { action, userId });
      return NextResponse.json({ error: ' 爪 拽砖转 转 驻注  砖砖 专 转.' }, { status: 404 });
    }


    // 砖 5: 拽转 转拽祝 转拽转 拽
    // ------------------------------------
    // 拽 5:  拽 驻 转拽祝?
    if (new Date() > verification.expiresAt) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'EXPIRED' }
        });
        logger.warn("住 砖转砖 拽 砖驻 转拽驻", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '拽 转 驻 转拽祝.  拽砖 拽 砖.' }, { status: 410 }); // 410 Gone
    }

    // 拽 5:  砖转砖 专 住驻专 住转?
    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'FAILED' }
        });
        logger.warn("专 住驻专 住转 转", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '专转 住驻专 住转 转 转专.  拽砖 拽 砖.' }, { status: 429 }); // 429 Too Many Requests
    }

    // 拽 5:  拽 砖 砖?
    if (verification.token !== code) {
        const updatedVerification = await prisma.verification.update({
            where: { id: verification.id },
            data: { attempts: { increment: 1 } }
        });
        const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - updatedVerification.attempts;
        logger.warn(" 拽 转 砖", { action, userId, attemptsLeft });
        return NextResponse.json({ error: `拽 转 砖. 转专  ${attemptsLeft} 住转.` }, { status: 400 });
    }


    // 砖 6: 转 爪 - 注 住住 转 砖转 
    // ----------------------------------------------------
    // 砖砖 专拽爪   砖砖转 驻注转 (注 砖转砖 注 转) 爪   砖 
    const [updatedVerification, updatedUser] = await prisma.$transaction([
        // 6: 注 专砖转 转 住住 'COMPLETED'
        prisma.verification.update({
            where: { id: verification.id },
            data: {
                status: 'COMPLETED',
                completedAt: new Date(),
                attempts: verification.attempts + 1
             }
        }),
        // 6: 注 专砖转 砖转砖 - 驻 转 驻注!
        prisma.user.update({
            where: { id: userId },
            data: {
                isPhoneVerified: true,
                isProfileComplete: true, // 专 转 驻, 驻专驻 砖 砖
                status: UserStatus.ACTIVE, // 砖转砖 驻 驻注
                updatedAt: new Date(),
            },
            // 专转 砖转 砖专 - 砖 拽 转  砖 注专 砖转 
            select: {
                id: true,
                email: true,
                firstName: true,
                isPhoneVerified: true,
                isProfileComplete: true,
                status: true,
             }
        })
    ]);
    
    logger.info("转 驻 砖 爪, 砖转砖 专 驻注", { action, userId });

    // 6: 砖转  "专 " - 专拽 专 砖专拽爪 爪
    try {
        await emailService.sendWelcomeEmail({
            locale, // << 注专转 砖驻 转 砖转拽 拽
            email: updatedUser.email,
            firstName: updatedUser.firstName || '专',
            dashboardUrl: '/profile'
        });
        logger.info(" 专  砖 爪", { action, userId, email: updatedUser.email, locale });
    } catch (emailError) {
        // 砖 砖转   爪专 砖 转  拽砖. 砖转砖 注 转.
        // 砖 专砖 转 砖 注拽.
        logger.error("砖 砖转  专  专 转 驻", { action, userId, error: emailError });
    }


    // 砖 7: 专转 转砖转 爪 拽
    // ------------------------------------
    return NextResponse.json({
         success: true,
         message: '转 驻 砖 爪!',
         user: updatedUser // 专转 驻专 砖转砖 注 注 住砖 爪 拽
    }, { status: 200 });

  } catch (error) {
    // --- 驻  砖转  爪驻转 ---
    const userId = (await getServerSession(authOptions))?.user?.id || 'unknown';
    logger.error("砖 拽专转 转 转 驻", { action, userId, error });

    if (error instanceof z.ZodError) {
        return NextResponse.json({ error: '转  转拽 拽砖', details: error.flatten() }, { status: 400 });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        return NextResponse.json({ error: '砖转 住 转 转 转' }, { status: 500 });
    }
    
    return NextResponse.json({ error: '专注 砖 驻转 砖专转.  住 砖转 专 转专.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for auth_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// 住专 转   驻注 转 专拽 住转 驻转
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// 驻拽爪 砖拽转  -metadata  转 住住 爪驻转
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    //  砖拽  住驻专  6 住驻专转
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "拽 转  转拽. 专砖 拽  6 住驻专转." },
        { status: 400 }
      );
    }

    // 爪转 拽
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "拽  转拽祝  砖驻 转拽驻" },
        { status: 400 }
      );
    }

    // 拽 砖- 转拽  转 住住 爪驻转
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "注 转 住专   转拽,  转 转 转 砖" },
        { status: 400 }
      );
    }

    // 注转 转 砖转 -hashedNewPassword , - 转
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // 注 住住 砖转 转
    await db.$transaction([
      // 注 住住
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // 注 住住 转
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "住住 注 爪"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "砖 砖转 砖 住住" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; //  砖转   爪注 注 拽抓 authOptions 砖
import prisma from '@/lib/prisma'; //  砖转  
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus } from '@prisma/client'; //  Gender -UserStatus

// Zod Schema -  phone 转 拽
const completeProfileSchema = z.object({
  // --- 住驻转 砖 驻专 砖 砖驻 ---
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),
  // --- 住祝 住驻 ---
  phone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });
  console.log("[API /api/auth/complete-profile] Request Headers:", JSON.stringify(headersObject, null, 2));

  // !!! 住专 转  住转 Production !!!
  // console.log("[API /api/auth/complete-profile] DEBUG: NEXTAUTH_SECRET value (first 5 chars):", process.env.NEXTAUTH_SECRET?.substring(0, 5) || "NOT SET");

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    console.log("[API /api/auth/complete-profile] Session object from getServerSession:", JSON.stringify(session, null, 2));

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);
    console.log(`[API /api/auth/complete-profile] User email from session: ${session.user.email}`);

    if (session.user.isPhoneVerified) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} phone is ALREADY verified according to session. Proceeding, but this might indicate a flow issue.`);
    }
    if (session.user.isProfileComplete) {
        console.warn(`[API /api/auth/complete-profile] User ${userId} profile is ALREADY complete according to session. Proceeding, but this might indicate a flow issue.`);
    }

    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
        console.log("[API /api/auth/complete-profile] Request body parsed successfully:", JSON.stringify(body, null, 2));
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    const {
        // --- 住驻转 砖 驻专 砖 砖驻 ---
        firstName,
        lastName,
        // --- 住祝 住驻 ---
        phone,
        gender,
        birthDate,
        maritalStatus,
        height,
        occupation,
        education
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);
    console.log("[API /api/auth/complete-profile] Data to be saved:", JSON.stringify(validation.data, null, 2));

    const updatedUser = await prisma.$transaction(async (tx) => {
      console.log(`[API /api/auth/complete-profile] Inside transaction for user ${userId}. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted for user ${userId}.`);

      console.log(`[API /api/auth/complete-profile] Updating User record for user ${userId} (names, phone, isProfileComplete, status)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          // --- 住驻转 砖 驻专 砖 砖驻 ---
          firstName: firstName,
          lastName: lastName,
          // --- 住祝 住驻 ---
          phone: phone,
          isProfileComplete: true,
          //  砖转砖 注 , 住专  砖转  砖 (  ).
          // , 住住 爪专 注专 -PENDING_PHONE_VERIFICATION.
          //  转 驻  驻爪   砖  , 转 -ACTIVE  住住 .
          status: UserStatus.PENDING_PHONE_VERIFICATION, //  砖 住住  转 专
          updatedAt: new Date(),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true
         }
      });
      console.log(`[API /api/auth/complete-profile] User record updated for user ${userId}. New profile status: isProfileComplete=${user.isProfileComplete}, isPhoneVerified=${user.isPhoneVerified}, status=${user.status}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    console.log("[API /api/auth/complete-profile] Returning success response with user data:", JSON.stringify({ message: "Profile completed successfully", user: updatedUser }, null, 2));
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error during processing:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Known Request Error - Code: ${error.code}`);
        console.error("[API /api/auth/complete-profile] Prisma Error Meta:", error.meta);
        console.error("[API /api/auth/complete-profile] Prisma Error Message:", error.message);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone') && target?.includes('User')) {
                 return NextResponse.json({ error: '住驻专 驻  专 专砖 注专转.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error (Prisma Validation Error).' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- 住驻 ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- 住祝 住驻 ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "拽砖专  转拽  砖驻 转拽驻.  拽砖 砖 砖  砖." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // 注 住住, 住住 砖转砖, 住住 转 专拽爪 转
    await prisma.$transaction(async (tx) => {
      // 注 住住, 转 , 住住 砖转砖
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- 住驻 ---
          isVerified: true, //  转  砖砖转砖 注 拽砖专
          status: UserStatus.PENDING_PHONE_VERIFICATION, // 注专 转 砖转砖 砖 
          // isProfileComplete 砖专 false   注 爪专  驻专
          // --- 住祝 住驻 ---
        },
      });

      // 注 住住 转 (拽 爪)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "砖 专 爪! 注转 转 转专 注 住住 砖." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "专注 砖 专转 砖." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `砖转 住 转 注转 拽转 砖转砖 (拽: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || '砖 拽转 砖.', status: 400 };
    }

    return { message: '专注 砖 转 爪驻 拽转 砖.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 .  转 住砖 驻注.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: '砖 拽 爪.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: '砖转砖 拽砖 拽  爪.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse, NextRequest } from "next/server"; //  NextRequest
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: NextRequest) { // 砖 -NextRequest
  try {
    // ================ 1. 砖驻转 -locale -URL ================
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    // ==========================================================

    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "砖转砖  爪" },
        { status: 404 }
      );
    }

    if (!user.password) {
      return NextResponse.json(
        { error: " 专 住住 砖 . 转 砖专砖转 爪注转 砖专转 爪." },
        { status: 400 }
      );
    }

    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "住住 转 砖" },
        { status: 400 }
      );
    }

    const hashedNewPassword = await hash(newPassword, 12);

    // 砖专转 爪专 OTP  6 住驻专转
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      24 // Expires in 24 hours
    );

    // 砖专转 住住 爪驻转 - 砖 转
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // ================ 2. 拽专 驻拽爪  注 驻专专 注 ================
    const otpCode = verification.token; // 拽 砖爪专  -OTP
    const expiresInText = locale === 'he' ? '24 砖注转' : '24 hours';

    await emailService.sendPasswordResetOtpEmail({
      locale,
      email: user.email,
      otp: otpCode,
      firstName: user.firstName,
      expiresIn: expiresInText,
    });
    // =================================================================================

    return NextResponse.json({ success: true, message: "拽 转 砖 住住 砖  砖." });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "砖 转 砖 住住" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/register/route.ts

import { NextRequest, NextResponse } from "next/server";
import { PrismaClient, UserRole, UserStatus, Prisma, VerificationType, UserSource  } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 
import { applyRateLimit } from '@/lib/rate-limiter';
import { UserEngagementService } from '@/lib/engagement/userEngagementService';

const prisma = new PrismaClient();

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
    marketingConsent?: boolean;

};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
        // For now, we'll keep it.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  // --- START OF CHANGE ---
  marketingConsent?: boolean;
  // --- END OF CHANGE ---
}

function handleError(error: unknown): { message: string; status: number } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: '砖转砖 注 转转   专 拽 注专转.', status: 409 };
          }
          return { message: `砖转砖 注 驻专  专 拽 注专转 (拽 ${error.code}).`, status: 409 };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `砖转 转转 转 (砖: ${fieldName || ' 注'}).  住 砖转.`, status: 500};
        }
        case 'P2014': return { message: '砖 转 砖.', status: 400 };
        default: 
            return { message: `砖 砖专转 转 (拽 砖转 DB: ${error.code}).`, status: 500 };
      }
    }
    if (error instanceof Error) {
       if (error.message === '砖转砖 注 转转   专 拽 注专转.') {
           return { message: error.message, status: 409 };
       }
       if (['住专 驻专 ', '转转   转拽', '住住 转  驻转 8 转, 转 , 转 拽 住驻专'].includes(error.message)) {
           return { message: error.message, status: 400 };
       }
       if (error.message.includes('专注 砖 爪专转 拽 转') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: '专注 砖 爪专转 专砖转 转 注拽 注转 转转.  住 砖转.', status: 500 };
       }
      return { message: error.message, status: 400 }; 
    }
    return { message: '专注 砖 转 爪驻.', status: 500 };
}


export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  logger.info('Initial registration process initiated');

 const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // 专专转  注专转
  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password,
      // --- START OF CHANGE ---
      marketingConsent: body.marketingConsent,
      // --- END OF CHANGE ---
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('住专 驻专 ');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('转转   转拽');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('住住 转  驻转 8 转, 转 , 转 拽 住驻专');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('砖转砖 注 转转   专 拽 注专转.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(),
            // --- START OF CHANGE ---
            marketingConsent: body.marketingConsent || false,
            // --- END OF CHANGE ---
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });
    // ---  住驻 砖: 驻注转 拽驻   ---
// 拽专   砖转  转,  专拽 转转 转  专砖 注 住驻专 .
try {
  await UserEngagementService.startCampaignForNewUser(result.user.id);
  logger.info('User engagement campaign successfully scheduled', { userId: result.user.id });
} catch (campaignError) {
  //  砖 注 转 拽驻,  专拽 转注 转  注爪专 转 转 专砖.
  logger.error('Failed to start user engagement campaign', { 
    userId: result.user.id,
    errorObject: campaignError 
  });
}
// --- 住祝 住驻 ---

    let emailSentSuccess = false;
        const emailOtpExpiryText = locale === 'he' ? "砖注 转" : "1 hour"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
        await emailService.sendVerificationEmail({
                locale, // <<<<<<<<<<<< 住驻转 -locale
                email: result.user.email,
                verificationCode: result.generatedOtp, 
                firstName: result.user.firstName,
                expiresIn: emailOtpExpiryText 
            });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = '砖 爪专 爪. ';
    if (emailSentSuccess) {
        responseMessage += `砖 拽 转 转转 " 砖 (${result.user.email}).   转 拽  砖.`;
    } else {
        responseMessage += '转 注 砖转 拽 转. 转 拽砖 拽 砖 住   驻转 转.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { userId: result.user.id });
    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id, 
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus, VerificationStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

// Zod schema for validating the request body
const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "转转   转拽" }),
});

// Helper for logging (consistent with your existing logs)
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus;
  locale?: 'he' | 'en'; // <<<<<<<<<<<< 转拽: 住驻转 驻 住专
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting (prevents email spam)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  // 2. Get Locale from URL for translation
  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Default to Hebrew
  
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined;

  try {
    // 3. Parse and Validate Request Body
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "转转   转拽" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    // 拽专  转拽 注砖
    logger.info('Processing password reset request', { action, email: normalizedEmail, locale });

    // 4. Find the user in the database
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    // SECURITY: Always return a generic success message to prevent user enumeration attacks.
    const genericSuccessMessage = locale === 'he'
      ? ' 拽转 转转   注专转 转 驻住 注专 住住, 拽 转 砖 注转.'
      : 'If an account with this email exists and is eligible for password reset, a code has been sent.';

    // 5. Handle cases where no email should be sent, but still return success to the client
    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    // 6. Invalidate previous pending password reset OTPs for this user
    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING,
        },
        data: {
            status: VerificationStatus.EXPIRED,
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    // 7. Create a new OTP using the Verification Service
    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60 // Service expects hours
    );
    logger.info('New password reset OTP created', { action, userId: user.id, verificationId: passwordResetVerification.id });

    // 8. Send the password reset email using the updated Email Service
    try {
      const expiresInText = locale === 'he' ? `${expiresInMinutes} 拽转` : `${expiresInMinutes} minutes`;

      await emailService.sendPasswordResetOtpEmail({
        locale,
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: expiresInText,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    // 9. Return the generic success response
    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    // 10. Handle unexpected errors
    const emailForLog = requestBody?.email;
    logger.error('Critical error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    const errorMessage = locale === 'he'
      ? '专注 砖 转.  住 砖转 专 转专.'
      : 'An error occurred. Please try again later.';

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, VerificationStatus } from '@prisma/client';

// --- 专转 ---
const RESEND_RATE_LIMIT_SECONDS = 60; //  转 砖转  拽砖转 专转

// --- 专 注专  ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => {
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta }));
    },
    warn: (message: string, meta?: Record<string, unknown>) => {
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta }));
    },
    error: (message: string, meta?: any) => {
      let logMeta = meta || {};
      if (meta instanceof Error) {
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
};

// --- 驻拽爪转 -API 专砖转 ---
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
    if (rateLimitResponse) {
        return rateLimitResponse;
    }

    logger.info("Resend phone code request received");

    // 1. --- 拽转 转 砖转砖 ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });

    try {
        // ============================ 转拽 专 (1 转 2) ============================
        // 2. --- 拽专转 砖驻 (locale) 驻专专 -URL ---
        const url = new URL(req.url);
        // 专转 注专转 砖驻转 专专转   驻专专  拽
        const locale = (url.searchParams.get('locale') || 'he') as 'he' | 'en';
        logger.info("Processing request with locale", { userId, locale });
        // =================================================================================

        // 3. --- 转专 拽砖转 转 专 砖 砖转砖 ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc'
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            return NextResponse.json({ error: ' 爪 拽砖转 转 驻注. 转 砖专 转转 转 住驻专  砖拽 驻 转拽祝.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });

        // 4. --- 拽转 转 拽爪 (Rate Limiting) ---
        const now = new Date();
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: ` 转 ${timeLeft} 砖转 驻 拽砖转 拽 砖.` }, { status: 429 });
        }
        logger.info("Rate limit check passed", { userId });

        // 5. --- 拽注转 住驻专 驻 砖 ---
        let targetPhone = lastVerification.target;
        let userFirstName = session.user.firstName || '';

        // 拽专 砖住驻专 驻  砖专 专砖转 转, 砖祝 转 砖转砖
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true }
             });
             if (!user?.phone) {
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                return NextResponse.json({ error: '砖:  转 转专 转 住驻专 驻 砖转 拽.' }, { status: 500 });
             }
             targetPhone = user.phone;
             userFirstName = user.firstName || '';
        }
        
        // 6. --- 爪专转 拽 砖 转专 转驻 砖 ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 转拽祝 -10 拽转
        logger.info("Generated new OTP", { userId });

        // 7. --- 注 专砖转 转 住 转 ---
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // 驻住  住转
                createdAt: new Date() // 注 转转  拽转 -rate limit 
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });

        // ============================ 转拽 专 (2 转 2) ============================
        // 8. --- 砖转 拽 砖, 转 注专转 砖驻 (locale) 砖专转 砖 ---
        // 注专: 砖  砖驻拽爪 `sendOtpViaWhatsApp`  拽转 驻专专 专注 砖 砖驻
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone, locale });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName,
        );
        // =================================================================================

        if (!otpSent) {
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            return NextResponse.json({ error: '砖转 拽 转 砖 爪注转 WhatsApp 砖.  住 砖 注 住驻专 专注.' }, { status: 500 });
        }

        // 9. --- 专转 转砖转 爪 ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: '拽 转 砖 砖 爪 爪注转 WhatsApp.' }, { status: 200 });

    } catch (error: unknown) {
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id,
            error: error
        });
        return NextResponse.json({ error: '专注 砖 驻转 砖专转. 住 砖 专 转专.' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification/route.ts

import { NextResponse, NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * 驻 拽砖转 砖 专转 砖 拽 转 .
 * 拽转 拽爪  注 砖转砖 砖专砖   拽 转 拽 转 专砖.
 */
export async function POST(req: NextRequest) {
  // 1. 转 拽爪 拽砖转 注转 砖砖 专注 砖转 住驻
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. 砖驻转 砖驻转 砖拽 -URL 爪专 转专 
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. 拽专转 转 祝 拽砖
    const body = await req.json();
    const { email } = body;

    if (!email || typeof email !== 'string') {
      return NextResponse.json(
        { success: false, error: "转转   砖 ." },
        { status: 400 }
      );
    }

    const normalizedEmail = email.toLowerCase();

    // 4. 转专 砖转砖 住 转
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    });

    // 拽转 拽爪 拽专转
    if (!user) {
      return NextResponse.json(
        { success: false, error: " 爪 砖转砖 注 转转  ." },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { success: false, error: "砖  专 转. 转 转专." },
        { status: 400 }
      );
    }

    // 5. 爪专转 拽 转 砖 爪注转 砖专转 转 专
    // 砖专转   转拽祝 砖 拽 拽 砖专 爪.
    const expiresInHours = 1; // 转拽祝 砖注
    const { otp: verificationCode } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email,
        expiresInHours
    );

    console.log(`[Resend Verification] New OTP generated for user: ${user.id}`);

    // 6. 砖转  转 砖 注 拽 砖爪专, 转 砖驻 砖专
    const expiresInText = locale === 'he' ? '砖注 转' : '1 hour';
    
    await emailService.sendVerificationEmail({
      locale, // 注专转 驻专专 砖驻
      email: user.email,
      verificationCode: verificationCode,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Resend Verification] Verification email sent successfully to ${user.email} in ${locale}`);

    // 7. 专转 转砖转 爪 拽
    return NextResponse.json({
      success: true,
      message: " 转 砖 砖 爪."
    });

  } catch (error: unknown) {
    // 8. 驻 砖转  爪驻转
    console.error('[API Resend Verification] A critical error occurred:', error);
    
    const errorMessage = error instanceof Error ? error.message : "砖  爪驻 砖转  转.";
    
    return NextResponse.json(
        { success: false, error: "专注 砖 转,  住 砖转 专 转专.", details: errorMessage }, 
        { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification-code/route.ts

import { NextResponse, NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { VerificationType, UserStatus } from '@prisma/client';
import { applyRateLimit } from '@/lib/rate-limiter';

// 专转 驻住 注 砖专 
type LogMetadata = {
  email?: string;
  error?: unknown;
  userId?: string;
  verificationId?: string;
  status?: UserStatus;
  isVerified?: boolean;
};

// 拽 专 驻砖 注拽
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: NextRequest) {
  // 1. 转 拽爪 拽砖转
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  let requestBody: ResendCodeRequest | null = null;
  try {
    // 2. 砖驻转 砖驻转 砖拽 -URL
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. 拽专转 转 祝 拽砖
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });

    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: '住专 转转 .' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    
    // 4. 转专 砖转砖 爪
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail });
      return NextResponse.json({ success: false, error: '砖转砖 注 转转    专砖.' }, { status: 404 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        logger.warn('User email already verified or not pending verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: '转转  专 转转  砖 转 转.' }, { status: 400 });
    }
    
    // 5. 爪专转 拽 转 砖 专 砖专转 专
    const expiresInHoursForOtp = 1;
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHoursForOtp
    );
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });

    // 6. 砖转  注 拽 砖 砖驻 
    const emailOtpExpiryText = locale === 'he' ? "砖注 转" : "1 hour";
    await emailService.sendVerificationEmail({
      locale, // <<<<<<<<<<<< 注专转 -locale
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    // 7. 专转 转砖转 爪
    return NextResponse.json({
      success: true,
      message: `拽 转 砖 砖 转转 ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    // 8. 驻 砖转  爪驻转
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails });

    let errorMessage = '专注 砖 砖 专转 砖 拽.';
    const errorStatus = 500;

    if (error instanceof Error && error.message.includes('专注 砖 爪专转 拽 转')) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { hash } from 'bcryptjs';
import { z } from 'zod';

// Zod schema for validating the request body with detailed messages
const resetPasswordSchema = z.object({
  email: z.string().email({ message: "转转   转拽" }),
  otp: z.string()
    .length(6, { message: "拽 转   6 住驻专转" })
    .regex(/^\d+$/, { message: "拽 转   住驻专转 " }),
  newPassword: z.string()
    .min(8, { message: "住住 转  驻转 8 转" })
    .regex(/[a-z]/, { message: "住住 转  驻转 转 拽 转 转" })
    .regex(/[A-Z]/, { message: "住住 转  驻转 转  转 转" })
    .regex(/[0-9]/, { message: "住住 转  驻转 住驻专 转" }),
});

// Helper for consistent logging
type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "reset-password-with-otp";
  let requestBody: { email?: string } | undefined;

  try {
    // 1. Apply Rate Limiting (prevents brute-force attacks on OTP)
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '15 m' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Default to Hebrew

    // 3. Parse and Validate Request Body
    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action, locale });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "转  转拽.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];

      logger.warn('Invalid input for password reset', { action, error: errors });
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    // 4. Verify the OTP using the centralized VerificationService
    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });
    
    // This service will throw an error if the OTP is invalid, expired, or has too many attempts.
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    // Ensure the result from the service contains the necessary data
    if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      logger.error('OTP verification failed unexpectedly or did not return required data', {
        action,
        email: normalizedEmail,
        error: verificationResult.message,
      });
      throw new Error(verificationResult.message || '砖 转 拽.');
    }

    const { userId, id: verificationId } = verificationResult;
    logger.info('OTP verified successfully', { action, userId, verificationId });

    // 5. Hash the new password
    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    // 6. Update user's password and mark OTP as used
    // These are done sequentially. If marking as completed fails, it's not critical as the token will expire.
    
    // Update the user's password
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
      },
      select: { email: true, firstName: true } // Select data needed for confirmation email
    });
    logger.info('User password updated in database', { action, userId });

    // Mark the verification record as COMPLETED
    await VerificationService.completeVerification(verificationId);
    logger.info('Verification record marked as completed', { action, verificationId });

    // 7. Send password change confirmation email (non-critical step)
    if (user) {
      try {
        // *** CRITICAL FIX: Pass the locale to the email service ***
        await emailService.sendPasswordChangedConfirmationEmail({
          locale, // Pass the determined locale
          email: user.email,
          firstName: user.firstName,
        });
        logger.info('Password change confirmation email sent', { action, userId, locale });
      } catch (emailError) {
        // Log the error but do not fail the request, as the password has been successfully changed.
        logger.error('Failed to send password change confirmation email', {
          action,
          userId,
          error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
        });
      }
    }

    // 8. Return success response
    const successMessage = locale === 'he'
      ? '住住 驻住 爪. 注转 转 转专 注 住住 砖.'
      : 'Password has been reset successfully. You can now log in with your new password.';
      
    return NextResponse.json({ success: true, message: successMessage }, { status: 200 });

  } catch (error: unknown) {
    // 9. Handle all errors gracefully
    const emailForLog = requestBody?.email;
    logger.error('Critical error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    let errorMessage = '专注 砖 驻住 住住.';
    let errorStatus = 500;

    // Map specific known errors from VerificationService to user-friendly messages and statuses
    if (error instanceof Error) {
      const knownClientErrors = [
        '拽 专 爪.',
        '转拽祝 拽 驻.  拽砖 拽 砖.',
        '拽 转  转拽  砖 拽转 拽砖转 转 驻注.',
        '拽 转 砖.',
        '专转 住驻专 住转 转 转专.  拽砖 拽 砖.',
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; // Bad Request
        if (error.message.includes("驻 转拽驻")) errorStatus = 410; // Gone
        if (error.message.includes("专转 住驻专 住转")) errorStatus = 429; // Too Many Requests
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 requests per user per hour (costly SMS/WhatsApp)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. 拽 转 驻专 砖转砖 -DB (注拽专 住驻专 驻)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // 砖   专 拽专转  砖转砖 注  专 砖转 驻专驻
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. 爪专转 OTP 砖
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 拽转 转驻

        // 3. 砖专转/注 专砖转 转
        // 拽 专砖转 拽转 转 砖转砖  注 
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // 爪专 专砖 砖
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. 砖转 -OTP 住驻
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // 专 砖  砖拽  爪 注 转
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/send-verification/route.ts

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { VerificationType, UserStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

export const runtime = 'nodejs';

/**
 * Handles requests to send a new email verification code to an existing, unverified user.
 */
export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting to prevent email spam
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. Parse and Validate Request Body
    const { email } = await req.json();
    if (!email || typeof email !== 'string') {
      return NextResponse.json({ success: false, error: "  砖 " }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 4. Find the user and perform necessary checks
    const user = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (!user) {
      // Security: Return a generic message even if the user doesn't exist to prevent enumeration.
      return NextResponse.json({ success: true, message: " 拽 砖 砖  , 砖  拽 转." }, { status: 200 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        return NextResponse.json({ success: false, error: "砖  专 转  砖 转 转." }, { status: 400 });
    }

    // 5. Create a new verification OTP using the central service
    const expiresInHours = 1; // 1-hour validity for the new code
    const { otp: generatedOtp } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHours
    );

    console.log(`[Send Verification] New OTP generated for user: ${user.id}`);

    // 6. Send the verification email using the updated Email Service
    const expiresInText = locale === 'he' ? '砖注 转' : '1 hour';
    await emailService.sendVerificationEmail({
      locale, // <-- Pass the correct locale
      email: user.email,
      verificationCode: generatedOtp,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Send Verification] Verification email re-sent successfully to ${user.email} in ${locale}`);

    // 7. Return a success response
    return NextResponse.json({ success: true, message: "拽 转 砖 砖 爪." }, { status: 200 });

  } catch (error) {
    // 8. Handle unexpected errors
    console.error('[API Send Verification] A critical error occurred:', error);
    const errorMessage = error instanceof Error ? error.message : "砖  爪驻 砖转 拽 转.";
    return NextResponse.json(
      { success: false, error: "专注 砖 转,  住 砖转 专 转专.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
});


export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. 拽 砖住驻专 砖  转驻住 注  砖转砖 转 专
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } //  砖转砖 
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: '住驻专 驻 专 专砖 驻注 注专转 注专 砖转砖 专.' }, { status: 409 }); // Conflict
          }

        // 2. 注 转 住驻专 驻 砖 砖转砖
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // 拽 转 砖 注  爪专
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. 爪专 OTP 砖
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 拽转 转驻

        // 4. 爪专/注 专砖转 转 注专 住驻专 砖
        //  专砖转 拽转  
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // 住 拽 驻 转拽祝
         });
         // 爪专 专砖 砖
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // 住驻专 砖
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. 砖 转 -OTP 住驻专 砖
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // 专 砖, 转 砖住驻专 砖  转拽 住驻
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // 专转 error -unknown
        console.error("API update-and-resend: An error occurred:", error);

        // 驻 砖转 住驻爪驻转
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // 砖转 驻转 - 专转 砖拽, 转 爪 race condition
            return NextResponse.json({ error: '住驻专 驻 专 专砖 注专转.' }, { status: 409 });
        }

        // 砖 转
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId   转 string  undefined    拽 
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 verification attempts per IP per 15 minutes (prevents brute-force)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '15 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: '住专 驻专   拽.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `驻专 拽  转拽. 拽 爪专  ${OTP_LENGTH_FROM_SERVICE} 住驻专转.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- 转拽 转  ---
    //  砖-userId 拽  专转 驻 砖砖
    // 住专  砖-verificationResult.userId  转 string | null
    // 注 驻 专 砖 VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // 专拽 砖 砖转驻 拽 -catch ,  驻  驻 住驻爪驻 转专
      // 砖  爪注 注 注 转 驻转  拽 转   砖转砖 砖
      throw new Error('砖 驻转:  爪 砖转砖 砖 转 专 转 拽 爪.');
    }
    
    // 注转, 专 拽, TypeScript  住拽 ( 砖 爪专 驻专砖)
    // 砖-userId  string.
    const userId: string = verificationResult.userId; 
    // --- 住祝 转拽 ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, //  userId  转 string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: '转转  转 爪! 转爪注转 转专转 转...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = '专注 砖 转 拽.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '拽 专 爪.', 
        '转拽祝 拽 驻.  拽砖 拽 砖.', 
        '拽 转  转拽  砖 拽转 拽砖转 转 驻注.', 
        '拽 转 砖.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === '砖 驻转:  爪 砖转砖 砖 转.' || 
                 error.message === '砖 驻转:  爪 砖转砖 砖 转 专 转 拽 爪.') { // 住驻转 砖 砖  专爪 驻 
        errorMessage = '专注 砖 驻转.  住 砖转 专 转专.';
        // errorStatus 砖专 500 专专转  砖转 驻转,  砖转砖 驻 爪专
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/verify-phone-code/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { z } from 'zod';
import { Prisma, VerificationType, UserStatus } from '@prisma/client';

import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { emailService } from '@/lib/email/emailService';

// --- 专转 ---
// 住驻专 住转 转 拽住 驻 砖拽 砖
const MAX_VERIFICATION_ATTEMPTS = 5;

// --- 住转 Zod 转 祝 拽砖 ---
// 转 砖拽 砖 拽 注 砖 'code' 转拽
const verifyCodeSchema = z.object({
  code: z.string()
    .length(6, { message: "拽 转   6 住驻专转" })
    .regex(/^\d+$/, { message: "驻专 拽  转拽, 住驻专转 " }),
});


// --- 专 驻砖  ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
    warn: (message: string, meta?: Record<string, unknown>) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
    error: (message: string, meta?: Record<string, unknown>) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};


// --- 拽转 拽爪 (Endpoint) 专砖转 ---
export async function POST(req: NextRequest) {
  const action = "verify-phone-code";

  try {
    // 砖 1: 转 砖转砖
    // ------------------------------------
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      logger.warn("住 转 驻  住砖 驻注", { action });
      return NextResponse.json({ error: 'Unauthorized - 专砖转 转专转' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("转 转 驻  注专 砖转砖", { action, userId });


    // 砖 2: 拽转 砖驻转 砖拽 拽
    // ------------------------------------
    // 砖驻 砖转 驻专专 -URL, 砖: /api/auth/verify-phone-code?locale=en
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // 专专转  注专转
    logger.info("砖驻转 砖拽 转", { action, userId, locale });


    // 砖 3: 拽专转 转 祝 拽砖
    // ------------------------------------
    const body = await req.json();
    const validation = verifyCodeSchema.safeParse(body);

    if (!validation.success) {
      logger.warn("转  转拽 拽砖", { action, userId, errors: validation.error.flatten() });
      return NextResponse.json({ error: '转  转拽', details: validation.error.flatten() }, { status: 400 });
    }
    const { code } = validation.data;


    // 砖 4: 转专 拽砖转 转 住住 转
    // ------------------------------------
    const verification = await prisma.verification.findFirst({
        where: {
            userId: userId,
            type: VerificationType.PHONE_WHATSAPP,
            status: 'PENDING',
        },
        orderBy: {
            createdAt: 'desc' //  砖 拽 转 拽砖 专
        }
    });

    if (!verification) {
      logger.warn(" 爪 拽砖转 转 驻 驻注", { action, userId });
      return NextResponse.json({ error: ' 爪 拽砖转 转 驻注  砖砖 专 转.' }, { status: 404 });
    }


    // 砖 5: 拽转 转拽祝 转拽转 拽
    // ------------------------------------
    // 拽 5:  拽 驻 转拽祝?
    if (new Date() > verification.expiresAt) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'EXPIRED' }
        });
        logger.warn("住 砖转砖 拽 砖驻 转拽驻", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '拽 转 驻 转拽祝.  拽砖 拽 砖.' }, { status: 410 }); // 410 Gone
    }

    // 拽 5:  砖转砖 专 住驻专 住转?
    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'FAILED' }
        });
        logger.warn("专 住驻专 住转 转", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '专转 住驻专 住转 转 转专.  拽砖 拽 砖.' }, { status: 429 }); // 429 Too Many Requests
    }

    // 拽 5:  拽 砖 砖?
    if (verification.token !== code) {
        const updatedVerification = await prisma.verification.update({
            where: { id: verification.id },
            data: { attempts: { increment: 1 } }
        });
        const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - updatedVerification.attempts;
        logger.warn(" 拽 转 砖", { action, userId, attemptsLeft });
        return NextResponse.json({ error: `拽 转 砖. 转专  ${attemptsLeft} 住转.` }, { status: 400 });
    }


    // 砖 6: 转 爪 - 注 住住 转 砖转 
    // ----------------------------------------------------
    // 砖砖 专拽爪   砖砖转 驻注转 (注 砖转砖 注 转) 爪   砖 
    const [updatedVerification, updatedUser] = await prisma.$transaction([
        // 6: 注 专砖转 转 住住 'COMPLETED'
        prisma.verification.update({
            where: { id: verification.id },
            data: {
                status: 'COMPLETED',
                completedAt: new Date(),
                attempts: verification.attempts + 1
             }
        }),
        // 6: 注 专砖转 砖转砖 - 驻 转 驻注!
        prisma.user.update({
            where: { id: userId },
            data: {
                isPhoneVerified: true,
                isProfileComplete: true, // 专 转 驻, 驻专驻 砖 砖
                status: UserStatus.ACTIVE, // 砖转砖 驻 驻注
                updatedAt: new Date(),
            },
            // 专转 砖转 砖专 - 砖 拽 转  砖 注专 砖转 
            select: {
                id: true,
                email: true,
                firstName: true,
                isPhoneVerified: true,
                isProfileComplete: true,
                status: true,
             }
        })
    ]);
    
    logger.info("转 驻 砖 爪, 砖转砖 专 驻注", { action, userId });

    // 6: 砖转  "专 " - 专拽 专 砖专拽爪 爪
    try {
        await emailService.sendWelcomeEmail({
            locale, // << 注专转 砖驻 转 砖转拽 拽
            email: updatedUser.email,
            firstName: updatedUser.firstName || '专',
            dashboardUrl: '/profile'
        });
        logger.info(" 专  砖 爪", { action, userId, email: updatedUser.email, locale });
    } catch (emailError) {
        // 砖 砖转   爪专 砖 转  拽砖. 砖转砖 注 转.
        // 砖 专砖 转 砖 注拽.
        logger.error("砖 砖转  专  专 转 驻", { action, userId, error: emailError });
    }


    // 砖 7: 专转 转砖转 爪 拽
    // ------------------------------------
    return NextResponse.json({
         success: true,
         message: '转 驻 砖 爪!',
         user: updatedUser // 专转 驻专 砖转砖 注 注 住砖 爪 拽
    }, { status: 200 });

  } catch (error) {
    // --- 驻  砖转  爪驻转 ---
    const userId = (await getServerSession(authOptions))?.user?.id || 'unknown';
    logger.error("砖 拽专转 转 转 驻", { action, userId, error });

    if (error instanceof z.ZodError) {
        return NextResponse.json({ error: '转  转拽 拽砖', details: error.flatten() }, { status: 400 });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        return NextResponse.json({ error: '砖转 住 转 转 转' }, { status: 500 });
    }
    
    return NextResponse.json({ error: '专注 砖 驻转 砖专转.  住 砖转 专 转专.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability\check
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability\check\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/availability/check/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
export async function POST(req: NextRequest) {
  try {
    // 1. Aplicar un l铆mite de peticiones para prevenir el abuso.
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });    if (rateLimitResponse) {
      return rateLimitResponse;
    }
    
    // 2. Autenticar la sesi贸n del usuario (matchmaker).
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Extraer el 'locale' de los par谩metros de la URL.
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Por defecto, se establece en hebreo.

    // 4. Extraer el 'clientId' del cuerpo de la solicitud.
    const body = await req.json();
    const { clientId } = body;

    if (!clientId) {
      return NextResponse.json({ success: false, error: "Bad Request: clientId is required." }, { status: 400 });
    }

    // 5. Llamar al servicio de disponibilidad, AHORA con el par谩metro 'locale'.
    const result = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId: clientId,
      locale: locale, // Se ha a帽adido el par谩metro 'locale' que faltaba.
    });

    // 6. Devolver el resultado exitoso.
    return NextResponse.json({ success: true, inquiry: result });

  } catch (error) {
    // 7. Manejar cualquier error que ocurra durante el proceso.
    console.error("Error checking availability:", error);
    
    // Devolver un mensaje de error m谩s espec铆fico si es posible.
    const errorMessage = error instanceof Error ? error.message : "Failed to check availability";
    
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\chat
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\chat\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/chat/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';
import nodemailer from 'nodemailer';

// --- 转住驻转 砖转  ---
import { getToken } from 'next-auth/jwt';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// --- 专转 Rate Limiter ( 驻爪'专 砖) ---
//  砖砖转 住 专
if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
  // 住转 驻转,  专拽 专. 驻专拽砖,   转 砖 拽专转.
  console.warn('Upstash Redis credentials are not configured. Rate limiting for CHAT API will not be active.');
}
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL || '',
  token: process.env.UPSTASH_REDIS_REST_TOKEN || '',
});

// 驻砖专 15 拽砖转 砖注.  驻砖专 砖 拽爪专 注 爪驻.
const ratelimit = new Ratelimit({
  redis: redis,
  limiter: Ratelimit.slidingWindow(15, '1 h'),
});
// --- 住祝 转住驻转  ---


// --- START: Internationalized Knowledge Base ---
const KNOWLEDGE_BASES = {
  he: [
      {
        question: "  NeshamaTech?  转 注砖?",
        answer:
          "NeshamaTech  驻驻专转 砖 砖住 转  注拽 砖 转专 注  专.  砖   注  砖  砖 爪转 砖,  爪专 专 专爪 砖注转.\n\n专 砖  专 转 注拽  转 专转, 驻砖专  驻砖 砖 注 住住 转 转转 砖 砖转 注专,  专拽 注 住 转."
      },
      {
        question: " 砖 砖?  转 注?",
        answer:
          "砖 砖  注 砖砖 住转: 注拽,   砖.\n\n1.  **专转 注拽:** 转 转 注 砖 '砖转 注转'  砖.   ,  住注 专转 砖 砖 转 砖转驻 转 转驻住转 注  砖砖 .\n\n2.  ** 砖专转 :** 注专转  砖 转转 转 注 转专转 转 专 专 转 砖 注 驻爪 转  转专 注专.\n\n3.  ** 砖拽 注转 砖:**  爪注 驻爪转 注专转 拽 砖专 砖 砖 砖. 转拽 专拽 爪注转 拽转,  砖  . 砖   转 专  专,  住拽专转 转."
      },
      {
          question: ' 转 砖 驻拽爪转 专转  砖 专?',
          answer:
          " 砖 爪转.  砖 转  砖 注转:\n\n*   ** 驻拽爪转:**  爪注 住拽专转  (驻专驻 砖  砖祝 ), 住  转  驻砖 ( 注 砖), 专 砖  砖转爪 转 转注 转.\n\n*   ** 砖转 住专转转:**  砖转砖   砖转 专  专 专 转专,  砖 转 住 爪, 转 砖专 注  砖 转 专转 转  砖注专 转 砖.\n\n 驻砖转,  砖转 砖转 注 ."
      },
      {
          question: ' 驻专转 砖 砖专转?  专 转 注 砖?',
          answer: "驻专转 住拽专转 砖  注专 注 注专.  . 驻专驻 砖 砖祝  专拽 爪转 砖 爪爪 砖驻 .   砖祝 砖转砖 专. 砖专   转,  爪  爪 驻专驻 驻专  砖 爪 砖, 转 专拽 专 砖拽 转 砖专 驻专砖. 转 转 砖  注 注 砖."
      },
      {
        question: ' 注转 砖 砖专转?   注?',
        answer:
          '拽 转拽驻转 砖拽 专爪 砖 转 拽 转转, 砖专转 专注 爪注  住 砖 10 砖" 砖 (  注转, 转 转拽驻). 砖 砖: 砖 ,  爪 " 爪" ,   转转专住 专. 专 砖  驻砖专  专 转 砖 转 砖  住. 注转, 转 注专  砖  爪,   砖   驻祝 注 转 砖砖 拽转 住转 砖转.'
      },
      {
        question: ' 住 砖 爪 转    拽?',
        answer:
          " 砖 砖.    拽 ,  砖 拽转 砖 住转  拽专 专 专砖转. 拽 转 砖转 砖转, 转拽 住驻专 爪爪 砖 爪注转 转转 拽转. 专  转 注 驻 转,  砖 爪注 转 砖注转转."
      },
      {
        question: '  转转 (AI) 注专转 ?',
        answer:
          "-AI   注专   注专  注专 砖 砖. 砖,  住注 转 注拽 砖 驻专驻  转 驻住 转 住转专. 注专, 注专转  爪注 转转 砖驻专 驻专驻, 住注  转注抓  爪注转 砖转拽    转专 转 拽转 拽 转."
      },
      {
        question: ' 砖专转 注?',
        answer:
          '砖专转 砖 注 专拽 专拽转 拽 转 驻砖 拽砖专 专爪  转. 砖 ,  转拽 注拽专 拽 转- 拽 砖专,  驻转   砖转专 砖 注拽 转 砖. 注专转 注转 专注 砖  专 砖 (住专) .'
      }
  ],
  en: [
    {
        question: "What is NeshamaTech? What do you do?",
        answer: "NeshamaTech is a matchmaking platform founded on a deep understanding of the challenges in the modern dating world. We combine smart technology with the warm, personal guidance of a team of matchmakers to create serious and meaningful connections.\n\nOur goal is to bring depth and respect back to the process of getting to know someone, allowing you to meet people based on a true compatibility of personality and values, not just a picture."
    },
    {
        question: "What is your method? How does the process work?",
        answer: "Our method is built on three pillars: depth, technology, and personal guidance.\n\n1.  **In-depth acquaintance:** The process begins with our unique 'Five Worlds' questionnaire. It's not a test, but a personal discovery journey where you share your worldviews and what's important to you.\n\n2.  **Technology at the service of the heart:** Our smart system analyzes the information and identifies individuals with the highest potential for compatibility from a wide database.\n\n3.  **Human guidance and judgment:** Every potential suggestion is reviewed and approved by a personal matchmaker. You will only receive well-reasoned suggestions that we believe in. The matchmaker also accompanies you throughout the process, all with complete discretion."
    },
    {
        question: "How are you different from dating apps or regular matchmakers?",
        answer: "That's an excellent question. We combine the best of both worlds:\n\n*   **Compared to apps:** We offer complete discretion (your profile is not public), we save you search time (we do the work for you), and our goal is for you to find a relationship and leave us.\n\n*   **Compared to traditional matchmaking:** We use technology to access a much larger and broader database, which increases the chances of success, while maintaining personal guidance and the ability to see beyond dry data.\n\nSimply put, we are personal matchmaking for the digital age."
    },
    {
        question: "How is my privacy protected? Who sees my information?",
        answer: "Your privacy and discretion are our top priority. This is a promise. Your profile is only visible to the small matchmaking team handling your case. It is not exposed to other users. When we identify a match, we present each side with a detailed and respectful profile of the other, but only after receiving your explicit approval. You are always in full control of your information."
    },
    {
        question: "What is the cost of the service? How much does it cost?",
        answer: "As part of our launch period and our desire to build a quality community, the service is currently offered at a symbolic model of $3/month (or for free, depending on the period). It's important to note: at this stage, we have **no 'success fees' at all**, even if you get engaged through us. Our goal is to let you experience our unique approach without barriers. In the future, we might add premium tracks or another model, but any such change will be subject to updating the terms of use and receiving your renewed consent."
    },
    {
        question: "What are my chances of finding a match and how long does it take?",
        answer: "That's an important question. There's no exact timeline for love, but our focused approach saves significant time and emotional energy. Instead of hundreds of superficial conversations, you'll receive a small number of high-quality, reasoned suggestions. The goal is quality over quantity, so that every suggestion is meaningful."
    },
    {
        question: "How does Artificial Intelligence (AI) help me?",
        answer: "The AI is a smart tool for both you and our matchmakers. For matchmakers, it assists in in-depth profile analysis to identify hidden compatibility patterns. For you, the system can offer insights to improve your profile and help you consult on suggestions you receive to better understand the strengths of a match."
    },
    {
        question: "Who is the service for?",
        answer: "Our service is designed for single men and women from the Jewish community who are looking for a serious relationship leading to marriage. At this stage, we primarily focus on the Religious-Zionist and academic community in Israel, but we are open to anyone who connects with our in-depth and respectful approach. The system is currently intended for heterosexual matchmaking only."
    }
  ]
};
// --- END: Internationalized Knowledge Base ---

const getPrompt = (lang: 'he' | 'en', knowledgeContext: string, message: string) => {
    if (lang === 'en') {
        return `
          **Your Persona:**
          You are the "Personal Assistant" for NeshamaTech. You are the first point of contact for potential users looking for a serious relationship. Your tone is that of a seasoned, warm, and trustworthy professional.
          - **Professional and Reassuring:** Use clear, respectful, and confident language.
          - **Empathetic and Understanding:** Acknowledge the challenges of the dating world but offer hope and a path forward.
          - **Trustworthy and Discreet:** Always emphasize the importance of privacy and trust.
          - **Value-Focused:** Explain not just *what* we do, but *why* it is beneficial for the user.
          - **Fluent and natural English speaker only.**

          **Your Mandatory Rules:**
          1.  **Rely solely on the knowledge base:** Do not invent information. Every answer must come directly from the text provided to you.
          2.  **Do not make promises:** Avoid promises like "you will find love." Instead, talk about "increasing the chances," "an efficient process," and "meaningful connections."
          3.  **Identify out-of-scope questions:** If the question is not covered in the knowledge base, you must respond with empathy and service-orientation. Reply: "That's an important question that deserves a personal answer from our team. I don't have specific information on that in the system, but I can forward your inquiry directly to one of the matchmakers. Would you like to send them a message by email?".
          4.  **Interpret questions:** Understand user intent. "How much" -> address cost. "How it works" -> address the method. "Is it safe?" -> address privacy.
          5.  **Avoid superlatives:** Don't say "we are the best." Instead, explain *why* our approach is unique and beneficial.

          --- Full Knowledge Base (Your absolute truth) ---
          ${knowledgeContext}
          --- End of Knowledge Base ---

          **Request:**
          Answer the following user's question, based on the persona and strict rules defined for you.

          User's question: "${message}"

          Answer in English:
        `;
    }

    // Default to Hebrew
    return `
      **驻专住 砖:**
      转 "注专 砖" 砖 NeshamaTech. 转 拽 专砖 注 注 砖转砖 驻爪 砖驻砖 拽砖专 专爪.  砖   砖 砖 拽爪注 转拽,  .
      - **拽爪注 专注:** 砖转砖 砖驻 专专, 转 转. 专  注.
      - **驻转 :** 专 转专 砖 注 ,  爪注 转拽 专 驻注.
      - ** 住拽专:** 砖 转 转 砖转 驻专转 .
      - **拽-注专:** 住专  专拽 **  注砖,  **   注 砖转砖.
      - **专 注专转 专 注转 .**

      **  砖:**
      1.  **转住住  专拽 注 专 注:**  转爪 注 砖 驻.  转砖 转 注 砖专转 拽住 砖住驻拽 .
      2.  ** 转 转:** 注 转  "转爪 ". 拽 转, 专 注 "转 住", "转 注", "专 砖注转".
      3.  ** 砖 抓 专:**  砖  住 专 注, 注 砖 驻转 爪专 砖专转转. 注: " 砖 砖 砖专 转砖 砖转 爪转 砖.   注 拽 注  注专转,    注专 转 驻转 砖专转  砖.  转专爪/ 砖  驻 ?".
      4.  **驻专砖转 砖转:**  转 转 砖转砖. " 注" -> 转住 注转. "  注" -> 转住 砖. "  ?" -> 转住 驻专转.
      5.  **注 住驻专:**  转 "  ". 拽, 住专 *注* 砖 砖 转 注.

      --- 专 注  (转 转 砖) ---
      ${knowledgeContext}
      --- 住祝 专 注 ---

      **拽砖:**
      注 注 砖转 砖转砖 , 转住住 注 驻专住  专 砖专 .

      砖转 砖转砖: "${message}"

      转砖 注专转:
    `;
};

const EMAIL_SUCCESS_MESSAGES = {
    he: '转 专! 驻转 砖 爪.  砖 爪转 砖 专  驻 砖 拽 驻砖专.',
    en: 'Thank you! Your message has been sent successfully. One of our team members will get back to you personally as soon as possible.'
};

const FALLBACK_PHRASES = {
    he: '砖  驻 ',
    en: 'send them a message by email'
};

const FALLBACK_ACTION_LABELS = {
    he: ', 砖 砖 驻 爪转',
    en: 'Yes, I\'d like to send an email to the team'
};

if (!process.env.GOOGLE_API_KEY) {
  console.error('[CHAT API ERROR] GOOGLE_API_KEY is not defined!');
}

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);

const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
];

export async function POST(req: NextRequest) {
  try {
    // --- 住驻转 拽转 Rate Limiting ---
    if (process.env.NODE_ENV === 'production' && process.env.UPSTASH_REDIS_REST_URL) {
      const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
      const ip = req.ip ?? '127.0.0.1';
      const identifier = token?.sub ?? ip;
      const { success } = await ratelimit.limit(identifier);

      if (!success) {
        return new NextResponse('Too many requests. Please try again later.', { status: 429 });
      }
    }
    // --- 住祝 拽转 Rate Limiting ---

    const { message, type, userEmail, locale } = await req.json();
    const lang: 'he' | 'en' = locale === 'en' ? 'en' : 'he';

    if (!message || typeof message !== 'string') {
      return NextResponse.json({ error: 'Message is required' }, { status: 400 });
    }

    if (type === 'email') {
      if (!userEmail || typeof userEmail !== 'string') {
        return NextResponse.json({ error: 'User email is required' }, { status: 400 });
      }

      const transporter = nodemailer.createTransport({
        service: process.env.EMAIL_SERVICE || 'gmail',
        auth: {
          user: process.env.GMAIL_USER || process.env.EMAIL_USER,
          pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
        },
        tls: { rejectUnauthorized: process.env.NODE_ENV === 'production' },
      });

      const mailOptions = {
        from: `"${process.env.EMAIL_FROM_NAME || 'NeshamaTech Chatbot'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to: 'jewish.matchpoint@gmail.com',
        subject: `New Chat Inquiry: ${userEmail}`,
        replyTo: userEmail,
        html: `
          <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6; color: #333;">
            <h2 style="color: #0891b2;">驻 砖 爪'- 转专 NeshamaTech:</h2>
            <p><strong>转:</strong> <a href="mailto:${userEmail}">${userEmail}</a></p>
            <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
              <p style="margin: 0; white-space: pre-wrap;">${message.replace(/\n/g, '<br>')}</p>
            </div>
            <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
               注 转. 转 砖   砖专转  注转 驻.
            </p>
          </div>
        `,
      };

      await transporter.sendMail(mailOptions);
      return NextResponse.json({
        reply: EMAIL_SUCCESS_MESSAGES[lang],
      });
    }

    const selectedKnowledgeBase = KNOWLEDGE_BASES[lang];
    const knowledgeContext = selectedKnowledgeBase
        .map((item) => `砖: ${item.question}\n转砖: ${item.answer}`)
        .join('\n\n');

    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash', safetySettings });
    
    const prompt = getPrompt(lang, knowledgeContext, message);

    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text();

    const isFallback = text.includes(FALLBACK_PHRASES[lang]);

    if (isFallback) {
      return NextResponse.json({
        reply: text,
        isFallback: true,
        actions: [{ type: 'email', label: FALLBACK_ACTION_LABELS[lang] }],
      });
    }

    return NextResponse.json({ reply: text, isFallback: false });
  } catch (error) {
    console.error('Error in /api/chat route:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { error: 'Internal Server Error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/contact/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import nodemailer from 'nodemailer';
import { z } from 'zod';

// Zod schema for validating the contact form data
const contactSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters long" }),
  email: z.string().email({ message: "Invalid email address" }),
  message: z.string().min(10, { message: "Message must be at least 10 characters long" }),
});

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 contact form submissions per IP per hour (prevents spam)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const body = await req.json();

    // Validate the request body
    const validationResult = contactSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: "Invalid input", details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { name, email, message } = validationResult.data;

    // Configure the email transporter using environment variables
    const transporter = nodemailer.createTransport({
      service: process.env.EMAIL_SERVICE || 'gmail',
      auth: {
        user: process.env.GMAIL_USER || process.env.EMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
      },
      tls: {
        rejectUnauthorized: process.env.NODE_ENV === 'production',
      }
    });

    // Define the email options
    const mailOptions = {
      from: `"${process.env.EMAIL_FROM_NAME || 'Match Point Contact Form'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
      to: "jewish.matchpoint@gmail.com", // Your support/admin email address
      subject: `驻 砖 转专 Match Point - ${name}`,
      replyTo: email, // This allows you to reply directly to the user
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6;">
          <h2 style="color: #0891b2;">转拽 注 砖 驻住 爪专转 拽砖专 转专:</h2>
          <p><strong>转:</strong> ${name} (<a href="mailto:${email}">${email}</a>)</p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;" />
          <h3 style="color: #333;">转 注:</h3>
          <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
            <p style="margin: 0; white-space: pre-wrap;">${message.replace(/\n/g, '<br>')}</p>
          </div>
          <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
             注 转. 转 砖   砖专转  注转 驻.
          </p>
        </div>
      `,
    };

    // Send the email
    await transporter.sendMail(mailOptions);

    // Return a success response
    return NextResponse.json({ success: true, message: "注 砖 爪." });

  } catch (error) {
    console.error("Error in /api/contact route:", error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal Server Error", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\feedback
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\feedback\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/feedback/route.ts

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getToken } from 'next-auth/jwt';
import { v2 as cloudinary } from 'cloudinary';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';
import prisma from '@/lib/prisma';
import { FeedbackType } from '@prisma/client';
import { emailService } from '@/lib/email/emailService';

// 专转 Redis -Rate Limiter 砖专转 专 转.  转拽.
if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
  console.warn('Upstash Redis credentials are not configured. Rate limiting will not be active.');
}

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL || '',
  token: process.env.UPSTASH_REDIS_REST_TOKEN || '',
});

const ratelimit = new Ratelimit({
  redis: redis,
  limiter: Ratelimit.slidingWindow(5, '1 h'),
});

export async function POST(req: NextRequest) {
  // --- 转转 转拽 拽专 ---
  // 专转 转爪专转 Cloudinary 转 驻拽爪转 -POST.
  //   砖 驻注 砖-API 拽专 (住转 Serverless),
  // 砖转 住 注   拽 驻 砖砖 .
  cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET,
  });
  // --- 住祝 转拽 拽专 ---

  // 拽转 Rate Limiting
  if (process.env.NODE_ENV === 'production' && process.env.UPSTASH_REDIS_REST_URL) {
    try {
      const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
      const ip = req.ip ?? '127.0.0.1';
      const identifier = token?.sub ?? ip;
      const { success } = await ratelimit.limit(identifier);

      if (!success) {
        return new NextResponse('Too many requests. Please try again later.', { status: 429 });
      }
    } catch (e) {
        console.error("Error with rate limiter:", e);
    }
  }

  try {
    const formData = await req.formData();
    const content = formData.get('content') as string;
    const feedbackType = formData.get('feedbackType') as FeedbackType;
    const pageUrl = formData.get('pageUrl') as string;
    const userAgent = req.headers.get('user-agent') || 'Unknown';
    const screenshot = formData.get('screenshot') as File | null;
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });

    if (!content || !feedbackType || !pageUrl) {
      return NextResponse.json({ success: false, error: 'Missing required fields' }, { status: 400 });
    }

    let screenshotUrl: string | undefined = undefined;

    if (screenshot) {
      // 拽 驻专砖转 砖 砖转 住 驻 住 注
      if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
          const errorMsg = "Server configuration error: Cloudinary environment variables are missing at the time of upload.";
          console.error(`CRITICAL: ${errorMsg}`);
          return NextResponse.json({ success: false, error: "砖转 转爪专 砖专转 注转 注转 转转." }, { status: 500 });
      }
        
      const bytes = await screenshot.arrayBuffer();
      const buffer = Buffer.from(bytes);

      const uploadResult = await new Promise<{ secure_url?: string; error?: any }>((resolve) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          { folder: 'feedback_screenshots', resource_type: 'image' },
          (error, result) => {
            if (error) resolve({ error });
            else if (result) resolve({ secure_url: result.secure_url });
            else resolve({ error: new Error('Cloudinary returned no result or error.') });
          }
        );
        uploadStream.end(buffer);
      });

      if (uploadResult.error) {
        console.error('Failed to upload screenshot to Cloudinary:', uploadResult.error);
      } else if (uploadResult.secure_url) {
        screenshotUrl = uploadResult.secure_url;
      }
    }

    const newFeedback = await prisma.feedback.create({
      data: {
        userId: token?.sub,
        content,
        feedbackType,
        pageUrl,
        userAgent,
        screenshotUrl,
      },
      include: { user: { select: { firstName: true, lastName: true, email: true } } }
    });

    try {
      const adminEmail = "jewish.matchpoint@gmail.com";
      const userIdentifier = newFeedback.user 
        ? `${newFeedback.user.firstName} ${newFeedback.user.lastName} (${newFeedback.user.email})`
        : `Anonymous User (IP: ${req.ip ?? 'N/A'})`;

      await emailService.sendEmail({
        to: adminEmail,
        subject: `New Feedback Received (${feedbackType}): ${userIdentifier}`,
        templateName: 'internal-feedback-notification',
        context: {
          feedbackType: feedbackType,
          userIdentifier: userIdentifier,
          content: content,
          pageUrl: pageUrl,
          screenshotUrl: screenshotUrl,
          feedbackId: newFeedback.id,
        }
      });
      console.log(`Feedback notification sent successfully to ${adminEmail}`);
    } catch (emailError) {
      console.error("Failed to send feedback notification email, but feedback was saved to DB. Error:", emailError);
    }

    return NextResponse.json({ success: true, message: 'Feedback submitted successfully' });

  } catch (error) {
    console.error('Fatal error in feedback submission process:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred";
    return NextResponse.json({ success: false, error: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker
# Generated on: 2025-09-25 18:12:13
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
# Generated on: 2025-09-19 14:46:50
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';
export const dynamic = 'force-dynamic';
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
export const dynamic = 'force-dynamic';

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const { id: candidateIdToUpdate } = params;

    const candidateExists = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true }
    });

    if (!candidateExists) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateExists.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const profileData = await req.json();

    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    numericFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        } else if (profileData[field] !== null) {
            profileData[field] = parseInt(profileData[field], 10);
            if (isNaN(profileData[field])) {
                console.warn(`Invalid number for ${field}: ${profileData[field]}, setting to null`);
                profileData[field] = null;
            }
        }
    });
    
    // --- START: 住驻转 砖转 拽爪注 专 专砖转 注 ---
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation'];
    // --- END: 住驻转 砖转 拽爪注 专 专砖转 注 ---
    stringAndEnumFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        }
    });

    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious', 'preferredHasChildrenFromPrevious', 'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible'];
    booleanFields.forEach(field => {
        if (profileData[field] === undefined) {
            profileData[field] = null;
        } else if (typeof profileData[field] !== 'boolean' && profileData[field] !== null) {
            if (profileData[field] === 'true') profileData[field] = true;
            else if (profileData[field] === 'false') profileData[field] = false;
            else profileData[field] = null;
        }
    });

    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    arrayFields.forEach(field => {
        if (profileData[field] === undefined || profileData[field] === null) {
            profileData[field] = [];
        } else if (!Array.isArray(profileData[field])) {
            console.warn(`Field ${field} is not an array, attempting to convert or defaulting to empty.`);
            if (typeof profileData[field] === 'string' && profileData[field].includes(',')) {
                profileData[field] = profileData[field].split(',').map((s: string) => s.trim());
            } else if (typeof profileData[field] === 'string' && profileData[field].trim() !== '') {
                 profileData[field] = [profileData[field].trim()];
            } else {
                profileData[field] = [];
            }
        }
    });
    
    const updatedProfile = await prisma.profile.update({
      where: { userId: candidateIdToUpdate },
      data: {
        ...profileData,
        updatedAt: new Date(),
        lastActive: new Date()
      }
    });

    updateUserAiProfile(candidateIdToUpdate).catch(err => {
        console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });
  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `砖: 专 砖 砖转 砖转 (   驻  专 驻专驻) 专 拽 注专转 注专 砖转砖 专. (${error.meta?.target})`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "驻专驻  注 拽砖 注  爪.";
            statusCode = 404;
        } else {
            errorMessage = `砖转 住 转 (拽 ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        errorMessage = `砖转 爪 注 驻专驻: ${error.message}`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const candidateIdToDelete = params.id;
  const timestamp = new Date().toISOString();
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 .  转 住砖 驻注  专砖.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 . 专砖转 专砖转 .' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: ' 注 (candidateId) 住专.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: '   拽 转 砖 砖 专 砖拽 . 砖转砖 专转 砖 砖转.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: '注 拽砖 拽  爪.' },
        { status: 404 }
      );
    }

    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '注 拽 爪.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: '注 拽砖 拽  爪 (砖转 Prisma).'},
                { status: 404 }
            );
        }
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 住 转 拽转 注 (拽: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 爪 拽转 注: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '砖  注 注转 拽转 注.';
    return NextResponse.json(
      {
        success: false,
        error: '专注 砖 拽转 注. 住 砖 专 转专.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

// 驻 驻砖 转爪
type UploadResult = {
  secure_url: string;
  public_id: string;
};

// Check for required environment variables
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Validate environment variables
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    // Convert to buffer
    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload using cloudinary.uploader.upload with string transformation
    //  注拽祝 转 注转 驻 专
  //  注 砖 注转, 砖转砖 :
    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        // 注拽祝 转 注转 驻 注 type assertion
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client"; //  砖-ADMIN 专  -enum 砖
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Check if required environment variables are set
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: cloudName as string,
  api_key: apiKey as string,
  api_secret: apiSecret as string,
});

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CORRECTED CODE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN]; // Explicitly type the array

    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CORRECTED CODE ----

    // Get params
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Find the image
    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    // Check if this is the main image and there are other images
    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      // If there are other images, set the most recent one as main
      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
        // Continue with DB deletion even if Cloudinary fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get params
    const { id, imageId } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Verify image exists and belongs to candidate
    const imageToSetMain = await prisma.userImage.findFirst({ // Renamed variable for clarity
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) { // Used the new variable name
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    // Start a transaction to update main image
    await prisma.$transaction([
      // First, unset all other images as main for this user
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId } // Don't unset the one we are about to set
        },
        data: { isMain: false }
      }),
      
      // Then, set the specified image as main
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * Handles a matchmaker's request to send an account setup invitation to a candidate.
 * This allows a manually-created user to set their own password and take control of their profile.
 */
export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  // 1. Apply Rate Limiting
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    // 2. Authenticate and authorize the matchmaker/admin
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 4. Validate request parameters and body
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "转转  转拽  砖 ." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 5. Fetch the candidate to invite
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    // 6. Create an account setup token using the Verification Service
    const expiresInHours = 72; // 3 days
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    // 7. Update candidate's email and invalidate old tokens in a transaction
    await prisma.$transaction(async (tx) => {
      // Only update the email if it's different from the current one.
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      // Invalidate any other pending setup tokens for this user
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id }, // Exclude the one we just created
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    // 8. Send the account setup email using the updated Email Service
    const expiresInText = locale === 'he' ? '3 ' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale, // <-- Pass the correct locale
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "砖/转 砖",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    // 9. Return success response
    return NextResponse.json({ success: true, message: " 专转 砖 砖 爪." });

  } catch (error) {
    // 10. Handle unexpected errors, including unique email constraint violations
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "转转   专 砖转 砖 专." },
          { status: 409 } // 409 Conflict
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "专注 砖 砖转 .", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: 住驻转 砖转 拽爪注 专 ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: 住驻转 砖转 拽爪注 专 ---

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "砖转砖 注 转转   专 拽 注专转." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
    };

    // --- START: 住驻转 砖转 砖 拽 爪专 ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: 住驻转 砖转 砖 拽 爪专 ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for candidates_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';
export const dynamic = 'force-dynamic';
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

export const dynamic = 'force-dynamic';

/**
 * GET: 专 驻专驻 砖 注 住驻爪驻.
 * 砖 砖 .
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

/**
 * PATCH: 注 驻专 驻专驻 砖 注.
 * 砖 砖 . 注 专拽 转 砖转 砖砖 拽砖.
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const { id: candidateIdToUpdate } = params;

    const candidateExists = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true }
    });

    if (!candidateExists) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateExists.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const incomingData = await req.json();
    const dataForUpdate: Prisma.ProfileUpdateInput = {};

    // 专转 住 砖转 爪专 驻  注专
    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation', 'manualEntryText', 'about', 'profileHeadline'];
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious', 'preferredHasChildrenFromPrevious', 'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible', 'birthDateIsApproximate'];
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    const dateFields = ['birthDate'];

    // 注专 注 砖转 砖转拽 拽砖 
    for (const key in incomingData) {
      if (Object.prototype.hasOwnProperty.call(incomingData, key)) {
        let value = incomingData[key];

        if (numericFields.includes(key)) {
            if (value === "" || value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else {
                const parsed = parseInt(String(value), 10);
                dataForUpdate[key] = isNaN(parsed) ? null : parsed;
            }
        } else if (stringAndEnumFields.includes(key)) {
            dataForUpdate[key] = (value === "" || value === undefined) ? null : value;
        } else if (booleanFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else if (typeof value === 'boolean') {
                dataForUpdate[key] = value;
            } else {
                dataForUpdate[key] = value === 'true';
            }
        } else if (arrayFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = [];
            } else if (Array.isArray(value)) {
                dataForUpdate[key] = value;
            }
        } else if (dateFields.includes(key)) {
            if (value) {
                const date = new Date(value);
                if (!isNaN(date.getTime())) {
                    dataForUpdate[key] = date;
                }
            } else {
                dataForUpdate[key] = null;
            }
        }
        else {
          // 注专  砖 专 砖 专砖转, 驻砖 注专 转 
          //  住 砖转  注专转 ' 砖 爪专 驻 
          if (incomingData[key] !== undefined) {
             dataForUpdate[key] = incomingData[key];
          }
        }
      }
    }
    
    // 爪注 转 注 专拽  砖 转 注
    if (Object.keys(dataForUpdate).length > 0) {
        const updatedProfile = await prisma.profile.update({
          where: { userId: candidateIdToUpdate },
          data: {
            ...dataForUpdate,
            updatedAt: new Date(),
            lastActive: new Date(),
            needsAiProfileUpdate: true,
          }
        });

        updateUserAiProfile(candidateIdToUpdate).catch(err => {
            console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
        });

        return NextResponse.json({
          success: true,
          profile: updatedProfile
        });
    }

    //   砖 转, 专 转 驻专驻 拽  砖
    const currentProfile = await prisma.profile.findUnique({ where: { userId: candidateIdToUpdate } });
    return NextResponse.json({ success: true, profile: currentProfile, message: "No data provided for update." });

  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `砖: 专 砖 砖转 砖转 (   驻  专 驻专驻) 专 拽 注专转 注专 砖转砖 专. (${error.meta?.target})`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "驻专驻  注 拽砖 注  爪.";
            statusCode = 404;
        } else {
            errorMessage = `砖转 住 转 (拽 ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        const relevantError = error.message.split('\n').pop() || error.message;
        errorMessage = `砖转 爪 注 驻专驻: ${relevantError}`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

/**
 * DELETE: 拽转 注.
 * 砖  .
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const candidateIdToDelete = params.id;
  const timestamp = new Date().toISOString();
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 .  转 住砖 驻注  专砖.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 . 专砖转 专砖转 .' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: ' 注 (candidateId) 住专.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: '   拽 转 砖 砖 专 砖拽 . 砖转砖 专转 砖 砖转.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: '注 拽砖 拽  爪.' },
        { status: 404 }
      );
    }

    // 驻注 'onDelete: Cascade' 住转 Prisma 转 拽转  转 拽砖专 (驻专驻, 转转 ')
    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '注 拽 爪.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: '注 拽砖 拽  爪 (砖转 Prisma).'},
                { status: 404 }
            );
        }
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 住 转 拽转 注 (拽: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 爪 拽转 注: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '砖  注 注转 拽转 注.';
    return NextResponse.json(
      {
        success: false,
        error: '专注 砖 拽转 注. 住 砖 专 转专.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

// 驻 驻砖 转爪
type UploadResult = {
  secure_url: string;
  public_id: string;
};

// Check for required environment variables
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Validate environment variables
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    // Convert to buffer
    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload using cloudinary.uploader.upload with string transformation
    //  注拽祝 转 注转 驻 专
  //  注 砖 注转, 砖转砖 :
    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        // 注拽祝 转 注转 驻 注 type assertion
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client"; //  砖-ADMIN 专  -enum 砖
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Check if required environment variables are set
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: cloudName as string,
  api_key: apiKey as string,
  api_secret: apiSecret as string,
});

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CORRECTED CODE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN]; // Explicitly type the array

    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CORRECTED CODE ----

    // Get params
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Find the image
    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    // Check if this is the main image and there are other images
    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      // If there are other images, set the most recent one as main
      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
        // Continue with DB deletion even if Cloudinary fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get params
    const { id, imageId } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Verify image exists and belongs to candidate
    const imageToSetMain = await prisma.userImage.findFirst({ // Renamed variable for clarity
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) { // Used the new variable name
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    // Start a transaction to update main image
    await prisma.$transaction([
      // First, unset all other images as main for this user
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId } // Don't unset the one we are about to set
        },
        data: { isMain: false }
      }),
      
      // Then, set the specified image as main
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * Handles a matchmaker's request to send an account setup invitation to a candidate.
 * This allows a manually-created user to set their own password and take control of their profile.
 */
export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  // 1. Apply Rate Limiting
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    // 2. Authenticate and authorize the matchmaker/admin
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 4. Validate request parameters and body
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "转转  转拽  砖 ." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 5. Fetch the candidate to invite
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    // 6. Create an account setup token using the Verification Service
    const expiresInHours = 72; // 3 days
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    // 7. Update candidate's email and invalidate old tokens in a transaction
    await prisma.$transaction(async (tx) => {
      // Only update the email if it's different from the current one.
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      // Invalidate any other pending setup tokens for this user
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id }, // Exclude the one we just created
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    // 8. Send the account setup email using the updated Email Service
    const expiresInText = locale === 'he' ? '3 ' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale, // <-- Pass the correct locale
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "砖/转 砖",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    // 9. Return success response
    return NextResponse.json({ success: true, message: " 专转 砖 砖 爪." });

  } catch (error) {
    // 10. Handle unexpected errors, including unique email constraint violations
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "转转   专 砖转 砖 专." },
          { status: 409 } // 409 Conflict
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "专注 砖 砖转 .", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: 住驻转 砖转 拽爪注 专 ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: 住驻转 砖转 拽爪注 专 ---

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "砖转砖 注 转转   专 拽 注专转." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
    };

    // --- START: 住驻转 砖转 砖 拽 爪专 ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: 住驻转 砖转 砖 拽 爪专 ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import prisma from "@/lib/prisma"; // Added prisma
import { UserRole } from "@prisma/client"; // Added UserRole
export const dynamic = 'force-dynamic';
export async function GET(
  req: Request, // req is not used, consider removing if not planned for future use
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    // ---- START OF CHANGE ----
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized - Not logged in" }, { status: 401 });
    }

    // Fetch user role for permission check
    const performingUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    // Additionally, a user involved in the inquiry should be able to see it.
    // This needs more context on how AvailabilityService.getInquiryById checks permissions.
    // For now, limiting to Matchmaker/Admin.
    // You might need to adjust this if users (CANDIDATE) should see their own inquiries via this route.
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
        // Before returning 403, check if the user is part of the inquiry if that's a requirement
        // For simplicity, the original request was about ADMIN access to MATCHMAKER functions.
        return NextResponse.json(
            { error: 'Unauthorized - Matchmaker or Admin access required to view this inquiry' },
            { status: 403 }
        );
    }
    // ---- END OF CHANGE ----

    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    // Potentially, AvailabilityService.getInquiryById already handles ownership/role checks.
    // If so, the above check might be redundant or could be simplified.
    // If 'inquiry' is null and no error was thrown, it means not found or no permission from service.
    if (!inquiry) {
        return NextResponse.json({ error: "Inquiry not found or access denied" }, { status: 404 });
    }
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    let message = "Failed to fetch inquiry";
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/respond/route.ts

import { type NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import { applyRateLimit } from "@/lib/rate-limiter";

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

// La definici贸n del tipo gen茅rico para los par谩metros de la ruta.
type RouteSegment<T> = (
  request: NextRequest,
  context: { params: T }
) => Promise<NextResponse> | NextResponse;

// El manejador de la solicitud.
const handler: RouteSegment<{ id: string }> = async (request, { params }) => {
  try {
    // 1. Aplicar un l铆mite de peticiones para prevenir el abuso.
    const rateLimitResponse = await applyRateLimit(request, { requests: 20, window: '1 h' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    // 2. Autenticar la sesi贸n del usuario.
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Extraer el 'locale' de los par谩metros de la URL.
    //    Esta es la correcci贸n principal para que coincida con la firma del servicio.
    const url = new URL(request.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Por defecto, se establece en hebreo.

    // 4. Extraer los datos del cuerpo de la solicitud.
    const { isAvailable, note } = await request.json();

    // Validar que 'isAvailable' sea un booleano.
    if (typeof isAvailable !== 'boolean') {
        return NextResponse.json({ success: false, error: "Bad Request: 'isAvailable' must be a boolean." }, { status: 400 });
    }

    // 5. Llamar al servicio de disponibilidad, AHORA con el par谩metro 'locale'.
    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note,
      locale: locale, // Se ha a帽adido el par谩metro 'locale' que faltaba.
    });

    // 6. Devolver una respuesta exitosa y consistente.
    return NextResponse.json({ success: true, inquiry: updatedInquiry });

  } catch (error) {
    // 7. Manejar cualquier error que ocurra.
    console.error("Error updating inquiry response:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Failed to update response";
    
    return NextResponse.json(
      { 
        success: false,
        error: errorMessage
      },
      { status: 500 }
    );
  }
};

// Exportar el manejador como el m茅todo POST.
export const POST = handler;
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { MatchSuggestionStatus, Prisma, UserRole } from '@prisma/client';
import { suggestionService } from '@/components/matchmaker/suggestions/services/suggestions/SuggestionService';
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import type { CreateSuggestionData } from '@/types/suggestions';
// ========================= 砖 专 1:  驻住  =========================
import type { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';
export const dynamic = 'force-dynamic';



/**
 * 砖 转 拽专 砖 爪注 转住住 注 住住 砖.
 */
const getSuggestionCategory = (status: MatchSuggestionStatus) => {
  switch (status) {
    case 'DRAFT':
    case 'AWAITING_MATCHMAKER_APPROVAL':
    case 'PENDING_FIRST_PARTY':
    case 'PENDING_SECOND_PARTY':
      return 'PENDING';

    case 'FIRST_PARTY_DECLINED':
    case 'SECOND_PARTY_DECLINED':
    case 'MATCH_DECLINED':
    case 'ENDED_AFTER_FIRST_DATE':
    case 'ENGAGED':
    case 'MARRIED':
    case 'EXPIRED':
    case 'CLOSED':
    case 'CANCELLED':
      return 'HISTORY';

    default:
      return 'ACTIVE';
  }
};

/**
 * POST: 爪专 爪注转 砖 砖.
 */
export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const allowedRolesToCreate: UserRole[] = [
      UserRole.MATCHMAKER,
      UserRole.ADMIN,
    ];
    if (!allowedRolesToCreate.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        {
          error:
            'Unauthorized - Matchmaker or Admin access required to create suggestions',
        },
        { status: 403 }
      );
    }

    const data = await req.json();

    if (!data.firstPartyId || !data.secondPartyId || !data.decisionDeadline) {
      return NextResponse.json(
        { error: 'Invalid input: Missing required fields.' },
        { status: 400 }
      );
    }
    
    // ========================= 砖 专 3: 注转 转专 =========================
    const url = new URL(req.url);
const rawLocale = url.searchParams.get('locale');
const locale: 'he' | 'en' = (rawLocale === 'en' || rawLocale === 'he') ? rawLocale : 'he';    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email; // 抓 拽 砖 

    if (!emailDict) {
        // 拽专 专 砖  注 专
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    // 拽 注 驻专驻 AI
    try {
      const [firstParty, secondParty] = await Promise.all([
        prisma.user.findUnique({
          where: { id: data.firstPartyId },
          include: { profile: true },
        }),
        prisma.user.findUnique({
          where: { id: data.secondPartyId },
          include: { profile: true },
        }),
      ]);

      if (!firstParty || !secondParty) {
        return NextResponse.json(
          { error: 'One or both candidates not found.' },
          { status: 404 }
        );
      }

      const profilesToUpdate: { userId: string; profileId: string }[] = [];
      if (firstParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: firstParty.id,
          profileId: firstParty.profile.id,
        });
      }
      if (secondParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: secondParty.id,
          profileId: secondParty.profile.id,
        });
      }

      if (profilesToUpdate.length > 0) {
        console.log(
          `[AI Update Trigger] Updating AI profiles for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')} before creating suggestion.`
        );
        await Promise.all(
          profilesToUpdate.map((p) => updateUserAiProfile(p.userId))
        );
        await prisma.profile.updateMany({
          where: { id: { in: profilesToUpdate.map((p) => p.profileId) } },
          data: { needsAiProfileUpdate: false },
        });
        console.log(
          `[AI Update Trigger] Flags reset for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')}.`
        );
      }
    } catch (aiUpdateError) {
      console.error('Failed during pre-suggestion AI profile update:', aiUpdateError);
      return NextResponse.json(
        { error: 'Failed to update AI profiles for candidates. Please try again.' },
        { status: 500 }
      );
    }

    // 爪专转 爪注 注专转  砖专转
    const suggestionData: CreateSuggestionData = {
      ...data,
      matchmakerId: session.user.id,
    };
    
    // ========================= 砖 专 4: 注专转  砖专转 =========================
    const newSuggestion = await suggestionService.createSuggestion(suggestionData, emailDict);

    return NextResponse.json(newSuggestion, { status: 201 });
  } catch (error) {
    console.error('Error creating suggestion:', error);
    let message = 'Failed to create suggestion';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/**
 * GET: 专 专砖 砖 爪注转 砖.
 */
export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(req.url);
    const status = searchParams.get('status');
    const priority = searchParams.get('priority');
    const timeframe = searchParams.get('timeframe');

    const where: Prisma.MatchSuggestionWhereInput = {};

    if (session.user.role === UserRole.MATCHMAKER) {
      where.matchmakerId = session.user.id;
    } else if (session.user.role === UserRole.CANDIDATE) {
      where.OR = [
        { firstPartyId: session.user.id },
        { secondPartyId: session.user.id },
      ];
    }

    if (status) where.status = status as MatchSuggestionStatus;
    if (priority)
      where.priority =
        priority as Prisma.EnumPriorityFieldUpdateOperationsInput['set'];

    if (timeframe) {
      const date = new Date();
      switch (timeframe) {
        case 'today':
          date.setHours(0, 0, 0, 0);
          where.createdAt = { gte: date };
          break;
        case 'week':
          date.setDate(date.getDate() - 7);
          where.createdAt = { gte: date };
          break;
        case 'month':
          date.setMonth(date.getMonth() - 1);
          where.createdAt = { gte: date };
          break;
      }
    }

    const suggestions = await prisma.matchSuggestion.findMany({
      where,
      include: {
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true, role: true },
        },
        statusHistory: { orderBy: { createdAt: 'desc' } },
        meetings: { orderBy: { createdAt: 'desc' } },
        inquiries: {
          include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
          },
          orderBy: { createdAt: 'asc' },
        },
      },
      orderBy: { lastActivity: 'desc' },
    });

    const formattedSuggestions = suggestions.map((suggestion) => ({
      ...suggestion,
      category: getSuggestionCategory(suggestion.status),
      // Formatting logic remains the same...
    }));

    console.log(
      `[API GET /suggestions] User: ${session.user.id} (Role: ${
        session.user.role
      }). Found ${suggestions.length} suggestions matching query.`
    );

    return NextResponse.json(formattedSuggestions);
  } catch (error) {
    console.error('Error fetching suggestions:', error);
    let message = 'Failed to fetch suggestions';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { SuggestionService } from "@/components/matchmaker/suggestions/services/suggestions/SuggestionService";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    //  砖转砖 专
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    //  专砖转 砖
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const suggestionId = params.id;
    const data = await req.json();
    
    const suggestionService = SuggestionService.getInstance();
    
    try {
      // 砖砖 砖专转 注 爪注
      const updatedSuggestion = await suggestionService.updateSuggestion(
        suggestionId,
        session.user.id,
        {
          id: suggestionId,
          priority: data.priority,
          notes: {
            internal: data.internalNotes,
            forFirstParty: data.firstPartyNotes,
            forSecondParty: data.secondPartyNotes,
            matchingReason: data.matchingReason,
            followUpNotes: data.followUpNotes
          },
          decisionDeadline: data.decisionDeadline ? new Date(data.decisionDeadline) : undefined,
          responseDeadline: data.responseDeadline ? new Date(data.responseDeadline) : undefined
        }
      );
      
      return NextResponse.json({
        success: true,
        data: updatedSuggestion
      });
      
    } catch (serviceError: unknown) {
        console.error("Error from suggestion service:", serviceError);
        
        if (serviceError instanceof Error) {
          return NextResponse.json(
            { success: false, error: serviceError.message || "Failed to update suggestion" },
            { status: serviceError.message.includes("Unauthorized") ? 403 : 400 }
          );
        }
        
        // 拽专 砖 砖 砖 住 Error
        return NextResponse.json(
          { success: false, error: "Failed to update suggestion" },
          { status: 400 }
        );
      }
  } catch (error) {
    console.error("Error updating suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    //  砖砖转砖 专
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    //  专砖转 砖  
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;

    //  拽 爪注
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 拽转 专砖转 住驻爪驻转 - 专拽 砖 砖爪专 转 爪注    拽
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to delete this suggestion" },
        { status: 403 }
      );
    }

    // 拽转 专 拽砖专 驻专 拽 专拽爪
    // 1. 拽转 专砖转 住专
    await prisma.suggestionStatusHistory.deleteMany({
      where: { suggestionId }
    });

    // 2. 拽转 砖 驻砖转  拽
    await prisma.dateFeedback.deleteMany({
      where: { suggestionId }
    });

    // 3. 拽转 驻砖转 拽砖专转 ( 砖)
    await prisma.meeting.deleteMany({
      where: { suggestionId }
    });

    // 4. 拽转 砖转/驻转  拽转
    await prisma.suggestionInquiry.deleteMany({
      where: { suggestionId }
    });

    // 5. 住专转 拽砖专 转 拽砖专 专-专 ( 砖)
    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        approvedBy: {
          set: []
        },
        reviewedBy: {
          set: []
        }
      }
    });

    // 6. 拽转 爪注 注爪
    await prisma.matchSuggestion.delete({
      where: { id: suggestionId }
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully"
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    
    // 专转 驻专 砖  拽
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete suggestion", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/message/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';
import { notificationService } from '@/components/matchmaker/suggestions/services/notification/NotificationService';
import { initNotificationService } from '@/components/matchmaker/suggestions/services/notification/initNotifications';
import { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';

// 驻注 砖 砖专转 转专转
initNotificationService();

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const suggestionId = params.id;

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: 'Unauthorized - Invalid session' }, { status: 401 });
    }

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: 'Unauthorized - Matchmaker or Admin access required' }, { status: 403 });
    }

    // ========================= 砖 1: 注转  =========================
    // 拽专 转 砖驻 -URL, 拽  砖注砖 -API 砖 爪专转 爪注.
    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /message] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email; // 抓 拽 砖 

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }
    // =====================================================================

    const body = await req.json();
    const { partyType, customMessage, channels } = body;

    if (!partyType || !customMessage || !channels) {
      return NextResponse.json({ error: 'Invalid input: Missing required fields.' }, { status: 400 });
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: 'Suggestion not found' }, { status: 404 });
    }

    // ========================= 砖 2: 拽专  砖专转 =========================
    // 注转  注专 转  砖砖转 专 专砖 住专 :
    // 1. suggestion (拽 爪注)
    // 2. emailDict (拽 )
    // 3. options (拽 专转)
    await notificationService.handleSuggestionStatusChange(
      suggestion, 
      emailDict, // 专 砖  
      {         // 专 砖砖  拽 专转
        channels: channels,
        notifyParties: [partyType],
        customMessage: customMessage
      }
    );
    // ==========================================================================

    return NextResponse.json({ success: true, message: 'Message sent successfully.' }, { status: 200 });

  } catch (error) {
    console.error('Error sending message for suggestion:', error);
    const message = (error instanceof Error) ? error.message : 'Failed to send message';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/remind/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { initNotificationService } from "@/components/matchmaker/suggestions/services/notification/initNotifications";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

// 驻注转 砖专转 转专转
const notificationService = initNotificationService();

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /remind] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict || !emailDict.notifications?.customMessage?.reminderText) {
        throw new Error(`Email dictionary for locale '${locale}' is missing required notification templates.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to send reminders for this suggestion" }, { status: 403 });
    }
    
    const notifyParties: ('first' | 'second')[] = [];
    if ((partyType === "first" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_FIRST_PARTY) {
      notifyParties.push('first');
    }
    if ((partyType === "second" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_SECOND_PARTY) {
      notifyParties.push('second');
    }
    
    if (notifyParties.length === 0) {
      return NextResponse.json({ success: false, error: "No applicable recipients for reminder in current status" }, { status: 400 });
    }

    // ============================ 转拽 专  ============================
    // 1. 拽 转 转转 拽住 砖专转 -reminderText.
    const reminderTemplateText = emailDict.notifications.customMessage.reminderText;
    
    // 2. 爪注 转 驻 专砖转 砖 砖 砖.
    const reminderContent = reminderTemplateText
        .replace('{{matchmakerName}}', `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`);
    // =========================================================================

    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: { lastActivity: new Date() },
    });

    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId,
        status: suggestion.status,
        notes: `转专转 砖 ${partyType === "first" ? "爪 专砖" : partyType === "second" ? "爪 砖" : "砖 爪"} 注  ${session.user.firstName} ${session.user.lastName}`,
      },
    });
    
    await notificationService.handleSuggestionStatusChange(
      suggestion,
      emailDict,
      {
        channels: ['email', 'whatsapp'],
        notifyParties,
        customMessage: reminderContent
      }
    );
    
    return NextResponse.json({
      success: true,
      message: "Reminder sent successfully",
      recipientCount: notifyParties.length
    });
  } catch (error) {
    console.error("Error sending reminder:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send reminder" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/resend/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
// ========================= 砖 1:  驻住  专砖 =========================
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";
// =====================================================================================

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    // ========================= 砖 2: 注转  -URL =========================
    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /resend] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }
    // ============================================================================

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to resend this suggestion" }, { status: 403 });
    }

    let updatedSuggestion = suggestion;
    const transitionNotes = `爪注 砖 砖 注" ${session.user.firstName} ${session.user.lastName}`;
    
    if (partyType === "both" || partyType === "first") {
      // ========================= 砖 3: 拽专  砖专转 =========================
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_FIRST_PARTY,
        emailDict, // <-- 专 3: 
        `${transitionNotes} - 爪 专砖`, // <-- 专 4: 注专转
        { // <-- 专 5: 专转
          sendNotifications: true,
          notifyParties: ['first']
        }
      );
      // ===========================================================================
      
      if (partyType === "first") {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            firstPartySent: new Date(),
            lastActivity: new Date()
          }
        });
      }
    }
    
    if (partyType === "both" || partyType === "second") {
      // ========================= 砖 3: 拽专  砖专转 (砖) =========================
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        emailDict, // <-- 专 3: 
        `${transitionNotes} - 爪 砖`, // <-- 专 4: 注专转
        { // <-- 专 5: 专转
          sendNotifications: true,
          notifyParties: ['second']
        }
      );
      // ===========================================================================
      
      await prisma.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          secondPartySent: new Date(),
          lastActivity: new Date()
        }
      });
    }

    return NextResponse.json({
      success: true,
      message: `Suggestion successfully resent to ${partyType === "first" ? "first party" : partyType === "second" ? "second party" : "both parties"}`,
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error resending suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to resend suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/share-contact/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
// ========================= 砖 1:  驻住  专砖 =========================
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";
// =====================================================================================

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const suggestionId = params.id;

    // ========================= 砖 2: 注转  -URL =========================
    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /share-contact] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }
    // ============================================================================

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to share contact details for this suggestion" }, { status: 403 });
    }
    
    // 拽 砖住住 驻砖专 砖转祝 驻专. 拽  转拽.
    if (suggestion.status !== MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      return NextResponse.json({
        success: false,
        error: "Cannot share contacts until both parties have approved the suggestion."
      }, { status: 400 });
    }
    
    // ========================= 砖 3: 拽专  砖专转 =========================
    // 注专 转  专 砖砖, 转 注专转 专 专注.
    const updatedSuggestion = await statusTransitionService.transitionStatus(
      suggestion,
      MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
      emailDict, // <-- 专 3: 
      `驻专 拽砖专 砖转驻  ${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} ${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} 注" ${session.user.firstName} ${session.user.lastName}`, // <-- 专 4: 注专转
      { // <-- 专 5: 专转
        sendNotifications: true,
        notifyParties: ['first', 'second', 'matchmaker']
      }
    );
    // ==========================================================================

    return NextResponse.json({
      success: true,
      message: "Contact details shared successfully",
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error sharing contact details:", error);
    return NextResponse.json(
      { success: false, error: "Failed to share contact details" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { z } from "zod";

// Schema for validating status update data
const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

/**
 * PATCH endpoint for updating suggestion status
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. Verify permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    // 3. Validate request data
    const body = await req.json();
    console.log("Received status update request:", body);
    
    const validationResult = updateStatusSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error:", validationResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid request data", 
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }
    
    const { status, notes } = validationResult.data;

    // 4. Verify suggestion exists
    const suggestionId = params.id;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 5. Verify permission on specific suggestion
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to update this suggestion" },
        { status: 403 }
      );
    }

    // 6. Calculate category based on new status
    const getCategory = (status: MatchSuggestionStatus) => {
      switch (status) {
        case "DRAFT":
        case "AWAITING_MATCHMAKER_APPROVAL":
        case "PENDING_FIRST_PARTY":
        case "PENDING_SECOND_PARTY":
          return "PENDING";
        
        case "FIRST_PARTY_DECLINED":
        case "SECOND_PARTY_DECLINED":
        case "MATCH_DECLINED":
        case "ENDED_AFTER_FIRST_DATE":
        case "ENGAGED":
        case "MARRIED":
        case "EXPIRED":
        case "CLOSED":
        case "CANCELLED":
          return "HISTORY";
        
        default:
          return "ACTIVE";
      }
    };

    // 7. Update status in a transaction
    const result = await prisma.$transaction(async (tx) => {
      // Save previous status
      const previousStatus = suggestion.status;

      // Update the suggestion
      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status,
          previousStatus: previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          category: getCategory(status),
          
          // Update additional fields based on new status
          ...(status === MatchSuggestionStatus.CLOSED ? { closedAt: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_FIRST_PARTY ? { firstPartySent: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY ? { secondPartySent: new Date() } : {}),
        },
      });

      // Add status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes: notes || `住住 砖 -${status} 注  ${session.user.firstName} ${session.user.lastName}`,
        },
      });

      return updatedSuggestion;
    });

    // 8. Return success response
    return NextResponse.json({
      success: true,
      message: "Status updated successfully",
      suggestion: {
        id: result.id,
        status: result.status,
        previousStatus: result.previousStatus,
        lastStatusChange: result.lastStatusChange,
        category: result.category,
      },
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    // Return detailed error message if available
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to update status", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint for fetching suggestion history
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse URL parameters
    const searchParams = new URL(req.url).searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 50;

    // 3. Check viewing permissions
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        matchmakerId: true,
        firstPartyId: true,
        secondPartyId: true,
      }
    });
    
    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    
    // Check if user has permission to view this suggestion
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return NextResponse.json({ error: "Not authorized to view this suggestion" }, { status: 403 });
    }
    
    // 4. Build history query
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(startDate && {
          createdAt: {
            gte: new Date(startDate),
            ...(endDate && {
              lte: new Date(endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            secondParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            matchmaker: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc" as const,
      },
      take: limit,
    };

    // 5. Fetch status change history
    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    // 6. Format results
    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { error: "Failed to fetch history", details: errorMessage },
      { status: 500 }
    );
  }
}

/**
 * HEAD endpoint for getting status summary
 */
export async function HEAD(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new Response(null, { status: 401 });
    }

    // 2. Fetch suggestion details
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      }
    });

    if (!suggestion) {
      return new Response(null, { status: 404 });
    }

    // 3. Check viewing permissions
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return new Response(null, { status: 403 });
    }

    // 4. Prepare headers
    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    // Add lastStatusChange header only if it exists
    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
# Generated on: 2025-09-19 14:46:50
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';
export const dynamic = 'force-dynamic';
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
export const dynamic = 'force-dynamic';

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const { id: candidateIdToUpdate } = params;

    const candidateExists = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true }
    });

    if (!candidateExists) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateExists.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const profileData = await req.json();

    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    numericFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        } else if (profileData[field] !== null) {
            profileData[field] = parseInt(profileData[field], 10);
            if (isNaN(profileData[field])) {
                console.warn(`Invalid number for ${field}: ${profileData[field]}, setting to null`);
                profileData[field] = null;
            }
        }
    });
    
    // --- START: 住驻转 砖转 拽爪注 专 专砖转 注 ---
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation'];
    // --- END: 住驻转 砖转 拽爪注 专 专砖转 注 ---
    stringAndEnumFields.forEach(field => {
        if (profileData[field] === "" || profileData[field] === undefined) {
            profileData[field] = null;
        }
    });

    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious', 'preferredHasChildrenFromPrevious', 'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible'];
    booleanFields.forEach(field => {
        if (profileData[field] === undefined) {
            profileData[field] = null;
        } else if (typeof profileData[field] !== 'boolean' && profileData[field] !== null) {
            if (profileData[field] === 'true') profileData[field] = true;
            else if (profileData[field] === 'false') profileData[field] = false;
            else profileData[field] = null;
        }
    });

    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    arrayFields.forEach(field => {
        if (profileData[field] === undefined || profileData[field] === null) {
            profileData[field] = [];
        } else if (!Array.isArray(profileData[field])) {
            console.warn(`Field ${field} is not an array, attempting to convert or defaulting to empty.`);
            if (typeof profileData[field] === 'string' && profileData[field].includes(',')) {
                profileData[field] = profileData[field].split(',').map((s: string) => s.trim());
            } else if (typeof profileData[field] === 'string' && profileData[field].trim() !== '') {
                 profileData[field] = [profileData[field].trim()];
            } else {
                profileData[field] = [];
            }
        }
    });
    
    const updatedProfile = await prisma.profile.update({
      where: { userId: candidateIdToUpdate },
      data: {
        ...profileData,
        updatedAt: new Date(),
        lastActive: new Date()
      }
    });

    updateUserAiProfile(candidateIdToUpdate).catch(err => {
        console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });
  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `砖: 专 砖 砖转 砖转 (   驻  专 驻专驻) 专 拽 注专转 注专 砖转砖 专. (${error.meta?.target})`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "驻专驻  注 拽砖 注  爪.";
            statusCode = 404;
        } else {
            errorMessage = `砖转 住 转 (拽 ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        errorMessage = `砖转 爪 注 驻专驻: ${error.message}`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const candidateIdToDelete = params.id;
  const timestamp = new Date().toISOString();
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 .  转 住砖 驻注  专砖.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 . 专砖转 专砖转 .' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: ' 注 (candidateId) 住专.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: '   拽 转 砖 砖 专 砖拽 . 砖转砖 专转 砖 砖转.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: '注 拽砖 拽  爪.' },
        { status: 404 }
      );
    }

    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '注 拽 爪.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: '注 拽砖 拽  爪 (砖转 Prisma).'},
                { status: 404 }
            );
        }
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 住 转 拽转 注 (拽: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 爪 拽转 注: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '砖  注 注转 拽转 注.';
    return NextResponse.json(
      {
        success: false,
        error: '专注 砖 拽转 注. 住 砖 专 转专.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

// 驻 驻砖 转爪
type UploadResult = {
  secure_url: string;
  public_id: string;
};

// Check for required environment variables
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Validate environment variables
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    // Convert to buffer
    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload using cloudinary.uploader.upload with string transformation
    //  注拽祝 转 注转 驻 专
  //  注 砖 注转, 砖转砖 :
    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        // 注拽祝 转 注转 驻 注 type assertion
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client"; //  砖-ADMIN 专  -enum 砖
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Check if required environment variables are set
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: cloudName as string,
  api_key: apiKey as string,
  api_secret: apiSecret as string,
});

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CORRECTED CODE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN]; // Explicitly type the array

    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CORRECTED CODE ----

    // Get params
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Find the image
    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    // Check if this is the main image and there are other images
    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      // If there are other images, set the most recent one as main
      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
        // Continue with DB deletion even if Cloudinary fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get params
    const { id, imageId } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Verify image exists and belongs to candidate
    const imageToSetMain = await prisma.userImage.findFirst({ // Renamed variable for clarity
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) { // Used the new variable name
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    // Start a transaction to update main image
    await prisma.$transaction([
      // First, unset all other images as main for this user
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId } // Don't unset the one we are about to set
        },
        data: { isMain: false }
      }),
      
      // Then, set the specified image as main
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * Handles a matchmaker's request to send an account setup invitation to a candidate.
 * This allows a manually-created user to set their own password and take control of their profile.
 */
export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  // 1. Apply Rate Limiting
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    // 2. Authenticate and authorize the matchmaker/admin
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 4. Validate request parameters and body
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "转转  转拽  砖 ." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 5. Fetch the candidate to invite
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    // 6. Create an account setup token using the Verification Service
    const expiresInHours = 72; // 3 days
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    // 7. Update candidate's email and invalidate old tokens in a transaction
    await prisma.$transaction(async (tx) => {
      // Only update the email if it's different from the current one.
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      // Invalidate any other pending setup tokens for this user
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id }, // Exclude the one we just created
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    // 8. Send the account setup email using the updated Email Service
    const expiresInText = locale === 'he' ? '3 ' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale, // <-- Pass the correct locale
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "砖/转 砖",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    // 9. Return success response
    return NextResponse.json({ success: true, message: " 专转 砖 砖 爪." });

  } catch (error) {
    // 10. Handle unexpected errors, including unique email constraint violations
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "转转   专 砖转 砖 专." },
          { status: 409 } // 409 Conflict
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "专注 砖 砖转 .", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: 住驻转 砖转 拽爪注 专 ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: 住驻转 砖转 拽爪注 专 ---

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "砖转砖 注 转转   专 拽 注专转." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
    };

    // --- START: 住驻转 砖转 砖 拽 爪专 ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: 住驻转 砖转 砖 拽 爪专 ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for candidates_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';
export const dynamic = 'force-dynamic';
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { Locale } from "../../../../../../i18n-config";
import { emailService } from "@/lib/email/emailService";

export const dynamic = 'force-dynamic';

/**
 * GET: 专 驻专驻 砖 注 住驻爪驻.
 * 砖 砖 .
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

/**
 * PATCH: 注 驻专 驻专驻 砖 注.
 * 砖 砖 . 注 专拽 转 砖转 砖砖 拽砖.
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    // 拽转 砖驻 (locale) 驻专专 -URL 爪专 砖转  转专
    const url = new URL(req.url);
    const locale = (url.searchParams.get('locale') as Locale) || 'he';

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
select: { role: true, firstName: true, lastName: true } // 砖祝 转 砖 驻专 砖 砖驻
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const { id: candidateIdToUpdate } = params;

    const candidateToUpdate = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true, email: true, firstName: true } // 砖祝 驻专 专砖 
    });

    if (!candidateToUpdate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateToUpdate.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const incomingData = await req.json();

    // 砖 拽: 砖祝 转 驻专驻 拽专  砖 砖转 转 '专 注专转'
    const originalProfile = await prisma.profile.findUnique({
        where: { userId: candidateIdToUpdate },
        select: { manualEntryText: true }
    });
    
    const dataForUpdate: Prisma.ProfileUpdateInput = {};

    // 专转 住 砖转 爪专 驻  注专
    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation', 'manualEntryText', 'about', 'profileHeadline'];
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious',  'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible', 'birthDateIsApproximate'];
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    const dateFields = ['birthDate'];

    // 注专 注  砖转 砖转拽 拽砖
    for (const key in incomingData) {
      if (Object.prototype.hasOwnProperty.call(incomingData, key)) {
        let value = incomingData[key];

        if (numericFields.includes(key)) {
            if (value === "" || value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else {
                const parsed = parseInt(String(value), 10);
                dataForUpdate[key] = isNaN(parsed) ? null : parsed;
            }
        } else if (stringAndEnumFields.includes(key)) {
            dataForUpdate[key] = (value === "" || value === undefined) ? null : value;
        } else if (booleanFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else if (typeof value === 'boolean') {
                dataForUpdate[key] = value;
            } else {
                dataForUpdate[key] = value === 'true';
            }
        } else if (arrayFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = [];
            } else if (Array.isArray(value)) {
                dataForUpdate[key] = value;
            }
        } else if (dateFields.includes(key)) {
            if (value) {
                const date = new Date(value);
                if (!isNaN(date.getTime())) {
                    dataForUpdate[key] = date;
                }
            } else {
                dataForUpdate[key] = null;
            }
        }
      }
    }
    
    // 爪注 转 注 专拽  砖 转 注
    if (Object.keys(dataForUpdate).length > 0) {
        const updatedProfile = await prisma.profile.update({
          where: { userId: candidateIdToUpdate },
          data: {
            ...dataForUpdate,
            updatedAt: new Date(),
            lastActive: new Date(),
            needsAiProfileUpdate: true, // 住 转 注 AI 专 砖 
          }
        });

        // --- 拽转 砖转  ---
        const newSummaryText = incomingData.manualEntryText;
        const oldSummaryText = originalProfile?.manualEntryText;

        // 砖  专拽  砖 'manualEntryText' 砖 拽砖转 注,
        //   专拽, 转 砖 砖转 注专 拽.
        if (newSummaryText !== undefined && newSummaryText.trim() !== '' && newSummaryText !== oldSummaryText) {
            try {
                await emailService.sendProfileSummaryUpdateEmail({
                    locale,
                    email: candidateToUpdate.email,
                    firstName: candidateToUpdate.firstName,
                    matchmakerName: session.user.name || "砖/转 砖"
                });
                console.log(`[Email Notification] Profile summary update email sent successfully to ${candidateToUpdate.email}.`);
            } catch (emailError) {
                // 砖:  砖 转  拽砖  砖转  砖.
                // 转注 转 砖 砖 专 转拽 砖 注 驻专驻.
                console.error(`[Email Notification] Failed to send profile summary update email to ${candidateToUpdate.email}:`, emailError);
            }
        }
        // --- 住祝 拽转 砖转  ---

        // 驻注转 注 驻专驻 AI 专拽注
        updateUserAiProfile(candidateIdToUpdate).catch(err => {
            console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
        });

        return NextResponse.json({
          success: true,
          profile: updatedProfile
        });
    }

    //   砖 转 专 注, 专 转 驻专驻 拽  砖
    const currentProfile = await prisma.profile.findUnique({ where: { userId: candidateIdToUpdate } });
    return NextResponse.json({ success: true, profile: currentProfile, message: "No data provided for update." });

  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `砖: 专 砖 砖转 砖转 (   驻  专 驻专驻) 专 拽 注专转 注专 砖转砖 专. (${error.meta?.target})`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "驻专驻  注 拽砖 注  爪.";
            statusCode = 404;
        } else {
            errorMessage = `砖转 住 转 (拽 ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        const relevantError = error.message.split('\n').pop() || error.message;
        errorMessage = `砖转 爪 注 驻专驻: ${relevantError}`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}


/**
 * DELETE: 拽转 注.
 * 砖  .
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const candidateIdToDelete = params.id;
  const timestamp = new Date().toISOString();
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 .  转 住砖 驻注  专砖.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: ' 专砖 爪注 驻注 . 专砖转 专砖转 .' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: ' 注 (candidateId) 住专.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: '   拽 转 砖 砖 专 砖拽 . 砖转砖 专转 砖 砖转.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: '注 拽砖 拽  爪.' },
        { status: 404 }
      );
    }

    // 驻注 'onDelete: Cascade' 住转 Prisma 转 拽转  转 拽砖专 (驻专驻, 转转 ')
    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '注 拽 爪.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: '注 拽砖 拽  爪 (砖转 Prisma).'},
                { status: 404 }
            );
        }
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 住 转 拽转 注 (拽: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `砖转 爪 拽转 注: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '砖  注 注转 拽转 注.';
    return NextResponse.json(
      {
        success: false,
        error: '专注 砖 拽转 注. 住 砖 专 转专.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

// 驻 驻砖 转爪
type UploadResult = {
  secure_url: string;
  public_id: string;
};

// Check for required environment variables
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Validate environment variables
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    // Convert to buffer
    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload using cloudinary.uploader.upload with string transformation
    //  注拽祝 转 注转 驻 专
  //  注 砖 注转, 砖转砖 :
    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        // 注拽祝 转 注转 驻 注 type assertion
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client"; //  砖-ADMIN 专  -enum 砖
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

// Check if required environment variables are set
if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: cloudName as string,
  api_key: apiKey as string,
  api_secret: apiSecret as string,
});

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CORRECTED CODE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN]; // Explicitly type the array

    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CORRECTED CODE ----

    // Get params
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Find the image
    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    // Check if this is the main image and there are other images
    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      // If there are other images, set the most recent one as main
      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    // Delete from Cloudinary
    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
        // Continue with DB deletion even if Cloudinary fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId }
    });

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string; imageId: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Verify that the user is a matchmaker OR an admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    // ---- START OF CHANGE ----
    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    // ---- END OF CHANGE ----

    // Get params
    const { id, imageId } = params;

    // Verify candidate exists
    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    // Verify image exists and belongs to candidate
    const imageToSetMain = await prisma.userImage.findFirst({ // Renamed variable for clarity
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) { // Used the new variable name
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    // Start a transaction to update main image
    await prisma.$transaction([
      // First, unset all other images as main for this user
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId } // Don't unset the one we are about to set
        },
        data: { isMain: false }
      }),
      
      // Then, set the specified image as main
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    // Update lastActive timestamp
    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
/**
 * Handles a matchmaker's request to send an account setup invitation to a candidate.
 * This allows a manually-created user to set their own password and take control of their profile.
 */
export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  // 1. Apply Rate Limiting
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    // 2. Authenticate and authorize the matchmaker/admin
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 4. Validate request parameters and body
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "转转  转拽  砖 ." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 5. Fetch the candidate to invite
    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    // 6. Create an account setup token using the Verification Service
    const expiresInHours = 72; // 3 days
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    // 7. Update candidate's email and invalidate old tokens in a transaction
    await prisma.$transaction(async (tx) => {
      // Only update the email if it's different from the current one.
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      // Invalidate any other pending setup tokens for this user
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id }, // Exclude the one we just created
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    // 8. Send the account setup email using the updated Email Service
    const expiresInText = locale === 'he' ? '3 ' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale, // <-- Pass the correct locale
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "砖/转 砖",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    // 9. Return success response
    return NextResponse.json({ success: true, message: " 专转 砖 砖 爪." });

  } catch (error) {
    // 10. Handle unexpected errors, including unique email constraint violations
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "转转   专 砖转 砖 专." },
          { status: 409 } // 409 Conflict
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "专注 砖 砖转 .", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: 住驻转 砖转 拽爪注 专 ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: 住驻转 砖转 拽爪注 专 ---

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "砖转砖 注 转转   专 拽 注专转." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
    };

    // --- START: 住驻转 砖转 砖 拽 爪专 ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: 住驻转 砖转 砖 拽 爪专 ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import prisma from "@/lib/prisma"; // Added prisma
import { UserRole } from "@prisma/client"; // Added UserRole
export const dynamic = 'force-dynamic';
export async function GET(
  req: Request, // req is not used, consider removing if not planned for future use
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    // ---- START OF CHANGE ----
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized - Not logged in" }, { status: 401 });
    }

    // Fetch user role for permission check
    const performingUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    // Additionally, a user involved in the inquiry should be able to see it.
    // This needs more context on how AvailabilityService.getInquiryById checks permissions.
    // For now, limiting to Matchmaker/Admin.
    // You might need to adjust this if users (CANDIDATE) should see their own inquiries via this route.
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
        // Before returning 403, check if the user is part of the inquiry if that's a requirement
        // For simplicity, the original request was about ADMIN access to MATCHMAKER functions.
        return NextResponse.json(
            { error: 'Unauthorized - Matchmaker or Admin access required to view this inquiry' },
            { status: 403 }
        );
    }
    // ---- END OF CHANGE ----

    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    // Potentially, AvailabilityService.getInquiryById already handles ownership/role checks.
    // If so, the above check might be redundant or could be simplified.
    // If 'inquiry' is null and no error was thrown, it means not found or no permission from service.
    if (!inquiry) {
        return NextResponse.json({ error: "Inquiry not found or access denied" }, { status: 404 });
    }
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    let message = "Failed to fetch inquiry";
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/respond/route.ts

import { type NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

// La definici贸n del tipo gen茅rico para los par谩metros de la ruta.
type RouteSegment<T> = (
  request: NextRequest,
  context: { params: T }
) => Promise<NextResponse> | NextResponse;

// El manejador de la solicitud.
const handler: RouteSegment<{ id: string }> = async (req, { params }) => {
  try {
    // 1. Aplicar un l铆mite de peticiones para prevenir el abuso.
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    // 2. Autenticar la sesi贸n del usuario.
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Extraer el 'locale' de los par谩metros de la URL.
    //    Esta es la correcci贸n principal para que coincida con la firma del servicio.
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Por defecto, se establece en hebreo.

    // 4. Extraer los datos del cuerpo de la solicitud.
    const { isAvailable, note } = await req.json();

    // Validar que 'isAvailable' sea un booleano.
    if (typeof isAvailable !== 'boolean') {
        return NextResponse.json({ success: false, error: "Bad Request: 'isAvailable' must be a boolean." }, { status: 400 });
    }

    // 5. Llamar al servicio de disponibilidad, AHORA con el par谩metro 'locale'.
    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note,
      locale: locale, // Se ha a帽adido el par谩metro 'locale' que faltaba.
    });

    // 6. Devolver una respuesta exitosa y consistente.
    return NextResponse.json({ success: true, inquiry: updatedInquiry });

  } catch (error) {
    // 7. Manejar cualquier error que ocurra.
    console.error("Error updating inquiry response:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Failed to update response";
    
    return NextResponse.json(
      { 
        success: false,
        error: errorMessage
      },
      { status: 500 }
    );
  }
};

// Exportar el manejador como el m茅todo POST.
export const POST = handler;
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { MatchSuggestionStatus, Prisma, UserRole } from '@prisma/client';
import { suggestionService } from '@/components/matchmaker/suggestions/services/suggestions/SuggestionService';
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import type { CreateSuggestionData } from '@/types/suggestions';
// ========================= 砖 专 1:  驻住  =========================
import type { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';
export const dynamic = 'force-dynamic';



/**
 * 砖 转 拽专 砖 爪注 转住住 注 住住 砖.
 */
const getSuggestionCategory = (status: MatchSuggestionStatus) => {
  switch (status) {
    case 'DRAFT':
    case 'AWAITING_MATCHMAKER_APPROVAL':
    case 'PENDING_FIRST_PARTY':
    case 'PENDING_SECOND_PARTY':
      return 'PENDING';

    case 'FIRST_PARTY_DECLINED':
    case 'SECOND_PARTY_DECLINED':
    case 'MATCH_DECLINED':
    case 'ENDED_AFTER_FIRST_DATE':
    case 'ENGAGED':
    case 'MARRIED':
    case 'EXPIRED':
    case 'CLOSED':
    case 'CANCELLED':
      return 'HISTORY';

    default:
      return 'ACTIVE';
  }
};

/**
 * POST: 爪专 爪注转 砖 砖.
 */
export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const allowedRolesToCreate: UserRole[] = [
      UserRole.MATCHMAKER,
      UserRole.ADMIN,
    ];
    if (!allowedRolesToCreate.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        {
          error:
            'Unauthorized - Matchmaker or Admin access required to create suggestions',
        },
        { status: 403 }
      );
    }

    const data = await req.json();

    if (!data.firstPartyId || !data.secondPartyId || !data.decisionDeadline) {
      return NextResponse.json(
        { error: 'Invalid input: Missing required fields.' },
        { status: 400 }
      );
    }
    
    // ========================= 砖 专 3: 注转 转专 =========================
    const url = new URL(req.url);
const rawLocale = url.searchParams.get('locale');
const locale: 'he' | 'en' = (rawLocale === 'en' || rawLocale === 'he') ? rawLocale : 'he';    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email; // 抓 拽 砖 

    if (!emailDict) {
        // 拽专 专 砖  注 专
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    // 拽 注 驻专驻 AI
    try {
      const [firstParty, secondParty] = await Promise.all([
        prisma.user.findUnique({
          where: { id: data.firstPartyId },
          include: { profile: true },
        }),
        prisma.user.findUnique({
          where: { id: data.secondPartyId },
          include: { profile: true },
        }),
      ]);

      if (!firstParty || !secondParty) {
        return NextResponse.json(
          { error: 'One or both candidates not found.' },
          { status: 404 }
        );
      }

      const profilesToUpdate: { userId: string; profileId: string }[] = [];
      if (firstParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: firstParty.id,
          profileId: firstParty.profile.id,
        });
      }
      if (secondParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: secondParty.id,
          profileId: secondParty.profile.id,
        });
      }

      if (profilesToUpdate.length > 0) {
        console.log(
          `[AI Update Trigger] Updating AI profiles for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')} before creating suggestion.`
        );
        await Promise.all(
          profilesToUpdate.map((p) => updateUserAiProfile(p.userId))
        );
        await prisma.profile.updateMany({
          where: { id: { in: profilesToUpdate.map((p) => p.profileId) } },
          data: { needsAiProfileUpdate: false },
        });
        console.log(
          `[AI Update Trigger] Flags reset for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')}.`
        );
      }
    } catch (aiUpdateError) {
      console.error('Failed during pre-suggestion AI profile update:', aiUpdateError);
      return NextResponse.json(
        { error: 'Failed to update AI profiles for candidates. Please try again.' },
        { status: 500 }
      );
    }

    // 爪专转 爪注 注专转  砖专转
    const suggestionData: CreateSuggestionData = {
      ...data,
      matchmakerId: session.user.id,
    };
    
    // ========================= 砖 专 4: 注专转  砖专转 =========================
    const newSuggestion = await suggestionService.createSuggestion(suggestionData, emailDict);

    return NextResponse.json(newSuggestion, { status: 201 });
  } catch (error) {
    console.error('Error creating suggestion:', error);
    let message = 'Failed to create suggestion';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/**
 * GET: 专 专砖 砖 爪注转 砖.
 */
export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(req.url);
    const status = searchParams.get('status');
    const priority = searchParams.get('priority');
    const timeframe = searchParams.get('timeframe');

    const where: Prisma.MatchSuggestionWhereInput = {};

    if (session.user.role === UserRole.MATCHMAKER) {
      where.matchmakerId = session.user.id;
    } else if (session.user.role === UserRole.CANDIDATE) {
      where.OR = [
        { firstPartyId: session.user.id },
        { secondPartyId: session.user.id },
      ];
    }

    if (status) where.status = status as MatchSuggestionStatus;
    if (priority)
      where.priority =
        priority as Prisma.EnumPriorityFieldUpdateOperationsInput['set'];

    if (timeframe) {
      const date = new Date();
      switch (timeframe) {
        case 'today':
          date.setHours(0, 0, 0, 0);
          where.createdAt = { gte: date };
          break;
        case 'week':
          date.setDate(date.getDate() - 7);
          where.createdAt = { gte: date };
          break;
        case 'month':
          date.setMonth(date.getMonth() - 1);
          where.createdAt = { gte: date };
          break;
      }
    }

    const suggestions = await prisma.matchSuggestion.findMany({
      where,
      include: {
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true, role: true },
        },
        statusHistory: { orderBy: { createdAt: 'desc' } },
        meetings: { orderBy: { createdAt: 'desc' } },
        inquiries: {
          include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
          },
          orderBy: { createdAt: 'asc' },
        },
      },
      orderBy: { lastActivity: 'desc' },
    });

    const formattedSuggestions = suggestions.map((suggestion) => ({
      ...suggestion,
      category: getSuggestionCategory(suggestion.status),
      // Formatting logic remains the same...
    }));

    console.log(
      `[API GET /suggestions] User: ${session.user.id} (Role: ${
        session.user.role
      }). Found ${suggestions.length} suggestions matching query.`
    );

    return NextResponse.json(formattedSuggestions);
  } catch (error) {
    console.error('Error fetching suggestions:', error);
    let message = 'Failed to fetch suggestions';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { SuggestionService } from "@/components/matchmaker/suggestions/services/suggestions/SuggestionService";

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    //  砖转砖 专
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    //  专砖转 砖
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const suggestionId = params.id;
    const data = await req.json();
    
    const suggestionService = SuggestionService.getInstance();
    
    try {
      // 砖砖 砖专转 注 爪注
      const updatedSuggestion = await suggestionService.updateSuggestion(
        suggestionId,
        session.user.id,
        {
          id: suggestionId,
          priority: data.priority,
          notes: {
            internal: data.internalNotes,
            forFirstParty: data.firstPartyNotes,
            forSecondParty: data.secondPartyNotes,
            matchingReason: data.matchingReason,
            followUpNotes: data.followUpNotes
          },
          decisionDeadline: data.decisionDeadline ? new Date(data.decisionDeadline) : undefined,
          responseDeadline: data.responseDeadline ? new Date(data.responseDeadline) : undefined
        }
      );
      
      return NextResponse.json({
        success: true,
        data: updatedSuggestion
      });
      
    } catch (serviceError: unknown) {
        console.error("Error from suggestion service:", serviceError);
        
        if (serviceError instanceof Error) {
          return NextResponse.json(
            { success: false, error: serviceError.message || "Failed to update suggestion" },
            { status: serviceError.message.includes("Unauthorized") ? 403 : 400 }
          );
        }
        
        // 拽专 砖 砖 砖 住 Error
        return NextResponse.json(
          { success: false, error: "Failed to update suggestion" },
          { status: 400 }
        );
      }
  } catch (error) {
    console.error("Error updating suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    //  砖砖转砖 专
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    //  专砖转 砖  
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const suggestionId = params.id;

    //  拽 爪注
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 拽转 专砖转 住驻爪驻转 - 专拽 砖 砖爪专 转 爪注    拽
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to delete this suggestion" },
        { status: 403 }
      );
    }

    // 拽转 专 拽砖专 驻专 拽 专拽爪
    // 1. 拽转 专砖转 住专
    await prisma.suggestionStatusHistory.deleteMany({
      where: { suggestionId }
    });

    // 2. 拽转 砖 驻砖转  拽
    await prisma.dateFeedback.deleteMany({
      where: { suggestionId }
    });

    // 3. 拽转 驻砖转 拽砖专转 ( 砖)
    await prisma.meeting.deleteMany({
      where: { suggestionId }
    });

    // 4. 拽转 砖转/驻转  拽转
    await prisma.suggestionInquiry.deleteMany({
      where: { suggestionId }
    });

    // 5. 住专转 拽砖专 转 拽砖专 专-专 ( 砖)
    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        approvedBy: {
          set: []
        },
        reviewedBy: {
          set: []
        }
      }
    });

    // 6. 拽转 爪注 注爪
    await prisma.matchSuggestion.delete({
      where: { id: suggestionId }
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully"
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    
    // 专转 驻专 砖  拽
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete suggestion", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/message/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';
import { notificationService } from '@/components/matchmaker/suggestions/services/notification/NotificationService';
import { initNotificationService } from '@/components/matchmaker/suggestions/services/notification/initNotifications';
import { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';

// 驻注 砖 砖专转 转专转
initNotificationService();

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const suggestionId = params.id;

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: 'Unauthorized - Invalid session' }, { status: 401 });
    }

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: 'Unauthorized - Matchmaker or Admin access required' }, { status: 403 });
    }

    // ========================= 砖 1: 注转  =========================
    // 拽专 转 砖驻 -URL, 拽  砖注砖 -API 砖 爪专转 爪注.
    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /message] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email; // 抓 拽 砖 

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }
    // =====================================================================

    const body = await req.json();
    const { partyType, customMessage, channels } = body;

    if (!partyType || !customMessage || !channels) {
      return NextResponse.json({ error: 'Invalid input: Missing required fields.' }, { status: 400 });
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: 'Suggestion not found' }, { status: 404 });
    }

    // ========================= 砖 2: 拽专  砖专转 =========================
    // 注转  注专 转  砖砖转 专 专砖 住专 :
    // 1. suggestion (拽 爪注)
    // 2. emailDict (拽 )
    // 3. options (拽 专转)
    await notificationService.handleSuggestionStatusChange(
      suggestion, 
      emailDict, // 专 砖  
      {         // 专 砖砖  拽 专转
        channels: channels,
        notifyParties: [partyType],
        customMessage: customMessage
      }
    );
    // ==========================================================================

    return NextResponse.json({ success: true, message: 'Message sent successfully.' }, { status: 200 });

  } catch (error) {
    console.error('Error sending message for suggestion:', error);
    const message = (error instanceof Error) ? error.message : 'Failed to send message';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/remind/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { initNotificationService } from "@/components/matchmaker/suggestions/services/notification/initNotifications";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

// 驻注转 砖专转 转专转
const notificationService = initNotificationService();

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /remind] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict || !emailDict.notifications?.customMessage?.reminderText) {
        throw new Error(`Email dictionary for locale '${locale}' is missing required notification templates.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to send reminders for this suggestion" }, { status: 403 });
    }
    
    const notifyParties: ('first' | 'second')[] = [];
    if ((partyType === "first" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_FIRST_PARTY) {
      notifyParties.push('first');
    }
    if ((partyType === "second" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_SECOND_PARTY) {
      notifyParties.push('second');
    }
    
    if (notifyParties.length === 0) {
      return NextResponse.json({ success: false, error: "No applicable recipients for reminder in current status" }, { status: 400 });
    }

    // ============================ 转拽 专  ============================
    // 1. 拽 转 转转 拽住 砖专转 -reminderText.
    const reminderTemplateText = emailDict.notifications.customMessage.reminderText;
    
    // 2. 爪注 转 驻 专砖转 砖 砖 砖.
    const reminderContent = reminderTemplateText
        .replace('{{matchmakerName}}', `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`);
    // =========================================================================

    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: { lastActivity: new Date() },
    });

    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId,
        status: suggestion.status,
        notes: `转专转 砖 ${partyType === "first" ? "爪 专砖" : partyType === "second" ? "爪 砖" : "砖 爪"} 注  ${session.user.firstName} ${session.user.lastName}`,
      },
    });
    
    await notificationService.handleSuggestionStatusChange(
      suggestion,
      emailDict,
      {
        channels: ['email', 'whatsapp'],
        notifyParties,
        customMessage: reminderContent
      }
    );
    
    return NextResponse.json({
      success: true,
      message: "Reminder sent successfully",
      recipientCount: notifyParties.length
    });
  } catch (error) {
    console.error("Error sending reminder:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send reminder" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/resend/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
// ========================= 砖 1:  驻住  专砖 =========================
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";
// =====================================================================================

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const suggestionId = params.id;
    const { partyType } = await req.json();

    // ========================= 砖 2: 注转  -URL =========================
    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /resend] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }
    // ============================================================================

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to resend this suggestion" }, { status: 403 });
    }

    let updatedSuggestion = suggestion;
    const transitionNotes = `爪注 砖 砖 注" ${session.user.firstName} ${session.user.lastName}`;
    
    if (partyType === "both" || partyType === "first") {
      // ========================= 砖 3: 拽专  砖专转 =========================
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_FIRST_PARTY,
        emailDict, // <-- 专 3: 
        `${transitionNotes} - 爪 专砖`, // <-- 专 4: 注专转
        { // <-- 专 5: 专转
          sendNotifications: true,
          notifyParties: ['first']
        }
      );
      // ===========================================================================
      
      if (partyType === "first") {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            firstPartySent: new Date(),
            lastActivity: new Date()
          }
        });
      }
    }
    
    if (partyType === "both" || partyType === "second") {
      // ========================= 砖 3: 拽专  砖专转 (砖) =========================
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        emailDict, // <-- 专 3: 
        `${transitionNotes} - 爪 砖`, // <-- 专 4: 注专转
        { // <-- 专 5: 专转
          sendNotifications: true,
          notifyParties: ['second']
        }
      );
      // ===========================================================================
      
      await prisma.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          secondPartySent: new Date(),
          lastActivity: new Date()
        }
      });
    }

    return NextResponse.json({
      success: true,
      message: `Suggestion successfully resent to ${partyType === "first" ? "first party" : partyType === "second" ? "second party" : "both parties"}`,
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error resending suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to resend suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/share-contact/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
// ========================= 砖 1:  驻住  专砖 =========================
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";
// =====================================================================================

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const suggestionId = params.id;

    // ========================= 砖 2: 注转  -URL =========================
    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /share-contact] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }
    // ============================================================================

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to share contact details for this suggestion" }, { status: 403 });
    }
    
    // 拽 砖住住 驻砖专 砖转祝 驻专. 拽  转拽.
    if (suggestion.status !== MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      return NextResponse.json({
        success: false,
        error: "Cannot share contacts until both parties have approved the suggestion."
      }, { status: 400 });
    }
    
    // ========================= 砖 3: 拽专  砖专转 =========================
    // 注专 转  专 砖砖, 转 注专转 专 专注.
    const updatedSuggestion = await statusTransitionService.transitionStatus(
      suggestion,
      MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
      emailDict, // <-- 专 3: 
      `驻专 拽砖专 砖转驻  ${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} ${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} 注" ${session.user.firstName} ${session.user.lastName}`, // <-- 专 4: 注专转
      { // <-- 专 5: 专转
        sendNotifications: true,
        notifyParties: ['first', 'second', 'matchmaker']
      }
    );
    // ==========================================================================

    return NextResponse.json({
      success: true,
      message: "Contact details shared successfully",
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error sharing contact details:", error);
    return NextResponse.json(
      { success: false, error: "Failed to share contact details" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { z } from "zod";

// Schema for validating status update data
const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

/**
 * PATCH endpoint for updating suggestion status
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. Verify permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    // 3. Validate request data
    const body = await req.json();
    console.log("Received status update request:", body);
    
    const validationResult = updateStatusSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error:", validationResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid request data", 
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }
    
    const { status, notes } = validationResult.data;

    // 4. Verify suggestion exists
    const suggestionId = params.id;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 5. Verify permission on specific suggestion
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to update this suggestion" },
        { status: 403 }
      );
    }

    // 6. Calculate category based on new status
    const getCategory = (status: MatchSuggestionStatus) => {
      switch (status) {
        case "DRAFT":
        case "AWAITING_MATCHMAKER_APPROVAL":
        case "PENDING_FIRST_PARTY":
        case "PENDING_SECOND_PARTY":
          return "PENDING";
        
        case "FIRST_PARTY_DECLINED":
        case "SECOND_PARTY_DECLINED":
        case "MATCH_DECLINED":
        case "ENDED_AFTER_FIRST_DATE":
        case "ENGAGED":
        case "MARRIED":
        case "EXPIRED":
        case "CLOSED":
        case "CANCELLED":
          return "HISTORY";
        
        default:
          return "ACTIVE";
      }
    };

    // 7. Update status in a transaction
    const result = await prisma.$transaction(async (tx) => {
      // Save previous status
      const previousStatus = suggestion.status;

      // Update the suggestion
      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status,
          previousStatus: previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          category: getCategory(status),
          
          // Update additional fields based on new status
          ...(status === MatchSuggestionStatus.CLOSED ? { closedAt: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_FIRST_PARTY ? { firstPartySent: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY ? { secondPartySent: new Date() } : {}),
        },
      });

      // Add status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes: notes || `住住 砖 -${status} 注  ${session.user.firstName} ${session.user.lastName}`,
        },
      });

      return updatedSuggestion;
    });

    // 8. Return success response
    return NextResponse.json({
      success: true,
      message: "Status updated successfully",
      suggestion: {
        id: result.id,
        status: result.status,
        previousStatus: result.previousStatus,
        lastStatusChange: result.lastStatusChange,
        category: result.category,
      },
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    // Return detailed error message if available
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to update status", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint for fetching suggestion history
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse URL parameters
    const searchParams = new URL(req.url).searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 50;

    // 3. Check viewing permissions
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        matchmakerId: true,
        firstPartyId: true,
        secondPartyId: true,
      }
    });
    
    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    
    // Check if user has permission to view this suggestion
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return NextResponse.json({ error: "Not authorized to view this suggestion" }, { status: 403 });
    }
    
    // 4. Build history query
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(startDate && {
          createdAt: {
            gte: new Date(startDate),
            ...(endDate && {
              lte: new Date(endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            secondParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            matchmaker: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc" as const,
      },
      take: limit,
    };

    // 5. Fetch status change history
    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    // 6. Format results
    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { error: "Failed to fetch history", details: errorMessage },
      { status: 500 }
    );
  }
}

/**
 * HEAD endpoint for getting status summary
 */
export async function HEAD(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new Response(null, { status: 401 });
    }

    // 2. Fetch suggestion details
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      }
    });

    if (!suggestion) {
      return new Response(null, { status: 404 });
    }

    // 3. Check viewing permissions
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return new Response(null, { status: 403 });
    }

    // 4. Prepare headers
    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    // Add lastStatusChange header only if it exists
    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages\feed
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages\feed\route.ts
--------------------------------------------------------------------------------
Content:
// FILENAME: src/app/api/messages/feed/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { FeedItem, FeedItemType, ExtendedSuggestionInquiry } from "@/types/messages";
import type { ExtendedMatchSuggestion } from "@/components/suggestions/types";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";

export const dynamic = 'force-dynamic';

// 专  砖驻转 驻专 砖转砖 
const partySelect = {
  id: true, email: true, firstName: true, lastName: true, isProfileComplete: true, phone: true,
  profile: true,
  images: {
    select: { 
      id: true, url: true, isMain: true, createdAt: true, updatedAt: true,
      cloudinaryPublicId: true, userId: true
    },
    orderBy: { isMain: "desc" as const },
  },
};

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const userId = session.user.id;
  const userRole = session.user.role as UserRole;

  try {
    // 1. 砖祝 爪注转 砖 专转
    const suggestionsFromDb = await prisma.matchSuggestion.findMany({
      where: {
        OR: [{ firstPartyId: userId }, { secondPartyId: userId }],
        status: { notIn: [MatchSuggestionStatus.DRAFT, MatchSuggestionStatus.CANCELLED] },
      },
      include: {
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: { select: partySelect },
        secondParty: { select: partySelect },
        statusHistory: { orderBy: { createdAt: "desc" } },
      },
      orderBy: { lastActivity: "desc" },
    });
    const suggestions: ExtendedMatchSuggestion[] = suggestionsFromDb.filter(
      (s) => s.firstParty?.profile && s.secondParty?.profile
    ) as ExtendedMatchSuggestion[];

    // 2. 砖祝 注转 爪' 专转
    const inquiriesFromDb = await prisma.suggestionInquiry.findMany({
        where: {
            OR: [{ fromUserId: userId }, { toUserId: userId }]
        },
        include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
            suggestion: {
                include: {
                    firstParty: { select: partySelect },
                    secondParty: { select: partySelect },
                    matchmaker: { select: { firstName: true, lastName: true } },
                }
            }
        },
        orderBy: { createdAt: 'desc' },
        take: 30
    });

    // 3. 专转 爪注转  FeedItem
    const suggestionFeedItems: FeedItem[] = suggestions.map((s) => {
      const isFirstParty = s.firstPartyId === userId;
      const otherParty = isFirstParty ? s.secondParty : s.firstParty;
      let type: FeedItemType = 'STATUS_UPDATE';
      let title = `注 爪注 注 ${otherParty.firstName}`;
      let description = "住住 转注. 抓/ 驻专.";
      
      const link = userRole === 'CANDIDATE' 
        ? `/matches?suggestionId=${s.id}` 
        : `/matchmaker/suggestions?suggestionId=${s.id}`;

      if ((s.status === "PENDING_FIRST_PARTY" && isFirstParty) || (s.status === "PENDING_SECOND_PARTY" && !isFirstParty)) {
        type = 'ACTION_REQUIRED';
        title = `爪注 砖 转 !`;
        description = `${s.matchmaker.firstName} 砖/转 砖砖  驻爪 .`;
      } else if (s.status === "CONTACT_DETAILS_SHARED") {
        title = " , 砖 转!";
        description = `驻专 拽砖专 注专.   爪专 拽砖专.`;
      } else if (s.status === "AWAITING_FIRST_DATE_FEEDBACK") {
        type = 'ACTION_REQUIRED';
        title = " 转 驻砖 专砖?";
        description = "砖 砖注 转 注转  砖 住注.";
      }
      
      return {
        id: `${s.id}-${s.status}`, type, title, description,
        timestamp: s.lastActivity, isRead: false,
        link: link,
        payload: { suggestion: s },
      };
    });

    // 4. 专转 注转 爪'  FeedItem
    const inquiryFeedItems: FeedItem[] = inquiriesFromDb.map((inquiry): FeedItem => {
        const isMyMessage = inquiry.fromUserId === userId;
        const otherUser = isMyMessage ? inquiry.toUser : inquiry.fromUser;
        const suggestionParticipant = inquiry.suggestion.firstPartyId === userId ? inquiry.suggestion.secondParty : inquiry.suggestion.firstParty;
        
        let title: string;
        let description: string;
        let type: FeedItemType;

        const link = userRole === 'CANDIDATE'
            ? `/matches?suggestionId=${inquiry.suggestionId}&view=chat`
            : `/matchmaker/suggestions?suggestionId=${inquiry.suggestionId}&view=chat`;

        if (isMyMessage) {
            title = `砖转 砖 ${otherUser.firstName}`;
            description = `"${inquiry.question.substring(0, 50)}..."`;
            type = inquiry.answer ? 'INQUIRY_RESPONSE' : 'MATCHMAKER_MESSAGE';
        } else {
            if (inquiry.answer) {
                 title = `转拽 转砖 ${otherUser.firstName}`;
                 description = ` 砖转 注 ${suggestionParticipant.firstName}: "${inquiry.answer.substring(0, 40)}..."`;
                 type = 'INQUIRY_RESPONSE';
            } else {
                 title = `注 砖 ${otherUser.firstName}`;
                 description = ` 爪注 注 ${suggestionParticipant.firstName}`;
                 type = userRole === 'MATCHMAKER' && inquiry.status === 'PENDING' ? 'ACTION_REQUIRED' : 'MATCHMAKER_MESSAGE';
            }
        }

        return {
            id: inquiry.id,
            type: type,
            title,
            description,
            timestamp: inquiry.answeredAt ? inquiry.answeredAt : inquiry.createdAt,
            isRead: isMyMessage || inquiry.status !== 'PENDING',
            link: link,
            payload: { 
                suggestion: inquiry.suggestion as unknown as ExtendedMatchSuggestion,
                suggestionInquiry: inquiry as unknown as ExtendedSuggestionInquiry
            }
        };
    });

    // 5. ,  专
    const allFeedItems = [...suggestionFeedItems, ...inquiryFeedItems];
    allFeedItems.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    
    return NextResponse.json({ success: true, feed: allFeedItems });

  } catch (error) {
    console.error("Error fetching activity feed:", error);
    return NextResponse.json({ success: false, error: "Failed to fetch activity feed" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\notifications
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\notifications\route.ts
--------------------------------------------------------------------------------
Content:
// FILENAME: src/app/api/notifications/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Session } from "next-auth";

export const dynamic = 'force-dynamic';

export async function GET() {
  try {
    const session = await getServerSession(authOptions) as Session | null;
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userId = session.user.id;

    // 1. 住驻专转 拽砖转 转 转 砖转转 砖转砖 
    const pendingAvailabilityRequests = await prisma.availabilityInquiry.count({
      where: {
        OR: [
          { 
            firstPartyId: userId,
            firstPartyResponse: null,
            expiresAt: { gt: new Date() }
          },
          { 
            secondPartyId: userId,
            secondPartyResponse: null,
            expiresAt: { gt: new Date() }
          }
        ]
      },
    });

    // 2. 住驻专转 注转 爪' 砖转 砖转转 砖转砖 
    // (注转 砖砖转砖  注 砖 住住 砖  "转")
    const unreadChatMessages = await prisma.suggestionInquiry.count({
        where: {
            toUserId: userId,
            status: 'PENDING'
        }
    });

    const total = pendingAvailabilityRequests + unreadChatMessages;

    return NextResponse.json({
      availabilityRequests: pendingAvailabilityRequests,
      messages: unreadChatMessages, //  注砖 住驻专 注转 爪' 转转
      total: total
    });

  } catch (error) {
    console.error("Error fetching notifications:", error);
    return NextResponse.json(
      { error: "Failed to fetch notifications" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\profile_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
# Generated on: 2025-10-05 16:04:14
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\profile_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/profile/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, HeadCoveringType, KippahType, ServiceType, ReligiousJourney, AvailabilityStatus } from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";

// 专   砖-Route Handler 专抓 转 砖  砖专 -Cache.
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    //  砖砖转砖 专. 专砖 住砖  砖转  驻专驻.
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 拽注 注专  砖转砖 砖驻 转:
    //  爪 ID 拽砖, 砖转砖 . 专转, 砖转砖 -ID 砖 砖转砖 专.
    const targetUserId = requestedUserId || session.user.id;

    // 砖祝 转 砖转砖  注  注 拽砖专 砖 (驻专驻, 转转, 爪转)
    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      include: {
        profile: {
          include: {
            testimonials: {
              orderBy: {
                createdAt: 'desc',
              }
            }
          }
        },
        images: {
            orderBy: {
                isMain: 'desc' //  砖转 专砖转 转 专砖
            }
        },
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        console.error(`Profile data not found for user ID: ${targetUserId}`);
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    if (!dbProfile.birthDate) {
        console.error(`birthDate is null or undefined for profile ID: ${dbProfile.id}`);
        return NextResponse.json(
            { success: false, message: 'Data integrity issue: birthDate is missing for the profile.' },
            { status: 500 }
        );
    }

    //  转 拽 转  砖砖 专 拽
    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering,
      kippahType: dbProfile.kippahType,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      
      // 砖转 住驻专 转 砖
      about: dbProfile.about || "",
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      
      // 专 注专转 爪转
      manualEntryText: dbProfile.manualEntryText || undefined,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      testimonials: dbProfile.testimonials || [],
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,

      // 注驻转 砖
      matchingNotes: dbProfile.matchingNotes || "",
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: dbProfile.preferredServiceTypes || [],
      preferredHeadCoverings: dbProfile.preferredHeadCoverings || [],
      preferredKippahTypes: dbProfile.preferredKippahTypes || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],

      // 专转 注驻转 拽爪注转
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender,

      // 住住 注 注专转
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      
      // 注 专驻 (住)
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
   medicalInfoDetails: dbProfile.isMedicalInfoVisible 
        ? dbProfile.medicalInfoDetails ?? undefined 
        : undefined,      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      
      // 注 住住 注 砖转砖
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };
    
    // 专转 转砖 爪转 注  转
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
export const dynamic = 'force-dynamic';
// Configure Cloudinary
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// 驻拽爪 注驻转 -Upload 注 Promise 
function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: 'profile-images',
        resource_type: 'image',
      },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({
            secure_url: result.secure_url,
            public_id: result.public_id,
          });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// GET - Fetch all images for a user
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: {
        user: {
          email: session.user.email,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error('[GetImages] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch images' },
      { status: 500 }
    );
  }
}

// POST - Upload new images (can be adapted for multiple files)
export async function POST(req: NextRequest) {
  // Apply rate limiting: 20 image uploads per user per hour (prevents resource abuse)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  const startTime = Date.now();

  try {
    console.log('[Upload] Starting upload process');

    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error('[Upload] Authentication failed - No user session');
      return NextResponse.json(
        {
          success: false,
          error: 'Unauthorized',
        },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      select: { id: true, email: true, _count: { select: { images: true } } },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.error('[Upload] No file provided in request');
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    if (user._count.images >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { success: false, error: 'Maximum number of images reached' },
        { status: 400 }
      );
    }

    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid file type. Only JPG, PNG and WEBP are allowed',
        },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { success: false, error: 'File size must be less than 5MB' },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    console.log(`[Upload] File processed, uploading to Cloudinary...`);

    const cloudinaryResult = await uploadToCloudinary(buffer);

    const isFirstImage = user._count.images === 0;

    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });

    console.log(
      `[Upload] Database save completed in ${Date.now() - startTime}ms`
    );
    return NextResponse.json({
      success: true,
      image,
      timing: `${Date.now() - startTime}ms`,
    });
  } catch (error) {
    console.error('[Upload] General error:', error);
    console.log(`[Upload] Failed after ${Date.now() - startTime}ms`);
    return NextResponse.json(
      { success: false, error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// --- NEW ---
// DELETE - Bulk delete images
export async function DELETE(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const { imageIds } = await req.json();

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Image IDs must be a non-empty array' },
        { status: 400 }
      );
    }

    // 1. Find images to verify ownership and get necessary data
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: userId, // CRUCIAL: Ensures user only deletes their own images
      },
      select: {
        id: true,
        cloudinaryPublicId: true,
        isMain: true,
      },
    });

    if (imagesToDelete.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No matching images found to delete.' },
        { status: 404 }
      );
    }

    // 2. Check if the main image is being deleted
    const wasMainImageDeleted = imagesToDelete.some((image) => image.isMain);

    // 3. Delete from Cloudinary
    const cloudinaryIdsToDelete = imagesToDelete
      .map((image) => image.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (cloudinaryIdsToDelete.length > 0) {
      const cloudinaryDeletions = cloudinaryIdsToDelete.map((publicId) =>
        cloudinary.uploader.destroy(publicId).catch((err) => {
          console.error(
            `[Bulk Delete] Failed to delete image ${publicId} from Cloudinary:`,
            err
          );
        })
      );
      await Promise.all(cloudinaryDeletions);
    }

    // 4. Delete from database
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) }, // Use validated IDs
        userId: userId,
      },
    });

    // 5. If main image was deleted, assign a new one if possible
    if (wasMainImageDeleted) {
      const newMainImage = await prisma.userImage.findFirst({
        where: { userId: userId },
        orderBy: { createdAt: 'desc' },
      });

      if (newMainImage) {
        await prisma.userImage.update({
          where: { id: newMainImage.id },
          data: { isMain: true },
        });
      }
    }

    // 6. Fetch the updated list of images to return to the client
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, images: updatedImages });
  } catch (error) {
    console.error('[Bulk Delete Images] Error:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete images',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;
    
    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Delete from Cloudinary if cloudinaryPublicId exists
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
        // Continue with database deletion even if Cloudinary deletion fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId },
    });

    // If this was the main image, set another image as main if available
    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;

    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Reset all user's images to non-main
    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    // Set the selected image as main
    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    // Get updated images list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/questionnaire/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma, UserRole } from '@prisma/client';
import { Locale } from '../../../../../i18n-config';

import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { DbWorldKey, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { WorldId, UpdateValue } from '@/types/next-auth';
import { formatQuestionnaireForDisplay } from '@/lib/services/questionnaireService';

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 拽注转 砖驻转 爪驻 -URL  -headers ( 砖转砖 专专转 )
    const url = new URL(req.url);
    const viewerLocale = (url.searchParams.get('locale') as Locale) || 'he';
    const targetUserId = url.searchParams.get('userId') || session.user.id;
const isOwnProfile = session.user.id === targetUserId;
const hasElevatedPermissions = 
    session.user.role === UserRole.ADMIN || 
    session.user.role === UserRole.MATCHMAKER;
const canViewAllAnswers = isOwnProfile || hasElevatedPermissions;
console.log(`---[ SERVER LOG | API questionnaire GET ]--- 砖驻转 砖 注专: ${targetUserId}, 爪驻: ${session.user.id}, 转驻拽 爪驻: ${session.user.role},  专转 : ${canViewAllAnswers}`);

console.log(`---[ SERVER LOG | API questionnaire GET ]--- 砖驻转 砖 注专 砖转砖: ${targetUserId}, 砖驻转 爪驻: ${viewerLocale},  注 驻专驻: ${isOwnProfile}`);


    const rawQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: targetUserId },
      orderBy: { createdAt: 'desc' },
    });

    if (!rawQuestionnaire) {
              console.warn('---[ SERVER LOG | API questionnaire GET ]---  爪 砖 注专 砖转砖.');

      return NextResponse.json({ success: false, message: 'No questionnaire found' }, { status: 404 });
    }
    console.log('---[ SERVER LOG | API questionnaire GET ]--- 转 砖  -DB:', JSON.stringify(rawQuestionnaire, null, 2));

    // 砖砖 驻拽爪转 注爪 砖
const formattedQuestionnaire = await formatQuestionnaireForDisplay(
  rawQuestionnaire,
  viewerLocale,
  canViewAllAnswers  // <-- 住驻转 驻专专 砖
);    console.log('---[ DEBUG 4: FINAL API RESPONSE ]--- Data being sent to client:', JSON.stringify(formattedQuestionnaire.formattedAnswers, null, 2));
    console.log('---[ SERVER LOG | API questionnaire GET ]--- 转 注 砖专 拽:', JSON.stringify(formattedQuestionnaire, null, 2));

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedQuestionnaire,
    });
  } catch (error) {
    console.error('Error fetching formatted questionnaire:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    return NextResponse.json({ success: false, message: errorMessage }, { status: 500 });
 
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
     const userId = session.user.id;

     const body = await req.json();
     
     const { worldKey, questionId, value } = body as {
       worldKey: WorldId;
       questionId: string;
       value: UpdateValue;
     };

     if (!worldKey || !questionId || !value || !value.type || !KEY_MAPPING[worldKey]) {
        return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
     }

     const dbKey = KEY_MAPPING[worldKey];

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       return NextResponse.json({ success: false, error: "砖  爪" }, { status: 404 });
     }

     const currentAnswersJson = questionnaire[dbKey];
     const currentAnswers = Array.isArray(currentAnswersJson) ? currentAnswersJson as unknown as JsonAnswerData[] : [];

     let updatedAnswers: JsonAnswerData[];

     if (value.type === 'delete') {
       // 拽 拽转 转砖
       updatedAnswers = currentAnswers.filter(a => a.questionId !== questionId);
     } else {
       // 拽 拽转 注  住驻转 转砖
       const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
       const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

       let updatedAnswer: JsonAnswerData;

       if (value.type === 'visibility') {
          if (!existingAnswer) return NextResponse.json({ success: false, error: " 爪 转砖 注 专转" }, { status: 404 });
          if (typeof value.isVisible !== 'boolean') return NextResponse.json({ success: false, error: "注专 专转  转拽" }, { status: 400 });
          updatedAnswer = { ...existingAnswer, isVisible: value.isVisible, answeredAt: new Date().toISOString() };
       } else if (value.type === 'answer') {
         if (value.value === undefined) return NextResponse.json({ success: false, error: "注专 转砖 住专" }, { status: 400 });
         updatedAnswer = {
           questionId,
           value: value.value as Prisma.JsonValue,
           isVisible: existingAnswer?.isVisible ?? true,
           answeredAt: new Date().toISOString()
         };
       } else {
           return NextResponse.json({ success: false, error: "住 注  转拽" }, { status: 400 });
       }

       updatedAnswers = [...currentAnswers];
       if (existingAnswerIndex !== -1) {
           updatedAnswers[existingAnswerIndex] = updatedAnswer;
       } else if (value.type === 'answer') {
           updatedAnswers.push(updatedAnswer);
       }
     }

     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });

     await prisma.profile.update({
       where: { userId },
       data: { needsAiProfileUpdate: true }
     });

    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach(key => {
       const currentDbKey = KEY_MAPPING[key];
        formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
    });

     const formattedResponse = {
       ...updated,
       formattedAnswers: formattedAnswers
     };

     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            return NextResponse.json({ success: false, error: "砖转 住 转" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           return NextResponse.json({ success: false, error: "祝 拽砖  JSON 转拽" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "砖 注 砖" }, { status: 500 });
   }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * GET - 专 爪转.
 * 拽  砖砖转 砖 转专砖:
 * 1.  砖 'userId' 驻专专: 专 爪转 *砖专转* 注专 驻专驻 爪专.
 * 2.   砖 'userId': 专 转 ** 爪转 注专 砖转砖 专,  砖  转.
 */
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');

  try {
    // 转专砖 1: 拽砖 爪转 爪转 驻专驻 砖 砖转砖 住驻爪驻 (爪驻 爪专转)
    if (userId) {
      const testimonials = await prisma.friendTestimonial.findMany({
        where: {
          profile: {
            userId: userId,
          },
          // 砖: 专 专拽 爪转 砖砖专 爪驻 爪专转
          status: 'APPROVED',
        },
        orderBy: {
          createdAt: 'desc',
        },
      });
      return NextResponse.json({ success: true, testimonials });
    }

    // 转专砖 2: 拽砖  爪转 砖 砖转砖 专 (转 注 驻专驻 砖)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const testimonials = await prisma.friendTestimonial.findMany({
      where: {
        profile: {
          userId: session.user.id,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, testimonials });
  } catch (error) {
    console.error('Error in GET /api/profile/testimonials:', error);
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}

/**
 * POST - 爪专 爪 砖 爪注转 拽 -驻注 .
 * 拽转 拽爪  砖砖转 转 驻住 爪专 砖专 .
 *   砖 拽砖专 砖砖 驻注 转 .
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      token,
      authorName,
      relationship,
      content,
      authorPhone,
      isPhoneVisibleToMatch,
    } = body;

    // 1. 爪 住住转 砖 砖转 
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields.' },
        { status: 400 }
      );
    }

    // 2. 砖砖 专拽爪   转.
    // 砖转 驻注转 (爪专转 爪 注 拽) 转 爪 .
    const result = await prisma.$transaction(async (tx) => {
      // 砖 ': 驻砖 转 拽砖转 拽.  转 转 拽转, 转拽祝 住住 PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() }, //  砖拽  驻 转拽祝
        },
      });

      //   爪 拽砖 转拽, 专拽 砖.   转 专拽爪 转.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // 砖 ': 爪专 转 专砖转 爪 住 转.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // 爪 砖 转 转 砖专 砖转砖
          submittedBy: 'FRIEND', // 住 砖爪 注 专
        },
      });

      // 砖 ': 拽专! 砖 转 住住 拽 -COMPLETED  注 砖砖 专.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    // 3.  专拽爪 爪, 专 转砖转 爪.
    if (result.success) {
      return NextResponse.json({
        success: true,
        message: 'Thank you! Your testimonial has been submitted.',
      });
    } else {
      // 爪   专 拽专转  拽转 专拽爪 
      throw new Error('Transaction failed unexpectedly.');
    }
  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);

    // 4. 驻 注 砖转 注转
    if (
      error instanceof Error &&
      error.message.includes('Invalid, expired, or already used link')
    ) {
      return NextResponse.json(
        {
          success: false,
          message:
            'This link is invalid, has expired, or has already been used.',
        },
        { status: 400 }
      );
    }

    // 5. 驻 砖转  爪驻转 专转
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
# Generated on: 2025-09-18 22:40:39
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

// GET all testimonials for the logged-in user
export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const testimonials = await prisma.friendTestimonial.findMany({
    where: { profileId: session.user.profile.id },
    orderBy: { createdAt: 'desc' },
  });

  return NextResponse.json({ success: true, testimonials });
}

// POST a new manual testimonial
export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }
  
  const body = await req.json();
  const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

  if (!authorName || !relationship || !content) {
    return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
  }

  const newTestimonial = await prisma.friendTestimonial.create({
    data: {
      profileId: session.user.profile.id,
      authorName,
      relationship,
      content,
      authorPhone: authorPhone || null,
      isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
      status: 'APPROVED', // Manual entries are pre-approved by the user
      submittedBy: 'USER',
    },
  });

  return NextResponse.json({ success: true, testimonial: newTestimonial }, { status: 201 });
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id, // Ensure ownership
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/testimonials/[token]/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { jwtVerify, JWTPayload } from 'jose'; //  JWTPayload 注专 专转

interface TokenPayload extends JWTPayload {
  profileId: string;
}

export async function POST(req: Request, { params }: { params: { token: string } }) {
  const { token } = params;
  if (!token) {
    return NextResponse.json({ success: false, message: 'Token is missing' }, { status: 400 });
  }

  const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
  if (!secret) {
      console.error("FATAL: NEXTAUTH_SECRET is not defined.");
      return NextResponse.json({ success: false, message: 'Server configuration error' }, { status: 500 });
  }

  try {
    // --- 砖 1: 驻专拽 转 专 (Casting) 砖 砖 ---
    // 砖 ': 转 拽  专拽
    const verificationResult = await jwtVerify(token, secret);
    
    // 砖 ': 专转 -payload 驻住 拽 砖.  驻转专 转 砖转 砖转.
    const payload = verificationResult.payload as TokenPayload;
    const { profileId } = payload;
    // --- 住祝 砖 ---
    
    const body = await req.json();
    const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    if (!authorName || !relationship || !content) {
      return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
    }

    await prisma.friendTestimonial.create({
      data: {
        profileId, // 注砖 TypeScript 注 砖 string
        authorName,
        relationship,
        content,
        authorPhone: authorPhone || null,
        isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
        status: 'PENDING',
        submittedBy: 'FRIEND',
      },
    });

    return NextResponse.json({ success: true, message: 'Testimonial submitted successfully' });

  } catch (error) {
    console.error("Error processing testimonial submission:", error);
    if (error instanceof Error && (error.name === 'JWTExpired' || error.name === 'JWSInvalid' || error.name === 'JOSEError')) {
        return NextResponse.json({ success: false, message: 'Link is invalid or has expired.' }, { status: 401 });
    }
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { SignJWT } from 'jose';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.profile?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized or profile not found' }, { status: 401 });
    }

    const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
    if (!secret) throw new Error("NEXTAUTH_SECRET is not defined.");

    const payload = {
      profileId: session.user.profile.id,
      userId: session.user.id, // Include userId for verification if needed
    };

    const token = await new SignJWT(payload)
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime('7d') // 拽砖专  转拽祝 砖注
      .sign(secret);

    const link = `${process.env.NEXT_PUBLIC_BASE_URL}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });

  } catch (error) {
    console.error("Error creating testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for testimonials_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id, // Ensure ownership
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { randomBytes } from 'crypto';

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Find the user's profile to link the request to
    const userProfile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found' }, { status: 404 });
    }

    // 1. Generate a secure, random token
    const token = randomBytes(32).toString('hex');

    // 2. Set an expiration date (e.g., 7 days from now)
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    // 3. Create the request record in the new database table
    await prisma.testimonialRequest.create({
      data: {
        token: token,
        expiresAt: expiresAt,
        profileId: userProfile.id, // Use the fetched profile ID
      },
    });

    // 4. Construct the full link to return to the client
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    const link = `${baseUrl}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });
  } catch (error) {
    console.error("Failed to create testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal server error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/update/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  ReligiousJourney,
  Profile, // Import Prisma's Profile type
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";
import { updateUserAiProfile } from '@/lib/services/profileAiService'; // <--- 1. 

// Helper to convert to number or null
const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

// Helper to convert to Date or error if invalid for required fields
const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

// Helper to convert to Date or null for optional fields
const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

// Helper to convert empty string or null to null, otherwise return the string
const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};

export async function PUT(req: NextRequest) {
  // Apply rate limiting: 50 profile updates per user per 10 minutes (prevents DB heavy load)
  const rateLimitResponse = await applyRateLimit(req, { requests: 50, window: '10 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    let body;
    try {
      body = await req.json();
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      religiousJourney,
      preferredReligiousJourneys, 
      about,
      // --- START: 住驻转 砖转 砖 ---
      profileHeadline,
      inspiringCoupleStory,
      influentialRabbi,
      // --- END: 住驻转 砖转 砖 ---
      parentStatus,
      fatherOccupation,
      motherOccupation,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious,
      profileCharacterTraits,
      profileHobbies,
      aliyaCountry,
      aliyaYear,
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      preferredCharacterTraits,
      preferredHobbies,
      preferredAliyaStatus,
      hasViewedProfilePreview,
      hasMedicalInfo,
      medicalInfoDetails,
      medicalInfoDisclosureTiming,
      isMedicalInfoVisible,
    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status & Background (User's own) ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious; // User's own
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
     if (fatherOccupation !== undefined) dataToUpdate.fatherOccupation = emptyStringToNull(fatherOccupation);
    if (motherOccupation !== undefined) dataToUpdate.motherOccupation = emptyStringToNull(motherOccupation);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education, Occupation & Service (User's own) ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion & Lifestyle (User's own) ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
        if (religiousJourney !== undefined) dataToUpdate.religiousJourney = emptyStringToNull(religiousJourney) as ReligiousJourney | null;

    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (body.hasOwnProperty('kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (body.hasOwnProperty('headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits & Hobbies (User's own) ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || []; // User's own hobbies

    // --- About & Additional Info ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
      if (profileHeadline !== undefined) dataToUpdate.profileHeadline = emptyStringToNull(profileHeadline);
    if (inspiringCoupleStory !== undefined) dataToUpdate.inspiringCoupleStory = emptyStringToNull(inspiringCoupleStory);
    if (influentialRabbi !== undefined) dataToUpdate.influentialRabbi = emptyStringToNull(influentialRabbi);
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    
    // --- Preferences (related to matching partner) ---
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah); // Assuming it's a string like "yes", "no" that needs to be nullable
    


    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || []; // Preference for partner
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || []; // Preference for partner's hobbies
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);
    if (preferredReligiousJourneys !== undefined) dataToUpdate.preferredReligiousJourneys = preferredReligiousJourneys || [];

    // --- Profile Management ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
    if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
   
    // --- START: 住驻转 拽转 注 砖转 专驻 ---
    if (hasMedicalInfo !== undefined) dataToUpdate.hasMedicalInfo = hasMedicalInfo;
    if (medicalInfoDetails !== undefined) dataToUpdate.medicalInfoDetails = emptyStringToNull(medicalInfoDetails);
    if (medicalInfoDisclosureTiming !== undefined) dataToUpdate.medicalInfoDisclosureTiming = emptyStringToNull(medicalInfoDisclosureTiming);
    if (isMedicalInfoVisible !== undefined) dataToUpdate.isMedicalInfoVisible = isMedicalInfoVisible;
    // --- END: 住驻转 拽转 注 砖转 专驻 ---

    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      if (!body.hasOwnProperty('availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    if (body.hasOwnProperty('availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // --- Perform the database update ---
    let updatedProfileRecord: Profile | null = null;
    if (Object.keys(dataToUpdate).length > 0) {
      try {
         dataToUpdate.needsAiProfileUpdate = true;
         
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
    
      } catch (dbError) {
        console.error('Prisma profile update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // Construct the response, ensuring all UserProfile fields are mapped
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, 
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],
      about: dbProfile.about || "",
        profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: refreshedUserWithProfile.isProfileComplete,
      // --- START: 住驻转 砖转 专驻 转 ---
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
            needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,

      // --- END: 住驻转 砖转 专驻 转 ---
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, 
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], 
      profileHobbies: dbProfile.profileHobbies || [],                 
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], 
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined, 
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], 
      preferredHobbies: dbProfile.preferredHobbies || [],                 
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, 

      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('Profile update route error:', error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for profile_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/profile/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, HeadCoveringType, KippahType, ServiceType, ReligiousJourney, AvailabilityStatus } from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";

// 专   砖-Route Handler 专抓 转 砖  砖专 -Cache.
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    //  砖砖转砖 专. 专砖 住砖  砖转  驻专驻.
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 拽注 注专  砖转砖 砖驻 转:
    //  爪 ID 拽砖, 砖转砖 . 专转, 砖转砖 -ID 砖 砖转砖 专.
    const targetUserId = requestedUserId || session.user.id;

    // 砖祝 转 砖转砖  注  注 拽砖专 砖 (驻专驻, 转转, 爪转)
    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      include: {
        profile: {
          include: {
            testimonials: {
              orderBy: {
                createdAt: 'desc',
              }
            }
          }
        },
        images: {
            orderBy: {
                isMain: 'desc' //  砖转 专砖转 转 专砖
            }
        },
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        console.error(`Profile data not found for user ID: ${targetUserId}`);
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    if (!dbProfile.birthDate) {
        console.error(`birthDate is null or undefined for profile ID: ${dbProfile.id}`);
        return NextResponse.json(
            { success: false, message: 'Data integrity issue: birthDate is missing for the profile.' },
            { status: 500 }
        );
    }

    //  转 拽 转  砖砖 专 拽
    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering,
      kippahType: dbProfile.kippahType,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      
      // 砖转 住驻专 转 砖
      about: dbProfile.about || "",
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      
      // 专 注专转 爪转
      manualEntryText: dbProfile.manualEntryText || undefined,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      testimonials: dbProfile.testimonials || [],
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,

      // 注驻转 砖
      matchingNotes: dbProfile.matchingNotes || "",
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: dbProfile.preferredServiceTypes || [],
      preferredHeadCoverings: dbProfile.preferredHeadCoverings || [],
      preferredKippahTypes: dbProfile.preferredKippahTypes || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],

      // 专转 注驻转 拽爪注转
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender,

      // 住住 注 注专转
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      
      // 注 专驻 (住)
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
   medicalInfoDetails: dbProfile.isMedicalInfoVisible 
        ? dbProfile.medicalInfoDetails ?? undefined 
        : undefined,      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      
      // 注 住住 注 砖转砖
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };
    
    // 专转 转砖 爪转 注  转
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
export const dynamic = 'force-dynamic';
// Configure Cloudinary
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// 驻拽爪 注驻转 -Upload 注 Promise 
function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: 'profile-images',
        resource_type: 'image',
      },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({
            secure_url: result.secure_url,
            public_id: result.public_id,
          });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// GET - Fetch all images for a user
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: {
        user: {
          email: session.user.email,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error('[GetImages] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch images' },
      { status: 500 }
    );
  }
}

// POST - Upload new images (can be adapted for multiple files)
export async function POST(req: NextRequest) {
  // Apply rate limiting: 20 image uploads per user per hour (prevents resource abuse)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  const startTime = Date.now();

  try {
    console.log('[Upload] Starting upload process');

    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error('[Upload] Authentication failed - No user session');
      return NextResponse.json(
        {
          success: false,
          error: 'Unauthorized',
        },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      select: { id: true, email: true, _count: { select: { images: true } } },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.error('[Upload] No file provided in request');
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    if (user._count.images >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { success: false, error: 'Maximum number of images reached' },
        { status: 400 }
      );
    }

    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid file type. Only JPG, PNG and WEBP are allowed',
        },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { success: false, error: 'File size must be less than 5MB' },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    console.log(`[Upload] File processed, uploading to Cloudinary...`);

    const cloudinaryResult = await uploadToCloudinary(buffer);

    const isFirstImage = user._count.images === 0;

    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });

    console.log(
      `[Upload] Database save completed in ${Date.now() - startTime}ms`
    );
    return NextResponse.json({
      success: true,
      image,
      timing: `${Date.now() - startTime}ms`,
    });
  } catch (error) {
    console.error('[Upload] General error:', error);
    console.log(`[Upload] Failed after ${Date.now() - startTime}ms`);
    return NextResponse.json(
      { success: false, error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// --- NEW ---
// DELETE - Bulk delete images
export async function DELETE(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const { imageIds } = await req.json();

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Image IDs must be a non-empty array' },
        { status: 400 }
      );
    }

    // 1. Find images to verify ownership and get necessary data
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: userId, // CRUCIAL: Ensures user only deletes their own images
      },
      select: {
        id: true,
        cloudinaryPublicId: true,
        isMain: true,
      },
    });

    if (imagesToDelete.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No matching images found to delete.' },
        { status: 404 }
      );
    }

    // 2. Check if the main image is being deleted
    const wasMainImageDeleted = imagesToDelete.some((image) => image.isMain);

    // 3. Delete from Cloudinary
    const cloudinaryIdsToDelete = imagesToDelete
      .map((image) => image.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (cloudinaryIdsToDelete.length > 0) {
      const cloudinaryDeletions = cloudinaryIdsToDelete.map((publicId) =>
        cloudinary.uploader.destroy(publicId).catch((err) => {
          console.error(
            `[Bulk Delete] Failed to delete image ${publicId} from Cloudinary:`,
            err
          );
        })
      );
      await Promise.all(cloudinaryDeletions);
    }

    // 4. Delete from database
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) }, // Use validated IDs
        userId: userId,
      },
    });

    // 5. If main image was deleted, assign a new one if possible
    if (wasMainImageDeleted) {
      const newMainImage = await prisma.userImage.findFirst({
        where: { userId: userId },
        orderBy: { createdAt: 'desc' },
      });

      if (newMainImage) {
        await prisma.userImage.update({
          where: { id: newMainImage.id },
          data: { isMain: true },
        });
      }
    }

    // 6. Fetch the updated list of images to return to the client
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, images: updatedImages });
  } catch (error) {
    console.error('[Bulk Delete Images] Error:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete images',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

// Configure Cloudinary
if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;
    
    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Delete from Cloudinary if cloudinaryPublicId exists
    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
        // Continue with database deletion even if Cloudinary deletion fails
      }
    }

    // Delete from database
    await prisma.userImage.delete({
      where: { id: imageId },
    });

    // If this was the main image, set another image as main if available
    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { imageId: string } }
) {
  try {
    // Verify authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const { imageId } = params;

    // Find the image and include user data for ownership verification
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    // Check if image exists
    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    // Verify image ownership
    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    // Reset all user's images to non-main
    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    // Set the selected image as main
    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    // Get updated images list
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/questionnaire/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma, UserRole } from '@prisma/client';
import { Locale } from '../../../../../i18n-config';

import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { DbWorldKey, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { WorldId, UpdateValue } from '@/types/next-auth';
import { formatQuestionnaireForDisplay } from '@/lib/services/questionnaireService';

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 拽注转 砖驻转 爪驻 -URL  -headers ( 砖转砖 专专转 )
    const url = new URL(req.url);
    const viewerLocale = (url.searchParams.get('locale') as Locale) || 'he';
    const targetUserId = url.searchParams.get('userId') || session.user.id;
const isOwnProfile = session.user.id === targetUserId;
const hasElevatedPermissions = 
    session.user.role === UserRole.ADMIN || 
    session.user.role === UserRole.MATCHMAKER;
const canViewAllAnswers = isOwnProfile || hasElevatedPermissions;
console.log(`---[ SERVER LOG | API questionnaire GET ]--- 砖驻转 砖 注专: ${targetUserId}, 爪驻: ${session.user.id}, 转驻拽 爪驻: ${session.user.role},  专转 : ${canViewAllAnswers}`);

console.log(`---[ SERVER LOG | API questionnaire GET ]--- 砖驻转 砖 注专 砖转砖: ${targetUserId}, 砖驻转 爪驻: ${viewerLocale},  注 驻专驻: ${isOwnProfile}`);


    const rawQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: targetUserId },
      orderBy: { createdAt: 'desc' },
    });

    if (!rawQuestionnaire) {
              console.warn('---[ SERVER LOG | API questionnaire GET ]---  爪 砖 注专 砖转砖.');

      return NextResponse.json({ success: false, message: 'No questionnaire found' }, { status: 404 });
    }
    console.log('---[ SERVER LOG | API questionnaire GET ]--- 转 砖  -DB:', JSON.stringify(rawQuestionnaire, null, 2));

    // 砖砖 驻拽爪转 注爪 砖
const formattedQuestionnaire = await formatQuestionnaireForDisplay(
  rawQuestionnaire,
  viewerLocale,
  canViewAllAnswers  // <-- 住驻转 驻专专 砖
);    console.log('---[ DEBUG 4: FINAL API RESPONSE ]--- Data being sent to client:', JSON.stringify(formattedQuestionnaire.formattedAnswers, null, 2));
    console.log('---[ SERVER LOG | API questionnaire GET ]--- 转 注 砖专 拽:', JSON.stringify(formattedQuestionnaire, null, 2));

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedQuestionnaire,
    });
  } catch (error) {
    console.error('Error fetching formatted questionnaire:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    return NextResponse.json({ success: false, message: errorMessage }, { status: 500 });
 
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
     const userId = session.user.id;

     const body = await req.json();
     
     const { worldKey, questionId, value } = body as {
       worldKey: WorldId;
       questionId: string;
       value: UpdateValue;
     };

     if (!worldKey || !questionId || !value || !value.type || !KEY_MAPPING[worldKey]) {
        return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
     }

     const dbKey = KEY_MAPPING[worldKey];

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       return NextResponse.json({ success: false, error: "砖  爪" }, { status: 404 });
     }

     const currentAnswersJson = questionnaire[dbKey];
     const currentAnswers = Array.isArray(currentAnswersJson) ? currentAnswersJson as unknown as JsonAnswerData[] : [];

     let updatedAnswers: JsonAnswerData[];

     if (value.type === 'delete') {
       // 拽 拽转 转砖
       updatedAnswers = currentAnswers.filter(a => a.questionId !== questionId);
     } else {
       // 拽 拽转 注  住驻转 转砖
       const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
       const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

       let updatedAnswer: JsonAnswerData;

       if (value.type === 'visibility') {
          if (!existingAnswer) return NextResponse.json({ success: false, error: " 爪 转砖 注 专转" }, { status: 404 });
          if (typeof value.isVisible !== 'boolean') return NextResponse.json({ success: false, error: "注专 专转  转拽" }, { status: 400 });
          updatedAnswer = { ...existingAnswer, isVisible: value.isVisible, answeredAt: new Date().toISOString() };
       } else if (value.type === 'answer') {
         if (value.value === undefined) return NextResponse.json({ success: false, error: "注专 转砖 住专" }, { status: 400 });
         updatedAnswer = {
           questionId,
           value: value.value as Prisma.JsonValue,
           isVisible: existingAnswer?.isVisible ?? true,
           answeredAt: new Date().toISOString()
         };
       } else {
           return NextResponse.json({ success: false, error: "住 注  转拽" }, { status: 400 });
       }

       updatedAnswers = [...currentAnswers];
       if (existingAnswerIndex !== -1) {
           updatedAnswers[existingAnswerIndex] = updatedAnswer;
       } else if (value.type === 'answer') {
           updatedAnswers.push(updatedAnswer);
       }
     }

     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });

     await prisma.profile.update({
       where: { userId },
       data: { needsAiProfileUpdate: true }
     });

    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach(key => {
       const currentDbKey = KEY_MAPPING[key];
        formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
    });

     const formattedResponse = {
       ...updated,
       formattedAnswers: formattedAnswers
     };

     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            return NextResponse.json({ success: false, error: "砖转 住 转" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           return NextResponse.json({ success: false, error: "祝 拽砖  JSON 转拽" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "砖 注 砖" }, { status: 500 });
   }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * GET - 专 爪转.
 * 拽  砖砖转 砖 转专砖:
 * 1.  砖 'userId' 驻专专: 专 爪转 *砖专转* 注专 驻专驻 爪专.
 * 2.   砖 'userId': 专 转 ** 爪转 注专 砖转砖 专,  砖  转.
 */
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');

  try {
    // 转专砖 1: 拽砖 爪转 爪转 驻专驻 砖 砖转砖 住驻爪驻 (爪驻 爪专转)
    if (userId) {
      const testimonials = await prisma.friendTestimonial.findMany({
        where: {
          profile: {
            userId: userId,
          },
          // 砖: 专 专拽 爪转 砖砖专 爪驻 爪专转
          status: 'APPROVED',
        },
        orderBy: {
          createdAt: 'desc',
        },
      });
      return NextResponse.json({ success: true, testimonials });
    }

    // 转专砖 2: 拽砖  爪转 砖 砖转砖 专 (转 注 驻专驻 砖)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const testimonials = await prisma.friendTestimonial.findMany({
      where: {
        profile: {
          userId: session.user.id,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, testimonials });
  } catch (error) {
    console.error('Error in GET /api/profile/testimonials:', error);
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}

/**
 * POST - 爪专 爪 砖 爪注转 拽 -驻注 .
 * 拽转 拽爪  砖砖转 转 驻住 爪专 砖专 .
 *   砖 拽砖专 砖砖 驻注 转 .
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      token,
      authorName,
      relationship,
      content,
      authorPhone,
      isPhoneVisibleToMatch,
    } = body;

    // 1. 爪 住住转 砖 砖转 
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields.' },
        { status: 400 }
      );
    }

    // 2. 砖砖 专拽爪   转.
    // 砖转 驻注转 (爪专转 爪 注 拽) 转 爪 .
    const result = await prisma.$transaction(async (tx) => {
      // 砖 ': 驻砖 转 拽砖转 拽.  转 转 拽转, 转拽祝 住住 PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() }, //  砖拽  驻 转拽祝
        },
      });

      //   爪 拽砖 转拽, 专拽 砖.   转 专拽爪 转.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // 砖 ': 爪专 转 专砖转 爪 住 转.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // 爪 砖 转 转 砖专 砖转砖
          submittedBy: 'FRIEND', // 住 砖爪 注 专
        },
      });

      // 砖 ': 拽专! 砖 转 住住 拽 -COMPLETED  注 砖砖 专.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    // 3.  专拽爪 爪, 专 转砖转 爪.
    if (result.success) {
      return NextResponse.json({
        success: true,
        message: 'Thank you! Your testimonial has been submitted.',
      });
    } else {
      // 爪   专 拽专转  拽转 专拽爪 
      throw new Error('Transaction failed unexpectedly.');
    }
  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);

    // 4. 驻 注 砖转 注转
    if (
      error instanceof Error &&
      error.message.includes('Invalid, expired, or already used link')
    ) {
      return NextResponse.json(
        {
          success: false,
          message:
            'This link is invalid, has expired, or has already been used.',
        },
        { status: 400 }
      );
    }

    // 5. 驻 砖转  爪驻转 专转
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
# Generated on: 2025-09-18 22:40:39
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

// GET all testimonials for the logged-in user
export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const testimonials = await prisma.friendTestimonial.findMany({
    where: { profileId: session.user.profile.id },
    orderBy: { createdAt: 'desc' },
  });

  return NextResponse.json({ success: true, testimonials });
}

// POST a new manual testimonial
export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }
  
  const body = await req.json();
  const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

  if (!authorName || !relationship || !content) {
    return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
  }

  const newTestimonial = await prisma.friendTestimonial.create({
    data: {
      profileId: session.user.profile.id,
      authorName,
      relationship,
      content,
      authorPhone: authorPhone || null,
      isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
      status: 'APPROVED', // Manual entries are pre-approved by the user
      submittedBy: 'USER',
    },
  });

  return NextResponse.json({ success: true, testimonial: newTestimonial }, { status: 201 });
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id, // Ensure ownership
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/testimonials/[token]/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { jwtVerify, JWTPayload } from 'jose'; //  JWTPayload 注专 专转

interface TokenPayload extends JWTPayload {
  profileId: string;
}

export async function POST(req: Request, { params }: { params: { token: string } }) {
  const { token } = params;
  if (!token) {
    return NextResponse.json({ success: false, message: 'Token is missing' }, { status: 400 });
  }

  const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
  if (!secret) {
      console.error("FATAL: NEXTAUTH_SECRET is not defined.");
      return NextResponse.json({ success: false, message: 'Server configuration error' }, { status: 500 });
  }

  try {
    // --- 砖 1: 驻专拽 转 专 (Casting) 砖 砖 ---
    // 砖 ': 转 拽  专拽
    const verificationResult = await jwtVerify(token, secret);
    
    // 砖 ': 专转 -payload 驻住 拽 砖.  驻转专 转 砖转 砖转.
    const payload = verificationResult.payload as TokenPayload;
    const { profileId } = payload;
    // --- 住祝 砖 ---
    
    const body = await req.json();
    const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    if (!authorName || !relationship || !content) {
      return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
    }

    await prisma.friendTestimonial.create({
      data: {
        profileId, // 注砖 TypeScript 注 砖 string
        authorName,
        relationship,
        content,
        authorPhone: authorPhone || null,
        isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
        status: 'PENDING',
        submittedBy: 'FRIEND',
      },
    });

    return NextResponse.json({ success: true, message: 'Testimonial submitted successfully' });

  } catch (error) {
    console.error("Error processing testimonial submission:", error);
    if (error instanceof Error && (error.name === 'JWTExpired' || error.name === 'JWSInvalid' || error.name === 'JOSEError')) {
        return NextResponse.json({ success: false, message: 'Link is invalid or has expired.' }, { status: 401 });
    }
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { SignJWT } from 'jose';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.profile?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized or profile not found' }, { status: 401 });
    }

    const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
    if (!secret) throw new Error("NEXTAUTH_SECRET is not defined.");

    const payload = {
      profileId: session.user.profile.id,
      userId: session.user.id, // Include userId for verification if needed
    };

    const token = await new SignJWT(payload)
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime('7d') // 拽砖专  转拽祝 砖注
      .sign(secret);

    const link = `${process.env.NEXT_PUBLIC_BASE_URL}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });

  } catch (error) {
    console.error("Error creating testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for testimonials_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id, // Ensure ownership
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { randomBytes } from 'crypto';

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Find the user's profile to link the request to
    const userProfile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found' }, { status: 404 });
    }

    // 1. Generate a secure, random token
    const token = randomBytes(32).toString('hex');

    // 2. Set an expiration date (e.g., 7 days from now)
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    // 3. Create the request record in the new database table
    await prisma.testimonialRequest.create({
      data: {
        token: token,
        expiresAt: expiresAt,
        profileId: userProfile.id, // Use the fetched profile ID
      },
    });

    // 4. Construct the full link to return to the client
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    const link = `${baseUrl}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });
  } catch (error) {
    console.error("Failed to create testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal server error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// File: app/api/profile/update/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  ReligiousJourney,
  Profile, // Import Prisma's Profile type
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

// Helper to convert to number or null
const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

// Helper to convert to Date or error if invalid for required fields
const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

// Helper to convert to Date or null for optional fields
const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

// Helper to convert empty string or null to null, otherwise return the string
const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};

export async function PUT(req: NextRequest) {
  // Apply rate limiting: 50 profile updates per user per 10 minutes (prevents DB heavy load)
  const rateLimitResponse = await applyRateLimit(req, { requests: 50, window: '10 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    let body;
    try {
      body = await req.json();
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      religiousJourney,
      about,
      profileHeadline,
      inspiringCoupleStory,
      influentialRabbi,
      isAboutVisible,
      isFriendsSectionVisible,
      isNeshamaTechSummaryVisible,
      parentStatus,
      fatherOccupation,
      motherOccupation,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious,
      profileCharacterTraits,
      profileHobbies,
      aliyaCountry,
      aliyaYear,
      // --- START: PREFERENCE FIELDS ---
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      preferredPartnerHasChildren,
      preferredCharacterTraits,
      preferredHobbies,
      preferredAliyaStatus,
      preferredReligiousJourneys,
      // --- END: PREFERENCE FIELDS ---
      hasViewedProfilePreview,
      hasMedicalInfo,
      medicalInfoDetails,
      medicalInfoDisclosureTiming,
      isMedicalInfoVisible,
    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status & Background (User's own) ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious;
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
    if (fatherOccupation !== undefined) dataToUpdate.fatherOccupation = emptyStringToNull(fatherOccupation);
    if (motherOccupation !== undefined) dataToUpdate.motherOccupation = emptyStringToNull(motherOccupation);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education, Occupation & Service (User's own) ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion & Lifestyle (User's own) ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
    if (religiousJourney !== undefined) dataToUpdate.religiousJourney = emptyStringToNull(religiousJourney) as ReligiousJourney | null;
    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (body.hasOwnProperty('kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (body.hasOwnProperty('headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits & Hobbies (User's own) ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || [];

    // --- About & Additional Info ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
    if (profileHeadline !== undefined) dataToUpdate.profileHeadline = emptyStringToNull(profileHeadline);
    if (inspiringCoupleStory !== undefined) dataToUpdate.inspiringCoupleStory = emptyStringToNull(inspiringCoupleStory);
    if (influentialRabbi !== undefined) dataToUpdate.influentialRabbi = emptyStringToNull(influentialRabbi);
    
    // --- Preferences (related to matching partner) ---
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    if (preferredReligiousJourneys !== undefined) dataToUpdate.preferredReligiousJourneys = preferredReligiousJourneys || [];
    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah);
    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredPartnerHasChildren !== undefined) dataToUpdate.preferredPartnerHasChildren = emptyStringToNull(preferredPartnerHasChildren);
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);
    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || [];
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || [];
    
    // --- Profile Management & Visibility ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
    if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
    if (isAboutVisible !== undefined) dataToUpdate.isAboutVisible = isAboutVisible;
    if (isFriendsSectionVisible !== undefined) dataToUpdate.isFriendsSectionVisible = isFriendsSectionVisible;
    if (isNeshamaTechSummaryVisible !== undefined) dataToUpdate.isNeshamaTechSummaryVisible = isNeshamaTechSummaryVisible;
   
    // --- Medical Info ---
    if (hasMedicalInfo !== undefined) dataToUpdate.hasMedicalInfo = hasMedicalInfo;
    if (medicalInfoDetails !== undefined) dataToUpdate.medicalInfoDetails = emptyStringToNull(medicalInfoDetails);
    if (medicalInfoDisclosureTiming !== undefined) dataToUpdate.medicalInfoDisclosureTiming = emptyStringToNull(medicalInfoDisclosureTiming);
    if (isMedicalInfoVisible !== undefined) dataToUpdate.isMedicalInfoVisible = isMedicalInfoVisible;

    // --- Availability ---
    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      if (!body.hasOwnProperty('availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    if (body.hasOwnProperty('availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // --- Perform the database update ---
    let updatedProfileRecord: Profile | null = null;
    if (Object.keys(dataToUpdate).length > 0) {
      try {
         dataToUpdate.needsAiProfileUpdate = true;
         
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
    
      } catch (dbError) {
        console.error('Prisma profile update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // Construct the response, ensuring all UserProfile fields are mapped
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, 
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney || undefined,
      about: dbProfile.about || "",
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: refreshedUserWithProfile.isProfileComplete,
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, 
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], 
      profileHobbies: dbProfile.profileHobbies || [],                 
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredLocations: dbProfile.preferredLocations || [],
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], 
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredPartnerHasChildren: dbProfile.preferredPartnerHasChildren || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], 
      preferredHobbies: dbProfile.preferredHobbies || [],                 
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, 
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('Profile update route error:', error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\questionnaire_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
# Generated on: 2025-10-03 13:47:59
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\questionnaire_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/questionnaire/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
export const dynamic = 'force-dynamic';
function isPrismaError(
  error: unknown
): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

const WORLD_IDS = [
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
] as const;

const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const baseAnswerSchema = z.object({
  questionId: z.string().min(1),
  worldId: WorldId,
  // --- 注 砖 value ---
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
    z.object({ // 住驻转 拽 砖 住
      text: z.string(),
      lang: z.string(),
    }),
  ]),

  answeredAt: z.string().datetime(),
  isVisible: z.boolean().optional().default(true), // 住驻转 砖 砖 注 专专转 
});

type QuestionAnswer = z.infer<typeof baseAnswerSchema>;

const QuestionnaireAnswer = baseAnswerSchema;

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional(),
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

function groupAnswersByWorld(answers: QuestionnaireSubmission['answers']) {
  return answers.reduce<Record<string, QuestionAnswer[]>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer: QuestionAnswer = {
      questionId: answer.questionId,
      worldId: answer.worldId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      isVisible: answer.isVisible, // 注专转 砖
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);

    return acc;
  }, {});
}

function validateSubmissionData(
  data: unknown
): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);

  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '专砖转 转专转' }, { status: 401 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    const transformedData = questionnaire
      ? {
          ...questionnaire,
          valuesAnswers: questionnaire.valuesAnswers || [],
          personalityAnswers: questionnaire.personalityAnswers || [],
          relationshipAnswers: questionnaire.relationshipAnswers || [],
          partnerAnswers: questionnaire.partnerAnswers || [],
          religionAnswers: questionnaire.religionAnswers || [],
        }
      : null;

    return NextResponse.json({
      success: true,
      data: transformedData,
    });
  } catch (error: unknown) {
    console.error('Error fetching questionnaire:', {
      message: isError(error) ? error.message : 'Unknown error occurred',
      stack: process.env.NODE_ENV === 'development' ? error : undefined,
    });

    return NextResponse.json(
      {
        error: '专注 砖 注转 砖',
        details: process.env.NODE_ENV === 'development' ? error : undefined,
      },
      { status: 500 }
    );
  }
}

type Answer = {
  questionId: string;
  worldId: WorldId;
  value: string | number | string[] | number[] | Record<string, number> | { text: string; lang: string };
  answeredAt: string;
  isVisible?: boolean; // 住驻转 砖
};

type MergedAnswers = {
  valuesAnswers: Answer[];
  personalityAnswers: Answer[];
  relationshipAnswers: Answer[];
  partnerAnswers: Answer[];
  religionAnswers: Answer[];
};

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '专砖转 转专转' }, { status: 401 });
    }

    const rawBody = await req.json();

    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json({ error: '砖转砖  爪' }, { status: 404 });
    }

    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers:
        rawBody.answers?.filter(
          (answer: Answer) =>
            answer &&
            answer.questionId &&
            answer.worldId &&
            answer.value !== undefined &&
            answer.value !== null &&
            answer.value !== ''
        ) ?? [],
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json(
        {
          error: '砖转 爪',
          details: isError(error) ? error.message : 'Unknown validation error',
        },
        { status: 400 }
      );
    }

    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    const result = await prisma.$transaction(async (prisma) => {
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' },
      });

      const mergedAnswers: MergedAnswers = {
        valuesAnswers: [
          ...((existingResponse?.valuesAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.valuesAnswers || []),
        ],
        personalityAnswers: [
          ...((existingResponse?.personalityAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.personalityAnswers || []),
        ],
        relationshipAnswers: [
          ...((existingResponse?.relationshipAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.relationshipAnswers || []),
        ],
        partnerAnswers: [
          ...((existingResponse?.partnerAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.partnerAnswers || []),
        ],
        religionAnswers: [
          ...((existingResponse?.religionAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.religionAnswers || []),
        ],
      };

      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof MergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce(
            (acc: Answer[], curr: Answer) => {
              const existingIndex = acc.findIndex(
                (a) => a.questionId === curr.questionId
              );
              if (existingIndex >= 0) {
                if (
                  new Date(curr.answeredAt) >
                  new Date(acc[existingIndex].answeredAt)
                ) {
                  acc[existingIndex] = curr;
                }
              } else {
                acc.push(curr);
              }
              return acc;
            },
            []
          );
          mergedAnswers[worldKey as keyof MergedAnswers] = uniqueAnswers;
        }
      }

      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          lastSaved: new Date(),
        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          lastSaved: new Date(),
        },
      });

      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: 'ACTIVE' },
        });
      }

      return savedQuestionnaire;
    });

    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error: unknown) {
    const errorMessage = isError(error)
      ? error.message
      : 'Unknown error occurred';
    const errorStack = isError(error) ? error.stack : undefined;

    console.error('Error details:', {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined,
    });

    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json(
            {
              error: '砖 砖专转 砖 - 砖转砖  拽',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 400 }
          );
        case 'P2002':
          return NextResponse.json(
            {
              error: '砖 砖专转 砖 - 专砖 专 拽转',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 409 }
          );
        default:
          return NextResponse.json(
            {
              error: '砖 砖专转 砖',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 500 }
          );
      }
    }

    return NextResponse.json(
      {
        error: '专注 砖 砖专转 砖',
        details:
          process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "专砖转 转专转" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const requiredWorlds = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;
    const allWorldsCompleted = requiredWorlds.every(
      world => validatedData.worldsCompleted.includes(world)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "  注转 砖"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: " 爪 砖 砖"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
      prisma.user.update({
        where: { id: session.user.id },
        data: { status: "ACTIVE" }
      })
    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "砖转 爪",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "专注 砖 砖转 砖"
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/questionnaire/world/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
import { updateUserAiProfile } from '@/lib/services/profileAiService';

const WorldId = z.enum([
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
]);
type WorldId = z.infer<typeof WorldId>;

const answerSchema = z.object({
  questionId: z.string().min(1),
  value: z
    .union([
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined(),
    ])
    .optional(),
  answeredAt: z
    .string()
    .datetime()
    .transform((str) => new Date(str)),
  isVisible: z.boolean().optional().default(true), // 住驻转 砖
});

const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(answerSchema),
});

type AnswerPayload = z.infer<typeof answerSchema>;

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const body = await req.json();
    const validationResult = worldAnswersSchema.safeParse(body);
    if (!validationResult.success) {
      console.error(
        'Validation error in /questionnaire/world:',
        validationResult.error
      );
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.flatten(),
        },
        { status: 400 }
      );
    }
    const { worldId, answers: newAnswers } = validationResult.data;

    const dbAnswersKey =
      `${worldId.toLowerCase()}Answers` as keyof Prisma.QuestionnaireResponseCreateInput;
    const dbCompletedKey =
      `${worldId.toLowerCase()}Completed` as keyof Prisma.QuestionnaireResponseCreateInput;

    const updatedQuestionnaire = await prisma.$transaction(async (tx) => {
      const existingResponse = await tx.questionnaireResponse.findFirst({
        where: { userId },
      });
   await tx.profile.update({
        where: { userId },
        data: { needsAiProfileUpdate: true }
      });
      const newAnswersJson = newAnswers.map((ans) => ({
        ...ans,
        answeredAt: ans.answeredAt.toISOString(),
      })) as unknown as Prisma.JsonArray;

      const questionnaire = await tx.questionnaireResponse.upsert({
        where: { id: existingResponse?.id || 'new-response-placeholder' },
        create: {
          userId,
          startedAt: new Date(),
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: [worldId],
        },
        update: {
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: {
            push: worldId,
          },
        },
      });
      return questionnaire;
    });

    return NextResponse.json({
      success: true,
      message: `Successfully saved answers for world: ${worldId}`,
      data: updatedQuestionnaire,
    });
  } catch (error: unknown) {
    console.error('Error in PUT /api/questionnaire/world:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }

    const errorMessage =
      error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for questionnaire_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/questionnaire/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
export const dynamic = 'force-dynamic';
function isPrismaError(
  error: unknown
): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

const WORLD_IDS = [
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
] as const;

const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const baseAnswerSchema = z.object({
  questionId: z.string().min(1),
  worldId: WorldId,
  // --- 注 砖 value ---
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
    z.object({ // 住驻转 拽 砖 住
      text: z.string(),
      lang: z.string(),
    }),
  ]),

  answeredAt: z.string().datetime(),
  isVisible: z.boolean().optional().default(true), // 住驻转 砖 砖 注 专专转 
});

type QuestionAnswer = z.infer<typeof baseAnswerSchema>;

const QuestionnaireAnswer = baseAnswerSchema;

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional(),
  currentQuestionIndices: z.record(WorldId, z.number()).optional(), // <--- 住祝 转 砖专 
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

function groupAnswersByWorld(answers: QuestionnaireSubmission['answers']) {
  return answers.reduce<Record<string, QuestionAnswer[]>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer: QuestionAnswer = {
      questionId: answer.questionId,
      worldId: answer.worldId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      isVisible: answer.isVisible, // 注专转 砖
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);

    return acc;
  }, {});
}

function validateSubmissionData(
  data: unknown
): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);

  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '专砖转 转专转' }, { status: 401 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    const transformedData = questionnaire
      ? {
          ...questionnaire,
          valuesAnswers: questionnaire.valuesAnswers || [],
          personalityAnswers: questionnaire.personalityAnswers || [],
          relationshipAnswers: questionnaire.relationshipAnswers || [],
          partnerAnswers: questionnaire.partnerAnswers || [],
          religionAnswers: questionnaire.religionAnswers || [],
        }
      : null;

    return NextResponse.json({
      success: true,
      data: transformedData,
    });
  } catch (error: unknown) {
    console.error('Error fetching questionnaire:', {
      message: isError(error) ? error.message : 'Unknown error occurred',
      stack: process.env.NODE_ENV === 'development' ? error : undefined,
    });

    return NextResponse.json(
      {
        error: '专注 砖 注转 砖',
        details: process.env.NODE_ENV === 'development' ? error : undefined,
      },
      { status: 500 }
    );
  }
}

type Answer = {
  questionId: string;
  worldId: WorldId;
  value: string | number | string[] | number[] | Record<string, number> | { text: string; lang: string };
  answeredAt: string;
  isVisible?: boolean; // 住驻转 砖
};

type MergedAnswers = {
  valuesAnswers: Answer[];
  personalityAnswers: Answer[];
  relationshipAnswers: Answer[];
  partnerAnswers: Answer[];
  religionAnswers: Answer[];
};

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '专砖转 转专转' }, { status: 401 });
    }

    const rawBody = await req.json();

    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json({ error: '砖转砖  爪' }, { status: 404 });
    }

    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers:
        rawBody.answers?.filter(
          (answer: Answer) =>
            answer &&
            answer.questionId &&
            answer.worldId &&
            answer.value !== undefined &&
            answer.value !== null &&
            answer.value !== ''
        ) ?? [],
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json(
        {
          error: '砖转 爪',
          details: isError(error) ? error.message : 'Unknown validation error',
        },
        { status: 400 }
      );
    }

    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    const result = await prisma.$transaction(async (prisma) => {
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' },
      });

      const mergedAnswers: MergedAnswers = {
        valuesAnswers: [
          ...((existingResponse?.valuesAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.valuesAnswers || []),
        ],
        personalityAnswers: [
          ...((existingResponse?.personalityAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.personalityAnswers || []),
        ],
        relationshipAnswers: [
          ...((existingResponse?.relationshipAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.relationshipAnswers || []),
        ],
        partnerAnswers: [
          ...((existingResponse?.partnerAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.partnerAnswers || []),
        ],
        religionAnswers: [
          ...((existingResponse?.religionAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.religionAnswers || []),
        ],
      };

      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof MergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce(
            (acc: Answer[], curr: Answer) => {
              const existingIndex = acc.findIndex(
                (a) => a.questionId === curr.questionId
              );
              if (existingIndex >= 0) {
                if (
                  new Date(curr.answeredAt) >
                  new Date(acc[existingIndex].answeredAt)
                ) {
                  acc[existingIndex] = curr;
                }
              } else {
                acc.push(curr);
              }
              return acc;
            },
            []
          );
          mergedAnswers[worldKey as keyof MergedAnswers] = uniqueAnswers;
        }
      }

      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
           currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),

        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),
        },
      });

      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: 'ACTIVE' },
        });
      }

      return savedQuestionnaire;
    });

    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error: unknown) {
    const errorMessage = isError(error)
      ? error.message
      : 'Unknown error occurred';
    const errorStack = isError(error) ? error.stack : undefined;

    console.error('Error details:', {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined,
    });

    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json(
            {
              error: '砖 砖专转 砖 - 砖转砖  拽',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 400 }
          );
        case 'P2002':
          return NextResponse.json(
            {
              error: '砖 砖专转 砖 - 专砖 专 拽转',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 409 }
          );
        default:
          return NextResponse.json(
            {
              error: '砖 砖专转 砖',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 500 }
          );
      }
    }

    return NextResponse.json(
      {
        error: '专注 砖 砖专转 砖',
        details:
          process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "专砖转 转专转" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const requiredWorlds = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;
    const allWorldsCompleted = requiredWorlds.every(
      world => validatedData.worldsCompleted.includes(world)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "  注转 砖"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: " 爪 砖 砖"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
      prisma.user.update({
        where: { id: session.user.id },
        data: { status: "ACTIVE" }
      })
    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "砖转 爪",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "专注 砖 砖转 砖"
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/questionnaire/world/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
import { updateUserAiProfile } from '@/lib/services/profileAiService';

const WorldId = z.enum([
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
]);
type WorldId = z.infer<typeof WorldId>;

const answerSchema = z.object({
  questionId: z.string().min(1),
  value: z
    .union([
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined(),
    ])
    .optional(),
  answeredAt: z
    .string()
    .datetime()
    .transform((str) => new Date(str)),
  isVisible: z.boolean().optional().default(true), // 住驻转 砖
});

const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(answerSchema),
});

type AnswerPayload = z.infer<typeof answerSchema>;

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const body = await req.json();
    const validationResult = worldAnswersSchema.safeParse(body);
    if (!validationResult.success) {
      console.error(
        'Validation error in /questionnaire/world:',
        validationResult.error
      );
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.flatten(),
        },
        { status: 400 }
      );
    }
    const { worldId, answers: newAnswers } = validationResult.data;

    const dbAnswersKey =
      `${worldId.toLowerCase()}Answers` as keyof Prisma.QuestionnaireResponseCreateInput;
    const dbCompletedKey =
      `${worldId.toLowerCase()}Completed` as keyof Prisma.QuestionnaireResponseCreateInput;

    const updatedQuestionnaire = await prisma.$transaction(async (tx) => {
      const existingResponse = await tx.questionnaireResponse.findFirst({
        where: { userId },
      });
   await tx.profile.update({
        where: { userId },
        data: { needsAiProfileUpdate: true }
      });
      const newAnswersJson = newAnswers.map((ans) => ({
        ...ans,
        answeredAt: ans.answeredAt.toISOString(),
      })) as unknown as Prisma.JsonArray;

      const questionnaire = await tx.questionnaireResponse.upsert({
        where: { id: existingResponse?.id || 'new-response-placeholder' },
        create: {
          userId,
          startedAt: new Date(),
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: [worldId],
        },
        update: {
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: {
            push: worldId,
          },
        },
      });
      return questionnaire;
    });

    return NextResponse.json({
      success: true,
      message: `Successfully saved answers for world: ${worldId}`,
      data: updatedQuestionnaire,
    });
  } catch (error: unknown) {
    console.error('Error in PUT /api/questionnaire/world:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }

    const errorMessage =
      error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.string().refine((val) => !isNaN(Date.parse(val)), { // Validate as date string
    message: "Invalid date format for decisionDeadline",
  }).transform((val) => new Date(val)), // Transform to Date object
});

export async function POST(req: NextRequest) {
  // Apply rate limiting: 30 new suggestions per matchmaker per hour (safety net)
  const rateLimitResponse = await applyRateLimit(req, { requests: 30, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) { // Check for user.id and user.role
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for POST ----
    // 2. Role verification (only matchmakers or admins can create suggestions)
    const allowedCreatorRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedCreatorRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to create suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE for POST ----

    // 3. Parse and validate request body
    const body = await req.json();
    const validationResult = createSuggestionSchema.safeParse(body);

    if (!validationResult.success) {
        return NextResponse.json(
            { error: "Validation error", details: validationResult.error.errors },
            { status: 400 }
        );
    }
    const validatedData = validationResult.data;


    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
                MatchSuggestionStatus.FIRST_PARTY_DECLINED, // Added
                MatchSuggestionStatus.SECOND_PARTY_DECLINED, // Added
                MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // Added
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: `Active or pending suggestion (ID: ${existingSuggestion.id}, Status: ${existingSuggestion.status}) already exists between these parties` },
        { status: 409 } // Conflict
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id, // The user creating is the matchmaker
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline,
          firstPartySent: new Date(),
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Initialize lastActivity
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion); // Consider passing the full suggestion object

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion, // Return the created suggestion object
    }, { status: 201 }); // HTTP 201 Created
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    // Handle Prisma unique constraint errors specifically if needed
    // if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {}
    
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for PATCH (General permission) ----
    const allowedUpdaterRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN, UserRole.CANDIDATE]; // CANDIDATE can update if they are a party
    if (!allowedUpdaterRoles.includes(session.user.role as UserRole)) {
        return NextResponse.json({ error: "Forbidden - Insufficient permissions to update suggestion status" }, { status: 403 });
    }
    // ---- END OF CHANGE for PATCH ----

    const body = await req.json();
    const { suggestionId, status, notes } = body; // Assuming status and notes are part of body

    // Validate incoming data (basic example)
    if (!suggestionId || !status) {
        return NextResponse.json({ error: "Missing suggestionId or status" }, { status: 400 });
    }
    if (!Object.values(MatchSuggestionStatus).includes(status as MatchSuggestionStatus)) {
        return NextResponse.json({ error: "Invalid status value" }, { status: 400 });
    }


    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true, // Include matchmaker for permission checks
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // ---- Specific permission check for PATCH ----
    // An ADMIN can update any suggestion.
    // A MATCHMAKER can update suggestions they created.
    // A CANDIDATE can update suggestions they are a party to (firstPartyId or secondPartyId).
    const isUserAdmin = session.user.role === UserRole.ADMIN;
    const isUserMatchmakerOwner = session.user.role === UserRole.MATCHMAKER && suggestion.matchmakerId === session.user.id;
    const isUserParty = session.user.role === UserRole.CANDIDATE && (suggestion.firstPartyId === session.user.id || suggestion.secondPartyId === session.user.id);

    if (!isUserAdmin && !isUserMatchmakerOwner && !isUserParty) {
        return NextResponse.json({ error: "Forbidden - You do not have permission to update this specific suggestion's status." }, { status: 403 });
    }
    // ---- End specific permission check ----


    // 3. Validate status transition (using your existing helper)
    const isValidTransition = validateStatusTransition(suggestion.status, status as MatchSuggestionStatus);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: `Invalid status transition from ${suggestion.status} to ${status}` },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status as MatchSuggestionStatus,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Update lastActivity
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            // closedAt: new Date(), // Typically, CONTACT_DETAILS_SHARED doesn't mean closed
          }),
          ...(status === MatchSuggestionStatus.CLOSED && { // Explicitly set closedAt for CLOSED status
            closedAt: new Date(),
          }),
        },
      });

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status: status as MatchSuggestionStatus,
          notes: notes || `Status changed to ${status} by user ${session.user.id}`, // Add more context to notes
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    // This logic might be better suited in a service layer or triggered by events
    // For example, if status is FIRST_PARTY_APPROVED, you might automatically transition to PENDING_SECOND_PARTY
    // and send notifications.
    // if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
    //   // TODO: Transition to PENDING_SECOND_PARTY and notify
    // } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
    //   // TODO: Transition to CONTACT_DETAILS_SHARED and notify
    // }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    if (error instanceof z.ZodError) { // Handle Zod validation errors if you add more validation
        return NextResponse.json(
            { error: "Validation error for status update", details: error.errors },
            { status: 400 }
        );
    }
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY, MatchSuggestionStatus.CANCELLED],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL, // Often matchmaker confirms before sharing
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED, // Or directly share
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [ // Matchmaker action after both parties approve
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.MATCH_DECLINED, // Matchmaker can decide not to proceed
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.MEETING_PENDING, // Or AWAITING_FIRST_DATE_FEEDBACK
        MatchSuggestionStatus.DATING, // If they skip formal feedback and start dating
        MatchSuggestionStatus.CLOSED, // If one party decides not to proceed after contact
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE, // If feedback leads to this
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [ // This might be too granular, DATNG might cover it
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK, // For feedback after 2nd date etc.
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // If it ends after 2nd date
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [ // This status might be redundant if AWAITING_FIRST_DATE_FEEDBACK is used
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [ // Similar to MEETING_PENDING
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [ // This is often equivalent to CONTACT_DETAILS_SHARED or DATNG
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENGAGED, // Could jump here
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED, // If dating ends
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CLOSED, // If engagement breaks
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [MatchSuggestionStatus.CLOSED], // Or just stay MARRIE
    EXPIRED: [MatchSuggestionStatus.CLOSED],
    CLOSED: [], // No transitions from CLOSED typically, except maybe reopening
    CANCELLED: [MatchSuggestionStatus.CLOSED] // Or just stay CANCELLED
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// 转拽 拽抓 src/app/api/matchmaker/suggestions/[id]/route.ts -  any

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole, Priority, Prisma } from "@prisma/client";
import prisma from "@/lib/prisma";

// 专转 驻住 转 住
interface SuggestionUpdateData {
  priority?: Priority;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: string | null;
}

// 专转 驻住 转 注 砖 Prisma
interface PrismaUpdateData {
  lastActivity: Date;
  priority?: Priority;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: Date | null;
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    //  砖转砖 专
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    //  专砖转 砖  
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const suggestionId = params.id;
    const data: SuggestionUpdateData = await req.json();
    
    console.log("PATCH request for suggestion:", suggestionId, "with data:", data);

    // 拽转 拽 爪注 专砖转
    const existingSuggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      select: {
        id: true,
        matchmakerId: true,
        status: true
      }
    });

    if (!existingSuggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 拽转 专砖转 住驻爪驻转
    if (existingSuggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to edit this suggestion" },
        { status: 403 }
      );
    }

    // 转 转 注 注 驻住 拽
    const updateData: PrismaUpdateData = {
      lastActivity: new Date(),
    };

    // 注 砖转  拽
    if (data.priority !== undefined) {
      updateData.priority = data.priority;
    }

    if (data.matchingReason !== undefined) {
      updateData.matchingReason = data.matchingReason;
    }

    if (data.firstPartyNotes !== undefined) {
      updateData.firstPartyNotes = data.firstPartyNotes;
    }

    if (data.secondPartyNotes !== undefined) {
      updateData.secondPartyNotes = data.secondPartyNotes;
    }

    if (data.internalNotes !== undefined) {
      updateData.internalNotes = data.internalNotes;
    }

    if (data.decisionDeadline !== undefined) {
      updateData.decisionDeadline = data.decisionDeadline ? new Date(data.decisionDeadline) : null;
    }

    console.log("Updating suggestion with data:", updateData);

    // 爪注 注
    const updatedSuggestion = await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: updateData,
      include: {
        firstParty: {
          select: { 
            id: true, 
            firstName: true, 
            lastName: true,
            images: { 
              select: { id: true, url: true, isMain: true }, 
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] 
            }, 
            profile: true 
          }
        },
        secondParty: {
          select: { 
            id: true, 
            firstName: true, 
            lastName: true,
            images: { 
              select: { id: true, url: true, isMain: true }, 
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] 
            }, 
            profile: true 
          }
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true }
        },
        statusHistory: { 
          orderBy: { createdAt: 'desc' } 
        }
      }
    });

    console.log("Suggestion updated successfully:", updatedSuggestion.id);
    if (updatedSuggestion.firstParty.profile && !updatedSuggestion.firstParty.profile.isMedicalInfoVisible) {
      updatedSuggestion.firstParty.profile.medicalInfoDetails = null; //  undefined
    }
    if (updatedSuggestion.secondParty.profile && !updatedSuggestion.secondParty.profile.isMedicalInfoVisible) {
      updatedSuggestion.secondParty.profile.medicalInfoDetails = null; //  undefined
    }
    // 驻专 转专 -ISO strings
    const formattedSuggestion = {
      ...updatedSuggestion,
      firstParty: {
        ...updatedSuggestion.firstParty,
        profile: updatedSuggestion.firstParty.profile ? {
          ...updatedSuggestion.firstParty.profile,
          birthDate: updatedSuggestion.firstParty.profile.birthDate?.toISOString(),
          lastActive: updatedSuggestion.firstParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: updatedSuggestion.firstParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: updatedSuggestion.firstParty.profile.createdAt?.toISOString(),
          updatedAt: updatedSuggestion.firstParty.profile.updatedAt?.toISOString()
        } : null
      },
      secondParty: {
        ...updatedSuggestion.secondParty,
        profile: updatedSuggestion.secondParty.profile ? {
          ...updatedSuggestion.secondParty.profile,
          birthDate: updatedSuggestion.secondParty.profile.birthDate?.toISOString(),
          lastActive: updatedSuggestion.secondParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: updatedSuggestion.secondParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: updatedSuggestion.secondParty.profile.createdAt?.toISOString(),
          updatedAt: updatedSuggestion.secondParty.profile.updatedAt?.toISOString()
        } : null
      },
      statusHistory: updatedSuggestion.statusHistory.map(history => ({
        ...history,
        createdAt: history.createdAt.toISOString()
      })),
      responseDeadline: updatedSuggestion.responseDeadline?.toISOString(),
      decisionDeadline: updatedSuggestion.decisionDeadline?.toISOString(),
      lastStatusChange: updatedSuggestion.lastStatusChange?.toISOString(),
      firstPartySent: updatedSuggestion.firstPartySent?.toISOString(),
      firstPartyResponded: updatedSuggestion.firstPartyResponded?.toISOString(),
      secondPartySent: updatedSuggestion.secondPartySent?.toISOString(),
      secondPartyResponded: updatedSuggestion.secondPartyResponded?.toISOString(),
      firstMeetingScheduled: updatedSuggestion.firstMeetingScheduled?.toISOString(),
      closedAt: updatedSuggestion.closedAt?.toISOString(),
      createdAt: updatedSuggestion.createdAt.toISOString(),
      updatedAt: updatedSuggestion.updatedAt.toISOString(),
      lastActivity: updatedSuggestion.lastActivity.toISOString()
    };
      
    return NextResponse.json({
      success: true,
      data: formattedSuggestion
    });
      
  } catch (error) {
    console.error("Error updating suggestion:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest, // req is not used, can be removed if not needed
  context: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const suggestionId = context.params.id;

    // 拽 砖爪注 拽转
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // ---- START OF CHANGE ----
    // 专砖转:
    // 1.   拽  爪注.
    // 2. 砖  拽 专拽 爪注 砖 爪专.
    const userRole = session.user.role as UserRole;
    const isOwner = suggestion.matchmakerId === session.user.id;

    if (userRole === UserRole.ADMIN) {
      // Admin can delete any suggestion
    } else if (userRole === UserRole.MATCHMAKER && isOwner) {
      // Matchmaker can delete their own suggestion
    } else {
      // Any other case is forbidden
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to delete this suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE ----

    // 拽转 爪注  转 拽砖专  ( 砖-onDelete: Cascade 专 住  专)
    //   Cascade, 砖 拽 专砖转 拽砖专转 转 拽.
    // 住专  砖 专    Cascade 注 .
    await prisma.$transaction(async (tx) => { // Changed to async for await inside
      // 拽转 住专转 住住
      await tx.suggestionStatusHistory.deleteMany({
        where: { suggestionId },
      });
      // 拽转 砖转
      await tx.suggestionInquiry.deleteMany({
        where: { suggestionId },
      });
      // 拽转 驻砖转 ( 拽转 拽砖专转 砖专转)
      await tx.meeting.deleteMany({
        where: { suggestionId },
      });
      // Consider other related data like DateFeedback
      await tx.dateFeedback.deleteMany({
        where: { suggestionId },
      });

      // 住专转 拽砖专 转 拽砖专 专-专 ( 砖)
      // ,  砖 拽砖专 approvedBy, reviewedBy -MatchSuggestion
      await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          approvedBy: { set: [] }, // Assuming relation exists
          reviewedBy: { set: [] }, // Assuming relation exists
        }
      });
      
      // 拽转 爪注 注爪
      await tx.matchSuggestion.delete({
        where: { id: suggestionId },
      });
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully",
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    // Consider more specific error handling (e.g., Prisma errors)
    return NextResponse.json(
      { error: "Internal server error during suggestion deletion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/inquiries/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { InquiryStatus, UserRole } from "@prisma/client";
import type { Session } from "next-auth";

type AuthSession = Session | null;

async function checkPermissions(suggestionId: string, session: AuthSession) {
  if (!session?.user?.id) {
    throw new Error("Unauthorized");
  }

  const suggestion = await prisma.matchSuggestion.findUnique({
    where: { id: suggestionId },
    select: { firstPartyId: true, secondPartyId: true, matchmakerId: true },
  });

  if (!suggestion) {
    throw new Error("Suggestion not found");
  }

  const isAuthorized =
    session.user.id === suggestion.firstPartyId ||
    session.user.id === suggestion.secondPartyId ||
    session.user.id === suggestion.matchmakerId ||
    session.user.role === UserRole.ADMIN;

  if (!isAuthorized) {
    throw new Error("Forbidden");
  }

  return { suggestion, userId: session.user.id, userRole: session.user.role as UserRole };
}

/**
 * GET: Fetch all inquiries for a specific suggestion.
 * Users can only see inquiries for suggestions they are a part of.
 */
export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    await checkPermissions(params.id, session);

    const inquiries = await prisma.suggestionInquiry.findMany({
      where: { suggestionId: params.id },
      include: {
        fromUser: { select: { id: true, firstName: true, lastName: true } },
        toUser: { select: { id: true, firstName: true, lastName: true } },
      },
      orderBy: { createdAt: "asc" },
    });

    return NextResponse.json({ success: true, inquiries });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error fetching inquiries:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * POST: Create a new inquiry (question) for a suggestion.
 * A user (candidate) sends a question to the matchmaker.
 */
export async function POST(req: NextRequest, { params }: { params: { id: string } }) {
  // Apply rate limiting: 20 inquiries per user per hour (prevents matchmaker spam)
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    const { suggestion, userId } = await checkPermissions(params.id, session);

    const { question } = await req.json();
    if (!question || typeof question !== 'string' || question.trim().length === 0) {
      return NextResponse.json({ error: "Question content is required" }, { status: 400 });
    }

    // --- START OF MODIFICATION ---
    // Perform both operations in a single transaction
    const inquiry = await prisma.$transaction(async (tx) => {
      // 1. Create the new inquiry
      const newInquiry = await tx.suggestionInquiry.create({
        data: {
          suggestionId: params.id,
          fromUserId: userId,
          toUserId: suggestion.matchmakerId, // Questions always go to the matchmaker
          question,
          status: InquiryStatus.PENDING,
        },
      });

      // 2. Update the parent suggestion's lastActivity timestamp
      await tx.matchSuggestion.update({
        where: { id: params.id },
        data: { lastActivity: new Date() },
      });

      return newInquiry;
    });
    // --- END OF MODIFICATION ---
    
    // TODO: Add notification to matchmaker about the new question

    return NextResponse.json({ success: true, inquiry });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error creating inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * PATCH: Answer an inquiry.
 * Only the matchmaker (or an admin) can answer an inquiry.
 */
export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const { userRole, userId } = await checkPermissions(params.id, session); // params.id is suggestionId

    if (userRole !== UserRole.MATCHMAKER && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: Only matchmakers or admins can answer inquiries." }, { status: 403 });
    }

    const { inquiryId, answer } = await req.json();
    if (!inquiryId || !answer || typeof answer !== 'string' || answer.trim().length === 0) {
      return NextResponse.json({ error: "Inquiry ID and answer content are required" }, { status: 400 });
    }

    const inquiryToUpdate = await prisma.suggestionInquiry.findUnique({
        where: { id: inquiryId },
    });

    if (!inquiryToUpdate) {
        return NextResponse.json({ error: "Inquiry not found." }, { status: 404 });
    }

    if (inquiryToUpdate.toUserId !== userId && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: You are not the recipient of this inquiry." }, { status: 403 });
    }

    // --- START OF MODIFICATION ---
    // Perform both operations in a single transaction
    const updatedInquiry = await prisma.$transaction(async (tx) => {
      // 1. Update the inquiry with the answer
      const inquiry = await tx.suggestionInquiry.update({
        where: { id: inquiryId },
        data: {
          answer,
          status: InquiryStatus.ANSWERED,
          answeredAt: new Date(),
        },
      });

      // 2. Update the parent suggestion's lastActivity timestamp
      await tx.matchSuggestion.update({
        where: { id: params.id }, // params.id is the suggestionId
        data: { lastActivity: new Date() },
      });

      return inquiry;
    });
    // --- END OF MODIFICATION ---
    
    // TODO: Add notification to the user who asked the question

    return NextResponse.json({ success: true, inquiry: updatedInquiry });
  } catch (error) {
     if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error answering inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries\mark-as-read
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries\mark-as-read\route.ts
--------------------------------------------------------------------------------
Content:
// FILENAME: src/app/api/suggestions/[id]/inquiries/mark-as-read/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

// This endpoint will mark all PENDING inquiries for a specific suggestion as ANSWERED (or a new status like VIEWED)
// when the recipient (matchmaker) opens the chat.

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const suggestionId = params.id;
    const userId = session.user.id;

    // We only mark messages as read if the current user is the recipient.
    // We change the status from PENDING to ANSWERED, assuming that viewing it
    // implies the matchmaker will now answer. A more robust solution might
    // add a 'VIEWED' status, but for now, this simplifies the flow.
    const updateResult = await prisma.suggestionInquiry.updateMany({
      where: {
        suggestionId: suggestionId,
        toUserId: userId, // Only update messages sent TO me
        status: 'PENDING',
      },
      data: {
        // Here we can choose to just mark it as ANSWERED or add a new logic.
        // For simplicity, let's assume viewing means it's being handled.
        // A better approach might be to just have a `readAt` field.
        // Let's stick to the current schema and move it to ANSWERED.
        // NOTE: This is a simplification. The best way is to have a dedicated `isRead` flag.
        // But to avoid schema changes, we will consider it "answered" when viewed by matchmaker.
        // A better flow would be to change status to 'VIEWED' and have a separate 'ANSWERED'
        status: 'ANSWERED', // A simplification: assumes viewing = handling.
      },
    });

    return NextResponse.json({ success: true, count: updateResult.count });

  } catch (error) {
    console.error("Error marking inquiries as read:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";
import { MatchSuggestionStatus, MatchSuggestion, UserRole } from "@prisma/client";
// 砖专转 专 砖驻 拽,  拽专 砖专转 注专
import { suggestionService } from "@/components/matchmaker/suggestions/services/suggestions/SuggestionService";
import { getDictionary } from "@/lib/dictionaries";
import { EmailDictionary } from "@/types/dictionary";

// 住转 爪 祝 拽砖
const statusUpdateSchema = z.object({
  status: z.enum([
    "DRAFT", "PENDING_FIRST_PARTY", "FIRST_PARTY_APPROVED", "FIRST_PARTY_DECLINED", 
    "PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "SECOND_PARTY_DECLINED", 
    "AWAITING_MATCHMAKER_APPROVAL", "CONTACT_DETAILS_SHARED", "AWAITING_FIRST_DATE_FEEDBACK", 
    "THINKING_AFTER_DATE", "PROCEEDING_TO_SECOND_DATE", "ENDED_AFTER_FIRST_DATE", 
    "MEETING_PENDING", "MEETING_SCHEDULED", "MATCH_APPROVED", "MATCH_DECLINED", 
    "DATING", "ENGAGED", "MARRIED", "EXPIRED", "CLOSED", "CANCELLED"
  ] as const),
  notes: z.string().optional(),
  feedback: z.string().optional(),
  meetingDate: z.string().optional(),
  customMessage: z.string().optional(),
});

export async function PATCH(
  req: NextRequest,
  context: { params: { id: string } }
) {
  try {
    // 1. 抓 驻专专 转 住砖
    const suggestionId = context.params.id;
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. 注转  转住住 注 砖驻转 砖转砖
    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /status PATCH] Suggestion ID: ${suggestionId}, Locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    // 3. 拽专 转 砖 祝 拽砖
    const body = await req.json();
    const validatedData = statusUpdateSchema.parse(body);
      
    // 4. 砖驻转 爪注 转 -DB
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    // 5. 拽转 专砖 拽 注住拽转
    // (: 拽转 爪注转 驻注转 专转 砖 注)
    const isCandidateApproval =
      session.user.role === UserRole.CANDIDATE &&
      (validatedData.status === MatchSuggestionStatus.FIRST_PARTY_APPROVED ||
       validatedData.status === MatchSuggestionStatus.SECOND_PARTY_APPROVED);

    if (isCandidateApproval) {
      //  转 住祝 转 拽 拽转 爪注转 驻注转 专转...
    }
    
    //  砖砖转砖  拽砖专 爪注
    if (
      suggestion.firstPartyId !== userId &&
      suggestion.secondPartyId !== userId &&
      suggestion.matchmakerId !== userId
    ) {
      return NextResponse.json({ error: "Unauthorized to update this suggestion" }, { status: 403 });
    }

    // 6. 拽专 转拽转 砖专转 专 注  驻专专 专砖
    let updatedSuggestion = await suggestionService.updateSuggestionStatus(
      suggestionId,
      validatedData.status,
      userId,
      emailDict, // <-- 注专转 
      validatedData.notes
    );
    
    // 7. 驻 驻注转 砖转 ( 注专 住住 )
    const secondaryAction = determineSecondaryAction(suggestion.status, validatedData.status);
    if (secondaryAction) {
      try {
        console.log(`[API /status PATCH] Triggering secondary action: ${secondaryAction}`);
        //  , 拽专 转拽转 砖专转 注  驻专专
        updatedSuggestion = await suggestionService.updateSuggestionStatus(
          updatedSuggestion.id,
          secondaryAction,
          userId, //  砖转砖 注专转, 转 拽
          emailDict, // <-- 注专转 
          `Automatic transition after ${validatedData.status}`
        );
      } catch (secondaryActionError) {
        console.warn("Warning: Secondary status transition failed:", secondaryActionError);
      }
    }

    // 8. 注 驻专驻 拽专 爪专 (砖, 专住/砖)
    await updateProfilesIfNeeded(validatedData.status, suggestion);

    // 9. 专转 转砖转 爪
    return NextResponse.json({
      success: true,
      suggestion: updatedSuggestion,
    });

  } catch (error) {
    console.error("Error processing request in status/route.ts:", error);
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: "Validation error", details: error.errors }, { status: 400 });
    }
    return NextResponse.json(
      { error: "Internal server error", details: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    );
  }
}

// ======================= 驻拽爪转 注专 (砖专转  砖) =======================

/**
 * 拽注转  专砖转 驻注转 砖 转 专 砖 住住.
 */
function determineSecondaryAction(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): MatchSuggestionStatus | null {
  const automaticTransitions: Partial<Record<MatchSuggestionStatus, MatchSuggestionStatus>> = {
    FIRST_PARTY_APPROVED: MatchSuggestionStatus.PENDING_SECOND_PARTY,
    SECOND_PARTY_APPROVED: MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
    FIRST_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
    SECOND_PARTY_DECLINED: MatchSuggestionStatus.CLOSED,
  };
  return automaticTransitions[newStatus] || null;
}

/**
 * 爪专 专砖转 驻砖 转 爪专.
 */
async function createMeetingIfNecessary(
  suggestionId: string,
  data: z.infer<typeof statusUpdateSchema>
) {
  if (data.meetingDate) {
    await prisma.meeting.create({
      data: {
        suggestionId,
        scheduledDate: new Date(data.meetingDate),
        status: "SCHEDULED",
        notes: data.notes || "Automatically created when contact details were shared",
      }
    });
  }
}

/**
 * 注 转 住住 转 驻专驻 砖 注 拽专 爪专.
 */
async function updateProfilesIfNeeded(
  newStatus: MatchSuggestionStatus,
  suggestion: MatchSuggestion,
) {
  if (newStatus === "ENGAGED" || newStatus === "MARRIED") {
    const availabilityStatus = newStatus === "ENGAGED" ? "ENGAGED" : "MARRIED";
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: { availabilityStatus, availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`, availabilityUpdatedAt: new Date() }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: { availabilityStatus, availabilityNote: `Status changed to ${newStatus} on ${new Date().toISOString().split('T')[0]}`, availabilityUpdatedAt: new Date() }
      })
    ]);
  }
  
  if (newStatus === "DATING") {
    await Promise.all([
      prisma.profile.update({
        where: { userId: suggestion.firstPartyId },
        data: { availabilityStatus: "DATING", availabilityNote: "Currently in a dating process", availabilityUpdatedAt: new Date() }
      }),
      prisma.profile.update({
        where: { userId: suggestion.secondPartyId },
        data: { availabilityStatus: "DATING", availabilityNote: "Currently in a dating process", availabilityUpdatedAt: new Date() }
      })
    ]);
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/active/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { formatAnswers, KEY_MAPPING, DbWorldKey, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { ExtendedMatchSuggestion, PartyInfo, QuestionnaireResponse } from "@/components/suggestions/types";
import type { FormattedAnswer, WorldId } from "@/types/next-auth";
export const dynamic = 'force-dynamic';
// --- 驻住 拽 拽 转 注 ---
type ProcessedQuestionnaireResponse = Omit<QuestionnaireResponse, 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers'> & {
  formattedAnswers: FormattedAnswersType;
};

type ProcessedPartyInfo = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: ProcessedQuestionnaireResponse[];
};

type SuggestionWithFormattedData = Omit<ExtendedMatchSuggestion, 'firstParty' | 'secondParty'> & {
  firstParty: ProcessedPartyInfo;
  secondParty: ProcessedPartyInfo;
};

// 驻住 砖注 -Prisma. 砖  砖-questionnaireResponses  住 .
type PartyInfoFromPrisma = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: QuestionnaireResponse[];
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: session.user.id, status: { in: ["PENDING_FIRST_PARTY", "FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] } },
          { secondPartyId: session.user.id, status: { in: ["PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] } },
        ],
      },
      include: {
        statusHistory: { orderBy: { createdAt: 'desc' } },
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
        secondParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // --- 注 转 注 驻住 拽 ( any) ---
    const suggestionsWithFormattedQuestionnaires: SuggestionWithFormattedData[] = activeSuggestions.map((suggestion) => {
        
        // 驻拽爪  拽转 转 驻住  驻专 专 转 驻住 注
        const formatPartyQuestionnaire = (party: PartyInfoFromPrisma): ProcessedPartyInfo => {
            const { questionnaireResponses, ...restOfParty } = party;

            if (questionnaireResponses && questionnaireResponses.length > 0) {
                const qr = questionnaireResponses[0];
                const formattedAnswers: Partial<FormattedAnswersType> = {};

                (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
                    const dbKey = KEY_MAPPING[worldKey];
                    // 砖  转专 砖 
                    const answersJson = qr[dbKey];
                    formattedAnswers[worldKey] = formatAnswers(answersJson);
                });
                
                // 住专转 砖转  爪专转 拽 注
                const { valuesAnswers, personalityAnswers, relationshipAnswers, partnerAnswers, religionAnswers, ...restOfQr } = qr;
                const processedQr: ProcessedQuestionnaireResponse = {
                    ...restOfQr,
                    formattedAnswers: formattedAnswers as FormattedAnswersType,
                };
                
                return { ...restOfParty, questionnaireResponses: [processedQr] };
            }
            //   砖, 专 转 砖专 注 注 砖转砖
            return restOfParty;
        };

        return {
            ...suggestion,
            firstParty: formatPartyQuestionnaire(suggestion.firstParty),
            secondParty: formatPartyQuestionnaire(suggestion.secondParty),
        };
    });

    return NextResponse.json({
      success: true,
      suggestions: suggestionsWithFormattedQuestionnaires,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/history/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { formatAnswers, KEY_MAPPING, DbWorldKey, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { ExtendedMatchSuggestion, PartyInfo, QuestionnaireResponse, WorldId } from "@/components/suggestions/types";
import type { FormattedAnswer } from "@/types/next-auth";
export const dynamic = 'force-dynamic';
// --- 驻住 拽 拽 转 注 ---
type ProcessedQuestionnaireResponse = Omit<QuestionnaireResponse, 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers'> & {
  formattedAnswers: FormattedAnswersType;
};

type ProcessedPartyInfo = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: ProcessedQuestionnaireResponse[];
};

type SuggestionWithFormattedData = Omit<ExtendedMatchSuggestion, 'firstParty' | 'secondParty'> & {
  firstParty: ProcessedPartyInfo;
  secondParty: ProcessedPartyInfo;
};

// 驻住 砖注 -Prisma.
type PartyInfoFromPrisma = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: QuestionnaireResponse[];
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: session.user.id, status: { in: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] } },
          { secondPartyId: session.user.id, status: { in: ["SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] } },
        ],
      },
      include: {
        statusHistory: { orderBy: { createdAt: 'desc' } },
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
        secondParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
      },
      orderBy: { updatedAt: "desc" },
    });

    const suggestionsWithFormattedQuestionnaires: SuggestionWithFormattedData[] = historySuggestions.map(suggestion => {
        const formatPartyQuestionnaire = (party: PartyInfoFromPrisma): ProcessedPartyInfo => {
            const { questionnaireResponses, ...restOfParty } = party;

            if (questionnaireResponses && questionnaireResponses.length > 0) {
                const qr = questionnaireResponses[0];
                const formattedAnswers: Partial<FormattedAnswersType> = {};

                (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
                    const dbKey = KEY_MAPPING[worldKey];
                    const answersJson = qr[dbKey];
                    formattedAnswers[worldKey] = formatAnswers(answersJson);
                });
                
                const { valuesAnswers, personalityAnswers, relationshipAnswers, partnerAnswers, religionAnswers, ...restOfQr } = qr;
                const processedQr: ProcessedQuestionnaireResponse = {
                    ...restOfQr,
                    formattedAnswers: formattedAnswers as FormattedAnswersType,
                };
                
                return { ...restOfParty, questionnaireResponses: [processedQr] };
            }
            return restOfParty;
        };

        return {
            ...suggestion,
            firstParty: formatPartyQuestionnaire(suggestion.firstParty),
            secondParty: formatPartyQuestionnaire(suggestion.secondParty),
        };
    });

    return NextResponse.json({
      success: true,
      suggestions: suggestionsWithFormattedQuestionnaires,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// The GET function remains unchanged...
export async function GET(req: NextRequest) {
  // ... existing GET implementation ...
}


/**
 * POST - Creates a new testimonial from a one-time use token.
 * This is used by the public testimonial submission form.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    // 'token' is now the random hex string from the URL, not a JWT
    const { token, authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    // Basic validation
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json({ success: false, error: 'Missing required fields.' }, { status: 400 });
    }

    // Use a transaction to ensure both operations (create testimonial, update token) succeed or fail together.
    const result = await prisma.$transaction(async (tx) => {
      // 1. Find the token request. It MUST be valid and PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() },
        },
      });

      // If no valid request is found, throw an error to abort the transaction.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // 2. Create the actual testimonial record.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // Always pending user's approval
          submittedBy: 'FRIEND', // Set the source based on your schema enum
        },
      });

      // 3. IMPORTANT: Mark the token as COMPLETED so it cannot be used again.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    if (result.success) {
      return NextResponse.json({ success: true, message: 'Thank you! Your testimonial has been submitted.' });
    } else {
       // This part should not be reached if the transaction logic is correct
       throw new Error("Transaction failed unexpectedly.");
    }

  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);
    if (error instanceof Error && error.message.includes('Invalid, expired, or already used link')) {
      return NextResponse.json({ success: false, message: 'This link is invalid, has expired, or has already been used.' }, { status: 400 });
    }
    return NextResponse.json({ success: false, error: 'An internal server error occurred.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
# Generated on: 2025-09-28 20:34:58
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// The GET function remains unchanged...
export async function GET(req: NextRequest) {
  // ... existing GET implementation ...
}


/**
 * POST - Creates a new testimonial from a one-time use token.
 * This is used by the public testimonial submission form.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    // 'token' is now the random hex string from the URL, not a JWT
    const { token, authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    // Basic validation
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json({ success: false, error: 'Missing required fields.' }, { status: 400 });
    }

    // Use a transaction to ensure both operations (create testimonial, update token) succeed or fail together.
    const result = await prisma.$transaction(async (tx) => {
      // 1. Find the token request. It MUST be valid and PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() },
        },
      });

      // If no valid request is found, throw an error to abort the transaction.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // 2. Create the actual testimonial record.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // Always pending user's approval
          submittedBy: 'FRIEND', // Set the source based on your schema enum
        },
      });

      // 3. IMPORTANT: Mark the token as COMPLETED so it cannot be used again.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    if (result.success) {
      return NextResponse.json({ success: true, message: 'Thank you! Your testimonial has been submitted.' });
    } else {
       // This part should not be reached if the transaction logic is correct
       throw new Error("Transaction failed unexpectedly.");
    }

  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);
    if (error instanceof Error && error.message.includes('Invalid, expired, or already used link')) {
      return NextResponse.json({ success: false, message: 'This link is invalid, has expired, or has already been used.' }, { status: 400 });
    }
    return NextResponse.json({ success: false, error: 'An internal server error occurred.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const { status } = await req.json() as { status: TestimonialStatus };
    if (!Object.values(TestimonialStatus).includes(status)) {
      return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
    }

    const updatedTestimonial = await prisma.friendTestimonial.updateMany({
      where: {
        id: params.testimonialId,
        profileId: userProfile.id, // Ensure ownership
      },
      data: { status },
    });

    if (updatedTestimonial.count === 0) {
      return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial status updated.' });
  } catch (error) {
    console.error("Error in PUT /api/profile/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: userProfile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial deleted.' });
  } catch (error) {
    console.error("Error in DELETE /api/profile/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for testimonials_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const { status } = await req.json() as { status: TestimonialStatus };
    if (!Object.values(TestimonialStatus).includes(status)) {
      return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
    }

    const updatedTestimonial = await prisma.friendTestimonial.updateMany({
      where: {
        id: params.testimonialId,
        profileId: userProfile.id, // Ensure ownership
      },
      data: { status },
    });

    if (updatedTestimonial.count === 0) {
      return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial status updated.' });
  } catch (error) {
    console.error("Error in PUT /api/profile/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: userProfile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial deleted.' });
  } catch (error) {
    console.error("Error in DELETE /api/profile/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/accept-terms/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; //  砖转 -authOptions 
import prisma from "@/lib/prisma";

export async function POST() {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const userId = session.user.id;

    // 拽  砖转砖 专 砖专 转 转  注 注 转专
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { termsAndPrivacyAcceptedAt: true },
    });

    if (user?.termsAndPrivacyAcceptedAt) {
      return NextResponse.json({ success: true, message: 'Terms already accepted' });
    }

    // 注 转 砖转砖 注 转转  住
    await prisma.user.update({
      where: { id: userId },
      data: {
        termsAndPrivacyAcceptedAt: new Date(),
      },
    });

    //  爪专 专 转 住砖 注 , 拽 专注 转 注 update()
    return NextResponse.json({ success: true, message: 'Terms accepted successfully' });

  } catch (error) {
    console.error('Error accepting terms:', error);
    let errorMessage = 'An unexpected error occurred';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\complete-onboarding
================================================================================

(This directory is empty.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\marketing-consent
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\marketing-consent\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/marketing-consent/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';

// Zod schema for strict validation of the incoming request body
const updateConsentSchema = z.object({
  marketingConsent: z.boolean({
    required_error: "Marketing consent status is required.",
    invalid_type_error: "Marketing consent must be a boolean.",
  }),
});

export async function PUT(req: Request) {
  try {
    // 1. Authenticate the user session on the server
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. Parse and validate the request body against the schema
    const body = await req.json();
    const validationResult = updateConsentSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: 'Invalid input', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }
    
    const { marketingConsent } = validationResult.data;

    // 3. Update the user record in the database
    await prisma.user.update({
      where: { id: userId },
      data: {
        marketingConsent: marketingConsent,
      },
    });

    // 4. Return a success response. 
    // The client is responsible for refreshing its session state.
    return NextResponse.json({ success: true, message: 'Marketing consent updated successfully.' });

  } catch (error) {
    console.error('Error updating marketing consent:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json(
      { success: false, error: "Internal server error.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

