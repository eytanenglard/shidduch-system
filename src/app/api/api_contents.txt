################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api
# Generated on: 2025-12-22 17:24:26
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\api_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\admin_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
# Generated on: 2025-11-03 09:07:19
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\admin_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
# Generated on: 2025-10-27 15:28:42
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
      case 'EVENING_FEEDBACK': {
        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
      case 'AI_SUMMARY': {
        // ğŸ¯ ×–×” ×”×—×œ×§ ×©×ª×§×•×¢!
        console.log('ğŸ§  [Manual Email] Loading AI insights...');
        
        // ×˜×¢×Ÿ AI insights ×¢× timeout × ×•×¡×£
        try {
          // âœ… ×”×•×¡×£ timeout ×¡×¤×¦×™×¤×™ ×œ-AI
          await Promise.race([
            SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('AI insights timeout')), 40000)
            ),
          ]);
          
          console.log('âœ… [Manual Email] AI insights loaded successfully');
        } catch (aiError) {
          console.error('âŒ [Manual Email] AI insights failed:', aiError);
          // ×× AI × ×›×©×œ, × ××©×™×š ×‘×œ×™ AI insights
          console.warn('âš ï¸ [Manual Email] Continuing without AI insights');
        }

        email = await SmartEngagementOrchestrator['getAiSummaryEmail'](profile, dict);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator['getPhotoNudgeEmail'](profile, dict);
        } else {
          email = await SmartEngagementOrchestrator['getQuestionnaireNudgeEmail'](profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator['getAlmostDoneEmail'](profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator['getValueEmail'](profile, dict);
        break;
      }
      case 'ONBOARDING': {
        email = await SmartEngagementOrchestrator['getOnboardingEmail'](profile, dict);
        break;
      }
      default:
        throw new Error('Unsupported email type');
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for engagement_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
case 'EVENING_FEEDBACK': {
        // --- ×ª×—×™×œ×ª ×”×ª×™×§×•×Ÿ ---
        console.log('ğŸŒ™ [Manual Email] Evening Feedback requires AI. Loading insights...');
        // ×˜×¢×™× ×ª ×ª×•×‘× ×•×ª ×”-AI ×‘××•×¤×Ÿ ×™×–×•× ×œ×ª×•×š ××•×‘×™×™×§×˜ ×”×¤×¨×•×¤×™×œ
        await SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language);
        console.log(`âœ… [Manual Email] AI insights ${profile.aiInsights ? 'loaded' : 'not available'}.`);
        // --- ×¡×•×£ ×”×ª×™×§×•×Ÿ ---

        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
            case 'AI_SUMMARY': {
        console.log('ğŸ§  [Manual Email] Generating AI Summary email...');
        email = await SmartEngagementOrchestrator.testGetAiSummaryEmail(profile, dict, user.language as Language);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator.testGetPhotoNudgeEmail(profile, dict);
        } else {
          email = await SmartEngagementOrchestrator.testGetQuestionnaireNudgeEmail(profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator.testGetAlmostDoneEmail(profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator.testGetValueEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_DAY_1': {
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      case 'ONBOARDING_PHOTOS': {
        email = await SmartEngagementOrchestrator.testGetOnboardingPhotosEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_AI_TEASER': {
        console.log('ğŸ§  [Manual Email] Generating Onboarding AI Teaser email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingAiTeaserEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING_QUESTIONNAIRE_WHY': {
        email = await SmartEngagementOrchestrator.testGetOnboardingQuestionnaireWhyEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_VALUE_ADD': {
        console.log('ğŸ’ [Manual Email] Generating Onboarding Value Add email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingValueAddEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING': { // Fallback for old value
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      default:
        throw new Error(`Unsupported email type: ${emailType}`);
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for admin_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
# Generated on: 2025-10-27 15:28:42
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
      case 'EVENING_FEEDBACK': {
        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
      case 'AI_SUMMARY': {
        // ğŸ¯ ×–×” ×”×—×œ×§ ×©×ª×§×•×¢!
        console.log('ğŸ§  [Manual Email] Loading AI insights...');
        
        // ×˜×¢×Ÿ AI insights ×¢× timeout × ×•×¡×£
        try {
          // âœ… ×”×•×¡×£ timeout ×¡×¤×¦×™×¤×™ ×œ-AI
          await Promise.race([
            SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('AI insights timeout')), 40000)
            ),
          ]);
          
          console.log('âœ… [Manual Email] AI insights loaded successfully');
        } catch (aiError) {
          console.error('âŒ [Manual Email] AI insights failed:', aiError);
          // ×× AI × ×›×©×œ, × ××©×™×š ×‘×œ×™ AI insights
          console.warn('âš ï¸ [Manual Email] Continuing without AI insights');
        }

        email = await SmartEngagementOrchestrator['getAiSummaryEmail'](profile, dict);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator['getPhotoNudgeEmail'](profile, dict);
        } else {
          email = await SmartEngagementOrchestrator['getQuestionnaireNudgeEmail'](profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator['getAlmostDoneEmail'](profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator['getValueEmail'](profile, dict);
        break;
      }
      case 'ONBOARDING': {
        email = await SmartEngagementOrchestrator['getOnboardingEmail'](profile, dict);
        break;
      }
      default:
        throw new Error('Unsupported email type');
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for engagement_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
case 'EVENING_FEEDBACK': {
        // --- ×ª×—×™×œ×ª ×”×ª×™×§×•×Ÿ ---
        console.log('ğŸŒ™ [Manual Email] Evening Feedback requires AI. Loading insights...');
        // ×˜×¢×™× ×ª ×ª×•×‘× ×•×ª ×”-AI ×‘××•×¤×Ÿ ×™×–×•× ×œ×ª×•×š ××•×‘×™×™×§×˜ ×”×¤×¨×•×¤×™×œ
        await SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language);
        console.log(`âœ… [Manual Email] AI insights ${profile.aiInsights ? 'loaded' : 'not available'}.`);
        // --- ×¡×•×£ ×”×ª×™×§×•×Ÿ ---

        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
            case 'AI_SUMMARY': {
        console.log('ğŸ§  [Manual Email] Generating AI Summary email...');
        email = await SmartEngagementOrchestrator.testGetAiSummaryEmail(profile, dict, user.language as Language);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator.testGetPhotoNudgeEmail(profile, dict);
        } else {
          email = await SmartEngagementOrchestrator.testGetQuestionnaireNudgeEmail(profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator.testGetAlmostDoneEmail(profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator.testGetValueEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_DAY_1': {
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      case 'ONBOARDING_PHOTOS': {
        email = await SmartEngagementOrchestrator.testGetOnboardingPhotosEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_AI_TEASER': {
        console.log('ğŸ§  [Manual Email] Generating Onboarding AI Teaser email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingAiTeaserEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING_QUESTIONNAIRE_WHY': {
        email = await SmartEngagementOrchestrator.testGetOnboardingQuestionnaireWhyEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_VALUE_ADD': {
        console.log('ğŸ’ [Manual Email] Generating Onboarding Value Add email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingValueAddEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING': { // Fallback for old value
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      default:
        throw new Error(`Unsupported email type: ${emailType}`);
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
# Generated on: 2025-12-22 13:10:11
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\ai_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×”××©×ª××© ×‘×××¦×¢×•×ª AI.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£,
 * ×©×•×œ×—×ª ××•×ª×• ×œ× ×™×ª×•×— AI, ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ××©×ª××©
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // ×©×œ×‘ 2: ×•×“× ×©×”××©×ª××© ×•×”×¤×¨×•×¤×™×œ ×§×™×™××™× ×œ×¤× ×™ ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] ×œ× × ××¦× ×¤×¨×•×¤×™×œ ×¢×‘×•×¨ ××©×ª××©: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    // ×©×™××•×© ×—×•×–×¨ ×‘×œ×•×’×™×§×” ×”×§×™×™××ª ×•×”××¦×•×™× ×ª ×-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×”×¦×¢×ª ×©×™×“×•×š ×¢×‘×•×¨ ×”××©×ª××© ×”××—×•×‘×¨.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×××—×–×¨×ª ××ª ×”×¤×¨×•×¤×™×œ ×©×œ×• ×•××ª ×”×¤×¨×•×¤×™×œ ×©×œ ×”××©×ª××© ×”××•×¦×¢,
 * ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™×”×, ×©×•×œ×—×ª ××•×ª× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©,
 * ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×§×‘×œ×ª ×”××©×ª××© ×”× ×•×›×—×™
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. ×§×‘×œ×ª ID ×©×œ ×”××©×ª××© ×”××•×¦×¢ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3. ×•×“× ×©×©× ×™ ×”×¤×¨×•×¤×™×œ×™× ×§×™×™××™×
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] ××—×“ ×”×¤×¨×•×¤×™×œ×™× ××• ×©× ×™×”× ×œ× × ××¦××•. × ××¦××•: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™ ×”××©×ª××©×™× ×‘××§×‘×™×œ
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ××—×“ ×”××©×ª××©×™×.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘×™× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××ª × ×™×ª×•×— ×”×¦×¢×”.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
# Generated on: 2025-09-28 20:43:55
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×©×œ ××©×ª××© ×¡×¤×¦×™×¤×™ ×¢×œ ×™×“×™ ×©×“×›×Ÿ.
 */
export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // ×©×œ×‘ 2: ×§×‘×œ×ª ID ×”××•×¢××“ ×œ× ×™×ª×•×— ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ ×‘×‘×§×©×”.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ×”××©×ª××© ×”××‘×•×§×©
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
    const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×©×œ ××©×ª××© ×¡×¤×¦×™×¤×™ ×¢×œ ×™×“×™ ×©×“×›×Ÿ.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // ×©×œ×‘ 2: ×§×‘×œ×ª ID ×”××•×¢××“ ×œ× ×™×ª×•×— ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ ×‘×‘×§×©×”.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ×”××©×ª××© ×”××‘×•×§×©
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/test-connection/route.ts

import { NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function GET() {
  console.log('--- [API TEST] Received request at /api/ai/test-connection ---');

  const apiKey = process.env.GOOGLE_API_KEY;

  if (!apiKey) {
    console.error('--- [API TEST] FATAL ERROR: GOOGLE_API_KEY is not set in .env or .env.local!');
    return NextResponse.json(
      { success: false, error: 'Server configuration error: GOOGLE_API_KEY is missing.' },
      { status: 500 }
    );
  }

  // --- ×§×˜×¢ ×”××™××•×ª ×©×”×•×¡×¤× ×• ---
  const keyIdentifier = `Starts with: ${apiKey.substring(0, 5)}... | Ends with: ...${apiKey.substring(apiKey.length - 4)} | Length: ${apiKey.length}`; // <-- ×”×•×¡×£
  console.log(`--- [API TEST] Verifying the loaded API Key: ${keyIdentifier} ---`); // <-- ×”×•×¡×£
  // -----------------------------

  console.log('--- [API TEST] GOOGLE_API_KEY found. Proceeding with API call.');

  try {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' }); 
    const prompt = 'Say "Connection Successful" in one sentence.';

    console.log('--- [API TEST] Sending a simple prompt to Google AI...');
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    console.log('--- [API TEST] SUCCESS! Google AI responded:', text);
    return NextResponse.json({ success: true, message: 'Connection to Google AI is working!', response: text });

  } catch (error) {
    console.error('--- [API TEST] FAILED! The API call to Google threw an error.', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to connect to Google AI. This is likely an API key, permissions, or billing issue.',
        details: JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×©××¨×™×¦×” ××ª ×ª×”×œ×™×š ×”×¢×“×›×•×Ÿ ×‘×¨×§×¢
 * ×•××“×¤×™×¡×” ×œ×•×’ ××¤×•×¨×˜ ×‘×¡×™×•××•.
 * @param userIds - ××¢×¨×š ××–×”×™ ×”××©×ª××©×™× ×œ×¢×“×›×•×Ÿ
 * @param adminId - ××–×”×” ×”××“××™×Ÿ ×©×”×¤×¢×™×œ ××ª ×”×ª×”×œ×™×š
 */
async function runBulkUpdateAndLog(userIds: string[]) {
  const totalUsers = userIds.length;
  // ×”×•×“×¢×ª ×”×ª×—×œ×” ×‘×¨×•×¨×” ×œ×ª×”×œ×™×š ×”×¨×§×¢
 
  try {
    // × ×©×ª××© ×‘-Promise.allSettled ×›×“×™ ×œ×”××ª×™×Ÿ ×œ×¡×™×•× ×›×œ ×”×¢×“×›×•× ×™×, ×’× ×× ×—×œ×§× × ×›×©×œ×™×
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // ××™×¡×•×£ ××–×”×™ ×”××©×ª××©×™× ×©× ×›×©×œ×• (×× ×™×© ×›××œ×”)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // ×”×“×¤×¡×ª ×¡×™×›×•× ××¤×•×¨×˜
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // ×‘××§×¨×” ×©×œ ×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ×”×¨×§×¢ ×¢×¦××•
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // ×›××Ÿ ×”×œ×•×’ ×”××§×•×¨×™ × ×©××¨, ×›×“×™ ×©×ª×¨××” ×©×”-API ×”×•×¤×¢×œ
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for ai_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-my-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-my-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×”××©×ª××© ×‘×××¦×¢×•×ª AI.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£,
 * ×©×•×œ×—×ª ××•×ª×• ×œ× ×™×ª×•×— AI, ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ××©×ª××©
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-my-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // ×©×œ×‘ 2: ×•×“× ×©×”××©×ª××© ×•×”×¤×¨×•×¤×™×œ ×§×™×™××™× ×œ×¤× ×™ ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘
    const userProfileExists = await prisma.profile.findUnique({
      where: { userId },
      select: { id: true }
    });

    if (!userProfileExists) {
        console.error(`[API analyze-my-profile] ×œ× × ××¦× ×¤×¨×•×¤×™×œ ×¢×‘×•×¨ ××©×ª××©: ${userId}`);
        return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    // ×©×™××•×© ×—×•×–×¨ ×‘×œ×•×’×™×§×” ×”×§×™×™××ª ×•×”××¦×•×™× ×ª ×-profileAiService
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API analyze-my-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API analyze-my-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-my-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\analyze-suggestion\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/analyze-suggestion/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×”×¦×¢×ª ×©×™×“×•×š ×¢×‘×•×¨ ×”××©×ª××© ×”××—×•×‘×¨.
 * ×”×¤×•× ×§×¦×™×” ××××ª×ª ××ª ×”××©×ª××©, ×××—×–×¨×ª ××ª ×”×¤×¨×•×¤×™×œ ×©×œ×• ×•××ª ×”×¤×¨×•×¤×™×œ ×©×œ ×”××©×ª××© ×”××•×¦×¢,
 * ×™×•×¦×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™×”×, ×©×•×œ×—×ª ××•×ª× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©,
 * ×•××—×–×™×¨×” ××ª ×”×ª×•×¦××” ×”××•×‘× ×™×ª.
 */
export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×§×‘×œ×ª ×”××©×ª××© ×”× ×•×›×—×™
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.warn('[API analyze-suggestion] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    // 2. ×§×‘×œ×ª ID ×©×œ ×”××©×ª××© ×”××•×¦×¢ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { suggestedUserId } = body;

    if (!suggestedUserId || typeof suggestedUserId !== 'string') {
      console.error('[API analyze-suggestion] Invalid or missing suggestedUserId in request body.');
      return NextResponse.json({ success: false, message: 'Bad Request: suggestedUserId is required.' }, { status: 400 });
    }


    // 3. ×•×“× ×©×©× ×™ ×”×¤×¨×•×¤×™×œ×™× ×§×™×™××™×
    const profilesExist = await prisma.profile.findMany({
      where: {
        userId: { in: [currentUserId, suggestedUserId] }
      },
      select: { userId: true }
    });

    if (profilesExist.length !== 2) {
      console.error(`[API analyze-suggestion] ××—×“ ×”×¤×¨×•×¤×™×œ×™× ××• ×©× ×™×”× ×œ× × ××¦××•. × ××¦××•: ${profilesExist.map(p => p.userId).join(', ')}`);
      return NextResponse.json({ success: false, message: 'One or both user profiles could not be found.' }, { status: 404 });
    }

    // 4. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ×™× × ×¨×˜×™×‘×™×™× ×¢×‘×•×¨ ×©× ×™ ×”××©×ª××©×™× ×‘××§×‘×™×œ
    const [currentUserNarrative, suggestedUserNarrative] = await Promise.all([
      profileAiService.generateNarrativeProfile(currentUserId),
      profileAiService.generateNarrativeProfile(suggestedUserId)
    ]);

    if (!currentUserNarrative || !suggestedUserNarrative) {
      console.error(`[API analyze-suggestion] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ××—×“ ×”××©×ª××©×™×.`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narratives.' }, { status: 500 });
    }

    // 5. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘×™× ×œ× ×™×ª×•×— AI ××•×ª×× ×œ××©×ª××©
    const analysisResult = await aiService.analyzeSuggestionForUser(
      currentUserNarrative,
      suggestedUserNarrative
    );

    if (!analysisResult) {
      console.error(`[API analyze-suggestion] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××ª × ×™×ª×•×— ×”×¦×¢×”.`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a suggestion analysis.' }, { status: 500 });
    }

    // 6. ×”×—×–×¨×ª ×”×ª×•×¦××” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API analyze-suggestion] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\find-matches\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/find-matches/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { targetUserId, candidatePoolIds } = body;

    if (!targetUserId || !Array.isArray(candidatePoolIds) || candidatePoolIds.length === 0) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'targetUserId' (string) and 'candidatePoolIds' (array) are required." }, { status: 400 });
    }

    // 3. Fetch the profile for the target user to get their profileId
    const targetProfile = await prisma.profile.findUnique({
        where: { userId: targetUserId },
        select: { id: true }
    });

    if (!targetProfile) {
        return NextResponse.json({ success: false, error: "Target user profile not found." }, { status: 404 });
    }
    
    // --- START OF FIX 1: Cast the vector to text ---
    // We explicitly cast the vector to ::text, which Prisma understands as a string.
    const vectorResult: { vector_text: string }[] = await prisma.$queryRaw`
      SELECT vector::text as vector_text FROM "profile_vectors" WHERE "profileId" = ${targetProfile.id} LIMIT 1;
    `;

    if (!vectorResult || vectorResult.length === 0 || !vectorResult[0]?.vector_text) {
        return NextResponse.json({ success: false, error: "Vector for target user not found. AI profile may still be processing." }, { status: 404 });
    }

    // Now, we parse the string back into a number array.
    // The string looks like '[0.1,0.2,...]', so we remove brackets and split.
    const targetVector: number[] = JSON.parse(vectorResult[0].vector_text);
    // --- END OF FIX 1 ---

    // 4. Perform Vector Similarity Search
    // We still use the original format for the similarity search operation itself.
    const targetVectorString = `[${targetVector.join(',')}]`;

    // --- START OF FIX 2: No change needed here, the previous query was the issue ---
    // The error was in retrieving the target vector, not in the search itself.
    // This query is fine because the `vector` column is only used for calculation
    // and is not returned in the final SELECT statement.
    const results: { profileId: string; similarity: number }[] = await prisma.$queryRaw`
      SELECT
        pv."profileId",
        1 - (pv.vector <=> ${targetVectorString}::vector) as similarity
      FROM
        "profile_vectors" AS pv
      INNER JOIN 
        "Profile" AS p ON pv."profileId" = p.id
      WHERE
        p."userId" IN (${Prisma.join(candidatePoolIds)}) AND p."userId" != ${targetUserId}
      ORDER BY
        similarity DESC
      LIMIT 20;
    `;
    // --- END OF FIX 2 ---
    
    // 5. Map results from profileId back to userId for the frontend
    const profileIdToUserIdMap = new Map<string, string>();
    const allProfileIds = results.map(r => r.profileId);

    if (allProfileIds.length > 0) {
        const profiles = await prisma.profile.findMany({
            where: { id: { in: allProfileIds } },
            select: { id: true, userId: true }
        });
        profiles.forEach(p => profileIdToUserIdMap.set(p.id, p.userId));
    }

    const finalMatches = results.map(r => ({
        userId: profileIdToUserIdMap.get(r.profileId) || '',
        score: Math.round(r.similarity * 100)
    })).filter(m => m.userId);

    // 6. Return the sorted list of matches
    return NextResponse.json({ success: true, matches: finalMatches });

  } catch (error) {
    console.error('Error in /api/ai/find-matches:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/generate-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import { analyzePairCompatibility } from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2, language } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // Validate language or set default
    const validLanguages = ['he', 'en'];
    const analysisLanguage = validLanguages.includes(language) ? language : 'he';

    // 3. Generate Narrative Profiles for both users
    // We run them in parallel for efficiency.
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // 4. Call the AI service to get the compatibility analysis
    const analysisResult = await analyzePairCompatibility(profile1Text, profile2Text, analysisLanguage);

    if (!analysisResult) {
        return NextResponse.json({ success: false, error: "Failed to get compatibility analysis from AI service." }, { status: 500 });
    }

    // 5. Return the successful analysis
    return NextResponse.json({ success: true, analysis: analysisResult });

  } catch (error) {
    console.error('Error in /api/ai/generate-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\generate-suggestion-rationale\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/generate-suggestion-rationale/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { generateNarrativeProfile } from "@/lib/services/profileAiService";
import aiService from "@/lib/services/aiService";

export async function POST(req: NextRequest) {
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. Authentication and Authorization
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 2. Body Validation
    const body = await req.json();
    const { userId1, userId2 } = body;

    if (!userId1 || !userId2) {
      return NextResponse.json({ success: false, error: "Invalid request body. 'userId1' and 'userId2' are required." }, { status: 400 });
    }
    
    // 3. Generate Narrative Profiles for both users in parallel
    const [profile1Text, profile2Text] = await Promise.all([
        generateNarrativeProfile(userId1),
        generateNarrativeProfile(userId2)
    ]);

    if (!profile1Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId1}.` }, { status: 404 });
    }
    if (!profile2Text) {
        return NextResponse.json({ success: false, error: `Could not generate narrative profile for user ${userId2}.` }, { status: 404 });
    }

    // --- START OF CHANGE ---
    // 4. Call the new AI service to get the full rationale package
    const rationaleObject = await aiService.generateFullSuggestionRationale(profile1Text, profile2Text);

    if (!rationaleObject) {
        return NextResponse.json({ success: false, error: "Failed to get suggestion rationale package from AI service." }, { status: 500 });
    }

    // 5. Return the successful rationale object
    return NextResponse.json({ success: true, rationales: rationaleObject });
    // --- END OF CHANGE ---

  } catch (error) {
    console.error('Error in /api/ai/generate-suggestion-rationale:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
# Generated on: 2025-09-28 20:43:55
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\matchmaker_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ× ×™×ª×•×— ×¤×¨×•×¤×™×œ ×©×œ ××©×ª××© ×¡×¤×¦×™×¤×™ ×¢×œ ×™×“×™ ×©×“×›×Ÿ.
 */
export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // ×©×œ×‘ 2: ×§×‘×œ×ª ID ×”××•×¢××“ ×œ× ×™×ª×•×— ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
        console.error('[API matchmaker/analyze-profile] userId ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ ×‘×‘×§×©×”.');
        return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // ×©×œ×‘ 3: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨ ×”××©×ª××© ×”××‘×•×§×©
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // ×©×œ×‘ 4: ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI
    const analysisResult = await aiService.getProfileAnalysis(narrativeProfile);

    if (!analysisResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce an analysis.' }, { status: 500 });
    }

    // ×©×œ×‘ 5: ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, data: analysisResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
    const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

--- End of Content for matchmaker_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\analyze-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/analyze-profile/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';
import prisma from '@/lib/prisma';
import { UserRole } from "@prisma/client";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª POST ×œ×™×¦×™×¨×ª ×¡×™×›×•× ×¤×¨×•×¤×™×œ (××™×©×™×•×ª + ××” ××—×¤×©) ×¢×‘×•×¨ ×©×“×›×Ÿ.
 * ×‘×•×“×§ ××˜××•×Ÿ ×‘×“××˜×” ×‘×™×™×¡ ×œ×¤× ×™ ×¤× ×™×™×” ×œ-AI.
 */
export async function POST(req: NextRequest) {
  // ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      console.warn('[API matchmaker/analyze-profile] × ×™×¡×™×•×Ÿ ×’×™×©×” ×œ× ××•×¨×©×”.');
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ×¤×¨××˜×¨×™× ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { userId, forceRefresh } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ ×•×”×©×“×” ×”×—×“×© ××”×“××˜×” ×‘×™×™×¡ ×œ×‘×“×™×§×ª ××˜××•×Ÿ
    const existingProfile = await prisma.profile.findUnique({
      where: { userId },
      select: { 
        aiProfileSummary: true, 
        needsAiProfileUpdate: true 
      }
    });

    if (!existingProfile) {
      return NextResponse.json({ success: false, message: 'Profile not found.' }, { status: 404 });
    }

    // 4. ×œ×•×’×™×§×ª ××˜××•×Ÿ: ×× ×™×© ×¡×™×›×•× ×©××•×¨, ×”×¤×¨×•×¤×™×œ ×œ× ×”×©×ª× ×”, ×•×œ× ×‘×™×§×©× ×• ×¨×¢× ×•×Ÿ ×‘×›×•×— -> × ×—×–×™×¨ ××ª ×”×§×™×™×
    if (
      existingProfile.aiProfileSummary && 
      !existingProfile.needsAiProfileUpdate && 
      !forceRefresh
    ) {
      console.log(`[API analyze-profile] Returning cached summary for user: ${userId}`);
      return NextResponse.json({ success: true, data: existingProfile.aiProfileSummary });
    }

    console.log(`[API analyze-profile] Generating NEW summary for user: ${userId} (Force: ${forceRefresh})`);

    // 5. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£ (×˜×§×¡×˜ ×’×•×œ××™ ×œ-AI)
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);

    if (!narrativeProfile) {
      console.error(`[API matchmaker/analyze-profile] × ×›×©×œ ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 6. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ× ×™×ª×•×— AI (×©×™××•×© ×‘×¤×•× ×§×¦×™×” ×”×—×“×©×” ×•×”×××•×§×“×ª)
    const summaryResult = await aiService.generateProfileSummary(narrativeProfile);

    if (!summaryResult) {
      console.error(`[API matchmaker/analyze-profile] ×©×™×¨×•×ª ×”-AI ×œ× ×”×—×–×™×¨ ×ª×•×¦××” ×¢×‘×•×¨: ${userId}`);
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 7. ×©××™×¨×ª ×”×ª×•×¦××” ×‘×“××˜×” ×‘×™×™×¡ (×‘×©×“×” ×”×—×“×© aiProfileSummary) ×•××™×¤×•×¡ ×”×“×’×œ needsAiProfileUpdate
    await prisma.profile.update({
      where: { userId },
      data: {
        aiProfileSummary: summaryResult as any, // ×”××¨×” ×œ-Json ×©×œ ×¤×¨×™×–××”
        needsAiProfileUpdate: false // ×”×“×•×— ××¢×•×“×›×Ÿ ×›×¢×ª
      }
    });

    // 8. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”×—×“×©×” ×œ×œ×§×•×—
    return NextResponse.json({ success: true, data: summaryResult });

  } catch (error) {
    console.error('[API matchmaker/analyze-profile] ×©×’×™××” ×¤×˜××œ×™×ª ×‘-endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\generate-summary\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/generate-summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import profileAiService from '@/lib/services/profileAiService';
import aiService from '@/lib/services/aiService';

export async function POST(req: NextRequest) {
  try {
    // 1. ××™××•×ª ×•×”×¨×©××•×ª (×©×“×›×Ÿ ××• ××“××™×Ÿ ×‘×œ×‘×“)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // 2. ×§×‘×œ×ª ID ×”××•×¢××“ ××’×•×£ ×”×‘×§×©×”
    const body = await req.json();
const { userId, locale } = body;

    if (!userId || typeof userId !== 'string') {
      return NextResponse.json({ success: false, message: 'Bad Request: userId is required.' }, { status: 400 });
    }

    // 3. ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ × ×¨×˜×™×‘×™ ××§×™×£
    const narrativeProfile = await profileAiService.generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      return NextResponse.json({ success: false, message: 'Could not generate user profile narrative.' }, { status: 500 });
    }

    // 4. ×©×œ×™×—×ª ×”× ×¨×˜×™×‘ ×œ-AI ×œ×™×¦×™×¨×ª ×”×¡×™×›×•×
const summaryResult = await aiService.generateNeshamaTechSummary(narrativeProfile, locale);
    if (!summaryResult || !summaryResult.summaryText) {
      return NextResponse.json({ success: false, message: 'AI service failed to produce a summary.' }, { status: 500 });
    }

    // 5. ×”×—×–×¨×ª ×”×ª×•×¦××” ×”××•×¦×œ×—×ª
    return NextResponse.json({ success: true, summary: summaryResult.summaryText });

  } catch (error) {
    console.error('[API generate-summary] Fatal error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, message: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\prepare-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/prepare-feedback-email/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { getDictionary, getQuestionnaireQuestionsDictionary } from "@/lib/dictionaries";
import { profileFeedbackService } from "@/lib/services/profileFeedbackService";
import type { ProfileFeedbackTemplateContext } from "@/lib/email/templates/emailTemplates";

import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';

// ×¨×™×©×•× helpers ×©×œ Handlebars
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

Handlebars.registerHelper('replace', function (str, searchValue, replaceValue) {
  if (typeof str !== 'string') return str;
  return str.replace(new RegExp(searchValue, 'g'), replaceValue);
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const { userId, locale, isAutomated } = await req.json();
    if (!userId || !locale) {
      return NextResponse.json({ success: false, error: "Missing userId or locale" }, { status: 400 });
    }
    
    // ×˜×¢×™× ×ª ×”××™×œ×•× ×™×
    const [dictionary, questionnaireQuestionsDict] = await Promise.all([
      getDictionary(locale),
      getQuestionnaireQuestionsDictionary(locale)
    ]);
    
    const emailDict = dictionary.email;

    // ×‘×“×™×§×” ×©××™×œ×•×Ÿ ×”××™×™×œ ×§×™×™×
    if (!emailDict?.profileFeedback || !emailDict?.shared) {
        console.error("Dictionary is missing 'email.profileFeedback' or 'email.shared' section.");
        return NextResponse.json({ success: false, error: "Server configuration error: Email dictionary is incomplete." }, { status: 500 });
    }

    // ×™×¦×™×¨×ª ×”×“×•×— ×¢× ×”×˜×™×¤×•×¡ ×”××ª×•×§×Ÿ
    const report = await profileFeedbackService.compileFeedbackReport(
      userId, 
      locale, 
      questionnaireQuestionsDict // ×–×” ×›×‘×¨ ×”×˜×™×¤×•×¡ ×”× ×›×•×Ÿ
    );

    // ×”×›× ×ª ×”×§×•× ×˜×§×¡×˜ ×œ×ª×‘× ×™×ª
    const context: ProfileFeedbackTemplateContext = {
      locale: locale as any,
      dict: emailDict.profileFeedback,
      sharedDict: {
        ...emailDict.shared,
        rightsReserved: (emailDict.shared.rightsReserved || "Â© {{year}} NeshamaTech").replace('{{year}}', new Date().getFullYear().toString())
      },
      name: report.name,
      report,
      isAutomated: isAutomated || false,
      matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      supportEmail: process.env.SUPPORT_EMAIL || 'support@neshamatech.com',
      companyName: process.env.COMPANY_NAME || 'NeshamaTech',
      currentYear: new Date().getFullYear().toString(),
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    };

    // ×˜×¢×™× ×ª ×ª×‘× ×™×ª ×”-Handlebars
    const templatePath = path.resolve(process.cwd(), 'src/lib/email/templates/profile-feedback.hbs');
    
    if (!fs.existsSync(templatePath)) {
      console.error(`Template file not found: ${templatePath}`);
      return NextResponse.json({ success: false, error: "Email template not found" }, { status: 500 });
    }

    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateSource);
    
    // ×”×•×¡×¤×ª greeting ×œ×§×•× ×˜×§×¡×˜
    const contextWithGreeting = {
      ...context,
      greeting: (emailDict.profileFeedback.greeting || "×©×œ×•× {{name}}").replace('{{name}}', report.name)
    };
    
    const htmlContent = compiledTemplate(contextWithGreeting);

    // ×”×—×–×¨×ª ×”×ª×•×›×Ÿ ×¢× headers × ×›×•× ×™×
    return NextResponse.json(
      { 
        success: true, 
        htmlContent,
        locale,
        direction: locale === 'he' ? 'rtl' : 'ltr'
      },
      {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        }
      }
    );

  } catch (error) {
    console.error("Error in prepare-feedback-email endpoint:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal Server Error", 
        details: errorMessage 
      }, 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\matchmaker\send-feedback-email\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/matchmaker/send-feedback-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { emailService } from "@/lib/email/emailService";
import { UserRole } from "@prisma/client";
export async function POST(req: NextRequest) {
try {
const session = await getServerSession(authOptions);
if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
}

const { userEmail, subject, htmlContent } = await req.json();
if (!userEmail || !subject || !htmlContent) {
  return NextResponse.json({ success: false, error: "Missing parameters" }, { status: 400 });
}

// ×§×¨×™××” ×œ×©×™×¨×•×ª ×”××™×™×œ ×¢× ×”×ª×•×›×Ÿ ×”×¢×¨×•×š
await emailService.sendRawEmail({
  to: userEmail,
  subject: subject,
  html: htmlContent,
});

return NextResponse.json({ success: true, message: "Email sent successfully" });
} catch (error) {
console.error("Error sending feedback email:", error);
return NextResponse.json({ success: false, error: "Internal Server Error" }, { status: 500 });
}
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\test-connection\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/ai/test-connection/route.ts

import { NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function GET() {
  console.log('--- [API TEST] Received request at /api/ai/test-connection ---');

  const apiKey = process.env.GOOGLE_API_KEY;

  if (!apiKey) {
    console.error('--- [API TEST] FATAL ERROR: GOOGLE_API_KEY is not set in .env or .env.local!');
    return NextResponse.json(
      { success: false, error: 'Server configuration error: GOOGLE_API_KEY is missing.' },
      { status: 500 }
    );
  }

  // --- ×§×˜×¢ ×”××™××•×ª ×©×”×•×¡×¤× ×• ---
  const keyIdentifier = `Starts with: ${apiKey.substring(0, 5)}... | Ends with: ...${apiKey.substring(apiKey.length - 4)} | Length: ${apiKey.length}`; // <-- ×”×•×¡×£
  console.log(`--- [API TEST] Verifying the loaded API Key: ${keyIdentifier} ---`); // <-- ×”×•×¡×£
  // -----------------------------

  console.log('--- [API TEST] GOOGLE_API_KEY found. Proceeding with API call.');

  try {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' }); 
    const prompt = 'Say "Connection Successful" in one sentence.';

    console.log('--- [API TEST] Sending a simple prompt to Google AI...');
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    console.log('--- [API TEST] SUCCESS! Google AI responded:', text);
    return NextResponse.json({ success: true, message: 'Connection to Google AI is working!', response: text });

  } catch (error) {
    console.error('--- [API TEST] FAILED! The API call to Google threw an error.', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to connect to Google AI. This is likely an API key, permissions, or billing issue.',
        details: JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\ai\update-all-profiles\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/ai/update-all-profiles/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

/**
 * ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×©××¨×™×¦×” ××ª ×ª×”×œ×™×š ×”×¢×“×›×•×Ÿ ×‘×¨×§×¢
 * ×•××“×¤×™×¡×” ×œ×•×’ ××¤×•×¨×˜ ×‘×¡×™×•××•.
 * @param userIds - ××¢×¨×š ××–×”×™ ×”××©×ª××©×™× ×œ×¢×“×›×•×Ÿ
 * @param adminId - ××–×”×” ×”××“××™×Ÿ ×©×”×¤×¢×™×œ ××ª ×”×ª×”×œ×™×š
 */
async function runBulkUpdateAndLog(userIds: string[]) {
  const totalUsers = userIds.length;
  // ×”×•×“×¢×ª ×”×ª×—×œ×” ×‘×¨×•×¨×” ×œ×ª×”×œ×™×š ×”×¨×§×¢
 
  try {
    // × ×©×ª××© ×‘-Promise.allSettled ×›×“×™ ×œ×”××ª×™×Ÿ ×œ×¡×™×•× ×›×œ ×”×¢×“×›×•× ×™×, ×’× ×× ×—×œ×§× × ×›×©×œ×™×
    const results = await Promise.allSettled(
      userIds.map(userId => updateUserAiProfile(userId))
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = totalUsers - successCount;
    
    // ××™×¡×•×£ ××–×”×™ ×”××©×ª××©×™× ×©× ×›×©×œ×• (×× ×™×© ×›××œ×”)
    const failedUserIds = results
      .map((result, index) => ({ result, userId: userIds[index] }))
      .filter(({ result }) => result.status === 'rejected')
      .map(({ userId }) => userId);

    // ×”×“×¤×¡×ª ×¡×™×›×•× ××¤×•×¨×˜
      if (failedCount > 0) {
      console.log(`  Failed User IDs: ${failedUserIds.join(', ')}`);
    }
    console.log(`======================================================================\n\n`);

  } catch (error) {
    // ×‘××§×¨×” ×©×œ ×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ×”×¨×§×¢ ×¢×¦××•
    console.error('[AI Bulk Update - BG] A critical error occurred in the background process:', error);
  }
}

export async function POST() {
  try {
    // 1. Authentication and Authorization (ADMIN ONLY)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized: Admin access required." }, { status: 403 });
    }
    const adminId = session.user.id;

    // ×›××Ÿ ×”×œ×•×’ ×”××§×•×¨×™ × ×©××¨, ×›×“×™ ×©×ª×¨××” ×©×”-API ×”×•×¤×¢×œ
    console.log(`[AI Bulk Update] API endpoint hit by admin: ${adminId}`);

    // 2. Fetch all active user IDs that have a profile
    const usersToUpdate = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        profile: {
          isNot: null,
        },
      },
      select: {
        id: true,
      },
    });

    const userIds = usersToUpdate.map(user => user.id);
    const totalUsers = userIds.length;

    if (totalUsers === 0) {
      return NextResponse.json({ success: true, message: "No active users with profiles found to update." });
    }

    // 3. Trigger background updates without waiting for them to complete
    //    The process will run and log its final summary independently.
    runBulkUpdateAndLog(userIds).catch(err => {
        console.error(`[AI Bulk Update] Failed to kick off background logging process:`, err);
    });

    const message = `AI profile update process has been initiated for ${totalUsers} users. The process will run in the background. Check server logs for completion status.`;
    console.log(`[AI Bulk Update] Immediate API response sent. ${message}`);

    // 4. Return an immediate success response
    return NextResponse.json({ success: true, message });

  } catch (error) {
    console.error('[AI Bulk Update] A critical error occurred in the API endpoint:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal server error.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
# Generated on: 2025-12-21 02:23:04
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\auth_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// ×”×¡×¨ ××ª ×”×œ×•×’×™× ××• ×”×¤×¢×œ ××•×ª× ×¨×§ ×‘×¡×‘×™×‘×ª ×¤×™×ª×•×—
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// ×¤×•× ×§×¦×™×” ×©×‘×•×“×§×ª ×× ×”-metadata ××›×™×œ ××ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // ×•×™×“×•× ×©×”×˜×•×§×Ÿ ×”×•× ××¡×¤×¨×™ ×‘×Ÿ 6 ×¡×¤×¨×•×ª
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ. × ×“×¨×© ×§×•×“ ×‘×Ÿ 6 ×¡×¤×¨×•×ª." },
        { status: 400 }
      );
    }

    // ××¦×™××ª ×”×˜×•×§×Ÿ
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "×§×•×“ ×œ× ×ª×§×£ ××• ×©×¤×’ ×ª×•×§×¤×•" },
        { status: 400 }
      );
    }

    // ×‘×“×™×§×” ×©×”××˜×-×“××˜×” ×ª×§×™×Ÿ ×•××›×™×œ ××ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "××™×“×¢ ××™××•×ª ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ, ×× × ×”×ª×—×œ ××ª ×”×ª×”×œ×™×š ××—×“×©" },
        { status: 400 }
      );
    }

    // ×›×¢×ª × ×™×ª×Ÿ ×œ×’×©×ª ×œ-hashedNewPassword ×‘×‘×˜×—×”, ×”××˜×-×“××˜×” ××•××ª
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // ×¢×“×›×•×Ÿ ×”×¡×™×¡××” ×•×”×©×œ××ª ×”××™××•×ª
    await db.$transaction([
      // ×¢×“×›×•×Ÿ ×¡×™×¡××”
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×”××™××•×ª
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "×”×¡×™×¡××” ×¢×•×“×›× ×” ×‘×”×¦×œ×—×”"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "×©×’×™××” ×‘×”×©×œ××ª ×©×™× ×•×™ ×”×¡×™×¡××”" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus, Language } from '@prisma/client'; 

// Zod Schema - ×›×•×œ×œ phone, ×©×“×•×ª ×“×™×•×•×¨, ×•-about
const completeProfileSchema = z.object({
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),

  phone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
  religiousLevel: z.string().optional(),
  language: z.nativeEnum(Language).optional().default(Language.he),

  // ×©×“×•×ª ×“×™×•×•×¨
  engagementEmailsConsent: z.boolean().optional().default(false),
  promotionalEmailsConsent: z.boolean().optional().default(false),

  // ========== ×”×•×¡×¤×”: ×©×“×” ×”×¡×™×¤×•×¨ ×©×œ×™ ==========
  about: z.string().max(2000, "About text is too long").optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);

    // ×§×¨×™××ª ×”×’×•×£
    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    // ×—×™×œ×•×¥ ×”××©×ª× ×™× ××”×•×•×œ×™×“×¦×™×”
    const {
        firstName,
        lastName,
        phone,
        gender,
        birthDate,
        maritalStatus,
        height,
        occupation,
        education,
        religiousLevel,
        language,
        engagementEmailsConsent,
        promotionalEmailsConsent,
        about,  // ========== ×”×•×¡×¤×” ==========
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Consents received -> Engagement: ${engagementEmailsConsent}, Promotional: ${promotionalEmailsConsent}`);
    console.log(`[API /api/auth/complete-profile] About text length: ${about?.length || 0} characters`);

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);

    const updatedUser = await prisma.$transaction(async (tx) => {
      
      // 1. ×¢×“×›×•×Ÿ/×™×¦×™×¨×ª ×”×¤×¨×•×¤×™×œ (×˜×‘×œ×ª Profile)
      console.log(`[API /api/auth/complete-profile] Inside transaction. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== ×”×•×¡×¤×” ==========

          // ×”×’×“×¨×•×ª ×‘×¨×™×¨×ª ××—×“×œ
          isProfileVisible: true,
          availabilityStatus: 'AVAILABLE',
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== ×”×•×¡×¤×” ==========

          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted.`);

      // 2. ×‘×“×™×§×” ×”×× ×™×© ×œ×¢×“×›×Ÿ ××ª ×ª××¨×™×š ××™×©×•×¨ ×”×ª× ××™×
      const currentUser = await tx.user.findUnique({ 
          where: { id: userId }, 
          select: { termsAndPrivacyAcceptedAt: true } 
      });
      
      const termsDateToSet = currentUser?.termsAndPrivacyAcceptedAt ? undefined : new Date();
      if (termsDateToSet) {
          console.log(`[API /api/auth/complete-profile] User accepts terms now. Setting timestamp.`);
      }

      // 3. ×¢×“×›×•×Ÿ ×”××©×ª××© (×˜×‘×œ×ª User)
      console.log(`[API /api/auth/complete-profile] Updating User record (names, phone, status, consents)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          firstName: firstName,
          lastName: lastName,
          phone: phone,
          isProfileComplete: true,
          language: language,

          // ××¢×‘×™×¨×™× ××ª ×”×¡×˜×˜×•×¡ ×œ××¦×‘ ×”×‘× (××™××•×ª ×˜×œ×¤×•×Ÿ)
          status: UserStatus.PENDING_PHONE_VERIFICATION,
          updatedAt: new Date(),
          
          // ×¢×“×›×•×Ÿ ×©×“×•×ª ×”×“×™×•×•×¨
          engagementEmailsConsent: engagementEmailsConsent,
          promotionalEmailsConsent: promotionalEmailsConsent,
          
          // ×¢×“×›×•×Ÿ ×ª××¨×™×š ××™×©×•×¨ ×ª× ××™× (×× ×¨×œ×•×•× ×˜×™)
          ...(termsDateToSet && { termsAndPrivacyAcceptedAt: termsDateToSet }),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true,
             engagementEmailsConsent: true,
             promotionalEmailsConsent: true
         }
      });
      
      console.log(`[API /api/auth/complete-profile] User updated. Consents saved as: Engagement=${user.engagementEmailsConsent}, Promo=${user.promotionalEmailsConsent}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Error Code: ${error.code}`);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone')) {
                 return NextResponse.json({ error: '××¡×¤×¨ ×˜×œ×¤×•×Ÿ ×–×” ×›×‘×¨ ×¨×©×•× ×‘××¢×¨×›×ª.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error.' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- ×”×•×¡×¤×” ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- ×¡×•×£ ×”×•×¡×¤×” ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "×§×™×©×•×¨ ×œ× ×ª×§×™×Ÿ ××• ×©×¤×’ ×ª×•×§×¤×•. ×× × ×‘×§×© ××”×©×“×›×Ÿ ×œ×©×œ×•×— ×”×–×× ×” ×—×“×©×”." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // ×¢×“×›×•×Ÿ ×”×¡×™×¡××”, ×¡×˜×˜×•×¡ ×”××©×ª××©, ×•×¡×˜×˜×•×¡ ×”××™××•×ª ×‘×˜×¨× ×–×§×¦×™×” ××—×ª
    await prisma.$transaction(async (tx) => {
      // ×¢×“×›×•×Ÿ ×¡×™×¡××”, ××™××•×ª ××™×™×œ, ×•×¡×˜×˜×•×¡ ×”××©×ª××©
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- ×”×•×¡×¤×” ---
          isVerified: true, // ×”××™×™×œ ××•××ª ××›×™×•×•×Ÿ ×©×”××©×ª××© ×”×’×™×¢ ××”×§×™×©×•×¨
          status: UserStatus.PENDING_PHONE_VERIFICATION, // ×”×¢×‘×¨ ××ª ×”××©×ª××© ×œ×©×œ×‘ ×”×‘×
          // isProfileComplete × ×©××¨ false ×›×™ ×”×•× ×¢×“×™×™×Ÿ ×¦×¨×™×š ×œ××œ× ×¤×¨×˜×™×
          // --- ×¡×•×£ ×”×•×¡×¤×” ---
        },
      });

      // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×”××™××•×ª (×”×˜×•×§×Ÿ × ×•×¦×œ)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "×”×—×©×‘×•×Ÿ ×”×•×’×“×¨ ×‘×”×¦×œ×—×”! ×›×¢×ª × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨ ×¢× ×”×¡×™×¡××” ×”×—×“×©×”." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×”×’×“×¨×ª ×”×—×©×‘×•×Ÿ." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘×¢×ª ××—×™×§×ª ×”××©×ª××© (×§×•×“: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || '×©×’×™××” ×‘××—×™×§×ª ×”×—×©×‘×•×Ÿ.', status: 400 };
    }

    return { message: '××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×” ×‘××—×™×§×ª ×”×—×©×‘×•×Ÿ.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. ×œ× ×–×•×”×ª×” ×¡×©×Ÿ ×¤×¢×™×œ.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: '×”×—×©×‘×•×Ÿ × ××—×§ ×‘×”×¦×œ×—×”.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: '×”××©×ª××© ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse, NextRequest } from "next/server"; // ×™×™×‘×•× NextRequest
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: NextRequest) { // ×©×™× ×•×™ ×œ-NextRequest
  try {
    // ================ 1. ×©×œ×™×¤×ª ×”-locale ××”-URL ================
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    // ==========================================================

    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "××©×ª××© ×œ× × ××¦×" },
        { status: 404 }
      );
    }

    if (!user.password) {
      return NextResponse.json(
        { error: "×œ× ×”×•×’×“×¨×” ×¡×™×¡××” ×œ×—×©×‘×•×Ÿ ×–×”. ×™×™×ª×›×Ÿ ×©× ×¨×©××ª ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×—×™×¦×•× ×™." },
        { status: 400 }
      );
    }

    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "×¡×™×¡××” × ×•×›×—×™×ª ×©×’×•×™×”" },
        { status: 400 }
      );
    }

    const hashedNewPassword = await hash(newPassword, 12);

    // ×”×©×™×¨×•×ª ×™×•×¦×¨ OTP ×‘×Ÿ 6 ×¡×¤×¨×•×ª
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      24 // Expires in 24 hours
    );

    // ×©××™×¨×ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª ×‘××˜×-×“××˜×” ×©×œ ×”××™××•×ª
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // ================ 2. ×§×¨×™××” ×œ×¤×•× ×§×¦×™×” ×”× ×›×•× ×” ×¢× ×”×¤×¨××˜×¨×™× ×”××¢×•×“×›× ×™× ================
    const otpCode = verification.token; // ×”×˜×•×§×Ÿ ×©× ×•×¦×¨ ×”×•× ×”-OTP
    const expiresInText = locale === 'he' ? '24 ×©×¢×•×ª' : '24 hours';

    await emailService.sendPasswordResetOtpEmail({
      locale,
      email: user.email,
      otp: otpCode,
      firstName: user.firstName,
      expiresIn: expiresInText,
    });
    // =================================================================================

    return NextResponse.json({ success: true, message: "×§×•×“ ××™××•×ª ×œ×©×™× ×•×™ ×¡×™×¡××” × ×©×œ×— ×œ××™×™×œ ×©×œ×š." });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "×©×’×™××” ×‘×ª×”×œ×™×š ×©×™× ×•×™ ×”×¡×™×¡××”" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/register/route.ts

import { NextRequest, NextResponse } from "next/server";
import { UserRole, UserStatus, Prisma, VerificationType, UserSource, Language } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 
import { applyRateLimit } from '@/lib/rate-limiter';
// ========== ğŸ”´ ×ª×™×§×•×Ÿ ×§×¨×™×˜×™: ×©×™××•×© ×‘-singleton ×©×œ Prisma ==========
import prisma from '@/lib/prisma';
// ==================================================================
import { 
  linkUserToReferral, 
  parseReferralCookie, 
  REFERRAL_COOKIE_NAME 
} from '@/lib/services/referralService';

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
  language?: 'he' | 'en';
  referralCode?: string;
  referralId?: string;
  referrerId?: string;
  referralLinked?: boolean;
  expiresAt?: string;
  error?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  language?: Language;
}

function handleError(error: unknown): { message: string; status: number; errorCode?: string } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.', status: 409, errorCode: 'EMAIL_EXISTS' };
          }
          return { message: `××©×ª××© ×¢× ×¤×¨×˜×™× ××œ×” ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª (×§×•×“ ${error.code}).`, status: 409, errorCode: error.code };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `×©×’×™××ª ×ª×œ×•×ª ×‘× ×ª×•× ×™× (×©×“×”: ${fieldName || '×œ× ×™×“×•×¢'}). ×× × × ×¡×” ×©× ×™×ª.`, status: 500, errorCode: error.code };
        }
        case 'P2014': return { message: '×©×’×™××” ×‘× ×ª×•× ×™× ×©×”×•×–× ×•.', status: 400, errorCode: error.code };
        // ========== ğŸ”´ ×”×•×¡×¤×”: ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×—×™×‘×•×¨ ==========
        case 'P1001': 
        case 'P1002':
        case 'P1003':
        case 'P1008':
        case 'P1017':
            return { 
              message: '×©×’×™××ª ×—×™×‘×•×¨ ×œ×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×‘×¢×•×“ ××¡×¤×¨ ×©× ×™×•×ª ××• ×”×™×¨×©× ×‘×××¦×¢×•×ª ×—×©×‘×•×Ÿ Google.', 
              status: 503, 
              errorCode: 'DB_CONNECTION_ERROR' 
            };
        // =====================================================
        default: 
            return { message: `×©×’×™××” ×‘×©××™×¨×ª ×”× ×ª×•× ×™× (×§×•×“ ×©×’×™××ª DB: ${error.code}).`, status: 500, errorCode: error.code };
      }
    }
    
    // ========== ğŸ”´ ×”×•×¡×¤×”: ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×—×™×‘×•×¨ ×›×œ×œ×™×•×ª ==========
    if (error instanceof Prisma.PrismaClientInitializationError) {
      return { 
        message: '×©×’×™××ª ×—×™×‘×•×¨ ×œ×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×‘×¢×•×“ ××¡×¤×¨ ×©× ×™×•×ª ××• ×”×™×¨×©× ×‘×××¦×¢×•×ª ×—×©×‘×•×Ÿ Google.', 
        status: 503, 
        errorCode: 'DB_INIT_ERROR' 
      };
    }
    // ==========================================================
    
    if (error instanceof Error) {
       if (error.message === '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.') {
           return { message: error.message, status: 409, errorCode: 'EMAIL_EXISTS' };
       }
       if (['×—×¡×¨×™× ×¤×¨×˜×™× ×—×•×‘×”', '×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”', '×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×, ××•×ª ×’×“×•×œ×”, ××•×ª ×§×˜× ×” ×•××¡×¤×¨'].includes(error.message)) {
           return { message: error.message, status: 400, errorCode: 'VALIDATION_ERROR' };
       }
       if (error.message.includes('××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×§×•×“ ××™××•×ª') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: '××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×¨×©×•××ª ×”××™××•×ª ×¢×§×‘ ×‘×¢×™×™×ª ×ª×œ×•×ª. ×× × × ×¡×” ×©× ×™×ª.', status: 500, errorCode: 'VERIFICATION_ERROR' };
       }
      return { message: error.message, status: 400, errorCode: 'GENERAL_ERROR' }; 
    }
    return { message: '××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×”.', status: 500, errorCode: 'UNKNOWN_ERROR' };
}


export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  logger.info('Initial registration process initiated');

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

  // ×§×¨×™××ª cookie ×¨×¤×¨×œ
  let referralData: { referralId: string; code: string; expiresAt: string } | null = null;
  try {
    const refCookie = req.cookies.get(REFERRAL_COOKIE_NAME)?.value;
    if (refCookie) {
      referralData = parseReferralCookie(refCookie);
      if (referralData) {
        if (new Date(referralData.expiresAt) < new Date()) {
          logger.info('Referral cookie expired, ignoring', { 
            referralCode: referralData.code,
            expiresAt: referralData.expiresAt 
          });
          referralData = null;
        } else {
          logger.info('Referral cookie found and valid', { 
            referralCode: referralData.code,
            referralId: referralData.referralId 
          });
        }
      }
    }
  } catch (refError) {
    logger.error('Error parsing referral cookie', { 
      errorMessage: refError instanceof Error ? refError.message : String(refError) 
    });
  }

  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password,
      language: body.language,
      referralCode: referralData?.code,
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('×—×¡×¨×™× ×¤×¨×˜×™× ×—×•×‘×”');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×, ××•×ª ×’×“×•×œ×”, ××•×ª ×§×˜× ×” ×•××¡×¤×¨');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            language: body.language || 'he',
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(),
            engagementEmailsConsent: false,
            promotionalEmailsConsent: false,
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });

    // ×§×™×©×•×¨ ×”××©×ª××© ×œ×¨×¤×¨×œ
    let referralLinked = false;
    if (referralData) {
      try {
        logger.info('Attempting to link user to referral', { 
          userId: result.user.id, 
          referralId: referralData.referralId,
          referralCode: referralData.code 
        });
        
        const linkResult = await linkUserToReferral({
          userId: result.user.id,
          referralId: referralData.referralId,
        });
        
        if (linkResult.success) {
          referralLinked = true;
          logger.info('User successfully linked to referral', { 
            userId: result.user.id, 
            referrerId: linkResult.referrerId,
            referralCode: referralData.code 
          });
        } else {
          logger.error('Failed to link user to referral', { 
            userId: result.user.id, 
            referralId: referralData.referralId,
            error: linkResult.error 
          });
        }
      } catch (refLinkError) {
        logger.error('Error linking user to referral', { 
          userId: result.user.id,
          referralId: referralData.referralId,
          errorMessage: refLinkError instanceof Error ? refLinkError.message : String(refLinkError)
        });
      }
    }
    
    let emailSentSuccess = false;
    const emailOtpExpiryText = locale === 'he' ? "×©×¢×” ××—×ª" : "1 hour"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
        await emailService.sendVerificationEmail({
                locale,
                email: result.user.email,
                verificationCode: result.generatedOtp, 
                firstName: result.user.firstName,
                expiresIn: emailOtpExpiryText 
            });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = '×”×—×©×‘×•×Ÿ × ×•×¦×¨ ×‘×”×¦×œ×—×”. ';
    if (emailSentSuccess) {
        responseMessage += `× ×©×œ×— ×§×•×“ ××™××•×ª ×œ×›×ª×•×‘×ª ×”×“×•××œ ×©×œ×š (${result.user.email}). ×× × ×”×–×Ÿ ××ª ×”×§×•×“ ×›×“×™ ×œ×”××©×™×š.`;
    } else {
        responseMessage += '×”×™×™×ª×” ×‘×¢×™×” ×‘×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª. ×ª×•×›×œ ×œ×‘×§×© ×§×•×“ ×—×“×© ×‘××¡×š ×”×‘× ××• ×œ×¤× ×•×ª ×œ×ª××™×›×”.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { 
      userId: result.user.id,
      referralLinked,
      referralCode: referralData?.code,
    });

    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id,
        referralLinked,
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status, errorCode } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        errorCode, // ========== ğŸ”´ ×”×•×¡×¤×”: ×§×•×“ ×©×’×™××” ×œ×–×™×”×•×™ ×‘×¦×“ ×”×œ×§×•×— ==========
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus, VerificationStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
  
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined;

  try {
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    logger.info('Processing password reset request', { action, email: normalizedEmail, locale });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    const genericSuccessMessage = locale === 'he'
      ? '×× ×§×™×™××ª ×›×ª×•×‘×ª ××™×™×œ ×–×• ×‘××¢×¨×›×ª ×•× ×™×ª×Ÿ ×œ××¤×¡ ×¢×‘×•×¨×” ×¡×™×¡××”, ×§×•×“ ××™××•×ª × ×©×œ×— ×›×¢×ª.'
      : 'If an account with this email exists and is eligible for password reset, a code has been sent.';

    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    const finalLocale = user.language || locale;

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING,
        },
        data: {
            status: VerificationStatus.EXPIRED,
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60 
    );
    logger.info('New password reset OTP created', { action, userId: user.id, verificationId: passwordResetVerification.id });

    try {
      const expiresInText = finalLocale === 'he' ? `${expiresInMinutes} ×“×§×•×ª` : `${expiresInMinutes} minutes`;

      await emailService.sendPasswordResetOtpEmail({
         locale: finalLocale,
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: expiresInText,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    const errorMessage = locale === 'he'
      ? '××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.'
      : 'An error occurred. Please try again later.';

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

// --- ×”×’×“×¨×•×ª ---
const RESEND_RATE_LIMIT_SECONDS = 60; // ×–××Ÿ ×”××ª× ×” ×‘×©× ×™×•×ª ×‘×™×Ÿ ×‘×§×©×•×ª ×—×•×–×¨×•×ª

// --- ×œ×•×’×¨ ×œ×¢×–×¨×” ×‘×“×™×‘××’×™× ×’ ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => {
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta }));
    },
    warn: (message: string, meta?: Record<string, unknown>) => {
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta }));
    },
    error: (message: string, meta?: any) => {
      let logMeta = meta || {};
      if (meta instanceof Error) {
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
};

// --- ×¤×•× ×§×¦×™×™×ª ×”-API ×”×¨××©×™×ª ---
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
    if (rateLimitResponse) {
        return rateLimitResponse;
    }

    logger.info("Resend phone code request received");

    // 1. --- ×‘×“×™×§×ª ××™××•×ª ××©×ª××© ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });

    try {
        // ============================ ×”×ª×™×§×•×Ÿ ×”××¨×›×–×™ (1 ××ª×•×š 2) ============================
        // 2. --- ×§×¨×™××ª ×”×©×¤×” (locale) ××¤×¨××˜×¨ ×”-URL ---
        const url = new URL(req.url);
        // ×”×’×“×¨×ª ×¢×‘×¨×™×ª ×›×©×¤×ª ×‘×¨×™×¨×ª ××—×“×œ ×× ×”×¤×¨××˜×¨ ×œ× ×§×™×™×
        const locale = (url.searchParams.get('locale') || 'he') as 'he' | 'en';
        logger.info("Processing request with locale", { userId, locale });
        // =================================================================================

        // 3. --- ××™×ª×•×¨ ×‘×§×©×ª ×”××™××•×ª ×”××—×¨×•× ×” ×©×œ ×”××©×ª××© ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc'
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            return NextResponse.json({ error: '×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”. ×™×™×ª×›×Ÿ ×©×›×‘×¨ ××™××ª×ª ××ª ××¡×¤×¨×š ××• ×©×”×§×•×“ ×¤×’ ×ª×•×§×£.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });

        // 4. --- ×‘×“×™×§×ª ×”×’×‘×œ×ª ×§×¦×‘ (Rate Limiting) ---
        const now = new Date();
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: `×× × ×”××ª×Ÿ ${timeLeft} ×©× ×™×•×ª ×œ×¤× ×™ ×‘×§×©×ª ×§×•×“ ×—×“×©.` }, { status: 429 });
        }
        logger.info("Rate limit check passed", { userId });

        // 5. --- ×§×‘×™×¢×ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×•×”×©× ---
        let targetPhone = lastVerification.target;
        let userFirstName = session.user.firstName || '';

        // ×‘××§×¨×” ×©××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×œ× × ×©××¨ ×‘×¨×©×•××ª ×”××™××•×ª, × ×©×œ×•×£ ××•×ª×• ××”××©×ª××©
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true }
             });
             if (!user?.phone) {
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                return NextResponse.json({ error: '×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ××ª×¨ ××ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×œ×©×œ×™×—×ª ×”×§×•×“.' }, { status: 500 });
             }
             targetPhone = user.phone;
             userFirstName = user.firstName || '';
        }
        
        // 6. --- ×™×¦×™×¨×ª ×§×•×“ ×—×“×© ×•×ª××¨×™×š ×ª×¤×•×’×” ×—×“×© ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // ×ª×•×§×£ ×œ-10 ×“×§×•×ª
        logger.info("Generated new OTP", { userId });

        // 7. --- ×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××™××•×ª ×‘××¡×“ ×”× ×ª×•× ×™× ---
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // ××™×¤×•×¡ ××•× ×” ×”× ×™×¡×™×•× ×•×ª
                createdAt: new Date() // ×¢×“×›×•×Ÿ ×—×•×ª××ª ×”×–××Ÿ ×œ×‘×“×™×§×ª ×”-rate limit ×”×‘××”
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });

        // ============================ ×”×ª×™×§×•×Ÿ ×”××¨×›×–×™ (2 ××ª×•×š 2) ============================
        // 8. --- ×©×œ×™×—×ª ×”×§×•×“ ×”×—×“×©, ×ª×•×š ×”×¢×‘×¨×ª ×”×©×¤×” (locale) ×œ×©×™×¨×•×ª ×”×©×œ×™×—×” ---
        // ×”×¢×¨×”: ×™×© ×œ×•×•×“× ×©×”×¤×•× ×§×¦×™×” `sendOtpViaWhatsApp` ××›×Ÿ ××§×‘×œ×ª ×¤×¨××˜×¨ ×¨×‘×™×¢×™ ×©×œ ×©×¤×”
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone, locale });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName,
        );
        // =================================================================================

        if (!otpSent) {
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            return NextResponse.json({ error: '×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª ×”×—×“×© ×‘×××¦×¢×•×ª WhatsApp × ×›×©×œ×”. ×× × × ×¡×” ×©×•×‘ ×‘×¢×•×“ ××¡×¤×¨ ×¨×’×¢×™×.' }, { status: 500 });
        }

        // 9. --- ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×” ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: '×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×” ×‘×××¦×¢×•×ª WhatsApp.' }, { status: 200 });

    } catch (error: unknown) {
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id,
            error: error
        });
        return NextResponse.json({ error: '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª ×‘×©×¨×ª. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification/route.ts

import { NextResponse, NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª ×œ×©×œ×™×—×” ×—×•×–×¨×ª ×©×œ ×§×•×“ ××™××•×ª ×œ××™×™×œ.
 * × ×§×•×“×ª ×§×¦×” ×–×• × ×•×¢×“×” ×œ××©×ª××©×™× ×©× ×¨×©××• ××š ×œ× ×§×™×‘×œ×• ××ª ×§×•×“ ×”××™××•×ª ×”×¨××©×•× ×™.
 */
export async function POST(req: NextRequest) {
  // 1. ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª ×œ×× ×™×¢×ª ×©×™××•×© ×œ×¨×¢×” ×•×©×œ×™×—×ª ×¡×¤××
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. ×©×œ×™×¤×ª ×©×¤×ª ×”×××©×§ ××”-URL ×œ×¦×•×¨×š ×ª×¨×’×•× ×”××™×™×œ
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. ×§×¨×™××ª ×•××™××•×ª ×’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { email } = body;

    if (!email || typeof email !== 'string') {
      return NextResponse.json(
        { success: false, error: "×›×ª×•×‘×ª ×”××™×™×œ ×”×™× ×©×“×” ×—×•×‘×”." },
        { status: 400 }
      );
    }

    const normalizedEmail = email.toLowerCase();

    // 4. ××™×ª×•×¨ ×”××©×ª××© ×‘××¡×“ ×”× ×ª×•× ×™×
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    });

    // ×‘×“×™×§×•×ª ×§×¦×” ×§×¨×™×˜×™×•×ª
    if (!user) {
      return NextResponse.json(
        { success: false, error: "×œ× × ××¦× ××©×ª××© ×¢× ×›×ª×•×‘×ª ×”××™×™×œ ×”×–×•." },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { success: false, error: "×—×©×‘×•×Ÿ ×–×” ×›×‘×¨ ×××•××ª. × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨." },
        { status: 400 }
      );
    }

    // 5. ×™×¦×™×¨×ª ×§×•×“ ××™××•×ª ×—×“×© ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×”××™××•×ª ×”××¨×›×–×™
    // ×”×©×™×¨×•×ª ×™×“××’ ×œ×‘×˜×œ ×ª×•×§×£ ×©×œ ×§×•×“×™× ×§×•×“××™× ×©×˜×¨× × ×•×¦×œ×•.
    const expiresInHours = 1; // ×ª×•×§×£ ×œ×©×¢×”
    const { otp: verificationCode } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email,
        expiresInHours
    );

    console.log(`[Resend Verification] New OTP generated for user: ${user.id}`);

    // 6. ×©×œ×™×—×ª ××™×™×œ ××™××•×ª ×—×“×© ×¢× ×”×§×•×“ ×©× ×•×¦×¨, ×‘×”×ª×× ×œ×©×¤×” ×©× ×‘×—×¨×”
    const expiresInText = locale === 'he' ? '×©×¢×” ××—×ª' : '1 hour';
    
    await emailService.sendVerificationEmail({
      locale, // ×”×¢×‘×¨×ª ×¤×¨××˜×¨ ×”×©×¤×”
      email: user.email,
      verificationCode: verificationCode,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Resend Verification] Verification email sent successfully to ${user.email} in ${locale}`);

    // 7. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×” ×œ×œ×§×•×—
    return NextResponse.json({
      success: true,
      message: "××™×™×œ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×”."
    });

  } catch (error: unknown) {
    // 8. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª
    console.error('[API Resend Verification] A critical error occurred:', error);
    
    const errorMessage = error instanceof Error ? error.message : "×©×’×™××” ×œ× ×¦×¤×•×™×” ×‘×©×œ×™×—×ª ××™×™×œ ×”××™××•×ª.";
    
    return NextResponse.json(
        { success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š, ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.", details: errorMessage }, 
        { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification-code/route.ts

import { NextResponse, NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { VerificationType, UserStatus } from '@prisma/client';
import { applyRateLimit } from '@/lib/rate-limiter';

// ×”×’×“×¨×ª ×˜×™×¤×•×¡ ×œ××™×“×¢ ×”× ×©××¨ ×‘×œ×•×’×™×
type LogMetadata = {
  email?: string;
  error?: unknown;
  userId?: string;
  verificationId?: string;
  status?: UserStatus;
  isVerified?: boolean;
};

// ××•×‘×™×™×§×˜ ×œ×•×’×¨ ×¤×©×•×˜ ×•×¢×§×‘×™
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: NextRequest) {
  // 1. ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  let requestBody: ResendCodeRequest | null = null;
  try {
    // 2. ×©×œ×™×¤×ª ×©×¤×ª ×”×××©×§ ××”-URL
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. ×§×¨×™××ª ×•××™××•×ª ×’×•×£ ×”×‘×§×©×”
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });

    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: '×—×¡×¨×” ×›×ª×•×‘×ª ××™××™×™×œ.' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    
    // 4. ××™×ª×•×¨ ×”××©×ª××© ×•×•×œ×™×“×¦×™×”
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail });
      return NextResponse.json({ success: false, error: '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ××™× ×• ×¨×©×•×.' }, { status: 404 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        logger.warn('User email already verified or not pending verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: '×›×ª×•×‘×ª ×”××™××™×™×œ ×›×‘×¨ ×××•××ª×ª ××• ×©××™× ×” ×××ª×™× ×” ×œ××™××•×ª.' }, { status: 400 });
    }
    
    // 5. ×™×¦×™×¨×ª ×§×•×“ ××™××•×ª ×—×“×© ×“×¨×š ×”×©×™×¨×•×ª ×”××¨×›×–×™
    const expiresInHoursForOtp = 1;
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHoursForOtp
    );
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });

    // 6. ×©×œ×™×—×ª ×”××™×™×œ ×¢× ×”×§×•×“ ×”×—×“×© ×•×”×©×¤×” ×”× ×›×•× ×”
    const emailOtpExpiryText = locale === 'he' ? "×©×¢×” ××—×ª" : "1 hour";
    await emailService.sendVerificationEmail({
      locale, // <<<<<<<<<<<< ×”×¢×‘×¨×ª ×”-locale
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    // 7. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×”
    return NextResponse.json({
      success: true,
      message: `×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×œ×›×ª×•×‘×ª ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    // 8. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×” ×—×•×–×¨×ª ×©×œ ×”×§×•×“.';
    const errorStatus = 500;

    if (error instanceof Error && error.message.includes('××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×§×•×“ ××™××•×ª')) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { hash } from 'bcryptjs';
import { z } from 'zod';

const resetPasswordSchema = z.object({
  email: z.string().email({ message: "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }),
  otp: z.string()
    .length(6, { message: "×§×•×“ ×”××™××•×ª ×—×™×™×‘ ×œ×”×›×™×œ 6 ×¡×¤×¨×•×ª" })
    .regex(/^\d+$/, { message: "×§×•×“ ××™××•×ª ×™×›×•×œ ×œ×”×›×™×œ ×¡×¤×¨×•×ª ×‘×œ×‘×“" }),
  newPassword: z.string()
    .min(8, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×" })
    .regex(/[a-z]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ××•×ª ×§×˜× ×” ××—×ª ×‘×× ×’×œ×™×ª" })
    .regex(/[A-Z]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ××•×ª ×’×“×•×œ×” ××—×ª ×‘×× ×’×œ×™×ª" })
    .regex(/[0-9]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ×¡×¤×¨×” ××—×ª" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "reset-password-with-otp";
  let requestBody: { email?: string } | undefined;

  try {
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '15 m' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action, locale });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "× ×ª×•× ×™× ×œ× ×ª×§×™× ×™×.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];

      logger.warn('Invalid input for password reset', { action, error: errors });
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });
    
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      logger.error('OTP verification failed unexpectedly or did not return required data', {
        action,
        email: normalizedEmail,
        error: verificationResult.message,
      });
      throw new Error(verificationResult.message || '×©×’×™××” ×‘××™××•×ª ×”×§×•×“.');
    }

    const { userId, id: verificationId } = verificationResult;
    logger.info('OTP verified successfully', { action, userId, verificationId });

    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
      },
      select: { email: true, firstName: true, language: true }
    });
    logger.info('User password updated in database', { action, userId });

    await VerificationService.completeVerification(verificationId);
    logger.info('Verification record marked as completed', { action, verificationId });

    if (user) {
      try {
        await emailService.sendPasswordChangedConfirmationEmail({
         locale: user.language || locale,
          email: user.email,
          firstName: user.firstName,
        });
        logger.info('Password change confirmation email sent', { action, userId, locale: user.language || locale });
      } catch (emailError) {
        logger.error('Failed to send password change confirmation email', {
          action,
          userId,
          error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
        });
      }
    }

    const successMessage = (user.language || locale) === 'he'
      ? '×”×¡×™×¡××” ××•×¤×¡×” ×‘×”×¦×œ×—×”. ×›×¢×ª ×ª×•×›×œ ×œ×”×ª×—×‘×¨ ×¢× ×”×¡×™×¡××” ×”×—×“×©×”.'
      : 'Password has been reset successfully. You can now log in with your new password.';
      
    return NextResponse.json({ success: true, message: successMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘××™×¤×•×¡ ×”×¡×™×¡××”.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '×”×§×•×“ ×›×‘×¨ × ×•×¦×œ.',
        '×ª×•×§×£ ×”×§×•×“ ×¤×’. ×× × ×‘×§×© ×§×•×“ ×—×“×©.',
        '×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ ××• ×©×œ× ×§×™×™××ª ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”.',
        '×§×•×“ ××™××•×ª ×©×’×•×™.',
        '×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª ×”××•×ª×¨. ×× × ×‘×§×© ×§×•×“ ×—×“×©.',
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400;
        if (error.message.includes("×¤×’ ×ª×•×§×¤×•")) errorStatus = 410;
        if (error.message.includes("×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª")) errorStatus = 429;
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 requests per user per hour (costly SMS/WhatsApp)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. ×§×‘×œ ××ª ×¤×¨×˜×™ ×”××©×ª××© ××”-DB (×‘×¢×™×§×¨ ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // ×©×’×™××” ×–×• ×œ× ×××•×¨×” ×œ×§×¨×•×ª ×× ×”××©×ª××© ×”×’×™×¢ ×œ×›××Ÿ ×“×¨×š ×”×©×œ××ª ×¤×¨×•×¤×™×œ
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. ×™×¦×™×¨×ª OTP ×—×“×©
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 ×“×§×•×ª ×ª×¤×•×’×”

        // 3. ×©××™×¨×ª/×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××™××•×ª
        // ××—×§ ×¨×©×•××•×ª ×§×•×“××•×ª ×œ××•×ª×• ××©×ª××© ×›×“×™ ×œ×× ×•×¢ ×‘×œ×‘×•×œ
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // ×¦×•×¨ ×¨×©×•××” ×—×“×©×”
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. ×©×œ×™×—×ª ×”-OTP ×‘×•×•××˜×¡××¤
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // ×”×—×–×¨ ×©×’×™××” ×›×“×™ ×©×”×§×œ×™×™× ×˜ ×™×•×›×œ ×œ×”×¦×™×’ ×”×•×“×¢×” ××ª××™××”
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/send-verification/route.ts

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { VerificationType, UserStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

export const runtime = 'nodejs';

/**
 * Handles requests to send a new email verification code to an existing, unverified user.
 */
export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting to prevent email spam
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. Parse and Validate Request Body
    const { email } = await req.json();
    if (!email || typeof email !== 'string') {
      return NextResponse.json({ success: false, error: "××™××™×™×œ ×”×•× ×©×“×” ×—×•×‘×”" }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 4. Find the user and perform necessary checks
    const user = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (!user) {
      // Security: Return a generic message even if the user doesn't exist to prevent enumeration.
      return NextResponse.json({ success: true, message: "×× ×§×™×™× ×—×©×‘×•×Ÿ ×”××©×•×™×š ×œ××™×™×œ ×–×”, × ×©×œ×— ××œ×™×• ×§×•×“ ××™××•×ª." }, { status: 200 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        return NextResponse.json({ success: false, error: "×—×©×‘×•×Ÿ ×–×” ×›×‘×¨ ×××•××ª ××• ×©××™× ×• ×××ª×™×Ÿ ×œ××™××•×ª." }, { status: 400 });
    }

    // 5. Create a new verification OTP using the central service
    const expiresInHours = 1; // 1-hour validity for the new code
    const { otp: generatedOtp } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHours
    );

    console.log(`[Send Verification] New OTP generated for user: ${user.id}`);

    // 6. Send the verification email using the updated Email Service
    const expiresInText = locale === 'he' ? '×©×¢×” ××—×ª' : '1 hour';
    await emailService.sendVerificationEmail({
      locale, // <-- Pass the correct locale
      email: user.email,
      verificationCode: generatedOtp,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Send Verification] Verification email re-sent successfully to ${user.email} in ${locale}`);

    // 7. Return a success response
    return NextResponse.json({ success: true, message: "×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×”." }, { status: 200 });

  } catch (error) {
    // 8. Handle unexpected errors
    console.error('[API Send Verification] A critical error occurred:', error);
    const errorMessage = error instanceof Error ? error.message : "×©×’×™××” ×œ× ×¦×¤×•×™×” ×‘×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª.";
    return NextResponse.json(
      { success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š, ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
});


export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. ×‘×“×•×§ ×©×”××¡×¤×¨ ×”×—×“×© ×œ× ×ª×¤×•×¡ ×¢×œ ×™×“×™ ××©×ª××© ×××•××ª ××—×¨
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } // ×œ× ×”××©×ª××© ×”× ×•×›×—×™
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: '××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×›×‘×¨ ×¨×©×•× ×•×¤×¢×™×œ ×‘××¢×¨×›×ª ×¢×‘×•×¨ ××©×ª××© ××—×¨.' }, { status: 409 }); // Conflict
          }

        // 2. ×¢×“×›×Ÿ ××ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×©×œ ×”××©×ª××©
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // ×§×— ××ª ×”×©× ×”××¢×•×“×›×Ÿ ×× ×¦×¨×™×š
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. ×¦×•×¨ OTP ×—×“×©
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 ×“×§×•×ª ×ª×¤×•×’×”

        // 4. ×¦×•×¨/×¢×“×›×Ÿ ×¨×©×•××ª ××™××•×ª ×¢×‘×•×¨ ×”××¡×¤×¨ ×”×—×“×©
        // ×‘×˜×œ ×¨×©×•××•×ª ×§×•×“××•×ª ×× ×”×™×•
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // ×¡××Ÿ ×§×•×“××™× ×›×¤×’×™ ×ª×•×§×£
         });
         // ×¦×•×¨ ×¨×©×•××” ×—×“×©×”
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // ×”××¡×¤×¨ ×”×—×“×©
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. ×©×œ×— ××ª ×”-OTP ×œ××¡×¤×¨ ×”×—×“×©
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // ×”×—×–×¨ ×©×’×™××”, ×™×™×ª×›×Ÿ ×©×”××¡×¤×¨ ×”×—×“×© ×œ× ×ª×§×™×Ÿ ×‘×•×•××˜×¡××¤
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // ×”×’×“×¨×ª error ×›-unknown
        console.error("API update-and-resend: An error occurred:", error);

        // ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×¡×¤×¦×™×¤×™×•×ª
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // ×©×’×™××ª ×›×¤×™×œ×•×ª - ×œ××¨×•×ª ×©×‘×“×§× ×•, ×™×™×ª×›×Ÿ ××¦×‘ race condition
            return NextResponse.json({ error: '××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×›×‘×¨ ×¨×©×•× ×‘××¢×¨×›×ª.' }, { status: 409 });
        }

        // ×©×’×™××” ×›×œ×œ×™×ª
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId ×›××Ÿ ×™×›×•×œ ×œ×”×™×•×ª string ××• undefined ×× ×”×•× ×œ× ×§×™×™× ×‘××˜××“××˜×”
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 verification attempts per IP per 15 minutes (prevents brute-force)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '15 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: '×—×¡×¨×™× ×¤×¨×˜×™ ××™××™×™×œ ××• ×§×•×“.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `×¤×•×¨××˜ ×§×•×“ ×œ× ×ª×§×™×Ÿ. ×”×§×•×“ ×¦×¨×™×š ×œ×”×›×™×œ ${OTP_LENGTH_FROM_SERVICE} ×¡×¤×¨×•×ª.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- ×”×ª×™×§×•×Ÿ ××ª×—×™×œ ×›××Ÿ ---
    // ×•×•×“× ×©-userId ×§×™×™× ×•×”×•× ××—×¨×•×–×ª ×œ×¤× ×™ ×©× ××©×™×š
    // ×¡×‘×™×¨ ×œ×”× ×™×— ×©-verificationResult.userId ×™×›×•×œ ×œ×”×™×•×ª string | null
    // ×¢×œ ×¤×™ ×”×”×’×“×¨×” ×©×œ VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // ×–×¨×•×§ ×©×’×™××” ×©×ª×˜×•×¤×œ ×‘×œ×•×§ ×”-catch ×”×›×œ×œ×™, ××• ×˜×¤×œ ×‘×” ×‘××•×¤×Ÿ ×¡×¤×¦×™×¤×™ ×™×•×ª×¨
      // ×©×’×™××” ×–×• ××¦×‘×™×¢×” ×¢×œ ×‘×¢×™×” ×œ×•×’×™×ª ×¤× ×™××™×ª ×× ×”×§×•×“ ××•××ª ××š ××™×Ÿ ××©×ª××© ××©×•×™×š
      throw new Error('×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª ×œ××—×¨ ××™××•×ª ×§×•×“ ××•×¦×œ×—.');
    }
    
    // ×›×¢×ª, ×œ××—×¨ ×”×‘×“×™×§×”, TypeScript ×™×›×•×œ ×œ×”×¡×™×§ (××• ×©× ×•×›×œ ×œ×”×¦×”×™×¨ ×‘××¤×•×¨×©)
    // ×©-userId ×”×•× string.
    const userId: string = verificationResult.userId; 
    // --- ×¡×•×£ ×”×ª×™×§×•×Ÿ ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, // ×›××Ÿ userId ××•×‘×˜×— ×œ×”×™×•×ª string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: '×›×ª×•×‘×ª ×”××™××™×™×œ ××•××ª×” ×‘×”×¦×œ×—×”! ××ª×‘×¦×¢×ª ×”×ª×—×‘×¨×•×ª ××•×˜×•××˜×™×ª...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘××™××•×ª ×”×§×•×“.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '×”×§×•×“ ×›×‘×¨ × ×•×¦×œ.', 
        '×ª×•×§×£ ×”×§×•×“ ×¤×’. ×× × ×‘×§×© ×§×•×“ ×—×“×©.', 
        '×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ ××• ×©×œ× ×§×™×™××ª ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”.', 
        '×§×•×“ ××™××•×ª ×©×’×•×™.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === '×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª.' || 
                 error.message === '×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª ×œ××—×¨ ××™××•×ª ×§×•×“ ××•×¦×œ×—.') { // ×”×•×¡×¤×ª ×”×©×’×™××” ×”×—×“×©×” ×× ×¨×•×¦×™× ×˜×™×¤×•×œ ××™×•×—×“
        errorMessage = '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.';
        // errorStatus × ×©××¨ 500 ×›×‘×¨×™×¨×ª ××—×“×œ ×œ×©×’×™××•×ª ×¤× ×™××™×•×ª, ××• ×©×ª×©× ×” ×œ×¤×™ ×”×¦×•×¨×š
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/verify-phone-code/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { z } from 'zod';
import { Prisma, VerificationType, UserStatus } from '@prisma/client';

import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { emailService } from '@/lib/email/emailService';
// ========== ğŸ”´ ×”×•×¡×¤×” ×—×“×©×”: ×™×™×‘×•× ×¤×•× ×§×¦×™×™×ª ×¢×“×›×•×Ÿ ×¨×¤×¨×œ ==========
import { updateReferralStatus } from '@/lib/services/referralService';
// ==============================================================

const MAX_VERIFICATION_ATTEMPTS = 5;

const verifyCodeSchema = z.object({
  code: z.string()
    .length(6, { message: "×§×•×“ ×”××™××•×ª ×—×™×™×‘ ×œ×”×›×™×œ 6 ×¡×¤×¨×•×ª" })
    .regex(/^\d+$/, { message: "×¤×•×¨××˜ ×§×•×“ ×œ× ×ª×§×™×Ÿ, ×¡×¤×¨×•×ª ×‘×œ×‘×“" }),
});

const logger = {
    info: (message: string, meta?: Record<string, unknown>) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
    warn: (message: string, meta?: Record<string, unknown>) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
    error: (message: string, meta?: Record<string, unknown>) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "verify-phone-code";

  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      logger.warn("× ×™×¡×™×•×Ÿ ×œ××™××•×ª ×˜×œ×¤×•×Ÿ ×œ×œ× ×¡×©×Ÿ ×¤×¢×™×œ", { action });
      return NextResponse.json({ error: 'Unauthorized - × ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("×ª×”×œ×™×š ××™××•×ª ×˜×œ×¤×•×Ÿ ×”×—×œ ×¢×‘×•×¨ ××©×ª××©", { action, userId });

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    logger.info("×©×¤×ª ×”×××©×§ ×–×•×”×ª×”", { action, userId, locale });

    const body = await req.json();
    const validation = verifyCodeSchema.safeParse(body);

    if (!validation.success) {
      logger.warn("× ×ª×•× ×™× ×œ× ×ª×§×™× ×™× ×‘×‘×§×©×”", { action, userId, errors: validation.error.flatten() });
      return NextResponse.json({ error: '× ×ª×•× ×™× ×œ× ×ª×§×™× ×™×', details: validation.error.flatten() }, { status: 400 });
    }
    const { code } = validation.data;

    const verification = await prisma.verification.findFirst({
        where: {
            userId: userId,
            type: VerificationType.PHONE_WHATSAPP,
            status: 'PENDING',
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    if (!verification) {
      logger.warn("×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×˜×œ×¤×•×Ÿ ×¤×¢×™×œ×”", { action, userId });
      return NextResponse.json({ error: '×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×” ××• ×©×”×—×©×‘×•×Ÿ ×›×‘×¨ ××•××ª.' }, { status: 404 });
    }

    if (new Date() > verification.expiresAt) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'EXPIRED' }
        });
        logger.warn("× ×™×¡×™×•×Ÿ ×œ×”×©×ª××© ×‘×§×•×“ ×©×¤×’ ×ª×•×§×¤×•", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '×§×•×“ ×”××™××•×ª ×¤×’ ×ª×•×§×£. ×× × ×‘×§×© ×§×•×“ ×—×“×©.' }, { status: 410 });
    }

    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'FAILED' }
        });
        logger.warn("×—×¨×’×” ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª ×”××•×ª×¨. ×× × ×‘×§×© ×§×•×“ ×—×“×©.' }, { status: 429 });
    }

    if (verification.token !== code) {
        const updatedVerification = await prisma.verification.update({
            where: { id: verification.id },
            data: { attempts: { increment: 1 } }
        });
        const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - updatedVerification.attempts;
        logger.warn("×”×•×–×Ÿ ×§×•×“ ××™××•×ª ×©×’×•×™", { action, userId, attemptsLeft });
        return NextResponse.json({ error: `×§×•×“ ××™××•×ª ×©×’×•×™. × ×•×ª×¨×• ×œ×š ${attemptsLeft} × ×™×¡×™×•× ×•×ª.` }, { status: 400 });
    }

    const [, updatedUser] = await prisma.$transaction([
        prisma.verification.update({
            where: { id: verification.id },
            data: {
                status: 'COMPLETED',
                completedAt: new Date(),
                attempts: verification.attempts + 1
             }
        }),
        prisma.user.update({
            where: { id: userId },
            data: {
                isPhoneVerified: true,
                isProfileComplete: true,
                status: UserStatus.ACTIVE,
                updatedAt: new Date(),
            },
            select: {
                id: true,
                email: true,
                firstName: true,
                language: true, 
                isPhoneVerified: true,
                isProfileComplete: true,
                status: true,
             }
        })
    ]);
    
    logger.info("××™××•×ª ×˜×œ×¤×•×Ÿ ×”×•×©×œ× ×‘×”×¦×œ×—×”, ××©×ª××© ×”×•×’×“×¨ ×›×¤×¢×™×œ", { action, userId });

    // ========== ğŸ”´ ×”×•×¡×¤×” ×—×“×©×”: ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×œ-VERIFIED ==========
    try {
      logger.info("×× ×¡×” ×œ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×œ-VERIFIED", { action, userId });
      
      const referralUpdateResult = await updateReferralStatus({
        userId: userId,
        newStatus: 'VERIFIED',
      });
      
      if (referralUpdateResult.success) {
        logger.info("×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×” ×œ-VERIFIED", { 
          action, 
          userId,
          referralId: referralUpdateResult.referralId,
          referrerId: referralUpdateResult.referrerId,
          newVerifiedCount: referralUpdateResult.newVerifiedCount
        });
      } else if (referralUpdateResult.error === 'NO_REFERRAL') {
        // ×”××©×ª××© ×œ× ×”×’×™×¢ ××¨×¤×¨×œ - ×–×” ×ª×§×™×Ÿ
        logger.info("×œ××©×ª××© ××™×Ÿ ×¨×¤×¨×œ ××§×•×©×¨, ×××©×™×›×™× ×¨×’×™×œ", { action, userId });
      } else {
        logger.warn("×œ× ×”×¦×œ×—× ×• ×œ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ", { 
          action, 
          userId,
          error: referralUpdateResult.error 
        });
      }
    } catch (referralError) {
      // ×œ× ×¢×•×¦×¨×™× ××ª ×”×ª×”×œ×™×š ×‘×’×œ×œ ×©×’×™××ª ×¨×¤×¨×œ
      logger.error("×©×’×™××” ×‘×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ", { 
        action, 
        userId, 
        error: referralError instanceof Error ? referralError.message : String(referralError)
      });
    }
    // =================================================================

    try {
        await emailService.sendWelcomeEmail({
            locale: updatedUser.language || locale,
            email: updatedUser.email,
            firstName: updatedUser.firstName || '×—×‘×¨',
            dashboardUrl: '/profile'
        });
        logger.info("××™×™×œ ×‘×¨×•×›×™× ×”×‘××™× × ×©×œ×— ×‘×”×¦×œ×—×”", { action, userId, email: updatedUser.email, locale: updatedUser.language || locale });
    } catch (emailError) {
        logger.error("×›×©×œ ×‘×©×œ×™×—×ª ××™×™×œ ×‘×¨×•×›×™× ×”×‘××™× ×œ××—×¨ ××™××•×ª ×˜×œ×¤×•×Ÿ", { action, userId, error: emailError });
    }

    return NextResponse.json({
         success: true,
         message: '××™××•×ª ×”×˜×œ×¤×•×Ÿ ×”×•×©×œ× ×‘×”×¦×œ×—×”!',
         user: updatedUser
    }, { status: 200 });

  } catch (error) {
    const userId = (await getServerSession(authOptions))?.user?.id || 'unknown';
    logger.error("×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ××™××•×ª ×”×˜×œ×¤×•×Ÿ", { action, userId, error });

    if (error instanceof z.ZodError) {
        return NextResponse.json({ error: '× ×ª×•× ×™× ×œ× ×ª×§×™× ×™× ×‘×‘×§×©×”', details: error.flatten() }, { status: 400 });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        return NextResponse.json({ error: '×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘×ª×”×œ×™×š ×”××™××•×ª' }, { status: 500 });
    }
    
    return NextResponse.json({ error: '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª ×‘×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for auth_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\[...nextauth]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

// ×”×¡×¨ ××ª ×”×œ×•×’×™× ××• ×”×¤×¢×œ ××•×ª× ×¨×§ ×‘×¡×‘×™×‘×ª ×¤×™×ª×•×—
const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-password-change/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { VerificationType, Prisma } from "@prisma/client";

// ×¤×•× ×§×¦×™×” ×©×‘×•×“×§×ª ×× ×”-metadata ××›×™×œ ××ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª
function hasValidPasswordMetadata(metadata: Prisma.JsonValue | null): boolean {
  return (
    typeof metadata === 'object' && 
    metadata !== null && 
    'hashedNewPassword' in metadata && 
    typeof (metadata as { hashedNewPassword: unknown }).hashedNewPassword === 'string'
  );
}

export async function POST(req: Request) {
  try {
    const { userId, token } = await req.json();

    // ×•×™×“×•× ×©×”×˜×•×§×Ÿ ×”×•× ××¡×¤×¨×™ ×‘×Ÿ 6 ×¡×¤×¨×•×ª
    if (!/^\d{6}$/.test(token)) {
      return NextResponse.json(
        { error: "×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ. × ×“×¨×© ×§×•×“ ×‘×Ÿ 6 ×¡×¤×¨×•×ª." },
        { status: 400 }
      );
    }

    // ××¦×™××ª ×”×˜×•×§×Ÿ
    const verification = await db.verification.findFirst({
      where: {
        token,
        userId,
        type: VerificationType.PASSWORD_RESET,
        status: "PENDING",
        expiresAt: { gt: new Date() }
      }
    });

    if (!verification) {
      return NextResponse.json(
        { error: "×§×•×“ ×œ× ×ª×§×£ ××• ×©×¤×’ ×ª×•×§×¤×•" },
        { status: 400 }
      );
    }

    // ×‘×“×™×§×” ×©×”××˜×-×“××˜×” ×ª×§×™×Ÿ ×•××›×™×œ ××ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª
    if (!hasValidPasswordMetadata(verification.metadata)) {
      return NextResponse.json(
        { error: "××™×“×¢ ××™××•×ª ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ, ×× × ×”×ª×—×œ ××ª ×”×ª×”×œ×™×š ××—×“×©" },
        { status: 400 }
      );
    }

    // ×›×¢×ª × ×™×ª×Ÿ ×œ×’×©×ª ×œ-hashedNewPassword ×‘×‘×˜×—×”, ×”××˜×-×“××˜×” ××•××ª
    const metadata = verification.metadata as Prisma.JsonObject;
    const hashedNewPassword = metadata.hashedNewPassword as string;

    // ×¢×“×›×•×Ÿ ×”×¡×™×¡××” ×•×”×©×œ××ª ×”××™××•×ª
    await db.$transaction([
      // ×¢×“×›×•×Ÿ ×¡×™×¡××”
      db.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword }
      }),
      // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×”××™××•×ª
      db.verification.update({
        where: { id: verification.id },
        data: { 
          status: "COMPLETED",
          completedAt: new Date()
        }
      })
    ]);

    return NextResponse.json({ 
      success: true,
      message: "×”×¡×™×¡××” ×¢×•×“×›× ×” ×‘×”×¦×œ×—×”"
    });

  } catch (error) {
    console.error("Complete password change error:", error);
    return NextResponse.json(
      { error: "×©×’×™××” ×‘×”×©×œ××ª ×©×™× ×•×™ ×”×¡×™×¡××”" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-profile\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-profile/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { Gender, UserStatus, Language } from '@prisma/client'; 

// Zod Schema - ×›×•×œ×œ phone, ×©×“×•×ª ×“×™×•×•×¨, ×•-about
const completeProfileSchema = z.object({
  firstName: z.string().min(1, "First name is required").max(100, "First name too long"),
  lastName: z.string().min(1, "Last name is required").max(100, "Last name too long"),

  phone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
  gender: z.nativeEnum(Gender),
  birthDate: z.string().refine((date) => !isNaN(Date.parse(date)), {
     message: "Invalid birth date format",
  }).refine((date) => {
      const age = Math.floor((new Date().getTime() - new Date(date).getTime()) / 31557600000);
      return age >= 18;
  }, { message: "Must be at least 18 years old" }),
  maritalStatus: z.string().min(1, "Marital status is required"),
  
  // ×”×•×¡×¤×ª ×©×“×” ×¢×™×¨ ×›×—×•×‘×”
  city: z.string().min(1, "City is required"),

  height: z.coerce.number().int().min(120).max(220).optional(),
  occupation: z.string().optional(),
  education: z.string().optional(),
  religiousLevel: z.string().optional(),
  language: z.nativeEnum(Language).optional().default(Language.he),

  // ×©×“×•×ª ×“×™×•×•×¨
  engagementEmailsConsent: z.boolean().optional().default(false),
  promotionalEmailsConsent: z.boolean().optional().default(false),

  // ========== ×”×•×¡×¤×”: ×©×“×” ×”×¡×™×¤×•×¨ ×©×œ×™ ==========
  about: z.string().max(2000, "About text is too long").optional(),
});

export async function POST(req: Request) {
  console.log("--- [API /api/auth/complete-profile] POST Request Received ---");
  console.log(`[API /api/auth/complete-profile] Timestamp: ${new Date().toISOString()}`);

  const headersObject: { [key: string]: string } = {};
  req.headers.forEach((value, key) => {
    headersObject[key] = value;
  });

  try {
    console.log("[API /api/auth/complete-profile] Attempting to get session using getServerSession...");
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      console.error("[API /api/auth/complete-profile] ERROR: Unauthorized access attempt. Session or user.id is missing.");
      return NextResponse.json({ error: 'Unauthorized - Session not found or invalid' }, { status: 401 });
    }

    const userId = session.user.id;
    console.log(`[API /api/auth/complete-profile] User authenticated with ID: ${userId}`);

    // ×§×¨×™××ª ×”×’×•×£
    console.log("[API /api/auth/complete-profile] Attempting to parse request body...");
    let body;
    try {
        body = await req.json();
    } catch (parseError) {
        console.error("[API /api/auth/complete-profile] ERROR: Failed to parse request body as JSON:", parseError);
        return NextResponse.json({ error: 'Invalid request body - Must be JSON' }, { status: 400 });
    }

    console.log("[API /api/auth/complete-profile] Validating request body with Zod schema...");
    const validation = completeProfileSchema.safeParse(body);

    if (!validation.success) {
      console.error("[API /api/auth/complete-profile] ERROR: Request body validation failed.");
      console.error("[API /api/auth/complete-profile] Validation errors:", JSON.stringify(validation.error.flatten(), null, 2));
      return NextResponse.json({ error: 'Invalid input data', details: validation.error.flatten() }, { status: 400 });
    }
    console.log("[API /api/auth/complete-profile] Request body validated successfully.");

    // ×—×™×œ×•×¥ ×”××©×ª× ×™× ××”×•×•×œ×™×“×¦×™×”
    const {
        firstName,
        lastName,
        phone,
        gender,
        birthDate,
        maritalStatus,
        city, // ×—×™×œ×•×¥ ×”×¢×™×¨
        height,
        occupation,
        education,
        religiousLevel,
        language,
        engagementEmailsConsent,
        promotionalEmailsConsent,
        about,  // ========== ×”×•×¡×¤×” ==========
    } = validation.data;

    console.log(`[API /api/auth/complete-profile] Consents received -> Engagement: ${engagementEmailsConsent}, Promotional: ${promotionalEmailsConsent}`);
    console.log(`[API /api/auth/complete-profile] About text length: ${about?.length || 0} characters`);
    console.log(`[API /api/auth/complete-profile] City received: ${city}`);

    console.log(`[API /api/auth/complete-profile] Attempting to update profile and user details for user ${userId} in a transaction.`);

    const updatedUser = await prisma.$transaction(async (tx) => {
      
      // 1. ×¢×“×›×•×Ÿ/×™×¦×™×¨×ª ×”×¤×¨×•×¤×™×œ (×˜×‘×œ×ª Profile)
      console.log(`[API /api/auth/complete-profile] Inside transaction. Upserting profile...`);
      await tx.profile.upsert({
        where: { userId: userId },
        create: {
          userId: userId,
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          city: city, // ×©××™×¨×ª ×”×¢×™×¨
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== ×”×•×¡×¤×” ==========

          // ×”×’×“×¨×•×ª ×‘×¨×™×¨×ª ××—×“×œ
          isProfileVisible: true,
          availabilityStatus: 'AVAILABLE',
        },
        update: {
          gender: gender,
          birthDate: new Date(birthDate),
          maritalStatus: maritalStatus,
          city: city, // ×¢×“×›×•×Ÿ ×”×¢×™×¨
          height: height,
          occupation: occupation,
          education: education,
          religiousLevel: religiousLevel,
          about: about,  // ========== ×”×•×¡×¤×” ==========

          updatedAt: new Date(),
        },
      });
      console.log(`[API /api/auth/complete-profile] Profile data upserted.`);

      // 2. ×‘×“×™×§×” ×”×× ×™×© ×œ×¢×“×›×Ÿ ××ª ×ª××¨×™×š ××™×©×•×¨ ×”×ª× ××™×
      const currentUser = await tx.user.findUnique({ 
          where: { id: userId }, 
          select: { termsAndPrivacyAcceptedAt: true } 
      });
      
      const termsDateToSet = currentUser?.termsAndPrivacyAcceptedAt ? undefined : new Date();
      if (termsDateToSet) {
          console.log(`[API /api/auth/complete-profile] User accepts terms now. Setting timestamp.`);
      }

      // 3. ×¢×“×›×•×Ÿ ×”××©×ª××© (×˜×‘×œ×ª User)
      console.log(`[API /api/auth/complete-profile] Updating User record (names, phone, status, consents)...`);
      const user = await tx.user.update({
        where: { id: userId },
        data: {
          firstName: firstName,
          lastName: lastName,
          phone: phone,
          isProfileComplete: true,
          language: language,

          // ××¢×‘×™×¨×™× ××ª ×”×¡×˜×˜×•×¡ ×œ××¦×‘ ×”×‘× (××™××•×ª ×˜×œ×¤×•×Ÿ)
          status: UserStatus.PENDING_PHONE_VERIFICATION,
          updatedAt: new Date(),
          
          // ×¢×“×›×•×Ÿ ×©×“×•×ª ×”×“×™×•×•×¨
          engagementEmailsConsent: engagementEmailsConsent,
          promotionalEmailsConsent: promotionalEmailsConsent,
          
          // ×¢×“×›×•×Ÿ ×ª××¨×™×š ××™×©×•×¨ ×ª× ××™× (×× ×¨×œ×•×•× ×˜×™)
          ...(termsDateToSet && { termsAndPrivacyAcceptedAt: termsDateToSet }),
        },
         select: {
             id: true,
             email: true,
             firstName: true,
             lastName: true,
             isProfileComplete: true,
             isPhoneVerified: true,
             role: true,
             status: true,
             phone: true,
             engagementEmailsConsent: true,
             promotionalEmailsConsent: true
         }
      });
      
      console.log(`[API /api/auth/complete-profile] User updated. Consents saved as: Engagement=${user.engagementEmailsConsent}, Promo=${user.promotionalEmailsConsent}`);
      return user;
    });

    console.log(`[API /api/auth/complete-profile] Profile completed successfully for user ${userId}.`);
    return NextResponse.json({ message: "Profile completed successfully", user: updatedUser }, { status: 200 });

  } catch (error: unknown) {
    console.error("[API /api/auth/complete-profile] --- ERROR IN POST HANDLER ---");
    console.error("[API /api/auth/complete-profile] Error object:", error);

    if (error instanceof z.ZodError) {
        console.error("[API /api/auth/complete-profile] Zod validation error:", JSON.stringify(error.flatten(), null, 2));
        return NextResponse.json({ error: 'Validation Error during processing', details: error.flatten() }, { status: 400 });
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        console.error(`[API /api/auth/complete-profile] Prisma Error Code: ${error.code}`);
        if (error.code === 'P2002') {
            const target = error.meta?.target as string[] | undefined;
            if (target?.includes('phone')) {
                 return NextResponse.json({ error: '××¡×¤×¨ ×˜×œ×¤×•×Ÿ ×–×” ×›×‘×¨ ×¨×©×•× ×‘××¢×¨×›×ª.' }, { status: 409 });
            } else {
                 return NextResponse.json({ error: `Unique constraint violation on ${target?.join(', ')}.` }, { status: 409 });
            }
        }
        return NextResponse.json({ error: 'Database error occurred (Prisma Known Request Error)' }, { status: 500 });
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
        console.error("[API /api/auth/complete-profile] Prisma Validation Error:", error.message);
        return NextResponse.json({ error: 'Database validation error.' }, { status: 400 });
    }

    let errorMessage = 'Internal Server Error';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    console.error(`[API /api/auth/complete-profile] Fallback error message: ${errorMessage}`);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    console.log("--- [API /api/auth/complete-profile] POST Request Finished ---");
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\complete-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/complete-setup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { hash } from "bcryptjs";
// --- ×”×•×¡×¤×” ---
import { VerificationType, VerificationStatus, UserStatus } from "@prisma/client";
// --- ×¡×•×£ ×”×•×¡×¤×” ---
import { z } from "zod";

const completeSetupSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validation = completeSetupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json({ success: false, error: "Invalid data", details: validation.error.flatten() }, { status: 400 });
    }

    const { token, password } = validation.data;

    const verification = await prisma.verification.findFirst({
      where: {
        token,
        type: VerificationType.ACCOUNT_SETUP,
        status: VerificationStatus.PENDING,
        expiresAt: {
          gt: new Date(),
        },
      },
    });

    if (!verification || !verification.userId) {
      return NextResponse.json({ success: false, error: "×§×™×©×•×¨ ×œ× ×ª×§×™×Ÿ ××• ×©×¤×’ ×ª×•×§×¤×•. ×× × ×‘×§×© ××”×©×“×›×Ÿ ×œ×©×œ×•×— ×”×–×× ×” ×—×“×©×”." }, { status: 400 });
    }

    const hashedPassword = await hash(password, 12);

    // ×¢×“×›×•×Ÿ ×”×¡×™×¡××”, ×¡×˜×˜×•×¡ ×”××©×ª××©, ×•×¡×˜×˜×•×¡ ×”××™××•×ª ×‘×˜×¨× ×–×§×¦×™×” ××—×ª
    await prisma.$transaction(async (tx) => {
      // ×¢×“×›×•×Ÿ ×¡×™×¡××”, ××™××•×ª ××™×™×œ, ×•×¡×˜×˜×•×¡ ×”××©×ª××©
      await tx.user.update({
        where: { id: verification.userId! },
        data: {
          password: hashedPassword,
          // --- ×”×•×¡×¤×” ---
          isVerified: true, // ×”××™×™×œ ××•××ª ××›×™×•×•×Ÿ ×©×”××©×ª××© ×”×’×™×¢ ××”×§×™×©×•×¨
          status: UserStatus.PENDING_PHONE_VERIFICATION, // ×”×¢×‘×¨ ××ª ×”××©×ª××© ×œ×©×œ×‘ ×”×‘×
          // isProfileComplete × ×©××¨ false ×›×™ ×”×•× ×¢×“×™×™×Ÿ ×¦×¨×™×š ×œ××œ× ×¤×¨×˜×™×
          // --- ×¡×•×£ ×”×•×¡×¤×” ---
        },
      });

      // ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×”××™××•×ª (×”×˜×•×§×Ÿ × ×•×¦×œ)
      await tx.verification.update({
        where: { id: verification.id },
        data: {
          status: VerificationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
    });

    return NextResponse.json({ success: true, message: "×”×—×©×‘×•×Ÿ ×”×•×’×“×¨ ×‘×”×¦×œ×—×”! ×›×¢×ª × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨ ×¢× ×”×¡×™×¡××” ×”×—×“×©×”." });

  } catch (error) {
    console.error("Error completing account setup:", error);
    return NextResponse.json({ success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×”×’×“×¨×ª ×”×—×©×‘×•×Ÿ." }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\delete\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/user/delete/route.ts

import { NextResponse } from 'next/server';
import { PrismaClient, Prisma } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Assuming authOptions is in this path

const prisma = new PrismaClient(); // Or import from '@/lib/prisma'

// Using the same LogMetadata and logger from your register route, now with 'warn'
type LogMetadata = {
  userId?: string;
  email?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  sessionId?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  warn: (message: string, meta?: LogMetadata) => { // Added warn function
    console.warn(JSON.stringify({ // Using console.warn
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
      // Consider removing or sanitizing errorObject in production
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

function handleError(error: unknown, userId?: string): { message: string; status: number } {
    const logMeta: LogMetadata = {
        userId,
        errorContext: "Inside handleError (delete user) before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
        logger.error(`Prisma error during user deletion: ${error.code}`, logMeta); // Still log as error for Prisma issues
        return { message: `×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘×¢×ª ××—×™×§×ª ×”××©×ª××© (×§×•×“: ${error.code}).`, status: 500 };
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError (delete user)", logMeta); // General errors logged as error

    if (error instanceof Error) {
      return { message: error.message || '×©×’×™××” ×‘××—×™×§×ª ×”×—×©×‘×•×Ÿ.', status: 400 };
    }

    return { message: '××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×” ×‘××—×™×§×ª ×”×—×©×‘×•×Ÿ.', status: 500 };
}

export async function DELETE() {
  const initialLogMeta: LogMetadata = { timestamp: new Date().toISOString() };
  logger.info('Attempting to delete user account', initialLogMeta);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id) {
    logger.warn('Unauthorized: No active session found for delete operation', { ...initialLogMeta }); // Changed to warn
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. ×œ× ×–×•×”×ª×” ×¡×©×Ÿ ×¤×¢×™×œ.' },
      { status: 401 }
    );
  }

  const userId = session.user.id;
  const userEmail = session.user.email || 'N/A';

  logger.info(`User deletion initiated by user: ${userId}`, { userId, email: userEmail, ...initialLogMeta });

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    logger.info(`User account ${userId} (${userEmail}) deleted successfully`, { userId, email: userEmail, ...initialLogMeta });
    return NextResponse.json(
      { success: true, message: '×”×—×©×‘×•×Ÿ × ××—×§ ×‘×”×¦×œ×—×”.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    const logMetaForCatch: LogMetadata = {
        userId,
        email: userEmail,
        errorContext: "Main catch block in DELETE /api/user/delete",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        logger.warn(`Attempted to delete non-existent user: ${userId}`, { ...logMetaForCatch, errorCode: error.code, errorMeta: error.meta });
        return NextResponse.json(
            { success: false, error: '×”××©×ª××© ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.'},
            { status: 404 }
        );
    }
    
    logger.error('User account deletion failed', logMetaForCatch);
    const { message, status } = handleError(error, userId); // handleError will also log the error

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message,
        details: responseErrorDetails
      },
      { status }
    );
  }
  // No finally block with prisma.$disconnect() needed if using a global/managed Prisma client
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\initiate-password-change\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/initiate-password-change/route.ts
import { NextResponse, NextRequest } from "next/server"; // ×™×™×‘×•× NextRequest
import { db } from "@/lib/db";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { hash, compare } from "bcryptjs";

export async function POST(req: NextRequest) { // ×©×™× ×•×™ ×œ-NextRequest
  try {
    // ================ 1. ×©×œ×™×¤×ª ×”-locale ××”-URL ================
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    // ==========================================================

    const { userId, currentPassword, newPassword } = await req.json();

    const user = await db.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return NextResponse.json(
        { error: "××©×ª××© ×œ× × ××¦×" },
        { status: 404 }
      );
    }

    if (!user.password) {
      return NextResponse.json(
        { error: "×œ× ×”×•×’×“×¨×” ×¡×™×¡××” ×œ×—×©×‘×•×Ÿ ×–×”. ×™×™×ª×›×Ÿ ×©× ×¨×©××ª ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×—×™×¦×•× ×™." },
        { status: 400 }
      );
    }

    const isValidPassword = await compare(currentPassword, user.password);
    if (!isValidPassword) {
      return NextResponse.json(
        { error: "×¡×™×¡××” × ×•×›×—×™×ª ×©×’×•×™×”" },
        { status: 400 }
      );
    }

    const hashedNewPassword = await hash(newPassword, 12);

    // ×”×©×™×¨×•×ª ×™×•×¦×¨ OTP ×‘×Ÿ 6 ×¡×¤×¨×•×ª
    const { verification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      24 // Expires in 24 hours
    );

    // ×©××™×¨×ª ×”×¡×™×¡××” ×”××•×¦×¤× ×ª ×‘××˜×-×“××˜×” ×©×œ ×”××™××•×ª
    await db.verification.update({
      where: { id: verification.id },
      data: {
        metadata: { hashedNewPassword }
      }
    });

    // ================ 2. ×§×¨×™××” ×œ×¤×•× ×§×¦×™×” ×”× ×›×•× ×” ×¢× ×”×¤×¨××˜×¨×™× ×”××¢×•×“×›× ×™× ================
    const otpCode = verification.token; // ×”×˜×•×§×Ÿ ×©× ×•×¦×¨ ×”×•× ×”-OTP
    const expiresInText = locale === 'he' ? '24 ×©×¢×•×ª' : '24 hours';

    await emailService.sendPasswordResetOtpEmail({
      locale,
      email: user.email,
      otp: otpCode,
      firstName: user.firstName,
      expiresIn: expiresInText,
    });
    // =================================================================================

    return NextResponse.json({ success: true, message: "×§×•×“ ××™××•×ª ×œ×©×™× ×•×™ ×¡×™×¡××” × ×©×œ×— ×œ××™×™×œ ×©×œ×š." });

  } catch (error) {
    console.error("Initiate password change error:", error);
    return NextResponse.json(
      { error: "×©×’×™××” ×‘×ª×”×œ×™×š ×©×™× ×•×™ ×”×¡×™×¡××”" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\register\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/register/route.ts

import { NextRequest, NextResponse } from "next/server";
import { UserRole, UserStatus, Prisma, VerificationType, UserSource, Language, Gender } from '@prisma/client';
import { hash } from 'bcryptjs';
import { emailService } from '@/lib/email/emailService';
import { VerificationService } from '@/lib/services/verificationService'; 
import { applyRateLimit } from '@/lib/rate-limiter';
// ×©×™××•×© ×‘-singleton ×©×œ Prisma
import prisma from '@/lib/prisma';
import { 
  linkUserToReferral, 
  parseReferralCookie, 
  REFERRAL_COOKIE_NAME 
} from '@/lib/services/referralService';

type LogMetadata = {
  userId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  status?: string;
  errorObject?: unknown;
  errorMessage?: string;
  errorName?: string;
  errorCode?: string;
  errorMeta?: unknown;
  errorStack?: string;
  errorContext?: string;
  timestamp?: string;
  hasEmail?: boolean;
  hasPassword?: boolean;
  hasFirstName?: boolean;
  hasLastName?: boolean;
  verificationId?: string;
  language?: 'he' | 'en';
  referralCode?: string;
  referralId?: string;
  referrerId?: string;
  referralLinked?: boolean;
  expiresAt?: string;
  error?: string;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    const loggableMeta = { ...meta };
    if (loggableMeta.errorObject && process.env.NODE_ENV !== 'development') {
        // In production, we might want to remove the full object if not handled properly.
    }
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...loggableMeta
    }));
  }
};

interface InitialRegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  language?: Language;
}

function handleError(error: unknown): { message: string; status: number; errorCode?: string } {
    const logMeta: LogMetadata = { 
        errorContext: "Inside handleError before processing",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMeta.errorName = error.name;
        logMeta.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMeta.errorStack = error.stack;
        }
    } else {
        logMeta.errorMessage = String(error);
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        logMeta.errorCode = error.code;
        logMeta.errorMeta = error.meta;
    } else if (typeof error === 'object' && error !== null && 'code' in error) {
        logMeta.errorCode = String((error as { code: unknown }).code);
    }
    
    logger.error("Error received in handleError", logMeta);

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002': {
          const target = error.meta?.target as string[] | undefined;
          if (target?.includes('email')) {
            return { message: '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.', status: 409, errorCode: 'EMAIL_EXISTS' };
          }
          return { message: `××©×ª××© ×¢× ×¤×¨×˜×™× ××œ×” ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª (×§×•×“ ${error.code}).`, status: 409, errorCode: error.code };
        }
        case 'P2003': {
            const fieldName = error.meta?.field_name as string | undefined;
            return { message: `×©×’×™××ª ×ª×œ×•×ª ×‘× ×ª×•× ×™× (×©×“×”: ${fieldName || '×œ× ×™×“×•×¢'}). ×× × × ×¡×” ×©× ×™×ª.`, status: 500, errorCode: error.code };
        }
        case 'P2014': return { message: '×©×’×™××” ×‘× ×ª×•× ×™× ×©×”×•×–× ×•.', status: 400, errorCode: error.code };
        case 'P1001': 
        case 'P1002':
        case 'P1003':
        case 'P1008':
        case 'P1017':
            return { 
              message: '×©×’×™××ª ×—×™×‘×•×¨ ×œ×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×‘×¢×•×“ ××¡×¤×¨ ×©× ×™×•×ª ××• ×”×™×¨×©× ×‘×××¦×¢×•×ª ×—×©×‘×•×Ÿ Google.', 
              status: 503, 
              errorCode: 'DB_CONNECTION_ERROR' 
            };
        default: 
            return { message: `×©×’×™××” ×‘×©××™×¨×ª ×”× ×ª×•× ×™× (×§×•×“ ×©×’×™××ª DB: ${error.code}).`, status: 500, errorCode: error.code };
      }
    }
    
    if (error instanceof Prisma.PrismaClientInitializationError) {
      return { 
        message: '×©×’×™××ª ×—×™×‘×•×¨ ×œ×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×‘×¢×•×“ ××¡×¤×¨ ×©× ×™×•×ª ××• ×”×™×¨×©× ×‘×××¦×¢×•×ª ×—×©×‘×•×Ÿ Google.', 
        status: 503, 
        errorCode: 'DB_INIT_ERROR' 
      };
    }
    
    if (error instanceof Error) {
       if (error.message === '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.') {
           return { message: error.message, status: 409, errorCode: 'EMAIL_EXISTS' };
       }
       if (['×—×¡×¨×™× ×¤×¨×˜×™× ×—×•×‘×”', '×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”', '×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×, ××•×ª ×’×“×•×œ×”, ××•×ª ×§×˜× ×” ×•××¡×¤×¨'].includes(error.message)) {
           return { message: error.message, status: 400, errorCode: 'VALIDATION_ERROR' };
       }
       if (error.message.includes('××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×§×•×“ ××™××•×ª') || 
           (error.cause instanceof Prisma.PrismaClientKnownRequestError && error.cause.code === 'P2003')) {
            return { message: '××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×¨×©×•××ª ×”××™××•×ª ×¢×§×‘ ×‘×¢×™×™×ª ×ª×œ×•×ª. ×× × × ×¡×” ×©× ×™×ª.', status: 500, errorCode: 'VERIFICATION_ERROR' };
       }
      return { message: error.message, status: 400, errorCode: 'GENERAL_ERROR' }; 
    }
    return { message: '××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×”.', status: 500, errorCode: 'UNKNOWN_ERROR' };
}


export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  logger.info('Initial registration process initiated');

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

  let referralData: { referralId: string; code: string; expiresAt: string } | null = null;
  try {
    const refCookie = req.cookies.get(REFERRAL_COOKIE_NAME)?.value;
    if (refCookie) {
      referralData = parseReferralCookie(refCookie);
      if (referralData) {
        if (new Date(referralData.expiresAt) < new Date()) {
          logger.info('Referral cookie expired, ignoring', { 
            referralCode: referralData.code,
            expiresAt: referralData.expiresAt 
          });
          referralData = null;
        } else {
          logger.info('Referral cookie found and valid', { 
            referralCode: referralData.code,
            referralId: referralData.referralId 
          });
        }
      }
    }
  } catch (refError) {
    logger.error('Error parsing referral cookie', { 
      errorMessage: refError instanceof Error ? refError.message : String(refError) 
    });
  }

  try {
    const body: InitialRegistrationData = await req.json();
    logger.info('Initial registration data received', {
      email: body.email,
      firstName: body.firstName,
      lastName: body.lastName,
      hasPassword: !!body.password,
      language: body.language,
      referralCode: referralData?.code,
    });

    if (!body.email || !body.password || !body.firstName || !body.lastName) {
        logger.error('Missing required fields for initial registration', { 
            hasEmail: !!body.email, 
            hasPassword: !!body.password, 
            hasFirstName: !!body.firstName, 
            hasLastName: !!body.lastName 
        });
        throw new Error('×—×¡×¨×™× ×¤×¨×˜×™× ×—×•×‘×”');
    }

    const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
    if (!emailRegex.test(body.email)) {
      logger.error('Invalid email format', { email: body.email });
      throw new Error('×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”');
    }

    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
    if (!passwordRegex.test(body.password)) {
      logger.error('Invalid password format');
      throw new Error('×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×, ××•×ª ×’×“×•×œ×”, ××•×ª ×§×˜× ×” ×•××¡×¤×¨');
    }
    
    const normalizedEmail = body.email.toLowerCase();

    const existingUser = await prisma.user.findUnique({
        where: { email: normalizedEmail }, 
    });
    if (existingUser) {
        logger.error('Email already exists in database', { email: normalizedEmail });
        throw new Error('××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª.');
    }
    
    logger.info('Starting password hashing');
    const hashedPassword = await hash(body.password, 12);
    logger.info('Password hashed successfully');

    logger.info('Starting database transaction for initial user creation');
    
    const result = await prisma.$transaction(async (tx) => { 
      const user = await tx.user.create({
          data: {
            email: normalizedEmail, 
            password: hashedPassword,
            firstName: body.firstName,
            lastName: body.lastName,
            language: body.language || 'he',
            role: UserRole.CANDIDATE,
            status: UserStatus.PENDING_EMAIL_VERIFICATION,
            isVerified: false, 
            isProfileComplete: false, 
            isPhoneVerified: false, 
            source: UserSource.REGISTRATION,
            termsAndPrivacyAcceptedAt: new Date(),
            engagementEmailsConsent: false,
            promotionalEmailsConsent: false,
            // ========================================================
            // ğŸ›‘ ×ª×™×§×•×Ÿ ×§×¨×™×˜×™: ×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ "×©×œ×“" ×›×‘×¨ ×‘×©×œ×‘ ×”×”×¨×©××”
            // ×–×” ××•× ×¢ ××™×•×–×¨×™× ×œ×”×™×•×ª "×¨×•×—×•×ª ×¨×¤××™×" ×× ×”× × ×•×˜×©×™×
            // ×‘×××¦×¢ ×”×ª×”×œ×™×š.
            // ========================================================
            profile: {
              create: {
                availabilityStatus: 'AVAILABLE',
                isProfileVisible: false,
                
                // ×”×•×¡×¤×ª ×¢×¨×›×™ ×—×•×‘×” ×–×× ×™×™× ×›×“×™ ×œ×¢×‘×•×¨ ××ª ×”×¡×›××”:
                // ×× ×• ××–×™× ×™× ×¢×¨×›×™× ××œ×• ×›×‘×¨×™×¨×ª ××—×“×œ ×›×“×™ ×©×”×™×¦×™×¨×” ×ª×¦×œ×™×—.
                // ×”××©×ª××© ×™×“×¨×•×¡ ××•×ª× ×‘×©×œ×‘ ××™×œ×•×™ ×”×¤×¨×˜×™× ×”×××™×ª×™.
                gender: Gender.FEMALE, // ×¢×¨×š ×–×× ×™ - ×™×•×—×œ×£ ×¢"×™ ×”××©×ª××©
                birthDate: new Date('2000-01-01T00:00:00.000Z'), // ×¢×¨×š ×–×× ×™
                
                // (××•×¤×¦×™×•× ×œ×™) ×× ×”×•×¡×¤×ª ××ª ×”×©×“×” ×”×–×” ×‘×¡×›××” - ×–×” ×¢×•×–×¨ ×œ×–×”×•×ª × ×ª×•× ×™× ×–×× ×™×™×
                birthDateIsApproximate: true 
              }
            }
          },
      });
      logger.info('User created successfully within transaction', { userId: user.id });

      const expiresInHoursForOtp = 1;
      const { verification: emailVerificationRecord, otp: generatedOtp } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email, 
        expiresInHoursForOtp,
        tx 
      );
      logger.info('Email verification record and OTP created within transaction', { verificationId: emailVerificationRecord.id, userId: user.id });

      return { user, generatedOtp }; 
    });

    logger.info('Database transaction completed successfully', { userId: result.user.id });

    let referralLinked = false;
    if (referralData) {
      try {
        logger.info('Attempting to link user to referral', { 
          userId: result.user.id, 
          referralId: referralData.referralId,
          referralCode: referralData.code 
        });
        
        const linkResult = await linkUserToReferral({
          userId: result.user.id,
          referralId: referralData.referralId,
        });
        
        if (linkResult.success) {
          referralLinked = true;
          logger.info('User successfully linked to referral', { 
            userId: result.user.id, 
            referrerId: linkResult.referrerId,
            referralCode: referralData.code 
          });
        } else {
          logger.error('Failed to link user to referral', { 
            userId: result.user.id, 
            referralId: referralData.referralId,
            error: linkResult.error 
          });
        }
      } catch (refLinkError) {
        logger.error('Error linking user to referral', { 
          userId: result.user.id,
          referralId: referralData.referralId,
          errorMessage: refLinkError instanceof Error ? refLinkError.message : String(refLinkError)
        });
      }
    }
    
    let emailSentSuccess = false;
    const emailOtpExpiryText = locale === 'he' ? "×©×¢×” ××—×ª" : "1 hour"; 

    try {
      logger.info('Sending verification OTP email', { userId: result.user.id, email: result.user.email });
        await emailService.sendVerificationEmail({
                locale,
                email: result.user.email,
                verificationCode: result.generatedOtp, 
                firstName: result.user.firstName,
                expiresIn: emailOtpExpiryText 
            });
      emailSentSuccess = true;
      logger.info('Verification OTP email sent successfully', { userId: result.user.id });
    } catch (error) {
      const errorLogMeta: LogMetadata = { userId: result.user.id };
      if (error instanceof Error) {
        errorLogMeta.errorName = error.name;
        errorLogMeta.errorMessage = error.message;
        errorLogMeta.errorStack = error.stack;
      } else {
        errorLogMeta.errorMessage = String(error);
      }
      logger.error('Failed to send verification OTP email', errorLogMeta);
    }
    
    let responseMessage = '×”×—×©×‘×•×Ÿ × ×•×¦×¨ ×‘×”×¦×œ×—×”. ';
    if (emailSentSuccess) {
        responseMessage += `× ×©×œ×— ×§×•×“ ××™××•×ª ×œ×›×ª×•×‘×ª ×”×“×•××œ ×©×œ×š (${result.user.email}). ×× × ×”×–×Ÿ ××ª ×”×§×•×“ ×›×“×™ ×œ×”××©×™×š.`;
    } else {
        responseMessage += '×”×™×™×ª×” ×‘×¢×™×” ×‘×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª. ×ª×•×›×œ ×œ×‘×§×© ×§×•×“ ×—×“×© ×‘××¡×š ×”×‘× ××• ×œ×¤× ×•×ª ×œ×ª××™×›×”.';
    }

    logger.info('Initial registration API call completed, user needs to verify email with OTP', { 
      userId: result.user.id,
      referralLinked,
      referralCode: referralData?.code,
    });

    return NextResponse.json(
      {
        success: true,
        message: responseMessage,
        email: result.user.email, 
        userId: result.user.id,
        referralLinked,
      },
      { status: 201 }
    );

  } catch (error: unknown) { 
    const logMetaForCatch: LogMetadata = { 
        errorContext: "Main catch block in POST /api/auth/register",
        timestamp: new Date().toISOString(),
        errorObject: error
    };

    if (error instanceof Error) {
        logMetaForCatch.errorName = error.name;
        logMetaForCatch.errorMessage = error.message;
        if (process.env.NODE_ENV === 'development') {
            logMetaForCatch.errorStack = error.stack;
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            logMetaForCatch.errorCode = error.code;
            logMetaForCatch.errorMeta = error.meta;
        } else if (typeof error === 'object' && error !== null && 'code' in error) {
            logMetaForCatch.errorCode = String((error as { code: unknown }).code);
        }
    } else {
        logMetaForCatch.errorMessage = String(error);
    }
    
    logger.error('Initial registration failed', logMetaForCatch);

    const { message, status, errorCode } = handleError(error);

    const responseErrorDetails = process.env.NODE_ENV === 'development' ? {
        name: logMetaForCatch.errorName,
        message: logMetaForCatch.errorMessage,
        code: logMetaForCatch.errorCode,
        meta: logMetaForCatch.errorMeta,
        stack: logMetaForCatch.errorStack
    } : undefined;

    return NextResponse.json(
      {
        success: false,
        error: message, 
        errorCode, 
        details: responseErrorDetails
      },
      { status }
    );
  } 
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\request-password-reset\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/request-password-reset/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType, UserStatus, VerificationStatus } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { z } from 'zod';

const requestPasswordResetSchema = z.object({
  email: z.string().email({ message: "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  status?: UserStatus | VerificationStatus;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  const url = new URL(req.url);
  const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
  
  const action = "request-password-reset";
  let requestBody: { email?: string } | undefined;

  try {
    requestBody = await req.json();
    logger.info('Request password reset initiated', { action });

    const validation = requestPasswordResetSchema.safeParse(requestBody);
    if (!validation.success) {
      logger.warn('Invalid email format for password reset request', {
        action,
        error: validation.error.flatten().fieldErrors,
      });
      return NextResponse.json({ success: false, error: validation.error.flatten().fieldErrors.email?.[0] || "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }, { status: 400 });
    }

    const { email } = validation.data;
    const normalizedEmail = email.toLowerCase();
    logger.info('Processing password reset request', { action, email: normalizedEmail, locale });

    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    const genericSuccessMessage = locale === 'he'
      ? '×× ×§×™×™××ª ×›×ª×•×‘×ª ××™×™×œ ×–×• ×‘××¢×¨×›×ª ×•× ×™×ª×Ÿ ×œ××¤×¡ ×¢×‘×•×¨×” ×¡×™×¡××”, ×§×•×“ ××™××•×ª × ×©×œ×— ×›×¢×ª.'
      : 'If an account with this email exists and is eligible for password reset, a code has been sent.';

    if (!user) {
      logger.info('User not found for password reset request', { action, email: normalizedEmail });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    const finalLocale = user.language || locale;

    if (!user.password) {
      logger.info('Password reset attempted for account without a password (e.g., OAuth user)', { action, email: normalizedEmail, userId: user.id });
      return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }
    
    if (user.status === UserStatus.BLOCKED || user.status === UserStatus.INACTIVE) {
        logger.warn('Password reset attempted for blocked or inactive user', { action, email: normalizedEmail, userId: user.id, status: user.status });
        return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });
    }

    await prisma.verification.updateMany({
        where: {
            userId: user.id,
            type: VerificationType.PASSWORD_RESET,
            status: VerificationStatus.PENDING,
        },
        data: {
            status: VerificationStatus.EXPIRED,
        },
    });
    logger.info('Invalidated previous pending password reset OTPs', { action, userId: user.id });

    const expiresInMinutes = 15;
    const { otp: generatedOtp, verification: passwordResetVerification } = await VerificationService.createVerification(
      user.id,
      VerificationType.PASSWORD_RESET,
      user.email,
      expiresInMinutes / 60 
    );
    logger.info('New password reset OTP created', { action, userId: user.id, verificationId: passwordResetVerification.id });

    try {
      const expiresInText = finalLocale === 'he' ? `${expiresInMinutes} ×“×§×•×ª` : `${expiresInMinutes} minutes`;

      await emailService.sendPasswordResetOtpEmail({
         locale: finalLocale,
        email: user.email,
        otp: generatedOtp,
        firstName: user.firstName,
        expiresIn: expiresInText,
      });
      logger.info('Password reset OTP email sent successfully', { action, userId: user.id, email: user.email });
    } catch (emailError) {
      logger.error('Failed to send password reset OTP email', {
        action,
        userId: user.id,
        email: user.email,
        error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
      });
    }

    return NextResponse.json({ success: true, message: genericSuccessMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in request password reset process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    const errorMessage = locale === 'he'
      ? '××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.'
      : 'An error occurred. Please try again later.';

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/resend-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

// --- ×”×’×“×¨×•×ª ---
const RESEND_RATE_LIMIT_SECONDS = 60; // ×–××Ÿ ×”××ª× ×” ×‘×©× ×™×•×ª ×‘×™×Ÿ ×‘×§×©×•×ª ×—×•×–×¨×•×ª

// --- ×œ×•×’×¨ ×œ×¢×–×¨×” ×‘×“×™×‘××’×™× ×’ ---
const logger = {
    info: (message: string, meta?: Record<string, unknown>) => {
      console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta }));
    },
    warn: (message: string, meta?: Record<string, unknown>) => {
      console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta }));
    },
    error: (message: string, meta?: any) => {
      let logMeta = meta || {};
      if (meta instanceof Error) {
          logMeta = { name: meta.name, message: meta.message, stack: meta.stack };
      }
      console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...logMeta }));
    },
};

// --- ×¤×•× ×§×¦×™×™×ª ×”-API ×”×¨××©×™×ª ---
export async function POST(req: NextRequest) {
    const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
    if (rateLimitResponse) {
        return rateLimitResponse;
    }

    logger.info("Resend phone code request received");

    // 1. --- ×‘×“×™×§×ª ××™××•×ª ××©×ª××© ---
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        logger.warn("Unauthorized attempt to resend code");
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("User authenticated", { userId });

    try {
        // ============================ ×”×ª×™×§×•×Ÿ ×”××¨×›×–×™ (1 ××ª×•×š 2) ============================
        // 2. --- ×§×¨×™××ª ×”×©×¤×” (locale) ××¤×¨××˜×¨ ×”-URL ---
        const url = new URL(req.url);
        // ×”×’×“×¨×ª ×¢×‘×¨×™×ª ×›×©×¤×ª ×‘×¨×™×¨×ª ××—×“×œ ×× ×”×¤×¨××˜×¨ ×œ× ×§×™×™×
        const locale = (url.searchParams.get('locale') || 'he') as 'he' | 'en';
        logger.info("Processing request with locale", { userId, locale });
        // =================================================================================

        // 3. --- ××™×ª×•×¨ ×‘×§×©×ª ×”××™××•×ª ×”××—×¨×•× ×” ×©×œ ×”××©×ª××© ---
        const lastVerification = await prisma.verification.findFirst({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING',
            },
            orderBy: {
                createdAt: 'desc'
            }
        });

        if (!lastVerification) {
            logger.warn("No pending verification found to resend", { userId });
            return NextResponse.json({ error: '×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”. ×™×™×ª×›×Ÿ ×©×›×‘×¨ ××™××ª×ª ××ª ××¡×¤×¨×š ××• ×©×”×§×•×“ ×¤×’ ×ª×•×§×£.' }, { status: 404 });
        }
        logger.info("Found pending verification record", { userId, verificationId: lastVerification.id });

        // 4. --- ×‘×“×™×§×ª ×”×’×‘×œ×ª ×§×¦×‘ (Rate Limiting) ---
        const now = new Date();
        const timeSinceLastAttempt = now.getTime() - lastVerification.createdAt.getTime();

        if (timeSinceLastAttempt < RESEND_RATE_LIMIT_SECONDS * 1000) {
            const timeLeft = Math.ceil((RESEND_RATE_LIMIT_SECONDS * 1000 - timeSinceLastAttempt) / 1000);
            logger.warn("Resend rate limit hit", { userId, timeLeft });
            return NextResponse.json({ error: `×× × ×”××ª×Ÿ ${timeLeft} ×©× ×™×•×ª ×œ×¤× ×™ ×‘×§×©×ª ×§×•×“ ×—×“×©.` }, { status: 429 });
        }
        logger.info("Rate limit check passed", { userId });

        // 5. --- ×§×‘×™×¢×ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×•×”×©× ---
        let targetPhone = lastVerification.target;
        let userFirstName = session.user.firstName || '';

        // ×‘××§×¨×” ×©××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×œ× × ×©××¨ ×‘×¨×©×•××ª ×”××™××•×ª, × ×©×œ×•×£ ××•×ª×• ××”××©×ª××©
        if (!targetPhone) {
             logger.warn(`Target phone missing in verification record ${lastVerification.id}. Fetching from user ${userId}.`);
             const user = await prisma.user.findUnique({
                 where: { id: userId },
                 select: { phone: true, firstName: true }
             });
             if (!user?.phone) {
                logger.error(`Cannot find phone number for user ${userId} in fallback during resend.`);
                return NextResponse.json({ error: '×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ××ª×¨ ××ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×œ×©×œ×™×—×ª ×”×§×•×“.' }, { status: 500 });
             }
             targetPhone = user.phone;
             userFirstName = user.firstName || '';
        }
        
        // 6. --- ×™×¦×™×¨×ª ×§×•×“ ×—×“×© ×•×ª××¨×™×š ×ª×¤×•×’×” ×—×“×© ---
        const newOtpCode = generateOtp();
        const newOtpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // ×ª×•×§×£ ×œ-10 ×“×§×•×ª
        logger.info("Generated new OTP", { userId });

        // 7. --- ×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××™××•×ª ×‘××¡×“ ×”× ×ª×•× ×™× ---
        await prisma.verification.update({
            where: { id: lastVerification.id },
            data: {
                token: newOtpCode,
                expiresAt: newOtpExpiresAt,
                attempts: 0, // ××™×¤×•×¡ ××•× ×” ×”× ×™×¡×™×•× ×•×ª
                createdAt: new Date() // ×¢×“×›×•×Ÿ ×—×•×ª××ª ×”×–××Ÿ ×œ×‘×“×™×§×ª ×”-rate limit ×”×‘××”
            }
        });
        logger.info(`Updated verification record ${lastVerification.id} with new OTP`, { userId });

        // ============================ ×”×ª×™×§×•×Ÿ ×”××¨×›×–×™ (2 ××ª×•×š 2) ============================
        // 8. --- ×©×œ×™×—×ª ×”×§×•×“ ×”×—×“×©, ×ª×•×š ×”×¢×‘×¨×ª ×”×©×¤×” (locale) ×œ×©×™×¨×•×ª ×”×©×œ×™×—×” ---
        // ×”×¢×¨×”: ×™×© ×œ×•×•×“× ×©×”×¤×•× ×§×¦×™×” `sendOtpViaWhatsApp` ××›×Ÿ ××§×‘×œ×ª ×¤×¨××˜×¨ ×¨×‘×™×¢×™ ×©×œ ×©×¤×”
        logger.info("Attempting to send new OTP via WhatsApp", { userId, phone: targetPhone, locale });
        const otpSent = await sendOtpViaWhatsApp(
            targetPhone,
            newOtpCode,
            userFirstName,
        );
        // =================================================================================

        if (!otpSent) {
            logger.error(`Failed to resend OTP via WhatsApp for user ${userId}.`, { userId, phone: targetPhone });
            return NextResponse.json({ error: '×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª ×”×—×“×© ×‘×××¦×¢×•×ª WhatsApp × ×›×©×œ×”. ×× × × ×¡×” ×©×•×‘ ×‘×¢×•×“ ××¡×¤×¨ ×¨×’×¢×™×.' }, { status: 500 });
        }

        // 9. --- ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×” ---
        logger.info("New OTP resent successfully via WhatsApp", { userId });
        return NextResponse.json({ message: '×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×” ×‘×××¦×¢×•×ª WhatsApp.' }, { status: 200 });

    } catch (error: unknown) {
        logger.error("An error occurred during the resend code process", {
            userId: session?.user?.id,
            error: error
        });
        return NextResponse.json({ error: '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª ×‘×©×¨×ª. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification/route.ts

import { NextResponse, NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { emailService } from "@/lib/email/emailService";
import { VerificationService } from "@/lib/services/verificationService";
import { VerificationType } from "@prisma/client";
import { applyRateLimit } from "@/lib/rate-limiter";

/**
 * ××˜×¤×œ ×‘×‘×§×©×•×ª ×œ×©×œ×™×—×” ×—×•×–×¨×ª ×©×œ ×§×•×“ ××™××•×ª ×œ××™×™×œ.
 * × ×§×•×“×ª ×§×¦×” ×–×• × ×•×¢×“×” ×œ××©×ª××©×™× ×©× ×¨×©××• ××š ×œ× ×§×™×‘×œ×• ××ª ×§×•×“ ×”××™××•×ª ×”×¨××©×•× ×™.
 */
export async function POST(req: NextRequest) {
  // 1. ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª ×œ×× ×™×¢×ª ×©×™××•×© ×œ×¨×¢×” ×•×©×œ×™×—×ª ×¡×¤××
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. ×©×œ×™×¤×ª ×©×¤×ª ×”×××©×§ ××”-URL ×œ×¦×•×¨×š ×ª×¨×’×•× ×”××™×™×œ
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. ×§×¨×™××ª ×•××™××•×ª ×’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const { email } = body;

    if (!email || typeof email !== 'string') {
      return NextResponse.json(
        { success: false, error: "×›×ª×•×‘×ª ×”××™×™×œ ×”×™× ×©×“×” ×—×•×‘×”." },
        { status: 400 }
      );
    }

    const normalizedEmail = email.toLowerCase();

    // 4. ××™×ª×•×¨ ×”××©×ª××© ×‘××¡×“ ×”× ×ª×•× ×™×
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    });

    // ×‘×“×™×§×•×ª ×§×¦×” ×§×¨×™×˜×™×•×ª
    if (!user) {
      return NextResponse.json(
        { success: false, error: "×œ× × ××¦× ××©×ª××© ×¢× ×›×ª×•×‘×ª ×”××™×™×œ ×”×–×•." },
        { status: 404 }
      );
    }

    if (user.isVerified) {
      return NextResponse.json(
        { success: false, error: "×—×©×‘×•×Ÿ ×–×” ×›×‘×¨ ×××•××ª. × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨." },
        { status: 400 }
      );
    }

    // 5. ×™×¦×™×¨×ª ×§×•×“ ××™××•×ª ×—×“×© ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×”××™××•×ª ×”××¨×›×–×™
    // ×”×©×™×¨×•×ª ×™×“××’ ×œ×‘×˜×œ ×ª×•×§×£ ×©×œ ×§×•×“×™× ×§×•×“××™× ×©×˜×¨× × ×•×¦×œ×•.
    const expiresInHours = 1; // ×ª×•×§×£ ×œ×©×¢×”
    const { otp: verificationCode } = await VerificationService.createVerification(
        user.id,
        VerificationType.EMAIL,
        user.email,
        expiresInHours
    );

    console.log(`[Resend Verification] New OTP generated for user: ${user.id}`);

    // 6. ×©×œ×™×—×ª ××™×™×œ ××™××•×ª ×—×“×© ×¢× ×”×§×•×“ ×©× ×•×¦×¨, ×‘×”×ª×× ×œ×©×¤×” ×©× ×‘×—×¨×”
    const expiresInText = locale === 'he' ? '×©×¢×” ××—×ª' : '1 hour';
    
    await emailService.sendVerificationEmail({
      locale, // ×”×¢×‘×¨×ª ×¤×¨××˜×¨ ×”×©×¤×”
      email: user.email,
      verificationCode: verificationCode,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Resend Verification] Verification email sent successfully to ${user.email} in ${locale}`);

    // 7. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×” ×œ×œ×§×•×—
    return NextResponse.json({
      success: true,
      message: "××™×™×œ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×”."
    });

  } catch (error: unknown) {
    // 8. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª
    console.error('[API Resend Verification] A critical error occurred:', error);
    
    const errorMessage = error instanceof Error ? error.message : "×©×’×™××” ×œ× ×¦×¤×•×™×” ×‘×©×œ×™×—×ª ××™×™×œ ×”××™××•×ª.";
    
    return NextResponse.json(
        { success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š, ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.", details: errorMessage }, 
        { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\resend-verification-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/resend-verification-code/route.ts

import { NextResponse, NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { VerificationType, UserStatus } from '@prisma/client';
import { applyRateLimit } from '@/lib/rate-limiter';

// ×”×’×“×¨×ª ×˜×™×¤×•×¡ ×œ××™×“×¢ ×”× ×©××¨ ×‘×œ×•×’×™×
type LogMetadata = {
  email?: string;
  error?: unknown;
  userId?: string;
  verificationId?: string;
  status?: UserStatus;
  isVerified?: boolean;
};

// ××•×‘×™×™×§×˜ ×œ×•×’×¨ ×¤×©×•×˜ ×•×¢×§×‘×™
const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

interface ResendCodeRequest {
  email: string;
}

export async function POST(req: NextRequest) {
  // 1. ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  let requestBody: ResendCodeRequest | null = null;
  try {
    // 2. ×©×œ×™×¤×ª ×©×¤×ª ×”×××©×§ ××”-URL
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. ×§×¨×™××ª ×•××™××•×ª ×’×•×£ ×”×‘×§×©×”
    requestBody = await req.json();
    const { email } = requestBody!;

    logger.info('Resend verification code process initiated', { email });

    if (!email) {
      logger.error('Missing email for resending code');
      return NextResponse.json({ success: false, error: '×—×¡×¨×” ×›×ª×•×‘×ª ××™××™×™×œ.' }, { status: 400 });
    }
    
    const normalizedEmail = email.toLowerCase();
    
    // 4. ××™×ª×•×¨ ×”××©×ª××© ×•×•×œ×™×“×¦×™×”
    const user = await prisma.user.findUnique({
      where: { email: normalizedEmail },
    });

    if (!user) {
      logger.warn('User not found for resending code', { email: normalizedEmail });
      return NextResponse.json({ success: false, error: '××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ××™× ×• ×¨×©×•×.' }, { status: 404 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        logger.warn('User email already verified or not pending verification', { email: normalizedEmail, userId: user.id, status: user.status, isVerified: user.isVerified });
        return NextResponse.json({ success: false, error: '×›×ª×•×‘×ª ×”××™××™×™×œ ×›×‘×¨ ×××•××ª×ª ××• ×©××™× ×” ×××ª×™× ×” ×œ××™××•×ª.' }, { status: 400 });
    }
    
    // 5. ×™×¦×™×¨×ª ×§×•×“ ××™××•×ª ×—×“×© ×“×¨×š ×”×©×™×¨×•×ª ×”××¨×›×–×™
    const expiresInHoursForOtp = 1;
    const { otp: newOtp, verification: newVerificationRecord } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHoursForOtp
    );
    logger.info('New verification record created for resend', { verificationId: newVerificationRecord.id, userId: user.id });

    // 6. ×©×œ×™×—×ª ×”××™×™×œ ×¢× ×”×§×•×“ ×”×—×“×© ×•×”×©×¤×” ×”× ×›×•× ×”
    const emailOtpExpiryText = locale === 'he' ? "×©×¢×” ××—×ª" : "1 hour";
    await emailService.sendVerificationEmail({
      locale, // <<<<<<<<<<<< ×”×¢×‘×¨×ª ×”-locale
      email: user.email,
      verificationCode: newOtp,
      firstName: user.firstName,
      expiresIn: emailOtpExpiryText,
    });

    logger.info('New verification code sent successfully', { email: user.email, userId: user.id });

    // 7. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×”
    return NextResponse.json({
      success: true,
      message: `×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×œ×›×ª×•×‘×ª ${user.email}.`,
    }, { status: 200 });

  } catch (error: unknown) {
    // 8. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Failed to resend verification code', { email: emailForLog, error: errorDetails });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×” ×—×•×–×¨×ª ×©×œ ×”×§×•×“.';
    const errorStatus = 500;

    if (error instanceof Error && error.message.includes('××™×¨×¢×” ×©×’×™××” ×‘×™×¦×™×¨×ª ×§×•×“ ××™××•×ª')) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/reset-password/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import prisma from '@/lib/prisma';
import { VerificationType } from '@prisma/client';
import { VerificationService } from '@/lib/services/verificationService';
import { emailService } from '@/lib/email/emailService';
import { hash } from 'bcryptjs';
import { z } from 'zod';

const resetPasswordSchema = z.object({
  email: z.string().email({ message: "×›×ª×•×‘×ª ××™×™×œ ×œ× ×ª×§×™× ×”" }),
  otp: z.string()
    .length(6, { message: "×§×•×“ ×”××™××•×ª ×—×™×™×‘ ×œ×”×›×™×œ 6 ×¡×¤×¨×•×ª" })
    .regex(/^\d+$/, { message: "×§×•×“ ××™××•×ª ×™×›×•×œ ×œ×”×›×™×œ ×¡×¤×¨×•×ª ×‘×œ×‘×“" }),
  newPassword: z.string()
    .min(8, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª 8 ×ª×•×•×™×" })
    .regex(/[a-z]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ××•×ª ×§×˜× ×” ××—×ª ×‘×× ×’×œ×™×ª" })
    .regex(/[A-Z]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ××•×ª ×’×“×•×œ×” ××—×ª ×‘×× ×’×œ×™×ª" })
    .regex(/[0-9]/, { message: "×”×¡×™×¡××” ×—×™×™×‘×ª ×œ×”×›×™×œ ×œ×¤×—×•×ª ×¡×¤×¨×” ××—×ª" }),
});

type LogMetadata = {
  email?: string;
  userId?: string;
  verificationId?: string;
  error?: unknown;
  timestamp?: string;
  action?: string;
  locale?: 'he' | 'en';
};

const logger = {
  info: (message: string, meta?: LogMetadata) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
  warn: (message: string, meta?: LogMetadata) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
  error: (message: string, meta?: LogMetadata) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "reset-password-with-otp";
  let requestBody: { email?: string } | undefined;

  try {
    const rateLimitResponse = await applyRateLimit(req, { requests: 10, window: '15 m' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    requestBody = await req.json();
    logger.info('Reset password with OTP process initiated', { action, locale });

    const validation = resetPasswordSchema.safeParse(requestBody);
    if (!validation.success) {
      const errors = validation.error.flatten().fieldErrors;
      let errorMessage = "× ×ª×•× ×™× ×œ× ×ª×§×™× ×™×.";
      if (errors.email?.[0]) errorMessage = errors.email[0];
      else if (errors.otp?.[0]) errorMessage = errors.otp[0];
      else if (errors.newPassword?.[0]) errorMessage = errors.newPassword[0];

      logger.warn('Invalid input for password reset', { action, error: errors });
      return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
    }

    const { email, otp, newPassword } = validation.data;
    const normalizedEmail = email.toLowerCase();

    logger.info('Attempting to verify OTP for password reset', { action, email: normalizedEmail });
    
    const verificationResult = await VerificationService.verifyCode(
      otp,
      VerificationType.PASSWORD_RESET,
      normalizedEmail
    );

    if (!verificationResult.success || !verificationResult.userId || !verificationResult.id) {
      logger.error('OTP verification failed unexpectedly or did not return required data', {
        action,
        email: normalizedEmail,
        error: verificationResult.message,
      });
      throw new Error(verificationResult.message || '×©×’×™××” ×‘××™××•×ª ×”×§×•×“.');
    }

    const { userId, id: verificationId } = verificationResult;
    logger.info('OTP verified successfully', { action, userId, verificationId });

    const hashedPassword = await hash(newPassword, 12);
    logger.info('New password hashed', { action, userId });

    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        password: hashedPassword,
        updatedAt: new Date(),
      },
      select: { email: true, firstName: true, language: true }
    });
    logger.info('User password updated in database', { action, userId });

    await VerificationService.completeVerification(verificationId);
    logger.info('Verification record marked as completed', { action, verificationId });

    if (user) {
      try {
        await emailService.sendPasswordChangedConfirmationEmail({
         locale: user.language || locale,
          email: user.email,
          firstName: user.firstName,
        });
        logger.info('Password change confirmation email sent', { action, userId, locale: user.language || locale });
      } catch (emailError) {
        logger.error('Failed to send password change confirmation email', {
          action,
          userId,
          error: emailError instanceof Error ? { name: emailError.name, message: emailError.message } : emailError,
        });
      }
    }

    const successMessage = (user.language || locale) === 'he'
      ? '×”×¡×™×¡××” ××•×¤×¡×” ×‘×”×¦×œ×—×”. ×›×¢×ª ×ª×•×›×œ ×œ×”×ª×—×‘×¨ ×¢× ×”×¡×™×¡××” ×”×—×“×©×”.'
      : 'Password has been reset successfully. You can now log in with your new password.';
      
    return NextResponse.json({ success: true, message: successMessage }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    logger.error('Critical error in reset password with OTP process', {
      action,
      email: emailForLog,
      error: error instanceof Error ? { name: error.name, message: error.message } : String(error),
    });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘××™×¤×•×¡ ×”×¡×™×¡××”.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '×”×§×•×“ ×›×‘×¨ × ×•×¦×œ.',
        '×ª×•×§×£ ×”×§×•×“ ×¤×’. ×× × ×‘×§×© ×§×•×“ ×—×“×©.',
        '×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ ××• ×©×œ× ×§×™×™××ª ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”.',
        '×§×•×“ ××™××•×ª ×©×’×•×™.',
        '×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª ×”××•×ª×¨. ×× × ×‘×§×© ×§×•×“ ×—×“×©.',
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400;
        if (error.message.includes("×¤×’ ×ª×•×§×¤×•")) errorStatus = 410;
        if (error.message.includes("×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª")) errorStatus = 429;
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: errorStatus }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/send-phone-code/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType } from '@prisma/client';

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 requests per user per hour (costly SMS/WhatsApp)
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    try {
        // 1. ×§×‘×œ ××ª ×¤×¨×˜×™ ×”××©×ª××© ××”-DB (×‘×¢×™×§×¨ ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ)
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { phone: true, firstName: true }
        });

        if (!user || !user.phone) {
            console.error(`API send-phone-code: User ${userId} not found or phone number missing.`);
            // ×©×’×™××” ×–×• ×œ× ×××•×¨×” ×œ×§×¨×•×ª ×× ×”××©×ª××© ×”×’×™×¢ ×œ×›××Ÿ ×“×¨×š ×”×©×œ××ª ×¤×¨×•×¤×™×œ
            return NextResponse.json({ error: 'User phone number not found.' }, { status: 400 });
        }

        // 2. ×™×¦×™×¨×ª OTP ×—×“×©
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 ×“×§×•×ª ×ª×¤×•×’×”

        // 3. ×©××™×¨×ª/×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××™××•×ª
        // ××—×§ ×¨×©×•××•×ª ×§×•×“××•×ª ×œ××•×ª×• ××©×ª××© ×›×“×™ ×œ×× ×•×¢ ×‘×œ×‘×•×œ
        await prisma.verification.deleteMany({
            where: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                status: 'PENDING'
            }
        });
        // ×¦×•×¨ ×¨×©×•××” ×—×“×©×”
        await prisma.verification.create({
            data: {
                userId: userId,
                type: VerificationType.PHONE_WHATSAPP,
                target: user.phone,
                token: otpCode,
                expiresAt: otpExpiresAt,
                status: 'PENDING',
            }
        });
        console.log(`API send-phone-code: Verification record created/updated for user ${userId}`);

        // 4. ×©×œ×™×—×ª ×”-OTP ×‘×•×•××˜×¡××¤
        const otpSent = await sendOtpViaWhatsApp(user.phone, otpCode, user.firstName);

        if (!otpSent) {
            console.error(`API send-phone-code: Failed to send OTP via WhatsApp for user ${userId}.`);
            // ×”×—×–×¨ ×©×’×™××” ×›×“×™ ×©×”×§×œ×™×™× ×˜ ×™×•×›×œ ×œ×”×¦×™×’ ×”×•×“×¢×” ××ª××™××”
            return NextResponse.json({ error: 'Failed to send verification code via WhatsApp.' }, { status: 500 });
        }

        console.log(`API send-phone-code: OTP sent successfully via WhatsApp for user ${userId}`);
        return NextResponse.json({ message: 'Verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error) {
        console.error("API send-phone-code: An error occurred:", error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\send-verification\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/send-verification/route.ts

import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { VerificationType, UserStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimit } from "@/lib/rate-limiter";

export const runtime = 'nodejs';

/**
 * Handles requests to send a new email verification code to an existing, unverified user.
 */
export async function POST(req: NextRequest) {
  // 1. Apply Rate Limiting to prevent email spam
  const rateLimitResponse = await applyRateLimit(req, { requests: 5, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // 2. Get Locale from URL for translation
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    // 3. Parse and Validate Request Body
    const { email } = await req.json();
    if (!email || typeof email !== 'string') {
      return NextResponse.json({ success: false, error: "××™××™×™×œ ×”×•× ×©×“×” ×—×•×‘×”" }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    // 4. Find the user and perform necessary checks
    const user = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (!user) {
      // Security: Return a generic message even if the user doesn't exist to prevent enumeration.
      return NextResponse.json({ success: true, message: "×× ×§×™×™× ×—×©×‘×•×Ÿ ×”××©×•×™×š ×œ××™×™×œ ×–×”, × ×©×œ×— ××œ×™×• ×§×•×“ ××™××•×ª." }, { status: 200 });
    }

    if (user.isVerified || user.status !== UserStatus.PENDING_EMAIL_VERIFICATION) {
        return NextResponse.json({ success: false, error: "×—×©×‘×•×Ÿ ×–×” ×›×‘×¨ ×××•××ª ××• ×©××™× ×• ×××ª×™×Ÿ ×œ××™××•×ª." }, { status: 400 });
    }

    // 5. Create a new verification OTP using the central service
    const expiresInHours = 1; // 1-hour validity for the new code
    const { otp: generatedOtp } = await VerificationService.createVerification(
      user.id,
      VerificationType.EMAIL,
      user.email,
      expiresInHours
    );

    console.log(`[Send Verification] New OTP generated for user: ${user.id}`);

    // 6. Send the verification email using the updated Email Service
    const expiresInText = locale === 'he' ? '×©×¢×” ××—×ª' : '1 hour';
    await emailService.sendVerificationEmail({
      locale, // <-- Pass the correct locale
      email: user.email,
      verificationCode: generatedOtp,
      firstName: user.firstName,
      expiresIn: expiresInText
    });

    console.log(`[Send Verification] Verification email re-sent successfully to ${user.email} in ${locale}`);

    // 7. Return a success response
    return NextResponse.json({ success: true, message: "×§×•×“ ××™××•×ª ×—×“×© × ×©×œ×— ×‘×”×¦×œ×—×”." }, { status: 200 });

  } catch (error) {
    // 8. Handle unexpected errors
    console.error('[API Send Verification] A critical error occurred:', error);
    const errorMessage = error instanceof Error ? error.message : "×©×’×™××” ×œ× ×¦×¤×•×™×” ×‘×©×œ×™×—×ª ×§×•×“ ×”××™××•×ª.";
    return NextResponse.json(
      { success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×ª×”×œ×™×š, ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\update-and-resend-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/update-and-resend-code/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateOtp, sendOtpViaWhatsApp } from '@/lib/phoneVerificationService';
import { VerificationType, Prisma } from '@prisma/client';
import { z } from 'zod';

const updatePhoneSchema = z.object({
  newPhone: z.string().refine(
    (phone) => /^\+[1-9]\d{1,14}$/.test(phone), 
    { message: "Invalid international phone number format (E.164 required)." }
  ),
});


export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    try {
        const body = await req.json();
        const validation = updatePhoneSchema.safeParse(body);

        if (!validation.success) {
          return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400 });
        }
        const { newPhone } = validation.data;

        // 1. ×‘×“×•×§ ×©×”××¡×¤×¨ ×”×—×“×© ×œ× ×ª×¤×•×¡ ×¢×œ ×™×“×™ ××©×ª××© ×××•××ª ××—×¨
        const existingVerifiedPhoneUser = await prisma.user.findFirst({
            where: {
              phone: newPhone,
              isPhoneVerified: true,
              id: { not: userId } // ×œ× ×”××©×ª××© ×”× ×•×›×—×™
            }
          });

          if (existingVerifiedPhoneUser) {
            console.warn(`API update-and-resend: Attempt to update to phone ${newPhone} already verified by user ${existingVerifiedPhoneUser.id}`);
            return NextResponse.json({ error: '××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×›×‘×¨ ×¨×©×•× ×•×¤×¢×™×œ ×‘××¢×¨×›×ª ×¢×‘×•×¨ ××©×ª××© ××—×¨.' }, { status: 409 }); // Conflict
          }

        // 2. ×¢×“×›×Ÿ ××ª ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×©×œ ×”××©×ª××©
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { phone: newPhone },
            select: { firstName: true, phone: true } // ×§×— ××ª ×”×©× ×”××¢×•×“×›×Ÿ ×× ×¦×¨×™×š
        });
         console.log(`API update-and-resend: Updated phone number for user ${userId} to ${newPhone}`);


        // 3. ×¦×•×¨ OTP ×—×“×©
        const otpCode = generateOtp();
        const otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 ×“×§×•×ª ×ª×¤×•×’×”

        // 4. ×¦×•×¨/×¢×“×›×Ÿ ×¨×©×•××ª ××™××•×ª ×¢×‘×•×¨ ×”××¡×¤×¨ ×”×—×“×©
        // ×‘×˜×œ ×¨×©×•××•×ª ×§×•×“××•×ª ×× ×”×™×•
         await prisma.verification.updateMany({
             where: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 status: 'PENDING',
             },
             data: { status: 'EXPIRED' } // ×¡××Ÿ ×§×•×“××™× ×›×¤×’×™ ×ª×•×§×£
         });
         // ×¦×•×¨ ×¨×©×•××” ×—×“×©×”
         await prisma.verification.create({
             data: {
                 userId: userId,
                 type: VerificationType.PHONE_WHATSAPP,
                 target: newPhone, // ×”××¡×¤×¨ ×”×—×“×©
                 token: otpCode,
                 expiresAt: otpExpiresAt,
                 status: 'PENDING',
             }
         });
         console.log(`API update-and-resend: Created new verification record for user ${userId} with new phone ${newPhone}`);

        // 5. ×©×œ×— ××ª ×”-OTP ×œ××¡×¤×¨ ×”×—×“×©
        const otpSent = await sendOtpViaWhatsApp(newPhone, otpCode, updatedUser.firstName);

        if (!otpSent) {
            console.error(`API update-and-resend: Failed to send OTP via WhatsApp to new phone ${newPhone} for user ${userId}.`);
            // ×”×—×–×¨ ×©×’×™××”, ×™×™×ª×›×Ÿ ×©×”××¡×¤×¨ ×”×—×“×© ×œ× ×ª×§×™×Ÿ ×‘×•×•××˜×¡××¤
            return NextResponse.json({ error: 'Failed to send verification code to the new phone number via WhatsApp. Please check the number.' }, { status: 500 });
        }

        console.log(`API update-and-resend: OTP sent successfully to new phone ${newPhone} for user ${userId}`);
        return NextResponse.json({ message: 'Phone number updated and new verification code sent successfully via WhatsApp.' }, { status: 200 });

    } catch (error: unknown) { // ×”×’×“×¨×ª error ×›-unknown
        console.error("API update-and-resend: An error occurred:", error);

        // ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×¡×¤×¦×™×¤×™×•×ª
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: 'Invalid request data', details: error.flatten() }, { status: 400 });
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             // ×©×’×™××ª ×›×¤×™×œ×•×ª - ×œ××¨×•×ª ×©×‘×“×§× ×•, ×™×™×ª×›×Ÿ ××¦×‘ race condition
            return NextResponse.json({ error: '××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ ×›×‘×¨ ×¨×©×•× ×‘××¢×¨×›×ª.' }, { status: 409 });
        }

        // ×©×’×™××” ×›×œ×œ×™×ª
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-email-code\route.ts
--------------------------------------------------------------------------------
Content:
// app/api/auth/verify-email-code/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { VerificationService } from '@/lib/services/verificationService';
import { VerificationType, PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

type LogMetadata = {
  email?: string;
  code?: string; 
  codePresent?: boolean;
  codeLength?: number;
  error?: unknown;
  timestamp?: string;
  verificationId?: string;
  userId?: string; // userId ×›××Ÿ ×™×›×•×œ ×œ×”×™×•×ª string ××• undefined ×× ×”×•× ×œ× ×§×™×™× ×‘××˜××“××˜×”
  authTokenGenerated?: boolean;
};

const logger = {
  info: (message: string, meta?: LogMetadata) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      ...meta
    }));
  },
  error: (message: string, meta?: LogMetadata) => {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      ...meta
    }));
  }
};

interface VerifyEmailCodeRequest {
  email: string;
  code: string;
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 verification attempts per IP per 15 minutes (prevents brute-force)
  const rateLimitResponse = await applyRateLimit(req, { requests: 15, window: '15 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  let requestBody: VerifyEmailCodeRequest | null = null;
  try {
    requestBody = await req.json();
    const { email, code } = requestBody!;

    logger.info('Email code verification process initiated', { email });

    if (!email || !code) {
      logger.error('Missing email or code for verification', { email: email, codePresent: !!code });
      return NextResponse.json({ success: false, error: '×—×¡×¨×™× ×¤×¨×˜×™ ××™××™×™×œ ××• ×§×•×“.' }, { status: 400 });
    }
    
    const OTP_LENGTH_FROM_SERVICE = 6;
    if (code.length !== OTP_LENGTH_FROM_SERVICE || !/^\d+$/.test(code)) {
        logger.error('Invalid code format', { email, code });
        return NextResponse.json({ success: false, error: `×¤×•×¨××˜ ×§×•×“ ×œ× ×ª×§×™×Ÿ. ×”×§×•×“ ×¦×¨×™×š ×œ×”×›×™×œ ${OTP_LENGTH_FROM_SERVICE} ×¡×¤×¨×•×ª.` }, { status: 400 });
    }

    logger.info('Attempting to verify email code', { email, codeLength: code.length });

    const verificationResult = await VerificationService.verifyCode(code, VerificationType.EMAIL, email.toLowerCase());
    
    // --- ×”×ª×™×§×•×Ÿ ××ª×—×™×œ ×›××Ÿ ---
    // ×•×•×“× ×©-userId ×§×™×™× ×•×”×•× ××—×¨×•×–×ª ×œ×¤× ×™ ×©× ××©×™×š
    // ×¡×‘×™×¨ ×œ×”× ×™×— ×©-verificationResult.userId ×™×›×•×œ ×œ×”×™×•×ª string | null
    // ×¢×œ ×¤×™ ×”×”×’×“×¨×” ×©×œ VerificationService.verifyCode
    if (!verificationResult.userId) {
      logger.error(
        'User ID is missing from verification result after successful code verification.', 
        { 
          email, 
          verificationId: verificationResult.id 
        }
      );
      // ×–×¨×•×§ ×©×’×™××” ×©×ª×˜×•×¤×œ ×‘×œ×•×§ ×”-catch ×”×›×œ×œ×™, ××• ×˜×¤×œ ×‘×” ×‘××•×¤×Ÿ ×¡×¤×¦×™×¤×™ ×™×•×ª×¨
      // ×©×’×™××” ×–×• ××¦×‘×™×¢×” ×¢×œ ×‘×¢×™×” ×œ×•×’×™×ª ×¤× ×™××™×ª ×× ×”×§×•×“ ××•××ª ××š ××™×Ÿ ××©×ª××© ××©×•×™×š
      throw new Error('×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª ×œ××—×¨ ××™××•×ª ×§×•×“ ××•×¦×œ×—.');
    }
    
    // ×›×¢×ª, ×œ××—×¨ ×”×‘×“×™×§×”, TypeScript ×™×›×•×œ ×œ×”×¡×™×§ (××• ×©× ×•×›×œ ×œ×”×¦×”×™×¨ ×‘××¤×•×¨×©)
    // ×©-userId ×”×•× string.
    const userId: string = verificationResult.userId; 
    // --- ×¡×•×£ ×”×ª×™×§×•×Ÿ ---

    logger.info('Email code verified successfully, user isVerified updated.', { email, verificationId: verificationResult.id, userId });

    const oneTimeTokenValue = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await prisma.oneTimeAuthToken.create({
      data: {
        token: oneTimeTokenValue,
        userId: userId, // ×›××Ÿ userId ××•×‘×˜×— ×œ×”×™×•×ª string
        expiresAt: expiresAt,
      }
    });
    logger.info('OneTimeAuthToken created successfully for auto-login', { userId, authTokenGenerated: true });

    return NextResponse.json({
      success: true,
      message: '×›×ª×•×‘×ª ×”××™××™×™×œ ××•××ª×” ×‘×”×¦×œ×—×”! ××ª×‘×¦×¢×ª ×”×ª×—×‘×¨×•×ª ××•×˜×•××˜×™×ª...',
      authToken: oneTimeTokenValue
    }, { status: 200 });

  } catch (error: unknown) {
    const emailForLog = requestBody?.email;
    const errorDetails = error instanceof Error ? { name: error.name, message: error.message } : { message: String(error) };
    logger.error('Email code verification or token generation failed', { email: emailForLog, error: errorDetails, timestamp: new Date().toISOString() });

    let errorMessage = '××™×¨×¢×” ×©×’×™××” ×‘××™××•×ª ×”×§×•×“.';
    let errorStatus = 500;

    if (error instanceof Error) {
      const knownClientErrors = [
        '×”×§×•×“ ×›×‘×¨ × ×•×¦×œ.', 
        '×ª×•×§×£ ×”×§×•×“ ×¤×’. ×× × ×‘×§×© ×§×•×“ ×—×“×©.', 
        '×§×•×“ ××™××•×ª ×œ× ×ª×§×™×Ÿ ××• ×©×œ× ×§×™×™××ª ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×”.', 
        '×§×•×“ ××™××•×ª ×©×’×•×™.'
      ];
      if (knownClientErrors.includes(error.message)) {
        errorMessage = error.message;
        errorStatus = 400; 
      } else if (error.message === '×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª.' || 
                 error.message === '×©×’×™××” ×¤× ×™××™×ª: ×œ× × ××¦× ××©×ª××© ××©×•×™×š ×œ××™××•×ª ×œ××—×¨ ××™××•×ª ×§×•×“ ××•×¦×œ×—.') { // ×”×•×¡×¤×ª ×”×©×’×™××” ×”×—×“×©×” ×× ×¨×•×¦×™× ×˜×™×¤×•×œ ××™×•×—×“
        errorMessage = '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.';
        // errorStatus × ×©××¨ 500 ×›×‘×¨×™×¨×ª ××—×“×œ ×œ×©×’×™××•×ª ×¤× ×™××™×•×ª, ××• ×©×ª×©× ×” ×œ×¤×™ ×”×¦×•×¨×š
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: errorStatus }
    );
  } finally {
    await prisma.$disconnect().catch(e => console.error("Failed to disconnect Prisma in verify-email-code API", e));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\auth\verify-phone-code\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/auth/verify-phone-code/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { z } from 'zod';
import { Prisma, VerificationType, UserStatus } from '@prisma/client';

import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { emailService } from '@/lib/email/emailService';
// ========== ğŸ”´ ×”×•×¡×¤×” ×—×“×©×”: ×™×™×‘×•× ×¤×•× ×§×¦×™×™×ª ×¢×“×›×•×Ÿ ×¨×¤×¨×œ ==========
import { updateReferralStatus } from '@/lib/services/referralService';
// ==============================================================

const MAX_VERIFICATION_ATTEMPTS = 5;

const verifyCodeSchema = z.object({
  code: z.string()
    .length(6, { message: "×§×•×“ ×”××™××•×ª ×—×™×™×‘ ×œ×”×›×™×œ 6 ×¡×¤×¨×•×ª" })
    .regex(/^\d+$/, { message: "×¤×•×¨××˜ ×§×•×“ ×œ× ×ª×§×™×Ÿ, ×¡×¤×¨×•×ª ×‘×œ×‘×“" }),
});

const logger = {
    info: (message: string, meta?: Record<string, unknown>) => console.log(JSON.stringify({ timestamp: new Date().toISOString(), level: 'info', message, ...meta })),
    warn: (message: string, meta?: Record<string, unknown>) => console.warn(JSON.stringify({ timestamp: new Date().toISOString(), level: 'warn', message, ...meta })),
    error: (message: string, meta?: Record<string, unknown>) => console.error(JSON.stringify({ timestamp: new Date().toISOString(), level: 'error', message, ...meta })),
};

export async function POST(req: NextRequest) {
  const action = "verify-phone-code";

  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      logger.warn("× ×™×¡×™×•×Ÿ ×œ××™××•×ª ×˜×œ×¤×•×Ÿ ×œ×œ× ×¡×©×Ÿ ×¤×¢×™×œ", { action });
      return NextResponse.json({ error: 'Unauthorized - × ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª' }, { status: 401 });
    }
    const userId = session.user.id;
    logger.info("×ª×”×œ×™×š ××™××•×ª ×˜×œ×¤×•×Ÿ ×”×—×œ ×¢×‘×•×¨ ××©×ª××©", { action, userId });

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';
    logger.info("×©×¤×ª ×”×××©×§ ×–×•×”×ª×”", { action, userId, locale });

    const body = await req.json();
    const validation = verifyCodeSchema.safeParse(body);

    if (!validation.success) {
      logger.warn("× ×ª×•× ×™× ×œ× ×ª×§×™× ×™× ×‘×‘×§×©×”", { action, userId, errors: validation.error.flatten() });
      return NextResponse.json({ error: '× ×ª×•× ×™× ×œ× ×ª×§×™× ×™×', details: validation.error.flatten() }, { status: 400 });
    }
    const { code } = validation.data;

    const verification = await prisma.verification.findFirst({
        where: {
            userId: userId,
            type: VerificationType.PHONE_WHATSAPP,
            status: 'PENDING',
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    if (!verification) {
      logger.warn("×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×˜×œ×¤×•×Ÿ ×¤×¢×™×œ×”", { action, userId });
      return NextResponse.json({ error: '×œ× × ××¦××” ×‘×§×©×ª ××™××•×ª ×¤×¢×™×œ×” ××• ×©×”×—×©×‘×•×Ÿ ×›×‘×¨ ××•××ª.' }, { status: 404 });
    }

    if (new Date() > verification.expiresAt) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'EXPIRED' }
        });
        logger.warn("× ×™×¡×™×•×Ÿ ×œ×”×©×ª××© ×‘×§×•×“ ×©×¤×’ ×ª×•×§×¤×•", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '×§×•×“ ×”××™××•×ª ×¤×’ ×ª×•×§×£. ×× × ×‘×§×© ×§×•×“ ×—×“×©.' }, { status: 410 });
    }

    if (verification.attempts >= MAX_VERIFICATION_ATTEMPTS) {
        await prisma.verification.update({
            where: { id: verification.id },
            data: { status: 'FAILED' }
        });
        logger.warn("×—×¨×’×” ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª", { action, userId, verificationId: verification.id });
        return NextResponse.json({ error: '×—×¨×’×ª ×××¡×¤×¨ × ×™×¡×™×•× ×•×ª ×”××™××•×ª ×”××•×ª×¨. ×× × ×‘×§×© ×§×•×“ ×—×“×©.' }, { status: 429 });
    }

    if (verification.token !== code) {
        const updatedVerification = await prisma.verification.update({
            where: { id: verification.id },
            data: { attempts: { increment: 1 } }
        });
        const attemptsLeft = MAX_VERIFICATION_ATTEMPTS - updatedVerification.attempts;
        logger.warn("×”×•×–×Ÿ ×§×•×“ ××™××•×ª ×©×’×•×™", { action, userId, attemptsLeft });
        return NextResponse.json({ error: `×§×•×“ ××™××•×ª ×©×’×•×™. × ×•×ª×¨×• ×œ×š ${attemptsLeft} × ×™×¡×™×•× ×•×ª.` }, { status: 400 });
    }

    const [, updatedUser] = await prisma.$transaction([
        prisma.verification.update({
            where: { id: verification.id },
            data: {
                status: 'COMPLETED',
                completedAt: new Date(),
                attempts: verification.attempts + 1
             }
        }),
        prisma.user.update({
            where: { id: userId },
            data: {
                isPhoneVerified: true,
                isProfileComplete: true,
                status: UserStatus.ACTIVE,
                updatedAt: new Date(),
            },
            select: {
                id: true,
                email: true,
                firstName: true,
                language: true, 
                isPhoneVerified: true,
                isProfileComplete: true,
                status: true,
             }
        })
    ]);
    
    logger.info("××™××•×ª ×˜×œ×¤×•×Ÿ ×”×•×©×œ× ×‘×”×¦×œ×—×”, ××©×ª××© ×”×•×’×“×¨ ×›×¤×¢×™×œ", { action, userId });

    // ========== ğŸ”´ ×”×•×¡×¤×” ×—×“×©×”: ×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×œ-VERIFIED ==========
    try {
      logger.info("×× ×¡×” ×œ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×œ-VERIFIED", { action, userId });
      
      const referralUpdateResult = await updateReferralStatus({
        userId: userId,
        newStatus: 'VERIFIED',
      });
      
      if (referralUpdateResult.success) {
        logger.info("×¡×˜×˜×•×¡ ×¨×¤×¨×œ ×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×” ×œ-VERIFIED", { 
          action, 
          userId,
          referralId: referralUpdateResult.referralId,
          referrerId: referralUpdateResult.referrerId,
          newVerifiedCount: referralUpdateResult.newVerifiedCount
        });
      } else if (referralUpdateResult.error === 'NO_REFERRAL') {
        // ×”××©×ª××© ×œ× ×”×’×™×¢ ××¨×¤×¨×œ - ×–×” ×ª×§×™×Ÿ
        logger.info("×œ××©×ª××© ××™×Ÿ ×¨×¤×¨×œ ××§×•×©×¨, ×××©×™×›×™× ×¨×’×™×œ", { action, userId });
      } else {
        logger.warn("×œ× ×”×¦×œ×—× ×• ×œ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ", { 
          action, 
          userId,
          error: referralUpdateResult.error 
        });
      }
    } catch (referralError) {
      // ×œ× ×¢×•×¦×¨×™× ××ª ×”×ª×”×œ×™×š ×‘×’×œ×œ ×©×’×™××ª ×¨×¤×¨×œ
      logger.error("×©×’×™××” ×‘×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡ ×¨×¤×¨×œ", { 
        action, 
        userId, 
        error: referralError instanceof Error ? referralError.message : String(referralError)
      });
    }
    // =================================================================

    try {
        await emailService.sendWelcomeEmail({
            locale: updatedUser.language || locale,
            email: updatedUser.email,
            firstName: updatedUser.firstName || '×—×‘×¨',
            dashboardUrl: '/profile'
        });
        logger.info("××™×™×œ ×‘×¨×•×›×™× ×”×‘××™× × ×©×œ×— ×‘×”×¦×œ×—×”", { action, userId, email: updatedUser.email, locale: updatedUser.language || locale });
    } catch (emailError) {
        logger.error("×›×©×œ ×‘×©×œ×™×—×ª ××™×™×œ ×‘×¨×•×›×™× ×”×‘××™× ×œ××—×¨ ××™××•×ª ×˜×œ×¤×•×Ÿ", { action, userId, error: emailError });
    }

    return NextResponse.json({
         success: true,
         message: '××™××•×ª ×”×˜×œ×¤×•×Ÿ ×”×•×©×œ× ×‘×”×¦×œ×—×”!',
         user: updatedUser
    }, { status: 200 });

  } catch (error) {
    const userId = (await getServerSession(authOptions))?.user?.id || 'unknown';
    logger.error("×©×’×™××” ×§×¨×™×˜×™×ª ×‘×ª×”×œ×™×š ××™××•×ª ×”×˜×œ×¤×•×Ÿ", { action, userId, error });

    if (error instanceof z.ZodError) {
        return NextResponse.json({ error: '× ×ª×•× ×™× ×œ× ×ª×§×™× ×™× ×‘×‘×§×©×”', details: error.flatten() }, { status: 400 });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        return NextResponse.json({ error: '×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘×ª×”×œ×™×š ×”××™××•×ª' }, { status: 500 });
    }
    
    return NextResponse.json({ error: '××™×¨×¢×” ×©×’×™××” ×¤× ×™××™×ª ×‘×©×¨×ª. ×× × × ×¡×” ×©× ×™×ª ×××•×—×¨ ×™×•×ª×¨.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability\check
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\availability\check\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/availability/check/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
export async function POST(req: NextRequest) {
  try {
    // 1. Aplicar un lÃ­mite de peticiones para prevenir el abuso.
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });    if (rateLimitResponse) {
      return rateLimitResponse;
    }
    
    // 2. Autenticar la sesiÃ³n del usuario (matchmaker).
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    // 3. Extraer el 'locale' de los parÃ¡metros de la URL.
    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he'; // Por defecto, se establece en hebreo.

    // 4. Extraer el 'clientId' del cuerpo de la solicitud.
    const body = await req.json();
    const { clientId } = body;

    if (!clientId) {
      return NextResponse.json({ success: false, error: "Bad Request: clientId is required." }, { status: 400 });
    }

    // 5. Llamar al servicio de disponibilidad, AHORA con el parÃ¡metro 'locale'.
    const result = await AvailabilityService.sendAvailabilityInquiry({
      matchmakerId: session.user.id,
      firstPartyId: clientId,
      locale: locale, // Se ha aÃ±adido el parÃ¡metro 'locale' que faltaba.
    });

    // 6. Devolver el resultado exitoso.
    return NextResponse.json({ success: true, inquiry: result });

  } catch (error) {
    // 7. Manejar cualquier error que ocurra durante el proceso.
    console.error("Error checking availability:", error);
    
    // Devolver un mensaje de error mÃ¡s especÃ­fico si es posible.
    const errorMessage = error instanceof Error ? error.message : "Failed to check availability";
    
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\chat
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\chat\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/chat/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';
import nodemailer from 'nodemailer';

// --- ×”×ª×•×¡×¤×•×ª ×”×—×“×©×•×ª ×œ××‘×˜×—×” ---
import { getToken } from 'next-auth/jwt';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// --- ×”×’×“×¨×ª Rate Limiter (×–×”×” ×œ×¤×™×¦'×¨ ×”××©×•×‘) ---
// ×•×“× ×©××©×ª× ×™ ×”×¡×‘×™×‘×” ××•×’×“×¨×™×
if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
  // ×‘×¡×‘×™×‘×ª ×¤×™×ª×•×—, ×–×• ×¨×§ ××–×”×¨×”. ×‘×¤×¨×•×“×§×©×Ÿ, ×–×• ×™×›×•×œ×” ×œ×”×™×•×ª ×©×’×™××” ×§×¨×™×˜×™×ª.
  console.warn('Upstash Redis credentials are not configured. Rate limiting for CHAT API will not be active.');
}
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL || '',
  token: process.env.UPSTASH_REDIS_REST_TOKEN || '',
});

// × ××¤×©×¨ 15 ×‘×§×©×•×ª ×‘×©×¢×”. ×–×” ×××¤×©×¨ ×©×™×—×” ×§×¦×¨×” ×•××•× ×¢ ×”×¦×¤×”.
const ratelimit = new Ratelimit({
  redis: redis,
  limiter: Ratelimit.slidingWindow(15, '1 h'),
});
// --- ×¡×•×£ ×”×ª×•×¡×¤×•×ª ×œ××‘×˜×—×” ---


// --- START: Internationalized Knowledge Base ---
const KNOWLEDGE_BASES = {
  he: [
      {
        question: "××” ×–×” NeshamaTech? ××” ××ª× ×¢×•×©×™×?",
        answer:
          "NeshamaTech ×”×™× ×¤×œ×˜×¤×•×¨××ª ×©×™×“×•×›×™× ×©× ×•×¡×“×” ××ª×•×š ×”×‘× ×” ×¢××•×§×” ×©×œ ×”××ª×’×¨×™× ×‘×¢×•×œ× ×”×“×™×™×˜×™× ×”××•×“×¨× ×™. ×× ×—× ×• ××©×œ×‘×™× ×˜×›× ×•×œ×•×’×™×” ×—×›××” ×¢× ×œ×™×•×•×™ ×× ×•×©×™ ×•×—× ×©×œ ×¦×•×•×ª ×©×“×›× ×™×, ×›×“×™ ×œ×™×¦×•×¨ ×—×™×‘×•×¨×™× ×¨×¦×™× ×™×™× ×•××©××¢×•×ª×™×™×.\n\n×”××˜×¨×” ×©×œ× ×• ×”×™× ×œ×”×—×–×™×¨ ××ª ×”×¢×•××§ ×•×”×›×‘×•×“ ×œ×ª×”×œ×™×š ×”×”×™×›×¨×•×ª, ×•×œ××¤×©×¨ ×œ×›× ×œ×¤×’×•×© ×× ×©×™× ×¢×œ ×‘×¡×™×¡ ×”×ª×××” ×××™×ª×™×ª ×©×œ ××™×©×™×•×ª ×•×¢×¨×›×™×, ×•×œ× ×¨×§ ×¢×œ ×¡××š ×ª××•× ×”."
      },
      {
        question: "××” ×”×©×™×˜×” ×©×œ×›×? ××™×š ×”×ª×”×œ×™×š ×¢×•×‘×“?",
        answer:
          "×”×©×™×˜×” ×©×œ× ×• ×‘× ×•×™×” ×¢×œ ×©×œ×•×©×” ×™×¡×•×“×•×ª: ×¢×•××§, ×˜×›× ×•×œ×•×’×™×” ×•×œ×™×•×•×™ ××™×©×™.\n\n1.  **×”×™×›×¨×•×ª ××¢××™×§×”:** ×”×ª×”×œ×™×š ××ª×—×™×œ ×¢× ×©××œ×•×Ÿ '×—××©×ª ×”×¢×•×œ××•×ª' ×”×™×™×—×•×“×™ ×©×œ× ×•. ×–×” ×œ× ××‘×—×Ÿ, ××œ× ××¡×¢ ×”×™×›×¨×•×ª ××™×©×™ ×©×‘×• ××ª× ××©×ª×¤×™× ××•×ª× ×• ×‘×ª×¤×™×¡×•×ª ×¢×•×œ××›× ×•×‘××” ×©×—×©×•×‘ ×œ×›×.\n\n2.  **×˜×›× ×•×œ×•×’×™×” ×‘×©×™×¨×•×ª ×”×œ×‘:** ×”××¢×¨×›×ª ×”×—×›××” ×©×œ× ×• ×× ×ª×—×ª ××ª ×”××™×“×¢ ×•×××ª×¨×ª ××ª×•×š ×××’×¨ ×¨×—×‘ ××ª ×”×× ×©×™× ×‘×¢×œ×™ ×¤×•×˜× ×¦×™××œ ×”×”×ª×××” ×”×’×‘×•×” ×‘×™×•×ª×¨ ×¢×‘×•×¨×›×.\n\n3.  **×œ×™×•×•×™ ×•×©×™×§×•×œ ×“×¢×ª ×× ×•×©×™:** ×›×œ ×”×¦×¢×” ×¤×•×˜× ×¦×™××œ×™×ª ×¢×•×‘×¨×ª ×‘×“×™×§×” ×•××™×©×•×¨ ×©×œ ×©×“×›×Ÿ ××™×©×™. ×ª×§×‘×œ×• ×¨×§ ×”×¦×¢×•×ª ×× ×•××§×•×ª, ×›××œ×• ×©×× ×—× ×• ××××™× ×™× ×‘×”×Ÿ. ×”×©×“×›×Ÿ ×’× ××œ×•×•×” ××ª×›× ×œ××•×¨×š ×›×œ ×”×“×¨×š, ×•×”×›×œ ×‘×“×™×¡×§×¨×˜×™×•×ª ××•×—×œ×˜×ª."
      },
      {
          question: '×‘××” ××ª× ×©×•× ×™× ×××¤×œ×™×§×¦×™×•×ª ×”×™×›×¨×•×™×•×ª ××• ××©×“×›× ×™× ×¨×’×™×œ×™×?',
          answer:
          "×–×• ×©××œ×” ××¦×•×™× ×ª. ×× ×—× ×• ××©×œ×‘×™× ××ª ×”×˜×•×‘ ××©× ×™ ×”×¢×•×œ××•×ª:\n\n*   **××•×œ ××¤×œ×™×§×¦×™×•×ª:** ×× ×—× ×• ××¦×™×¢×™× ×“×™×¡×§×¨×˜×™×•×ª ××œ××” (×”×¤×¨×•×¤×™×œ ×©×œ×›× ×œ× ×—×©×•×£ ×œ×›×œ), ×—×•×¡×›×™× ×œ×›× ××ª ×–××Ÿ ×”×—×™×¤×•×© (×× ×—× ×• ×¢×•×‘×“×™× ×‘×©×‘×™×œ×›×), ×•×”××˜×¨×” ×©×œ× ×• ×”×™× ×©×ª××¦××• ×–×•×’×™×•×ª ×•×ª×¢×–×‘×• ××•×ª× ×•.\n\n*   **××•×œ ×©×“×›× ×•×ª ××¡×•×¨×ª×™×ª:** ×× ×—× ×• ××©×ª××©×™× ×‘×˜×›× ×•×œ×•×’×™×” ×›×“×™ ×œ×’×©×ª ×œ×××’×¨ ×’×“×•×œ ×•×¨×—×‘ ×”×¨×‘×” ×™×•×ª×¨, ××” ×©××’×“×™×œ ××ª ×¡×™×›×•×™×™ ×”×”×¦×œ×—×”, ×ª×•×š ×©××™×¨×” ×¢×œ ×”×œ×™×•×•×™ ×”××™×©×™ ×•×”×™×›×•×œ×ª ×œ×¨××•×ª ××ª ××” ×©××¢×‘×¨ ×œ× ×ª×•× ×™× ×”×™×‘×©×™×.\n\n×‘××™×œ×™× ×¤×©×•×˜×•×ª, ×× ×—× ×• ×©×“×›× ×•×ª ××™×©×™×ª ×‘×¢×™×“×Ÿ ×”×“×™×’×™×˜×œ×™."
      },
      {
          question: '××™×š ×”×¤×¨×˜×™×•×ª ×©×œ×™ × ×©××¨×ª? ××™ ×¨×•××” ××ª ×”××™×“×¢ ×©×œ×™?',
          answer: "×”×¤×¨×˜×™×•×ª ×•×”×“×™×¡×§×¨×˜×™×•×ª ×©×œ×›× ×”×Ÿ ×¢×¨×š ×¢×œ×™×•×Ÿ ×¢×‘×•×¨× ×•. ×–×• ×”×‘×˜×—×”. ×”×¤×¨×•×¤×™×œ ×©×œ×›× ×—×©×•×£ ××š ×•×¨×§ ×œ×¦×•×•×ª ×”×©×“×›× ×™× ×”××¦×•××¦× ×©××˜×¤×œ ×‘×›×. ×”×•× ××™× ×• ×—×©×•×£ ×œ××©×ª××©×™× ××—×¨×™×. ×›××©×¨ ×× ×—× ×• ××–×”×™× ×”×ª×××”, ×× ×• ××¦×™×’×™× ×œ×›×œ ×¦×“ ×¤×¨×•×¤×™×œ ××¤×•×¨×˜ ×•××›×‘×“ ×©×œ ×”×¦×“ ×”×©× ×™, ×•×–××ª ×¨×§ ×œ××—×¨ ×©×§×™×‘×œ× ×• ××ª ××™×©×•×¨×›× ×”××¤×•×¨×©. ××ª× ×ª××™×“ ×‘×©×œ×™×˜×” ××œ××” ×¢×œ ×”××™×“×¢ ×©×œ×›×."
      },
      {
        question: '××” ×”×¢×œ×•×ª ×©×œ ×”×©×™×¨×•×ª? ×›××” ×–×” ×¢×•×œ×”?',
        answer:
          '×›×—×œ×§ ××ª×§×•×¤×ª ×”×”×©×§×” ×•×”×¨×¦×•×Ÿ ×©×œ× ×• ×œ×‘× ×•×ª ×§×”×™×œ×” ××™×›×•×ª×™×ª, ×”×©×™×¨×•×ª ×›×¨×’×¢ ××•×¦×¢ ×‘××•×“×œ ×¡××œ×™ ×©×œ 10 ×©"×— ×œ×—×•×“×© (××• ×œ×œ× ×¢×œ×•×ª, ×‘×”×ª×× ×œ×ª×§×•×¤×”). ×—×©×•×‘ ×œ×”×“×’×™×©: ×‘×©×œ×‘ ×–×”, ××™×Ÿ ××¦×œ× ×• "×“××™ ×”×¦×œ×—×”" ×›×œ×œ, ×’× ×× ×ª×ª××¨×¡×• ×“×¨×›× ×•. ×”××˜×¨×” ×©×œ× ×• ×”×™× ×œ××¤×©×¨ ×œ×›× ×œ×”×›×™×¨ ××ª ×”×’×™×©×” ×”×™×™×—×•×“×™×ª ×©×œ× ×• ×œ×œ× ××—×¡×•××™×. ×‘×¢×ª×™×“, ×™×™×ª×›×Ÿ ×•× ×¢×‘×•×¨ ×œ××•×“×œ ×©×™×›×œ×•×œ ×“××™ ×”×¦×œ×—×”, ××š ×›×œ ×©×™× ×•×™ ×›×–×” ×™×”×™×” ×›×¤×•×£ ×œ×¢×“×›×•×Ÿ ×ª× ××™ ×”×©×™××•×© ×•×œ×§×‘×œ×ª ×”×¡×›××ª×›× ×”××—×•×“×©×ª.'
      },
      {
        question: '××” ×”×¡×™×›×•×™ ×©×œ×™ ×œ××¦×•× ×”×ª×××” ×•×›××” ×–××Ÿ ×–×” ×œ×•×§×—?',
        answer:
          "×–×• ×©××œ×” ×—×©×•×‘×”. ××™×Ÿ ×œ×•×— ×–×× ×™× ××“×•×™×§ ×œ××”×‘×”, ××š ×”×’×™×©×” ×”×××•×§×“×ª ×©×œ× ×• ×—×•×¡×›×ª ×–××Ÿ ×™×§×¨ ×•×× ×¨×’×™×” ×¨×’×©×™×ª. ×‘××§×•× ×××•×ª ×©×™×—×•×ª ×©×˜×—×™×•×ª, ×ª×§×‘×œ×• ××¡×¤×¨ ××¦×•××¦× ×©×œ ×”×¦×¢×•×ª ××™×›×•×ª×™×•×ª ×•×× ×•××§×•×ª. ×”××˜×¨×” ×”×™× ××™×›×•×ª ×¢×œ ×¤× ×™ ×›××•×ª, ×›×“×™ ×©×›×œ ×”×¦×¢×” ×ª×”×™×” ××©××¢×•×ª×™×ª."
      },
      {
        question: '××™×š ×”×‘×™× ×” ×”××œ××›×•×ª×™×ª (AI) ×¢×•×–×¨×ª ×œ×™?',
        answer:
          "×”-AI ×”×•× ×›×œ×™ ×¢×–×¨ ×—×›× ×’× ×¢×‘×•×¨×›× ×•×’× ×¢×‘×•×¨ ×”×©×“×›× ×™× ×©×œ× ×•. ×œ×©×“×›× ×™×, ×”×•× ××¡×™×™×¢ ×‘× ×™×ª×•×— ××¢××™×§ ×©×œ ×¤×¨×•×¤×™×œ×™× ×›×“×™ ×œ×–×”×•×ª ×“×¤×•×¡×™ ×”×ª×××” × ×¡×ª×¨×™×. ×¢×‘×•×¨×›×, ×”××¢×¨×›×ª ×™×›×•×œ×” ×œ×”×¦×™×¢ ×ª×•×‘× ×•×ª ×œ×©×™×¤×•×¨ ×”×¤×¨×•×¤×™×œ, ×•×œ×¡×™×™×¢ ×œ×›× ×œ×”×ª×™×™×¢×¥ ×œ×’×‘×™ ×”×¦×¢×•×ª ×©×ª×§×‘×œ×• ×›×“×™ ×œ×”×‘×™×Ÿ ×˜×•×‘ ×™×•×ª×¨ ××ª × ×§×•×“×•×ª ×”×—×•×–×§ ×‘×”×ª×××”."
      },
      {
        question: '×œ××™ ×”×©×™×¨×•×ª ××™×•×¢×“?',
        answer:
          '×”×©×™×¨×•×ª ×©×œ× ×• ××™×•×¢×“ ×œ×¨×•×•×§×™× ×•×¨×•×•×§×•×ª ××”×§×”×™×œ×” ×”×™×”×•×“×™×ª ×”××—×¤×©×™× ×§×©×¨ ×¨×¦×™× ×™ ×”××•×‘×™×œ ×œ×—×ª×•× ×”. ×‘×©×œ×‘ ×–×”, ×× ×• ××ª××§×“×™× ×‘×¢×™×§×¨ ×‘×§×”×œ ×”×“×ª×™-×œ××•××™ ×•×”××§×“××™ ×‘×™×©×¨××œ, ××š ×¤×ª×•×—×™× ×œ×›×œ ××™ ×©××ª×—×‘×¨ ×œ×’×™×©×” ×”××¢××™×§×” ×•×”××›×‘×“×ª ×©×œ× ×•. ×”××¢×¨×›×ª ××™×•×¢×“×ª ×›×¨×’×¢ ×œ×©×™×“×•×›×™× ×‘×™×Ÿ ×’×‘×¨×™× ×œ× ×©×™× (×¡×˜×¨×™×™×˜×™×) ×‘×œ×‘×“.'
      }
  ],
  en: [
    {
        question: "What is NeshamaTech? What do you do?",
        answer: "NeshamaTech is a matchmaking platform founded on a deep understanding of the challenges in the modern dating world. We combine smart technology with the warm, personal guidance of a team of matchmakers to create serious and meaningful connections.\n\nOur goal is to bring depth and respect back to the process of getting to know someone, allowing you to meet people based on a true compatibility of personality and values, not just a picture."
    },
    {
        question: "What is your method? How does the process work?",
        answer: "Our method is built on three pillars: depth, technology, and personal guidance.\n\n1.  **In-depth acquaintance:** The process begins with our unique 'Five Worlds' questionnaire. It's not a test, but a personal discovery journey where you share your worldviews and what's important to you.\n\n2.  **Technology at the service of the heart:** Our smart system analyzes the information and identifies individuals with the highest potential for compatibility from a wide database.\n\n3.  **Human guidance and judgment:** Every potential suggestion is reviewed and approved by a personal matchmaker. You will only receive well-reasoned suggestions that we believe in. The matchmaker also accompanies you throughout the process, all with complete discretion."
    },
    {
        question: "How are you different from dating apps or regular matchmakers?",
        answer: "That's an excellent question. We combine the best of both worlds:\n\n*   **Compared to apps:** We offer complete discretion (your profile is not public), we save you search time (we do the work for you), and our goal is for you to find a relationship and leave us.\n\n*   **Compared to traditional matchmaking:** We use technology to access a much larger and broader database, which increases the chances of success, while maintaining personal guidance and the ability to see beyond dry data.\n\nSimply put, we are personal matchmaking for the digital age."
    },
    {
        question: "How is my privacy protected? Who sees my information?",
        answer: "Your privacy and discretion are our top priority. This is a promise. Your profile is only visible to the small matchmaking team handling your case. It is not exposed to other users. When we identify a match, we present each side with a detailed and respectful profile of the other, but only after receiving your explicit approval. You are always in full control of your information."
    },
    {
        question: "What is the cost of the service? How much does it cost?",
        answer: "As part of our launch period and our desire to build a quality community, the service is currently offered at a symbolic model of $3/month (or for free, depending on the period). It's important to note: at this stage, we have **no 'success fees' at all**, even if you get engaged through us. Our goal is to let you experience our unique approach without barriers. In the future, we might add premium tracks or another model, but any such change will be subject to updating the terms of use and receiving your renewed consent."
    },
    {
        question: "What are my chances of finding a match and how long does it take?",
        answer: "That's an important question. There's no exact timeline for love, but our focused approach saves significant time and emotional energy. Instead of hundreds of superficial conversations, you'll receive a small number of high-quality, reasoned suggestions. The goal is quality over quantity, so that every suggestion is meaningful."
    },
    {
        question: "How does Artificial Intelligence (AI) help me?",
        answer: "The AI is a smart tool for both you and our matchmakers. For matchmakers, it assists in in-depth profile analysis to identify hidden compatibility patterns. For you, the system can offer insights to improve your profile and help you consult on suggestions you receive to better understand the strengths of a match."
    },
    {
        question: "Who is the service for?",
        answer: "Our service is designed for single men and women from the Jewish community who are looking for a serious relationship leading to marriage. At this stage, we primarily focus on the Religious-Zionist and academic community in Israel, but we are open to anyone who connects with our in-depth and respectful approach. The system is currently intended for heterosexual matchmaking only."
    }
  ]
};
// --- END: Internationalized Knowledge Base ---

const getPrompt = (lang: 'he' | 'en', knowledgeContext: string, message: string) => {
    if (lang === 'en') {
        return `
          **Your Persona:**
          You are the "Personal Assistant" for NeshamaTech. You are the first point of contact for potential users looking for a serious relationship. Your tone is that of a seasoned, warm, and trustworthy professional.
          - **Professional and Reassuring:** Use clear, respectful, and confident language.
          - **Empathetic and Understanding:** Acknowledge the challenges of the dating world but offer hope and a path forward.
          - **Trustworthy and Discreet:** Always emphasize the importance of privacy and trust.
          - **Value-Focused:** Explain not just *what* we do, but *why* it is beneficial for the user.
          - **Fluent and natural English speaker only.**

          **Your Mandatory Rules:**
          1.  **Rely solely on the knowledge base:** Do not invent information. Every answer must come directly from the text provided to you.
          2.  **Do not make promises:** Avoid promises like "you will find love." Instead, talk about "increasing the chances," "an efficient process," and "meaningful connections."
          3.  **Identify out-of-scope questions:** If the question is not covered in the knowledge base, you must respond with empathy and service-orientation. Reply: "That's an important question that deserves a personal answer from our team. I don't have specific information on that in the system, but I can forward your inquiry directly to one of the matchmakers. Would you like to send them a message by email?".
          4.  **Interpret questions:** Understand user intent. "How much" -> address cost. "How it works" -> address the method. "Is it safe?" -> address privacy.
          5.  **Avoid superlatives:** Don't say "we are the best." Instead, explain *why* our approach is unique and beneficial.

          --- Full Knowledge Base (Your absolute truth) ---
          ${knowledgeContext}
          --- End of Knowledge Base ---

          **Request:**
          Answer the following user's question, based on the persona and strict rules defined for you.

          User's question: "${message}"

          Answer in English:
        `;
    }

    // Default to Hebrew
    return `
      **×”×¤×¨×¡×•× ×” ×©×œ×š:**
      ××ª×” "×”×¢×•×–×¨ ×”××™×©×™" ×©×œ NeshamaTech. ××ª×” ×”× ×§×•×“×” ×”×¨××©×•× ×” ×‘××’×¢ ×¢× ××©×ª××©×™× ×¤×•×˜× ×¦×™××œ×™×™× ×©××—×¤×©×™× ×§×©×¨ ×¨×¦×™× ×™. ×”×˜×•×Ÿ ×©×œ×š ×”×•× ×›××• ×©×œ ××™×© ××§×¦×•×¢ ×•×ª×™×§, ×—× ×•××”×™××Ÿ.
      - **××§×¦×•×¢×™ ×•××¨×’×™×¢:** ×”×©×ª××© ×‘×©×¤×” ×‘×¨×•×¨×”, ××›×‘×“×ª ×•×‘×•×˜×—×ª. ×“×‘×¨ ×‘×’×•×‘×” ×”×¢×™× ×™×™×.
      - **×××¤×ª×™ ×•××‘×™×Ÿ:** ×”×›×¨ ×‘××ª×’×¨×™× ×©×œ ×¢×•×œ× ×”×“×™×™×˜×™×, ××š ×”×¦×¢ ×ª×§×•×•×” ×•×“×¨×š ×¤×¢×•×œ×”.
      - **×××™×Ÿ ×•×“×™×¡×§×¨×˜×™:** ×”×“×’×© ×ª××™×“ ××ª ×—×©×™×‘×•×ª ×”×¤×¨×˜×™×•×ª ×•×”×××•×Ÿ.
      - **×××•×§×“-×¢×¨×š:** ×”×¡×‘×¨ ×œ× ×¨×§ *××”* ×× ×—× ×• ×¢×•×©×™×, ××œ× *×œ××”* ×–×” ×˜×•×‘ ×•××•×¢×™×œ ×œ××©×ª××©.
      - **×“×•×‘×¨ ×¢×‘×¨×™×ª ×¨×”×•×˜×” ×•×˜×‘×¢×™×ª ×‘×œ×‘×“.**

      **×”×›×œ×œ×™× ×”××—×™×™×‘×™× ×©×œ×š:**
      1.  **×”×ª×‘×¡×¡ ××š ×•×¨×§ ×¢×œ ×××’×¨ ×”×™×“×¢:** ××œ ×ª××¦×™× ××™×“×¢ ×‘×©×•× ××•×¤×Ÿ. ×›×œ ×ª×©×•×‘×” ×—×™×™×‘×ª ×œ× ×‘×•×¢ ×™×©×™×¨×•×ª ××”×˜×§×¡×˜ ×©×¡×•×¤×§ ×œ×š.
      2.  **××œ ×ª×‘×˜×™×— ×”×‘×˜×—×•×ª:** ×”×™×× ×¢ ××”×‘×˜×—×•×ª ×›××• "×ª××¦× ××”×‘×”". ×‘××§×•× ×–××ª, ×“×‘×¨ ×¢×œ "×”×’×“×œ×ª ×”×¡×™×›×•×™×™×", "×ª×”×œ×™×š ×™×¢×™×œ", ×•"×—×™×‘×•×¨×™× ××©××¢×•×ª×™×™×".
      3.  **×–×™×”×•×™ ×©××œ×” ××—×•×¥ ×œ×××’×¨:** ×× ×”×©××œ×” ××™× ×” ××›×•×¡×” ×‘×××’×¨ ×”×™×“×¢, ×¢×œ×™×š ×œ×”×©×™×‘ ×‘×××¤×ª×™×” ×•×‘×¦×•×¨×” ×©×™×¨×•×ª×™×ª. ×¢× ×”: "×–×• ×©××œ×” ×—×©×•×‘×” ×©×¨××•×™×” ×œ×ª×©×•×‘×” ××™×©×™×ª ××”×¦×•×•×ª ×©×œ× ×•. ××™×Ÿ ×œ×™ ××™×“×¢ ××“×•×™×§ ×¢×œ ×›×š ×‘××¢×¨×›×ª, ××š ×× ×™ ×™×›×•×œ ×œ×”×¢×‘×™×¨ ××ª ×¤× ×™×™×ª×š ×™×©×™×¨×•×ª ×œ××—×“ ×”×©×“×›× ×™×. ×”×× ×ª×¨×¦×”/×™ ×œ×©×œ×•×— ×œ×”× ×¤× ×™×™×” ×‘××™×™×œ?".
      4.  **×¤×¨×©× ×•×ª ×©××œ×•×ª:** ×”×‘×Ÿ ××ª ×›×•×•× ×ª ×”××©×ª××©. "×›××” ×¢×•×œ×”" -> ×”×ª×™×™×—×¡ ×œ×¢×œ×•×ª. "××™×š ×–×” ×¢×•×‘×“" -> ×”×ª×™×™×—×¡ ×œ×©×™×˜×”. "×”×× ×–×” ×‘×˜×•×—?" -> ×”×ª×™×™×—×¡ ×œ×¤×¨×˜×™×•×ª.
      5.  **×”×™×× ×¢ ××¡×•×¤×¨×œ×˜×™×‘×™×:** ××œ ×ª×’×™×“ "×× ×—× ×• ×”×›×™ ×˜×•×‘×™×". ×‘××§×•×, ×”×¡×‘×¨ *××“×•×¢* ×”×’×™×©×” ×©×œ× ×• ×™×™×—×•×“×™×ª ×•××•×¢×™×œ×”.

      --- ×××’×¨ ×”×™×“×¢ ×”××œ× (×”×××ª ×”××•×—×œ×˜×ª ×©×œ×š) ---
      ${knowledgeContext}
      --- ×¡×•×£ ×××’×¨ ×”×™×“×¢ ---

      **×”×‘×§×©×”:**
      ×¢× ×” ×¢×œ ×©××œ×ª ×”××©×ª××© ×”×‘××”, ×‘×”×ª×‘×¡×¡ ×¢×œ ×”×¤×¨×¡×•× ×” ×•×”×›×œ×œ×™× ×”××—××™×¨×™× ×©×”×•×’×“×¨×• ×œ×š.

      ×©××œ×ª ×”××©×ª××©: "${message}"

      ×ª×©×•×‘×” ×‘×¢×‘×¨×™×ª:
    `;
};

const EMAIL_SUCCESS_MESSAGES = {
    he: '×ª×•×“×” ×¨×‘×”! ×¤× ×™×™×ª×š × ×©×œ×—×” ×‘×”×¦×œ×—×”. ××—×“ ××× ×©×™ ×”×¦×•×•×ª ×©×œ× ×• ×™×—×–×•×¨ ××œ×™×š ×‘××•×¤×Ÿ ××™×©×™ ×‘×”×§×“× ×”××¤×©×¨×™.',
    en: 'Thank you! Your message has been sent successfully. One of our team members will get back to you personally as soon as possible.'
};

const FALLBACK_PHRASES = {
    he: '×œ×©×œ×•×— ×œ×”× ×¤× ×™×™×” ×‘××™×™×œ',
    en: 'send them a message by email'
};

const FALLBACK_ACTION_LABELS = {
    he: '×›×Ÿ, ××©××— ×œ×©×œ×•×— ×¤× ×™×™×” ×œ×¦×•×•×ª',
    en: 'Yes, I\'d like to send an email to the team'
};

if (!process.env.GOOGLE_API_KEY) {
  console.error('[CHAT API ERROR] GOOGLE_API_KEY is not defined!');
}

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);

const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
];

export async function POST(req: NextRequest) {
  try {
    // --- ×”×•×¡×¤×ª ×œ×•×’×™×§×ª Rate Limiting ---
    if (process.env.NODE_ENV === 'production' && process.env.UPSTASH_REDIS_REST_URL) {
      const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
const ip = req.headers.get('x-forwarded-for') ?? '127.0.0.1';
      const identifier = token?.sub ?? ip;
      const { success } = await ratelimit.limit(identifier);

      if (!success) {
        return new NextResponse('Too many requests. Please try again later.', { status: 429 });
      }
    }
    // --- ×¡×•×£ ×œ×•×’×™×§×ª Rate Limiting ---

    const { message, type, userEmail, locale } = await req.json();
    const lang: 'he' | 'en' = locale === 'en' ? 'en' : 'he';

    if (!message || typeof message !== 'string') {
      return NextResponse.json({ error: 'Message is required' }, { status: 400 });
    }

    if (type === 'email') {
      if (!userEmail || typeof userEmail !== 'string') {
        return NextResponse.json({ error: 'User email is required' }, { status: 400 });
      }

      const transporter = nodemailer.createTransport({
        service: process.env.EMAIL_SERVICE || 'gmail',
        auth: {
          user: process.env.GMAIL_USER || process.env.EMAIL_USER,
          pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
        },
        tls: { rejectUnauthorized: process.env.NODE_ENV === 'production' },
      });

      const mailOptions = {
        from: `"${process.env.EMAIL_FROM_NAME || 'NeshamaTech Chatbot'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
        to: 'neshamatech.jsmatch@gmail.com',
        subject: `New Chat Inquiry: ${userEmail}`,
        replyTo: userEmail,
        html: `
          <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6; color: #333;">
            <h2 style="color: #0891b2;">×¤× ×™×™×” ×—×“×©×” ××”×¦'××˜-×‘×•×˜ ×‘××ª×¨ NeshamaTech:</h2>
            <p><strong>×××ª:</strong> <a href="mailto:${userEmail}">${userEmail}</a></p>
            <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
              <p style="margin: 0; white-space: pre-wrap;">${message.replace(/\n/g, '<br>')}</p>
            </div>
            <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
              ×–×•×”×™ ×”×•×“×¢×” ××•×˜×•××˜×™×ª. × ×™×ª×Ÿ ×œ×”×©×™×‘ ×œ××™×™×œ ×–×” ×™×©×™×¨×•×ª ×›×“×™ ×œ×¢× ×•×ª ×œ×¤×•× ×”.
            </p>
          </div>
        `,
      };

      await transporter.sendMail(mailOptions);
      return NextResponse.json({
        reply: EMAIL_SUCCESS_MESSAGES[lang],
      });
    }

    const selectedKnowledgeBase = KNOWLEDGE_BASES[lang];
    const knowledgeContext = selectedKnowledgeBase
        .map((item) => `×©××œ×”: ${item.question}\n×ª×©×•×‘×”: ${item.answer}`)
        .join('\n\n');

    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash', safetySettings });
    
    const prompt = getPrompt(lang, knowledgeContext, message);

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    const isFallback = text.includes(FALLBACK_PHRASES[lang]);

    if (isFallback) {
      return NextResponse.json({
        reply: text,
        isFallback: true,
        actions: [{ type: 'email', label: FALLBACK_ACTION_LABELS[lang] }],
      });
    }

    return NextResponse.json({ reply: text, isFallback: false });
  } catch (error) {
    console.error('Error in /api/chat route:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { error: 'Internal Server Error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/contact/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import nodemailer from 'nodemailer';
import { z } from 'zod';

// Zod schema for validating the contact form data
const contactSchema = z.object({
  name: z.string().min(2, { message: "Name must be at least 2 characters long" }),
  email: z.string().email({ message: "Invalid email address" }),
  message: z.string().min(10, { message: "Message must be at least 10 characters long" }),
});

export async function POST(req: NextRequest) {
  // Apply rate limiting: 5 contact form submissions per IP per hour (prevents spam)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const body = await req.json();

    // Validate the request body
    const validationResult = contactSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: "Invalid input", details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { name, email, message } = validationResult.data;

    // Configure the email transporter using environment variables
    const transporter = nodemailer.createTransport({
      service: process.env.EMAIL_SERVICE || 'gmail',
      auth: {
        user: process.env.GMAIL_USER || process.env.EMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD || process.env.EMAIL_PASS,
      },
      tls: {
        rejectUnauthorized: process.env.NODE_ENV === 'production',
      }
    });

    // Define the email options
    const mailOptions = {
      from: `"${process.env.EMAIL_FROM_NAME || 'Match Point Contact Form'}" <${process.env.GMAIL_USER || process.env.EMAIL_USER}>`,
      to: "neshamatech.jsmatch@gmail.com", // Your support/admin email address
      subject: `×¤× ×™×™×” ×—×“×©×” ×××ª×¨ Match Point - ${name}`,
      replyTo: email, // This allows you to reply directly to the user
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; text-align: right; line-height: 1.6;">
          <h2 style="color: #0891b2;">×”×ª×§×‘×œ×” ×”×•×“×¢×” ×—×“×©×” ××˜×•×¤×¡ ×™×¦×™×¨×ª ×”×§×©×¨ ×‘××ª×¨:</h2>
          <p><strong>×××ª:</strong> ${name} (<a href="mailto:${email}">${email}</a>)</p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;" />
          <h3 style="color: #333;">×ª×•×›×Ÿ ×”×”×•×“×¢×”:</h3>
          <div style="background-color: #f8f9fa; border-right: 4px solid #06b6d4; padding: 15px; border-radius: 5px; margin-top: 10px;">
            <p style="margin: 0; white-space: pre-wrap;">${message.replace(/\n/g, '<br>')}</p>
          </div>
          <p style="font-size: 12px; color: #6c757d; margin-top: 20px;">
            ×–×•×”×™ ×”×•×“×¢×” ××•×˜×•××˜×™×ª. × ×™×ª×Ÿ ×œ×”×©×™×‘ ×œ××™×™×œ ×–×” ×™×©×™×¨×•×ª ×›×“×™ ×œ×¢× ×•×ª ×œ×¤×•× ×”.
          </p>
        </div>
      `,
    };

    // Send the email
    await transporter.sendMail(mailOptions);

    // Return a success response
    return NextResponse.json({ success: true, message: "×”×”×•×“×¢×” × ×©×œ×—×” ×‘×”×¦×œ×—×”." });

  } catch (error) {
    console.error("Error in /api/contact route:", error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "Internal Server Error", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\feedback
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\feedback\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/feedback/route.ts

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getToken } from 'next-auth/jwt';
import { v2 as cloudinary } from 'cloudinary';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';
import prisma from '@/lib/prisma';
import { FeedbackType } from '@prisma/client';
import { emailService } from '@/lib/email/emailService';

// The Redis and Rate Limiter configurations remain at the global level. This is correct.
if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
  console.warn('Upstash Redis credentials are not configured. Rate limiting will not be active.');
}

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL || '',
  token: process.env.UPSTASH_REDIS_REST_TOKEN || '',
});

const ratelimit = new Ratelimit({
  redis: redis,
  limiter: Ratelimit.slidingWindow(5, '1 h'),
});

export async function POST(req: NextRequest) {
  // --- Start of the critical fix ---
  // The Cloudinary configuration is set within the POST function.
  // This ensures that every time the API is called (in a Serverless environment),
  // the environment variables will be loaded and available to the code before they are used.
  cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET,
  });
  // --- End of the critical fix ---

  // Rate Limiting Logic
  if (process.env.NODE_ENV === 'production' && process.env.UPSTASH_REDIS_REST_URL) {
    try {
      const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
      // --- FIX: Accessing the 'x-forwarded-for' header to get the IP address ---
      const ip = (req.headers.get('x-forwarded-for') ?? '127.0.0.1').split(',')[0];
      const identifier = token?.sub ?? ip;
      const { success } = await ratelimit.limit(identifier);

      if (!success) {
        return new NextResponse('Too many requests. Please try again later.', { status: 429 });
      }
    } catch (e) {
        console.error("Error with rate limiter:", e);
    }
  }

  try {
    const formData = await req.formData();
    const content = formData.get('content') as string;
    const feedbackType = formData.get('feedbackType') as FeedbackType;
    const pageUrl = formData.get('pageUrl') as string;
    const userAgent = req.headers.get('user-agent') || 'Unknown';
    const screenshot = formData.get('screenshot') as File | null;
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });

    if (!content || !feedbackType || !pageUrl) {
      return NextResponse.json({ success: false, error: 'Missing required fields' }, { status: 400 });
    }

    let screenshotUrl: string | undefined = undefined;

    if (screenshot) {
      // Explicit check of environment variables before attempting upload
      if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
          const errorMsg = "Server configuration error: Cloudinary environment variables are missing at the time of upload.";
          console.error(`CRITICAL: ${errorMsg}`);
          return NextResponse.json({ success: false, error: "Server configuration error preventing image upload." }, { status: 500 });
      }
        
      const bytes = await screenshot.arrayBuffer();
      const buffer = Buffer.from(bytes);

      const uploadResult = await new Promise<{ secure_url?: string; error?: any }>((resolve) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          { folder: 'feedback_screenshots', resource_type: 'image' },
          (error, result) => {
            if (error) resolve({ error });
            else if (result) resolve({ secure_url: result.secure_url });
            else resolve({ error: new Error('Cloudinary returned no result or error.') });
          }
        );
        uploadStream.end(buffer);
      });

      if (uploadResult.error) {
        console.error('Failed to upload screenshot to Cloudinary:', uploadResult.error);
      } else if (uploadResult.secure_url) {
        screenshotUrl = uploadResult.secure_url;
      }
    }

    const newFeedback = await prisma.feedback.create({
      data: {
        userId: token?.sub,
        content,
        feedbackType,
        pageUrl,
        userAgent,
        screenshotUrl,
      },
      include: { user: { select: { firstName: true, lastName: true, email: true } } }
    });

    try {
      const adminEmail = "neshamatech.jsmatch@gmail.com";
      const userIp = (req.headers.get('x-forwarded-for') ?? 'N/A').split(',')[0];
      const userIdentifier = newFeedback.user 
        ? `${newFeedback.user.firstName} ${newFeedback.user.lastName} (${newFeedback.user.email})`
        : `Anonymous User (IP: ${userIp})`;

      await emailService.sendEmail({
        to: adminEmail,
        subject: `New Feedback Received (${feedbackType}): ${userIdentifier}`,
        templateName: 'internal-feedback-notification',
        context: {
          feedbackType: feedbackType,
          userIdentifier: userIdentifier,
          content: content,
          pageUrl: pageUrl,
          screenshotUrl: screenshotUrl,
          feedbackId: newFeedback.id,
        }
      });
      console.log(`Feedback notification sent successfully to ${adminEmail}`);
    } catch (emailError) {
      console.error("Failed to send feedback notification email, but feedback was saved to DB. Error:", emailError);
    }

    return NextResponse.json({ success: true, message: 'Feedback submitted successfully' });

  } catch (error) {
    console.error('Fatal error in feedback submission process:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred";
    return NextResponse.json({ success: false, error: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
# Generated on: 2025-12-21 02:16:34
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\candidates_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';
export const dynamic = 'force-dynamic';
const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { Locale } from "../../../../../../i18n-config";
import { emailService } from "@/lib/email/emailService";

export const dynamic = 'force-dynamic';

/**
 * GET: ××—×–×•×¨ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“ ×¡×¤×¦×™×¤×™.
 * × ×’×™×© ×œ×©×“×›× ×™× ×•×× ×”×œ×™×.
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params;
    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

/**
 * PATCH: ×¢×“×›×•×Ÿ ×¤×¨×˜×™ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“.
 * × ×’×™×© ×œ×©×“×›× ×™× ×•×× ×”×œ×™×. ××¢×‘×“ ×¨×§ ××ª ×”×©×“×•×ª ×©× ×©×œ×—×• ×‘×‘×§×©×”.
 */
export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const url = new URL(req.url);
    const locale = (url.searchParams.get('locale') as Locale) || 'he';

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true, firstName: true, lastName: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const params = await props.params;
    const { id: candidateIdToUpdate } = params;

    const candidateToUpdate = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true, email: true, firstName: true }
    });

    if (!candidateToUpdate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateToUpdate.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const incomingData = await req.json();

    const originalProfile = await prisma.profile.findUnique({
        where: { userId: candidateIdToUpdate },
        select: { manualEntryText: true }
    });
    
    const dataForUpdate: Prisma.ProfileUpdateInput = {};

    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation', 'manualEntryText', 'about', 'profileHeadline'];
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious',  'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible', 'birthDateIsApproximate'];
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    const dateFields = ['birthDate'];

    for (const key in incomingData) {
      if (Object.prototype.hasOwnProperty.call(incomingData, key)) {
        const value = incomingData[key];

        if (numericFields.includes(key)) {
            if (value === "" || value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else {
                const parsed = parseInt(String(value), 10);
                dataForUpdate[key] = isNaN(parsed) ? null : parsed;
            }
        } else if (stringAndEnumFields.includes(key)) {
            dataForUpdate[key] = (value === "" || value === undefined) ? null : value;
        } else if (booleanFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else if (typeof value === 'boolean') {
                dataForUpdate[key] = value;
            } else {
                dataForUpdate[key] = value === 'true';
            }
        } else if (arrayFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = [];
            } else if (Array.isArray(value)) {
                dataForUpdate[key] = value;
            }
        } else if (dateFields.includes(key)) {
            if (value) {
                const date = new Date(value);
                if (!isNaN(date.getTime())) {
                    dataForUpdate[key] = date;
                }
            } else {
                dataForUpdate[key] = null;
            }
        }
      }
    }
    
    if (Object.keys(dataForUpdate).length > 0) {
        const updatedProfile = await prisma.profile.update({
          where: { userId: candidateIdToUpdate },
          data: {
            ...dataForUpdate,
            updatedAt: new Date(),
            lastActive: new Date(),
            needsAiProfileUpdate: true,
          }
        });

        const newSummaryText = incomingData.manualEntryText;
        const oldSummaryText = originalProfile?.manualEntryText;

        if (newSummaryText !== undefined && newSummaryText.trim() !== '' && newSummaryText !== oldSummaryText) {
            try {
                await emailService.sendProfileSummaryUpdateEmail({
                    locale,
                    email: candidateToUpdate.email,
                    firstName: candidateToUpdate.firstName,
                    matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š"
                });
                console.log(`[Email Notification] Profile summary update email sent successfully to ${candidateToUpdate.email}.`);
            } catch (emailError) {
                console.error(`[Email Notification] Failed to send profile summary update email to ${candidateToUpdate.email}:`, emailError);
            }
        }

        updateUserAiProfile(candidateIdToUpdate).catch(err => {
            console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
        });

        return NextResponse.json({
          success: true,
          profile: updatedProfile
        });
    }

    const currentProfile = await prisma.profile.findUnique({ where: { userId: candidateIdToUpdate } });
    return NextResponse.json({ success: true, profile: currentProfile, message: "No data provided for update." });

  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `×©×’×™××”: × ×¨××” ×©××—×“ ×”×©×“×•×ª ×©×”×–× ×ª (×›××• ××™×™×œ ××• ×˜×œ×¤×•×Ÿ ×× ×¨×œ×•×•× ×˜×™ ×œ×¤×¨×•×¤×™×œ) ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª ×¢×‘×•×¨ ××©×ª××© ××—×¨. (${error.meta?.target})`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "×”×¤×¨×•×¤×™×œ ××• ×”××•×¢××“ ×”××‘×•×§×© ×œ×¢×“×›×•×Ÿ ×œ× × ××¦×.";
            statusCode = 404;
        } else {
            errorMessage = `×©×’×™××ª ××¡×“ × ×ª×•× ×™× (×§×•×“ ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        const relevantError = error.message.split('\n').pop() || error.message;
        errorMessage = `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘×¢×“×›×•×Ÿ ×”×¤×¨×•×¤×™×œ: ${relevantError}`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

/**
 * DELETE: ××—×™×§×ª ××•×¢××“.
 * × ×’×™×© ×œ×× ×”×œ×™× ×‘×œ×‘×“.
 */
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const timestamp = new Date().toISOString();
  
  const params = await props.params;
  const candidateIdToDelete = params.id;
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. ×œ× ×–×•×”×ª×” ×¡×©×Ÿ ×¤×¢×™×œ ××• ×”×¨×©××”.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. × ×“×¨×©×ª ×”×¨×©××ª ××“××™×Ÿ.' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: '××–×”×” ××•×¢××“ (candidateId) ×—×¡×¨.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: '×× ×”×œ ××™× ×• ×™×›×•×œ ×œ××—×•×§ ××ª ×—×©×‘×•× ×• ×”××™×©×™ ×“×¨×š ×××©×§ ×–×”. ×”×©×ª××© ×‘×”×’×“×¨×•×ª ×—×©×‘×•×Ÿ ××™×©×™×•×ª.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.' },
        { status: 404 }
      );
    }

    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '×”××•×¢××“ × ××—×§ ×‘×”×¦×œ×—×”.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦× (×©×’×™××ª Prisma).'},
                { status: 404 }
            );
        }
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘××—×™×§×ª ×”××•×¢××“ (×§×•×“: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘××—×™×§×ª ×”××•×¢××“: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '×©×’×™××” ×œ× ×™×“×•×¢×” ×‘×¢×ª ××—×™×§×ª ×”××•×¢××“.';
    return NextResponse.json(
      {
        success: false,
        error: '××™×¨×¢×” ×©×’×™××” ×‘××—×™×§×ª ×”××•×¢××“. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    // Await params before destructuring
    const params = await props.params;
    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/main/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const imageToSetMain = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    await prisma.$transaction([
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId }
        },
        data: { isMain: false }
      }),
      
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';

export async function POST(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    const params = await props.params;
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×ª×§×™× ×” ×”×™× ×©×“×” ×—×•×‘×”." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    const expiresInHours = 72;
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    await prisma.$transaction(async (tx) => {
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id },
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    const expiresInText = locale === 'he' ? '3 ×™××™×' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale,
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    return NextResponse.json({ success: true, message: "×”×–×× ×” ×œ×”×’×“×¨×ª ×—×©×‘×•×Ÿ × ×©×œ×—×” ×‘×”×¦×œ×—×”." });

  } catch (error) {
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ××©×•×™×›×ª ×œ×—×©×‘×•×Ÿ ××—×¨." },
          { status: 409 }
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×ª ×”×”×–×× ×”.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
    };

    // --- START: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for candidates_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/route.ts
import { updateUserAiProfile } from '@/lib/services/profileAiService';

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole, MatchSuggestionStatus } from '@prisma/client';

export const dynamic = 'force-dynamic';

const BLOCKING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'FIRST_PARTY_APPROVED',
  'SECOND_PARTY_APPROVED',
  'AWAITING_MATCHMAKER_APPROVAL',
  'CONTACT_DETAILS_SHARED',
  'AWAITING_FIRST_DATE_FEEDBACK',
  'THINKING_AFTER_DATE',
  'PROCEEDING_TO_SECOND_DATE',
  'MEETING_PENDING',
  'MEETING_SCHEDULED',
  'MATCH_APPROVED',
  'DATING',
];

const PENDING_SUGGESTION_STATUSES: MatchSuggestionStatus[] = [
  'PENDING_FIRST_PARTY',
  'PENDING_SECOND_PARTY',
  'DRAFT',
];

type SuggestionStatusInfo = {
  status: 'BLOCKED' | 'PENDING';
  suggestionId: string;
  withCandidateName: string;
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized - Not logged in' }),
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
      return new NextResponse(
        JSON.stringify({
          error: 'Unauthorized - Matchmaker or Admin access required',
        }),
        { status: 403 }
      );
    }

    // Step 1: Fetch all candidates
    const users = await prisma.user.findMany({
      where: {
        status: { notIn: ['BLOCKED', 'INACTIVE'] },
        role: 'CANDIDATE',
        profile: { isNot: null },
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        status: true,
        source: true,
        createdAt: true,
        isVerified: true,
        isProfileComplete: true,
        images: {
          select: { id: true, url: true, isMain: true },
          orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
        },
        profile: true,
      },
    });

    // ================== ğŸš¨ START SERVER DEBUG: LINOY ğŸš¨ ==================
    const targetEmail = 'linoyreznik032@gmail.com';
    const foundUser = users.find(u => u.email === targetEmail);

    console.log('\n-----------------------------------------------------');
    console.log(`ğŸ” [API DEBUG] Checking for user: ${targetEmail}`);
    
    if (foundUser) {
        console.log('âœ… SUCCESS: User exists in the API response list.');
        console.log('   User Data:', JSON.stringify({
            id: foundUser.id,
            status: foundUser.status,
            role: 'CANDIDATE (verified by query)',
            hasProfile: !!foundUser.profile,
            gender: foundUser.profile?.gender,
            birthDate: foundUser.profile?.birthDate
        }, null, 2));
    } else {
        console.log('âŒ FAILURE: User is MISSING from the main list.');
        console.log('   Running direct DB check to investigate why...');

        // ×‘×“×™×§×” ×™×©×™×¨×” ××•×œ ×”×“××˜×” ×‘×™×™×¡ ×œ×œ× ×¤×™×œ×˜×¨×™×
        const directCheck = await prisma.user.findUnique({
            where: { email: targetEmail },
            include: { profile: true }
        });

        if (!directCheck) {
            console.log('   ğŸ’€ FATAL: User does not exist in the Database at all.');
        } else {
            console.log('   ğŸ§ DIAGNOSIS - Why was she filtered out?');
            console.log(`   1. Email: ${directCheck.email}`);
            
            // ×‘×“×™×§×ª ×¡×˜×˜×•×¡
            const statusOk = !['BLOCKED', 'INACTIVE'].includes(directCheck.status);
            console.log(`   2. Status: ${directCheck.status} [${statusOk ? 'OK' : 'FAIL - Blocked or Inactive'}]`);
            
            // ×‘×“×™×§×ª ×ª×¤×§×™×“
            const roleOk = directCheck.role === 'CANDIDATE';
            console.log(`   3. Role: ${directCheck.role} [${roleOk ? 'OK' : 'FAIL - Must be CANDIDATE'}]`);
            
            // ×‘×“×™×§×ª ×¤×¨×•×¤×™×œ
            const profileExists = !!directCheck.profile;
            console.log(`   4. Profile Exists: ${profileExists} [${profileExists ? 'OK' : 'FAIL - Profile is null'}]`);

            if (profileExists) {
                console.log('      Profile Details:', JSON.stringify(directCheck.profile, null, 2));
            }
        }
    }
    console.log('-----------------------------------------------------\n');
    // ================== ğŸš¨ END SERVER DEBUG ğŸš¨ ==================


    if (users.length === 0) {
      return new NextResponse(
        JSON.stringify({ success: true, clients: [], count: 0 }),
        { status: 200 }
      );
    }

    // Step 2: Collect all user IDs
    const userIds = users.map((user) => user.id);

    // Step 3: Fetch all relevant suggestions in a single query
    const allSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: { in: userIds } },
          { secondPartyId: { in: userIds } },
        ],
        status: {
          in: [...BLOCKING_SUGGESTION_STATUSES, ...PENDING_SUGGESTION_STATUSES],
        },
      },
      include: {
        firstParty: { select: { id: true, firstName: true, lastName: true } },
        secondParty: { select: { id: true, firstName: true, lastName: true } },
      },
    });

    // Step 4: Process suggestions into an efficient lookup map
    const suggestionStatusMap = new Map<string, SuggestionStatusInfo>();

    for (const suggestion of allSuggestions) {
      const isBlocking = BLOCKING_SUGGESTION_STATUSES.includes(
        suggestion.status
      );
      const statusType = isBlocking ? 'BLOCKED' : 'PENDING';

      // Attach info to first party
      if (
        !suggestionStatusMap.has(suggestion.firstPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.firstPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.firstPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName}`,
        });
      }

      // Attach info to second party
      if (
        !suggestionStatusMap.has(suggestion.secondPartyId) ||
        (isBlocking &&
          suggestionStatusMap.get(suggestion.secondPartyId)?.status !==
            'BLOCKED')
      ) {
        suggestionStatusMap.set(suggestion.secondPartyId, {
          status: statusType,
          suggestionId: suggestion.id,
          withCandidateName: `${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName}`,
        });
      }
    }

    // Step 5: Map suggestion info back to users in memory (no more DB queries)
    const usersWithSuggestionInfo = users.map((user) => {
      const suggestionInfo = suggestionStatusMap.get(user.id) || null;
      const profile = user.profile;

      return {
        ...user,
        suggestionStatus: suggestionInfo,
        profile: profile
          ? {
              ...profile,
              birthDate: profile.birthDate.toISOString(),
              availabilityUpdatedAt:
                profile.availabilityUpdatedAt?.toISOString() || null,
              createdAt: profile.createdAt.toISOString(),
              updatedAt: profile.updatedAt.toISOString(),
              lastActive: profile.lastActive?.toISOString() || null,
            }
          : null,
      };
    });
  const profilesNeedingUpdate = usersWithSuggestionInfo.filter(
      (user) => user.profile?.needsAiProfileUpdate
    );

    if (profilesNeedingUpdate.length > 0) {
      const profileIdsToUpdate = profilesNeedingUpdate.map(u => u.profile!.id);
      // console.log(`[Proactive AI Update] Found ${profileIdsToUpdate.length} profiles needing AI update. Triggering in background.`);

      // First, immediately reset the flags in the DB to prevent duplicate jobs
      prisma.profile.updateMany({
        where: { id: { in: profileIdsToUpdate } },
        data: { needsAiProfileUpdate: false }
      }).then(() => {
        // console.log(`[Proactive AI Update] Flags for ${profileIdsToUpdate.length} profiles reset.`);
        // Then, run the actual AI updates without awaiting them
        profilesNeedingUpdate.forEach(user => {
          updateUserAiProfile(user.id).catch(err => {
            console.error(`[Proactive AI Update - BG] Failed for user ${user.id}:`, err);
            // Optional: Re-flag the profile on failure
            // prisma.profile.update({ where: { id: user.profile!.id }, data: { needsAiProfileUpdate: true } });
          });
        });
      }).catch(err => {
        console.error("[Proactive AI Update] Failed to reset flags:", err);
      });
    }
    return new NextResponse(
      JSON.stringify({
        success: true,
        clients: usersWithSuggestionInfo,
        count: usersWithSuggestionInfo.length,
      }),
      { status: 200 }
    );
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    console.error('Candidate list fetch error:', errorMessage, error);

    return new NextResponse(
      JSON.stringify({
        success: false,
        error: 'An error occurred while fetching candidates.',
        details: errorMessage,
      }),
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Prisma, UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { Locale } from "../../../../../../i18n-config";
import { emailService } from "@/lib/email/emailService";

export const dynamic = 'force-dynamic';

/**
 * GET: ××—×–×•×¨ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“ ×¡×¤×¦×™×¤×™.
 * × ×’×™×© ×œ×©×“×›× ×™× ×•×× ×”×œ×™×.
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params;
    const { id } = params;

    const candidateData = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        isVerified: true,
        role: true,
        profile: true,
        images: {
          orderBy: [{ isMain: 'desc' }, { createdAt: 'desc' }]
        }
      }
    });

    if (!candidateData) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      profile: candidateData.profile,
      user: {
        id: candidateData.id,
        firstName: candidateData.firstName,
        lastName: candidateData.lastName,
        email: candidateData.email,
        phone: candidateData.phone,
        isVerified: candidateData.isVerified,
        role: candidateData.role,
      },
      images: candidateData.images
    });
  } catch (error) {
    console.error("Error fetching candidate profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch candidate profile" },
      { status: 500 }
    );
  }
}

/**
 * PATCH: ×¢×“×›×•×Ÿ ×¤×¨×˜×™ ×¤×¨×•×¤×™×œ ×©×œ ××•×¢××“.
 * × ×’×™×© ×œ×©×“×›× ×™× ×•×× ×”×œ×™×. ××¢×‘×“ ×¨×§ ××ª ×”×©×“×•×ª ×©× ×©×œ×—×• ×‘×‘×§×©×”.
 */
export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    const url = new URL(req.url);
    const locale = (url.searchParams.get('locale') as Locale) || 'he';

    const performingUser = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true, firstName: true, lastName: true }
    });

    if (!performingUser || (performingUser.role !== UserRole.MATCHMAKER && performingUser.role !== UserRole.ADMIN)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }
    
    const params = await props.params;
    const { id: candidateIdToUpdate } = params;

    const candidateToUpdate = await prisma.user.findUnique({
      where: { id: candidateIdToUpdate },
      select: { id: true, role: true, email: true, firstName: true }
    });

    if (!candidateToUpdate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    if (candidateToUpdate.role === UserRole.ADMIN && performingUser.role !== UserRole.ADMIN) {
        return NextResponse.json(
            { success: false, error: "Unauthorized - Admins can only be edited by other Admins." },
            { status: 403 }
        );
    }

    const incomingData = await req.json();

    const originalProfile = await prisma.profile.findUnique({
        where: { userId: candidateIdToUpdate },
        select: { manualEntryText: true }
    });
    
    const dataForUpdate: Prisma.ProfileUpdateInput = {};

    const numericFields = ['height', 'siblings', 'position', 'preferredAgeMin', 'preferredAgeMax', 'preferredHeightMin', 'preferredHeightMax', 'aliyaYear'];
    const stringAndEnumFields = ['gender', 'preferredMatchmakerGender', 'maritalStatus', 'serviceType', 'headCovering', 'kippahType', 'contactPreference', 'preferredShomerNegiah', 'preferredPartnerHasChildren', 'preferredAliyaStatus', 'availabilityStatus' , 'religiousJourney', 'medicalInfoDetails', 'medicalInfoDisclosureTiming', 'fatherOccupation', 'motherOccupation', 'manualEntryText', 'about', 'profileHeadline'];
    const booleanFields = ['shomerNegiah', 'hasChildrenFromPrevious',  'isProfileVisible', 'hasMedicalInfo', 'isMedicalInfoVisible', 'birthDateIsApproximate'];
    const arrayFields = ['additionalLanguages', 'profileCharacterTraits', 'profileHobbies', 'preferredReligiousLevels', 'preferredLocations', 'preferredEducation', 'preferredOccupations', 'preferredMaritalStatuses', 'preferredOrigins', 'preferredServiceTypes', 'preferredHeadCoverings', 'preferredKippahTypes', 'preferredCharacterTraits', 'preferredHobbies', 'preferredReligiousJourneys'];
    const dateFields = ['birthDate'];

    for (const key in incomingData) {
      if (Object.prototype.hasOwnProperty.call(incomingData, key)) {
        const value = incomingData[key];

        if (numericFields.includes(key)) {
            if (value === "" || value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else {
                const parsed = parseInt(String(value), 10);
                dataForUpdate[key] = isNaN(parsed) ? null : parsed;
            }
        } else if (stringAndEnumFields.includes(key)) {
            dataForUpdate[key] = (value === "" || value === undefined) ? null : value;
        } else if (booleanFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = null;
            } else if (typeof value === 'boolean') {
                dataForUpdate[key] = value;
            } else {
                dataForUpdate[key] = value === 'true';
            }
        } else if (arrayFields.includes(key)) {
            if (value === undefined || value === null) {
                dataForUpdate[key] = [];
            } else if (Array.isArray(value)) {
                dataForUpdate[key] = value;
            }
        } else if (dateFields.includes(key)) {
            if (value) {
                const date = new Date(value);
                if (!isNaN(date.getTime())) {
                    dataForUpdate[key] = date;
                }
            } else {
                dataForUpdate[key] = null;
            }
        }
      }
    }
    
    if (Object.keys(dataForUpdate).length > 0) {
        const updatedProfile = await prisma.profile.update({
          where: { userId: candidateIdToUpdate },
          data: {
            ...dataForUpdate,
            updatedAt: new Date(),
            lastActive: new Date(),
            needsAiProfileUpdate: true,
          }
        });

        const newSummaryText = incomingData.manualEntryText;
        const oldSummaryText = originalProfile?.manualEntryText;

        if (newSummaryText !== undefined && newSummaryText.trim() !== '' && newSummaryText !== oldSummaryText) {
            try {
                await emailService.sendProfileSummaryUpdateEmail({
                    locale,
                    email: candidateToUpdate.email,
                    firstName: candidateToUpdate.firstName,
                    matchmakerName: session.user.name || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š"
                });
                console.log(`[Email Notification] Profile summary update email sent successfully to ${candidateToUpdate.email}.`);
            } catch (emailError) {
                console.error(`[Email Notification] Failed to send profile summary update email to ${candidateToUpdate.email}:`, emailError);
            }
        }

        updateUserAiProfile(candidateIdToUpdate).catch(err => {
            console.error(`[AI Profile Trigger - Matchmaker Update] Failed to update AI profile in the background for candidate ${candidateIdToUpdate}:`, err);
        });

        return NextResponse.json({
          success: true,
          profile: updatedProfile
        });
    }

    const currentProfile = await prisma.profile.findUnique({ where: { userId: candidateIdToUpdate } });
    return NextResponse.json({ success: true, profile: currentProfile, message: "No data provided for update." });

  } catch (error) {
    console.error("Error updating candidate profile:", error);
    let errorMessage = "Failed to update candidate profile";
    let statusCode = 500;

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
            errorMessage = `×©×’×™××”: × ×¨××” ×©××—×“ ×”×©×“×•×ª ×©×”×–× ×ª (×›××• ××™×™×œ ××• ×˜×œ×¤×•×Ÿ ×× ×¨×œ×•×•× ×˜×™ ×œ×¤×¨×•×¤×™×œ) ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª ×¢×‘×•×¨ ××©×ª××© ××—×¨. (${error.meta?.target})`;
            statusCode = 409;
        } else if (error.code === 'P2025') {
            errorMessage = "×”×¤×¨×•×¤×™×œ ××• ×”××•×¢××“ ×”××‘×•×§×© ×œ×¢×“×›×•×Ÿ ×œ× × ××¦×.";
            statusCode = 404;
        } else {
            errorMessage = `×©×’×™××ª ××¡×“ × ×ª×•× ×™× (×§×•×“ ${error.code}).`;
        }
        console.error("Prisma Known Error on PATCH:", error.code, error.message, error.meta);
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        const relevantError = error.message.split('\n').pop() || error.message;
        errorMessage = `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘×¢×“×›×•×Ÿ ×”×¤×¨×•×¤×™×œ: ${relevantError}`;
        statusCode = 400;
        console.error("Prisma Validation Error on PATCH:", error.message);
    } else if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return NextResponse.json(
      { success: false, error: errorMessage, details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined },
      { status: statusCode }
    );
  }
}

/**
 * DELETE: ××—×™×§×ª ××•×¢××“.
 * × ×’×™×© ×œ×× ×”×œ×™× ×‘×œ×‘×“.
 */
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  const timestamp = new Date().toISOString();
  
  const params = await props.params;
  const candidateIdToDelete = params.id;
  
  console.log(`[${timestamp}] DELETE request for candidate ID: ${candidateIdToDelete}`);

  const session = await getServerSession(authOptions);

  if (!session || !session.user || !session.user.id || !session.user.role) {
    console.warn(`[${timestamp}] Unauthorized DELETE attempt: No active session or role. PerformingUserID: ${session?.user?.id}`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. ×œ× ×–×•×”×ª×” ×¡×©×Ÿ ×¤×¢×™×œ ××• ×”×¨×©××”.' },
      { status: 401 }
    );
  }

  const performingUserId = session.user.id;
  const performingUserRole = session.user.role as UserRole; 

  if (performingUserRole !== UserRole.ADMIN) {
    console.warn(`[${timestamp}] Forbidden DELETE attempt: User ${performingUserId} (Role: ${performingUserRole}) is not ADMIN.`);
    return NextResponse.json(
      { success: false, error: '××™× ×š ××•×¨×©×” ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•. × ×“×¨×©×ª ×”×¨×©××ª ××“××™×Ÿ.' },
      { status: 403 }
    );
  }

  if (!candidateIdToDelete) {
    console.warn(`[${timestamp}] Bad Request DELETE: candidateId is missing. PerformingUserID: ${performingUserId}`);
    return NextResponse.json(
        { success: false, error: '××–×”×” ××•×¢××“ (candidateId) ×—×¡×¨.' },
        { status: 400 }
    );
  }

  if (candidateIdToDelete === performingUserId) {
    console.warn(`[${timestamp}] Forbidden DELETE: Admin ${performingUserId} attempting to delete their own account via candidate deletion endpoint.`);
    return NextResponse.json(
        { success: false, error: '×× ×”×œ ××™× ×• ×™×›×•×œ ×œ××—×•×§ ××ª ×—×©×‘×•× ×• ×”××™×©×™ ×“×¨×š ×××©×§ ×–×”. ×”×©×ª××© ×‘×”×’×“×¨×•×ª ×—×©×‘×•×Ÿ ××™×©×™×•×ª.' },
        { status: 403 }
    );
  }

  try {
    const candidateToDelete = await prisma.user.findUnique({
      where: { id: candidateIdToDelete },
      select: { id: true, role: true, email: true }
    });

    if (!candidateToDelete) {
      console.warn(`[${timestamp}] Candidate with ID ${candidateIdToDelete} not found for deletion. Requested by Admin: ${performingUserId}`);
      return NextResponse.json(
        { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦×.' },
        { status: 404 }
      );
    }

    await prisma.user.delete({
      where: { id: candidateIdToDelete },
    });

    console.log(`[${timestamp}] Candidate ${candidateIdToDelete} (Email: ${candidateToDelete.email}, Role: ${candidateToDelete.role}) deleted successfully by admin ${performingUserId}`);
    return NextResponse.json(
      { success: true, message: '×”××•×¢××“ × ××—×§ ×‘×”×¦×œ×—×”.' },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error(`[${timestamp}] Candidate deletion failed for ID ${candidateIdToDelete}. Requested by Admin: ${performingUserId}. Error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            console.warn(`[${timestamp}] Prisma P2025 Error on DELETE: Attempted to delete non-existent candidate ${candidateIdToDelete}. Requested by Admin: ${performingUserId}`);
            return NextResponse.json(
                { success: false, error: '×”××•×¢××“ ×”××‘×•×§×© ×œ××—×™×§×” ×œ× × ××¦× (×©×’×™××ª Prisma).'},
                { status: 404 }
            );
        }
        console.error(`[${timestamp}] Prisma Known Error during DELETE for candidate ${candidateIdToDelete}: Code ${error.code}, Meta: ${JSON.stringify(error.meta)}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ××¡×“ × ×ª×•× ×™× ×‘××—×™×§×ª ×”××•×¢××“ (×§×•×“: ${error.code}).`},
            { status: 500 }
        );
    } else if (error instanceof Prisma.PrismaClientValidationError) {
        console.error(`[${timestamp}] Prisma Validation Error during DELETE for candidate ${candidateIdToDelete}: ${error.message}. Requested by Admin: ${performingUserId}`);
        return NextResponse.json(
            { success: false, error: `×©×’×™××ª ×•×œ×™×“×¦×™×” ×‘××—×™×§×ª ×”××•×¢××“: ${error.message}`},
            { status: 400 }
        );
    }

    const errorMessage = error instanceof Error ? error.message : '×©×’×™××” ×œ× ×™×“×•×¢×” ×‘×¢×ª ××—×™×§×ª ×”××•×¢××“.';
    return NextResponse.json(
      {
        success: false,
        error: '××™×¨×¢×” ×©×’×™××” ×‘××—×™×§×ª ×”××•×¢××“. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.',
        details: process.env.NODE_ENV === 'development' ? errorMessage : undefined
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from "cloudinary";

const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    // Await params before destructuring
    const params = await props.params;
    const { id } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const image = formData.get('image') as File;

    if (!image) {
      return NextResponse.json(
        { success: false, error: "No image provided" },
        { status: 400 }
      );
    }

    if (!cloudName || !apiKey || !apiSecret) {
      return NextResponse.json(
        { success: false, error: "Server configuration error" },
        { status: 500 }
      );
    }

    const arrayBuffer = await image.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const uploadResult = await cloudinary.uploader.upload(
      `data:${image.type};base64,${buffer.toString('base64')}`,
      {
        folder: `shidduch-system/users/${id}`,
        resource_type: 'image',
        transformation: [
          { width: 1000, height: 1000, crop: 'limit' },
          { quality: 'auto:good' }
        ] as unknown as Record<string, unknown>
      }
    );

    const existingImages = await prisma.userImage.count({
      where: { userId: id }
    });

    const newImage = await prisma.userImage.create({
      data: {
        userId: id,
        url: uploadResult.secure_url,
        cloudinaryPublicId: uploadResult.public_id,
        isMain: existingImages === 0
      }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      image: newImage
    });
  } catch (error) {
    console.error("Error uploading image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to upload image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;

if (!cloudName || !apiKey || !apiSecret) {
  console.error("Missing required Cloudinary environment variables");
} else {
  cloudinary.config({
    cloud_name: cloudName,
    api_key: apiKey,
    api_secret: apiSecret,
  });
}

// DELETE request handler for deleting an image
export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    console.log(`Handling DELETE request for candidate ${id}, image ${imageId}`);

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const image = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    console.log(`Found image to delete: ${image.id}, isMain: ${image.isMain}`);

    if (image.isMain) {
      const otherImage = await prisma.userImage.findFirst({
        where: {
          userId: id,
          id: { not: imageId }
        },
        orderBy: { createdAt: 'desc' }
      });

      if (otherImage) {
        console.log(`Setting image ${otherImage.id} as new main image`);
        await prisma.userImage.update({
          where: { id: otherImage.id },
          data: { isMain: true }
        });
      }
    }

    if (image.cloudinaryPublicId) {
      try {
        console.log(`Deleting from Cloudinary: ${image.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (cloudinaryError) {
        console.error("Cloudinary deletion error:", cloudinaryError);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId }
    });

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to delete image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\images\[imageId]\main\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/images/[imageId]/main/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string; imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!user || !allowedRoles.includes(user.role)) {
      return NextResponse.json(
        { success: false, error: "Unauthorized - Matchmaker or Admin access required" },
        { status: 403 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { id, imageId } = params;

    const candidate = await prisma.user.findUnique({
      where: { id },
      select: { id: true }
    });

    if (!candidate) {
      return NextResponse.json(
        { success: false, error: "Candidate not found" },
        { status: 404 }
      );
    }

    const imageToSetMain = await prisma.userImage.findFirst({
      where: {
        id: imageId,
        userId: id
      }
    });

    if (!imageToSetMain) {
      return NextResponse.json(
        { success: false, error: "Image not found" },
        { status: 404 }
      );
    }

    await prisma.$transaction([
      prisma.userImage.updateMany({
        where: { 
            userId: id,
            id: { not: imageId }
        },
        data: { isMain: false }
      }),
      
      prisma.userImage.update({
        where: { id: imageId },
        data: { isMain: true }
      })
    ]);

    await prisma.profile.update({
      where: { userId: id },
      data: { lastActive: new Date() }
    });

    return NextResponse.json({
      success: true,
      message: "Main image updated successfully"
    });
  } catch (error) {
    console.error("Error setting main image:", error);
    return NextResponse.json(
      { success: false, error: "Failed to set main image" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\[id]\invite-setup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/[id]/invite-setup/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, VerificationType, Prisma, VerificationStatus } from "@prisma/client";
import { VerificationService } from "@/lib/services/verificationService";
import { emailService } from "@/lib/email/emailService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';

export async function POST(req: NextRequest, props: { params: Promise<{ id: string }> }) {
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    const params = await props.params;
    const candidateId = params.id;
    const body = await req.json();
    const { email } = body;

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return NextResponse.json({ success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×ª×§×™× ×” ×”×™× ×©×“×” ×—×•×‘×”." }, { status: 400 });
    }
    const normalizedEmail = email.toLowerCase();

    const candidate = await prisma.user.findUnique({
      where: { id: candidateId },
    });

    if (!candidate) {
      return NextResponse.json({ success: false, error: "Candidate not found." }, { status: 404 });
    }
    
    const expiresInHours = 72;
    const { otp: setupToken, verification } = await VerificationService.createVerification(
      candidateId,
      VerificationType.ACCOUNT_SETUP,
      normalizedEmail,
      expiresInHours
    );

    await prisma.$transaction(async (tx) => {
      if (candidate.email !== normalizedEmail) {
          await tx.user.update({
            where: { id: candidateId },
            data: { email: normalizedEmail },
          });
      }
      await tx.verification.updateMany({
        where: {
          userId: candidateId,
          type: VerificationType.ACCOUNT_SETUP,
          status: VerificationStatus.PENDING,
          id: { not: verification.id },
        },
        data: {
          status: VerificationStatus.EXPIRED,
        },
      });
    });

    const expiresInText = locale === 'he' ? '3 ×™××™×' : '3 days';
    await emailService.sendAccountSetupEmail({
      locale,
      email: normalizedEmail,
      firstName: candidate.firstName,
      matchmakerName: session.user.firstName || "×”×©×“×›×Ÿ/×™×ª ×©×œ×š",
      setupToken: setupToken,
      expiresIn: expiresInText,
    });

    return NextResponse.json({ success: true, message: "×”×–×× ×” ×œ×”×’×“×¨×ª ×—×©×‘×•×Ÿ × ×©×œ×—×” ×‘×”×¦×œ×—×”." });

  } catch (error) {
    console.error("Error sending account setup invite:", error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      const target = error.meta?.target as string[] | undefined;
      if (target?.includes('email')) {
        return NextResponse.json(
          { success: false, error: "×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ××©×•×™×›×ª ×œ×—×©×‘×•×Ÿ ××—×¨." },
          { status: 409 }
        );
      }
    }

    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json({ success: false, error: "××™×¨×¢×” ×©×’×™××” ×‘×©×œ×™×—×ª ×”×”×–×× ×”.", details: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\candidates\manual\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/candidates/manual/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Gender, UserSource, UserStatus, UserRole, Prisma } from '@prisma/client';
import { v2 as cloudinary } from "cloudinary";
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import { createId } from '@paralleldrive/cuid2';

type CloudinaryUploadResult = {
  secure_url: string;
  public_id: string;
};

if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.error("CRITICAL: Missing required Cloudinary environment variables.");
  throw new Error("Missing required Cloudinary environment variables.");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function uploadImageToCloudinary(file: File, userId: string): Promise<{ url: string; publicId: string }> {
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder: `manual-candidates/${userId}/images`, resource_type: "image" },
      (error, result) => {
        if (error) return reject(new Error("Failed to upload image to Cloudinary."));
        if (!result) return reject(new Error("Cloudinary upload failed: no result object."));
        const cloudinaryResult = result as CloudinaryUploadResult;
        resolve({ url: cloudinaryResult.secure_url, publicId: cloudinaryResult.public_id });
      }
    );
    uploadStream.end(buffer);
  });
}

export async function POST(req: NextRequest) {
  // Apply rate limiting: 15 manual creations per matchmaker per hour (resource intensive)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user || (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN)) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }
    const matchmakerId = session.user.id;

    const formData = await req.formData();
    const firstName = formData.get('firstName') as string;
    const lastName = formData.get('lastName') as string;
    const emailValue = formData.get('email') as string | null;
    const gender = formData.get('gender') as Gender;
    const birthDateStr = formData.get('birthDate') as string;
    const manualEntryText = formData.get('manualEntryText') as string;
    const images = formData.getAll('images') as File[];
    const birthDateIsApproximate = formData.get('birthDateIsApproximate') === 'true';
    
    // --- START: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---
    const fatherOccupation = formData.get('fatherOccupation') as string | null;
    const motherOccupation = formData.get('motherOccupation') as string | null;
    // --- END: ×”×•×¡×¤×ª ×©×“×•×ª ××§×¦×•×¢ ×”×•×¨×™× ---

    const hasMedicalInfo = formData.get('hasMedicalInfo');
    const medicalInfoDetails = formData.get('medicalInfoDetails') as string | null;
    const medicalInfoDisclosureTiming = formData.get('medicalInfoDisclosureTiming') as string | null;
    const isMedicalInfoVisible = formData.get('isMedicalInfoVisible');

    if (!firstName || !lastName || !gender || !birthDateStr || !manualEntryText) {
      return NextResponse.json({ success: false, error: "Missing required fields" }, { status: 400 });
    }

    const birthDate = new Date(birthDateStr);
    if (isNaN(birthDate.getTime())) {
      return NextResponse.json({ success: false, error: "Invalid birth date" }, { status: 400 });
    }

    let email: string;
    if (emailValue && emailValue.trim() !== '') {
        email = emailValue.trim().toLowerCase();
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            return NextResponse.json({ success: false, error: "××©×ª××© ×¢× ×›×ª×•×‘×ª ××™××™×™×œ ×–×• ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª." }, { status: 409 });
        }
    } else {
        email = `manual_${createId()}@shidduch.placeholder.com`;
    }

    const profileCreateData: Prisma.ProfileCreateWithoutUserInput = {
      gender,
      birthDate,
      birthDateIsApproximate,
      manualEntryText,
      availabilityStatus: 'AVAILABLE',
    };

    // --- START: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---
    if (fatherOccupation) {
        profileCreateData.fatherOccupation = fatherOccupation;
    }
    if (motherOccupation) {
        profileCreateData.motherOccupation = motherOccupation;
    }
    if (hasMedicalInfo !== null) {
      profileCreateData.hasMedicalInfo = hasMedicalInfo === 'true';
    }
    if (medicalInfoDetails) {
      profileCreateData.medicalInfoDetails = medicalInfoDetails;
    }
    if (medicalInfoDisclosureTiming) {
      profileCreateData.medicalInfoDisclosureTiming = medicalInfoDisclosureTiming;
    }
    if (isMedicalInfoVisible !== null) {
      profileCreateData.isMedicalInfoVisible = isMedicalInfoVisible === 'true';
    }
    // --- END: ×”×•×¡×¤×ª ×”×©×“×•×ª ×”×—×“×©×™× ×œ××•×‘×™×™×§×˜ ×”×™×¦×™×¨×” ---

    const newManualCandidate = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: null,
        role: UserRole.CANDIDATE,
        status: UserStatus.PENDING_EMAIL_VERIFICATION,
        isVerified: false,
        isProfileComplete: false,
        source: UserSource.MANUAL_ENTRY,
        addedByMatchmakerId: matchmakerId,
        profile: {
          create: profileCreateData,
        },
      },
      include: {
        profile: true,
      },
    });

    type UserImageCreateInput = {
      userId: string;
      url: string;
      cloudinaryPublicId: string;
      isMain: boolean;
    };

    const uploadedImageData: UserImageCreateInput[] = [];

    if (images && images.length > 0) {
      for (const file of images) {
        if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
            return NextResponse.json({ success: false, error: `Invalid file type: ${file.name}. Only JPG, PNG, WEBP allowed.` }, { status: 400 });
        }
        if (file.size > 5 * 1024 * 1024) {
            return NextResponse.json({ success: false, error: `File too large: ${file.name}. Max 5MB.` }, { status: 400 });
        }
      }
      
      for (let i = 0; i < images.length; i++) {
        try {
          const { url, publicId } = await uploadImageToCloudinary(images[i], newManualCandidate.id);
          uploadedImageData.push({
            userId: newManualCandidate.id,
            url: url,
            cloudinaryPublicId: publicId,
            isMain: i === 0,
          });
        } catch (uploadError) {
            console.error("Failed to upload an image during manual candidate creation:", uploadError);
            return NextResponse.json({
                success: false,
                error: `Failed to upload image ${images[i].name}. ${(uploadError as Error).message}`
            }, { status: 500 });
        }
      }

      if (uploadedImageData.length > 0) {
        await prisma.userImage.createMany({
          data: uploadedImageData,
        });
      }
    }
   
    updateUserAiProfile(newManualCandidate.id).catch(err => {
        console.error(`[AI Profile Trigger] Failed to create AI profile for manual candidate ${newManualCandidate.id}:`, err);
    });

    const candidateToReturn = await prisma.user.findUnique({
        where: { id: newManualCandidate.id },
        include: { profile: true, images: true }
    });

    return NextResponse.json({ success: true, candidate: candidateToReturn });

  } catch (error) {
    console.error("Error in POST /api/matchmaker/candidates/manual:", error);
    let errorMessage = "Internal server error.";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    if (error instanceof SyntaxError && error.message.includes("Unexpected token") && error.message.includes("in JSON at position")) {
        errorMessage = "Invalid request body or FormData. Ensure all fields are correctly formatted.";
    } else if (error instanceof TypeError && error.message.includes("Could not parse content as FormData")) {
        errorMessage = "Invalid request format. Expected FormData.";
    }

    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export const dynamic = 'force-dynamic';

export async function GET(
  req: Request,
  props: { params: Promise<{ id: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized - Not logged in" }, { status: 401 });
    }

    const performingUser = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
    });

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!performingUser || !allowedRoles.includes(performingUser.role)) {
        return NextResponse.json(
            { error: 'Unauthorized - Matchmaker or Admin access required to view this inquiry' },
            { status: 403 }
        );
    }
    
    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const inquiry = await AvailabilityService.getInquiryById(params.id);
    
    if (!inquiry) {
        return NextResponse.json({ error: "Inquiry not found or access denied" }, { status: 404 });
    }
    
    return NextResponse.json(inquiry);
  } catch (error) {
    console.error("Error fetching inquiry:", error);
    let message = "Failed to fetch inquiry";
    if (error instanceof Error) {
        message = error.message;
    }
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\inquiries\[id]\respond\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/inquiries/[id]/respond/route.ts

import { type NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { AvailabilityService } from "@/lib/services/availabilityService";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

type RouteSegment<T> = (
  request: NextRequest,
  props: { params: Promise<T> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) => Promise<NextResponse> | NextResponse;

const handler: RouteSegment<{ id: string }> = async (req, { params: paramsPromise }) => {
  try {
    const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    const url = new URL(req.url);
    const locale = url.searchParams.get('locale') === 'en' ? 'en' : 'he';

    const { isAvailable, note } = await req.json();

    if (typeof isAvailable !== 'boolean') {
        return NextResponse.json({ success: false, error: "Bad Request: 'isAvailable' must be a boolean." }, { status: 400 });
    }

    const params = await paramsPromise; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await

    const updatedInquiry = await AvailabilityService.updateInquiryResponse({
      inquiryId: params.id,
      userId: session.user.id,
      isAvailable,
      note,
      locale: locale,
    });

    return NextResponse.json({ success: true, inquiry: updatedInquiry });

  } catch (error) {
    console.error("Error updating inquiry response:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Failed to update response";
    
    return NextResponse.json(
      { 
        success: false,
        error: errorMessage
      },
      { status: 500 }
    );
  }
};

export const POST = handler;
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { MatchSuggestionStatus, Prisma, UserRole } from '@prisma/client';
import { suggestionService } from '@/components/matchmaker/suggestions/services/suggestions/SuggestionService';
import { updateUserAiProfile } from '@/lib/services/profileAiService';
import type { CreateSuggestionData } from '@/types/suggestions';
// ========================= ×©×™× ×•×™ ××¨×›×–×™ 1: ×™×™×‘×•× ×˜×™×¤×•×¡ ×”××™×œ×•×Ÿ =========================
import type { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';
export const dynamic = 'force-dynamic';



/**
 * ××—×©×‘ ××ª ×”×§×˜×’×•×¨×™×” ×©×œ ×”×”×¦×¢×” ×‘×”×ª×‘×¡×¡ ×¢×œ ×”×¡×˜×˜×•×¡ ×©×œ×”.
 */
const getSuggestionCategory = (status: MatchSuggestionStatus) => {
  switch (status) {
    case 'DRAFT':
    case 'AWAITING_MATCHMAKER_APPROVAL':
    case 'PENDING_FIRST_PARTY':
    case 'PENDING_SECOND_PARTY':
      return 'PENDING';

    case 'FIRST_PARTY_DECLINED':
    case 'SECOND_PARTY_DECLINED':
    case 'MATCH_DECLINED':
    case 'ENDED_AFTER_FIRST_DATE':
    case 'ENGAGED':
    case 'MARRIED':
    case 'EXPIRED':
    case 'CLOSED':
    case 'CANCELLED':
      return 'HISTORY';

    default:
      return 'ACTIVE';
  }
};

/**
 * POST: ×™×•×¦×¨ ×”×¦×¢×ª ×©×™×“×•×š ×—×“×©×”.
 */
export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const allowedRolesToCreate: UserRole[] = [
      UserRole.MATCHMAKER,
      UserRole.ADMIN,
    ];
    if (!allowedRolesToCreate.includes(session.user.role as UserRole)) {
      return NextResponse.json(
        {
          error:
            'Unauthorized - Matchmaker or Admin access required to create suggestions',
        },
        { status: 403 }
      );
    }

    const data = await req.json();

    if (!data.firstPartyId || !data.secondPartyId || !data.decisionDeadline) {
      return NextResponse.json(
        { error: 'Invalid input: Missing required fields.' },
        { status: 400 }
      );
    }
    
    // ========================= ×©×™× ×•×™ ××¨×›×–×™ 3: ×˜×¢×™× ×ª ×”×ª×¨×’×•××™× =========================
    const url = new URL(req.url);
const rawLocale = url.searchParams.get('locale');
const locale: 'he' | 'en' = (rawLocale === 'en' || rawLocale === 'he') ? rawLocale : 'he';    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email; // ×—×™×œ×•×¥ ×”×—×œ×§ ×©×œ ×”××™×™×œ×™×

    if (!emailDict) {
        // ×‘××§×¨×” ×—×™×¨×•× ×©×”××™×œ×•×Ÿ ×œ× × ×˜×¢×Ÿ ×›×¨××•×™
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    // ×‘×“×™×§×” ×•×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ×™ AI
    try {
      const [firstParty, secondParty] = await Promise.all([
        prisma.user.findUnique({
          where: { id: data.firstPartyId },
          include: { profile: true },
        }),
        prisma.user.findUnique({
          where: { id: data.secondPartyId },
          include: { profile: true },
        }),
      ]);

      if (!firstParty || !secondParty) {
        return NextResponse.json(
          { error: 'One or both candidates not found.' },
          { status: 404 }
        );
      }

      const profilesToUpdate: { userId: string; profileId: string }[] = [];
      if (firstParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: firstParty.id,
          profileId: firstParty.profile.id,
        });
      }
      if (secondParty.profile?.needsAiProfileUpdate) {
        profilesToUpdate.push({
          userId: secondParty.id,
          profileId: secondParty.profile.id,
        });
      }

      if (profilesToUpdate.length > 0) {
        console.log(
          `[AI Update Trigger] Updating AI profiles for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')} before creating suggestion.`
        );
        await Promise.all(
          profilesToUpdate.map((p) => updateUserAiProfile(p.userId))
        );
        await prisma.profile.updateMany({
          where: { id: { in: profilesToUpdate.map((p) => p.profileId) } },
          data: { needsAiProfileUpdate: false },
        });
        console.log(
          `[AI Update Trigger] Flags reset for users: ${profilesToUpdate
            .map((p) => p.userId)
            .join(', ')}.`
        );
      }
    } catch (aiUpdateError) {
      console.error('Failed during pre-suggestion AI profile update:', aiUpdateError);
      return NextResponse.json(
        { error: 'Failed to update AI profiles for candidates. Please try again.' },
        { status: 500 }
      );
    }

    // ×™×¦×™×¨×ª ×”×”×¦×¢×” ×•×”×¢×‘×¨×ª ×”××™×œ×•×Ÿ ×œ×©×™×¨×•×ª
    const suggestionData: CreateSuggestionData = {
      ...data,
      matchmakerId: session.user.id,
    };
    
    // ========================= ×©×™× ×•×™ ××¨×›×–×™ 4: ×”×¢×‘×¨×ª ×”××™×œ×•×Ÿ ×œ×©×™×¨×•×ª =========================
    const newSuggestion = await suggestionService.createSuggestion(suggestionData, emailDict);

    return NextResponse.json(newSuggestion, { status: 201 });
  } catch (error) {
    console.error('Error creating suggestion:', error);
    let message = 'Failed to create suggestion';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/**
 * GET: ×××—×–×¨ ×¨×©×™××” ×©×œ ×”×¦×¢×•×ª ×©×™×“×•×š.
 */
export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid session' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(req.url);
    const status = searchParams.get('status');
    const priority = searchParams.get('priority');
    const timeframe = searchParams.get('timeframe');

    const where: Prisma.MatchSuggestionWhereInput = {};

    if (session.user.role === UserRole.MATCHMAKER) {
      where.matchmakerId = session.user.id;
    } else if (session.user.role === UserRole.CANDIDATE) {
      where.OR = [
        { firstPartyId: session.user.id },
        { secondPartyId: session.user.id },
      ];
    }

    if (status) where.status = status as MatchSuggestionStatus;
    if (priority)
      where.priority =
        priority as Prisma.EnumPriorityFieldUpdateOperationsInput['set'];

    if (timeframe) {
      const date = new Date();
      switch (timeframe) {
        case 'today':
          date.setHours(0, 0, 0, 0);
          where.createdAt = { gte: date };
          break;
        case 'week':
          date.setDate(date.getDate() - 7);
          where.createdAt = { gte: date };
          break;
        case 'month':
          date.setMonth(date.getMonth() - 1);
          where.createdAt = { gte: date };
          break;
      }
    }

    const suggestions = await prisma.matchSuggestion.findMany({
      where,
      include: {
        firstParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        secondParty: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            status: true,
            isVerified: true,
            images: {
              select: { id: true, url: true, isMain: true },
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc' }],
            },
            profile: true,
          },
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true, role: true },
        },
        statusHistory: { orderBy: { createdAt: 'desc' } },
        meetings: { orderBy: { createdAt: 'desc' } },
        inquiries: {
          include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
          },
          orderBy: { createdAt: 'asc' },
        },
      },
      orderBy: { lastActivity: 'desc' },
    });

    const formattedSuggestions = suggestions.map((suggestion) => ({
      ...suggestion,
      category: getSuggestionCategory(suggestion.status),
      // Formatting logic remains the same...
    }));

    console.log(
      `[API GET /suggestions] User: ${session.user.id} (Role: ${
        session.user.role
      }). Found ${suggestions.length} suggestions matching query.`
    );

    return NextResponse.json(formattedSuggestions);
  } catch (error) {
    console.error('Error fetching suggestions:', error);
    let message = 'Failed to fetch suggestions';
    if (error instanceof Error) {
      message = error.message;
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { SuggestionService } from "@/components/matchmaker/suggestions/services/suggestions/SuggestionService";

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const params = await props.params;
    const suggestionId = params.id;
    const data = await req.json();
    
    const suggestionService = SuggestionService.getInstance();
    
    try {
      const updatedSuggestion = await suggestionService.updateSuggestion(
        suggestionId,
        session.user.id,
        {
          id: suggestionId,
          priority: data.priority,
          notes: {
            internal: data.internalNotes,
            forFirstParty: data.firstPartyNotes,
            forSecondParty: data.secondPartyNotes,
            matchingReason: data.matchingReason,
            followUpNotes: data.followUpNotes
          },
          decisionDeadline: data.decisionDeadline ? new Date(data.decisionDeadline) : undefined,
          responseDeadline: data.responseDeadline ? new Date(data.responseDeadline) : undefined
        }
      );
      
      return NextResponse.json({
        success: true,
        data: updatedSuggestion
      });
      
    } catch (serviceError: unknown) {
        console.error("Error from suggestion service:", serviceError);
        
        if (serviceError instanceof Error) {
          return NextResponse.json(
            { success: false, error: serviceError.message || "Failed to update suggestion" },
            { status: serviceError.message.includes("Unauthorized") ? 403 : 400 }
          );
        }
        
        return NextResponse.json(
          { success: false, error: "Failed to update suggestion" },
          { status: 400 }
        );
      }
  } catch (error) {
    console.error("Error updating suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const params = await props.params;
    const suggestionId = params.id;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to delete this suggestion" },
        { status: 403 }
      );
    }

    await prisma.suggestionStatusHistory.deleteMany({
      where: { suggestionId }
    });

    await prisma.dateFeedback.deleteMany({
      where: { suggestionId }
    });

    await prisma.meeting.deleteMany({
      where: { suggestionId }
    });

    await prisma.suggestionInquiry.deleteMany({
      where: { suggestionId }
    });

    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: {
        approvedBy: { set: [] },
        reviewedBy: { set: [] }
      }
    });

    await prisma.matchSuggestion.delete({
      where: { id: suggestionId }
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully"
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete suggestion", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\message\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/message/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';
import { notificationService } from '@/components/matchmaker/suggestions/services/notification/NotificationService';
import { initNotificationService } from '@/components/matchmaker/suggestions/services/notification/initNotifications';
import { EmailDictionary } from '@/types/dictionary';
import { getDictionary } from '@/lib/dictionaries';

initNotificationService();

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    const params = await props.params;
    const suggestionId = params.id;

    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: 'Unauthorized - Invalid session' }, { status: 401 });
    }

    const allowedRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: 'Unauthorized - Matchmaker or Admin access required' }, { status: 403 });
    }

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /message] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    const body = await req.json();
    const { partyType, customMessage, channels } = body;

    if (!partyType || !customMessage || !channels) {
      return NextResponse.json({ error: 'Invalid input: Missing required fields.' }, { status: 400 });
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true,
      },
    });

    if (!suggestion) {
      return NextResponse.json({ error: 'Suggestion not found' }, { status: 404 });
    }

    await notificationService.handleSuggestionStatusChange(
      suggestion, 
      emailDict,
      {
        channels: channels,
        notifyParties: [partyType],
        customMessage: customMessage
      }
    );

    return NextResponse.json({ success: true, message: 'Message sent successfully.' }, { status: 200 });

  } catch (error) {
    console.error('Error sending message for suggestion:', error);
    const message = (error instanceof Error) ? error.message : 'Failed to send message';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\remind\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/remind/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { initNotificationService } from "@/components/matchmaker/suggestions/services/notification/initNotifications";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

const notificationService = initNotificationService();

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const params = await props.params;
    const suggestionId = params.id;
    const { partyType } = await req.json();

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /remind] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict || !emailDict.notifications?.customMessage?.reminderText) {
        throw new Error(`Email dictionary for locale '${locale}' is missing required notification templates.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to send reminders for this suggestion" }, { status: 403 });
    }
    
    const notifyParties: ('first' | 'second')[] = [];
    if ((partyType === "first" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_FIRST_PARTY) {
      notifyParties.push('first');
    }
    if ((partyType === "second" || partyType === "both") && suggestion.status === MatchSuggestionStatus.PENDING_SECOND_PARTY) {
      notifyParties.push('second');
    }
    
    if (notifyParties.length === 0) {
      return NextResponse.json({ success: false, error: "No applicable recipients for reminder in current status" }, { status: 400 });
    }

    const reminderTemplateText = emailDict.notifications.customMessage.reminderText;
    const reminderContent = reminderTemplateText
        .replace('{{matchmakerName}}', `${suggestion.matchmaker.firstName} ${suggestion.matchmaker.lastName}`);

    await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: { lastActivity: new Date() },
    });

    await prisma.suggestionStatusHistory.create({
      data: {
        suggestionId,
        status: suggestion.status,
        notes: `×ª×–×›×•×¨×ª × ×©×œ×—×” ×œ${partyType === "first" ? "×¦×“ ×¨××©×•×Ÿ" : partyType === "second" ? "×¦×“ ×©× ×™" : "×©× ×™ ×”×¦×“×“×™×"} ×¢×œ ×™×“×™ ${session.user.firstName} ${session.user.lastName}`,
      },
    });
    
    await notificationService.handleSuggestionStatusChange(
      suggestion,
      emailDict,
      {
        channels: ['email', 'whatsapp'],
        notifyParties,
        customMessage: reminderContent
      }
    );
    
    return NextResponse.json({
      success: true,
      message: "Reminder sent successfully",
      recipientCount: notifyParties.length
    });
  } catch (error) {
    console.error("Error sending reminder:", error);
    return NextResponse.json(
      { success: false, error: "Failed to send reminder" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\resend\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/resend/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const params = await props.params;
    const suggestionId = params.id;
    const { partyType } = await req.json();

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /resend] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to resend this suggestion" }, { status: 403 });
    }

    let updatedSuggestion = suggestion;
    const transitionNotes = `×”×¦×¢×” × ×©×œ×—×” ××—×“×© ×¢"×™ ${session.user.firstName} ${session.user.lastName}`;
    
    if (partyType === "both" || partyType === "first") {
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_FIRST_PARTY,
        emailDict,
        `${transitionNotes} - ×œ×¦×“ ×¨××©×•×Ÿ`,
        {
          sendNotifications: true,
          notifyParties: ['first']
        }
      );
      
      if (partyType === "first") {
        await prisma.matchSuggestion.update({
          where: { id: suggestionId },
          data: {
            firstPartySent: new Date(),
            lastActivity: new Date()
          }
        });
      }
    }
    
    if (partyType === "both" || partyType === "second") {
      updatedSuggestion = await statusTransitionService.transitionStatus(
        updatedSuggestion, 
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        emailDict,
        `${transitionNotes} - ×œ×¦×“ ×©× ×™`,
        {
          sendNotifications: true,
          notifyParties: ['second']
        }
      );
      
      await prisma.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          secondPartySent: new Date(),
          lastActivity: new Date()
        }
      });
    }

    return NextResponse.json({
      success: true,
      message: `Suggestion successfully resent to ${partyType === "first" ? "first party" : partyType === "second" ? "second party" : "both parties"}`,
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error resending suggestion:", error);
    return NextResponse.json(
      { success: false, error: "Failed to resend suggestion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\share-contact\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/share-contact/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, MatchSuggestionStatus } from "@prisma/client";
import { statusTransitionService } from "@/components/matchmaker/suggestions/services/suggestions/StatusTransitionService";
import { EmailDictionary } from "@/types/dictionary";
import { getDictionary } from "@/lib/dictionaries";

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Insufficient permissions" }, { status: 403 });
    }

    const params = await props.params;
    const suggestionId = params.id;

    const url = new URL(req.url);
    const locale: 'he' | 'en' = (url.searchParams.get('locale') === 'en') ? 'en' : 'he';
    
    console.log(`[API /share-contact] Received request with locale: '${locale}'`);

    const dictionary = await getDictionary(locale);
    const emailDict: EmailDictionary = dictionary.email;

    if (!emailDict) {
        throw new Error(`Email dictionary for locale '${locale}' could not be loaded.`);
    }

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true
      },
    });

    if (!suggestion) {
      return NextResponse.json({ success: false, error: "Suggestion not found" }, { status: 404 });
    }

    if (suggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "You are not authorized to share contact details for this suggestion" }, { status: 403 });
    }
    
    if (suggestion.status !== MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
      return NextResponse.json({
        success: false,
        error: "Cannot share contacts until both parties have approved the suggestion."
      }, { status: 400 });
    }
    
    const updatedSuggestion = await statusTransitionService.transitionStatus(
      suggestion,
      MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
      emailDict,
      `×¤×¨×˜×™ ×§×©×¨ ×©×•×ª×¤×• ×‘×™×Ÿ ${suggestion.firstParty.firstName} ${suggestion.firstParty.lastName} ×œ${suggestion.secondParty.firstName} ${suggestion.secondParty.lastName} ×¢"×™ ${session.user.firstName} ${session.user.lastName}`,
      {
        sendNotifications: true,
        notifyParties: ['first', 'second', 'matchmaker']
      }
    );

    return NextResponse.json({
      success: true,
      message: "Contact details shared successfully",
      suggestion: updatedSuggestion
    });
  } catch (error) {
    console.error("Error sharing contact details:", error);
    return NextResponse.json(
      { success: false, error: "Failed to share contact details" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\matchmaker\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/matchmaker/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { z } from "zod";

const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    const body = await req.json();
    console.log("Received status update request:", body);
    
    const validationResult = updateStatusSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error:", validationResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid request data", 
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }
    
    const { status, notes } = validationResult.data;
    const params = await props.params;
    const suggestionId = params.id;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to update this suggestion" },
        { status: 403 }
      );
    }

    const getCategory = (status: MatchSuggestionStatus) => {
      switch (status) {
        case "DRAFT":
        case "AWAITING_MATCHMAKER_APPROVAL":
        case "PENDING_FIRST_PARTY":
        case "PENDING_SECOND_PARTY":
          return "PENDING";
        
        case "FIRST_PARTY_DECLINED":
        case "SECOND_PARTY_DECLINED":
        case "MATCH_DECLINED":
        case "ENDED_AFTER_FIRST_DATE":
        case "ENGAGED":
        case "MARRIED":
        case "EXPIRED":
        case "CLOSED":
        case "CANCELLED":
          return "HISTORY";
        
        default:
          return "ACTIVE";
      }
    };

    const result = await prisma.$transaction(async (tx) => {
      const previousStatus = suggestion.status;
      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status,
          previousStatus: previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          category: getCategory(status),
          ...(status === MatchSuggestionStatus.CLOSED ? { closedAt: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_FIRST_PARTY ? { firstPartySent: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY ? { secondPartySent: new Date() } : {}),
        },
      });

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes: notes || `×¡×˜×˜×•×¡ ×©×•× ×” ×œ-${status} ×¢×œ ×™×“×™ ${session.user.firstName} ${session.user.lastName}`,
        },
      });

      return updatedSuggestion;
    });

    return NextResponse.json({
      success: true,
      message: "Status updated successfully",
      suggestion: {
        id: result.id,
        status: result.status,
        previousStatus: result.previousStatus,
        lastStatusChange: result.lastStatusChange,
        category: result.category,
      },
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to update status", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const params = await props.params;
    const searchParams = new URL(req.url).searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 50;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        matchmakerId: true,
        firstPartyId: true,
        secondPartyId: true,
      }
    });
    
    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return NextResponse.json({ error: "Not authorized to view this suggestion" }, { status: 403 });
    }
    
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(startDate && {
          createdAt: {
            gte: new Date(startDate),
            ...(endDate && {
              lte: new Date(endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: { id: true, firstName: true, lastName: true },
            },
            secondParty: {
              select: { id: true, firstName: true, lastName: true },
            },
            matchmaker: {
              select: { id: true, firstName: true, lastName: true },
            },
          },
        },
      },
      orderBy: { createdAt: "desc" as const },
      take: limit,
    };

    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { error: "Failed to fetch history", details: errorMessage },
      { status: 500 }
    );
  }
}

export async function HEAD(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new Response(null, { status: 401 });
    }

    const params = await props.params;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      }
    });

    if (!suggestion) {
      return new Response(null, { status: 404 });
    }

    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return new Response(null, { status: 403 });
    }

    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages\feed
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\messages\feed\route.ts
--------------------------------------------------------------------------------
Content:
// FILENAME: src/app/api/messages/feed/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { FeedItem, FeedItemType, ExtendedSuggestionInquiry } from "@/types/messages";
import type { ExtendedMatchSuggestion } from "@/components/suggestions/types";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";

export const dynamic = 'force-dynamic';

// ×”×’×“×¨×” ××—×™×“×” ×œ×©×œ×™×¤×ª ×¤×¨×˜×™ ××©×ª××©×™× ××œ××™×
const partySelect = {
  id: true, email: true, firstName: true, lastName: true, isProfileComplete: true, phone: true,
  profile: true,
  images: {
    select: { 
      id: true, url: true, isMain: true, createdAt: true, updatedAt: true,
      cloudinaryPublicId: true, userId: true
    },
    orderBy: { isMain: "desc" as const },
  },
};

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const userId = session.user.id;
  const userRole = session.user.role as UserRole;

  try {
    // 1. ×©×œ×•×£ ×”×¦×¢×•×ª ×©×™×“×•×š ×¨×œ×•×•× ×˜×™×•×ª
    const suggestionsFromDb = await prisma.matchSuggestion.findMany({
      where: {
        OR: [{ firstPartyId: userId }, { secondPartyId: userId }],
        status: { notIn: [MatchSuggestionStatus.DRAFT, MatchSuggestionStatus.CANCELLED] },
      },
      include: {
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: { select: partySelect },
        secondParty: { select: partySelect },
        statusHistory: { orderBy: { createdAt: "desc" } },
      },
      orderBy: { lastActivity: "desc" },
    });
    const suggestions: ExtendedMatchSuggestion[] = suggestionsFromDb.filter(
      (s) => s.firstParty?.profile && s.secondParty?.profile
    ) as ExtendedMatchSuggestion[];

    // 2. ×©×œ×•×£ ×”×•×“×¢×•×ª ×¦'××˜ ×¨×œ×•×•× ×˜×™×•×ª
    const inquiriesFromDb = await prisma.suggestionInquiry.findMany({
        where: {
            OR: [{ fromUserId: userId }, { toUserId: userId }]
        },
        include: {
            fromUser: { select: { id: true, firstName: true, lastName: true } },
            toUser: { select: { id: true, firstName: true, lastName: true } },
            suggestion: {
                include: {
                    firstParty: { select: partySelect },
                    secondParty: { select: partySelect },
                    matchmaker: { select: { firstName: true, lastName: true } },
                }
            }
        },
        orderBy: { createdAt: 'desc' },
        take: 30
    });

    // 3. ×”××¨×ª ×”×¦×¢×•×ª ×œ××‘× ×” FeedItem
    const suggestionFeedItems: FeedItem[] = suggestions.map((s) => {
      const isFirstParty = s.firstPartyId === userId;
      const otherParty = isFirstParty ? s.secondParty : s.firstParty;
      let type: FeedItemType = 'STATUS_UPDATE';
      let title = `×¢×“×›×•×Ÿ ×‘×”×¦×¢×” ×¢× ${otherParty.firstName}`;
      let description = "×”×¡×˜×˜×•×¡ ×”×ª×¢×“×›×Ÿ. ×œ×—×¥/×™ ×œ×¤×¨×˜×™×.";
      
      const link = userRole === 'CANDIDATE' 
        ? `/matches?suggestionId=${s.id}` 
        : `/matchmaker/suggestions?suggestionId=${s.id}`;

      if ((s.status === "PENDING_FIRST_PARTY" && isFirstParty) || (s.status === "PENDING_SECOND_PARTY" && !isFirstParty)) {
        type = 'ACTION_REQUIRED';
        title = `×”×¦×¢×” ×—×“×©×” ×××ª×™× ×” ×œ×š!`;
        description = `${s.matchmaker.firstName} ×—×•×©×‘/×ª ×©×™×© ×›××Ÿ ×¤×•×˜× ×¦×™××œ ×’×“×•×œ.`;
      } else if (s.status === "CONTACT_DETAILS_SHARED") {
        title = "××–×œ ×˜×•×‘, ×™×© ×”×ª×××”!";
        description = `×¤×¨×˜×™ ×”×§×©×¨ ×”×•×¢×‘×¨×•. ×–×” ×”×–××Ÿ ×œ×™×¦×•×¨ ×§×©×¨.`;
      } else if (s.status === "AWAITING_FIRST_DATE_FEEDBACK") {
        type = 'ACTION_REQUIRED';
        title = "××™×š ×”×™×™×ª×” ×”×¤×’×™×©×” ×”×¨××©×•× ×”?";
        description = "× ×©××— ×œ×©××•×¢ ××ª ×“×¢×ª×š ×›×“×™ ×œ×”××©×™×š ×•×œ×¡×™×™×¢.";
      }
      
      return {
        id: `${s.id}-${s.status}`, type, title, description,
        timestamp: s.lastActivity, isRead: false,
        link: link,
        payload: { suggestion: s },
      };
    });

    // 4. ×”××¨×ª ×”×•×“×¢×•×ª ×¦'××˜ ×œ××‘× ×” FeedItem
    const inquiryFeedItems: FeedItem[] = inquiriesFromDb.map((inquiry): FeedItem => {
        const isMyMessage = inquiry.fromUserId === userId;
        const otherUser = isMyMessage ? inquiry.toUser : inquiry.fromUser;
        const suggestionParticipant = inquiry.suggestion.firstPartyId === userId ? inquiry.suggestion.secondParty : inquiry.suggestion.firstParty;
        
        let title: string;
        let description: string;
        let type: FeedItemType;

        const link = userRole === 'CANDIDATE'
            ? `/matches?suggestionId=${inquiry.suggestionId}&view=chat`
            : `/matchmaker/suggestions?suggestionId=${inquiry.suggestionId}&view=chat`;

        if (isMyMessage) {
            title = `×©×œ×—×ª ×©××œ×” ×œ${otherUser.firstName}`;
            description = `"${inquiry.question.substring(0, 50)}..."`;
            type = inquiry.answer ? 'INQUIRY_RESPONSE' : 'MATCHMAKER_MESSAGE';
        } else {
            if (inquiry.answer) {
                 title = `×”×ª×§×‘×œ×” ×ª×©×•×‘×” ×${otherUser.firstName}`;
                 description = `×œ×’×‘×™ ×©××œ×ª×š ×¢×œ ${suggestionParticipant.firstName}: "${inquiry.answer.substring(0, 40)}..."`;
                 type = 'INQUIRY_RESPONSE';
            } else {
                 title = `×”×•×“×¢×” ×—×“×©×” ×${otherUser.firstName}`;
                 description = `×œ×’×‘×™ ×”×”×¦×¢×” ×¢× ${suggestionParticipant.firstName}`;
                 type = userRole === 'MATCHMAKER' && inquiry.status === 'PENDING' ? 'ACTION_REQUIRED' : 'MATCHMAKER_MESSAGE';
            }
        }

        return {
            id: inquiry.id,
            type: type,
            title,
            description,
            timestamp: inquiry.answeredAt ? inquiry.answeredAt : inquiry.createdAt,
            isRead: isMyMessage || inquiry.status !== 'PENDING',
            link: link,
            payload: { 
                suggestion: inquiry.suggestion as unknown as ExtendedMatchSuggestion,
                suggestionInquiry: inquiry as unknown as ExtendedSuggestionInquiry
            }
        };
    });

    // 5. ××™×—×•×“, ××™×•×Ÿ ×•×”×—×–×¨×”
    const allFeedItems = [...suggestionFeedItems, ...inquiryFeedItems];
    allFeedItems.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    
    return NextResponse.json({ success: true, feed: allFeedItems });

  } catch (error) {
    console.error("Error fetching activity feed:", error);
    return NextResponse.json({ success: false, error: "Failed to fetch activity feed" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\notifications
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\notifications\route.ts
--------------------------------------------------------------------------------
Content:
// FILENAME: src/app/api/notifications/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { Session } from "next-auth";

export const dynamic = 'force-dynamic';

export async function GET() {
  try {
    const session = await getServerSession(authOptions) as Session | null;
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userId = session.user.id;

    // 1. ×¡×¤×™×¨×ª ×‘×§×©×•×ª ×–××™× ×•×ª ×›×œ×œ×™×•×ª ×©×××ª×™× ×•×ª ×œ××©×ª××© ×–×”
    const pendingAvailabilityRequests = await prisma.availabilityInquiry.count({
      where: {
        OR: [
          { 
            firstPartyId: userId,
            firstPartyResponse: null,
            expiresAt: { gt: new Date() }
          },
          { 
            secondPartyId: userId,
            secondPartyResponse: null,
            expiresAt: { gt: new Date() }
          }
        ]
      },
    });

    // 2. ×¡×¤×™×¨×ª ×”×•×“×¢×•×ª ×¦'××˜ ×—×“×©×•×ª ×©×××ª×™× ×•×ª ×œ××©×ª××© ×–×”
    // (×”×•×“×¢×•×ª ×©×”××©×ª××© ×”×•× ×”× ××¢×Ÿ ×©×œ×”×Ÿ ×•×”×¡×˜×˜×•×¡ ×©×œ×”×Ÿ ×”×•× "×××ª×™×Ÿ")
    const unreadChatMessages = await prisma.suggestionInquiry.count({
        where: {
            toUserId: userId,
            status: 'PENDING'
        }
    });

    const total = pendingAvailabilityRequests + unreadChatMessages;

    return NextResponse.json({
      availabilityRequests: pendingAvailabilityRequests,
      messages: unreadChatMessages, // ×–×” ×¢×›×©×™×• ×¡×•×¤×¨ ×”×•×“×¢×•×ª ×¦'××˜ ×××™×ª×™×•×ª
      total: total
    });

  } catch (error) {
    console.error("Error fetching notifications:", error);
    return NextResponse.json(
      { error: "Failed to fetch notifications" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\og
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\og\route.tsx
--------------------------------------------------------------------------------
Content:
// src/app/api/og/route.tsx
import { ImageResponse } from 'next/og';

export const runtime = 'edge';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    
    // ×× ×™×© ×œ× ×• ××ª ×©× ×”×××œ×™×¥, × ×¦×™×’ ××•×ª×•. ××—×¨×ª × ×¦×™×’ ×˜×§×¡×˜ ×›×œ×œ×™
    const referrerName = searchParams.get('name');
    const title = referrerName 
      ? `${referrerName} ××–××™×Ÿ/×” ××•×ª×š ×œ×”×¦×˜×¨×£`
      : '×”×–×× ×” ××™×©×™×ª ×œ×”×¦×˜×¨×£ ×œ×§×”×™×œ×”';

    return new ImageResponse(
      (
        <div
          style={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#0f172a', // Slate-900 background
            backgroundImage: 'linear-gradient(to bottom right, #0f172a, #1e293b)',
            position: 'relative',
          }}
        >
          {/* Decorative Hanukkah Glow */}
          <div
            style={{
              position: 'absolute',
              top: '-100px',
              left: '50%',
              transform: 'translateX(-50%)',
              width: '600px',
              height: '600px',
              background: 'radial-gradient(circle, rgba(251, 191, 36, 0.15) 0%, transparent 70%)',
              filter: 'blur(40px)',
            }}
          />

          {/* Logo / Brand Name */}
          <div style={{ display: 'flex', alignItems: 'center', marginBottom: '40px' }}>
             {/* ××¤×©×¨ ×œ×”×•×¡×™×£ ×›××Ÿ ×ª××•× ×” ×©×œ ×”×œ×•×’×• ×× ×™×© ×œ×š URL ×—×™×¦×•× ×™ */}
            <span style={{ fontSize: 60, fontWeight: 'bold', color: '#f59e0b', letterSpacing: '-2px' }}>
              NeshamaTech
            </span>
          </div>

          {/* Card Container */}
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center',
              backgroundColor: 'rgba(255, 255, 255, 0.05)',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: '20px',
              padding: '40px 60px',
              boxShadow: '0 20px 50px rgba(0,0,0,0.3)',
            }}
          >
            {/* Main Title */}
            <div
              style={{
                fontSize: 50,
                fontWeight: 900,
                color: 'white',
                textAlign: 'center',
                lineHeight: 1.2,
                marginBottom: '20px',
                whiteSpace: 'pre-wrap',
              }}
            >
              {title}
            </div>

            {/* Subtitle */}
            <div
              style={{
                fontSize: 28,
                color: '#cbd5e1', // Slate-300
                textAlign: 'center',
                maxWidth: '800px',
              }}
            >
              ××•×¡×™×¤×™× ××•×¨ ×‘×—× ×•×›×” ğŸ• | ×©×™×“×•×›×™× ×¢× × ×©××”
            </div>
          </div>
          
          {/* Footer / URL */}
          <div style={{ position: 'absolute', bottom: 40, fontSize: 24, color: '#64748b' }}>
            neshamatech.com
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
      }
    );
} catch (e) {
  // ×”×©×™× ×•×™ ×”×•× ×‘×”×•×¡×¤×ª (e as Error)
  console.log((e as Error).message); 
  
  return new Response(`Failed to generate the image`, {
    status: 500,
  });
}
}
--- End of Content for route.tsx ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\profile_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
# Generated on: 2025-11-09 10:30:56
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\profile_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/profile/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UserProfile } from "@/types/next-auth";

// ×”×’×“×¨×” ×–×• ××‘×˜×™×—×” ×©×”-Route Handler ×™×¨×•×¥ ×ª××™×“ ××—×“×© ×•×œ× ×™×©××¨ ×‘-Cache.
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    // ×•×“× ×©×”××©×ª××© ××—×•×‘×¨. × ×“×¨×© ×¡×©×Ÿ ×›×“×™ ×œ×’×©×ª ×œ×›×œ ×¤×¨×•×¤×™×œ.
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×§×‘×¢ ×¢×‘×•×¨ ××™×–×” ××©×ª××© × ×©×œ×¤×™× ×”× ×ª×•× ×™×:
    // ×× ×¦×•×™×Ÿ ID ×‘×‘×§×©×”, ×”×©×ª××© ×‘×•. ××—×¨×ª, ×”×©×ª××© ×‘-ID ×©×œ ×”××©×ª××© ×”××—×•×‘×¨.
    const targetUserId = requestedUserId || session.user.id;

    // ×©×œ×•×£ ××ª ×”××©×ª××© ×™×—×“ ×¢× ×›×œ ×”××™×“×¢ ×”××§×•×©×¨ ×©×œ×• (×¤×¨×•×¤×™×œ, ×ª××•× ×•×ª, ×•×”××œ×¦×•×ª)
    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      include: {
        profile: {
          include: {
            testimonials: {
              orderBy: {
                createdAt: 'desc',
              }
            }
          }
        },
        images: {
            orderBy: {
                isMain: 'desc' // ×•×“× ×©×”×ª××•× ×” ×”×¨××©×™×ª ×ª××™×“ ×¨××©×•× ×”
            }
        },
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        console.error(`Profile data not found for user ID: ${targetUserId}`);
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    if (!dbProfile.birthDate) {
        console.error(`birthDate is null or undefined for profile ID: ${dbProfile.id}`);
        return NextResponse.json(
            { success: false, message: 'Data integrity issue: birthDate is missing for the profile.' },
            { status: 500 }
        );
    }

    // ×‘× ×” ××ª ××•×‘×™×™×§×˜ ×”×ª×’×•×‘×” ×”××œ× ×©×™×©×œ×— ×—×–×¨×” ×œ×œ×§×•×—
    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering,
      kippahType: dbProfile.kippahType,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      
      // ×©×“×•×ª ×”×¡×™×¤×•×¨ ×•×”×ª×•×›×Ÿ ×”××™×©×™
      about: dbProfile.about || "",
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      
      // ×“×‘×¨ ×”××¢×¨×›×ª ×•×”××œ×¦×•×ª
      manualEntryText: dbProfile.manualEntryText || undefined,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      testimonials: dbProfile.testimonials || [],
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,

      // ×”×¢×“×¤×•×ª ×©×™×“×•×š
      matchingNotes: dbProfile.matchingNotes || "",
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: dbProfile.preferredServiceTypes || [],
      preferredHeadCoverings: dbProfile.preferredHeadCoverings || [],
      preferredKippahTypes: dbProfile.preferredKippahTypes || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],

      // ×”×’×“×¨×•×ª ×•×”×¢×“×¤×•×ª ××§×¦×•×¢×™×•×ª
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender,

      // ×¡×˜×˜×•×¡ ×•××™×“×¢ ××¢×¨×›×ª×™
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      
      // ××™×“×¢ ×¨×¤×•××™ (×—×¡×•×™)
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
   medicalInfoDetails: dbProfile.isMedicalInfoVisible 
        ? dbProfile.medicalInfoDetails ?? undefined 
        : undefined,      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
       cvUrl: dbProfile.cvUrl,
      cvSummary: dbProfile.cvSummary,
      // ××™×“×¢ ×‘×¡×™×¡×™ ×¢×œ ×”××©×ª××©
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };
    
    // ×”×—×–×¨×ª ×ª×©×•×‘×” ××•×¦×œ×—×ª ×¢× ×›×œ ×”× ×ª×•× ×™×
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });
await prisma.user.update({
  where: { id: session.user.id },
  data: { updatedAt: new Date() }
});

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\cv
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\cv\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/cv/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // Adjust path if needed
import prisma from '@/lib/prisma'; // Adjust path if needed
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary with your credentials
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// --- POST Handler for uploading a CV ---
export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }
  const userId = session.user.id;

  try {
    const formData = await req.formData();
    const file = formData.get('cv') as File | null;

    if (!file) {
      return NextResponse.json({ success: false, message: 'No file provided' }, { status: 400 });
    }

    // Convert file to buffer
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    // Upload to Cloudinary
    const uploadResult = await new Promise<any>((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
            {
                resource_type: 'raw', // Use 'raw' for non-image files like PDF/DOCX
                folder: `users/${userId}/cvs`, // Organize files in a structured way
                public_id: `${file.name}-${Date.now()}`, // Create a unique file name
            },
            (error, result) => {
                if (error) reject(error);
                resolve(result);
            }
        );
        uploadStream.end(buffer);
    });
    
    if (!uploadResult?.secure_url) {
        throw new Error('Cloudinary upload failed');
    }

    // Update user's profile in the database
    const updatedProfile = await prisma.profile.update({
      where: { userId },
      data: {
        cvUrl: uploadResult.secure_url,
      },
    });

    // TODO: In the future, trigger the AI summary generation here (async)
    // For example: await generateCvSummary(userId, uploadResult.secure_url);

    return NextResponse.json({ success: true, profile: updatedProfile });
  } catch (error) {
    console.error('CV Upload API Error:', error);
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}


// --- DELETE Handler for deleting a CV ---
export async function DELETE(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
  
    try {
        const profile = await prisma.profile.findUnique({
            where: { userId },
            select: { cvUrl: true },
        });

        if (profile?.cvUrl) {
            // Extract public_id from URL to delete from Cloudinary
            const publicIdMatch = profile.cvUrl.match(/\/users\/.*\/cvs\/(.*)/);
            if (publicIdMatch && publicIdMatch[1]) {
                const publicId = `users/${userId}/cvs/${decodeURIComponent(publicIdMatch[1])}`;
                await cloudinary.uploader.destroy(publicId, { resource_type: 'raw' });
            }
        }

        // Remove the URL from the user's profile
        const updatedProfile = await prisma.profile.update({
            where: { userId },
            data: {
                cvUrl: null,
                cvSummary: null, // Also clear the summary when CV is deleted
            },
        });

        return NextResponse.json({ success: true, profile: updatedProfile });
    } catch (error) {
        console.error('CV Delete API Error:', error);
        return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
export const dynamic = 'force-dynamic';
// Configure Cloudinary
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// ×¤×•× ×§×¦×™×” ×¢×•×˜×¤×ª ×œ-Upload ×¢× Promise × ×›×•×Ÿ
function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: 'profile-images',
        resource_type: 'image',
      },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({
            secure_url: result.secure_url,
            public_id: result.public_id,
          });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// GET - Fetch all images for a user
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: {
        user: {
          email: session.user.email,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error('[GetImages] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch images' },
      { status: 500 }
    );
  }
}

// POST - Upload new images (can be adapted for multiple files)
export async function POST(req: NextRequest) {
  // Apply rate limiting: 20 image uploads per user per hour (prevents resource abuse)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  const startTime = Date.now();

  try {
    console.log('[Upload] Starting upload process');

    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error('[Upload] Authentication failed - No user session');
      return NextResponse.json(
        {
          success: false,
          error: 'Unauthorized',
        },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      select: { id: true, email: true, _count: { select: { images: true } } },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.error('[Upload] No file provided in request');
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    if (user._count.images >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { success: false, error: 'Maximum number of images reached' },
        { status: 400 }
      );
    }

    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid file type. Only JPG, PNG and WEBP are allowed',
        },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { success: false, error: 'File size must be less than 5MB' },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    console.log(`[Upload] File processed, uploading to Cloudinary...`);

    const cloudinaryResult = await uploadToCloudinary(buffer);

    const isFirstImage = user._count.images === 0;

    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });
await prisma.user.update({
  where: { id: session.user.id },
  data: { updatedAt: new Date() }
});

    console.log(
      `[Upload] Database save completed in ${Date.now() - startTime}ms`
    );
    return NextResponse.json({
      success: true,
      image,
      timing: `${Date.now() - startTime}ms`,
    });
  } catch (error) {
    console.error('[Upload] General error:', error);
    console.log(`[Upload] Failed after ${Date.now() - startTime}ms`);
    return NextResponse.json(
      { success: false, error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// --- NEW ---
// DELETE - Bulk delete images
export async function DELETE(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const { imageIds } = await req.json();

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Image IDs must be a non-empty array' },
        { status: 400 }
      );
    }

    // 1. Find images to verify ownership and get necessary data
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: userId, // CRUCIAL: Ensures user only deletes their own images
      },
      select: {
        id: true,
        cloudinaryPublicId: true,
        isMain: true,
      },
    });

    if (imagesToDelete.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No matching images found to delete.' },
        { status: 404 }
      );
    }

    // 2. Check if the main image is being deleted
    const wasMainImageDeleted = imagesToDelete.some((image) => image.isMain);

    // 3. Delete from Cloudinary
    const cloudinaryIdsToDelete = imagesToDelete
      .map((image) => image.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (cloudinaryIdsToDelete.length > 0) {
      const cloudinaryDeletions = cloudinaryIdsToDelete.map((publicId) =>
        cloudinary.uploader.destroy(publicId).catch((err) => {
          console.error(
            `[Bulk Delete] Failed to delete image ${publicId} from Cloudinary:`,
            err
          );
        })
      );
      await Promise.all(cloudinaryDeletions);
    }

    // 4. Delete from database
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) }, // Use validated IDs
        userId: userId,
      },
    });

    // 5. If main image was deleted, assign a new one if possible
    if (wasMainImageDeleted) {
      const newMainImage = await prisma.userImage.findFirst({
        where: { userId: userId },
        orderBy: { createdAt: 'desc' },
      });

      if (newMainImage) {
        await prisma.userImage.update({
          where: { id: newMainImage.id },
          data: { isMain: true },
        });
      }
    }

    // 6. Fetch the updated list of images to return to the client
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, images: updatedImages });
  } catch (error) {
    console.error('[Bulk Delete Images] Error:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete images',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/[imageId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { imageId } = params;
    
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId },
    });

    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { imageId } = params;

    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/questionnaire/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma, UserRole } from '@prisma/client';
import { Locale } from '../../../../../i18n-config';

import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { WorldId, UpdateValue } from '@/types/next-auth';
import { formatQuestionnaireForDisplay } from '@/lib/services/questionnaireService';

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // ×§×‘×™×¢×ª ×©×¤×ª ×”×¦×•×¤×” ××”-URL ××• ××”-headers (×›××Ÿ × ×©×ª××© ×‘×‘×¨×™×¨×ª ××—×“×œ)
    const url = new URL(req.url);
    const viewerLocale = (url.searchParams.get('locale') as Locale) || 'he';
    const targetUserId = url.searchParams.get('userId') || session.user.id;
const isOwnProfile = session.user.id === targetUserId;
const hasElevatedPermissions = 
    session.user.role === UserRole.ADMIN || 
    session.user.role === UserRole.MATCHMAKER;
const canViewAllAnswers = isOwnProfile || hasElevatedPermissions;
console.log(`---[ SERVER LOG | API questionnaire GET ]--- ×©×œ×™×¤×ª ×©××œ×•×Ÿ ×¢×‘×•×¨: ${targetUserId}, ×¦×•×¤×”: ${session.user.id}, ×ª×¤×§×™×“ ×¦×•×¤×”: ${session.user.role}, ×™×›×•×œ ×œ×¨××•×ª ×”×›×œ: ${canViewAllAnswers}`);

console.log(`---[ SERVER LOG | API questionnaire GET ]--- ×©×œ×™×¤×ª ×©××œ×•×Ÿ ×¢×‘×•×¨ ××©×ª××©: ${targetUserId}, ×©×¤×ª ×¦×¤×™×™×”: ${viewerLocale}, ×”×× ×‘×¢×œ ×”×¤×¨×•×¤×™×œ: ${isOwnProfile}`);


    const rawQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: targetUserId },
      orderBy: { createdAt: 'desc' },
    });

    if (!rawQuestionnaire) {
              console.warn('---[ SERVER LOG | API questionnaire GET ]--- ×œ× × ××¦× ×©××œ×•×Ÿ ×¢×‘×•×¨ ×”××©×ª××©.');

      return NextResponse.json({ success: false, message: 'No questionnaire found' }, { status: 404 });
    }
    console.log('---[ SERVER LOG | API questionnaire GET ]--- × ×ª×•× ×™ ×©××œ×•×Ÿ ×’×•×œ××™×™× ××”-DB:', JSON.stringify(rawQuestionnaire, null, 2));

    // ×©×™××•×© ×‘×¤×•× ×§×¦×™×™×ª ×”×¢×™×¦×•×‘ ×”×—×“×©×”
const formattedQuestionnaire = await formatQuestionnaireForDisplay(
  rawQuestionnaire,
  viewerLocale,
  canViewAllAnswers  // <-- ×”×•×¡×¤×ª ×”×¤×¨××˜×¨ ×”×—×“×©
);    console.log('---[ DEBUG 4: FINAL API RESPONSE ]--- Data being sent to client:', JSON.stringify(formattedQuestionnaire.formattedAnswers, null, 2));
    console.log('---[ SERVER LOG | API questionnaire GET ]--- × ×ª×•× ×™× ××¢×•×‘×“×™× ×©××•×—×–×¨×™× ×œ×§×œ×™×™× ×˜:', JSON.stringify(formattedQuestionnaire, null, 2));

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedQuestionnaire,
    });
  } catch (error) {
    console.error('Error fetching formatted questionnaire:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    return NextResponse.json({ success: false, message: errorMessage }, { status: 500 });
 
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
     const userId = session.user.id;

     const body = await req.json();
     
     const { worldKey, questionId, value } = body as {
       worldKey: WorldId;
       questionId: string;
       value: UpdateValue;
     };

     if (!worldKey || !questionId || !value || !value.type || !KEY_MAPPING[worldKey]) {
        return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
     }

     const dbKey = KEY_MAPPING[worldKey];

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       return NextResponse.json({ success: false, error: "×©××œ×•×Ÿ ×œ× × ××¦×" }, { status: 404 });
     }

     const currentAnswersJson = questionnaire[dbKey];
     const currentAnswers = Array.isArray(currentAnswersJson) ? currentAnswersJson as unknown as JsonAnswerData[] : [];

     let updatedAnswers: JsonAnswerData[];

     if (value.type === 'delete') {
       // ×œ×•×’×™×§×” ×œ××—×™×§×ª ×”×ª×©×•×‘×”
       updatedAnswers = currentAnswers.filter(a => a.questionId !== questionId);
     } else {
       // ×œ×•×’×™×§×” ×§×™×™××ª ×œ×¢×“×›×•×Ÿ ××• ×”×•×¡×¤×ª ×ª×©×•×‘×”
       const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
       const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

       let updatedAnswer: JsonAnswerData;

       if (value.type === 'visibility') {
          if (!existingAnswer) return NextResponse.json({ success: false, error: "×œ× × ××¦××” ×ª×©×•×‘×” ×œ×¢×“×›×•×Ÿ × ×¨××•×ª" }, { status: 404 });
          if (typeof value.isVisible !== 'boolean') return NextResponse.json({ success: false, error: "×¢×¨×š × ×¨××•×ª ×œ× ×ª×§×™×Ÿ" }, { status: 400 });
          updatedAnswer = { ...existingAnswer, isVisible: value.isVisible, answeredAt: new Date().toISOString() };
       } else if (value.type === 'answer') {
         if (value.value === undefined) return NextResponse.json({ success: false, error: "×¢×¨×š ×ª×©×•×‘×” ×—×¡×¨" }, { status: 400 });
         updatedAnswer = {
           questionId,
           value: value.value as Prisma.JsonValue,
           isVisible: existingAnswer?.isVisible ?? true,
           answeredAt: new Date().toISOString()
         };
       } else {
           return NextResponse.json({ success: false, error: "×¡×•×’ ×¢×“×›×•×Ÿ ×œ× ×ª×§×™×Ÿ" }, { status: 400 });
       }

       updatedAnswers = [...currentAnswers];
       if (existingAnswerIndex !== -1) {
           updatedAnswers[existingAnswerIndex] = updatedAnswer;
       } else if (value.type === 'answer') {
           updatedAnswers.push(updatedAnswer);
       }
     }

     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });

     await prisma.profile.update({
       where: { userId },
       data: { needsAiProfileUpdate: true }
     });
await prisma.user.update({
  where: { id: userId },
  data: { updatedAt: new Date() }
});
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach(key => {
       const currentDbKey = KEY_MAPPING[key];
        formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
    });

     const formattedResponse = {
       ...updated,
       formattedAnswers: formattedAnswers
     };

     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            return NextResponse.json({ success: false, error: "×©×’×™××ª ××¡×“ × ×ª×•× ×™×" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           return NextResponse.json({ success: false, error: "×’×•×£ ×”×‘×§×©×” ××™× ×• JSON ×ª×§×™×Ÿ" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "×©×’×™××” ×‘×¢×“×›×•×Ÿ ×”×©××œ×•×Ÿ" }, { status: 500 });
   }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * GET - ×××—×–×¨ ×”××œ×¦×•×ª.
 * ×œ×•×’×™×§×” ×–×• ××©××©×ª ×œ×©× ×™ ×ª×¨×—×™×©×™×:
 * 1. ×× × ×©×œ×— 'userId' ×‘×¤×¨××˜×¨×™×: ××—×–×¨ ×”××œ×¦×•×ª *×××•×©×¨×•×ª* ×¢×‘×•×¨ ×¤×¨×•×¤×™×œ ×¦×™×‘×•×¨×™.
 * 2. ×× ×œ× × ×©×œ×— 'userId': ××—×–×¨ ××ª *×›×œ* ×”×”××œ×¦×•×ª ×¢×‘×•×¨ ×”××©×ª××© ×”××—×•×‘×¨, ×›×“×™ ×©×™×•×›×œ ×œ× ×”×œ ××•×ª×Ÿ.
 */
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');

  try {
    // ×ª×¨×—×™×© 1: ×‘×§×©×” ×œ×”×¦×’×ª ×”××œ×¦×•×ª ×‘×¤×¨×•×¤×™×œ ×©×œ ××©×ª××© ×¡×¤×¦×™×¤×™ (×œ×¦×¤×™×™×” ×¦×™×‘×•×¨×™×ª)
    if (userId) {
      const testimonials = await prisma.friendTestimonial.findMany({
        where: {
          profile: {
            userId: userId,
          },
          // ×—×©×•×‘: ×”×—×–×¨ ×¨×§ ×”××œ×¦×•×ª ×©××•×©×¨×• ×œ×¦×¤×™×™×” ×¦×™×‘×•×¨×™×ª
          status: 'APPROVED',
        },
        orderBy: {
          createdAt: 'desc',
        },
      });
      return NextResponse.json({ success: true, testimonials });
    }

    // ×ª×¨×—×™×© 2: ×‘×§×©×” ×œ× ×™×”×•×œ ×”××œ×¦×•×ª ×©×œ ×”××©×ª××© ×”××—×•×‘×¨ (×‘×ª×•×š ×¢××•×“ ×”×¤×¨×•×¤×™×œ ×”××™×©×™)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const testimonials = await prisma.friendTestimonial.findMany({
      where: {
        profile: {
          userId: session.user.id,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, testimonials });
  } catch (error) {
    console.error('Error in GET /api/profile/testimonials:', error);
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}

/**
 * POST - ×™×•×¦×¨ ×”××œ×¦×” ×—×“×©×” ×‘×××¦×¢×•×ª ×˜×•×§×Ÿ ×—×“-×¤×¢××™ ×•×××•×‘×˜×—.
 * × ×§×•×“×ª ×§×¦×” ×–×• ××©××©×ª ××ª ×”×˜×•×¤×¡ ×”×¦×™×‘×•×¨×™ ×©×—×‘×¨×™× ×××œ××™×.
 * ×”×™× ××‘×˜×™×—×” ×©×›×œ ×§×™×©×•×¨ ×™×©××© ×¤×¢× ××—×ª ×‘×œ×‘×“.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      token,
      authorName,
      relationship,
      content,
      authorPhone,
      isPhoneVisibleToMatch,
    } = body;

    // 1. ×•×œ×™×“×¦×™×” ×‘×¡×™×¡×™×ª ×©×œ ×©×“×•×ª ×”×—×•×‘×”
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields.' },
        { status: 400 }
      );
    }

    // 2. ×©×™××•×© ×‘×˜×¨× ×–×§×¦×™×” ×›×“×™ ×œ×”×‘×˜×™×— ××˜×•××™×•×ª.
    // ×©×ª×™ ×”×¤×¢×•×œ×•×ª (×™×¦×™×¨×ª ×”××œ×¦×” ×•×¢×“×›×•×Ÿ ×”×˜×•×§×Ÿ) ×—×™×™×‘×•×ª ×œ×”×¦×œ×™×— ×™×—×“.
    const result = await prisma.$transaction(async (tx) => {
      // ×©×œ×‘ ×': ×—×¤×© ××ª ×‘×§×©×ª ×”×˜×•×§×Ÿ. ×”×™× ×—×™×™×‘×ª ×œ×”×™×•×ª ×§×™×™××ª, ×‘×ª×•×§×£ ×•×‘×¡×˜×˜×•×¡ PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() }, // ×•×“× ×©×”×˜×•×§×Ÿ ×œ× ×¤×’ ×ª×•×§×£
        },
      });

      // ×× ×œ× × ××¦××” ×‘×§×©×” ×ª×§×™× ×”, ×–×¨×•×§ ×©×’×™××”. ×–×” ×™×‘×˜×œ ××ª ×”×˜×¨× ×–×§×¦×™×” ××•×˜×•××˜×™×ª.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // ×©×œ×‘ ×‘': ×¦×•×¨ ××ª ×¨×©×•××ª ×”×”××œ×¦×” ×‘××¡×“ ×”× ×ª×•× ×™×.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // ×”××œ×¦×” ×—×“×©×” ×ª××™×“ ×××ª×™× ×” ×œ××™×©×•×¨ ×”××©×ª××©
          submittedBy: 'FRIEND', // ×¡××Ÿ ×©×”×”××œ×¦×” ×”×’×™×¢×” ××—×‘×¨
        },
      });

      // ×©×œ×‘ ×’': ×§×¨×™×˜×™! ×©× ×” ××ª ×¡×˜×˜×•×¡ ×”×˜×•×§×Ÿ ×œ-COMPLETED ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×—×•×–×¨.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    // 3. ×× ×”×˜×¨× ×–×§×¦×™×” ×”×¦×œ×™×—×”, ×”×—×–×¨ ×ª×©×•×‘×ª ×”×¦×œ×—×”.
    if (result.success) {
      return NextResponse.json({
        success: true,
        message: 'Thank you! Your testimonial has been submitted.',
      });
    } else {
      // ××¦×‘ ×–×” ×œ× ×××•×¨ ×œ×§×¨×•×ª ×× ×œ×•×’×™×§×ª ×”×˜×¨× ×–×§×¦×™×” × ×›×•× ×”
      throw new Error('Transaction failed unexpectedly.');
    }
  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);

    // 4. ×˜×™×¤×•×œ ×™×™×¢×•×“×™ ×‘×©×’×™××•×ª ×™×“×•×¢×•×ª
    if (
      error instanceof Error &&
      error.message.includes('Invalid, expired, or already used link')
    ) {
      return NextResponse.json(
        {
          success: false,
          message:
            'This link is invalid, has expired, or has already been used.',
        },
        { status: 400 }
      );
    }

    // 5. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª ××—×¨×•×ª
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
# Generated on: 2025-09-18 22:40:39
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

// GET all testimonials for the logged-in user
export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const testimonials = await prisma.friendTestimonial.findMany({
    where: { profileId: session.user.profile.id },
    orderBy: { createdAt: 'desc' },
  });

  return NextResponse.json({ success: true, testimonials });
}

// POST a new manual testimonial
export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }
  
  const body = await req.json();
  const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

  if (!authorName || !relationship || !content) {
    return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
  }

  const newTestimonial = await prisma.friendTestimonial.create({
    data: {
      profileId: session.user.profile.id,
      authorName,
      relationship,
      content,
      authorPhone: authorPhone || null,
      isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
      status: 'APPROVED', // Manual entries are pre-approved by the user
      submittedBy: 'USER',
    },
  });

  return NextResponse.json({ success: true, testimonial: newTestimonial }, { status: 201 });
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id, // Ensure ownership
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/testimonials/[token]/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { jwtVerify, JWTPayload } from 'jose'; // ×™×™×‘×•× JWTPayload ×¢×•×–×¨ ×œ×‘×”×™×¨×•×ª

interface TokenPayload extends JWTPayload {
  profileId: string;
}

export async function POST(req: Request, { params }: { params: { token: string } }) {
  const { token } = params;
  if (!token) {
    return NextResponse.json({ success: false, message: 'Token is missing' }, { status: 400 });
  }

  const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
  if (!secret) {
      console.error("FATAL: NEXTAUTH_SECRET is not defined.");
      return NextResponse.json({ success: false, message: 'Server configuration error' }, { status: 500 });
  }

  try {
    // --- ×©×™× ×•×™ 1: ×¤×™×¨×•×§ ×”××™××•×ª ×•×”×”×’×“×¨×” (Casting) ×œ×©× ×™ ×©×œ×‘×™× ---
    // ×©×œ×‘ ×': ××™××•×ª ×”×˜×•×§×Ÿ ×œ×œ× ×’× ×¨×™×§×”
    const verificationResult = await jwtVerify(token, secret);
    
    // ×©×œ×‘ ×‘': ×”×’×“×¨×ª ×”-payload ×œ×˜×™×¤×•×¡ ×”××“×•×™×§ ×©×œ× ×•. ×–×” ×¤×•×ª×¨ ××ª ×©×ª×™ ×”×©×’×™××•×ª.
    const payload = verificationResult.payload as TokenPayload;
    const { profileId } = payload;
    // --- ×¡×•×£ ×”×©×™× ×•×™ ---
    
    const body = await req.json();
    const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    if (!authorName || !relationship || !content) {
      return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
    }

    await prisma.friendTestimonial.create({
      data: {
        profileId, // ×¢×›×©×™×• TypeScript ×™×•×“×¢ ×©×–×” string
        authorName,
        relationship,
        content,
        authorPhone: authorPhone || null,
        isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
        status: 'PENDING',
        submittedBy: 'FRIEND',
      },
    });

    return NextResponse.json({ success: true, message: 'Testimonial submitted successfully' });

  } catch (error) {
    console.error("Error processing testimonial submission:", error);
    if (error instanceof Error && (error.name === 'JWTExpired' || error.name === 'JWSInvalid' || error.name === 'JOSEError')) {
        return NextResponse.json({ success: false, message: 'Link is invalid or has expired.' }, { status: 401 });
    }
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { SignJWT } from 'jose';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.profile?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized or profile not found' }, { status: 401 });
    }

    const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
    if (!secret) throw new Error("NEXTAUTH_SECRET is not defined.");

    const payload = {
      profileId: session.user.profile.id,
      userId: session.user.id, // Include userId for verification if needed
    };

    const token = await new SignJWT(payload)
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime('7d') // ×”×§×™×©×•×¨ ×™×”×™×” ×ª×§×£ ×œ×©×‘×•×¢
      .sign(secret);

    const link = `${process.env.NEXT_PUBLIC_BASE_URL}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });

  } catch (error) {
    console.error("Error creating testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for testimonials_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts

import { NextResponse, NextRequest } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

export async function PUT(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id,
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

export async function DELETE(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id,
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { randomBytes } from 'crypto';

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Find the user's profile to link the request to
    const userProfile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found' }, { status: 404 });
    }

    // 1. Generate a secure, random token
    const token = randomBytes(32).toString('hex');

    // 2. Set an expiration date (e.g., 7 days from now)
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    // 3. Create the request record in the new database table
    await prisma.testimonialRequest.create({
      data: {
        token: token,
        expiresAt: expiresAt,
        profileId: userProfile.id, // Use the fetched profile ID
      },
    });

    // 4. Construct the full link to return to the client
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    const link = `${baseUrl}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });
  } catch (error) {
    console.error("Failed to create testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal server error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/update/route.ts (××ª×•×§×Ÿ)

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  ReligiousJourney,
  Profile, // Import Prisma's Profile type
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";

// ... (×©××¨ ×”×¤×•× ×§×¦×™×•×ª × ×©××¨×•×ª ×–×”×•×ª) ...
// Helper to convert to number or null
const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

// Helper to convert to Date or error if invalid for required fields
const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

// Helper to convert to Date or null for optional fields
const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

// Helper to convert empty string or null to null, otherwise return the string
const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};


export async function PUT(req: NextRequest) {
  // Apply rate limiting: 50 profile updates per user per 10 minutes (prevents DB heavy load)
  const rateLimitResponse = await applyRateLimit(req, { requests: 50, window: '10 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    let body;
    try {
      body = await req.json();
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      religiousJourney,
      about,
      profileHeadline,
      inspiringCoupleStory,
      influentialRabbi,
      isAboutVisible,
      isFriendsSectionVisible,
      isNeshamaTechSummaryVisible,
      parentStatus,
      fatherOccupation,
      motherOccupation,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious,
      profileCharacterTraits,
      profileHobbies,
      aliyaCountry,
      aliyaYear,
      // --- START: PREFERENCE FIELDS ---
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      preferredPartnerHasChildren,
      preferredCharacterTraits,
      preferredHobbies,
      preferredAliyaStatus,
      preferredReligiousJourneys,
      // --- END: PREFERENCE FIELDS ---
      hasViewedProfilePreview,
      hasMedicalInfo,
      medicalInfoDetails,
      medicalInfoDisclosureTiming,
      isMedicalInfoVisible,
        cvUrl,
      cvSummary,
    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status & Background (User's own) ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious;
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
    if (fatherOccupation !== undefined) dataToUpdate.fatherOccupation = emptyStringToNull(fatherOccupation);
    if (motherOccupation !== undefined) dataToUpdate.motherOccupation = emptyStringToNull(motherOccupation);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education, Occupation & Service (User's own) ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion & Lifestyle (User's own) ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
    if (religiousJourney !== undefined) dataToUpdate.religiousJourney = emptyStringToNull(religiousJourney) as ReligiousJourney | null;
    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        // â—€ï¸ FIX: Changed body.hasOwnProperty('kippahType') to the safe version
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (Object.prototype.hasOwnProperty.call(body, 'kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        // â—€ï¸ FIX: Changed body.hasOwnProperty('headCovering') to the safe version
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (Object.prototype.hasOwnProperty.call(body, 'headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits & Hobbies (User's own) ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || [];

    // --- About & Additional Info ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
    if (profileHeadline !== undefined) dataToUpdate.profileHeadline = emptyStringToNull(profileHeadline);
    if (inspiringCoupleStory !== undefined) dataToUpdate.inspiringCoupleStory = emptyStringToNull(inspiringCoupleStory);
    if (influentialRabbi !== undefined) dataToUpdate.influentialRabbi = emptyStringToNull(influentialRabbi);
    
    // --- Preferences (related to matching partner) ---
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    if (preferredReligiousJourneys !== undefined) dataToUpdate.preferredReligiousJourneys = preferredReligiousJourneys || [];
    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah);
    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredPartnerHasChildren !== undefined) dataToUpdate.preferredPartnerHasChildren = emptyStringToNull(preferredPartnerHasChildren);
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);
    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || [];
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || [];
    
    // --- Profile Management & Visibility ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
    if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
    if (isAboutVisible !== undefined) dataToUpdate.isAboutVisible = isAboutVisible;
    if (isFriendsSectionVisible !== undefined) dataToUpdate.isFriendsSectionVisible = isFriendsSectionVisible;
    if (isNeshamaTechSummaryVisible !== undefined) dataToUpdate.isNeshamaTechSummaryVisible = isNeshamaTechSummaryVisible;
   
    // --- Medical Info ---
    if (hasMedicalInfo !== undefined) dataToUpdate.hasMedicalInfo = hasMedicalInfo;
    if (medicalInfoDetails !== undefined) dataToUpdate.medicalInfoDetails = emptyStringToNull(medicalInfoDetails);
    if (medicalInfoDisclosureTiming !== undefined) dataToUpdate.medicalInfoDisclosureTiming = emptyStringToNull(medicalInfoDisclosureTiming);
    if (isMedicalInfoVisible !== undefined) dataToUpdate.isMedicalInfoVisible = isMedicalInfoVisible;
  if (cvUrl !== undefined) dataToUpdate.cvUrl = emptyStringToNull(cvUrl);
    if (cvSummary !== undefined) dataToUpdate.cvSummary = emptyStringToNull(cvSummary);
    // --- Availability ---
    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      // â—€ï¸ FIX: Changed body.hasOwnProperty to the safe version
      if (!Object.prototype.hasOwnProperty.call(body, 'availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    // â—€ï¸ FIX: Changed body.hasOwnProperty to the safe version
    if (Object.prototype.hasOwnProperty.call(body, 'availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // ... (×©××¨ ×”×§×•×‘×¥ × ×©××¨ ×–×”×”) ...
    // --- Perform the database update ---
    let updatedProfileRecord: Profile | null = null;
    if (Object.keys(dataToUpdate).length > 0) {
      try {
         dataToUpdate.needsAiProfileUpdate = true;
         
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
    
      } catch (dbError) {
        console.error('Prisma profile update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // Construct the response, ensuring all UserProfile fields are mapped
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, 
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney || undefined,
      about: dbProfile.about || "",
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: refreshedUserWithProfile.isProfileComplete,
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, 
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], 
      profileHobbies: dbProfile.profileHobbies || [],                 
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredLocations: dbProfile.preferredLocations || [],
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], 
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredPartnerHasChildren: dbProfile.preferredPartnerHasChildren || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], 
      preferredHobbies: dbProfile.preferredHobbies || [],                 
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, 
      cvUrl: dbProfile.cvUrl,
      cvSummary: dbProfile.cvSummary,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('Profile update route error:', error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for profile_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/profile/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UserProfile } from "@/types/next-auth";

// ×”×’×“×¨×” ×–×• ××‘×˜×™×—×” ×©×”-Route Handler ×™×¨×•×¥ ×ª××™×“ ××—×“×© ×•×œ× ×™×©××¨ ×‘-Cache.
export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const requestedUserId = searchParams.get('userId');

    const session = await getServerSession(authOptions);
    
    // ×•×“× ×©×”××©×ª××© ××—×•×‘×¨. × ×“×¨×© ×¡×©×Ÿ ×›×“×™ ×œ×’×©×ª ×œ×›×œ ×¤×¨×•×¤×™×œ.
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×§×‘×¢ ×¢×‘×•×¨ ××™×–×” ××©×ª××© × ×©×œ×¤×™× ×”× ×ª×•× ×™×:
    // ×× ×¦×•×™×Ÿ ID ×‘×‘×§×©×”, ×”×©×ª××© ×‘×•. ××—×¨×ª, ×”×©×ª××© ×‘-ID ×©×œ ×”××©×ª××© ×”××—×•×‘×¨.
    const targetUserId = requestedUserId || session.user.id;

    // ×©×œ×•×£ ××ª ×”××©×ª××© ×™×—×“ ×¢× ×›×œ ×”××™×“×¢ ×”××§×•×©×¨ ×©×œ×• (×¤×¨×•×¤×™×œ, ×ª××•× ×•×ª, ×•×”××œ×¦×•×ª)
    const userWithProfile = await prisma.user.findUnique({
      where: { id: targetUserId },
      include: {
        profile: {
          include: {
            testimonials: {
              orderBy: {
                createdAt: 'desc',
              }
            }
          }
        },
        images: {
            orderBy: {
                isMain: 'desc' // ×•×“× ×©×”×ª××•× ×” ×”×¨××©×™×ª ×ª××™×“ ×¨××©×•× ×”
            }
        },
      }
    });

    if (!userWithProfile) {
      return NextResponse.json(
        { success: false, message: 'User not found' },
        { status: 404 }
      );
    }

    const dbProfile = userWithProfile.profile;

    if (!dbProfile) {
        console.error(`Profile data not found for user ID: ${targetUserId}`);
        return NextResponse.json(
            { success: false, message: 'Profile data not found for user.' },
            { status: 404 }
        );
    }

    if (!dbProfile.birthDate) {
        console.error(`birthDate is null or undefined for profile ID: ${dbProfile.id}`);
        return NextResponse.json(
            { success: false, message: 'Data integrity issue: birthDate is missing for the profile.' },
            { status: 500 }
        );
    }

    // ×‘× ×” ××ª ××•×‘×™×™×§×˜ ×”×ª×’×•×‘×” ×”××œ× ×©×™×©×œ×— ×—×–×¨×” ×œ×œ×§×•×—
    const profileResponseData: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender,
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      educationLevel: dbProfile.educationLevel || undefined,
      education: dbProfile.education || "",
      occupation: dbProfile.occupation || "",
      serviceType: dbProfile.serviceType,
      serviceDetails: dbProfile.serviceDetails || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney,
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      headCovering: dbProfile.headCovering,
      kippahType: dbProfile.kippahType,
      profileCharacterTraits: dbProfile.profileCharacterTraits || [],
      profileHobbies: dbProfile.profileHobbies || [],
      
      // ×©×“×•×ª ×”×¡×™×¤×•×¨ ×•×”×ª×•×›×Ÿ ×”××™×©×™
      about: dbProfile.about || "",
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      
      // ×“×‘×¨ ×”××¢×¨×›×ª ×•×”××œ×¦×•×ª
      manualEntryText: dbProfile.manualEntryText || undefined,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      testimonials: dbProfile.testimonials || [],
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,

      // ×”×¢×“×¤×•×ª ×©×™×“×•×š
      matchingNotes: dbProfile.matchingNotes || "",
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredLocations: dbProfile.preferredLocations || [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: dbProfile.preferredServiceTypes || [],
      preferredHeadCoverings: dbProfile.preferredHeadCoverings || [],
      preferredKippahTypes: dbProfile.preferredKippahTypes || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [],
      preferredHobbies: dbProfile.preferredHobbies || [],
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],

      // ×”×’×“×¨×•×ª ×•×”×¢×“×¤×•×ª ××§×¦×•×¢×™×•×ª
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender,

      // ×¡×˜×˜×•×¡ ×•××™×“×¢ ××¢×¨×›×ª×™
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: userWithProfile.isProfileComplete,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      verifiedBy: dbProfile.verifiedBy || undefined,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      
      // ××™×“×¢ ×¨×¤×•××™ (×—×¡×•×™)
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
   medicalInfoDetails: dbProfile.isMedicalInfoVisible 
        ? dbProfile.medicalInfoDetails ?? undefined 
        : undefined,      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
       cvUrl: dbProfile.cvUrl,
      cvSummary: dbProfile.cvSummary,
            aiProfileSummary: dbProfile.aiProfileSummary,

      // ××™×“×¢ ×‘×¡×™×¡×™ ×¢×œ ×”××©×ª××©
      user: {
        id: userWithProfile.id,
        firstName: userWithProfile.firstName,
        lastName: userWithProfile.lastName,
        email: userWithProfile.email,
      }
    };
    
    // ×”×—×–×¨×ª ×ª×©×•×‘×” ××•×¦×œ×—×ª ×¢× ×›×œ ×”× ×ª×•× ×™×
    return NextResponse.json({
      success: true,
      profile: profileResponseData,
      images: userWithProfile.images || []
    });

  } catch (error) {
    console.error('Profile fetch error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred while fetching profile.';
    return NextResponse.json(
      { success: false, message: 'Internal server error', details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\availability\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/availability/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import type { UpdateAvailabilityRequest } from "@/types/profile";

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const data = await req.json() as UpdateAvailabilityRequest;

    const updatedProfile = await prisma.profile.update({
      where: { userId: session.user.id },
      data: {
        availabilityStatus: data.availabilityStatus,
        availabilityNote: data.availabilityNote || null,
        updatedAt: new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          }
        }
      }
    });
await prisma.user.update({
  where: { id: session.user.id },
  data: { updatedAt: new Date() }
});

    return NextResponse.json({
      success: true,
      profile: updatedProfile
    });

  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update status" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\cv
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\cv\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/cv/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
import aiService from '@/lib/services/aiService';
import profileAiService from '@/lib/services/profileAiService';
import mammoth from 'mammoth';

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// --- POST Handler for uploading a CV ---
export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }
  const userId = session.user.id;
  const userLocale = session.user.language || 'he';

  try {
    const formData = await req.formData();
    const file = formData.get('cv') as File | null;

    if (!file) {
      return NextResponse.json({ success: false, message: 'No file provided' }, { status: 400 });
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    // 1. Upload file to Cloudinary
    const uploadResult = await new Promise<any>((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
            {
                resource_type: 'raw',
                folder: `users/${userId}/cvs`,
                public_id: file.name, 
                overwrite: true, 
            },
            (error, result) => {
                if (error) reject(error);
                resolve(result);
            }
        );
        uploadStream.end(buffer);
    });
    
    if (!uploadResult?.secure_url) {
        throw new Error('Cloudinary upload failed');
    }

    // --- AI DEEP ANALYSIS ---
    let cvSummaryMarkdown: string | null = null;
    try {
        console.log(`[CV Route] Extracting text from CV for user ${userId}. File type: ${file.type}`);
        
        let extractedCvText: string | null = null;

        // Check if file is Word (.docx) - PDF temporarily disabled
        if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
            console.log("[CV Route] Parsing DOCX file.");
            const { value } = await mammoth.extractRawText({ buffer });
            extractedCvText = value;
        } else if (file.type === 'application/pdf') {
            console.log("[CV Route] PDF parsing temporarily disabled. Please upload DOCX for AI analysis.");
            // TODO: Implement PDF parsing with alternative library
        } else {
            console.warn(`[CV Route] Unsupported file type for text extraction: ${file.type}`);
        }

        if (extractedCvText && extractedCvText.trim().length > 50) {
            console.log(`[CV Route] Sending CV text to AI for deep analysis in locale: ${userLocale}.`);
            const analysisResult = await aiService.analyzeCvInDepth(extractedCvText, userLocale);
            
            if (analysisResult) {
                const parts = [
                    `### ×¡×™×›×•× ×× ×”×œ×™×\n${analysisResult.executiveSummary}`,
                    `### ×ª×•×‘× ×•×ª ××™×©×™×•×ª×™×•×ª\n- ${analysisResult.personalityInsights.join('\n- ')}`,
                    `### ×ª×•×‘× ×•×ª ×¢×¨×›×™×•×ª\n- ${analysisResult.valuesInsights.join('\n- ')}`,
                    `### ××¡×œ×•×œ ×§×¨×™×™×¨×”\n**× ×¨×˜×™×‘:** ${analysisResult.careerTrajectory.narrative}\n\n**××‘× ×™ ×“×¨×š:**\n` +
                    analysisResult.careerTrajectory.milestones.map(m => `  - **${m.title} (${m.period}):** ${m.keyLearnings}`).join('\n'),
                ];
                if (analysisResult.redFlags.length > 0) {
                    parts.push(`### × ×§×•×“×•×ª ×œ×‘×™×¨×•×¨ (×©×“×›×Ÿ)\n- ${analysisResult.redFlags.join('\n- ')}`);
                }
                cvSummaryMarkdown = parts.join('\n\n');
                console.log(`[CV Route] AI deep analysis generated successfully for user ${userId}.`);
            }
        }
    } catch (aiError) {
        console.error(`[CV Route] AI processing failed for user ${userId}:`, aiError);
    }

    // 3. Update database
    const updatedProfile = await prisma.profile.update({
      where: { userId },
      data: {
        cvUrl: uploadResult.secure_url,
        cvSummary: cvSummaryMarkdown,
        needsAiProfileUpdate: true,
      },
    });

    // 4. Trigger background update
    profileAiService.updateUserAiProfile(userId).catch(err => {
        console.error(`[CV Route] Background AI profile vector update failed for user ${userId}:`, err);
    });

    return NextResponse.json({ success: true, profile: updatedProfile });

  } catch (error) {
    console.error('CV Upload API Error:', error);
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}

// --- DELETE Handler for deleting a CV ---
export async function DELETE(req: Request) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;
  
    try {
        const profile = await prisma.profile.findUnique({
            where: { userId },
            select: { cvUrl: true },
        });

        if (profile?.cvUrl) {
            try {
                const urlParts = profile.cvUrl.split('/');
                const fileNameWithExt = urlParts[urlParts.length - 1];
                if (fileNameWithExt) {
                    const publicId = `users/${userId}/cvs/${decodeURIComponent(fileNameWithExt)}`;
                    console.log(`[CV Delete] Attempting to delete from Cloudinary with public_id: ${publicId}`);
                    await cloudinary.uploader.destroy(publicId, { resource_type: 'raw' });
                }
            } catch(e) {
                console.error(`[CV Delete] Could not parse public_id from URL: ${profile.cvUrl}`, e);
            }
        }

        const updatedProfile = await prisma.profile.update({
            where: { userId },
            data: {
                cvUrl: null,
                cvSummary: null,
                needsAiProfileUpdate: true,
            },
        });

        profileAiService.updateUserAiProfile(userId).catch(err => {
            console.error(`[CV Delete] Background AI profile vector update failed for user ${userId}:`, err);
        });

        return NextResponse.json({ success: true, profile: updatedProfile });
    } catch (error) {
        console.error('CV Delete API Error:', error);
        return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
    }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\images_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
# Generated on: 2025-12-22 16:55:45
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\images_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';
export const dynamic = 'force-dynamic';
// Configure Cloudinary
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// ×¤×•× ×§×¦×™×” ×¢×•×˜×¤×ª ×œ-Upload ×¢× Promise × ×›×•×Ÿ
function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: 'profile-images',
        resource_type: 'image',
      },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({
            secure_url: result.secure_url,
            public_id: result.public_id,
          });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// GET - Fetch all images for a user
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: {
        user: {
          email: session.user.email,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error('[GetImages] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch images' },
      { status: 500 }
    );
  }
}

// POST - Upload new images (can be adapted for multiple files)
export async function POST(req: NextRequest) {
  // Apply rate limiting: 20 image uploads per user per hour (prevents resource abuse)
const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  const startTime = Date.now();

  try {
    console.log('[Upload] Starting upload process');

    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error('[Upload] Authentication failed - No user session');
      return NextResponse.json(
        {
          success: false,
          error: 'Unauthorized',
        },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      select: { id: true, email: true, _count: { select: { images: true } } },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.error('[Upload] No file provided in request');
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    if (user._count.images >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { success: false, error: 'Maximum number of images reached' },
        { status: 400 }
      );
    }

    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid file type. Only JPG, PNG and WEBP are allowed',
        },
        { status: 400 }
      );
    }

    if (file.size > 5 * 1024 * 1024) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { success: false, error: 'File size must be less than 5MB' },
        { status: 400 }
      );
    }

    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    console.log(`[Upload] File processed, uploading to Cloudinary...`);

    const cloudinaryResult = await uploadToCloudinary(buffer);

    const isFirstImage = user._count.images === 0;

    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });
await prisma.user.update({
  where: { id: session.user.id },
  data: { updatedAt: new Date() }
});

    console.log(
      `[Upload] Database save completed in ${Date.now() - startTime}ms`
    );
    return NextResponse.json({
      success: true,
      image,
      timing: `${Date.now() - startTime}ms`,
    });
  } catch (error) {
    console.error('[Upload] General error:', error);
    console.log(`[Upload] Failed after ${Date.now() - startTime}ms`);
    return NextResponse.json(
      { success: false, error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// --- NEW ---
// DELETE - Bulk delete images
export async function DELETE(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const { imageIds } = await req.json();

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Image IDs must be a non-empty array' },
        { status: 400 }
      );
    }

    // 1. Find images to verify ownership and get necessary data
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: userId, // CRUCIAL: Ensures user only deletes their own images
      },
      select: {
        id: true,
        cloudinaryPublicId: true,
        isMain: true,
      },
    });

    if (imagesToDelete.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No matching images found to delete.' },
        { status: 404 }
      );
    }

    // 2. Check if the main image is being deleted
    const wasMainImageDeleted = imagesToDelete.some((image) => image.isMain);

    // 3. Delete from Cloudinary
    const cloudinaryIdsToDelete = imagesToDelete
      .map((image) => image.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (cloudinaryIdsToDelete.length > 0) {
      const cloudinaryDeletions = cloudinaryIdsToDelete.map((publicId) =>
        cloudinary.uploader.destroy(publicId).catch((err) => {
          console.error(
            `[Bulk Delete] Failed to delete image ${publicId} from Cloudinary:`,
            err
          );
        })
      );
      await Promise.all(cloudinaryDeletions);
    }

    // 4. Delete from database
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) }, // Use validated IDs
        userId: userId,
      },
    });

    // 5. If main image was deleted, assign a new one if possible
    if (wasMainImageDeleted) {
      const newMainImage = await prisma.userImage.findFirst({
        where: { userId: userId },
        orderBy: { createdAt: 'desc' },
      });

      if (newMainImage) {
        await prisma.userImage.update({
          where: { id: newMainImage.id },
          data: { isMain: true },
        });
      }
    }

    // 6. Fetch the updated list of images to return to the client
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, images: updatedImages });
  } catch (error) {
    console.error('[Bulk Delete Images] Error:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete images',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/[imageId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { imageId } = params;
    
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId },
    });

    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { imageId } = params;

    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for images_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimitWithRoleCheck } from '@/lib/rate-limiter';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { v2 as cloudinary } from 'cloudinary';

export const dynamic = 'force-dynamic';

// 1. ×§×•× ×¤×™×’×•×¨×¦×™×” ×©×œ Cloudinary
if (
  !process.env.CLOUDINARY_CLOUD_NAME ||
  !process.env.CLOUDINARY_API_KEY ||
  !process.env.CLOUDINARY_API_SECRET
) {
  throw new Error('Missing required Cloudinary environment variables');
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true,
});

// 2. ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×”×¢×œ××” (×¢×•×˜×¤×ª ××ª ×”-Stream ×‘-Promise)
function uploadToCloudinary(
  buffer: Buffer
): Promise<{ secure_url: string; public_id: string }> {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: 'profile-images',
        resource_type: 'image',
        // × ×™×ª×Ÿ ×œ×”×•×¡×™×£ ×›××Ÿ ×˜×¨× ×¡×¤×•×¨××¦×™×•×ª ×‘×¡×™×¡×™×•×ª ×× ×¨×•×¦×™×, ××‘×œ ×¢×“×™×£ ×œ×‘×¦×¢ ××•×ª×Ÿ ×‘×¢×ª ×”×ª×¦×•×’×”
      },
      (error, result) => {
        if (error) {
          console.error('[Cloudinary] Upload error:', error);
          reject(error);
        } else if (result) {
          resolve({
            secure_url: result.secure_url,
            public_id: result.public_id,
          });
        } else {
          reject(new Error('Upload failed - no result'));
        }
      }
    );
    uploadStream.end(buffer);
  });
}

// 3. GET - ×©×œ×™×¤×ª ×›×œ ×”×ª××•× ×•×ª ×©×œ ×”××©×ª××©
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userImages = await prisma.userImage.findMany({
      where: {
        user: {
          email: session.user.email,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, images: userImages });
  } catch (error) {
    console.error('[GetImages] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch images' },
      { status: 500 }
    );
  }
}

// 4. POST - ×”×¢×œ××ª ×ª××•× ×” ×—×“×©×”
export async function POST(req: NextRequest) {
  // ×”×’×‘×œ×ª ×§×¦×‘ ×‘×§×©×•×ª: 15 ×‘×§×©×•×ª ×œ×©×¢×” ×œ××©×ª××© (××•× ×¢ ×”×¦×¤×”)
  const rateLimitResponse = await applyRateLimitWithRoleCheck(req, { requests: 15, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  
  const startTime = Date.now();

  try {
    console.log('[Upload] Starting upload process');

    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      console.error('[Upload] Authentication failed - No user session');
      return NextResponse.json(
        {
          success: false,
          error: 'Unauthorized',
        },
        { status: 401 }
      );
    }

    // ×©×œ×™×¤×ª ×”××©×ª××© ×•×‘×“×™×§×ª ×›××•×ª ×”×ª××•× ×•×ª ×”×§×™×™××ª
    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      select: { id: true, email: true, _count: { select: { images: true } } },
    });

    if (!user) {
      console.error(`[Upload] User not found for email: ${session.user.email}`);
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 404 }
      );
    }

    // ×¢×™×‘×•×“ ×”×˜×•×¤×¡ (FormData)
    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      console.error('[Upload] No file provided in request');
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    // ×‘×“×™×§×ª ××’×‘×œ×ª ×›××•×ª ×ª××•× ×•×ª (5)
    if (user._count.images >= 5) {
      console.warn(`[Upload] User ${user.id} has reached maximum images limit`);
      return NextResponse.json(
        { success: false, error: 'Maximum number of images reached' },
        { status: 400 }
      );
    }

    // ×‘×“×™×§×ª ×¡×•×’ ×§×•×‘×¥
    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      console.error(`[Upload] Invalid file type: ${file.type}`);
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid file type. Only JPG, PNG and WEBP are allowed',
        },
        { status: 400 }
      );
    }

    // === ×›××Ÿ ×”×©×™× ×•×™ ×”×—×©×•×‘: ××’×‘×œ×” ×©×œ 10MB ===
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    if (file.size > MAX_FILE_SIZE) {
      console.error(`[Upload] File too large: ${file.size} bytes`);
      return NextResponse.json(
        { success: false, error: 'File size must be less than 10MB' },
        { status: 400 }
      );
    }

    // ×”××¨×ª ×”×§×•×‘×¥ ×œ-Buffer ×œ×¦×•×¨×š ×”×¢×œ××”
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    console.log(`[Upload] File processed (${file.size} bytes), uploading to Cloudinary...`);

    // ×©×œ×™×—×” ×œ-Cloudinary
    const cloudinaryResult = await uploadToCloudinary(buffer);

    // ×× ×–×• ×”×ª××•× ×” ×”×¨××©×•× ×”, × ×’×“×™×¨ ××•×ª×” ×›×¨××©×™×ª
    const isFirstImage = user._count.images === 0;

    // ×©××™×¨×” ×‘-DB
    const image = await prisma.userImage.create({
      data: {
        userId: user.id,
        url: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        isMain: isFirstImage,
      },
    });

    // ×¢×“×›×•×Ÿ ×–××Ÿ ×”×©×™× ×•×™ ×”××—×¨×•×Ÿ ×©×œ ×”××©×ª××©
    await prisma.user.update({
      where: { id: session.user.id },
      data: { updatedAt: new Date() }
    });

    console.log(
      `[Upload] Database save completed in ${Date.now() - startTime}ms`
    );
    
    return NextResponse.json({
      success: true,
      image,
      timing: `${Date.now() - startTime}ms`,
    });

  } catch (error) {
    console.error('[Upload] General error:', error);
    console.log(`[Upload] Failed after ${Date.now() - startTime}ms`);
    return NextResponse.json(
      { success: false, error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// 5. DELETE - ××—×™×§×ª ×ª××•× ×•×ª ××¨×•×‘×•×ª
export async function DELETE(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const { imageIds } = await req.json();

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Image IDs must be a non-empty array' },
        { status: 400 }
      );
    }

    // 1. ×‘×“×™×§×ª ×‘×¢×œ×•×ª ×¢×œ ×”×ª××•× ×•×ª ×•×§×‘×œ×ª ×”××™×“×¢ ×¢×œ×™×”×Ÿ
    const imagesToDelete = await prisma.userImage.findMany({
      where: {
        id: { in: imageIds },
        userId: userId, // ×§×¨×™×˜×™: ××•×•×“× ×©×”××©×ª××© ××•×—×§ ×¨×§ ××ª ×”×ª××•× ×•×ª ×©×œ×•
      },
      select: {
        id: true,
        cloudinaryPublicId: true,
        isMain: true,
      },
    });

    if (imagesToDelete.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No matching images found to delete.' },
        { status: 404 }
      );
    }

    // 2. ×”×× ×”×ª××•× ×” ×”×¨××©×™×ª × ××—×§×ª?
    const wasMainImageDeleted = imagesToDelete.some((image) => image.isMain);

    // 3. ××—×™×§×” ×-Cloudinary
    const cloudinaryIdsToDelete = imagesToDelete
      .map((image) => image.cloudinaryPublicId)
      .filter((id): id is string => !!id);

    if (cloudinaryIdsToDelete.length > 0) {
      const cloudinaryDeletions = cloudinaryIdsToDelete.map((publicId) =>
        cloudinary.uploader.destroy(publicId).catch((err) => {
          console.error(
            `[Bulk Delete] Failed to delete image ${publicId} from Cloudinary:`,
            err
          );
        })
      );
      await Promise.all(cloudinaryDeletions);
    }

    // 4. ××—×™×§×” ××”-DB
    await prisma.userImage.deleteMany({
      where: {
        id: { in: imagesToDelete.map((img) => img.id) },
        userId: userId,
      },
    });

    // 5. ×× ×”×ª××•× ×” ×”×¨××©×™×ª × ××—×§×”, × ×’×“×™×¨ ×—×“×©×” (×”×›×™ ×—×“×©×” ×©× ×©××¨×”)
    if (wasMainImageDeleted) {
      const newMainImage = await prisma.userImage.findFirst({
        where: { userId: userId },
        orderBy: { createdAt: 'desc' },
      });

      if (newMainImage) {
        await prisma.userImage.update({
          where: { id: newMainImage.id },
          data: { isMain: true },
        });
      }
    }

    // 6. ×”×—×–×¨×ª ×”×¨×©×™××” ×”××¢×•×“×›× ×ª ×œ×§×œ×™× ×˜
    const updatedImages = await prisma.userImage.findMany({
      where: { userId: userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, images: updatedImages });

  } catch (error) {
    console.error('[Bulk Delete Images] Error:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete images',
        details: errorMessage,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\images\[imageId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/images/[imageId]/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { v2 as cloudinary } from "cloudinary";

if (!process.env.CLOUDINARY_CLOUD_NAME || 
    !process.env.CLOUDINARY_API_KEY || 
    !process.env.CLOUDINARY_API_SECRET) {
  throw new Error("Missing required Cloudinary environment variables");
}

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function DELETE(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { imageId } = params;
    
    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    if (image.cloudinaryPublicId) {
      try {
        await cloudinary.uploader.destroy(image.cloudinaryPublicId);
      } catch (error) {
        console.error("[Delete Image] Cloudinary deletion error:", error);
      }
    }

    await prisma.userImage.delete({
      where: { id: imageId },
    });

    if (image.isMain) {
      const remainingImage = await prisma.userImage.findFirst({
        where: { userId: image.userId },
        orderBy: { createdAt: 'desc' },
      });

      if (remainingImage) {
        await prisma.userImage.update({
          where: { id: remainingImage.id },
          data: { isMain: true },
        });
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Delete Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to delete image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  props: { params: Promise<{ imageId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 401 }
      );
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const { imageId } = params;

    const image = await prisma.userImage.findUnique({
      where: { id: imageId },
      include: { user: true },
    });

    if (!image) {
      return NextResponse.json(
        { success: false, error: "Image not found" }, 
        { status: 404 }
      );
    }

    if (image.user.email !== session.user.email) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" }, 
        { status: 403 }
      );
    }

    await prisma.userImage.updateMany({
      where: { userId: image.userId },
      data: { isMain: false },
    });

    await prisma.userImage.update({
      where: { id: imageId },
      data: { isMain: true },
    });

    const updatedImages = await prisma.userImage.findMany({
      where: { userId: image.userId },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ 
      success: true, 
      images: updatedImages 
    });
  } catch (error) {
    console.error("[Set Main Image] Error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to set main image",
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\neshama-insight
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\neshama-insight\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/neshama-insight/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { generateNarrativeProfile } from '@/lib/services/profileAiService';
import { GoogleGenerativeAI } from '@google/generative-ai';
import type { Language } from '@prisma/client';

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body = await req.json();
    const { userId, locale = 'he' } = body;

    // Verify user can only generate insight for themselves
    if (userId !== session.user.id) {
      return NextResponse.json(
        { success: false, message: 'Forbidden' },
        { status: 403 }
      );
    }

    // Fetch user data
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: {
          take: 1,
          orderBy: { lastSaved: 'desc' },
        },
      },
    });

    if (!user || !user.profile) {
      return NextResponse.json(
        { success: false, message: 'Profile not found' },
        { status: 404 }
      );
    }

    // Check if insight was already generated today
    if (user.neshamaInsightLastGeneratedAt) {
      const lastGenerated = new Date(user.neshamaInsightLastGeneratedAt);
      const now = new Date();
      const diffTime = now.getTime() - lastGenerated.getTime();
      const diffHours = diffTime / (1000 * 60 * 60);

      if (diffHours < 24) {
        return NextResponse.json(
          {
            success: false,
            message:
              locale === 'he'
                ? '× ×™×ª×Ÿ ×œ×™×¦×•×¨ ×ª×•×‘× ×ª × ×©××” ×¤×¢× ××—×ª ×‘-24 ×©×¢×•×ª. × ×¡×” ×©×•×‘ ××—×¨!'
                : 'You can generate Neshama Insight once every 24 hours. Try again tomorrow!',
          },
          { status: 429 } // Too Many Requests
        );
      }
    }

    // Verify profile is 100% complete
    const isComplete = await verifyProfileCompletion(user);
    if (!isComplete) {
      return NextResponse.json(
        {
          success: false,
          message:
            locale === 'he'
              ? '×™×© ×œ×”×©×œ×™× ××ª ×”×¤×¨×•×¤×™×œ ×œ-100% ×œ×¤× ×™ ×™×¦×™×¨×ª ×”×ª×•×‘× ×”'
              : 'Profile must be 100% complete before generating insight',
        },
        { status: 400 }
      );
    }

    // Generate narrative profile
    const narrativeProfile = await generateNarrativeProfile(userId);
    if (!narrativeProfile) {
      throw new Error('Failed to generate narrative profile');
    }

    // Generate the Neshama Insight using AI
    const insight = await generateNeshmaInsight(
      narrativeProfile,
      user,
      locale as Language
    );

    // Update database to track that insight was generated
    await prisma.user.update({
      where: { id: userId },
      data: {
        neshamaInsightLastGeneratedAt: new Date(),
        neshamaInsightGeneratedCount: {
          increment: 1,
        },
        updatedAt: new Date(),
      },
    });

    return NextResponse.json({
      success: true,
      insight,
    });
  } catch (error) {
    console.error('Error generating Neshama Insight:', error);
    return NextResponse.json(
      {
        success: false,
        message: 'Internal server error',
      },
      { status: 500 }
    );
  }
}

async function verifyProfileCompletion(user: any): Promise<boolean> {
  const profile = user.profile;
  const questionnaire = user.questionnaireResponses[0];

  if (!profile || !questionnaire) return false;

  // Check basic profile fields
  const basicChecks = [
    user.images?.length >= 1,
    !!profile.profileHeadline,
    !!profile.about && profile.about.length >= 100,
    !!profile.height,
    !!profile.city,
    !!profile.maritalStatus,
    !!profile.religiousLevel,
    !!profile.educationLevel,
    !!profile.occupation,
    !!profile.matchingNotes,
  ];

  // Check questionnaire completion
  const questionnaireChecks = [
    questionnaire.valuesCompleted,
    questionnaire.personalityCompleted,
    questionnaire.relationshipCompleted,
    questionnaire.partnerCompleted,
    questionnaire.religionCompleted,
  ];

  const allChecks = [...basicChecks, ...questionnaireChecks];
  return allChecks.every(Boolean);
}

async function generateNeshmaInsight(
  narrativeProfile: string,
  user: any,
  locale: Language
) {
  const profile = user.profile;
  const questionnaire = user.questionnaireResponses[0];

  const isHebrew = locale === 'he';
  const languageInstruction = isHebrew
    ? '×›×ª×•×‘ ××ª ×›×œ ×”×ª×©×•×‘×•×ª ×‘×¢×‘×¨×™×ª ×‘×œ×‘×“.'
    : 'Write all responses in English only.';

  const prompt = `
You are an expert matchmaker and relationship counselor with deep psychological insight. You have been given comprehensive information about a person who has completed their profile on a Jewish matchmaking platform.

${languageInstruction}

YOUR TASK:
Create a deeply personalized "Neshama Insight" (Soul Insight) report that will:
1. Help them understand themselves better
2. Clarify who would be their ideal partner
3. Prepare them for meaningful dating
4. Empower them with confidence
5. Guide their next steps

IMPORTANT TONE GUIDELINES:
- Be warm, empathetic, and encouraging
- Use "you" to speak directly to them
- Be specific and personal (avoid generic statements)
- Balance honesty with sensitivity
- Show that you truly SEE them as an individual
- Be professional yet friendly
- Avoid clichÃ©s and empty platitudes

---

PROFILE INFORMATION:
${narrativeProfile}

QUESTIONNAIRE DATA:
${JSON.stringify(questionnaire, null, 2)}

---

Generate a response in the following JSON structure:

{
  "whoYouAre": {
    "summary": "A 2-3 paragraph deep analysis of their personality, values, and character. What makes them unique? What are their core strengths in relationships?",
    "details": [
      "Specific insight about their personality trait #1",
      "Specific insight about their personality trait #2",
      "Specific insight about their values and what drives them",
      "An observation about how they approach life/relationships"
    ]
  },
  "idealPartner": {
    "summary": "A vivid 2-3 paragraph description of the type of partner who would complement them. Not generic qualities, but specific traits that would create harmony with THEIR personality.",
    "details": [
      "Critical quality #1 and WHY it matters for them specifically",
      "Critical quality #2 and WHY it matters for them specifically", 
      "Critical quality #3 and WHY it matters for them specifically",
      "A gentle caution about a potential mismatch to watch for"
    ]
  },
  "firstMeetingTips": {
    "summary": "Personalized advice for their first dates based on their personality type and tendencies.",
    "details": [
      "Tip #1 tailored to their communication style",
      "Tip #2 about managing their specific anxieties or tendencies",
      "Tip #3 about creating authentic connection given their personality",
      "Tip #4 about what to focus on or avoid"
    ]
  },
  "uniquePotential": {
    "summary": "What makes them special as a potential partner. Their unique strengths and what they bring to a relationship.",
    "details": [
      "Unique strength #1 with specific example of how it shows up",
      "Unique strength #2 with specific example",
      "Unique strength #3 with specific example",
      "What a lucky partner will gain by being with them"
    ]
  },
  "nextSteps": {
    "summary": "Transparent explanation of what happens now in the matchmaking process, setting realistic expectations.",
    "details": [
      "What the matchmaking team is doing behind the scenes",
      "Realistic timeline for receiving match suggestions",
      "1-2 specific ways they can optimize their profile further (if any)",
      "How to prepare mentally/emotionally while waiting",
      "A resource or reflection exercise they can do in the meantime"
    ]
  }
}

Remember: This person has invested significant time and emotional energy into completing their profile. They deserve a response that honors that investment with genuine insight, not generic template text. Make them feel SEEN, UNDERSTOOD, and HOPEFUL.

${isHebrew ? '×©×•×‘, ×—×©×•×‘: ×›×ª×•×‘ ×”×›×œ ×‘×¢×‘×¨×™×ª!' : 'Again, important: Write everything in English!'}
`;

  try {
    // Use Google Generative AI directly
    const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);

    const model = genAI.getGenerativeModel({
      model: 'gemini-2.5-flash',
      generationConfig: {
        responseMimeType: 'application/json',
      },
    });

    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();

    // Parse the AI response
    let insightData;
    try {
      // Try to extract JSON from markdown code blocks if present
      let cleanedResponse = text;
      if (text.includes('```json')) {
        cleanedResponse = text
          .replace(/```json\n?/g, '')
          .replace(/```\n?/g, '')
          .trim();
      }
      insightData = JSON.parse(cleanedResponse);
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      console.error('Raw response:', text);
      throw new Error('Failed to parse insight data');
    }

    return insightData;
  } catch (error) {
    console.error('Error calling Google AI:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/questionnaire/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { Prisma, UserRole } from '@prisma/client';
import { Locale } from '../../../../../i18n-config';

import { formatAnswers, KEY_MAPPING } from '@/lib/questionnaireFormatter';
import type { FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { WorldId, UpdateValue } from '@/types/next-auth';
import { formatQuestionnaireForDisplay } from '@/lib/services/questionnaireService';

type JsonAnswerData = {
  questionId: string;
  value: Prisma.JsonValue;
  answeredAt: string;
  isVisible: boolean;
};

export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    // ×§×‘×™×¢×ª ×©×¤×ª ×”×¦×•×¤×” ××”-URL ××• ××”-headers (×›××Ÿ × ×©×ª××© ×‘×‘×¨×™×¨×ª ××—×“×œ)
    const url = new URL(req.url);
    const viewerLocale = (url.searchParams.get('locale') as Locale) || 'he';
    const targetUserId = url.searchParams.get('userId') || session.user.id;
const isOwnProfile = session.user.id === targetUserId;
const hasElevatedPermissions = 
    session.user.role === UserRole.ADMIN || 
    session.user.role === UserRole.MATCHMAKER;
const canViewAllAnswers = isOwnProfile || hasElevatedPermissions;
console.log(`---[ SERVER LOG | API questionnaire GET ]--- ×©×œ×™×¤×ª ×©××œ×•×Ÿ ×¢×‘×•×¨: ${targetUserId}, ×¦×•×¤×”: ${session.user.id}, ×ª×¤×§×™×“ ×¦×•×¤×”: ${session.user.role}, ×™×›×•×œ ×œ×¨××•×ª ×”×›×œ: ${canViewAllAnswers}`);

console.log(`---[ SERVER LOG | API questionnaire GET ]--- ×©×œ×™×¤×ª ×©××œ×•×Ÿ ×¢×‘×•×¨ ××©×ª××©: ${targetUserId}, ×©×¤×ª ×¦×¤×™×™×”: ${viewerLocale}, ×”×× ×‘×¢×œ ×”×¤×¨×•×¤×™×œ: ${isOwnProfile}`);


    const rawQuestionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: targetUserId },
      orderBy: { createdAt: 'desc' },
    });

    if (!rawQuestionnaire) {
              console.warn('---[ SERVER LOG | API questionnaire GET ]--- ×œ× × ××¦× ×©××œ×•×Ÿ ×¢×‘×•×¨ ×”××©×ª××©.');

      return NextResponse.json({ success: false, message: 'No questionnaire found' }, { status: 404 });
    }
    console.log('---[ SERVER LOG | API questionnaire GET ]--- × ×ª×•× ×™ ×©××œ×•×Ÿ ×’×•×œ××™×™× ××”-DB:', JSON.stringify(rawQuestionnaire, null, 2));

    // ×©×™××•×© ×‘×¤×•× ×§×¦×™×™×ª ×”×¢×™×¦×•×‘ ×”×—×“×©×”
const formattedQuestionnaire = await formatQuestionnaireForDisplay(
  rawQuestionnaire,
  viewerLocale,
  canViewAllAnswers  // <-- ×”×•×¡×¤×ª ×”×¤×¨××˜×¨ ×”×—×“×©
);    console.log('---[ DEBUG 4: FINAL API RESPONSE ]--- Data being sent to client:', JSON.stringify(formattedQuestionnaire.formattedAnswers, null, 2));
    console.log('---[ SERVER LOG | API questionnaire GET ]--- × ×ª×•× ×™× ××¢×•×‘×“×™× ×©××•×—×–×¨×™× ×œ×§×œ×™×™× ×˜:', JSON.stringify(formattedQuestionnaire, null, 2));

    return NextResponse.json({
      success: true,
      questionnaireResponse: formattedQuestionnaire,
    });
  } catch (error) {
    console.error('Error fetching formatted questionnaire:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    return NextResponse.json({ success: false, message: errorMessage }, { status: 500 });
 
  }
}


export async function PATCH(req: Request) {
   try {
     const session = await getServerSession(authOptions);
     if (!session?.user?.id) {
       return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 });
     }
     const userId = session.user.id;

     const body = await req.json();
     
     const { worldKey, questionId, value } = body as {
       worldKey: WorldId;
       questionId: string;
       value: UpdateValue;
     };

     if (!worldKey || !questionId || !value || !value.type || !KEY_MAPPING[worldKey]) {
        return NextResponse.json({ success: false, error: "Invalid request body" }, { status: 400 });
     }

     const dbKey = KEY_MAPPING[worldKey];

     const questionnaire = await prisma.questionnaireResponse.findFirst({
       where: { userId: session.user.id },
       orderBy: { createdAt: 'desc' }
     });

     if (!questionnaire) {
       return NextResponse.json({ success: false, error: "×©××œ×•×Ÿ ×œ× × ××¦×" }, { status: 404 });
     }

     const currentAnswersJson = questionnaire[dbKey];
     const currentAnswers = Array.isArray(currentAnswersJson) ? currentAnswersJson as unknown as JsonAnswerData[] : [];

     let updatedAnswers: JsonAnswerData[];

     if (value.type === 'delete') {
       // ×œ×•×’×™×§×” ×œ××—×™×§×ª ×”×ª×©×•×‘×”
       updatedAnswers = currentAnswers.filter(a => a.questionId !== questionId);
     } else {
       // ×œ×•×’×™×§×” ×§×™×™××ª ×œ×¢×“×›×•×Ÿ ××• ×”×•×¡×¤×ª ×ª×©×•×‘×”
       const existingAnswerIndex = currentAnswers.findIndex((a) => a.questionId === questionId);
       const existingAnswer = existingAnswerIndex !== -1 ? currentAnswers[existingAnswerIndex] : null;

       let updatedAnswer: JsonAnswerData;

       if (value.type === 'visibility') {
          if (!existingAnswer) return NextResponse.json({ success: false, error: "×œ× × ××¦××” ×ª×©×•×‘×” ×œ×¢×“×›×•×Ÿ × ×¨××•×ª" }, { status: 404 });
          if (typeof value.isVisible !== 'boolean') return NextResponse.json({ success: false, error: "×¢×¨×š × ×¨××•×ª ×œ× ×ª×§×™×Ÿ" }, { status: 400 });
          updatedAnswer = { ...existingAnswer, isVisible: value.isVisible, answeredAt: new Date().toISOString() };
       } else if (value.type === 'answer') {
         if (value.value === undefined) return NextResponse.json({ success: false, error: "×¢×¨×š ×ª×©×•×‘×” ×—×¡×¨" }, { status: 400 });
         updatedAnswer = {
           questionId,
           value: value.value as Prisma.JsonValue,
           isVisible: existingAnswer?.isVisible ?? true,
           answeredAt: new Date().toISOString()
         };
       } else {
           return NextResponse.json({ success: false, error: "×¡×•×’ ×¢×“×›×•×Ÿ ×œ× ×ª×§×™×Ÿ" }, { status: 400 });
       }

       updatedAnswers = [...currentAnswers];
       if (existingAnswerIndex !== -1) {
           updatedAnswers[existingAnswerIndex] = updatedAnswer;
       } else if (value.type === 'answer') {
           updatedAnswers.push(updatedAnswer);
       }
     }

     const updated = await prisma.questionnaireResponse.update({
       where: { id: questionnaire.id },
       data: {
         [dbKey]: updatedAnswers as Prisma.JsonValue,
         lastSaved: new Date()
       }
     });

     await prisma.profile.update({
       where: { userId },
       data: { needsAiProfileUpdate: true }
     });
await prisma.user.update({
  where: { id: userId },
  data: { updatedAt: new Date() }
});
    const formattedAnswers: Partial<FormattedAnswersType> = {};
    (Object.keys(KEY_MAPPING) as WorldId[]).forEach(key => {
       const currentDbKey = KEY_MAPPING[key];
        formattedAnswers[key] = formatAnswers(updated[currentDbKey]);
    });

     const formattedResponse = {
       ...updated,
       formattedAnswers: formattedAnswers
     };

     return NextResponse.json({
       success: true,
       data: formattedResponse
     });

   } catch (error) {
       console.error('FATAL Error in PATCH /api/profile/questionnaire:', error);
       if (error instanceof Prisma.PrismaClientKnownRequestError) {
            return NextResponse.json({ success: false, error: "×©×’×™××ª ××¡×“ × ×ª×•× ×™×" }, { status: 500 });
       }
       if (error instanceof SyntaxError && error.message.includes("JSON")) {
           return NextResponse.json({ success: false, error: "×’×•×£ ×”×‘×§×©×” ××™× ×• JSON ×ª×§×™×Ÿ" }, { status: 400 });
       }
       if (error instanceof Error) {
         return NextResponse.json({ success: false, error: error.message }, { status: 500 });
       }
       return NextResponse.json({ success: false, error: "×©×’×™××” ×‘×¢×“×›×•×Ÿ ×”×©××œ×•×Ÿ" }, { status: 500 });
   }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * GET - ×××—×–×¨ ×”××œ×¦×•×ª.
 * ×œ×•×’×™×§×” ×–×• ××©××©×ª ×œ×©× ×™ ×ª×¨×—×™×©×™×:
 * 1. ×× × ×©×œ×— 'userId' ×‘×¤×¨××˜×¨×™×: ××—×–×¨ ×”××œ×¦×•×ª *×××•×©×¨×•×ª* ×¢×‘×•×¨ ×¤×¨×•×¤×™×œ ×¦×™×‘×•×¨×™.
 * 2. ×× ×œ× × ×©×œ×— 'userId': ××—×–×¨ ××ª *×›×œ* ×”×”××œ×¦×•×ª ×¢×‘×•×¨ ×”××©×ª××© ×”××—×•×‘×¨, ×›×“×™ ×©×™×•×›×œ ×œ× ×”×œ ××•×ª×Ÿ.
 */
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');

  try {
    // ×ª×¨×—×™×© 1: ×‘×§×©×” ×œ×”×¦×’×ª ×”××œ×¦×•×ª ×‘×¤×¨×•×¤×™×œ ×©×œ ××©×ª××© ×¡×¤×¦×™×¤×™ (×œ×¦×¤×™×™×” ×¦×™×‘×•×¨×™×ª)
    if (userId) {
      const testimonials = await prisma.friendTestimonial.findMany({
        where: {
          profile: {
            userId: userId,
          },
          // ×—×©×•×‘: ×”×—×–×¨ ×¨×§ ×”××œ×¦×•×ª ×©××•×©×¨×• ×œ×¦×¤×™×™×” ×¦×™×‘×•×¨×™×ª
          status: 'APPROVED',
        },
        orderBy: {
          createdAt: 'desc',
        },
      });
      return NextResponse.json({ success: true, testimonials });
    }

    // ×ª×¨×—×™×© 2: ×‘×§×©×” ×œ× ×™×”×•×œ ×”××œ×¦×•×ª ×©×œ ×”××©×ª××© ×”××—×•×‘×¨ (×‘×ª×•×š ×¢××•×“ ×”×¤×¨×•×¤×™×œ ×”××™×©×™)
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: 'Unauthorized' },
        { status: 401 }
      );
    }

    const testimonials = await prisma.friendTestimonial.findMany({
      where: {
        profile: {
          userId: session.user.id,
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ success: true, testimonials });
  } catch (error) {
    console.error('Error in GET /api/profile/testimonials:', error);
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}

/**
 * POST - ×™×•×¦×¨ ×”××œ×¦×” ×—×“×©×” ×‘×××¦×¢×•×ª ×˜×•×§×Ÿ ×—×“-×¤×¢××™ ×•×××•×‘×˜×—.
 * × ×§×•×“×ª ×§×¦×” ×–×• ××©××©×ª ××ª ×”×˜×•×¤×¡ ×”×¦×™×‘×•×¨×™ ×©×—×‘×¨×™× ×××œ××™×.
 * ×”×™× ××‘×˜×™×—×” ×©×›×œ ×§×™×©×•×¨ ×™×©××© ×¤×¢× ××—×ª ×‘×œ×‘×“.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      token,
      authorName,
      relationship,
      content,
      authorPhone,
      isPhoneVisibleToMatch,
    } = body;

    // 1. ×•×œ×™×“×¦×™×” ×‘×¡×™×¡×™×ª ×©×œ ×©×“×•×ª ×”×—×•×‘×”
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields.' },
        { status: 400 }
      );
    }

    // 2. ×©×™××•×© ×‘×˜×¨× ×–×§×¦×™×” ×›×“×™ ×œ×”×‘×˜×™×— ××˜×•××™×•×ª.
    // ×©×ª×™ ×”×¤×¢×•×œ×•×ª (×™×¦×™×¨×ª ×”××œ×¦×” ×•×¢×“×›×•×Ÿ ×”×˜×•×§×Ÿ) ×—×™×™×‘×•×ª ×œ×”×¦×œ×™×— ×™×—×“.
    const result = await prisma.$transaction(async (tx) => {
      // ×©×œ×‘ ×': ×—×¤×© ××ª ×‘×§×©×ª ×”×˜×•×§×Ÿ. ×”×™× ×—×™×™×‘×ª ×œ×”×™×•×ª ×§×™×™××ª, ×‘×ª×•×§×£ ×•×‘×¡×˜×˜×•×¡ PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() }, // ×•×“× ×©×”×˜×•×§×Ÿ ×œ× ×¤×’ ×ª×•×§×£
        },
      });

      // ×× ×œ× × ××¦××” ×‘×§×©×” ×ª×§×™× ×”, ×–×¨×•×§ ×©×’×™××”. ×–×” ×™×‘×˜×œ ××ª ×”×˜×¨× ×–×§×¦×™×” ××•×˜×•××˜×™×ª.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // ×©×œ×‘ ×‘': ×¦×•×¨ ××ª ×¨×©×•××ª ×”×”××œ×¦×” ×‘××¡×“ ×”× ×ª×•× ×™×.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // ×”××œ×¦×” ×—×“×©×” ×ª××™×“ ×××ª×™× ×” ×œ××™×©×•×¨ ×”××©×ª××©
          submittedBy: 'FRIEND', // ×¡××Ÿ ×©×”×”××œ×¦×” ×”×’×™×¢×” ××—×‘×¨
        },
      });

      // ×©×œ×‘ ×’': ×§×¨×™×˜×™! ×©× ×” ××ª ×¡×˜×˜×•×¡ ×”×˜×•×§×Ÿ ×œ-COMPLETED ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×—×•×–×¨.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    // 3. ×× ×”×˜×¨× ×–×§×¦×™×” ×”×¦×œ×™×—×”, ×”×—×–×¨ ×ª×©×•×‘×ª ×”×¦×œ×—×”.
    if (result.success) {
      return NextResponse.json({
        success: true,
        message: 'Thank you! Your testimonial has been submitted.',
      });
    } else {
      // ××¦×‘ ×–×” ×œ× ×××•×¨ ×œ×§×¨×•×ª ×× ×œ×•×’×™×§×ª ×”×˜×¨× ×–×§×¦×™×” × ×›×•× ×”
      throw new Error('Transaction failed unexpectedly.');
    }
  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);

    // 4. ×˜×™×¤×•×œ ×™×™×¢×•×“×™ ×‘×©×’×™××•×ª ×™×“×•×¢×•×ª
    if (
      error instanceof Error &&
      error.message.includes('Invalid, expired, or already used link')
    ) {
      return NextResponse.json(
        {
          success: false,
          message:
            'This link is invalid, has expired, or has already been used.',
        },
        { status: 400 }
      );
    }

    // 5. ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×œ× ×¦×¤×•×™×•×ª ××—×¨×•×ª
    return NextResponse.json(
      { success: false, error: 'An internal server error occurred.' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
# Generated on: 2025-09-18 22:40:39
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

// GET all testimonials for the logged-in user
export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const testimonials = await prisma.friendTestimonial.findMany({
    where: { profileId: session.user.profile.id },
    orderBy: { createdAt: 'desc' },
  });

  return NextResponse.json({ success: true, testimonials });
}

// POST a new manual testimonial
export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }
  
  const body = await req.json();
  const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

  if (!authorName || !relationship || !content) {
    return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
  }

  const newTestimonial = await prisma.friendTestimonial.create({
    data: {
      profileId: session.user.profile.id,
      authorName,
      relationship,
      content,
      authorPhone: authorPhone || null,
      isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
      status: 'APPROVED', // Manual entries are pre-approved by the user
      submittedBy: 'USER',
    },
  });

  return NextResponse.json({ success: true, testimonial: newTestimonial }, { status: 201 });
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id, // Ensure ownership
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[token]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/testimonials/[token]/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { jwtVerify, JWTPayload } from 'jose'; // ×™×™×‘×•× JWTPayload ×¢×•×–×¨ ×œ×‘×”×™×¨×•×ª

interface TokenPayload extends JWTPayload {
  profileId: string;
}

export async function POST(req: Request, { params }: { params: { token: string } }) {
  const { token } = params;
  if (!token) {
    return NextResponse.json({ success: false, message: 'Token is missing' }, { status: 400 });
  }

  const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
  if (!secret) {
      console.error("FATAL: NEXTAUTH_SECRET is not defined.");
      return NextResponse.json({ success: false, message: 'Server configuration error' }, { status: 500 });
  }

  try {
    // --- ×©×™× ×•×™ 1: ×¤×™×¨×•×§ ×”××™××•×ª ×•×”×”×’×“×¨×” (Casting) ×œ×©× ×™ ×©×œ×‘×™× ---
    // ×©×œ×‘ ×': ××™××•×ª ×”×˜×•×§×Ÿ ×œ×œ× ×’× ×¨×™×§×”
    const verificationResult = await jwtVerify(token, secret);
    
    // ×©×œ×‘ ×‘': ×”×’×“×¨×ª ×”-payload ×œ×˜×™×¤×•×¡ ×”××“×•×™×§ ×©×œ× ×•. ×–×” ×¤×•×ª×¨ ××ª ×©×ª×™ ×”×©×’×™××•×ª.
    const payload = verificationResult.payload as TokenPayload;
    const { profileId } = payload;
    // --- ×¡×•×£ ×”×©×™× ×•×™ ---
    
    const body = await req.json();
    const { authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    if (!authorName || !relationship || !content) {
      return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
    }

    await prisma.friendTestimonial.create({
      data: {
        profileId, // ×¢×›×©×™×• TypeScript ×™×•×“×¢ ×©×–×” string
        authorName,
        relationship,
        content,
        authorPhone: authorPhone || null,
        isPhoneVisibleToMatch: isPhoneVisibleToMatch && !!authorPhone,
        status: 'PENDING',
        submittedBy: 'FRIEND',
      },
    });

    return NextResponse.json({ success: true, message: 'Testimonial submitted successfully' });

  } catch (error) {
    console.error("Error processing testimonial submission:", error);
    if (error instanceof Error && (error.name === 'JWTExpired' || error.name === 'JWSInvalid' || error.name === 'JOSEError')) {
        return NextResponse.json({ success: false, message: 'Link is invalid or has expired.' }, { status: 401 });
    }
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { SignJWT } from 'jose';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.profile?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized or profile not found' }, { status: 401 });
    }

    const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
    if (!secret) throw new Error("NEXTAUTH_SECRET is not defined.");

    const payload = {
      profileId: session.user.profile.id,
      userId: session.user.id, // Include userId for verification if needed
    };

    const token = await new SignJWT(payload)
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime('7d') // ×”×§×™×©×•×¨ ×™×”×™×” ×ª×§×£ ×œ×©×‘×•×¢
      .sign(secret);

    const link = `${process.env.NEXT_PUBLIC_BASE_URL}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });

  } catch (error) {
    console.error("Error creating testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for testimonials_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts

import { NextResponse, NextRequest } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

export async function PUT(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.profile?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await

  const { status } = await req.json() as { status: TestimonialStatus };
  if (!Object.values(TestimonialStatus).includes(status)) {
    return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
  }

  const updatedTestimonial = await prisma.friendTestimonial.updateMany({
    where: {
      id: params.testimonialId,
      profileId: session.user.profile.id,
    },
    data: { status },
  });

  if (updatedTestimonial.count === 0) {
    return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}

export async function DELETE(
  req: NextRequest, 
  props: { params: Promise<{ testimonialId: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.profile?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: session.user.profile.id,
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true });
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\testimonials\request-link\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/request-link/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { randomBytes } from 'crypto';

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Find the user's profile to link the request to
    const userProfile = await prisma.profile.findUnique({
      where: { userId: session.user.id },
      select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found' }, { status: 404 });
    }

    // 1. Generate a secure, random token
    const token = randomBytes(32).toString('hex');

    // 2. Set an expiration date (e.g., 7 days from now)
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    // 3. Create the request record in the new database table
    await prisma.testimonialRequest.create({
      data: {
        token: token,
        expiresAt: expiresAt,
        profileId: userProfile.id, // Use the fetched profile ID
      },
    });

    // 4. Construct the full link to return to the client
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    const link = `${baseUrl}/testimonial/${token}`;

    return NextResponse.json({ success: true, link });
  } catch (error) {
    console.error("Failed to create testimonial request link:", error);
    return NextResponse.json({ success: false, message: 'Internal server error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\update\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/update/route.ts (××ª×•×§×Ÿ)

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import {
  Prisma,
  Gender,
  ServiceType,
  HeadCoveringType,
  KippahType,
  AvailabilityStatus,
  ReligiousJourney,
  Profile, // Import Prisma's Profile type
} from "@prisma/client";
import type { UserProfile } from "@/types/next-auth";

// ... (×©××¨ ×”×¤×•× ×§×¦×™×•×ª × ×©××¨×•×ª ×–×”×•×ª) ...
// Helper to convert to number or null
const toNumberOrNull = (value: string | number | null | undefined): number | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  const num = Number(value);
  return isNaN(num) ? null : num;
};

// Helper to convert to Date or error if invalid for required fields
const toRequiredDate = (value: string | number | Date | null | undefined, fieldName: string): Date => {
  if (value === null || value === undefined || String(value).trim() === "") {
    throw new Error(`Required date field '${fieldName}' is missing or empty.`);
  }
  let date: Date;
  if (value instanceof Date) {
    date = value;
  } else {
    date = new Date(value);
  }
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date value for required field '${fieldName}'.`);
  }
  return date;
};

// Helper to convert to Date or null for optional fields
const toDateOrNull = (value: string | number | Date | null | undefined): Date | null => {
  if (value === null || value === undefined || String(value).trim() === "") {
    return null;
  }
  if (value instanceof Date) {
    return isNaN(value.getTime()) ? null : value;
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

// Helper to convert empty string or null to null, otherwise return the string
const emptyStringToNull = (value: string | null | undefined): string | null => {
  if (value === "" || value === null || value === undefined) {
    return null;
  }
  return value;
};


export async function PUT(req: NextRequest) {
  // Apply rate limiting: 50 profile updates per user per 10 minutes (prevents DB heavy load)
  const rateLimitResponse = await applyRateLimit(req, { requests: 50, window: '10 m' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, message: "Unauthorized" },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    let body;
    try {
      body = await req.json();
    } catch (error) {
      console.error("Invalid JSON body:", error);
      return NextResponse.json(
        { success: false, message: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const {
      gender,
      birthDate,
      nativeLanguage,
      additionalLanguages,
      height,
      maritalStatus,
      occupation,
      education,
      educationLevel,
      city,
      origin,
      religiousLevel,
      religiousJourney,
      about,
      profileHeadline,
      inspiringCoupleStory,
      influentialRabbi,
      isAboutVisible,
      isFriendsSectionVisible,
      isNeshamaTechSummaryVisible,
      parentStatus,
      fatherOccupation,
      motherOccupation,
      siblings,
      position,
      isProfileVisible,
      preferredMatchmakerGender,
      availabilityStatus,
      availabilityNote,
      availabilityUpdatedAt,
      matchingNotes,
      shomerNegiah,
      serviceType,
      serviceDetails,
      headCovering,
      kippahType,
      hasChildrenFromPrevious,
      profileCharacterTraits,
      profileHobbies,
      aliyaCountry,
      aliyaYear,
      // --- START: PREFERENCE FIELDS ---
      preferredAgeMin,
      preferredAgeMax,
      preferredHeightMin,
      preferredHeightMax,
      preferredReligiousLevels,
      preferredLocations,
      preferredEducation,
      preferredOccupations,
      contactPreference,
      preferredMaritalStatuses,
      preferredOrigins,
      preferredServiceTypes,
      preferredHeadCoverings,
      preferredKippahTypes,
      preferredShomerNegiah,
      preferredPartnerHasChildren,
      preferredCharacterTraits,
      preferredHobbies,
      preferredAliyaStatus,
      preferredReligiousJourneys,
      // --- END: PREFERENCE FIELDS ---
      hasViewedProfilePreview,
      hasMedicalInfo,
      medicalInfoDetails,
      medicalInfoDisclosureTiming,
      isMedicalInfoVisible,
        cvUrl,
      cvSummary,
    } = body as Partial<UserProfile>;

    const dataToUpdate: Prisma.ProfileUpdateInput = {};

    // --- Personal & Demographic ---
    if (gender !== undefined) dataToUpdate.gender = gender as Gender;
    if (birthDate !== undefined) {
      try {
        dataToUpdate.birthDate = toRequiredDate(birthDate, "birthDate");
      } catch (e) {
         if (e instanceof Error) return NextResponse.json({ success: false, message: e.message }, { status: 400 });
         return NextResponse.json({ success: false, message: "Invalid birthDate provided." }, { status: 400 });
      }
    }
    if (nativeLanguage !== undefined) dataToUpdate.nativeLanguage = emptyStringToNull(nativeLanguage);
    if (additionalLanguages !== undefined) dataToUpdate.additionalLanguages = additionalLanguages || [];
    if (height !== undefined) dataToUpdate.height = toNumberOrNull(height);
    if (city !== undefined) dataToUpdate.city = emptyStringToNull(city);
    if (origin !== undefined) dataToUpdate.origin = emptyStringToNull(origin);
    if (aliyaCountry !== undefined) dataToUpdate.aliyaCountry = emptyStringToNull(aliyaCountry);
    if (aliyaYear !== undefined) dataToUpdate.aliyaYear = toNumberOrNull(aliyaYear);

    // --- Marital Status & Background (User's own) ---
    if (maritalStatus !== undefined) dataToUpdate.maritalStatus = emptyStringToNull(maritalStatus);
    if (hasChildrenFromPrevious !== undefined) dataToUpdate.hasChildrenFromPrevious = hasChildrenFromPrevious;
    if (parentStatus !== undefined) dataToUpdate.parentStatus = emptyStringToNull(parentStatus);
    if (fatherOccupation !== undefined) dataToUpdate.fatherOccupation = emptyStringToNull(fatherOccupation);
    if (motherOccupation !== undefined) dataToUpdate.motherOccupation = emptyStringToNull(motherOccupation);
    if (siblings !== undefined) dataToUpdate.siblings = toNumberOrNull(siblings);
    if (position !== undefined) dataToUpdate.position = toNumberOrNull(position);

    // --- Education, Occupation & Service (User's own) ---
    if (educationLevel !== undefined) dataToUpdate.educationLevel = emptyStringToNull(educationLevel);
    if (education !== undefined) dataToUpdate.education = emptyStringToNull(education);
    if (occupation !== undefined) dataToUpdate.occupation = emptyStringToNull(occupation);
    if (serviceType !== undefined) dataToUpdate.serviceType = emptyStringToNull(serviceType) as ServiceType | null;
    if (serviceDetails !== undefined) dataToUpdate.serviceDetails = emptyStringToNull(serviceDetails);

    // --- Religion & Lifestyle (User's own) ---
    if (religiousLevel !== undefined) dataToUpdate.religiousLevel = emptyStringToNull(religiousLevel);
    if (religiousJourney !== undefined) dataToUpdate.religiousJourney = emptyStringToNull(religiousJourney) as ReligiousJourney | null;
    if (shomerNegiah !== undefined) dataToUpdate.shomerNegiah = shomerNegiah;

    const existingProfileMinimal = await prisma.profile.findUnique({ where: { userId }, select: { gender: true }});
    const currentGenderForLogic = gender !== undefined ? gender : existingProfileMinimal?.gender;

    if (currentGenderForLogic === Gender.FEMALE) {
        if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
        // â—€ï¸ FIX: Changed body.hasOwnProperty('kippahType') to the safe version
        if (gender !== undefined && gender === Gender.FEMALE) dataToUpdate.kippahType = null;
        else if (Object.prototype.hasOwnProperty.call(body, 'kippahType') && kippahType === null) dataToUpdate.kippahType = null;
    } else if (currentGenderForLogic === Gender.MALE) {
        if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        // â—€ï¸ FIX: Changed body.hasOwnProperty('headCovering') to the safe version
        if (gender !== undefined && gender === Gender.MALE) dataToUpdate.headCovering = null;
        else if (Object.prototype.hasOwnProperty.call(body, 'headCovering') && headCovering === null) dataToUpdate.headCovering = null;
    } else {
        if (gender !== undefined && gender === null) {
           dataToUpdate.headCovering = null; dataToUpdate.kippahType = null;
        } else {
            if (headCovering !== undefined) dataToUpdate.headCovering = emptyStringToNull(headCovering) as HeadCoveringType | null;
            if (kippahType !== undefined) dataToUpdate.kippahType = emptyStringToNull(kippahType) as KippahType | null;
        }
    }
    if (preferredMatchmakerGender !== undefined) dataToUpdate.preferredMatchmakerGender = emptyStringToNull(preferredMatchmakerGender) as Gender | null;

    // --- Traits & Hobbies (User's own) ---
    if (profileCharacterTraits !== undefined) dataToUpdate.profileCharacterTraits = profileCharacterTraits || [];
    if (profileHobbies !== undefined) dataToUpdate.profileHobbies = profileHobbies || [];

    // --- About & Additional Info ---
    if (about !== undefined) dataToUpdate.about = emptyStringToNull(about);
    if (profileHeadline !== undefined) dataToUpdate.profileHeadline = emptyStringToNull(profileHeadline);
    if (inspiringCoupleStory !== undefined) dataToUpdate.inspiringCoupleStory = emptyStringToNull(inspiringCoupleStory);
    if (influentialRabbi !== undefined) dataToUpdate.influentialRabbi = emptyStringToNull(influentialRabbi);
    
    // --- Preferences (related to matching partner) ---
    if (matchingNotes !== undefined) dataToUpdate.matchingNotes = emptyStringToNull(matchingNotes);
    if (contactPreference !== undefined) dataToUpdate.contactPreference = emptyStringToNull(contactPreference);
    if (preferredAgeMin !== undefined) dataToUpdate.preferredAgeMin = toNumberOrNull(preferredAgeMin);
    if (preferredAgeMax !== undefined) dataToUpdate.preferredAgeMax = toNumberOrNull(preferredAgeMax);
    if (preferredHeightMin !== undefined) dataToUpdate.preferredHeightMin = toNumberOrNull(preferredHeightMin);
    if (preferredHeightMax !== undefined) dataToUpdate.preferredHeightMax = toNumberOrNull(preferredHeightMax);
    if (preferredLocations !== undefined) dataToUpdate.preferredLocations = preferredLocations || [];
    if (preferredReligiousLevels !== undefined) dataToUpdate.preferredReligiousLevels = preferredReligiousLevels || [];
    if (preferredReligiousJourneys !== undefined) dataToUpdate.preferredReligiousJourneys = preferredReligiousJourneys || [];
    if (preferredShomerNegiah !== undefined) dataToUpdate.preferredShomerNegiah = emptyStringToNull(preferredShomerNegiah);
    if (preferredHeadCoverings !== undefined) dataToUpdate.preferredHeadCoverings = preferredHeadCoverings || [];
    if (preferredKippahTypes !== undefined) dataToUpdate.preferredKippahTypes = preferredKippahTypes || [];
    if (preferredEducation !== undefined) dataToUpdate.preferredEducation = preferredEducation || [];
    if (preferredOccupations !== undefined) dataToUpdate.preferredOccupations = preferredOccupations || [];
    if (preferredServiceTypes !== undefined) dataToUpdate.preferredServiceTypes = preferredServiceTypes || [];
    if (preferredMaritalStatuses !== undefined) dataToUpdate.preferredMaritalStatuses = preferredMaritalStatuses || [];
    if (preferredPartnerHasChildren !== undefined) dataToUpdate.preferredPartnerHasChildren = emptyStringToNull(preferredPartnerHasChildren);
    if (preferredOrigins !== undefined) dataToUpdate.preferredOrigins = preferredOrigins || [];
    if (preferredAliyaStatus !== undefined) dataToUpdate.preferredAliyaStatus = emptyStringToNull(preferredAliyaStatus);
    if (preferredCharacterTraits !== undefined) dataToUpdate.preferredCharacterTraits = preferredCharacterTraits || [];
    if (preferredHobbies !== undefined) dataToUpdate.preferredHobbies = preferredHobbies || [];
    
    // --- Profile Management & Visibility ---
    if (isProfileVisible !== undefined) dataToUpdate.isProfileVisible = isProfileVisible;
    if (hasViewedProfilePreview !== undefined) dataToUpdate.hasViewedProfilePreview = hasViewedProfilePreview;
    if (isAboutVisible !== undefined) dataToUpdate.isAboutVisible = isAboutVisible;
    if (isFriendsSectionVisible !== undefined) dataToUpdate.isFriendsSectionVisible = isFriendsSectionVisible;
    if (isNeshamaTechSummaryVisible !== undefined) dataToUpdate.isNeshamaTechSummaryVisible = isNeshamaTechSummaryVisible;
   
    // --- Medical Info ---
    if (hasMedicalInfo !== undefined) dataToUpdate.hasMedicalInfo = hasMedicalInfo;
    if (medicalInfoDetails !== undefined) dataToUpdate.medicalInfoDetails = emptyStringToNull(medicalInfoDetails);
    if (medicalInfoDisclosureTiming !== undefined) dataToUpdate.medicalInfoDisclosureTiming = emptyStringToNull(medicalInfoDisclosureTiming);
    if (isMedicalInfoVisible !== undefined) dataToUpdate.isMedicalInfoVisible = isMedicalInfoVisible;
  if (cvUrl !== undefined) dataToUpdate.cvUrl = emptyStringToNull(cvUrl);
    if (cvSummary !== undefined) dataToUpdate.cvSummary = emptyStringToNull(cvSummary);
    // --- Availability ---
    if (availabilityStatus !== undefined) {
      const statusValue = emptyStringToNull(availabilityStatus);
      dataToUpdate.availabilityStatus = (statusValue === null ? "AVAILABLE" : statusValue) as AvailabilityStatus;
      // â—€ï¸ FIX: Changed body.hasOwnProperty to the safe version
      if (!Object.prototype.hasOwnProperty.call(body, 'availabilityUpdatedAt') || availabilityUpdatedAt === undefined) {
        dataToUpdate.availabilityUpdatedAt = new Date();
      }
    }
    if (availabilityNote !== undefined) dataToUpdate.availabilityNote = emptyStringToNull(availabilityNote);
    // â—€ï¸ FIX: Changed body.hasOwnProperty to the safe version
    if (Object.prototype.hasOwnProperty.call(body, 'availabilityUpdatedAt') && availabilityUpdatedAt !== undefined) {
        dataToUpdate.availabilityUpdatedAt = toDateOrNull(availabilityUpdatedAt);
    }
    dataToUpdate.lastActive = new Date();

    // ... (×©××¨ ×”×§×•×‘×¥ × ×©××¨ ×–×”×”) ...
    // --- Perform the database update ---
    let updatedProfileRecord: Profile | null = null;
    if (Object.keys(dataToUpdate).length > 0) {
      try {
         dataToUpdate.needsAiProfileUpdate = true;
         
        updatedProfileRecord = await prisma.profile.update({
          where: { userId: userId },
          data: dataToUpdate,
        });
    
      } catch (dbError) {
        console.error('Prisma profile update error:', dbError);
        if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2025') {
          return NextResponse.json({ success: false, message: 'Profile not found for this user to update.' }, { status: 404 });
        }
        throw dbError;
      }
    } else {
      updatedProfileRecord = await prisma.profile.findUnique({ where: { userId } });
    }

    if (!updatedProfileRecord) {
      return NextResponse.json({ success: false, message: "Profile not found or no update performed." }, { status: 404 });
    }

    const refreshedUserWithProfile = await prisma.user.findUnique({
      where: { id: userId },
      include: { profile: true }
    });

    if (!refreshedUserWithProfile || !refreshedUserWithProfile.profile) {
      console.error("Failed to retrieve user or profile after update for userId:", userId);
      return NextResponse.json({ success: false, message: "Failed to retrieve updated profile after update." }, { status: 500 });
    }
    
    const dbProfile = refreshedUserWithProfile.profile;

    // Construct the response, ensuring all UserProfile fields are mapped
    const responseUserProfile: UserProfile = {
      id: dbProfile.id,
      userId: dbProfile.userId,
      gender: dbProfile.gender, 
      birthDate: new Date(dbProfile.birthDate),
      nativeLanguage: dbProfile.nativeLanguage || undefined,
      additionalLanguages: dbProfile.additionalLanguages || [],
      height: dbProfile.height ?? null,
      maritalStatus: dbProfile.maritalStatus || undefined,
      occupation: dbProfile.occupation || "",
      education: dbProfile.education || "",
      educationLevel: dbProfile.educationLevel || undefined,
      city: dbProfile.city || "",
      origin: dbProfile.origin || "",
      religiousLevel: dbProfile.religiousLevel || undefined,
      religiousJourney: dbProfile.religiousJourney || undefined,
      about: dbProfile.about || "",
      profileHeadline: dbProfile.profileHeadline || undefined,
      inspiringCoupleStory: dbProfile.inspiringCoupleStory || undefined,
      influentialRabbi: dbProfile.influentialRabbi || undefined,
      isAboutVisible: dbProfile.isAboutVisible ?? true,
      isFriendsSectionVisible: dbProfile.isFriendsSectionVisible ?? true,
      isNeshamaTechSummaryVisible: dbProfile.isNeshamaTechSummaryVisible ?? true,
      parentStatus: dbProfile.parentStatus || undefined,
      fatherOccupation: dbProfile.fatherOccupation || "",
      motherOccupation: dbProfile.motherOccupation || "",
      siblings: dbProfile.siblings ?? null,
      position: dbProfile.position ?? null,
      isProfileVisible: dbProfile.isProfileVisible,
      isProfileComplete: refreshedUserWithProfile.isProfileComplete,
      hasMedicalInfo: dbProfile.hasMedicalInfo ?? undefined,
      medicalInfoDetails: dbProfile.medicalInfoDetails ?? undefined,
      medicalInfoDisclosureTiming: dbProfile.medicalInfoDisclosureTiming ?? undefined,
      isMedicalInfoVisible: dbProfile.isMedicalInfoVisible,
      needsAiProfileUpdate: dbProfile.needsAiProfileUpdate,
      preferredMatchmakerGender: dbProfile.preferredMatchmakerGender || undefined,
      availabilityStatus: dbProfile.availabilityStatus,
      availabilityNote: dbProfile.availabilityNote || "",
      availabilityUpdatedAt: dbProfile.availabilityUpdatedAt ? new Date(dbProfile.availabilityUpdatedAt) : null,
      matchingNotes: dbProfile.matchingNotes || "",
      shomerNegiah: dbProfile.shomerNegiah ?? undefined,
      serviceType: dbProfile.serviceType || undefined,
      serviceDetails: dbProfile.serviceDetails || "",
      headCovering: dbProfile.headCovering || undefined,
      kippahType: dbProfile.kippahType || undefined,
      hasChildrenFromPrevious: dbProfile.hasChildrenFromPrevious ?? undefined, 
      profileCharacterTraits: dbProfile.profileCharacterTraits || [], 
      profileHobbies: dbProfile.profileHobbies || [],                 
      aliyaCountry: dbProfile.aliyaCountry || "",
      aliyaYear: dbProfile.aliyaYear ?? null,
      preferredAgeMin: dbProfile.preferredAgeMin ?? null,
      preferredAgeMax: dbProfile.preferredAgeMax ?? null,
      preferredHeightMin: dbProfile.preferredHeightMin ?? null,
      preferredHeightMax: dbProfile.preferredHeightMax ?? null,
      preferredLocations: dbProfile.preferredLocations || [],
      preferredReligiousLevels: dbProfile.preferredReligiousLevels || [],
      preferredReligiousJourneys: dbProfile.preferredReligiousJourneys ?? [],
      preferredEducation: dbProfile.preferredEducation || [],
      preferredOccupations: dbProfile.preferredOccupations || [],
      contactPreference: dbProfile.contactPreference || undefined,
      preferredMaritalStatuses: dbProfile.preferredMaritalStatuses || [],
      preferredOrigins: dbProfile.preferredOrigins || [],
      preferredServiceTypes: (dbProfile.preferredServiceTypes as ServiceType[]) || [], 
      preferredHeadCoverings: (dbProfile.preferredHeadCoverings as HeadCoveringType[]) || [],
      preferredKippahTypes: (dbProfile.preferredKippahTypes as KippahType[]) || [],
      preferredShomerNegiah: dbProfile.preferredShomerNegiah || undefined,
      preferredPartnerHasChildren: dbProfile.preferredPartnerHasChildren || undefined,
      preferredCharacterTraits: dbProfile.preferredCharacterTraits || [], 
      preferredHobbies: dbProfile.preferredHobbies || [],                 
      preferredAliyaStatus: dbProfile.preferredAliyaStatus || undefined,
      hasViewedProfilePreview: dbProfile.hasViewedProfilePreview, 
      cvUrl: dbProfile.cvUrl,
      cvSummary: dbProfile.cvSummary,
      createdAt: new Date(dbProfile.createdAt),
      updatedAt: new Date(dbProfile.updatedAt),
      lastActive: dbProfile.lastActive ? new Date(dbProfile.lastActive) : null,
      user: {
        id: refreshedUserWithProfile.id,
        firstName: refreshedUserWithProfile.firstName,
        lastName: refreshedUserWithProfile.lastName,
        email: refreshedUserWithProfile.email,
      },
    };

    return NextResponse.json({
      success: true,
      profile: responseUserProfile,
    });

  } catch (error) {
    console.error('Profile update route error:', error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002' && error.meta?.target) {
         return NextResponse.json({ success: false, message: `Error: A field violates a unique constraint (${JSON.stringify(error.meta.target)}).` }, { status: 409 });
      }
      if (error.code === 'P2025') { 
        return NextResponse.json({ success: false, message: 'Record to update or affect not found.' }, { status: 404 });
      }
      return NextResponse.json(
        { success: false, message: 'Database operation failed.', code: error.code, details: error.message },
        { status: 400 }
      );
    } 
    if (error instanceof Prisma.PrismaClientValidationError) {
        return NextResponse.json(
          { success: false, message: 'Data validation failed for database operation.', details: error.message },
          { status: 400 }
        );
    }
    let errorMessage = 'An unexpected error occurred during profile update.';
    if (error instanceof Error && error.message) {
        errorMessage = error.message;
    }
    return NextResponse.json(
      { success: false, message: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\profile\viewed-preview\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/viewed-preview/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const updatedProfile = await prisma.profile.update({
      where: {
        userId: session.user.id,
      },
      data: {
        hasViewedProfilePreview: true,
      },
      select: {
        userId: true,
        hasViewedProfilePreview: true,
      }
    });

    if (!updatedProfile) {
        return NextResponse.json({ success: false, error: 'Profile not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: updatedProfile }, { status: 200 });

  } catch (error) {
    console.error('Error updating profile preview status:', error);
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\questionnaire_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
# Generated on: 2025-10-27 15:37:55
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\questionnaire_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/questionnaire/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
export const dynamic = 'force-dynamic';
function isPrismaError(
  error: unknown
): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

const WORLD_IDS = [
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
] as const;

const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const baseAnswerSchema = z.object({
  questionId: z.string().min(1),
  worldId: WorldId,
  // --- ×¢×“×›×•×Ÿ ×”×©×“×” value ---
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
    z.object({ // ×”×•×¡×¤×ª ×”××•×‘×™×™×§×˜ ×”×—×“×© ×œ×¡×›××”
      text: z.string(),
      lang: z.string(),
    }),
  ]),

  answeredAt: z.string().datetime(),
  isVisible: z.boolean().optional().default(true), // ×”×•×¡×¤×ª ×”×©×“×” ×”×—×“×© ×¢× ×‘×¨×™×¨×ª ××—×“×œ
});

type QuestionAnswer = z.infer<typeof baseAnswerSchema>;

const QuestionnaireAnswer = baseAnswerSchema;

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional(),
  currentQuestionIndices: z.record(WorldId, z.number()).optional(), // <--- ×”×•×¡×£ ××ª ×”×©×•×¨×” ×”×–×•
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

function groupAnswersByWorld(answers: QuestionnaireSubmission['answers']) {
  return answers.reduce<Record<string, QuestionAnswer[]>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer: QuestionAnswer = {
      questionId: answer.questionId,
      worldId: answer.worldId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      isVisible: answer.isVisible, // ×”×¢×‘×¨×ª ×”×©×“×”
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);

    return acc;
  }, {});
}

function validateSubmissionData(
  data: unknown
): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);

  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '× ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª' }, { status: 401 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    const transformedData = questionnaire
      ? {
          ...questionnaire,
          valuesAnswers: questionnaire.valuesAnswers || [],
          personalityAnswers: questionnaire.personalityAnswers || [],
          relationshipAnswers: questionnaire.relationshipAnswers || [],
          partnerAnswers: questionnaire.partnerAnswers || [],
          religionAnswers: questionnaire.religionAnswers || [],
        }
      : null;

    return NextResponse.json({
      success: true,
      data: transformedData,
    });
  } catch (error: unknown) {
    console.error('Error fetching questionnaire:', {
      message: isError(error) ? error.message : 'Unknown error occurred',
      stack: process.env.NODE_ENV === 'development' ? error : undefined,
    });

    return NextResponse.json(
      {
        error: '××™×¨×¢×” ×©×’×™××” ×‘×˜×¢×™× ×ª ×”×©××œ×•×Ÿ',
        details: process.env.NODE_ENV === 'development' ? error : undefined,
      },
      { status: 500 }
    );
  }
}

type Answer = {
  questionId: string;
  worldId: WorldId;
  value: string | number | string[] | number[] | Record<string, number> | { text: string; lang: string };
  answeredAt: string;
  isVisible?: boolean; // ×”×•×¡×¤×ª ×”×©×“×”
};

type MergedAnswers = {
  valuesAnswers: Answer[];
  personalityAnswers: Answer[];
  relationshipAnswers: Answer[];
  partnerAnswers: Answer[];
  religionAnswers: Answer[];
};

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '× ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª' }, { status: 401 });
    }

    const rawBody = await req.json();

    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json({ error: '××©×ª××© ×œ× × ××¦×' }, { status: 404 });
    }

    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers:
        rawBody.answers?.filter(
          (answer: Answer) =>
            answer &&
            answer.questionId &&
            answer.worldId &&
            answer.value !== undefined &&
            answer.value !== null &&
            answer.value !== ''
        ) ?? [],
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json(
        {
          error: '×©×’×™××ª ×•×œ×™×“×¦×™×”',
          details: isError(error) ? error.message : 'Unknown validation error',
        },
        { status: 400 }
      );
    }

    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    const result = await prisma.$transaction(async (prisma) => {
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' },
      });

      const mergedAnswers: MergedAnswers = {
        valuesAnswers: [
          ...((existingResponse?.valuesAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.valuesAnswers || []),
        ],
        personalityAnswers: [
          ...((existingResponse?.personalityAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.personalityAnswers || []),
        ],
        relationshipAnswers: [
          ...((existingResponse?.relationshipAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.relationshipAnswers || []),
        ],
        partnerAnswers: [
          ...((existingResponse?.partnerAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.partnerAnswers || []),
        ],
        religionAnswers: [
          ...((existingResponse?.religionAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.religionAnswers || []),
        ],
      };

      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof MergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce(
            (acc: Answer[], curr: Answer) => {
              const existingIndex = acc.findIndex(
                (a) => a.questionId === curr.questionId
              );
              if (existingIndex >= 0) {
                if (
                  new Date(curr.answeredAt) >
                  new Date(acc[existingIndex].answeredAt)
                ) {
                  acc[existingIndex] = curr;
                }
              } else {
                acc.push(curr);
              }
              return acc;
            },
            []
          );
          mergedAnswers[worldKey as keyof MergedAnswers] = uniqueAnswers;
        }
      }

      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
           currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),

        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),
        },
      });

      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: 'ACTIVE' },
        });
      }

      return savedQuestionnaire;
    });

    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error: unknown) {
    const errorMessage = isError(error)
      ? error.message
      : 'Unknown error occurred';
    const errorStack = isError(error) ? error.stack : undefined;

    console.error('Error details:', {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined,
    });

    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json(
            {
              error: '×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ - ××©×ª××© ×œ× ×§×™×™×',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 400 }
          );
        case 'P2002':
          return NextResponse.json(
            {
              error: '×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ - ×¨×©×•××” ×›×‘×¨ ×§×™×™××ª',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 409 }
          );
        default:
          return NextResponse.json(
            {
              error: '×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 500 }
          );
      }
    }

    return NextResponse.json(
      {
        error: '××™×¨×¢×” ×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ',
        details:
          process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "× ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const requiredWorlds = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;
    const allWorldsCompleted = requiredWorlds.every(
      world => validatedData.worldsCompleted.includes(world)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "×œ× ×›×œ ×”×¢×•×œ××•×ª ×”×•×©×œ××•"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: "×œ× × ××¦× ×©××œ×•×Ÿ ×œ×”×©×œ××”"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
      prisma.user.update({
        where: { id: session.user.id },
        data: { status: "ACTIVE" }
      })
    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "×©×’×™××ª ×•×œ×™×“×¦×™×”",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "××™×¨×¢×” ×©×’×™××” ×‘×”×©×œ××ª ×”×©××œ×•×Ÿ"
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/questionnaire/world/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';

const WorldId = z.enum([
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
]);
type WorldId = z.infer<typeof WorldId>;

const answerSchema = z.object({
  questionId: z.string().min(1),
  value: z
    .union([
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined(),
    ])
    .optional(),
  answeredAt: z
    .string()
    .datetime()
    .transform((str) => new Date(str)),
  isVisible: z.boolean().optional().default(true), // ×”×•×¡×¤×ª ×”×©×“×”
});

const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(answerSchema),
});


export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const body = await req.json();
    const validationResult = worldAnswersSchema.safeParse(body);
    if (!validationResult.success) {
      console.error(
        'Validation error in /questionnaire/world:',
        validationResult.error
      );
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.flatten(),
        },
        { status: 400 }
      );
    }
    const { worldId, answers: newAnswers } = validationResult.data;

    const dbAnswersKey =
      `${worldId.toLowerCase()}Answers` as keyof Prisma.QuestionnaireResponseCreateInput;
    const dbCompletedKey =
      `${worldId.toLowerCase()}Completed` as keyof Prisma.QuestionnaireResponseCreateInput;

    const updatedQuestionnaire = await prisma.$transaction(async (tx) => {
      const existingResponse = await tx.questionnaireResponse.findFirst({
        where: { userId },
      });
   await tx.profile.update({
        where: { userId },
        data: { needsAiProfileUpdate: true }
      });
      const newAnswersJson = newAnswers.map((ans) => ({
        ...ans,
        answeredAt: ans.answeredAt.toISOString(),
      })) as unknown as Prisma.JsonArray;

      const questionnaire = await tx.questionnaireResponse.upsert({
        where: { id: existingResponse?.id || 'new-response-placeholder' },
        create: {
          userId,
          startedAt: new Date(),
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: [worldId],
        },
        update: {
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: {
            push: worldId,
          },
        },
      });
      return questionnaire;
    });

    return NextResponse.json({
      success: true,
      message: `Successfully saved answers for world: ${worldId}`,
      data: updatedQuestionnaire,
    });
  } catch (error: unknown) {
    console.error('Error in PUT /api/questionnaire/world:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }

    const errorMessage =
      error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for questionnaire_contents.txt ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/questionnaire/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
export const dynamic = 'force-dynamic';
function isPrismaError(
  error: unknown
): error is Prisma.PrismaClientKnownRequestError {
  return error instanceof Prisma.PrismaClientKnownRequestError;
}

function isError(error: unknown): error is Error {
  return error instanceof Error;
}

const WORLD_IDS = [
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
] as const;

const WorldId = z.enum(WORLD_IDS);
type WorldId = z.infer<typeof WorldId>;

const baseAnswerSchema = z.object({
  questionId: z.string().min(1),
  worldId: WorldId,
  // --- ×¢×“×›×•×Ÿ ×”×©×“×” value ---
  value: z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number()),
    z.record(z.string(), z.number()),
    z.object({ // ×”×•×¡×¤×ª ×”××•×‘×™×™×§×˜ ×”×—×“×© ×œ×¡×›××”
      text: z.string(),
      lang: z.string(),
    }),
  ]),

  answeredAt: z.string().datetime(),
  isVisible: z.boolean().optional().default(true), // ×”×•×¡×¤×ª ×”×©×“×” ×”×—×“×© ×¢× ×‘×¨×™×¨×ª ××—×“×œ
});

type QuestionAnswer = z.infer<typeof baseAnswerSchema>;

const QuestionnaireAnswer = baseAnswerSchema;

const QuestionnaireSubmission = z.object({
  userId: z.string(),
  answers: z.array(QuestionnaireAnswer),
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime().optional(),
  currentQuestionIndices: z.record(WorldId, z.number()).optional(), // <--- ×”×•×¡×£ ××ª ×”×©×•×¨×” ×”×–×•
});

type QuestionnaireSubmission = z.infer<typeof QuestionnaireSubmission>;

function groupAnswersByWorld(answers: QuestionnaireSubmission['answers']) {
  return answers.reduce<Record<string, QuestionAnswer[]>>((acc, answer) => {
    const worldKey = `${answer.worldId.toLowerCase()}Answers`;
    const formattedAnswer: QuestionAnswer = {
      questionId: answer.questionId,
      worldId: answer.worldId,
      value: answer.value,
      answeredAt: answer.answeredAt,
      isVisible: answer.isVisible, // ×”×¢×‘×¨×ª ×”×©×“×”
    };

    if (!acc[worldKey]) {
      acc[worldKey] = [];
    }
    acc[worldKey].push(formattedAnswer);

    return acc;
  }, {});
}

function validateSubmissionData(
  data: unknown
): z.infer<typeof QuestionnaireSubmission> {
  const validatedData = QuestionnaireSubmission.safeParse(data);

  if (!validatedData.success) {
    throw new Error(`Validation Error: ${validatedData.error.message}`);
  }

  return validatedData.data;
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '× ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª' }, { status: 401 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    const transformedData = questionnaire
      ? {
          ...questionnaire,
          valuesAnswers: questionnaire.valuesAnswers || [],
          personalityAnswers: questionnaire.personalityAnswers || [],
          relationshipAnswers: questionnaire.relationshipAnswers || [],
          partnerAnswers: questionnaire.partnerAnswers || [],
          religionAnswers: questionnaire.religionAnswers || [],
        }
      : null;

    return NextResponse.json({
      success: true,
      data: transformedData,
    });
  } catch (error: unknown) {
    console.error('Error fetching questionnaire:', {
      message: isError(error) ? error.message : 'Unknown error occurred',
      stack: process.env.NODE_ENV === 'development' ? error : undefined,
    });

    return NextResponse.json(
      {
        error: '××™×¨×¢×” ×©×’×™××” ×‘×˜×¢×™× ×ª ×”×©××œ×•×Ÿ',
        details: process.env.NODE_ENV === 'development' ? error : undefined,
      },
      { status: 500 }
    );
  }
}

type Answer = {
  questionId: string;
  worldId: WorldId;
  value: string | number | string[] | number[] | Record<string, number> | { text: string; lang: string };
  answeredAt: string;
  isVisible?: boolean; // ×”×•×¡×¤×ª ×”×©×“×”
};

type MergedAnswers = {
  valuesAnswers: Answer[];
  personalityAnswers: Answer[];
  relationshipAnswers: Answer[];
  partnerAnswers: Answer[];
  religionAnswers: Answer[];
};

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '× ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª' }, { status: 401 });
    }

    const rawBody = await req.json();

    if (process.env.NODE_ENV === 'development') {
      console.log('Request body:', JSON.stringify(rawBody, null, 2));
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json({ error: '××©×ª××© ×œ× × ××¦×' }, { status: 404 });
    }

    const submissionData = {
      ...rawBody,
      userId: session.user.id,
      answers:
        rawBody.answers?.filter(
          (answer: Answer) =>
            answer &&
            answer.questionId &&
            answer.worldId &&
            answer.value !== undefined &&
            answer.value !== null &&
            answer.value !== ''
        ) ?? [],
    };

    let validatedData: QuestionnaireSubmission;
    try {
      validatedData = validateSubmissionData(submissionData);
    } catch (error) {
      return NextResponse.json(
        {
          error: '×©×’×™××ª ×•×œ×™×“×¦×™×”',
          details: isError(error) ? error.message : 'Unknown validation error',
        },
        { status: 400 }
      );
    }

    const answersGroupedByWorld = groupAnswersByWorld(validatedData.answers);

    const result = await prisma.$transaction(async (prisma) => {
      const existingResponse = await prisma.questionnaireResponse.findFirst({
        where: { userId: session.user.id },
        orderBy: { createdAt: 'desc' },
      });

      const mergedAnswers: MergedAnswers = {
        valuesAnswers: [
          ...((existingResponse?.valuesAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.valuesAnswers || []),
        ],
        personalityAnswers: [
          ...((existingResponse?.personalityAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.personalityAnswers || []),
        ],
        relationshipAnswers: [
          ...((existingResponse?.relationshipAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.relationshipAnswers || []),
        ],
        partnerAnswers: [
          ...((existingResponse?.partnerAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.partnerAnswers || []),
        ],
        religionAnswers: [
          ...((existingResponse?.religionAnswers as Answer[]) || []),
          ...(answersGroupedByWorld.religionAnswers || []),
        ],
      };

      for (const worldKey in mergedAnswers) {
        const answers = mergedAnswers[worldKey as keyof MergedAnswers];
        if (Array.isArray(answers)) {
          const uniqueAnswers = answers.reduce(
            (acc: Answer[], curr: Answer) => {
              const existingIndex = acc.findIndex(
                (a) => a.questionId === curr.questionId
              );
              if (existingIndex >= 0) {
                if (
                  new Date(curr.answeredAt) >
                  new Date(acc[existingIndex].answeredAt)
                ) {
                  acc[existingIndex] = curr;
                }
              } else {
                acc.push(curr);
              }
              return acc;
            },
            []
          );
          mergedAnswers[worldKey as keyof MergedAnswers] = uniqueAnswers;
        }
      }

      const savedQuestionnaire = await prisma.questionnaireResponse.upsert({
        where: {
          id: existingResponse?.id || 'new-response',
        },
        create: {
          userId: session.user.id,
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          startedAt: new Date(validatedData.startedAt),
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
           currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),

        },
        update: {
          ...mergedAnswers,
          worldsCompleted: validatedData.worldsCompleted,
          completed: validatedData.completed,
          completedAt: validatedData.completedAt
            ? new Date(validatedData.completedAt)
            : null,
          valuesCompleted: validatedData.worldsCompleted.includes('VALUES'),
          personalityCompleted:
            validatedData.worldsCompleted.includes('PERSONALITY'),
          relationshipCompleted:
            validatedData.worldsCompleted.includes('RELATIONSHIP'),
          partnerCompleted: validatedData.worldsCompleted.includes('PARTNER'),
          religionCompleted: validatedData.worldsCompleted.includes('RELIGION'),
          currentQuestionIndices: validatedData.currentQuestionIndices,
          lastSaved: new Date(),
        },
      });
await prisma.user.update({
  where: { id: session.user.id },
  data: { updatedAt: new Date() }
});

      if (validatedData.completed) {
        await prisma.user.update({
          where: { id: session.user.id },
          data: { status: 'ACTIVE' },
        });
      }

      return savedQuestionnaire;
    });

    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error: unknown) {
    const errorMessage = isError(error)
      ? error.message
      : 'Unknown error occurred';
    const errorStack = isError(error) ? error.stack : undefined;

    console.error('Error details:', {
      message: errorMessage,
      stack: process.env.NODE_ENV === 'development' ? errorStack : undefined,
    });

    if (isPrismaError(error)) {
      switch (error.code) {
        case 'P2003':
          return NextResponse.json(
            {
              error: '×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ - ××©×ª××© ×œ× ×§×™×™×',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 400 }
          );
        case 'P2002':
          return NextResponse.json(
            {
              error: '×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ - ×¨×©×•××” ×›×‘×¨ ×§×™×™××ª',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 409 }
          );
        default:
          return NextResponse.json(
            {
              error: '×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ',
              details:
                process.env.NODE_ENV === 'development'
                  ? error.message
                  : undefined,
            },
            { status: 500 }
          );
      }
    }

    return NextResponse.json(
      {
        error: '××™×¨×¢×” ×©×’×™××” ×‘×©××™×¨×ª ×”×©××œ×•×Ÿ',
        details:
          process.env.NODE_ENV === 'development' ? errorMessage : undefined,
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\complete\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { z } from "zod";

const WorldId = z.enum(["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"]);

const completionSchema = z.object({
  worldsCompleted: z.array(WorldId),
  completed: z.boolean(),
  startedAt: z.string().datetime(),
  completedAt: z.string().datetime()
});

export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "× ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª" },
        { status: 401 }
      );
    }

    const body = await req.json();
    const validatedData = completionSchema.parse(body);

    // Verify all required worlds are completed
    const requiredWorlds = ["VALUES", "RELATIONSHIP", "PERSONALITY", "PARTNER", "RELIGION"] as const;
    const allWorldsCompleted = requiredWorlds.every(
      world => validatedData.worldsCompleted.includes(world)
    );

    if (!allWorldsCompleted) {
      return NextResponse.json({
        error: "×œ× ×›×œ ×”×¢×•×œ××•×ª ×”×•×©×œ××•"
      }, { status: 400 });
    }

    const questionnaire = await prisma.questionnaireResponse.findFirst({
      where: { userId: session.user.id }
    });

    if (!questionnaire) {
      return NextResponse.json({
        error: "×œ× × ××¦× ×©××œ×•×Ÿ ×œ×”×©×œ××”"
      }, { status: 404 });
    }

    // Update questionnaire and user status in a transaction
    const result = await prisma.$transaction([
      prisma.questionnaireResponse.update({
        where: { id: questionnaire.id },
        data: {
          completed: true,
          completedAt: new Date(validatedData.completedAt),
          worldsCompleted: validatedData.worldsCompleted,
          lastSaved: new Date()
        }
      }),
     prisma.user.update({
  where: { id: session.user.id },
  data: { 
    status: "ACTIVE",
    updatedAt: new Date() // ğŸ†• ×”×•×¡×£
  }
})

    ]);

    return NextResponse.json({
      success: true,
      data: result[0]
    });

  } catch (error: unknown) {
    console.error("Error completing questionnaire:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: "×©×’×™××ª ×•×œ×™×“×¦×™×”",
        details: error.issues
      }, { status: 400 });
    }

    return NextResponse.json({
      error: "××™×¨×¢×” ×©×’×™××” ×‘×”×©×œ××ª ×”×©××œ×•×Ÿ"
    }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\questionnaire\world\route.ts
--------------------------------------------------------------------------------
Content:
// File: src/app/api/questionnaire/world/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Prisma } from '@prisma/client';

const WorldId = z.enum([
  'VALUES',
  'RELATIONSHIP',
  'PERSONALITY',
  'PARTNER',
  'RELIGION',
]);
type WorldId = z.infer<typeof WorldId>;

const answerSchema = z.object({
  questionId: z.string().min(1),
  value: z
    .union([
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.number()),
      z.record(z.string(), z.number()),
      z.null(),
      z.undefined(),
    ])
    .optional(),
  answeredAt: z
    .string()
    .datetime()
    .transform((str) => new Date(str)),
  isVisible: z.boolean().optional().default(true), // ×”×•×¡×¤×ª ×”×©×“×”
});

const worldAnswersSchema = z.object({
  worldId: WorldId,
  answers: z.array(answerSchema),
});


export async function PUT(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }
    const userId = session.user.id;

    const body = await req.json();
    const validationResult = worldAnswersSchema.safeParse(body);
    if (!validationResult.success) {
      console.error(
        'Validation error in /questionnaire/world:',
        validationResult.error
      );
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.flatten(),
        },
        { status: 400 }
      );
    }
    const { worldId, answers: newAnswers } = validationResult.data;

    const dbAnswersKey =
      `${worldId.toLowerCase()}Answers` as keyof Prisma.QuestionnaireResponseCreateInput;
    const dbCompletedKey =
      `${worldId.toLowerCase()}Completed` as keyof Prisma.QuestionnaireResponseCreateInput;

    const updatedQuestionnaire = await prisma.$transaction(async (tx) => {
      const existingResponse = await tx.questionnaireResponse.findFirst({
        where: { userId },
      });
   await tx.profile.update({
        where: { userId },
        data: { needsAiProfileUpdate: true }
      });
      await tx.user.update({
  where: { id: userId },
  data: { updatedAt: new Date() }
});

      const newAnswersJson = newAnswers.map((ans) => ({
        ...ans,
        answeredAt: ans.answeredAt.toISOString(),
      })) as unknown as Prisma.JsonArray;

      const questionnaire = await tx.questionnaireResponse.upsert({
        where: { id: existingResponse?.id || 'new-response-placeholder' },
        create: {
          userId,
          startedAt: new Date(),
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: [worldId],
        },
        update: {
          lastSaved: new Date(),
          [dbAnswersKey]: newAnswersJson,
          [dbCompletedKey]: true,
          worldsCompleted: {
            push: worldId,
          },
        },
      });
      return questionnaire;
    });

    return NextResponse.json({
      success: true,
      message: `Successfully saved answers for world: ${worldId}`,
      data: updatedQuestionnaire,
    });
  } catch (error: unknown) {
    console.error('Error in PUT /api/questionnaire/world:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }

    const errorMessage =
      error instanceof Error ? error.message : 'An unexpected error occurred.';
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\referral_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral
# Generated on: 2025-12-16 09:43:33
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\referral_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\campaign
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\campaign\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/campaign/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma'; // ğŸ”´ ×ª×™×§×•×Ÿ: default import
import { getCampaignWithStats, getActiveCampaign } from '@/lib/services/referralService';
import { z } from 'zod';

// Validation schema for creating campaign
const createCampaignSchema = z.object({
  name: z.string().min(2).max(100),
  slug: z.string().min(2).max(50).regex(/^[a-z0-9-]+$/, 'Slug can only contain lowercase letters, numbers and hyphens'),
  description: z.string().optional(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  prizeTiers: z.array(z.object({
    threshold: z.number().min(1),
    prize: z.string(),
    prizeValue: z.number().optional(),
  })).optional(),
  grandPrize: z.string().optional(),
  settings: z.object({
    requireVerification: z.boolean().default(true),
    requireProfileComplete: z.boolean().default(false),
    maxReferralsPerIP: z.number().min(0).default(5),
    allowSelfReferral: z.boolean().default(false),
  }).optional(),
});

// GET - ×”×‘× ×§××¤×™×™×Ÿ ×¤×¢×™×œ ××• ×¡×¤×¦×™×¤×™
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const campaignId = searchParams.get('id');
    const slug = searchParams.get('slug');
    const withStats = searchParams.get('stats') === 'true';

    // ×× ××‘×§×©×™× ×§××¤×™×™×Ÿ ×¡×¤×¦×™×¤×™ ×¢× ×¡×˜×˜×™×¡×˜×™×§×•×ª - ×¦×¨×™×š ×œ×”×™×•×ª ××“××™×Ÿ
    if (withStats) {
      const session = await getServerSession(authOptions);
      if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
        return NextResponse.json(
          { success: false, error: 'UNAUTHORIZED' },
          { status: 401 }
        );
      }
    }

    let campaign;

    if (campaignId && withStats) {
      campaign = await getCampaignWithStats(campaignId);
    } else if (slug) {
      campaign = await getActiveCampaign(slug);
    } else {
      campaign = await getActiveCampaign();
    }

    if (!campaign) {
      return NextResponse.json(
        { success: false, error: 'CAMPAIGN_NOT_FOUND' },
        { status: 404 }
      );
    }

    // ×× ×–×” ×¢× ×¡×˜×˜×™×¡×˜×™×§×•×ª, ×”×‘× ×’× ××ª ×”××¤× ×™× ×•×”×¡×˜×˜×™×¡×˜×™×§×•×ª
    if (withStats) {
      const campaignIdToUse = campaignId || campaign.id;
      
      const referrers = await prisma.referrer.findMany({
        where: { campaignId: campaignIdToUse },
        orderBy: { verifiedCount: 'desc' },
        include: {
          _count: {
            select: { referrals: true }
          }
        }
      });

      // ×—×™×©×•×‘ ×¡×˜×˜×™×¡×˜×™×§×•×ª ×›×œ×œ×™×•×ª
      const totalClicks = referrers.reduce((sum, r) => sum + r.clickCount, 0);
      const totalRegistrations = referrers.reduce((sum, r) => sum + r.registrationCount, 0);
      const totalVerified = referrers.reduce((sum, r) => sum + r.verifiedCount, 0);
      const conversionRate = totalClicks > 0 ? (totalVerified / totalClicks) * 100 : 0;

      return NextResponse.json({
        success: true,
        campaign: {
          id: campaign.id,
          name: campaign.name,
          slug: campaign.slug,
          description: campaign.description,
          startDate: campaign.startDate,
          endDate: campaign.endDate,
          isActive: campaign.isActive,
          prizeTiers: campaign.prizeTiers,
          grandPrize: campaign.grandPrize,
          totalReferrers: referrers.length,
          totalClicks,
          totalRegistrations,
          totalVerified,
          conversionRate,
        },
        referrers: referrers.map(r => ({
          ...r,
          referralsCount: r._count.referrals,
        })),
      });
    }

    return NextResponse.json({
      success: true,
      campaign: {
        id: campaign.id,
        name: campaign.name,
        slug: campaign.slug,
        description: campaign.description,
        startDate: campaign.startDate,
        endDate: campaign.endDate,
        isActive: campaign.isActive,
        prizeTiers: campaign.prizeTiers,
        grandPrize: campaign.grandPrize,
      },
    });

  } catch (error) {
    console.error('[Campaign GET] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}

// POST - ×¦×•×¨ ×§××¤×™×™×Ÿ ×—×“×© (××“××™×Ÿ ×‘×œ×‘×“)
export async function POST(request: NextRequest) {
  try {
    // ×‘×“×•×§ ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { success: false, error: 'UNAUTHORIZED' },
        { status: 401 }
      );
    }

    const body = await request.json();
    
    // Validate
    const validationResult = createCampaignSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'VALIDATION_ERROR',
          details: validationResult.error.flatten().fieldErrors,
        },
        { status: 400 }
      );
    }

    const data = validationResult.data;

    // ×‘×“×•×§ ×©-slug ×™×™×—×•×“×™
    const existingSlug = await prisma.referralCampaign.findUnique({
      where: { slug: data.slug },
    });

    if (existingSlug) {
      return NextResponse.json(
        { success: false, error: 'SLUG_TAKEN' },
        { status: 409 }
      );
    }

    // ×¦×•×¨ ××ª ×”×§××¤×™×™×Ÿ
    const campaign = await prisma.referralCampaign.create({
      data: {
        name: data.name,
        slug: data.slug,
        description: data.description,
        startDate: new Date(data.startDate),
        endDate: new Date(data.endDate),
        isActive: true,
        prizeTiers: data.prizeTiers ?? undefined, // ğŸ”´ ×ª×™×§×•×Ÿ: undefined ×‘××§×•× null
        grandPrize: data.grandPrize,
        settings: data.settings ?? undefined, // ğŸ”´ ×ª×™×§×•×Ÿ: undefined ×‘××§×•× null
      },
    });

    return NextResponse.json({
      success: true,
      campaign,
    });

  } catch (error) {
    console.error('[Campaign POST] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}

// PATCH - ×¢×“×›×Ÿ ×§××¤×™×™×Ÿ (××“××™×Ÿ ×‘×œ×‘×“)
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { success: false, error: 'UNAUTHORIZED' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { id, ...updates } = body;

    if (!id) {
      return NextResponse.json(
        { success: false, error: 'Missing campaign ID' },
        { status: 400 }
      );
    }

    // ×¢×“×›×Ÿ
    const campaign = await prisma.referralCampaign.update({
      where: { id },
      data: {
        ...updates,
        startDate: updates.startDate ? new Date(updates.startDate) : undefined,
        endDate: updates.endDate ? new Date(updates.endDate) : undefined,
      },
    });

    return NextResponse.json({
      success: true,
      campaign,
    });

  } catch (error) {
    console.error('[Campaign PATCH] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\leaderboard
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\leaderboard\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/leaderboard/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getLeaderboard, getActiveCampaign } from '@/lib/services/referralService';
import prisma from '@/lib/prisma'; // ğŸ”´ ×ª×™×§×•×Ÿ: import ×™×©×™×¨

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const campaignSlug = searchParams.get('campaign');
    const limit = Math.min(parseInt(searchParams.get('limit') || '10'), 50);
    const currentUserCode = searchParams.get('myCode');

    // ××¦× ×§××¤×™×™×Ÿ ×¤×¢×™×œ
    const campaign = await getActiveCampaign(campaignSlug || undefined);
    
    if (!campaign) {
      return NextResponse.json(
        { success: false, error: 'NO_ACTIVE_CAMPAIGN' },
        { status: 404 }
      );
    }

    // ×”×‘× ×œ×™×“×¨×‘×•×¨×“
    const leaderboard = await getLeaderboard(
      campaign.id, 
      limit, 
      currentUserCode || undefined
    );

    // ×¡×¤×•×¨ ×¡×”"×› ××©×ª×ª×¤×™×
    const countResult = await prisma.referrer.aggregate({ // ğŸ”´ ×ª×™×§×•×Ÿ: ×©×™××•×© ×™×©×™×¨ ×‘-prisma
      where: { campaignId: campaign.id },
      _count: { id: true },
    });

    return NextResponse.json({
      success: true,
      leaderboard,
      totalParticipants: countResult._count.id,
      campaign: {
        name: campaign.name,
        endsAt: campaign.endDate.toISOString(),
      },
      lastUpdated: new Date().toISOString(),
    });

  } catch (error) {
    console.error('[Referral Leaderboard] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\lookup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\lookup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/lookup/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

// ×˜×™×¤×•×¡ ×”×ª×•×¦××”
type ReferrerResult = {
  code: string;
  name: string;
} | null;

/**
 * ×—×™×¤×•×© ××¤× ×” ×œ×¤×™ ×§×•×“, ××™××™×™×œ, ××• ×˜×œ×¤×•×Ÿ
 * ×××¤×©×¨ ×œ××¤× ×™× ×§×™×™××™× ×œ××¦×•× ××ª ×”×“×©×‘×•×¨×“ ×©×œ×”×
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');
    const email = searchParams.get('email');
    const phone = searchParams.get('phone');

    // ×—×™×™×‘ ×œ×¤×—×•×ª ×¤×¨××˜×¨ ××—×“
    if (!code && !email && !phone) {
      return NextResponse.json(
        { success: false, error: 'MISSING_SEARCH_PARAM' },
        { status: 400 }
      );
    }

    // ×‘× ×™×™×ª ×©××™×œ×ª×ª ×—×™×¤×•×©
    let referrer: ReferrerResult = null;

    if (code) {
      // ×—×™×¤×•×© ×œ×¤×™ ×§×•×“ (×”×›×™ ××“×•×™×§)
      referrer = await prisma.referrer.findFirst({
        where: { 
          code: code.toUpperCase(),
        },
        select: {
          code: true,
          name: true,
        },
      });
    } else if (email) {
      // ×—×™×¤×•×© ×œ×¤×™ ××™××™×™×œ
      referrer = await prisma.referrer.findFirst({
        where: { 
          email: email.toLowerCase(),
        },
        select: {
          code: true,
          name: true,
        },
      });
    } else if (phone) {
      // ×—×™×¤×•×© ×œ×¤×™ ×˜×œ×¤×•×Ÿ - × ×¨××•×œ ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ
      const normalizedPhone = phone.replace(/[^0-9]/g, '');
      
      referrer = await prisma.referrer.findFirst({
        where: { 
          OR: [
            { phone: phone },
            { phone: normalizedPhone },
            { phone: { contains: normalizedPhone.slice(-9) } }, // 9 ×¡×¤×¨×•×ª ××—×¨×•× ×•×ª
          ],
        },
        select: {
          code: true,
          name: true,
        },
      });
    }

    if (!referrer) {
      return NextResponse.json({
        success: false,
        error: 'NOT_FOUND',
      });
    }

    return NextResponse.json({
      success: true,
      code: referrer.code,
      name: referrer.name,
    });

  } catch (error) {
    console.error('[Referral Lookup] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\register\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/register/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { 
  getActiveCampaign, 
  createReferrer, 
  isValidCode,
  getReferrerByCode,
} from '@/lib/services/referralService';
import { z } from 'zod';

// Validation schema
const registerSchema = z.object({
  campaignSlug: z.string().optional(),
  name: z.string().min(2, '×©× ×—×™×™×‘ ×œ×”×›×™×œ ×œ×¤×—×•×ª 2 ×ª×•×•×™×').max(50),
  email: z.string().email('×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”').optional().or(z.literal('')),
  phone: z.string().optional().or(z.literal('')),
  preferredCode: z.string()
    .min(3, '×§×•×“ ×—×™×™×‘ ×œ×”×›×™×œ ×œ×¤×—×•×ª 3 ×ª×•×•×™×')
    .max(15, '×§×•×“ ×™×›×•×œ ×œ×”×›×™×œ ×¢×“ 15 ×ª×•×•×™×')
    .regex(/^[A-Za-z0-9]+$/, '×§×•×“ ×™×›×•×œ ×œ×”×›×™×œ ×¨×§ ××•×ª×™×•×ª ×‘×× ×’×œ×™×ª ×•××¡×¤×¨×™×')
    .optional()
    .or(z.literal('')),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    const validationResult = registerSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'VALIDATION_ERROR',
          details: validationResult.error.flatten().fieldErrors,
        },
        { status: 400 }
      );
    }

    const { campaignSlug, name, email, phone, preferredCode } = validationResult.data;

    // ××¦× ×§××¤×™×™×Ÿ ×¤×¢×™×œ
    const campaign = await getActiveCampaign(campaignSlug);
    
    if (!campaign) {
      return NextResponse.json(
        { success: false, error: 'NO_ACTIVE_CAMPAIGN' },
        { status: 404 }
      );
    }

    // ×‘×“×•×§ ×× ×”×§×•×“ ×”××•×¢×“×£ ×ª×¤×•×¡
    if (preferredCode) {
      const existing = await getReferrerByCode(preferredCode);
      if (existing) {
        return NextResponse.json(
          { success: false, error: 'CODE_TAKEN' },
          { status: 409 }
        );
      }
      
      if (!isValidCode(preferredCode)) {
        return NextResponse.json(
          { success: false, error: 'INVALID_CODE_FORMAT' },
          { status: 400 }
        );
      }
    }

    // ×¦×•×¨ ××ª ×”××¤× ×”
    const referrer = await createReferrer({
      campaignId: campaign.id,
      name,
      email: email || undefined,
      phone: phone || undefined,
      preferredCode: preferredCode || undefined,
      tier: 'COMMUNITY',
    });

    // ×‘× ×” ××ª ×”-URLs
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://www.neshamatech.com';
    const shareUrl = `${baseUrl}/r/${referrer.code}`;
    const dashboardUrl = `${baseUrl}/he/referral/dashboard?code=${referrer.code}`;

    return NextResponse.json({
      success: true,
      referrer: {
        code: referrer.code,
        shareUrl,
        dashboardUrl,
      },
    });

  } catch (error) {
    console.error('[Referral Register] Error:', error);
    
    if (error instanceof Error) {
      if (error.message === 'CODE_TAKEN') {
        return NextResponse.json(
          { success: false, error: 'CODE_TAKEN' },
          { status: 409 }
        );
      }
      if (error.message === 'INVALID_CODE_FORMAT') {
        return NextResponse.json(
          { success: false, error: 'INVALID_CODE_FORMAT' },
          { status: 400 }
        );
      }
    }

    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}

// ×‘×“×™×§×ª ×–××™× ×•×ª ×§×•×“
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');

    if (!code) {
      return NextResponse.json(
        { success: false, error: 'Missing code parameter' },
        { status: 400 }
      );
    }

    if (!isValidCode(code)) {
      return NextResponse.json({
        success: true,
        available: false,
        reason: 'INVALID_FORMAT',
      });
    }

    const existing = await getReferrerByCode(code);
    
    return NextResponse.json({
      success: true,
      available: !existing,
      reason: existing ? 'TAKEN' : null,
    });

  } catch (error) {
    console.error('[Referral Check Code] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/stats/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getReferrerStats, getReferrerByCode } from '@/lib/services/referralService';
import prisma from '@/lib/prisma';
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');

    if (!code) {
      return NextResponse.json(
        { success: false, error: 'Missing code parameter' },
        { status: 400 }
      );
    }

    // ×‘×“×•×§ ×©×”××¤× ×” ×§×™×™×
    const referrer = await getReferrerByCode(code);
    if (!referrer) {
      return NextResponse.json(
        { success: false, error: 'REFERRER_NOT_FOUND' },
        { status: 404 }
      );
    }

    // ×”×‘× ×¡×˜×˜×™×¡×˜×™×§×•×ª
    const stats = await getReferrerStats(code);
    if (!stats) {
      return NextResponse.json(
        { success: false, error: 'STATS_NOT_FOUND' },
        { status: 404 }
      );
    }

    // ×”×‘× ×¤×™×¨×•×˜ ×”×¤× ×™×•×ª ×œ×¤×™ ×¡×˜×˜×•×¡
    const statusCounts = await prisma.referral.groupBy({
      by: ['status'],
      where: { referrerId: referrer.id },
      _count: { id: true },
    });

    const byStatus = statusCounts.reduce((acc, curr) => {
      acc[curr.status] = curr._count.id;
      return acc;
    }, {} as Record<string, number>);

    // ×”×‘× ×”×¤× ×™×•×ª ××—×¨×•× ×•×ª
    const recentReferrals = await prisma.referral.findMany({
      where: { referrerId: referrer.id },
      orderBy: { createdAt: 'desc' },
      take: 10,
      select: {
        status: true,
        createdAt: true,
      },
    });

    // ×—×©×‘ ×™××™× ×©× ×•×ª×¨×• ×œ×§××¤×™×™×Ÿ
    const now = new Date();
    const endDate = new Date(referrer.campaign.endDate);
    const daysRemaining = Math.max(0, Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));

    return NextResponse.json({
      success: true,
      stats,
      referrals: {
        total: Object.values(byStatus).reduce((a, b) => a + b, 0),
        byStatus,
        recent: recentReferrals.map(r => ({
          status: r.status,
          createdAt: r.createdAt.toISOString(),
        })),
      },
      campaign: {
        name: referrer.campaign.name,
        endsAt: referrer.campaign.endDate.toISOString(),
        daysRemaining,
        isActive: referrer.campaign.isActive && endDate > now,
      },
    });

  } catch (error) {
    console.error('[Referral Stats] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\track
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\track\[code]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\track\[code]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/track/[code]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { 
  trackClick, 
  getReferrerByCode,
  createReferralCookieValue,
  REFERRAL_COOKIE_NAME,
  REFERRAL_COOKIE_DAYS,
} from '@/lib/services/referralService';
import { v4 as uuidv4 } from 'uuid';

/**
 * ×¤×•× ×§×¦×™×” ×œ×§×‘×œ×ª ×”-Base URL ×”× ×›×•×Ÿ
 * ×‘-Heroku, request.url ×™×›×•×œ ×œ×”×—×–×™×¨ URL ×¤× ×™××™ ×œ× × ×›×•×Ÿ
 */
function getBaseUrl(request: NextRequest): string {
  // × ×¡×” ×œ×§×‘×œ ××ª ×”-host ××”-headers
  const host = request.headers.get('x-forwarded-host') || 
               request.headers.get('host') ||
               'localhost:3000';
  
  // ×‘×“×•×§ ×× ×–×” HTTPS (×‘-production)
  const protocol = request.headers.get('x-forwarded-proto') || 
                   (process.env.NODE_ENV === 'production' ? 'https' : 'http');
  
  return `${protocol}://${host}`;
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ code: string }> }
) {
  try {
    // ×ª×™×§×•×Ÿ ×œ-Next.js 15: ×—×•×‘×” ×œ×¢×©×•×ª await ×œ-params
    const { code } = await params;
    
    if (!code) {
      return NextResponse.json(
        { success: false, error: 'Missing code' },
        { status: 400 }
      );
    }

    // ×§×‘×œ ××ª ×”-Base URL ×”× ×›×•×Ÿ
    const baseUrl = getBaseUrl(request);
    console.log('[Referral Track] Base URL:', baseUrl);

    // ×‘×“×•×§ ×× ×”××¤× ×” ×§×™×™× ×•×¤×¢×™×œ
    const referrer = await getReferrerByCode(code);
    
    if (!referrer) {
      // ×§×•×“ ×œ× ×§×™×™× - ×”×¤× ×” ×œ×¢××•×“ ×”×‘×™×ª
      return NextResponse.redirect(new URL('/', baseUrl));
    }

    // ×—×œ×¥ ××™×“×¢ ××”×‘×§×©×”
    const ipAddress = request.headers.get('x-forwarded-for')?.split(',')[0] || 
                      request.headers.get('x-real-ip') || 
                      'unknown';
    const userAgent = request.headers.get('user-agent') || undefined;
    
    // ×¦×•×¨ session ID ×™×™×—×•×“×™
    const sessionId = uuidv4();

    // ×¨×©×•× ××ª ×”×œ×—×™×¦×”
    const result = await trackClick({
      code: code.toUpperCase(),
      ipAddress,
      userAgent,
      sessionId,
    });

    // ×”×›×Ÿ ××ª ×”-redirect URL
    const { searchParams } = new URL(request.url);
    const localeParam = searchParams.get('locale');
    const acceptLanguage = request.headers.get('accept-language') || '';
    const locale = localeParam || (acceptLanguage.startsWith('he') ? 'he' : 'en');
const redirectUrl = new URL(`/${locale}`, baseUrl);    
    // ×”×•×¡×£ ×¤×¨××˜×¨ ×œ×–×™×”×•×™ ×©×–×” ×¨×¤×¨×œ
    redirectUrl.searchParams.set('ref', code.toUpperCase());

    // ×¦×•×¨ response ×¢× redirect
    const response = NextResponse.redirect(redirectUrl);

    // ×”×’×“×¨ cookie ×œ×©××™×¨×ª ×”×¨×¤×¨×œ
    if (result.success && result.referralId) {
      const cookieValue = createReferralCookieValue(code.toUpperCase(), result.referralId);
      
      response.cookies.set(REFERRAL_COOKIE_NAME, cookieValue, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: REFERRAL_COOKIE_DAYS * 24 * 60 * 60, // 30 ×™××™× ×‘×©× ×™×•×ª
        path: '/',
      });

      // ×’× session ID ×œ-localStorage (×“×¨×š query param)
      redirectUrl.searchParams.set('sid', sessionId);
    }

    console.log('[Referral Track] Redirecting to:', redirectUrl.toString());
    return response;

  } catch (error) {
    console.error('[Referral Track] Error:', error);
    
    // ×‘××§×¨×” ×©×œ ×©×’×™××” - ×”×¤× ×” ×œ×¢××•×“ ×”×‘×™×ª
    const baseUrl = getBaseUrl(request);
    return NextResponse.redirect(new URL('/', baseUrl));
  }
}
--- End of Content for route.ts ---

--- End of Content for referral_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\campaign
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\campaign\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/campaign/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma'; // ğŸ”´ ×ª×™×§×•×Ÿ: default import
import { getCampaignWithStats, getActiveCampaign } from '@/lib/services/referralService';
import { z } from 'zod';

// Validation schema for creating campaign
const createCampaignSchema = z.object({
  name: z.string().min(2).max(100),
  slug: z.string().min(2).max(50).regex(/^[a-z0-9-]+$/, 'Slug can only contain lowercase letters, numbers and hyphens'),
  description: z.string().optional(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  prizeTiers: z.array(z.object({
    threshold: z.number().min(1),
    prize: z.string(),
    prizeValue: z.number().optional(),
  })).optional(),
  grandPrize: z.string().optional(),
  settings: z.object({
    requireVerification: z.boolean().default(true),
    requireProfileComplete: z.boolean().default(false),
    maxReferralsPerIP: z.number().min(0).default(5),
    allowSelfReferral: z.boolean().default(false),
  }).optional(),
});

// GET - ×”×‘× ×§××¤×™×™×Ÿ ×¤×¢×™×œ ××• ×¡×¤×¦×™×¤×™
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const campaignId = searchParams.get('id');
    const slug = searchParams.get('slug');
    const withStats = searchParams.get('stats') === 'true';

    // ×× ××‘×§×©×™× ×§××¤×™×™×Ÿ ×¡×¤×¦×™×¤×™ ×¢× ×¡×˜×˜×™×¡×˜×™×§×•×ª - ×¦×¨×™×š ×œ×”×™×•×ª ××“××™×Ÿ
    if (withStats) {
      const session = await getServerSession(authOptions);
      if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
        return NextResponse.json(
          { success: false, error: 'UNAUTHORIZED' },
          { status: 401 }
        );
      }
    }

    let campaign;

    if (campaignId && withStats) {
      campaign = await getCampaignWithStats(campaignId);
    } else if (slug) {
      campaign = await getActiveCampaign(slug);
    } else {
      campaign = await getActiveCampaign();
    }

    if (!campaign) {
      return NextResponse.json(
        { success: false, error: 'CAMPAIGN_NOT_FOUND' },
        { status: 404 }
      );
    }

    // ×× ×–×” ×¢× ×¡×˜×˜×™×¡×˜×™×§×•×ª, ×”×‘× ×’× ××ª ×”××¤× ×™× ×•×”×¡×˜×˜×™×¡×˜×™×§×•×ª
    if (withStats) {
      const campaignIdToUse = campaignId || campaign.id;
      
      const referrers = await prisma.referrer.findMany({
        where: { campaignId: campaignIdToUse },
        orderBy: { verifiedCount: 'desc' },
        include: {
          _count: {
            select: { referrals: true }
          }
        }
      });

      // ×—×™×©×•×‘ ×¡×˜×˜×™×¡×˜×™×§×•×ª ×›×œ×œ×™×•×ª
      const totalClicks = referrers.reduce((sum, r) => sum + r.clickCount, 0);
      const totalRegistrations = referrers.reduce((sum, r) => sum + r.registrationCount, 0);
      const totalVerified = referrers.reduce((sum, r) => sum + r.verifiedCount, 0);
      const conversionRate = totalClicks > 0 ? (totalVerified / totalClicks) * 100 : 0;

      return NextResponse.json({
        success: true,
        campaign: {
          id: campaign.id,
          name: campaign.name,
          slug: campaign.slug,
          description: campaign.description,
          startDate: campaign.startDate,
          endDate: campaign.endDate,
          isActive: campaign.isActive,
          prizeTiers: campaign.prizeTiers,
          grandPrize: campaign.grandPrize,
          totalReferrers: referrers.length,
          totalClicks,
          totalRegistrations,
          totalVerified,
          conversionRate,
        },
        referrers: referrers.map(r => ({
          ...r,
          referralsCount: r._count.referrals,
        })),
      });
    }

    return NextResponse.json({
      success: true,
      campaign: {
        id: campaign.id,
        name: campaign.name,
        slug: campaign.slug,
        description: campaign.description,
        startDate: campaign.startDate,
        endDate: campaign.endDate,
        isActive: campaign.isActive,
        prizeTiers: campaign.prizeTiers,
        grandPrize: campaign.grandPrize,
      },
    });

  } catch (error) {
    console.error('[Campaign GET] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}

// POST - ×¦×•×¨ ×§××¤×™×™×Ÿ ×—×“×© (××“××™×Ÿ ×‘×œ×‘×“)
export async function POST(request: NextRequest) {
  try {
    // ×‘×“×•×§ ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { success: false, error: 'UNAUTHORIZED' },
        { status: 401 }
      );
    }

    const body = await request.json();
    
    // Validate
    const validationResult = createCampaignSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'VALIDATION_ERROR',
          details: validationResult.error.flatten().fieldErrors,
        },
        { status: 400 }
      );
    }

    const data = validationResult.data;

    // ×‘×“×•×§ ×©-slug ×™×™×—×•×“×™
    const existingSlug = await prisma.referralCampaign.findUnique({
      where: { slug: data.slug },
    });

    if (existingSlug) {
      return NextResponse.json(
        { success: false, error: 'SLUG_TAKEN' },
        { status: 409 }
      );
    }

    // ×¦×•×¨ ××ª ×”×§××¤×™×™×Ÿ
    const campaign = await prisma.referralCampaign.create({
      data: {
        name: data.name,
        slug: data.slug,
        description: data.description,
        startDate: new Date(data.startDate),
        endDate: new Date(data.endDate),
        isActive: true,
        prizeTiers: data.prizeTiers ?? undefined, // ğŸ”´ ×ª×™×§×•×Ÿ: undefined ×‘××§×•× null
        grandPrize: data.grandPrize,
        settings: data.settings ?? undefined, // ğŸ”´ ×ª×™×§×•×Ÿ: undefined ×‘××§×•× null
      },
    });

    return NextResponse.json({
      success: true,
      campaign,
    });

  } catch (error) {
    console.error('[Campaign POST] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}

// PATCH - ×¢×“×›×Ÿ ×§××¤×™×™×Ÿ (××“××™×Ÿ ×‘×œ×‘×“)
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { success: false, error: 'UNAUTHORIZED' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { id, ...updates } = body;

    if (!id) {
      return NextResponse.json(
        { success: false, error: 'Missing campaign ID' },
        { status: 400 }
      );
    }

    // ×¢×“×›×Ÿ
    const campaign = await prisma.referralCampaign.update({
      where: { id },
      data: {
        ...updates,
        startDate: updates.startDate ? new Date(updates.startDate) : undefined,
        endDate: updates.endDate ? new Date(updates.endDate) : undefined,
      },
    });

    return NextResponse.json({
      success: true,
      campaign,
    });

  } catch (error) {
    console.error('[Campaign PATCH] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\leaderboard
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\leaderboard\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/leaderboard/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getLeaderboard, getActiveCampaign } from '@/lib/services/referralService';
import prisma from '@/lib/prisma'; // ğŸ”´ ×ª×™×§×•×Ÿ: import ×™×©×™×¨

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const campaignSlug = searchParams.get('campaign');
    const limit = Math.min(parseInt(searchParams.get('limit') || '10'), 50);
    const currentUserCode = searchParams.get('myCode');

    // ××¦× ×§××¤×™×™×Ÿ ×¤×¢×™×œ
    const campaign = await getActiveCampaign(campaignSlug || undefined);
    
    if (!campaign) {
      return NextResponse.json(
        { success: false, error: 'NO_ACTIVE_CAMPAIGN' },
        { status: 404 }
      );
    }

    // ×”×‘× ×œ×™×“×¨×‘×•×¨×“
    const leaderboard = await getLeaderboard(
      campaign.id, 
      limit, 
      currentUserCode || undefined
    );

    // ×¡×¤×•×¨ ×¡×”"×› ××©×ª×ª×¤×™×
    const countResult = await prisma.referrer.aggregate({ // ğŸ”´ ×ª×™×§×•×Ÿ: ×©×™××•×© ×™×©×™×¨ ×‘-prisma
      where: { campaignId: campaign.id },
      _count: { id: true },
    });

    return NextResponse.json({
      success: true,
      leaderboard,
      totalParticipants: countResult._count.id,
      campaign: {
        name: campaign.name,
        endsAt: campaign.endDate.toISOString(),
      },
      lastUpdated: new Date().toISOString(),
    });

  } catch (error) {
    console.error('[Referral Leaderboard] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\lookup
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\lookup\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/lookup/route.ts

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

// ×˜×™×¤×•×¡ ×”×ª×•×¦××”
type ReferrerResult = {
  code: string;
  name: string;
} | null;

/**
 * ×—×™×¤×•×© ××¤× ×” ×œ×¤×™ ×§×•×“, ××™××™×™×œ, ××• ×˜×œ×¤×•×Ÿ
 * ×××¤×©×¨ ×œ××¤× ×™× ×§×™×™××™× ×œ××¦×•× ××ª ×”×“×©×‘×•×¨×“ ×©×œ×”×
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');
    const email = searchParams.get('email');
    const phone = searchParams.get('phone');

    // ×—×™×™×‘ ×œ×¤×—×•×ª ×¤×¨××˜×¨ ××—×“
    if (!code && !email && !phone) {
      return NextResponse.json(
        { success: false, error: 'MISSING_SEARCH_PARAM' },
        { status: 400 }
      );
    }

    // ×‘× ×™×™×ª ×©××™×œ×ª×ª ×—×™×¤×•×©
    let referrer: ReferrerResult = null;

    if (code) {
      // ×—×™×¤×•×© ×œ×¤×™ ×§×•×“ (×”×›×™ ××“×•×™×§)
      referrer = await prisma.referrer.findFirst({
        where: { 
          code: code.toUpperCase(),
        },
        select: {
          code: true,
          name: true,
        },
      });
    } else if (email) {
      // ×—×™×¤×•×© ×œ×¤×™ ××™××™×™×œ
      referrer = await prisma.referrer.findFirst({
        where: { 
          email: email.toLowerCase(),
        },
        select: {
          code: true,
          name: true,
        },
      });
    } else if (phone) {
      // ×—×™×¤×•×© ×œ×¤×™ ×˜×œ×¤×•×Ÿ - × ×¨××•×œ ××¡×¤×¨ ×”×˜×œ×¤×•×Ÿ
      const normalizedPhone = phone.replace(/[^0-9]/g, '');
      
      referrer = await prisma.referrer.findFirst({
        where: { 
          OR: [
            { phone: phone },
            { phone: normalizedPhone },
            { phone: { contains: normalizedPhone.slice(-9) } }, // 9 ×¡×¤×¨×•×ª ××—×¨×•× ×•×ª
          ],
        },
        select: {
          code: true,
          name: true,
        },
      });
    }

    if (!referrer) {
      return NextResponse.json({
        success: false,
        error: 'NOT_FOUND',
      });
    }

    return NextResponse.json({
      success: true,
      code: referrer.code,
      name: referrer.name,
    });

  } catch (error) {
    console.error('[Referral Lookup] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\register
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\register\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/register/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { 
  getActiveCampaign, 
  createReferrer, 
  isValidCode,
  getReferrerByCode,
} from '@/lib/services/referralService';
import { z } from 'zod';

// Validation schema - ××™×™×œ ××• ×˜×œ×¤×•×Ÿ × ×“×¨×©×™× (×œ×¤×—×•×ª ××—×“)
const registerSchema = z.object({
  campaignSlug: z.string().optional(),
  name: z.string().min(2, '×©× ×—×™×™×‘ ×œ×”×›×™×œ ×œ×¤×—×•×ª 2 ×ª×•×•×™×').max(50),
  email: z.string().email('×›×ª×•×‘×ª ××™××™×™×œ ×œ× ×ª×§×™× ×”').optional().or(z.literal('')),
  phone: z.string().optional().or(z.literal('')),
  preferredCode: z.string()
    .min(3, '×§×•×“ ×—×™×™×‘ ×œ×”×›×™×œ ×œ×¤×—×•×ª 3 ×ª×•×•×™×')
    .max(15, '×§×•×“ ×™×›×•×œ ×œ×”×›×™×œ ×¢×“ 15 ×ª×•×•×™×')
    .regex(/^[A-Za-z0-9]+$/, '×§×•×“ ×™×›×•×œ ×œ×”×›×™×œ ×¨×§ ××•×ª×™×•×ª ×‘×× ×’×œ×™×ª ×•××¡×¤×¨×™×')
    .optional()
    .or(z.literal('')),
}).refine(
  // ×•×œ×™×“×¦×™×” ××•×ª×××ª ××™×©×™×ª: ×œ×¤×—×•×ª ××™×™×œ ××• ×˜×œ×¤×•×Ÿ × ×“×¨×©×™×
  (data) => {
    const hasEmail = data.email && data.email.trim().length > 0;
    const hasPhone = data.phone && data.phone.trim().length > 0;
    return hasEmail || hasPhone;
  },
  {
    message: '× ×“×¨×© ×œ×¤×—×•×ª ××™××™×™×œ ××• ×˜×œ×¤×•×Ÿ',
    path: ['contact'], // ×©×“×” ×•×™×¨×˜×•××œ×™ ×œ×©×’×™××”
  }
);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    const validationResult = registerSchema.safeParse(body);
    if (!validationResult.success) {
      const errors = validationResult.error.flatten();
      
      // ×‘×“×™×§×” ×× ×”×©×’×™××” ×”×™× ×¢×œ contact (××™×™×œ ××• ×˜×œ×¤×•×Ÿ)
      const contactError = validationResult.error.issues.find(
        issue => issue.path.includes('contact')
      );
      
      return NextResponse.json(
        { 
          success: false, 
          error: contactError ? 'EMAIL_OR_PHONE_REQUIRED' : 'VALIDATION_ERROR',
          details: errors.fieldErrors,
          message: contactError?.message,
        },
        { status: 400 }
      );
    }

    const { campaignSlug, name, email, phone, preferredCode } = validationResult.data;

    // ××¦× ×§××¤×™×™×Ÿ ×¤×¢×™×œ
    const campaign = await getActiveCampaign(campaignSlug);
    
    if (!campaign) {
      return NextResponse.json(
        { success: false, error: 'NO_ACTIVE_CAMPAIGN' },
        { status: 404 }
      );
    }

    // ×‘×“×•×§ ×× ×”×§×•×“ ×”××•×¢×“×£ ×ª×¤×•×¡
    if (preferredCode) {
      const existing = await getReferrerByCode(preferredCode);
      if (existing) {
        return NextResponse.json(
          { success: false, error: 'CODE_TAKEN' },
          { status: 409 }
        );
      }
      
      if (!isValidCode(preferredCode)) {
        return NextResponse.json(
          { success: false, error: 'INVALID_CODE_FORMAT' },
          { status: 400 }
        );
      }
    }

    // ×¦×•×¨ ××ª ×”××¤× ×”
    const referrer = await createReferrer({
      campaignId: campaign.id,
      name,
      email: email || undefined,
      phone: phone || undefined,
      preferredCode: preferredCode || undefined,
      tier: 'COMMUNITY',
    });

    // ×‘× ×” ××ª ×”-URLs
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://www.neshamatech.com';
    const shareUrl = `${baseUrl}/r/${referrer.code}`;
    const dashboardUrl = `${baseUrl}/he/referral/dashboard?code=${referrer.code}`;

    return NextResponse.json({
      success: true,
      referrer: {
        code: referrer.code,
        shareUrl,
        dashboardUrl,
      },
    });

  } catch (error) {
    console.error('[Referral Register] Error:', error);
    
    if (error instanceof Error) {
      if (error.message === 'CODE_TAKEN') {
        return NextResponse.json(
          { success: false, error: 'CODE_TAKEN' },
          { status: 409 }
        );
      }
      if (error.message === 'INVALID_CODE_FORMAT') {
        return NextResponse.json(
          { success: false, error: 'INVALID_CODE_FORMAT' },
          { status: 400 }
        );
      }
    }

    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}

// ×‘×“×™×§×ª ×–××™× ×•×ª ×§×•×“
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');

    if (!code) {
      return NextResponse.json(
        { success: false, error: 'Missing code parameter' },
        { status: 400 }
      );
    }

    if (!isValidCode(code)) {
      return NextResponse.json({
        success: true,
        available: false,
        reason: 'INVALID_FORMAT',
      });
    }

    const existing = await getReferrerByCode(code);
    
    return NextResponse.json({
      success: true,
      available: !existing,
      reason: existing ? 'TAKEN' : null,
    });

  } catch (error) {
    console.error('[Referral Check Code] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/stats/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getReferrerStats, getReferrerByCode } from '@/lib/services/referralService';
import prisma from '@/lib/prisma';
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');

    if (!code) {
      return NextResponse.json(
        { success: false, error: 'Missing code parameter' },
        { status: 400 }
      );
    }

    // ×‘×“×•×§ ×©×”××¤× ×” ×§×™×™×
    const referrer = await getReferrerByCode(code);
    if (!referrer) {
      return NextResponse.json(
        { success: false, error: 'REFERRER_NOT_FOUND' },
        { status: 404 }
      );
    }

    // ×”×‘× ×¡×˜×˜×™×¡×˜×™×§×•×ª
    const stats = await getReferrerStats(code);
    if (!stats) {
      return NextResponse.json(
        { success: false, error: 'STATS_NOT_FOUND' },
        { status: 404 }
      );
    }

    // ×”×‘× ×¤×™×¨×•×˜ ×”×¤× ×™×•×ª ×œ×¤×™ ×¡×˜×˜×•×¡
    const statusCounts = await prisma.referral.groupBy({
      by: ['status'],
      where: { referrerId: referrer.id },
      _count: { id: true },
    });

    const byStatus = statusCounts.reduce((acc, curr) => {
      acc[curr.status] = curr._count.id;
      return acc;
    }, {} as Record<string, number>);

    // ×”×‘× ×”×¤× ×™×•×ª ××—×¨×•× ×•×ª
    const recentReferrals = await prisma.referral.findMany({
      where: { referrerId: referrer.id },
      orderBy: { createdAt: 'desc' },
      take: 10,
      select: {
        status: true,
        createdAt: true,
      },
    });

    // ×—×©×‘ ×™××™× ×©× ×•×ª×¨×• ×œ×§××¤×™×™×Ÿ
    const now = new Date();
    const endDate = new Date(referrer.campaign.endDate);
    const daysRemaining = Math.max(0, Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));

    return NextResponse.json({
      success: true,
      stats,
      referrals: {
        total: Object.values(byStatus).reduce((a, b) => a + b, 0),
        byStatus,
        recent: recentReferrals.map(r => ({
          status: r.status,
          createdAt: r.createdAt.toISOString(),
        })),
      },
      campaign: {
        name: referrer.campaign.name,
        endsAt: referrer.campaign.endDate.toISOString(),
        daysRemaining,
        isActive: referrer.campaign.isActive && endDate > now,
      },
    });

  } catch (error) {
    console.error('[Referral Stats] Error:', error);
    return NextResponse.json(
      { success: false, error: 'INTERNAL_ERROR' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\track
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\track\[code]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\referral\track\[code]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/referral/track/[code]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { 
  trackClick, 
  getReferrerByCode,
  createReferralCookieValue,
  REFERRAL_COOKIE_NAME,
  REFERRAL_COOKIE_DAYS,
} from '@/lib/services/referralService';
import { v4 as uuidv4 } from 'uuid';

/**
 * ×¤×•× ×§×¦×™×” ×œ×§×‘×œ×ª ×”-Base URL ×”× ×›×•×Ÿ
 * ×‘-Heroku, request.url ×™×›×•×œ ×œ×”×—×–×™×¨ URL ×¤× ×™××™ ×œ× × ×›×•×Ÿ
 */
function getBaseUrl(request: NextRequest): string {
  // × ×¡×” ×œ×§×‘×œ ××ª ×”-host ××”-headers
  const host = request.headers.get('x-forwarded-host') || 
               request.headers.get('host') ||
               'localhost:3000';
  
  // ×‘×“×•×§ ×× ×–×” HTTPS (×‘-production)
  const protocol = request.headers.get('x-forwarded-proto') || 
                   (process.env.NODE_ENV === 'production' ? 'https' : 'http');
  
  return `${protocol}://${host}`;
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ code: string }> }
) {
  try {
    // ×ª×™×§×•×Ÿ ×œ-Next.js 15: ×—×•×‘×” ×œ×¢×©×•×ª await ×œ-params
    const { code } = await params;
    
    if (!code) {
      return NextResponse.json(
        { success: false, error: 'Missing code' },
        { status: 400 }
      );
    }

    // ×§×‘×œ ××ª ×”-Base URL ×”× ×›×•×Ÿ
    const baseUrl = getBaseUrl(request);
    console.log('[Referral Track] Base URL:', baseUrl);

    // ×‘×“×•×§ ×× ×”××¤× ×” ×§×™×™× ×•×¤×¢×™×œ
    const referrer = await getReferrerByCode(code);
    
    if (!referrer) {
      // ×§×•×“ ×œ× ×§×™×™× - ×”×¤× ×” ×œ×¢××•×“ ×”×‘×™×ª
      return NextResponse.redirect(new URL('/', baseUrl));
    }

    // ×—×œ×¥ ××™×“×¢ ××”×‘×§×©×”
    const ipAddress = request.headers.get('x-forwarded-for')?.split(',')[0] || 
                      request.headers.get('x-real-ip') || 
                      'unknown';
    const userAgent = request.headers.get('user-agent') || undefined;
    
    // ×¦×•×¨ session ID ×™×™×—×•×“×™
    const sessionId = uuidv4();

    // ×¨×©×•× ××ª ×”×œ×—×™×¦×”
    const result = await trackClick({
      code: code.toUpperCase(),
      ipAddress,
      userAgent,
      sessionId,
    });

    // ×”×›×Ÿ ××ª ×”-redirect URL
    const { searchParams } = new URL(request.url);
    const localeParam = searchParams.get('locale');
    const acceptLanguage = request.headers.get('accept-language') || '';
    const locale = localeParam || (acceptLanguage.startsWith('he') ? 'he' : 'en');
const redirectUrl = new URL(`/${locale}`, baseUrl);    
    // ×”×•×¡×£ ×¤×¨××˜×¨ ×œ×–×™×”×•×™ ×©×–×” ×¨×¤×¨×œ
    redirectUrl.searchParams.set('ref', code.toUpperCase());

    // ×¦×•×¨ response ×¢× redirect
    const response = NextResponse.redirect(redirectUrl);

    // ×”×’×“×¨ cookie ×œ×©××™×¨×ª ×”×¨×¤×¨×œ
    if (result.success && result.referralId) {
      const cookieValue = createReferralCookieValue(code.toUpperCase(), result.referralId);
      
      response.cookies.set(REFERRAL_COOKIE_NAME, cookieValue, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: REFERRAL_COOKIE_DAYS * 24 * 60 * 60, // 30 ×™××™× ×‘×©× ×™×•×ª
        path: '/',
      });

      // ×’× session ID ×œ-localStorage (×“×¨×š query param)
      redirectUrl.searchParams.set('sid', sessionId);
    }

    console.log('[Referral Track] Redirecting to:', redirectUrl.toString());
    return response;

  } catch (error) {
    console.error('[Referral Track] Error:', error);
    
    // ×‘××§×¨×” ×©×œ ×©×’×™××” - ×”×¤× ×” ×œ×¢××•×“ ×”×‘×™×ª
    const baseUrl = getBaseUrl(request);
    return NextResponse.redirect(new URL('/', baseUrl));
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';

import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole, Priority } from "@prisma/client";
import { z } from "zod";

// Validation schema for creating a new suggestion
const createSuggestionSchema = z.object({
  firstPartyId: z.string({
    required_error: "First party ID is required",
  }),
  secondPartyId: z.string({
    required_error: "Second party ID is required",
  }),
  priority: z.enum([Priority.LOW, Priority.MEDIUM, Priority.HIGH, Priority.URGENT])
    .default(Priority.MEDIUM),
  matchingReason: z.string().optional(),
  firstPartyNotes: z.string().optional(),
  secondPartyNotes: z.string().optional(),
  internalNotes: z.string().optional(),
  decisionDeadline: z.string().refine((val) => !isNaN(Date.parse(val)), { // Validate as date string
    message: "Invalid date format for decisionDeadline",
  }).transform((val) => new Date(val)), // Transform to Date object
});

export async function POST(req: NextRequest) {
  // Apply rate limiting: 30 new suggestions per matchmaker per hour (safety net)
  const rateLimitResponse = await applyRateLimit(req, { requests: 30, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) { // Check for user.id and user.role
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for POST ----
    // 2. Role verification (only matchmakers or admins can create suggestions)
    const allowedCreatorRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN];
    if (!allowedCreatorRoles.includes(session.user.role as UserRole)) {
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to create suggestion" }, { status: 403 });
    }
    // ---- END OF CHANGE for POST ----

    // 3. Parse and validate request body
    const body = await req.json();
    const validationResult = createSuggestionSchema.safeParse(body);

    if (!validationResult.success) {
        return NextResponse.json(
            { error: "Validation error", details: validationResult.error.errors },
            { status: 400 }
        );
    }
    const validatedData = validationResult.data;


    // 4. Check if parties exist and are available
    const [firstParty, secondParty] = await Promise.all([
      prisma.user.findUnique({
        where: { id: validatedData.firstPartyId },
        include: { profile: true },
      }),
      prisma.user.findUnique({
        where: { id: validatedData.secondPartyId },
        include: { profile: true },
      }),
    ]);

    if (!firstParty || !secondParty) {
      return NextResponse.json(
        { error: "One or both parties not found" },
        { status: 404 }
      );
    }

    // 5. Check availability status
    if (
      firstParty.profile?.availabilityStatus !== "AVAILABLE" ||
      secondParty.profile?.availabilityStatus !== "AVAILABLE"
    ) {
      return NextResponse.json(
        { error: "One or both parties are not available for matching" },
        { status: 400 }
      );
    }

    // 6. Check for existing active suggestions between the parties
    const existingSuggestion = await prisma.matchSuggestion.findFirst({
      where: {
        AND: [
          {
            OR: [
              {
                firstPartyId: validatedData.firstPartyId,
                secondPartyId: validatedData.secondPartyId,
              },
              {
                firstPartyId: validatedData.secondPartyId,
                secondPartyId: validatedData.firstPartyId,
              },
            ],
          },
          {
            status: {
              notIn: [
                MatchSuggestionStatus.CLOSED,
                MatchSuggestionStatus.CANCELLED,
                MatchSuggestionStatus.EXPIRED,
                MatchSuggestionStatus.MATCH_DECLINED,
                MatchSuggestionStatus.FIRST_PARTY_DECLINED, // Added
                MatchSuggestionStatus.SECOND_PARTY_DECLINED, // Added
                MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // Added
              ],
            },
          },
        ],
      },
    });

    if (existingSuggestion) {
      return NextResponse.json(
        { error: `Active or pending suggestion (ID: ${existingSuggestion.id}, Status: ${existingSuggestion.status}) already exists between these parties` },
        { status: 409 } // Conflict
      );
    }

    // 7. Create the suggestion using a transaction
    const suggestion = await prisma.$transaction(async (tx) => {
      // Create the suggestion
      const newSuggestion = await tx.matchSuggestion.create({
        data: {
          matchmakerId: session.user.id, // The user creating is the matchmaker
          firstPartyId: validatedData.firstPartyId,
          secondPartyId: validatedData.secondPartyId,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          priority: validatedData.priority,
          matchingReason: validatedData.matchingReason,
          firstPartyNotes: validatedData.firstPartyNotes,
          secondPartyNotes: validatedData.secondPartyNotes,
          internalNotes: validatedData.internalNotes,
          decisionDeadline: validatedData.decisionDeadline,
          responseDeadline: validatedData.decisionDeadline,
          firstPartySent: new Date(),
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Initialize lastActivity
        },
      });

      // Create initial status history entry
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId: newSuggestion.id,
          status: MatchSuggestionStatus.PENDING_FIRST_PARTY,
          notes: "Initial suggestion created and sent to first party",
        },
      });

      return newSuggestion;
    });

    // 8. Trigger email notifications (should be moved to a separate service)
    // TODO: Implement email service integration
    // await emailService.sendSuggestionNotification(suggestion); // Consider passing the full suggestion object

    return NextResponse.json({
      message: "Suggestion created successfully",
      suggestion, // Return the created suggestion object
    }, { status: 201 }); // HTTP 201 Created
  } catch (error) {
    console.error("Error creating suggestion:", error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    // Handle Prisma unique constraint errors specifically if needed
    // if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {}
    
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Status update handler
export async function PATCH(req: NextRequest) {
  try {
    // 1. Authentication check
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    // ---- START OF CHANGE for PATCH (General permission) ----
    const allowedUpdaterRoles: UserRole[] = [UserRole.MATCHMAKER, UserRole.ADMIN, UserRole.CANDIDATE]; // CANDIDATE can update if they are a party
    if (!allowedUpdaterRoles.includes(session.user.role as UserRole)) {
        return NextResponse.json({ error: "Forbidden - Insufficient permissions to update suggestion status" }, { status: 403 });
    }
    // ---- END OF CHANGE for PATCH ----

    const body = await req.json();
    const { suggestionId, status, notes } = body; // Assuming status and notes are part of body

    // Validate incoming data (basic example)
    if (!suggestionId || !status) {
        return NextResponse.json({ error: "Missing suggestionId or status" }, { status: 400 });
    }
    if (!Object.values(MatchSuggestionStatus).includes(status as MatchSuggestionStatus)) {
        return NextResponse.json({ error: "Invalid status value" }, { status: 400 });
    }


    // 2. Fetch current suggestion
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        firstParty: { include: { profile: true } },
        secondParty: { include: { profile: true } },
        matchmaker: true, // Include matchmaker for permission checks
      },
    });

    if (!suggestion) {
      return NextResponse.json(
        { error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // ---- Specific permission check for PATCH ----
    // An ADMIN can update any suggestion.
    // A MATCHMAKER can update suggestions they created.
    // A CANDIDATE can update suggestions they are a party to (firstPartyId or secondPartyId).
    const isUserAdmin = session.user.role === UserRole.ADMIN;
    const isUserMatchmakerOwner = session.user.role === UserRole.MATCHMAKER && suggestion.matchmakerId === session.user.id;
    const isUserParty = session.user.role === UserRole.CANDIDATE && (suggestion.firstPartyId === session.user.id || suggestion.secondPartyId === session.user.id);

    if (!isUserAdmin && !isUserMatchmakerOwner && !isUserParty) {
        return NextResponse.json({ error: "Forbidden - You do not have permission to update this specific suggestion's status." }, { status: 403 });
    }
    // ---- End specific permission check ----


    // 3. Validate status transition (using your existing helper)
    const isValidTransition = validateStatusTransition(suggestion.status, status as MatchSuggestionStatus);
    if (!isValidTransition) {
      return NextResponse.json(
        { error: `Invalid status transition from ${suggestion.status} to ${status}` },
        { status: 400 }
      );
    }

    // 4. Update suggestion and create history entry
    const updatedSuggestion = await prisma.$transaction(async (tx) => {
      const updated = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status as MatchSuggestionStatus,
          previousStatus: suggestion.status,
          lastStatusChange: new Date(),
          lastActivity: new Date(), // Update lastActivity
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY && {
            secondPartySent: new Date(),
          }),
          ...(status === MatchSuggestionStatus.CONTACT_DETAILS_SHARED && {
            // closedAt: new Date(), // Typically, CONTACT_DETAILS_SHARED doesn't mean closed
          }),
          ...(status === MatchSuggestionStatus.CLOSED && { // Explicitly set closedAt for CLOSED status
            closedAt: new Date(),
          }),
        },
      });

      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status: status as MatchSuggestionStatus,
          notes: notes || `Status changed to ${status} by user ${session.user.id}`, // Add more context to notes
        },
      });

      return updated;
    });

    // 5. Handle automatic transitions and notifications
    // This logic might be better suited in a service layer or triggered by events
    // For example, if status is FIRST_PARTY_APPROVED, you might automatically transition to PENDING_SECOND_PARTY
    // and send notifications.
    // if (status === MatchSuggestionStatus.FIRST_PARTY_APPROVED) {
    //   // TODO: Transition to PENDING_SECOND_PARTY and notify
    // } else if (status === MatchSuggestionStatus.SECOND_PARTY_APPROVED) {
    //   // TODO: Transition to CONTACT_DETAILS_SHARED and notify
    // }

    return NextResponse.json({
      message: "Suggestion status updated successfully",
      suggestion: updatedSuggestion,
    });
  } catch (error) {
    console.error("Error updating suggestion status:", error);
    if (error instanceof z.ZodError) { // Handle Zod validation errors if you add more validation
        return NextResponse.json(
            { error: "Validation error for status update", details: error.errors },
            { status: 400 }
        );
    }
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Helper function to validate status transitions
function validateStatusTransition(
  currentStatus: MatchSuggestionStatus,
  newStatus: MatchSuggestionStatus
): boolean {
  const validTransitions: Record<MatchSuggestionStatus, MatchSuggestionStatus[]> = {
    DRAFT: [MatchSuggestionStatus.PENDING_FIRST_PARTY, MatchSuggestionStatus.CANCELLED],
    PENDING_FIRST_PARTY: [
        MatchSuggestionStatus.FIRST_PARTY_APPROVED,
        MatchSuggestionStatus.FIRST_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    FIRST_PARTY_APPROVED: [
        MatchSuggestionStatus.PENDING_SECOND_PARTY,
        MatchSuggestionStatus.CANCELLED
    ],
    FIRST_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    PENDING_SECOND_PARTY: [
        MatchSuggestionStatus.SECOND_PARTY_APPROVED,
        MatchSuggestionStatus.SECOND_PARTY_DECLINED,
        MatchSuggestionStatus.CANCELLED,
        MatchSuggestionStatus.EXPIRED,
    ],
    SECOND_PARTY_APPROVED: [
        MatchSuggestionStatus.AWAITING_MATCHMAKER_APPROVAL, // Often matchmaker confirms before sharing
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED, // Or directly share
        MatchSuggestionStatus.CANCELLED
    ],
    SECOND_PARTY_DECLINED: [MatchSuggestionStatus.CLOSED],
    AWAITING_MATCHMAKER_APPROVAL: [ // Matchmaker action after both parties approve
        MatchSuggestionStatus.CONTACT_DETAILS_SHARED,
        MatchSuggestionStatus.MATCH_DECLINED, // Matchmaker can decide not to proceed
        MatchSuggestionStatus.CANCELLED
    ],
    CONTACT_DETAILS_SHARED: [
        MatchSuggestionStatus.MEETING_PENDING, // Or AWAITING_FIRST_DATE_FEEDBACK
        MatchSuggestionStatus.DATING, // If they skip formal feedback and start dating
        MatchSuggestionStatus.CLOSED, // If one party decides not to proceed after contact
        MatchSuggestionStatus.CANCELLED
    ],
    AWAITING_FIRST_DATE_FEEDBACK: [
        MatchSuggestionStatus.THINKING_AFTER_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE, // If feedback leads to this
        MatchSuggestionStatus.CANCELLED
    ],
    THINKING_AFTER_DATE: [
        MatchSuggestionStatus.PROCEEDING_TO_SECOND_DATE,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE,
        MatchSuggestionStatus.CANCELLED
    ],
    PROCEEDING_TO_SECOND_DATE: [ // This might be too granular, DATNG might cover it
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK, // For feedback after 2nd date etc.
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENDED_AFTER_FIRST_DATE, // If it ends after 2nd date
        MatchSuggestionStatus.CANCELLED
    ],
    ENDED_AFTER_FIRST_DATE: [MatchSuggestionStatus.CLOSED],
    MEETING_PENDING: [ // This status might be redundant if AWAITING_FIRST_DATE_FEEDBACK is used
        MatchSuggestionStatus.MEETING_SCHEDULED,
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.CANCELLED
    ],
    MEETING_SCHEDULED: [ // Similar to MEETING_PENDING
        MatchSuggestionStatus.AWAITING_FIRST_DATE_FEEDBACK,
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_APPROVED: [ // This is often equivalent to CONTACT_DETAILS_SHARED or DATNG
        MatchSuggestionStatus.DATING,
        MatchSuggestionStatus.ENGAGED, // Could jump here
        MatchSuggestionStatus.CANCELLED
    ],
    MATCH_DECLINED: [MatchSuggestionStatus.CLOSED],
    DATING: [
        MatchSuggestionStatus.ENGAGED,
        MatchSuggestionStatus.CLOSED, // If dating ends
        MatchSuggestionStatus.CANCELLED
    ],
    ENGAGED: [
        MatchSuggestionStatus.MARRIED,
        MatchSuggestionStatus.CLOSED, // If engagement breaks
        MatchSuggestionStatus.CANCELLED
    ],
    MARRIED: [MatchSuggestionStatus.CLOSED], // Or just stay MARRIE
    EXPIRED: [MatchSuggestionStatus.CLOSED],
    CLOSED: [], // No transitions from CLOSED typically, except maybe reopening
    CANCELLED: [MatchSuggestionStatus.CLOSED] // Or just stay CANCELLED
};

  return validTransitions[currentStatus]?.includes(newStatus) ?? false;
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { UserRole, Priority } from "@prisma/client";
import prisma from "@/lib/prisma";

interface SuggestionUpdateData {
  priority?: Priority;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: string | null;
}

interface PrismaUpdateData {
  lastActivity: Date;
  priority?: Priority;
  matchingReason?: string;
  firstPartyNotes?: string;
  secondPartyNotes?: string;
  internalNotes?: string;
  decisionDeadline?: Date | null;
}

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }
    
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    
    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const suggestionId = params.id;
    const data: SuggestionUpdateData = await req.json();
    
    console.log("PATCH request for suggestion:", suggestionId, "with data:", data);

    const existingSuggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      select: {
        id: true,
        matchmakerId: true,
        status: true
      }
    });

    if (!existingSuggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    if (existingSuggestion.matchmakerId !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to edit this suggestion" },
        { status: 403 }
      );
    }

    const updateData: PrismaUpdateData = {
      lastActivity: new Date(),
    };

    if (data.priority !== undefined) {
      updateData.priority = data.priority;
    }
    if (data.matchingReason !== undefined) {
      updateData.matchingReason = data.matchingReason;
    }
    if (data.firstPartyNotes !== undefined) {
      updateData.firstPartyNotes = data.firstPartyNotes;
    }
    if (data.secondPartyNotes !== undefined) {
      updateData.secondPartyNotes = data.secondPartyNotes;
    }
    if (data.internalNotes !== undefined) {
      updateData.internalNotes = data.internalNotes;
    }
    if (data.decisionDeadline !== undefined) {
      updateData.decisionDeadline = data.decisionDeadline ? new Date(data.decisionDeadline) : null;
    }

    console.log("Updating suggestion with data:", updateData);

    const updatedSuggestion = await prisma.matchSuggestion.update({
      where: { id: suggestionId },
      data: updateData,
      include: {
        firstParty: {
          select: { 
            id: true, 
            firstName: true, 
            lastName: true,
            images: { 
              select: { id: true, url: true, isMain: true }, 
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] 
            }, 
            profile: true 
          }
        },
        secondParty: {
          select: { 
            id: true, 
            firstName: true, 
            lastName: true,
            images: { 
              select: { id: true, url: true, isMain: true }, 
              orderBy: [{ isMain: 'desc' }, { createdAt: 'asc'}] 
            }, 
            profile: true 
          }
        },
        matchmaker: {
          select: { id: true, firstName: true, lastName: true }
        },
        statusHistory: { 
          orderBy: { createdAt: 'desc' } 
        }
      }
    });

    console.log("Suggestion updated successfully:", updatedSuggestion.id);

    if (updatedSuggestion.firstParty.profile && !updatedSuggestion.firstParty.profile.isMedicalInfoVisible) {
      updatedSuggestion.firstParty.profile.medicalInfoDetails = null;
    }
    if (updatedSuggestion.secondParty.profile && !updatedSuggestion.secondParty.profile.isMedicalInfoVisible) {
      updatedSuggestion.secondParty.profile.medicalInfoDetails = null;
    }

    const formattedSuggestion = {
      ...updatedSuggestion,
      firstParty: {
        ...updatedSuggestion.firstParty,
        profile: updatedSuggestion.firstParty.profile ? {
          ...updatedSuggestion.firstParty.profile,
          birthDate: updatedSuggestion.firstParty.profile.birthDate?.toISOString(),
          lastActive: updatedSuggestion.firstParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: updatedSuggestion.firstParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: updatedSuggestion.firstParty.profile.createdAt?.toISOString(),
          updatedAt: updatedSuggestion.firstParty.profile.updatedAt?.toISOString()
        } : null
      },
      secondParty: {
        ...updatedSuggestion.secondParty,
        profile: updatedSuggestion.secondParty.profile ? {
          ...updatedSuggestion.secondParty.profile,
          birthDate: updatedSuggestion.secondParty.profile.birthDate?.toISOString(),
          lastActive: updatedSuggestion.secondParty.profile.lastActive?.toISOString(),
          availabilityUpdatedAt: updatedSuggestion.secondParty.profile.availabilityUpdatedAt?.toISOString(),
          createdAt: updatedSuggestion.secondParty.profile.createdAt?.toISOString(),
          updatedAt: updatedSuggestion.secondParty.profile.updatedAt?.toISOString()
        } : null
      },
      statusHistory: updatedSuggestion.statusHistory.map(history => ({
        ...history,
        createdAt: history.createdAt.toISOString()
      })),
      responseDeadline: updatedSuggestion.responseDeadline?.toISOString(),
      decisionDeadline: updatedSuggestion.decisionDeadline?.toISOString(),
      lastStatusChange: updatedSuggestion.lastStatusChange?.toISOString(),
      firstPartySent: updatedSuggestion.firstPartySent?.toISOString(),
      firstPartyResponded: updatedSuggestion.firstPartyResponded?.toISOString(),
      secondPartySent: updatedSuggestion.secondPartySent?.toISOString(),
      secondPartyResponded: updatedSuggestion.secondPartyResponded?.toISOString(),
      firstMeetingScheduled: updatedSuggestion.firstMeetingScheduled?.toISOString(),
      closedAt: updatedSuggestion.closedAt?.toISOString(),
      createdAt: updatedSuggestion.createdAt.toISOString(),
      updatedAt: updatedSuggestion.updatedAt.toISOString(),
      lastActivity: updatedSuggestion.lastActivity.toISOString()
    };
      
    return NextResponse.json({
      success: true,
      data: formattedSuggestion
    });
      
  } catch (error) {
    console.error("Error updating suggestion:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    
    return NextResponse.json(
      { success: false, error: "Failed to update suggestion", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\delete
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\delete\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";

export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.role) {
      return NextResponse.json({ error: "Unauthorized - Invalid session" }, { status: 401 });
    }

    const params = await props.params;
    const suggestionId = params.id;

    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
    });

    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }

    const userRole = session.user.role as UserRole;
    const isOwner = suggestion.matchmakerId === session.user.id;

    if (userRole !== UserRole.ADMIN && !(userRole === UserRole.MATCHMAKER && isOwner)) {
      return NextResponse.json({ error: "Forbidden - Insufficient permissions to delete this suggestion" }, { status: 403 });
    }

    await prisma.$transaction(async (tx) => {
      await tx.suggestionStatusHistory.deleteMany({
        where: { suggestionId },
      });
      await tx.suggestionInquiry.deleteMany({
        where: { suggestionId },
      });
      await tx.meeting.deleteMany({
        where: { suggestionId },
      });
      await tx.dateFeedback.deleteMany({
        where: { suggestionId },
      });
      await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          approvedBy: { set: [] },
          reviewedBy: { set: [] },
        }
      });
      await tx.matchSuggestion.delete({
        where: { id: suggestionId },
      });
    });

    return NextResponse.json({
      success: true,
      message: "Suggestion deleted successfully",
    });

  } catch (error) {
    console.error("Error deleting suggestion:", error);
    return NextResponse.json(
      { error: "Internal server error during suggestion deletion" },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/inquiries/route.ts

import { NextRequest, NextResponse } from "next/server";
import { applyRateLimit } from '@/lib/rate-limiter';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { InquiryStatus, UserRole } from "@prisma/client";
import type { Session } from "next-auth";

type AuthSession = Session | null;

async function checkPermissions(suggestionId: string, session: AuthSession) {
  if (!session?.user?.id) {
    throw new Error("Unauthorized");
  }

  const suggestion = await prisma.matchSuggestion.findUnique({
    where: { id: suggestionId },
    select: { firstPartyId: true, secondPartyId: true, matchmakerId: true },
  });

  if (!suggestion) {
    throw new Error("Suggestion not found");
  }

  const isAuthorized =
    session.user.id === suggestion.firstPartyId ||
    session.user.id === suggestion.secondPartyId ||
    session.user.id === suggestion.matchmakerId ||
    session.user.role === UserRole.ADMIN;

  if (!isAuthorized) {
    throw new Error("Forbidden");
  }

  return { suggestion, userId: session.user.id, userRole: session.user.role as UserRole };
}

/**
 * GET: Fetch all inquiries for a specific suggestion.
 * Users can only see inquiries for suggestions they are a part of.
 */
export async function GET(
  req: NextRequest, // ×©×™× ×•×™: ×©×™××•×© ×‘-NextRequest ×‘××§×•× Request
  props: { params: Promise<{ id: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const session = await getServerSession(authOptions);
    await checkPermissions(params.id, session);

    const inquiries = await prisma.suggestionInquiry.findMany({
      where: { suggestionId: params.id },
      include: {
        fromUser: { select: { id: true, firstName: true, lastName: true } },
        toUser: { select: { id: true, firstName: true, lastName: true } },
      },
      orderBy: { createdAt: "asc" },
    });

    return NextResponse.json({ success: true, inquiries });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error fetching inquiries:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * POST: Create a new inquiry (question) for a suggestion.
 * A user (candidate) sends a question to the matchmaker.
 */
export async function POST(
  req: NextRequest, 
  props: { params: Promise<{ id: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  const rateLimitResponse = await applyRateLimit(req, { requests: 20, window: '1 h' });
  if (rateLimitResponse) {
    return rateLimitResponse;
  }
  try {
    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const session = await getServerSession(authOptions);
    const { suggestion, userId } = await checkPermissions(params.id, session);

    const { question } = await req.json();
    if (!question || typeof question !== 'string' || question.trim().length === 0) {
      return NextResponse.json({ error: "Question content is required" }, { status: 400 });
    }

    const inquiry = await prisma.$transaction(async (tx) => {
      const newInquiry = await tx.suggestionInquiry.create({
        data: {
          suggestionId: params.id,
          fromUserId: userId,
          toUserId: suggestion.matchmakerId,
          question,
          status: InquiryStatus.PENDING,
        },
      });

      await tx.matchSuggestion.update({
        where: { id: params.id },
        data: { lastActivity: new Date() },
      });

      return newInquiry;
    });
    
    // TODO: Add notification to matchmaker about the new question

    return NextResponse.json({ success: true, inquiry });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error creating inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * PATCH: Answer an inquiry.
 * Only the matchmaker (or an admin) can answer an inquiry.
 */
export async function PATCH(
  req: NextRequest, // ×©×™× ×•×™: ×©×™××•×© ×‘-NextRequest ×‘××§×•× Request
  props: { params: Promise<{ id: string }> } // âœ… ×©×™× ×•×™: ×”×ª×××” ×œ-Next.js 15
) {
  try {
    const params = await props.params; // âœ… ×©×™× ×•×™: ×”×•×¡×¤×ª await
    const session = await getServerSession(authOptions);
    const { userRole, userId } = await checkPermissions(params.id, session);

    if (userRole !== UserRole.MATCHMAKER && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: Only matchmakers or admins can answer inquiries." }, { status: 403 });
    }

    const { inquiryId, answer } = await req.json();
    if (!inquiryId || !answer || typeof answer !== 'string' || answer.trim().length === 0) {
      return NextResponse.json({ error: "Inquiry ID and answer content are required" }, { status: 400 });
    }

    const inquiryToUpdate = await prisma.suggestionInquiry.findUnique({
        where: { id: inquiryId },
    });

    if (!inquiryToUpdate) {
        return NextResponse.json({ error: "Inquiry not found." }, { status: 404 });
    }

    if (inquiryToUpdate.toUserId !== userId && userRole !== UserRole.ADMIN) {
        return NextResponse.json({ error: "Forbidden: You are not the recipient of this inquiry." }, { status: 403 });
    }

    const updatedInquiry = await prisma.$transaction(async (tx) => {
      const inquiry = await tx.suggestionInquiry.update({
        where: { id: inquiryId },
        data: {
          answer,
          status: InquiryStatus.ANSWERED,
          answeredAt: new Date(),
        },
      });

      await tx.matchSuggestion.update({
        where: { id: params.id },
        data: { lastActivity: new Date() },
      });

      return inquiry;
    });
    
    // TODO: Add notification to the user who asked the question

    return NextResponse.json({ success: true, inquiry: updatedInquiry });
  } catch (error) {
     if (error instanceof Error) {
      if (error.message === "Unauthorized") return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      if (error.message === "Forbidden") return NextResponse.json({ error: "Forbidden" }, { status: 403 });
      if (error.message === "Suggestion not found") return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    console.error("Error answering inquiry:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries\mark-as-read
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\inquiries\mark-as-read\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/inquiries/mark-as-read/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function POST(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const params = await props.params;
    const suggestionId = params.id;
    const userId = session.user.id;

    const updateResult = await prisma.suggestionInquiry.updateMany({
      where: {
        suggestionId: suggestionId,
        toUserId: userId,
        status: 'PENDING',
      },
      data: {
        status: 'ANSWERED', // A simplification: assumes viewing = handling.
      },
    });

    return NextResponse.json({ success: true, count: updateResult.count });

  } catch (error) {
    console.error("Error marking inquiries as read:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\status
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\[id]\status\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/[id]/status/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { MatchSuggestionStatus, UserRole } from "@prisma/client";
import { z } from "zod";

const updateStatusSchema = z.object({
  status: z.nativeEnum(MatchSuggestionStatus),
  notes: z.string().optional(),
});

/**
 * PATCH endpoint for updating suggestion status
 */
export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. Verify permissions
    if (session.user.role !== UserRole.MATCHMAKER && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }

    // 3. Validate request data
    const body = await req.json();
    console.log("Received status update request:", body);
    
    const validationResult = updateStatusSchema.safeParse(body);
    if (!validationResult.success) {
      console.error("Validation error:", validationResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid request data", 
          details: validationResult.error.errors 
        },
        { status: 400 }
      );
    }
    
    const { status, notes } = validationResult.data;

    // 4. Verify suggestion exists
    const params = await props.params;
    const suggestionId = params.id;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: suggestionId },
      include: {
        matchmaker: {
          select: { id: true }
        }
      }
    });

    if (!suggestion) {
      return NextResponse.json(
        { success: false, error: "Suggestion not found" },
        { status: 404 }
      );
    }

    // 5. Verify permission on specific suggestion
    if (suggestion.matchmaker.id !== session.user.id && session.user.role !== UserRole.ADMIN) {
      return NextResponse.json(
        { success: false, error: "You don't have permission to update this suggestion" },
        { status: 403 }
      );
    }

    // 6. Calculate category based on new status
    const getCategory = (status: MatchSuggestionStatus) => {
      switch (status) {
        case "DRAFT":
        case "AWAITING_MATCHMAKER_APPROVAL":
        case "PENDING_FIRST_PARTY":
        case "PENDING_SECOND_PARTY":
          return "PENDING";
        
        case "FIRST_PARTY_DECLINED":
        case "SECOND_PARTY_DECLINED":
        case "MATCH_DECLINED":
        case "ENDED_AFTER_FIRST_DATE":
        case "ENGAGED":
        case "MARRIED":
        case "EXPIRED":
        case "CLOSED":
        case "CANCELLED":
          return "HISTORY";
        
        default:
          return "ACTIVE";
      }
    };

    // 7. Update status in a transaction
    const result = await prisma.$transaction(async (tx) => {
      // Save previous status
      const previousStatus = suggestion.status;

      // Update the suggestion
      const updatedSuggestion = await tx.matchSuggestion.update({
        where: { id: suggestionId },
        data: {
          status: status,
          previousStatus: previousStatus,
          lastStatusChange: new Date(),
          lastActivity: new Date(),
          category: getCategory(status),
          
          // Update additional fields based on new status
          ...(status === MatchSuggestionStatus.CLOSED ? { closedAt: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_FIRST_PARTY ? { firstPartySent: new Date() } : {}),
          ...(status === MatchSuggestionStatus.PENDING_SECOND_PARTY ? { secondPartySent: new Date() } : {}),
        },
      });

      // Add status history record
      await tx.suggestionStatusHistory.create({
        data: {
          suggestionId,
          status,
          notes: notes || `×¡×˜×˜×•×¡ ×©×•× ×” ×œ-${status} ×¢×œ ×™×“×™ ${session.user.firstName} ${session.user.lastName}`,
        },
      });

      return updatedSuggestion;
    });

    // 8. Return success response
    return NextResponse.json({
      success: true,
      message: "Status updated successfully",
      suggestion: {
        id: result.id,
        status: result.status,
        previousStatus: result.previousStatus,
        lastStatusChange: result.lastStatusChange,
        category: result.category,
      },
    });

  } catch (error) {
    console.error("Error updating suggestion status:", error);
    
    // Return detailed error message if available
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to update status", 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint for fetching suggestion history
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse URL parameters
    const params = await props.params;
    const searchParams = new URL(req.url).searchParams;
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 50;

    // 3. Check viewing permissions
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        matchmakerId: true,
        firstPartyId: true,
        secondPartyId: true,
      }
    });
    
    if (!suggestion) {
      return NextResponse.json({ error: "Suggestion not found" }, { status: 404 });
    }
    
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return NextResponse.json({ error: "Not authorized to view this suggestion" }, { status: 403 });
    }
    
    // 4. Build history query
    const historyQuery = {
      where: {
        suggestionId: params.id,
        ...(startDate && {
          createdAt: {
            gte: new Date(startDate),
            ...(endDate && {
              lte: new Date(endDate),
            }),
          },
        }),
      },
      include: {
        suggestion: {
          select: {
            firstParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            secondParty: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            matchmaker: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc" as const,
      },
      take: limit,
    };

    // 5. Fetch status change history
    const history = await prisma.suggestionStatusHistory.findMany(historyQuery);

    // 6. Format results
    const formattedHistory = history.map(entry => ({
      id: entry.id,
      status: entry.status,
      notes: entry.notes,
      createdAt: entry.createdAt,
      actors: {
        firstParty: {
          id: entry.suggestion.firstParty.id,
          name: `${entry.suggestion.firstParty.firstName} ${entry.suggestion.firstParty.lastName}`,
        },
        secondParty: {
          id: entry.suggestion.secondParty.id,
          name: `${entry.suggestion.secondParty.firstName} ${entry.suggestion.secondParty.lastName}`,
        },
        matchmaker: {
          id: entry.suggestion.matchmaker.id,
          name: `${entry.suggestion.matchmaker.firstName} ${entry.suggestion.matchmaker.lastName}`,
        },
      },
    }));

    return NextResponse.json({
      history: formattedHistory,
      suggestion: {
        id: suggestion.id,
        currentStatus: suggestion.status,
        lastStatusChange: suggestion.lastStatusChange?.toISOString() ?? null,
      },
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    
    return NextResponse.json(
      { error: "Failed to fetch history", details: errorMessage },
      { status: 500 }
    );
  }
}

/**
 * HEAD endpoint for getting status summary
 */
export async function HEAD(
  req: NextRequest,
  props: { params: Promise<{ id: string }> }
) {
  try {
    // 1. User authentication
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return new Response(null, { status: 401 });
    }

    // 2. Fetch suggestion details
    const params = await props.params;
    const suggestion = await prisma.matchSuggestion.findUnique({
      where: { id: params.id },
      select: {
        id: true,
        status: true,
        lastStatusChange: true,
        firstPartyId: true,
        secondPartyId: true,
        matchmakerId: true,
      }
    });

    if (!suggestion) {
      return new Response(null, { status: 404 });
    }

    // 3. Check viewing permissions
    const canView = 
      session.user.role === UserRole.ADMIN ||
      suggestion.matchmakerId === session.user.id ||
      suggestion.firstPartyId === session.user.id ||
      suggestion.secondPartyId === session.user.id;
      
    if (!canView) {
      return new Response(null, { status: 403 });
    }

    // 4. Prepare headers
    const headers: Record<string, string> = {
      'X-Suggestion-Status': suggestion.status,
      'X-First-Party': suggestion.firstPartyId,
      'X-Second-Party': suggestion.secondPartyId,
    };

    // Add lastStatusChange header only if it exists
    if (suggestion.lastStatusChange) {
      headers['X-Last-Status-Change'] = suggestion.lastStatusChange.toISOString();
    }

    return new Response(null, { headers });

  } catch (error) {
    console.error("Error fetching suggestion status:", error);
    return new Response(null, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\active
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\active\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/active/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { formatAnswers, KEY_MAPPING, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { ExtendedMatchSuggestion, PartyInfo, QuestionnaireResponse } from "@/components/suggestions/types";
import type {  WorldId } from "@/types/next-auth";
export const dynamic = 'force-dynamic';
// --- ×˜×™×¤×•×¡×™× ×—×–×§×™× ×•××“×•×™×§×™× ×œ×ª×”×œ×™×š ×”×¢×™×‘×•×“ ---
type ProcessedQuestionnaireResponse = Omit<QuestionnaireResponse, 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers'> & {
  formattedAnswers: FormattedAnswersType;
};

type ProcessedPartyInfo = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: ProcessedQuestionnaireResponse[];
};

type SuggestionWithFormattedData = Omit<ExtendedMatchSuggestion, 'firstParty' | 'secondParty'> & {
  firstParty: ProcessedPartyInfo;
  secondParty: ProcessedPartyInfo;
};

// ×”×˜×™×¤×•×¡ ×©××’×™×¢ ×-Prisma. ×©×™××• ×œ×‘ ×©-questionnaireResponses ×”×•× ××”×¡×•×’ ×”×’×•×œ××™.
type PartyInfoFromPrisma = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: QuestionnaireResponse[];
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const activeSuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: session.user.id, status: { in: ["PENDING_FIRST_PARTY", "FIRST_PARTY_APPROVED", "PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] } },
          { secondPartyId: session.user.id, status: { in: ["PENDING_SECOND_PARTY", "SECOND_PARTY_APPROVED", "CONTACT_DETAILS_SHARED"] } },
        ],
      },
      include: {
        statusHistory: { orderBy: { createdAt: 'desc' } },
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
        secondParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // --- ×¢×™×‘×•×“ × ×ª×•× ×™× ×¢× ×˜×™×¤×•×¡×™× ×—×–×§×™× (×œ×œ× any) ---
    const suggestionsWithFormattedQuestionnaires: SuggestionWithFormattedData[] = activeSuggestions.map((suggestion) => {
        
        // ×”×¤×•× ×§×¦×™×” ×”×–×• ××§×‘×œ×ª ××ª ×”×˜×™×¤×•×¡ ×”×’×•×œ××™ ××¤×¨×™×–××” ×•××—×–×™×¨×” ××ª ×”×˜×™×¤×•×¡ ×”××¢×•×‘×“
        const formatPartyQuestionnaire = (party: PartyInfoFromPrisma): ProcessedPartyInfo => {
            const { questionnaireResponses, ...restOfParty } = party;

            if (questionnaireResponses && questionnaireResponses.length > 0) {
                const qr = questionnaireResponses[0];
                const formattedAnswers: Partial<FormattedAnswersType> = {};

                (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
                    const dbKey = KEY_MAPPING[worldKey];
                    // ×’×™×©×” ×‘×˜×•×—×” ×™×•×ª×¨ ×œ×©×“×” ×“×™× ××™
                    const answersJson = qr[dbKey];
                    formattedAnswers[worldKey] = formatAnswers(answersJson);
                });
                
                // ×”×¡×¨×ª ×”×©×“×•×ª ×”×’×•×œ××™×™× ×•×™×¦×™×¨×ª ×”××•×‘×™×™×§×˜ ×”××¢×•×‘×“
                const { valuesAnswers, personalityAnswers, relationshipAnswers, partnerAnswers, religionAnswers, ...restOfQr } = qr;
                const processedQr: ProcessedQuestionnaireResponse = {
                    ...restOfQr,
                    formattedAnswers: formattedAnswers as FormattedAnswersType,
                };
                
                return { ...restOfParty, questionnaireResponses: [processedQr] };
            }
            // ×× ××™×Ÿ ×©××œ×•×Ÿ, ××—×–×™×¨×™× ××ª ×©××¨ ×”××™×“×¢ ×¢×œ ×”××©×ª××©
            return restOfParty;
        };

        return {
            ...suggestion,
            firstParty: formatPartyQuestionnaire(suggestion.firstParty),
            secondParty: formatPartyQuestionnaire(suggestion.secondParty),
        };
    });

    return NextResponse.json({
      success: true,
      suggestions: suggestionsWithFormattedQuestionnaires,
    });
    
  } catch (error) {
    console.error("Error fetching active suggestions:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\history
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\suggestions\history\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/suggestions/history/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { formatAnswers, KEY_MAPPING, FormattedAnswersType } from '@/lib/questionnaireFormatter';
import type { ExtendedMatchSuggestion, PartyInfo, QuestionnaireResponse, WorldId } from "@/components/suggestions/types";
export const dynamic = 'force-dynamic';
// --- ×˜×™×¤×•×¡×™× ×—×–×§×™× ×•××“×•×™×§×™× ×œ×ª×”×œ×™×š ×”×¢×™×‘×•×“ ---
type ProcessedQuestionnaireResponse = Omit<QuestionnaireResponse, 'valuesAnswers' | 'personalityAnswers' | 'relationshipAnswers' | 'partnerAnswers' | 'religionAnswers'> & {
  formattedAnswers: FormattedAnswersType;
};

type ProcessedPartyInfo = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: ProcessedQuestionnaireResponse[];
};

type SuggestionWithFormattedData = Omit<ExtendedMatchSuggestion, 'firstParty' | 'secondParty'> & {
  firstParty: ProcessedPartyInfo;
  secondParty: ProcessedPartyInfo;
};

// ×”×˜×™×¤×•×¡ ×©××’×™×¢ ×-Prisma.
type PartyInfoFromPrisma = Omit<PartyInfo, 'questionnaireResponses'> & {
  questionnaireResponses?: QuestionnaireResponse[];
};

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const historySuggestions = await prisma.matchSuggestion.findMany({
      where: {
        OR: [
          { firstPartyId: session.user.id, status: { in: ["FIRST_PARTY_DECLINED", "SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] } },
          { secondPartyId: session.user.id, status: { in: ["SECOND_PARTY_DECLINED", "MATCH_DECLINED", "CLOSED", "CANCELLED", "MARRIED", "ENGAGED"] } },
        ],
      },
      include: {
        statusHistory: { orderBy: { createdAt: 'desc' } },
        matchmaker: { select: { firstName: true, lastName: true } },
        firstParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
        secondParty: {
          include: { profile: true, images: true, questionnaireResponses: { orderBy: { createdAt: 'desc' }, take: 1 } },
        },
      },
      orderBy: { updatedAt: "desc" },
    });

    const suggestionsWithFormattedQuestionnaires: SuggestionWithFormattedData[] = historySuggestions.map(suggestion => {
        const formatPartyQuestionnaire = (party: PartyInfoFromPrisma): ProcessedPartyInfo => {
            const { questionnaireResponses, ...restOfParty } = party;

            if (questionnaireResponses && questionnaireResponses.length > 0) {
                const qr = questionnaireResponses[0];
                const formattedAnswers: Partial<FormattedAnswersType> = {};

                (Object.keys(KEY_MAPPING) as WorldId[]).forEach(worldKey => {
                    const dbKey = KEY_MAPPING[worldKey];
                    const answersJson = qr[dbKey];
                    formattedAnswers[worldKey] = formatAnswers(answersJson);
                });
                
                const { valuesAnswers, personalityAnswers, relationshipAnswers, partnerAnswers, religionAnswers, ...restOfQr } = qr;
                const processedQr: ProcessedQuestionnaireResponse = {
                    ...restOfQr,
                    formattedAnswers: formattedAnswers as FormattedAnswersType,
                };
                
                return { ...restOfParty, questionnaireResponses: [processedQr] };
            }
            return restOfParty;
        };

        return {
            ...suggestion,
            firstParty: formatPartyQuestionnaire(suggestion.firstParty),
            secondParty: formatPartyQuestionnaire(suggestion.secondParty),
        };
    });

    return NextResponse.json({
      success: true,
      suggestions: suggestionsWithFormattedQuestionnaires,
    });

  } catch (error) {
    console.error("Error fetching suggestion history:", error);
    const errorMessage = error instanceof Error ? error.message : "Internal server error";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\test
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\test\check-update-detection
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\test\check-update-detection\route.ts
--------------------------------------------------------------------------------
Content:
// ×§×•×‘×¥: /src/app/api/test/check-update-detection/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // ×¢×“×›×Ÿ ××©×”×• ×‘×¤×¨×•×¤×™×œ
  await prisma.profile.update({
    where: { userId: session.user.id },
    data: { matchingNotes: `Test update at ${new Date().toISOString()}` }
  });

  // ×‘×“×•×§ ××” ×”-updatedAt ×©×œ User
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { updatedAt: true }
  });

  // ×‘×“×•×§ ××” ×”-updatedAt ×©×œ Profile
  const profile = await prisma.profile.findUnique({
    where: { userId: session.user.id },
    select: { updatedAt: true }
  });

  return NextResponse.json({
    success: true,
    message: 'Updated profile',
    userUpdatedAt: user?.updatedAt,
    profileUpdatedAt: profile?.updatedAt,
    timeDiff: user?.updatedAt && profile?.updatedAt 
      ? Math.abs(user.updatedAt.getTime() - profile.updatedAt.getTime()) 
      : null
  });
}

--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';


/**
 * POST - Creates a new testimonial from a one-time use token.
 * This is used by the public testimonial submission form.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    // 'token' is now the random hex string from the URL, not a JWT
    const { token, authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    // Basic validation
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json({ success: false, error: 'Missing required fields.' }, { status: 400 });
    }

    // Use a transaction to ensure both operations (create testimonial, update token) succeed or fail together.
    const result = await prisma.$transaction(async (tx) => {
      // 1. Find the token request. It MUST be valid and PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() },
        },
      });

      // If no valid request is found, throw an error to abort the transaction.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // 2. Create the actual testimonial record.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // Always pending user's approval
          submittedBy: 'FRIEND', // Set the source based on your schema enum
        },
      });

      // 3. IMPORTANT: Mark the token as COMPLETED so it cannot be used again.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    if (result.success) {
      return NextResponse.json({ success: true, message: 'Thank you! Your testimonial has been submitted.' });
    } else {
       // This part should not be reached if the transaction logic is correct
       throw new Error("Transaction failed unexpectedly.");
    }

  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);
    if (error instanceof Error && error.message.includes('Invalid, expired, or already used link')) {
      return NextResponse.json({ success: false, message: 'This link is invalid, has expired, or has already been used.' }, { status: 400 });
    }
    return NextResponse.json({ success: false, error: 'An internal server error occurred.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
# Generated on: 2025-09-28 20:34:58
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// The GET function remains unchanged...
export async function GET(req: NextRequest) {
  // ... existing GET implementation ...
}


/**
 * POST - Creates a new testimonial from a one-time use token.
 * This is used by the public testimonial submission form.
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    // 'token' is now the random hex string from the URL, not a JWT
    const { token, authorName, relationship, content, authorPhone, isPhoneVisibleToMatch } = body;

    // Basic validation
    if (!token || !authorName || !relationship || !content) {
      return NextResponse.json({ success: false, error: 'Missing required fields.' }, { status: 400 });
    }

    // Use a transaction to ensure both operations (create testimonial, update token) succeed or fail together.
    const result = await prisma.$transaction(async (tx) => {
      // 1. Find the token request. It MUST be valid and PENDING.
      const request = await tx.testimonialRequest.findUnique({
        where: {
          token: token,
          status: 'PENDING',
          expiresAt: { gt: new Date() },
        },
      });

      // If no valid request is found, throw an error to abort the transaction.
      if (!request) {
        throw new Error('Invalid, expired, or already used link.');
      }

      // 2. Create the actual testimonial record.
      const testimonial = await tx.friendTestimonial.create({
        data: {
          profileId: request.profileId,
          authorName,
          relationship,
          content,
          authorPhone: authorPhone || null,
          isPhoneVisibleToMatch: isPhoneVisibleToMatch || false,
          status: 'PENDING', // Always pending user's approval
          submittedBy: 'FRIEND', // Set the source based on your schema enum
        },
      });

      // 3. IMPORTANT: Mark the token as COMPLETED so it cannot be used again.
      await tx.testimonialRequest.update({
        where: { id: request.id },
        data: { status: 'COMPLETED' },
      });

      return { success: true, testimonial };
    });

    if (result.success) {
      return NextResponse.json({ success: true, message: 'Thank you! Your testimonial has been submitted.' });
    } else {
       // This part should not be reached if the transaction logic is correct
       throw new Error("Transaction failed unexpectedly.");
    }

  } catch (error) {
    console.error('Error in POST /api/profile/testimonials:', error);
    if (error instanceof Error && error.message.includes('Invalid, expired, or already used link')) {
      return NextResponse.json({ success: false, message: 'This link is invalid, has expired, or has already been used.' }, { status: 400 });
    }
    return NextResponse.json({ success: false, error: 'An internal server error occurred.' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\testimonials_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/profile/testimonials/[testimonialId]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

// PUT - Update a testimonial's status
export async function PUT(req: Request, { params }: { params: { testimonialId: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const { status } = await req.json() as { status: TestimonialStatus };
    if (!Object.values(TestimonialStatus).includes(status)) {
      return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
    }

    const updatedTestimonial = await prisma.friendTestimonial.updateMany({
      where: {
        id: params.testimonialId,
        profileId: userProfile.id, // Ensure ownership
      },
      data: { status },
    });

    if (updatedTestimonial.count === 0) {
      return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial status updated.' });
  } catch (error) {
    console.error("Error in PUT /api/profile/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}

// DELETE a testimonial
export async function DELETE(req: Request, { params }: { params: { testimonialId: string } }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: userProfile.id, // Ensure ownership
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial deleted.' });
  } catch (error) {
    console.error("Error in DELETE /api/profile/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

--- End of Content for testimonials_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\testimonials\[testimonialId]\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/testimonials/[testimonialId]/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { TestimonialStatus } from '@prisma/client';

export async function PUT(req: Request, props: { params: Promise<{ testimonialId: string }> }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const { status } = await req.json() as { status: TestimonialStatus };
    if (!Object.values(TestimonialStatus).includes(status)) {
      return NextResponse.json({ success: false, message: 'Invalid status provided' }, { status: 400 });
    }

    const params = await props.params;
    const updatedTestimonial = await prisma.friendTestimonial.updateMany({
      where: {
        id: params.testimonialId,
        profileId: userProfile.id,
      },
      data: { status },
    });

    if (updatedTestimonial.count === 0) {
      return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to edit it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial status updated.' });
  } catch (error) {
    console.error("Error in PUT /api/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}

export async function DELETE(req: Request, props: { params: Promise<{ testimonialId: string }> }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }

    const userProfile = await prisma.profile.findUnique({
        where: { userId: session.user.id },
        select: { id: true }
    });

    if (!userProfile) {
        return NextResponse.json({ success: false, message: 'Profile not found for current user' }, { status: 404 });
    }

    const params = await props.params;
    const deletedTestimonial = await prisma.friendTestimonial.deleteMany({
        where: {
            id: params.testimonialId,
            profileId: userProfile.id,
        },
    });

    if (deletedTestimonial.count === 0) {
        return NextResponse.json({ success: false, message: 'Testimonial not found or you do not have permission to delete it' }, { status: 404 });
    }

    return NextResponse.json({ success: true, message: 'Testimonial deleted.' });
  } catch (error) {
    console.error("Error in DELETE /api/testimonials/[id]:", error);
    return NextResponse.json({ success: false, message: "Internal Server Error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\user_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user
# Generated on: 2025-11-20 13:39:53
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\user_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/accept-terms/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from "@/lib/prisma";

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const userId = session.user.id;

    // × ×¡×” ×œ×§×¨×•× ××ª ×”×’×•×£ ×œ××§×¨×” ×©× ×©×œ×—×• ×’× ×”×¡×›××•×ª ×©×™×•×•×§×™×•×ª
    let body = {};
    try {
      body = await req.json();
    } catch (e) {
      // ×”×’×•×£ ×¨×™×§, ×–×” ×‘×¡×“×¨
    }
    
    const { engagementEmailsConsent, promotionalEmailsConsent } = body as any;

    // ×‘×“×•×§ ××¦×‘ ×§×™×™×
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { termsAndPrivacyAcceptedAt: true },
    });

    // ×”×›×Ÿ ××•×‘×™×™×§×˜ ×œ×¢×“×›×•×Ÿ
    const updateData: any = {};

    // ×¢×“×›×Ÿ ×ª××¨×™×š ×¨×§ ×× ×˜×¨× ××•×©×¨
    if (!user?.termsAndPrivacyAcceptedAt) {
      updateData.termsAndPrivacyAcceptedAt = new Date();
    }

    // ×¢×“×›×Ÿ ×”×¡×›××•×ª ×©×™×•×•×§×™×•×ª ×× × ×©×œ×—×• ×‘×‘×§×©×” (×’× ×× ×”××©×ª××© ×›×‘×¨ ××™×©×¨ ×ª× ××™× ×‘×¢×‘×¨)
    if (typeof engagementEmailsConsent === 'boolean') {
      updateData.engagementEmailsConsent = engagementEmailsConsent;
    }
    if (typeof promotionalEmailsConsent === 'boolean') {
      updateData.promotionalEmailsConsent = promotionalEmailsConsent;
    }

    // ×‘×¦×¢ ×¢×“×›×•×Ÿ ×¨×§ ×× ×™×© ××” ×œ×¢×“×›×Ÿ
    if (Object.keys(updateData).length > 0) {
      await prisma.user.update({
        where: { id: userId },
        data: updateData,
      });
      return NextResponse.json({ success: true, message: 'User terms/consents updated' });
    } else {
      return NextResponse.json({ success: true, message: 'No changes needed' });
    }

  } catch (error) {
    console.error('Error accepting terms:', error);
    return NextResponse.json({ error: 'Internal Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\complete-onboarding
================================================================================

(This directory is empty.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\consent-settings
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\consent-settings\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/consent-settings/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';

// ×¡×›××ª ×•×œ×™×“×¦×™×” ×§×¤×“× ×™×ª ×œ×‘×§×©×”
const updateConsentSchema = z.object({
  consentType: z.enum(['engagement', 'promotional'], {
    required_error: "Consent type is required ('engagement' or 'promotional').",
  }),
  consentValue: z.boolean({
    required_error: 'Consent value (true/false) is required.',
  }),
});

export async function PUT(req: Request) {
  try {
    // 1. ××™××•×ª ×”××©×ª××©
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. ×§×¨×™××” ×•×•×œ×™×“×¦×™×” ×©×œ ×’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const validationResult = updateConsentSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: 'Invalid input', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }
    
    const { consentType, consentValue } = validationResult.data;

    // 3. ×”×›× ×ª ×”× ×ª×•× ×™× ×œ×¢×“×›×•×Ÿ
    let dataToUpdate = {};
    if (consentType === 'engagement') {
      dataToUpdate = { engagementEmailsConsent: consentValue };
    } else { // consentType === 'promotional'
      dataToUpdate = { promotionalEmailsConsent: consentValue };
    }

    // 4. ×¢×“×›×•×Ÿ ××¡×“ ×”× ×ª×•× ×™×
    await prisma.user.update({
      where: { id: userId },
      data: dataToUpdate,
    });

    // 5. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×”
    return NextResponse.json({ success: true, message: 'Consent preferences updated successfully.' });

  } catch (error) {
    console.error('Error updating consent settings:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json(
      { success: false, error: "Internal server error.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\marketing-consent
================================================================================

(This directory is empty.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\settings
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\settings\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/settings/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Language } from '@prisma/client';

// ×¡×›××ª ×•×œ×™×“×¦×™×” ×§×¤×“× ×™×ª ×œ×•×•×“× ×©×¨×§ ×¢×¨×›×™× ××•×ª×¨×™× ××ª×§×‘×œ×™×
const updateSettingsSchema = z.object({
  language: z.nativeEnum(Language, {
    errorMap: () => ({ message: "×¢×¨×š ×”×©×¤×” ×—×™×™×‘ ×œ×”×™×•×ª 'he' ××• 'en'." }),
  }),
});

export async function PUT(req: Request) {
  try {
    // 1. ××™××•×ª ×”××©×ª××© ×”××—×•×‘×¨
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.error('[API Settings] Unauthorized access attempt');
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. ×§×¨×™××” ×•××™××•×ª ×©×œ ×’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    console.log('[API Settings] Received language update request:', body);
    
    const validationResult = updateSettingsSchema.safeParse(body);

    if (!validationResult.success) {
      console.error('[API Settings] Validation failed:', validationResult.error.flatten());
      return NextResponse.json(
        { success: false, error: 'Invalid input', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }
    
    const { language } = validationResult.data;
    console.log('[API Settings] Updating language to:', language, 'for user:', userId);

    // 3. ×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××©×ª××© ×‘××¡×“ ×”× ×ª×•× ×™×
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        language: language,
      },
      select: {
        id: true,
        language: true,
        email: true,
      }
    });

    console.log('[API Settings] âœ… Language updated successfully in DB:', {
      userId: updatedUser.id,
      email: updatedUser.email,
      newLanguage: updatedUser.language
    });

    // 4. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×”
    return NextResponse.json({ 
      success: true, 
      message: 'Language updated successfully.',
      language: updatedUser.language // âœ… ××—×–×™×¨ ××ª ×”×©×¤×” ×”××¢×•×“×›× ×ª (×œ×“×™×‘×•×’)
    });

  } catch (error) {
    console.error('[API Settings] âŒ Error updating user settings:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json(
      { success: false, error: "Internal server error.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\unsubscribe
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\unsubscribe\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/unsubscribe/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { jwtVerify, JWTPayload } from 'jose';
import prisma from '@/lib/prisma';

interface UnsubscribeTokenPayload extends JWTPayload {
  userId: string;
  email: string;
}

export async function POST(req: NextRequest) {
  try {
    const { token } = await req.json();

    if (!token) {
      return NextResponse.json({ success: false, error: 'Token is required.' }, { status: 400 });
    }

    const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
    if (!secret) {
      console.error("FATAL: NEXTAUTH_SECRET is not defined.");
      throw new Error("Server configuration error.");
    }

    const { payload } = await jwtVerify(token, secret);
    const { userId, email } = payload as UnsubscribeTokenPayload;

    if (!userId || !email) {
      throw new Error("Invalid token payload.");
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, email: true }
    });

    if (!user || user.email !== email) {
      throw new Error("User not found or token mismatch.");
    }

    // This is the core action: update the consent fields
    await prisma.user.update({
      where: { id: userId },
      data: {
        engagementEmailsConsent: false, // Set to false
        // We can also set promotional to false as a safety measure
        promotionalEmailsConsent: false, 
      },
    });
    
    console.log(`[Unsubscribe] User ${userId} (${email}) has successfully unsubscribed from engagement mailings.`);

    return NextResponse.json({ success: true, message: 'Successfully unsubscribed.' });

  } catch (error) {
    console.error('Error during unsubscribe process:', error);
    let errorMessage = 'The unsubscribe link is invalid or has expired.';
    
    if (error instanceof Error) {
        if (error.name === 'JWTExpired') {
            errorMessage = 'This unsubscribe link has expired. Please use the link from a more recent email.';
        } else if (error.message.includes('User not found')) {
            errorMessage = 'The user associated with this link could not be found.';
        }
    }
    
    return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
  }
}
--- End of Content for route.ts ---

--- End of Content for user_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\accept-terms\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/accept-terms/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from "@/lib/prisma";

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user || !session.user.id) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const userId = session.user.id;

    // × ×¡×” ×œ×§×¨×•× ××ª ×”×’×•×£ ×œ××§×¨×” ×©× ×©×œ×—×• ×’× ×”×¡×›××•×ª ×©×™×•×•×§×™×•×ª
    let body = {};
    try {
      body = await req.json();
    } catch (e) {
      // ×”×’×•×£ ×¨×™×§, ×–×” ×‘×¡×“×¨
    }
    
    const { engagementEmailsConsent, promotionalEmailsConsent } = body as any;

    // ×‘×“×•×§ ××¦×‘ ×§×™×™×
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { termsAndPrivacyAcceptedAt: true },
    });

    // --- ×”×ª×™×§×•×Ÿ: ×‘×“×™×§×” ×©×”××©×ª××© ×§×™×™× ---
    if (!user) {
      console.error(`[accept-terms] User ID ${userId} from session not found in database.`);
      return NextResponse.json({ error: 'User not found in database' }, { status: 404 });
    }
    // ----------------------------------

    // ×”×›×Ÿ ××•×‘×™×™×§×˜ ×œ×¢×“×›×•×Ÿ
    const updateData: any = {};

    // ×¢×“×›×Ÿ ×ª××¨×™×š ×¨×§ ×× ×˜×¨× ××•×©×¨
    if (!user.termsAndPrivacyAcceptedAt) {
      updateData.termsAndPrivacyAcceptedAt = new Date();
    }

    // ×¢×“×›×Ÿ ×”×¡×›××•×ª ×©×™×•×•×§×™×•×ª ×× × ×©×œ×—×• ×‘×‘×§×©×” (×’× ×× ×”××©×ª××© ×›×‘×¨ ××™×©×¨ ×ª× ××™× ×‘×¢×‘×¨)
    if (typeof engagementEmailsConsent === 'boolean') {
      updateData.engagementEmailsConsent = engagementEmailsConsent;
    }
    if (typeof promotionalEmailsConsent === 'boolean') {
      updateData.promotionalEmailsConsent = promotionalEmailsConsent;
    }

    // ×‘×¦×¢ ×¢×“×›×•×Ÿ ×¨×§ ×× ×™×© ××” ×œ×¢×“×›×Ÿ
    if (Object.keys(updateData).length > 0) {
      await prisma.user.update({
        where: { id: userId },
        data: updateData,
      });
      return NextResponse.json({ success: true, message: 'User terms/consents updated' });
    } else {
      return NextResponse.json({ success: true, message: 'No changes needed' });
    }

  } catch (error) {
    console.error('Error accepting terms:', error);
    return NextResponse.json({ error: 'Internal Error' }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\complete-onboarding
================================================================================

(This directory is empty.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\consent-settings
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\consent-settings\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/consent-settings/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';

// ×¡×›××ª ×•×œ×™×“×¦×™×” ×§×¤×“× ×™×ª ×œ×‘×§×©×”
const updateConsentSchema = z.object({
  consentType: z.enum(['engagement', 'promotional'], {
    required_error: "Consent type is required ('engagement' or 'promotional').",
  }),
  consentValue: z.boolean({
    required_error: 'Consent value (true/false) is required.',
  }),
});

export async function PUT(req: Request) {
  try {
    // 1. ××™××•×ª ×”××©×ª××©
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. ×§×¨×™××” ×•×•×œ×™×“×¦×™×” ×©×œ ×’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    const validationResult = updateConsentSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { success: false, error: 'Invalid input', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }
    
    const { consentType, consentValue } = validationResult.data;

    // 3. ×”×›× ×ª ×”× ×ª×•× ×™× ×œ×¢×“×›×•×Ÿ
    let dataToUpdate = {};
    if (consentType === 'engagement') {
      dataToUpdate = { engagementEmailsConsent: consentValue };
    } else { // consentType === 'promotional'
      dataToUpdate = { promotionalEmailsConsent: consentValue };
    }

    // 4. ×¢×“×›×•×Ÿ ××¡×“ ×”× ×ª×•× ×™×
    await prisma.user.update({
      where: { id: userId },
      data: dataToUpdate,
    });

    // 5. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×”
    return NextResponse.json({ success: true, message: 'Consent preferences updated successfully.' });

  } catch (error) {
    console.error('Error updating consent settings:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json(
      { success: false, error: "Internal server error.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\marketing-consent
================================================================================

(This directory is empty.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\settings
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\settings\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/settings/route.ts

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';
import { Language } from '@prisma/client';

// ×¡×›××ª ×•×œ×™×“×¦×™×” ×§×¤×“× ×™×ª ×œ×•×•×“× ×©×¨×§ ×¢×¨×›×™× ××•×ª×¨×™× ××ª×§×‘×œ×™×
const updateSettingsSchema = z.object({
  language: z.nativeEnum(Language, {
    errorMap: () => ({ message: "×¢×¨×š ×”×©×¤×” ×—×™×™×‘ ×œ×”×™×•×ª 'he' ××• 'en'." }),
  }),
});

export async function PUT(req: Request) {
  try {
    // 1. ××™××•×ª ×”××©×ª××© ×”××—×•×‘×¨
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.error('[API Settings] Unauthorized access attempt');
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }
    const userId = session.user.id;

    // 2. ×§×¨×™××” ×•××™××•×ª ×©×œ ×’×•×£ ×”×‘×§×©×”
    const body = await req.json();
    console.log('[API Settings] Received language update request:', body);
    
    const validationResult = updateSettingsSchema.safeParse(body);

    if (!validationResult.success) {
      console.error('[API Settings] Validation failed:', validationResult.error.flatten());
      return NextResponse.json(
        { success: false, error: 'Invalid input', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }
    
    const { language } = validationResult.data;
    console.log('[API Settings] Updating language to:', language, 'for user:', userId);

    // 3. ×¢×“×›×•×Ÿ ×¨×©×•××ª ×”××©×ª××© ×‘××¡×“ ×”× ×ª×•× ×™×
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        language: language,
      },
      select: {
        id: true,
        language: true,
        email: true,
      }
    });

    console.log('[API Settings] âœ… Language updated successfully in DB:', {
      userId: updatedUser.id,
      email: updatedUser.email,
      newLanguage: updatedUser.language
    });

    // 4. ×”×—×–×¨×ª ×ª×©×•×‘×ª ×”×¦×œ×—×”
    return NextResponse.json({ 
      success: true, 
      message: 'Language updated successfully.',
      language: updatedUser.language // âœ… ××—×–×™×¨ ××ª ×”×©×¤×” ×”××¢×•×“×›× ×ª (×œ×“×™×‘×•×’)
    });

  } catch (error) {
    console.error('[API Settings] âŒ Error updating user settings:', error);
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
    return NextResponse.json(
      { success: false, error: "Internal server error.", details: errorMessage },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\unsubscribe
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\user\unsubscribe\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/user/unsubscribe/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { jwtVerify, JWTPayload } from 'jose';
import prisma from '@/lib/prisma';

interface UnsubscribeTokenPayload extends JWTPayload {
  userId: string;
  email: string;
}

export async function POST(req: NextRequest) {
  try {
    const { token } = await req.json();

    if (!token) {
      return NextResponse.json({ success: false, error: 'Token is required.' }, { status: 400 });
    }

    const secret = new TextEncoder().encode(process.env.NEXTAUTH_SECRET);
    if (!secret) {
      console.error("FATAL: NEXTAUTH_SECRET is not defined.");
      throw new Error("Server configuration error.");
    }

    const { payload } = await jwtVerify(token, secret);
    const { userId, email } = payload as UnsubscribeTokenPayload;

    if (!userId || !email) {
      throw new Error("Invalid token payload.");
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, email: true }
    });

    if (!user || user.email !== email) {
      throw new Error("User not found or token mismatch.");
    }

    // This is the core action: update the consent fields
    await prisma.user.update({
      where: { id: userId },
      data: {
        engagementEmailsConsent: false, // Set to false
        // We can also set promotional to false as a safety measure
        promotionalEmailsConsent: false, 
      },
    });
    
    console.log(`[Unsubscribe] User ${userId} (${email}) has successfully unsubscribed from engagement mailings.`);

    return NextResponse.json({ success: true, message: 'Successfully unsubscribed.' });

  } catch (error) {
    console.error('Error during unsubscribe process:', error);
    let errorMessage = 'The unsubscribe link is invalid or has expired.';
    
    if (error instanceof Error) {
        if (error.name === 'JWTExpired') {
            errorMessage = 'This unsubscribe link has expired. Please use the link from a more recent email.';
        } else if (error.message.includes('User not found')) {
            errorMessage = 'The user associated with this link could not be found.';
        }
    }
    
    return NextResponse.json({ success: false, error: errorMessage }, { status: 400 });
  }
}
--- End of Content for route.ts ---

