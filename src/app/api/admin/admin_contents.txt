################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
# Generated on: 2026-01-27 22:42:04
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\admin_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
# Generated on: 2025-10-27 15:28:42
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\engagement_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
      case 'EVENING_FEEDBACK': {
        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
      case 'AI_SUMMARY': {
        // ğŸ¯ ×–×” ×”×—×œ×§ ×©×ª×§×•×¢!
        console.log('ğŸ§  [Manual Email] Loading AI insights...');
        
        // ×˜×¢×Ÿ AI insights ×¢× timeout × ×•×¡×£
        try {
          // âœ… ×”×•×¡×£ timeout ×¡×¤×¦×™×¤×™ ×œ-AI
          await Promise.race([
            SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('AI insights timeout')), 40000)
            ),
          ]);
          
          console.log('âœ… [Manual Email] AI insights loaded successfully');
        } catch (aiError) {
          console.error('âŒ [Manual Email] AI insights failed:', aiError);
          // ×× AI × ×›×©×œ, × ××©×™×š ×‘×œ×™ AI insights
          console.warn('âš ï¸ [Manual Email] Continuing without AI insights');
        }

        email = await SmartEngagementOrchestrator['getAiSummaryEmail'](profile, dict);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator['getPhotoNudgeEmail'](profile, dict);
        } else {
          email = await SmartEngagementOrchestrator['getQuestionnaireNudgeEmail'](profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator['getAlmostDoneEmail'](profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator['getValueEmail'](profile, dict);
        break;
      }
      case 'ONBOARDING': {
        email = await SmartEngagementOrchestrator['getOnboardingEmail'](profile, dict);
        break;
      }
      default:
        throw new Error('Unsupported email type');
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for engagement_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\eligible-users\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/eligible-users/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { UserRole } from '@prisma/client';

export async function GET(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] GET /api/admin/engagement/eligible-users - Request received.`);

  try {
    // ×©×œ×‘ 1: ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);

    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      const reason = !session?.user?.id ? 'No active session' : `Invalid role: ${session.user.role}`;
      console.warn(`[${timestamp}] Unauthorized access attempt: ${reason}.`);
      return NextResponse.json(
        { success: false, error: 'Forbidden: Administrator access required.' },
        { status: 403 }
      );
    }

    console.log(`[${timestamp}] Access granted for ADMIN user: ${session.user.id}`);

    // ×©×œ×‘ 2: ×©×œ×™×¤×ª ×”× ×ª×•× ×™× ××”-Database
    // ğŸ¯ ×¢×“×›×•×Ÿ: ××—×–×™×¨×™× ××ª ×›×œ ×”××©×ª××©×™× ×”×¤×¢×™×œ×™× (×œ× ×¨×§ ××œ×” ×¢× ×¤×¨×•×¤×™×œ ×œ× ×©×œ×)
    const users = await prisma.user.findMany({
      where: {
        status: 'ACTIVE',
        role: 'CANDIDATE', // ×¨×§ ××•×¢××“×™×, ×œ× ××“××™× ×™×/×©×“×›× ×™×
        // ğŸ¯ ×”×¡×¨× ×• ××ª ×”×ª× ××™ isProfileComplete: false
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        isProfileComplete: true, // ğŸ¯ × ×•×¡×™×£ ××ª ×–×” ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×˜×˜×•×¡
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    console.log(`[${timestamp}] Found ${users.length} eligible users for engagement campaign.`);

    // ×©×œ×‘ 3: ×”×—×–×¨×ª ×ª×’×•×‘×” ××•×¦×œ×—×ª
    return NextResponse.json({ success: true, users: users });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    console.error(`[${timestamp}] Error in /api/admin/engagement/eligible-users:`, error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to fetch eligible users due to an internal server error.',
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-evening\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-evening/route.ts

import { NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * ğŸŒ™ Evening Feedback Campaign Runner
 * 
 * ××¨×™×¥ ×§××¤×™×™×Ÿ ×¢×¨×‘ - ×©×•×œ×— ×¤×™×“×‘×§ ×œ××©×ª××©×™× ×©×”×™×• ×¤×¢×™×œ×™× ×”×™×•×
 * ×¨×§ ××©×ª××© ADMIN ×™×›×•×œ ×œ×”×¨×™×¥ ××ª ×”×§××¤×™×™×Ÿ ×”×–×”
 */
export async function POST() {
  const timestamp = new Date().toISOString();
  
  try {
    // ××™××•×ª ×•×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'ADMIN') {
      console.warn(`[${timestamp}] Unauthorized evening campaign attempt`);
      return NextResponse.json(
        { error: 'Unauthorized - Admin access required' },
        { status: 401 }
      );
    }

    console.log(`[${timestamp}] ğŸŒ™ Manual evening campaign triggered by admin: ${session.user.id}`);
    console.log('========================================');
    console.log('ğŸŒ™ EVENING FEEDBACK CAMPAIGN - MANUAL RUN');
    console.log('========================================');
    
    // ×”×¨×¦×ª ×”×§××¤×™×™×Ÿ
    const results = await SmartEngagementOrchestrator.runEveningCampaign();
    
    console.log('========================================');
    console.log(`âœ… Evening campaign completed successfully`);
    console.log(`ğŸ“Š Results: Processed ${results.processed} users, Sent ${results.sent} emails`);
    console.log('========================================');
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('========================================');
    console.error('âŒ Evening campaign failed!');
    console.error('========================================');
    
    if (error instanceof Error) {
      console.error(`Error: ${error.message}`);
      console.error(error.stack);
    } else {
      console.error('Unknown error:', error);
    }
    
    console.error('========================================');
    
    return NextResponse.json(
      { 
        error: 'Evening campaign failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\run-now\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/run-now/route.ts
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ğŸš€ Manual campaign triggered by admin');
    
    const results = await SmartEngagementOrchestrator.runDailyCampaign();
    
    return NextResponse.json({
      success: true,
      processed: results.processed,
      sent: results.sent
    });

  } catch (error) {
    console.error('Error running campaign:', error);
    return NextResponse.json(
      { error: 'Campaign failed' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\search-users\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q') || '';

    if (query.length < 2) {
      return NextResponse.json({ users: [] });
    }

    // ×—×™×¤×•×© ××©×ª××©×™× ×œ×¤×™ ×©×, ××™××™×™×œ ××• ID
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            status: 'ACTIVE',
            isProfileComplete: false, // ×¨×§ ××©×ª××©×™× ×©×œ× ×”×©×œ×™××• ×¤×¨×•×¤×™×œ
          },
          {
            OR: [
              {
                firstName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                lastName: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: query,
                  mode: 'insensitive',
                },
              },
              {
                id: {
                  contains: query,
                },
              },
            ],
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        profile: {
          select: {
            city: true,
          },
        },
        dripCampaign: {
          select: {
            lastSentType: true,
            updatedAt: true,
          },
        },
      },
      take: 10,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error('Error searching users:', error);
    return NextResponse.json(
      { error: 'Failed to search users' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\send-manual\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { SmartEngagementOrchestrator } from '@/lib/engagement/SmartEngagementOrchestrator';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { getEmailDictionary } from '@/lib/dictionaries';
import { Language, Prisma } from '@prisma/client';
import { EmailDictionary } from '@/types/dictionaries/email';

// âœ… ×”×’×“×¨×ª ××‘× ×” ×”×©××™×œ×ª×” ×œ×©×™××•×© ×—×•×–×¨ ×•×œ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ×“×™× ××™
const userWithEngagementDataInclude = {
  include: {
    profile: true,
    images: true,
    questionnaireResponses: { take: 1, orderBy: { lastSaved: 'desc' } as const },
    dripCampaign: true,
  },
};

// âœ… ×™×¦×™×¨×ª ×˜×™×¤×•×¡ ××“×•×™×§ ×¢×‘×•×¨ ××•×‘×™×™×§×˜ ×”××©×ª××© ×¢×œ ×‘×¡×™×¡ ×”×©××™×œ×ª×”, ×›×“×™ ×œ×× ×•×¢ ×©×™××•×© ×‘-any
type UserWithEngagementData = Prisma.UserGetPayload<typeof userWithEngagementDataInclude>;


// ğŸ¯ ×”×’×“×¨ timeout ×©×œ 55 ×©× ×™×•×ª
export const maxDuration = 55;

// ğŸ¯ ×”×’×“×¨ ××ª ×¡×•×’×™ ×”×ª×©×•×‘×”
interface EmailGenerationResult {
  timeout: false;
  emailType: string;
}

interface TimeoutResult {
  timeout: true;
}

type GenerationResult = EmailGenerationResult | TimeoutResult;

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { userId, emailType } = await request.json();

    console.log('ğŸ“§ [Manual Email] Starting send process...', {
      userId,
      emailType,
    });

    if (!userId || !emailType) {
      return NextResponse.json(
        { error: 'Missing userId or emailType' },
        { status: 400 }
      );
    }

    // ××¦× ××ª ×”××©×ª××©
    const user = await prisma.user.findUnique({
      where: { id: userId },
      ...userWithEngagementDataInclude, // âœ… ×©×™××•×© ×‘×§×‘×•×¢ ×©×”×’×“×¨× ×•
    });

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    if (!user.email) {
      return NextResponse.json(
        { error: 'User has no email address' },
        { status: 400 }
      );
    }

    console.log('ğŸ‘¤ [Manual Email] User found:', {
      name: `${user.firstName} ${user.lastName}`,
      email: user.email,
      language: user.language,
    });

    // ×˜×¢×Ÿ ××ª ××™×œ×•×Ÿ ×”××™×™×œ×™×
    const dict = await getEmailDictionary(user.language as Language);

    // ğŸ”¥ ×”×•×¡×¤×ª ×œ×•×’ ×œ×‘×“×™×§×ª ×ª×•×›×Ÿ ×”××™×œ×•×Ÿ ×©× ×˜×¢×Ÿ ×‘×¤×•×¢×œ
    console.log('DEBUG: Loaded Dictionary Object:', JSON.stringify(dict, null, 2));

    // ğŸ¯ ×¢×˜×•×£ ××ª ×›×œ ×”×ª×”×œ×™×š ×‘-timeout wrapper
    const emailGenerationPromise = generateEmailWithTimeout(
      userId,
      emailType,
      user,
      dict
    );

    const result: GenerationResult = await Promise.race([
      emailGenerationPromise,
      timeoutPromise(50000), // 50 ×©× ×™×•×ª
    ]);

    // ğŸ¯ ×‘×“×™×§×” ×¢× Type Guard
    if (result.timeout) {
      console.error('âŒ [Manual Email] Request timed out after 50 seconds');
      return NextResponse.json(
        {
          error: 'Request timed out',
          details: 'AI processing took too long. Please try again or choose a different email type.',
        },
        { status: 504 }
      );
    }

    console.log('ğŸ‰ [Manual Email] Email sent successfully!');

    return NextResponse.json({
      success: true,
      message: 'Email sent successfully',
      emailType: result.emailType,
      recipient: user.email,
    });

  } catch (error) {
    console.error('âŒ [Manual Email] Error:', error);
    return NextResponse.json(
      {
        error: 'Failed to send email',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×œ×™×¦×™×¨×ª timeout promise
function timeoutPromise(ms: number): Promise<TimeoutResult> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ timeout: true });
    }, ms);
  });
}

// ğŸ¯ ×¤×•× ×§×¦×™×” ×¢×•×–×¨×ª ×©×¢×•×˜×¤×ª ××ª ×›×œ ×ª×”×œ×™×š ×™×¦×™×¨×ª ×”××™×™×œ
async function generateEmailWithTimeout(
  userId: string,
  emailType: string,
  user: UserWithEngagementData, // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
  dict: EmailDictionary        // âœ… ×©×™× ×•×™: ×©×™××•×© ×‘×˜×™×¤×•×¡ ×”××“×•×™×§ ×‘××§×•× any
): Promise<EmailGenerationResult> {
  try {
    // ×‘× ×” ×¤×¨×•×¤×™×œ engagement
    const profile = await SmartEngagementOrchestrator.testBuildUserEngagementProfile(userId);

    console.log('ğŸ“Š [Manual Email] Profile built:', {
      completionPercentage: profile.completionStatus.overall,
      daysInSystem: profile.daysInSystem,
    });

    // ×¦×•×¨ ××™×™×œ ××ª××™×
    let email;
    switch (emailType) {
case 'EVENING_FEEDBACK': {
        // --- ×ª×—×™×œ×ª ×”×ª×™×§×•×Ÿ ---
        console.log('ğŸŒ™ [Manual Email] Evening Feedback requires AI. Loading insights...');
        // ×˜×¢×™× ×ª ×ª×•×‘× ×•×ª ×”-AI ×‘××•×¤×Ÿ ×™×–×•× ×œ×ª×•×š ××•×‘×™×™×§×˜ ×”×¤×¨×•×¤×™×œ
        await SmartEngagementOrchestrator['loadAiInsights'](profile, user.language as Language);
        console.log(`âœ… [Manual Email] AI insights ${profile.aiInsights ? 'loaded' : 'not available'}.`);
        // --- ×¡×•×£ ×”×ª×™×§×•×Ÿ ---

        const dailyActivity = await SmartEngagementOrchestrator.testDetectDailyActivity(userId);
        email = await SmartEngagementOrchestrator.testGetEveningFeedbackEmail(
          profile,
          dailyActivity,
          dict
        );
        break;
      }
            case 'AI_SUMMARY': {
        console.log('ğŸ§  [Manual Email] Generating AI Summary email...');
        email = await SmartEngagementOrchestrator.testGetAiSummaryEmail(profile, dict, user.language as Language);
        break;
      }
      case 'NUDGE': {
        if (!profile.completionStatus.photos.isDone) {
          email = await SmartEngagementOrchestrator.testGetPhotoNudgeEmail(profile, dict);
        } else {
          email = await SmartEngagementOrchestrator.testGetQuestionnaireNudgeEmail(profile, dict);
        }
        break;
      }
      case 'CELEBRATION': {
        email = await SmartEngagementOrchestrator.testGetAlmostDoneEmail(profile, dict);
        break;
      }
      case 'VALUE': {
        email = await SmartEngagementOrchestrator.testGetValueEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_DAY_1': {
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      case 'ONBOARDING_PHOTOS': {
        email = await SmartEngagementOrchestrator.testGetOnboardingPhotosEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_AI_TEASER': {
        console.log('ğŸ§  [Manual Email] Generating Onboarding AI Teaser email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingAiTeaserEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING_QUESTIONNAIRE_WHY': {
        email = await SmartEngagementOrchestrator.testGetOnboardingQuestionnaireWhyEmail(profile, dict);
        break;
      }
      case 'ONBOARDING_VALUE_ADD': {
        console.log('ğŸ’ [Manual Email] Generating Onboarding Value Add email...');
        email = await SmartEngagementOrchestrator.testGetOnboardingValueAddEmail(profile, dict, user.language as Language);
        break;
      }
      case 'ONBOARDING': { // Fallback for old value
        email = await SmartEngagementOrchestrator.testGetOnboardingDay1Email(profile, dict);
        break;
      }
      default:
        throw new Error(`Unsupported email type: ${emailType}`);
    }

    if (!email) {
      throw new Error('Could not generate email for this user state');
    }

    console.log('âœ… [Manual Email] Email generated:', { type: email.type });

    // ×©×œ×—
    await SmartEngagementOrchestrator['sendEmail'](user, email);
    await SmartEngagementOrchestrator['updateCampaignRecord'](userId, emailType);

    return {
      emailType: email.type,
      timeout: false,
    };

  } catch (error) {
    console.error('âŒ [Manual Email] Error in generateEmailWithTimeout:', error);
    throw error;
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\engagement\stats\route.ts
--------------------------------------------------------------------------------
Content:
// src/app/api/admin/engagement/stats/route.ts
// ============================================

import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET() {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×™×•×
    const todayEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: today }
      }
    });

    // ×¡×¤×™×¨×ª ××™×™×œ×™× ×”×©×‘×•×¢
    const weeklyEmails = await prisma.userDripCampaign.count({
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    // ××©×ª××©×™× ×¤×¢×™×œ×™×
    const activeUsers = await prisma.user.count({
      where: {
        status: 'ACTIVE',
        isProfileComplete: false
      }
    });

    // ×”×ª×¤×œ×’×•×ª ×”×©×œ××”
    const allUsers = await prisma.user.findMany({
      where: { status: 'ACTIVE' },
      include: {
        profile: true,
        images: true,
        questionnaireResponses: { take: 1 }
      }
    });

    const completionRanges = {
      '0-25%': 0,
      '26-50%': 0,
      '51-75%': 0,
      '76-90%': 0,
      '91-100%': 0
    };

    allUsers.forEach(user => {
      // ×—×™×©×•×‘ ×¤×©×˜× ×™ ×©×œ ××—×•×– ×”×©×œ××”
      let score = 0;
      if (user.images.length >= 3) score += 20;
      if (user.profile?.profileHeadline) score += 20;
      if (user.profile?.about && user.profile.about.length >= 100) score += 20;
      if (user.questionnaireResponses[0]?.completed) score += 40;
      
      if (score <= 25) completionRanges['0-25%']++;
      else if (score <= 50) completionRanges['26-50%']++;
      else if (score <= 75) completionRanges['51-75%']++;
      else if (score <= 90) completionRanges['76-90%']++;
      else completionRanges['91-100%']++;
    });

    const completionDistribution = [
      { range: '0-25%', count: completionRanges['0-25%'], color: '#ef4444' },
      { range: '26-50%', count: completionRanges['26-50%'], color: '#f59e0b' },
      { range: '51-75%', count: completionRanges['51-75%'], color: '#3b82f6' },
      { range: '76-90%', count: completionRanges['76-90%'], color: '#8b5cf6' },
      { range: '91-100%', count: completionRanges['91-100%'], color: '#10b981' }
    ];

    // ×¤×¢×™×œ×•×ª ××—×¨×•× ×”
    const recentActivity = await prisma.userDripCampaign.findMany({
      take: 10,
      orderBy: { updatedAt: 'desc' },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    });

    const formattedActivity = recentActivity.map(activity => ({
      time: new Date(activity.updatedAt).toLocaleTimeString('he-IL', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      user: `${activity.user.firstName} ${activity.user.lastName}`,
      action: activity.lastSentType || 'UNKNOWN',
      status: 'sent' as const
    }));

    // ×”×ª×¤×œ×’×•×ª ×¡×•×’×™ ××™×™×œ×™×
    const emailTypes = await prisma.userDripCampaign.groupBy({
      by: ['lastSentType'],
      _count: true,
      where: {
        updatedAt: { gte: weekAgo }
      }
    });

    const typeColors: Record<string, string> = {
      'ONBOARDING': '#3b82f6',
      'NUDGE': '#f59e0b',
      'CELEBRATION': '#10b981',
      'INSIGHT': '#8b5cf6',
      'VALUE': '#06b6d4',
      'EVENING_FEEDBACK': '#ec4899',
      'AI_SUMMARY': '#14b8a6'
    };

    const emailTypeBreakdown = emailTypes.map(type => ({
      name: type.lastSentType || 'Unknown',
      value: type._count,
      color: typeColors[type.lastSentType || ''] || '#6b7280'
    }));

    return NextResponse.json({
      todayEmails,
      weeklyEmails,
      activeUsers,
      completionDistribution,
      recentActivity: formattedActivity,
      emailTypeBreakdown
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch stats' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\fill-missing-summaries
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\fill-missing-summaries\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole, Prisma } from "@prisma/client";
import aiService from '@/lib/services/aiService';
import profileAiService from '@/lib/services/profileAiService';

export const maxDuration = 300; 
export const dynamic = 'force-dynamic';

/**
 * ×¤×•× ×§×¦×™×™×ª ×”×¨×§×¢ ×©××‘×¦×¢×ª ××ª ×”×¢×‘×•×“×”
 */
async function runBackfillProcess(usersToUpdate: { id: string, profileId: string }[]) {
  console.log(`ğŸš€ [Backfill AI Summary] Starting background process for ${usersToUpdate.length} users...`);
  
  let successCount = 0;
  let failCount = 0;

  for (const user of usersToUpdate) {
    try {
      // 1. ×™×¦×™×¨×ª ×”×¤×¨×•×¤×™×œ ×”× ×¨×˜×™×‘×™
      const narrative = await profileAiService.generateNarrativeProfile(user.id);
      
      if (!narrative) {
        console.warn(`âš ï¸ [Backfill] Failed to generate narrative for User ID: ${user.id}`);
        failCount++;
        continue;
      }

      // 2. ×©×œ×™×—×” ×œ-AI
      const summaryResult = await aiService.generateProfileSummary(narrative);

      if (!summaryResult) {
        console.warn(`âš ï¸ [Backfill] AI returned null for User ID: ${user.id}`);
        failCount++;
        continue;
      }

      // 3. ×¢×“×›×•×Ÿ ×”×“××˜×”-×‘×™×™×¡ (×¢× ×ª×™×§×•×Ÿ ×”×˜×™×¤×•×¡×™×)
      await prisma.profile.update({
        where: { id: user.profileId },
        data: {
          // ×ª×™×§×•×Ÿ: ×”××¨×” ×›×¤×•×œ×” ×›×“×™ ×œ×¨×¦×•×ª ××ª TypeScript ×•-Prisma
          aiProfileSummary: summaryResult as unknown as Prisma.InputJsonValue
        }
      });

      console.log(`âœ… [Backfill] Updated summary for User ID: ${user.id}`);
      successCount++;

      // ×”×©×”×™×™×” ×œ×× ×™×¢×ª ×—×¡×™××” ××’×•×’×œ
      await new Promise(resolve => setTimeout(resolve, 1000));

    } catch (error) {
      console.error(`âŒ [Backfill] Error processing User ID: ${user.id}`, error);
      failCount++;
    }
  }

  console.log(`\nğŸ [Backfill AI Summary] Process Completed.`);
  console.log(`Total: ${usersToUpdate.length} | Success: ${successCount} | Failed: ${failCount}`);
}

export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 403 });
    }

    console.log(`[Backfill API] Searching for users...`);

    // ×ª×™×§×•×Ÿ ×”×©××™×œ×ª×”: ×‘××§×•× ×œ×”×¡×ª×‘×š ×¢× ×˜×™×¤×•×¡×™ Json ×‘×ª×•×š ×”-Where,
    // × ×©×œ×•×£ ××ª ×”××•×¢××“×™× ×”×¨×œ×•×•× ×˜×™×™× ×•× ×¡× ×Ÿ ×‘×§×•×“ (JS).
    const users = await prisma.user.findMany({
      where: {
        role: 'CANDIDATE',
        isProfileComplete: true,
        profile: {
          isNot: null // ××•×•×“× ×©×™×© ×¤×¨×•×¤×™×œ
        }
      },
      select: {
        id: true,
        profile: {
          select: { 
            id: true,
            aiProfileSummary: true // ×©×•×œ×¤×™× ××ª ×”×©×“×” ×›×“×™ ×œ×‘×“×•×§ ××•×ª×•
          }
        }
      }
    });

    // ×¡×™× ×•×Ÿ ×‘-JS: ×¨×§ ××™ ×©××™×Ÿ ×œ×• aiProfileSummary (××• ×©×”×•× null/×¨×™×§)
    // ×”×˜×™×¤×•×¡×™× ×¤×” ×‘×˜×•×—×™× ×™×•×ª×¨ ×××©×¨ ×‘×©××™×œ×ª×ª Prisma ××•×¨×›×‘×ª
    const targets = users
      .filter(u => !u.profile?.aiProfileSummary) 
      .map(u => ({ 
        id: u.id, 
        profileId: u.profile!.id // ×”-! ×‘×˜×•×— ×›××Ÿ ×›×™ ×¡×™× × ×• ×‘-where ×œ××¢×œ×”
      }));

    if (targets.length === 0) {
      return NextResponse.json({ success: true, message: "âœ… ×›×•×œ× ××¢×•×“×›× ×™×! ×œ× × ××¦××• ××©×ª××©×™× ×œ×¢×“×›×•×Ÿ." });
    }

    // ×”×¤×¢×œ×ª ×”×ª×”×œ×™×š ×‘×¨×§×¢
    runBackfillProcess(targets).catch(err => {
      console.error(`[Backfill API] Critical background error:`, err);
    });

    return NextResponse.json({ 
      success: true, 
      message: `× ××¦××• ${targets.length} ××©×ª××©×™× ×œ×¢×“×›×•×Ÿ. ×”×ª×”×œ×™×š ×”×ª×—×™×œ ×‘×¨×§×¢.` 
    });

  } catch (error) {
    console.error('[Backfill API] Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\profiles_contents.txt
--------------------------------------------------------------------------------
Content:
################################################################################
# Directory Content Map For: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles
# Generated on: 2026-01-27 19:01:34
# Filter: Only content of code files (.bat, .c, .cfg, .conf, .cpp, .cs, .css, .go, .h, .html, .ini, .java, .js, .json, .jsx, .kt, .less, .md, .php, .py, .rb, .rs, .scss, .sh, .sql, .swift, .ts, .tsx, .txt, .xml, .yaml, .yml) is included.
################################################################################

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\profiles_contents.txt
--------------------------------------------------------------------------------
[This is the output log file itself. Content not included.]

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\[profileId]
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\[profileId]\update-metrics
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\[profileId]\update-metrics\route.ts
--------------------------------------------------------------------------------
Content:
// ============================================================
// NeshamaTech - Update Profile Metrics & Vectors API
// src/app/api/admin/profiles/[profileId]/update-metrics/route.ts
// ============================================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { updateProfileVectorsAndMetrics } from '@/lib/services/dualVectorService';

// ×”×’×“×¨×ª ×˜×™×¤×•×¡ ×¢×‘×•×¨ ×”×¤×¨××˜×¨×™× (×ª×•×× Next.js 15)
type RouteContext = {
  params: Promise<{ profileId: string }>;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST - ×¢×“×›×•×Ÿ ××“×“×™× ×•×•×§×˜×•×¨×™× ×œ×¤×¨×•×¤×™×œ ×‘×•×“×“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function POST(
  request: NextRequest,
  context: RouteContext // ×©×™× ×•×™: ×©×™××•×© ×‘-context ×‘××§×•× destructuring ×™×©×™×¨ ×‘×—×ª×™××”
) {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª (×¨×§ ××“××™×Ÿ/×©×“×›×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×©×™× ×•×™: ×—×™×œ×•×¥ ×”×¤×¨××˜×¨×™× ×œ××—×¨ await
    const { profileId } = await context.params;

    // ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×§×™×™×
    const profile = await prisma.profile.findUnique({
      where: { id: profileId },
      select: { id: true, userId: true, gender: true },
    });

    if (!profile) {
      return NextResponse.json(
        { error: 'Profile not found' },
        { status: 404 }
      );
    }

    console.log(`[API] Starting metrics/vectors update for profile: ${profileId}`);
    const startTime = Date.now();

    // ×”×¤×¢×œ×ª ×”×¢×“×›×•×Ÿ
    const result = await updateProfileVectorsAndMetrics(profileId);

    const duration = Date.now() - startTime;

    // ×œ×•×’ ×œ×“×™×‘×•×’
    await prisma.$executeRaw`
      INSERT INTO metrics_calculation_log (
        id, "profileId", "calculatedAt", "calculationType", 
        "inputData", "outputMetrics", "durationMs", "errors"
      ) VALUES (
        ${`log_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`},
        ${profileId},
        NOW(),
        'FULL',
        ${JSON.stringify({ triggeredBy: session.user.email })}::jsonb,
        ${JSON.stringify(result)}::jsonb,
        ${duration},
        ${result.errors.length > 0 ? JSON.stringify(result.errors) : null}::jsonb
      )
    `;

    return NextResponse.json({
      success: result.metricsUpdated && result.vectorsUpdated,
      profileId,
      metricsUpdated: result.metricsUpdated,
      vectorsUpdated: result.vectorsUpdated,
      errors: result.errors,
      durationMs: duration,
    });

  } catch (error) {
    console.error('[API] Update metrics failed:', error);
    return NextResponse.json(
      { error: 'Internal server error', details: String(error) },
      { status: 500 }
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET - ×§×‘×œ×ª ××“×“×™× ×§×™×™××™× ×©×œ ×¤×¨×•×¤×™×œ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET(
  request: NextRequest,
  context: RouteContext // ×©×™× ×•×™: ×©×™××•×© ×‘-context ×‘××§×•× destructuring ×™×©×™×¨
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×©×™× ×•×™: ×—×™×œ×•×¥ ×”×¤×¨××˜×¨×™× ×œ××—×¨ await
    const { profileId } = await context.params;

    // ×©×œ×™×¤×ª ×”××“×“×™×
    const metrics = await prisma.$queryRaw<any[]>`
      SELECT * FROM profile_metrics WHERE "profileId" = ${profileId}
    `;

    // ×©×œ×™×¤×ª ××¦×‘ ×”×•×§×˜×•×¨×™×
    const vectors = await prisma.$queryRaw<any[]>`
      SELECT 
        "profileId",
        "selfVector" IS NOT NULL as "hasSelfVector",
        "seekingVector" IS NOT NULL as "hasSeekingVector",
        "selfVectorUpdatedAt",
        "seekingVectorUpdatedAt",
        "updatedAt"
      FROM profile_vectors 
      WHERE "profileId" = ${profileId}
    `;

    if (!metrics[0]) {
      return NextResponse.json({
        exists: false,
        metrics: null,
        vectors: vectors[0] || null,
      });
    }

    return NextResponse.json({
      exists: true,
      metrics: metrics[0],
      vectors: vectors[0] || null,
    });

  } catch (error) {
    console.error('[API] Get metrics failed:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\batch-update-metrics
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\batch-update-metrics\route.ts
--------------------------------------------------------------------------------
Content:
// ============================================================
// NeshamaTech - Batch Update All Profiles Metrics & Vectors
// src/app/api/admin/profiles/batch-update-metrics/route.ts
// ============================================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { updateProfileVectorsAndMetrics } from '@/lib/services/dualVectorService';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST - ×¢×“×›×•×Ÿ ××“×“×™× ×•×•×§×˜×•×¨×™× ×œ×›×œ ×”×¤×¨×•×¤×™×œ×™×
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function POST(request: NextRequest) {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª (×¨×§ ××“××™×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { error: 'Unauthorized - Admin only' },
        { status: 401 }
      );
    }

    // ×¤×¨××˜×¨×™× ××•×¤×¦×™×•× ×œ×™×™×
    const body = await request.json().catch(() => ({}));
    const {
      limit = 50,           // ×›××” ×¤×¨×•×¤×™×œ×™× ×œ×¢×“×›×Ÿ
      onlyMissing = true,   // ×¨×§ ×›××œ×” ×©×—×¡×¨ ×œ×”× ××“×“×™×
      gender = null,        // ×¡×™× ×•×Ÿ ×œ×¤×™ ××’×“×¨
      forceUpdate = false,  // ×œ×¢×“×›×Ÿ ×’× ××ª ××™ ×©×›×‘×¨ ×™×© ×œ×•
    } = body;

    console.log(`[BatchUpdate] Starting batch update. Limit: ${limit}, OnlyMissing: ${onlyMissing}`);

    // ×©×œ×™×¤×ª ×¤×¨×•×¤×™×œ×™× ×œ×¢×“×›×•×Ÿ
    let query = `
      SELECT p.id, p.gender, p."userId",
             pm.id IS NOT NULL as "hasMetrics",
             pv."selfVector" IS NOT NULL as "hasSelfVector",
             pv."seekingVector" IS NOT NULL as "hasSeekingVector"
      FROM profiles p
      LEFT JOIN profile_metrics pm ON pm."profileId" = p.id
      LEFT JOIN profile_vectors pv ON pv."profileId" = p.id
      WHERE p.status = 'AVAILABLE'
    `;

    if (onlyMissing && !forceUpdate) {
      query += ` AND (pm.id IS NULL OR pv."selfVector" IS NULL OR pv."seekingVector" IS NULL)`;
    }

    if (gender) {
      query += ` AND p.gender = '${gender}'`;
    }

    query += ` ORDER BY p."createdAt" DESC LIMIT ${limit}`;

    const profilesToUpdate = await prisma.$queryRawUnsafe<any[]>(query);

    console.log(`[BatchUpdate] Found ${profilesToUpdate.length} profiles to update`);

    // ×¢×“×›×•×Ÿ ×›×œ ×¤×¨×•×¤×™×œ
    const results: {
      profileId: string;
      success: boolean;
      metricsUpdated: boolean;
      vectorsUpdated: boolean;
      errors: string[];
      durationMs: number;
    }[] = [];

    for (const profile of profilesToUpdate) {
      const startTime = Date.now();
      
      try {
        console.log(`[BatchUpdate] Processing profile: ${profile.id}`);
        
        const result = await updateProfileVectorsAndMetrics(profile.id);
        
        results.push({
          profileId: profile.id,
          success: result.metricsUpdated && result.vectorsUpdated,
          metricsUpdated: result.metricsUpdated,
          vectorsUpdated: result.vectorsUpdated,
          errors: result.errors,
          durationMs: Date.now() - startTime,
        });

        // ×”××ª× ×” ×§×¦×¨×” ×‘×™×Ÿ ×§×¨×™××•×ª (rate limiting)
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        results.push({
          profileId: profile.id,
          success: false,
          metricsUpdated: false,
          vectorsUpdated: false,
          errors: [String(error)],
          durationMs: Date.now() - startTime,
        });
      }
    }

    // ×¡×™×›×•×
    const summary = {
      total: results.length,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      metricsUpdated: results.filter(r => r.metricsUpdated).length,
      vectorsUpdated: results.filter(r => r.vectorsUpdated).length,
      avgDurationMs: Math.round(results.reduce((sum, r) => sum + r.durationMs, 0) / results.length),
    };

    console.log(`[BatchUpdate] Completed. Summary:`, summary);

    return NextResponse.json({
      success: true,
      summary,
      results,
    });

  } catch (error) {
    console.error('[BatchUpdate] Failed:', error);
    return NextResponse.json(
      { error: 'Internal server error', details: String(error) },
      { status: 500 }
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET - ×¡×˜×˜×•×¡ ×©×œ ×”××“×“×™× ×•×”×•×§×˜×•×¨×™× ×‘××¢×¨×›×ª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×¡×˜×˜×™×¡×˜×™×§×•×ª ×›×œ×œ×™×•×ª
    const stats = await prisma.$queryRaw<any[]>`
      SELECT 
        COUNT(DISTINCT p.id) as "totalProfiles",
        COUNT(DISTINCT CASE WHEN p.status = 'AVAILABLE' THEN p.id END) as "availableProfiles",
        COUNT(DISTINCT pm."profileId") as "profilesWithMetrics",
        COUNT(DISTINCT CASE WHEN pv."selfVector" IS NOT NULL THEN pv."profileId" END) as "profilesWithSelfVector",
        COUNT(DISTINCT CASE WHEN pv."seekingVector" IS NOT NULL THEN pv."profileId" END) as "profilesWithSeekingVector",
        COUNT(DISTINCT CASE WHEN pv."selfVector" IS NOT NULL AND pv."seekingVector" IS NOT NULL THEN pv."profileId" END) as "profilesWithBothVectors"
      FROM profiles p
      LEFT JOIN profile_metrics pm ON pm."profileId" = p.id
      LEFT JOIN profile_vectors pv ON pv."profileId" = p.id
    `;

    // ×¤×™×¨×•×˜ ×œ×¤×™ ××’×“×¨
    const byGender = await prisma.$queryRaw<any[]>`
      SELECT 
        p.gender,
        COUNT(p.id) as total,
        COUNT(pm."profileId") as "withMetrics",
        COUNT(CASE WHEN pv."selfVector" IS NOT NULL AND pv."seekingVector" IS NOT NULL THEN 1 END) as "withBothVectors"
      FROM profiles p
      LEFT JOIN profile_metrics pm ON pm."profileId" = p.id
      LEFT JOIN profile_vectors pv ON pv."profileId" = p.id
      WHERE p.status = 'AVAILABLE'
      GROUP BY p.gender
    `;

    // ×××•×¦×¢ confidence
    const avgConfidence = await prisma.$queryRaw<any[]>`
      SELECT 
        AVG("confidenceScore") as "avgConfidence",
        AVG("dataCompleteness") as "avgDataCompleteness"
      FROM profile_metrics
    `;

    // ×¤×¨×•×¤×™×œ×™× ×©×¦×¨×™×›×™× ×¢×“×›×•×Ÿ
    const needsUpdate = await prisma.$queryRaw<any[]>`
      SELECT COUNT(*) as count
      FROM profiles p
      LEFT JOIN profile_metrics pm ON pm."profileId" = p.id
      LEFT JOIN profile_vectors pv ON pv."profileId" = p.id
      WHERE p.status = 'AVAILABLE'
        AND (pm.id IS NULL OR pv."selfVector" IS NULL OR pv."seekingVector" IS NULL)
    `;

    return NextResponse.json({
      overall: stats[0],
      byGender,
      avgMetrics: avgConfidence[0],
      needsUpdate: Number(needsUpdate[0]?.count || 0),
    });

  } catch (error) {
    console.error('[BatchUpdate] Stats failed:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\scan
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\scan\[userId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\scan\[userId]\route.ts
--------------------------------------------------------------------------------
Content:
// ============================================================
// NeshamaTech - Scan Single User API V2 (FIXED)
// src/app/api/admin/scan/[userId]/route.ts
// ============================================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { scanSingleUserV2, saveScanResults, ScanOptions } from '@/lib/services/scanSingleUserV2';
import { Gender } from '@prisma/client';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST - ×”×¤×¢×œ×ª ×¡×¨×™×§×” ×œ×™×•×–×¨ ×‘×•×“×“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function POST(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { userId } = params;

    // ×¤×¨××˜×¨×™× ××”-body
    const body = await request.json().catch(() => ({}));
    const options: ScanOptions = {
      useVectors: body.useVectors ?? true,
      useAIDeepAnalysis: body.useAIDeepAnalysis ?? true,
      maxCandidates: body.maxCandidates ?? 100,
      topForAI: body.topForAI ?? 30,
      forceUpdateMetrics: body.forceUpdateMetrics ?? false,
    };

    console.log(`[API] Starting scan for user: ${userId}`, options);

    // ×”×¤×¢×œ×ª ×”×¡×¨×™×§×”
    const result = await scanSingleUserV2(userId, options);

    // ×©××™×¨×” ×œ-DB (×× ×¨×•×¦×™×)
    const saveToDb = body.saveToDb ?? true;
    if (saveToDb && result.matches.length > 0) {
      await saveScanResults(result);
    }

    // ×¡×™×›×•× ×ª××¦×™×ª×™
    const summary = {
      totalMatches: result.matches.length,
      tier1: result.matches.filter(m => m.tier === 1).length,
      tier2: result.matches.filter(m => m.tier === 2).length,
      tier3: result.matches.filter(m => m.tier === 3).length,
      excellent: result.matches.filter(m => m.recommendation === 'EXCELLENT').length,
      good: result.matches.filter(m => m.recommendation === 'GOOD').length,
      avgScore: result.matches.length > 0
        ? Math.round(result.matches.reduce((sum, m) => sum + m.symmetricScore, 0) / result.matches.length)
        : 0,
    };

    return NextResponse.json({
      success: true,
      userId,
      profileId: result.profileId,
      durationMs: result.durationMs,
      stats: result.stats,
      summary,
      matches: result.matches,
      errors: result.errors,
      warnings: result.warnings,
    });

  } catch (error) {
    console.error('[API] Scan failed:', error);
    return NextResponse.json(
      { error: 'Scan failed', details: String(error) },
      { status: 500 }
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET - ×§×‘×œ×ª ×ª×•×¦××•×ª ×¡×¨×™×§×” ×§×•×“××•×ª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { userId } = params;
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '50');
    const minScore = parseInt(searchParams.get('minScore') || '0');

    // ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ
    const profile = await prisma.profile.findFirst({
      where: { userId },
      select: { id: true, gender: true, lastScannedAt: true },
    });

    if (!profile) {
      return NextResponse.json(
        { error: 'Profile not found' },
        { status: 404 }
      );
    }

    const isMale = profile.gender === Gender.MALE;
    
    // ×©×œ×™×¤×ª ×”×ª×××•×ª ×§×™×™××•×ª
    const matches = await prisma.potentialMatch.findMany({
      where: {
        OR: [
          { maleUserId: userId },
          { femaleUserId: userId },
        ],
        aiScore: { gte: minScore },
        // ×ª×™×§×•×Ÿ: ×©×™××•×© ×‘×¡×˜×˜×•×¡×™× ×”× ×›×•× ×™× ××”-enum
        status: { notIn: ['DISMISSED', 'EXPIRED'] },
      },
      orderBy: { aiScore: 'desc' },
      take: limit,
    });

    // ×©×œ×™×¤×ª ×¤×¨×˜×™ ×”××©×ª××©×™× ×‘× ×¤×¨×“
    const formattedMatches = await Promise.all(matches.map(async (match) => {
      const candidateUserId = isMale ? match.femaleUserId : match.maleUserId;
      
      const candidateUser = await prisma.user.findUnique({
        where: { id: candidateUserId },
        select: {
          firstName: true,
          lastName: true,
          profile: {
            select: { id: true, city: true, birthDate: true }
          }
        }
      });

      const candidateAge = candidateUser?.profile?.birthDate
        ? Math.floor((Date.now() - new Date(candidateUser.profile.birthDate).getTime()) / (1000 * 60 * 60 * 24 * 365.25))
        : null;
      
      return {
        matchId: match.id,
        candidateUserId,
        candidateProfileId: candidateUser?.profile?.id,
        candidateName: candidateUser ? `${candidateUser.firstName} ${candidateUser.lastName}` : 'Unknown',
        candidateCity: candidateUser?.profile?.city,
        candidateAge,
        aiScore: match.aiScore,
        firstPassScore: match.firstPassScore,
        status: match.status,
        shortReasoning: match.shortReasoning,
        scannedAt: match.scannedAt,
      };
    }));

    return NextResponse.json({
      userId,
      profileId: profile.id,
      lastScannedAt: profile.lastScannedAt,
      matchCount: formattedMatches.length,
      matches: formattedMatches,
    });

  } catch (error) {
    console.error('[API] Get matches failed:', error);
    return NextResponse.json(
      { error: 'Failed to get matches', details: String(error) },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

--- End of Content for profiles_contents.txt ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\[profileId]
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\[profileId]\update-metrics
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\[profileId]\update-metrics\route.ts
--------------------------------------------------------------------------------
Content:
// ============================================================
// NeshamaTech - Update Profile Metrics & Vectors API
// src/app/api/admin/profiles/[profileId]/update-metrics/route.ts
// ============================================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { updateProfileVectorsAndMetrics } from '@/lib/services/dualVectorService';

// ×”×’×“×¨×ª ×˜×™×¤×•×¡ ×¢×‘×•×¨ ×”×¤×¨××˜×¨×™× (×ª×•×× Next.js 15)
type RouteContext = {
  params: Promise<{ profileId: string }>;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST - ×¢×“×›×•×Ÿ ××“×“×™× ×•×•×§×˜×•×¨×™× ×œ×¤×¨×•×¤×™×œ ×‘×•×“×“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function POST(
  request: NextRequest,
  context: RouteContext // ×©×™× ×•×™: ×©×™××•×© ×‘-context ×‘××§×•× destructuring ×™×©×™×¨ ×‘×—×ª×™××”
) {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª (×¨×§ ××“××™×Ÿ/×©×“×›×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×©×™× ×•×™: ×—×™×œ×•×¥ ×”×¤×¨××˜×¨×™× ×œ××—×¨ await
    const { profileId } = await context.params;

    // ×•×™×“×•× ×©×”×¤×¨×•×¤×™×œ ×§×™×™×
    const profile = await prisma.profile.findUnique({
      where: { id: profileId },
      select: { id: true, userId: true, gender: true },
    });

    if (!profile) {
      return NextResponse.json(
        { error: 'Profile not found' },
        { status: 404 }
      );
    }

    console.log(`[API] Starting metrics/vectors update for profile: ${profileId}`);
    const startTime = Date.now();

    // ×”×¤×¢×œ×ª ×”×¢×“×›×•×Ÿ
    const result = await updateProfileVectorsAndMetrics(profileId);

    const duration = Date.now() - startTime;

    // ×œ×•×’ ×œ×“×™×‘×•×’
    await prisma.$executeRaw`
      INSERT INTO metrics_calculation_log (
        id, "profileId", "calculatedAt", "calculationType", 
        "inputData", "outputMetrics", "durationMs", "errors"
      ) VALUES (
        ${`log_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`},
        ${profileId},
        NOW(),
        'FULL',
        ${JSON.stringify({ triggeredBy: session.user.email })}::jsonb,
        ${JSON.stringify(result)}::jsonb,
        ${duration},
        ${result.errors.length > 0 ? JSON.stringify(result.errors) : null}::jsonb
      )
    `;

    return NextResponse.json({
      success: result.metricsUpdated && result.vectorsUpdated,
      profileId,
      metricsUpdated: result.metricsUpdated,
      vectorsUpdated: result.vectorsUpdated,
      errors: result.errors,
      durationMs: duration,
    });

  } catch (error) {
    console.error('[API] Update metrics failed:', error);
    return NextResponse.json(
      { error: 'Internal server error', details: String(error) },
      { status: 500 }
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET - ×§×‘×œ×ª ××“×“×™× ×§×™×™××™× ×©×œ ×¤×¨×•×¤×™×œ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET(
  request: NextRequest,
  context: RouteContext // ×©×™× ×•×™: ×©×™××•×© ×‘-context ×‘××§×•× destructuring ×™×©×™×¨
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×©×™× ×•×™: ×—×™×œ×•×¥ ×”×¤×¨××˜×¨×™× ×œ××—×¨ await
    const { profileId } = await context.params;

    // ×©×œ×™×¤×ª ×”××“×“×™×
    const metrics = await prisma.$queryRaw<any[]>`
      SELECT * FROM profile_metrics WHERE "profileId" = ${profileId}
    `;

    // ×©×œ×™×¤×ª ××¦×‘ ×”×•×§×˜×•×¨×™×
    const vectors = await prisma.$queryRaw<any[]>`
      SELECT 
        "profileId",
        "selfVector" IS NOT NULL as "hasSelfVector",
        "seekingVector" IS NOT NULL as "hasSeekingVector",
        "selfVectorUpdatedAt",
        "seekingVectorUpdatedAt",
        "updatedAt"
      FROM profile_vectors 
      WHERE "profileId" = ${profileId}
    `;

    if (!metrics[0]) {
      return NextResponse.json({
        exists: false,
        metrics: null,
        vectors: vectors[0] || null,
      });
    }

    return NextResponse.json({
      exists: true,
      metrics: metrics[0],
      vectors: vectors[0] || null,
    });

  } catch (error) {
    console.error('[API] Get metrics failed:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\batch-update-metrics
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\batch-update-metrics\route.ts
--------------------------------------------------------------------------------
Content:
// ============================================================
// NeshamaTech - Batch Update All Profiles Metrics & Vectors
// src/app/api/admin/profiles/batch-update-metrics/route.ts
// ============================================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { updateProfileVectorsAndMetrics } from '@/lib/services/dualVectorService';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST - ×¢×“×›×•×Ÿ ××“×“×™× ×•×•×§×˜×•×¨×™× ×œ×›×œ ×”×¤×¨×•×¤×™×œ×™×
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function POST(request: NextRequest) {
  try {
    // ×‘×“×™×§×ª ×”×¨×©××•×ª (×¨×§ ××“××™×Ÿ)
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { error: 'Unauthorized - Admin only' },
        { status: 401 }
      );
    }

    // ×¤×¨××˜×¨×™× ××•×¤×¦×™×•× ×œ×™×™×
    const body = await request.json().catch(() => ({}));
    const {
      limit = 50,           // ×›××” ×¤×¨×•×¤×™×œ×™× ×œ×¢×“×›×Ÿ
      onlyMissing = true,   // ×¨×§ ×›××œ×” ×©×—×¡×¨ ×œ×”× ××“×“×™×
      gender = null,        // ×¡×™× ×•×Ÿ ×œ×¤×™ ××’×“×¨
      forceUpdate = false,  // ×œ×¢×“×›×Ÿ ×’× ××ª ××™ ×©×›×‘×¨ ×™×© ×œ×•
    } = body;

    console.log(`[BatchUpdate] Starting batch update. Limit: ${limit}, OnlyMissing: ${onlyMissing}`);

    // ×©×œ×™×¤×ª ×¤×¨×•×¤×™×œ×™× ×œ×¢×“×›×•×Ÿ
// ×‘×§×•×‘×¥ batch-update-metrics/route.ts
    let query = `
      SELECT p.id, p.gender, p."userId",
             pm.id IS NOT NULL as "hasMetrics",
             pv."selfVector" IS NOT NULL as "hasSelfVector",
             pv."seekingVector" IS NOT NULL as "hasSeekingVector"
      FROM "Profile" p  -- ×©×•× ×” ×-profiles
      LEFT JOIN "profile_metrics" pm ON pm."profileId" = p.id
      LEFT JOIN "profile_vectors" pv ON pv."profileId" = p.id
      WHERE p.status = 'AVAILABLE'
    `;

    if (onlyMissing && !forceUpdate) {
      query += ` AND (pm.id IS NULL OR pv."selfVector" IS NULL OR pv."seekingVector" IS NULL)`;
    }

    if (gender) {
      query += ` AND p.gender = '${gender}'`;
    }

    query += ` ORDER BY p."createdAt" DESC LIMIT ${limit}`;

    const profilesToUpdate = await prisma.$queryRawUnsafe<any[]>(query);

    console.log(`[BatchUpdate] Found ${profilesToUpdate.length} profiles to update`);

    // ×¢×“×›×•×Ÿ ×›×œ ×¤×¨×•×¤×™×œ
    const results: {
      profileId: string;
      success: boolean;
      metricsUpdated: boolean;
      vectorsUpdated: boolean;
      errors: string[];
      durationMs: number;
    }[] = [];

    for (const profile of profilesToUpdate) {
      const startTime = Date.now();
      
      try {
        console.log(`[BatchUpdate] Processing profile: ${profile.id}`);
        
        const result = await updateProfileVectorsAndMetrics(profile.id);
        
        results.push({
          profileId: profile.id,
          success: result.metricsUpdated && result.vectorsUpdated,
          metricsUpdated: result.metricsUpdated,
          vectorsUpdated: result.vectorsUpdated,
          errors: result.errors,
          durationMs: Date.now() - startTime,
        });

        // ×”××ª× ×” ×§×¦×¨×” ×‘×™×Ÿ ×§×¨×™××•×ª (rate limiting)
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        results.push({
          profileId: profile.id,
          success: false,
          metricsUpdated: false,
          vectorsUpdated: false,
          errors: [String(error)],
          durationMs: Date.now() - startTime,
        });
      }
    }

    // ×¡×™×›×•×
    const summary = {
      total: results.length,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      metricsUpdated: results.filter(r => r.metricsUpdated).length,
      vectorsUpdated: results.filter(r => r.vectorsUpdated).length,
      avgDurationMs: Math.round(results.reduce((sum, r) => sum + r.durationMs, 0) / results.length),
    };

    console.log(`[BatchUpdate] Completed. Summary:`, summary);

    return NextResponse.json({
      success: true,
      summary,
      results,
    });

  } catch (error) {
    console.error('[BatchUpdate] Failed:', error);
    return NextResponse.json(
      { error: 'Internal server error', details: String(error) },
      { status: 500 }
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET - ×¡×˜×˜×•×¡ ×©×œ ×”××“×“×™× ×•×”×•×§×˜×•×¨×™× ×‘××¢×¨×›×ª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×¡×˜×˜×™×¡×˜×™×§×•×ª ×›×œ×œ×™×•×ª
    const stats = await prisma.$queryRaw<any[]>`
      SELECT 
        COUNT(DISTINCT p.id) as "totalProfiles",
        COUNT(DISTINCT CASE WHEN p.status = 'AVAILABLE' THEN p.id END) as "availableProfiles",
        COUNT(DISTINCT pm."profileId") as "profilesWithMetrics",
        COUNT(DISTINCT CASE WHEN pv."selfVector" IS NOT NULL THEN pv."profileId" END) as "profilesWithSelfVector",
        COUNT(DISTINCT CASE WHEN pv."seekingVector" IS NOT NULL THEN pv."profileId" END) as "profilesWithSeekingVector",
        COUNT(DISTINCT CASE WHEN pv."selfVector" IS NOT NULL AND pv."seekingVector" IS NOT NULL THEN pv."profileId" END) as "profilesWithBothVectors"
      FROM profiles p
      LEFT JOIN profile_metrics pm ON pm."profileId" = p.id
      LEFT JOIN profile_vectors pv ON pv."profileId" = p.id
    `;

    // ×¤×™×¨×•×˜ ×œ×¤×™ ××’×“×¨
    const byGender = await prisma.$queryRaw<any[]>`
      SELECT 
        p.gender,
        COUNT(p.id) as total,
        COUNT(pm."profileId") as "withMetrics",
        COUNT(CASE WHEN pv."selfVector" IS NOT NULL AND pv."seekingVector" IS NOT NULL THEN 1 END) as "withBothVectors"
      FROM profiles p
      LEFT JOIN profile_metrics pm ON pm."profileId" = p.id
      LEFT JOIN profile_vectors pv ON pv."profileId" = p.id
      WHERE p.status = 'AVAILABLE'
      GROUP BY p.gender
    `;

    // ×××•×¦×¢ confidence
    const avgConfidence = await prisma.$queryRaw<any[]>`
      SELECT 
        AVG("confidenceScore") as "avgConfidence",
        AVG("dataCompleteness") as "avgDataCompleteness"
      FROM profile_metrics
    `;

    // ×¤×¨×•×¤×™×œ×™× ×©×¦×¨×™×›×™× ×¢×“×›×•×Ÿ
    const needsUpdate = await prisma.$queryRaw<any[]>`
      SELECT COUNT(*) as count
      FROM profiles p
      LEFT JOIN profile_metrics pm ON pm."profileId" = p.id
      LEFT JOIN profile_vectors pv ON pv."profileId" = p.id
      WHERE p.status = 'AVAILABLE'
        AND (pm.id IS NULL OR pv."selfVector" IS NULL OR pv."seekingVector" IS NULL)
    `;

    return NextResponse.json({
      overall: stats[0],
      byGender,
      avgMetrics: avgConfidence[0],
      needsUpdate: Number(needsUpdate[0]?.count || 0),
    });

  } catch (error) {
    console.error('[BatchUpdate] Stats failed:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\scan
================================================================================

(This directory contains subdirectories but no files directly. See subdirectories below.)

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\scan\[userId]
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\profiles\profiles\scan\[userId]\route.ts
--------------------------------------------------------------------------------
Content:
// ============================================================
// NeshamaTech - Scan Single User API V2 (FIXED)
// src/app/api/admin/profiles/profiles/scan/[userId]/route.ts
// ============================================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { scanSingleUserV2, saveScanResults, ScanOptions } from '@/lib/services/scanSingleUserV2';
import { Gender } from '@prisma/client';

// ×”×’×“×¨×ª ×˜×™×¤×•×¡ ×¢×‘×•×¨ ×”×¤×¨××˜×¨×™× ×©×œ ×”× ×ª×™×‘ (×ª×•×× Next.js 15)
interface RouteContext {
  params: Promise<{ userId: string }>;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST - ×”×¤×¢×œ×ª ×¡×¨×™×§×” ×œ×™×•×–×¨ ×‘×•×“×“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function POST(
  request: NextRequest,
  context: RouteContext
) {
  try {
    // 1. ×—×™×œ×•×¥ ×”×¤×¨××˜×¨×™× ×‘×¦×•×¨×” ××¡×™× ×›×¨×•× ×™×ª (×ª×•×× ×œ×’×¨×¡××•×ª ×—×“×©×•×ª)
    const { userId } = await context.params;

    // ×‘×“×™×§×ª ×”×¨×©××•×ª
    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // ×¤×¨××˜×¨×™× ××”-body
    const body = await request.json().catch(() => ({}));
    const options: ScanOptions = {
      useVectors: body.useVectors ?? true,
      useAIDeepAnalysis: body.useAIDeepAnalysis ?? true,
      maxCandidates: body.maxCandidates ?? 100,
      topForAI: body.topForAI ?? 30,
      forceUpdateMetrics: body.forceUpdateMetrics ?? false,
    };

    console.log(`[API] Starting scan for user: ${userId}`, options);

    // ×”×¤×¢×œ×ª ×”×¡×¨×™×§×”
    const result = await scanSingleUserV2(userId, options);

    // ×©××™×¨×” ×œ-DB (×× ×¨×•×¦×™×)
    const saveToDb = body.saveToDb ?? true;
    if (saveToDb && result.matches.length > 0) {
      await saveScanResults(result);
    }

    // ×¡×™×›×•× ×ª××¦×™×ª×™
    const summary = {
      totalMatches: result.matches.length,
      tier1: result.matches.filter(m => m.tier === 1).length,
      tier2: result.matches.filter(m => m.tier === 2).length,
      tier3: result.matches.filter(m => m.tier === 3).length,
      excellent: result.matches.filter(m => m.recommendation === 'EXCELLENT').length,
      good: result.matches.filter(m => m.recommendation === 'GOOD').length,
      avgScore: result.matches.length > 0
        ? Math.round(result.matches.reduce((sum, m) => sum + m.symmetricScore, 0) / result.matches.length)
        : 0,
    };

    return NextResponse.json({
      success: true,
      userId,
      profileId: result.profileId,
      durationMs: result.durationMs,
      stats: result.stats,
      summary,
      matches: result.matches,
      errors: result.errors,
      warnings: result.warnings,
    });

  } catch (error) {
    console.error('[API] Scan failed:', error);
    return NextResponse.json(
      { error: 'Scan failed', details: String(error) },
      { status: 500 }
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET - ×§×‘×œ×ª ×ª×•×¦××•×ª ×¡×¨×™×§×” ×§×•×“××•×ª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET(
  request: NextRequest,
  context: RouteContext
) {
  try {
    // 1. ×—×™×œ×•×¥ ×”×¤×¨××˜×¨×™× ×‘×¦×•×¨×” ××¡×™× ×›×¨×•× ×™×ª
    const { userId } = await context.params;

    const session = await getServerSession(authOptions);
    if (!session?.user || !['ADMIN', 'MATCHMAKER'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '50');
    const minScore = parseInt(searchParams.get('minScore') || '0');

    // ×©×œ×™×¤×ª ×”×¤×¨×•×¤×™×œ
    const profile = await prisma.profile.findFirst({
      where: { userId },
      select: { id: true, gender: true, lastScannedAt: true },
    });

    if (!profile) {
      return NextResponse.json(
        { error: 'Profile not found' },
        { status: 404 }
      );
    }

    const isMale = profile.gender === Gender.MALE;
    
    // ×©×œ×™×¤×ª ×”×ª×××•×ª ×§×™×™××•×ª
    const matches = await prisma.potentialMatch.findMany({
      where: {
        OR: [
          { maleUserId: userId },
          { femaleUserId: userId },
        ],
        aiScore: { gte: minScore },
        // ×©×™××•×© ×‘×¡×˜×˜×•×¡×™× ×”× ×›×•× ×™× ××”-enum
        status: { notIn: ['DISMISSED', 'EXPIRED'] },
      },
      orderBy: { aiScore: 'desc' },
      take: limit,
    });

    // ×©×œ×™×¤×ª ×¤×¨×˜×™ ×”××©×ª××©×™× ×‘× ×¤×¨×“
    const formattedMatches = await Promise.all(matches.map(async (match) => {
      const candidateUserId = isMale ? match.femaleUserId : match.maleUserId;
      
      const candidateUser = await prisma.user.findUnique({
        where: { id: candidateUserId },
        select: {
          firstName: true,
          lastName: true,
          profile: {
            select: { id: true, city: true, birthDate: true }
          }
        }
      });

      const candidateAge = candidateUser?.profile?.birthDate
        ? Math.floor((Date.now() - new Date(candidateUser.profile.birthDate).getTime()) / (1000 * 60 * 60 * 24 * 365.25))
        : null;
      
      return {
        matchId: match.id,
        candidateUserId,
        candidateProfileId: candidateUser?.profile?.id,
        candidateName: candidateUser ? `${candidateUser.firstName} ${candidateUser.lastName}` : 'Unknown',
        candidateCity: candidateUser?.profile?.city,
        candidateAge,
        aiScore: match.aiScore,
        firstPassScore: match.firstPassScore,
        status: match.status,
        shortReasoning: match.shortReasoning,
        scannedAt: match.scannedAt,
      };
    }));

    return NextResponse.json({
      userId,
      profileId: profile.id,
      lastScannedAt: profile.lastScannedAt,
      matchCount: formattedMatches.length,
      matches: formattedMatches,
    });

  } catch (error) {
    console.error('[API] Get matches failed:', error);
    return NextResponse.json(
      { error: 'Failed to get matches', details: String(error) },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\update-all-metrics
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\update-all-metrics\route.ts
--------------------------------------------------------------------------------
Content:
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { updateProfileVectorsAndMetrics } from '@/lib/services/dualVectorService';
import { extractMetricsFromProfile } from '@/lib/services/metricsExtractionService';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json().catch(() => ({}));
    const limit = body.limit ?? 100;
    const forceUpdate = body.forceUpdate ?? false;

    console.log(`[UpdateAllMetrics] Starting batch update, limit: ${limit}, force: ${forceUpdate}`);

    // ×©×œ×™×¤×ª ×¤×¨×•×¤×™×œ×™× ×©×¦×¨×™×›×™× ×¢×“×›×•×Ÿ
    const profiles = await prisma.profile.findMany({
      where: forceUpdate ? {} : {
        OR: [
          { metrics: null },
          { vector: null },
        ],
      },
      select: { id: true, userId: true },
      take: limit,
    });

    console.log(`[UpdateAllMetrics] Found ${profiles.length} profiles to update`);

    const results = {
      total: profiles.length,
      success: 0,
      failed: 0,
      errors: [] as string[],
    };

    for (const profile of profiles) {
      try {
        // ×¢×“×›×•×Ÿ ××“×“×™×
        await extractMetricsFromProfile(profile.id);
        
        // ×¢×“×›×•×Ÿ ×•×§×˜×•×¨×™×
        await updateProfileVectorsAndMetrics(profile.id);
        
        results.success++;
        
        // Delay ×œ×× ×™×¢×ª ×¢×•××¡ ×¢×œ API
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        results.failed++;
        results.errors.push(`${profile.id}: ${error}`);
      }
    }

    console.log(`[UpdateAllMetrics] Completed: ${results.success} success, ${results.failed} failed`);

    return NextResponse.json({
      success: true,
      results,
    });

  } catch (error) {
    console.error('[UpdateAllMetrics] Failed:', error);
    return NextResponse.json(
      { error: 'Update failed', details: String(error) },
      { status: 500 }
    );
  }
}
--- End of Content for route.ts ---

================================================================================
Directory: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\update-vectors
================================================================================

--------------------------------------------------------------------------------
File: C:\Users\eytan\Desktop\NeshamaTech\shidduch-system\src\app\api\admin\update-vectors\route.ts
--------------------------------------------------------------------------------
Content:
import { NextResponse, NextRequest } from 'next/server';
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { UserRole } from "@prisma/client";
import { updateUserAiProfile } from '@/lib/services/profileAiService';

export const maxDuration = 300; 
export const dynamic = 'force-dynamic';

async function runVectorUpdateProcess(usersToUpdate: { id: string, email: string }[]) {
  console.log(`ğŸš€ [Vector Update] Starting process for ${usersToUpdate.length} users...`);
  
  let successCount = 0;
  let failCount = 0;

  for (const user of usersToUpdate) {
    try {
      console.log(`Processing User: ${user.email} (${user.id})...`);
      
      // ×™×¦×™×¨×ª ×”× ×¨×˜×™×‘, ×©×œ×™×—×” ×œ-AI ×•×©××™×¨×ª ×”×•×•×§×˜×•×¨
      await updateUserAiProfile(user.id);

      console.log(`âœ… [Vector Update] Updated vector for: ${user.email}`);
      successCount++;

      // ×”×©×”×™×™×” ×œ×× ×™×¢×ª ×—×¡×™××”
      await new Promise(resolve => setTimeout(resolve, 1000));

    } catch (error) {
      console.error(`âŒ [Vector Update] Error for: ${user.email}`, error);
      failCount++;
    }
  }

  console.log(`\nğŸ [Vector Update] DONE. Success: ${successCount}, Failed: ${failCount}`);
}

// ×”×œ×•×’×™×§×” ×”××¨×›×–×™×ª (××©×•×ª×¤×ª ×œ-POST ×•×œ-GET)
async function handler(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    // ×‘×“×™×§×ª ××“××™×Ÿ
    if (!session?.user?.id || session.user.role !== UserRole.ADMIN) {
      return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 403 });
    }

    console.log(`[Vector Update API] Fetching active candidates...`);

    const users = await prisma.user.findMany({
      where: {
        role: 'CANDIDATE',
        status: 'ACTIVE', 
        isProfileComplete: true,
        profile: {
          isNot: null
        }
      },
      select: {
        id: true,
        email: true
      }
    });

    if (users.length === 0) {
      return NextResponse.json({ success: true, message: "No active users found to update." });
    }

    // ×”×¨×¦×” ×‘×¨×§×¢ (×œ×œ× await) ×›×“×™ ×©×”×“×¤×“×¤×Ÿ ×œ× ×™×ª×§×¢ ×‘-Timeout
    runVectorUpdateProcess(users).catch(err => {
      console.error(`[Vector Update API] Background error:`, err);
    });

    return NextResponse.json({ 
      success: true, 
      message: `×ª×”×œ×™×š ×”×¢×“×›×•×Ÿ ×”×ª×—×™×œ ×¢×‘×•×¨ ${users.length} ××©×ª××©×™×. ×‘×“×•×§ ××ª ×”-Terminal ×œ×¨××•×ª ××ª ×”×”×ª×§×“××•×ª.` 
    });

  } catch (error) {
    console.error('[Vector Update API] Error:', error);
    return NextResponse.json({ success: false, error: "Internal server error" }, { status: 500 });
  }
}

// ×™×™×¦×•× ×’× ×œ-POST ×•×’× ×œ-GET
export async function POST(req: NextRequest) {
  return handler(req);
}

export async function GET(req: NextRequest) {
  return handler(req);
}
--- End of Content for route.ts ---

